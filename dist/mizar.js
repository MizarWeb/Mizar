(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery'), require('moment'), require('jquery-ui-bundle')) :
  typeof define === 'function' && define.amd ? define(['jquery', 'moment', 'jquery-ui-bundle'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mizar = factory(global.$, global.moment));
}(this, (function ($, Moment) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var $__default = /*#__PURE__*/_interopDefaultLegacy($);
  var Moment__default = /*#__PURE__*/_interopDefaultLegacy(Moment);

  // Current version.
  var VERSION = '1.12.0';

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            Function('return this')() ||
            {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // Modern feature detection.
  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
      supportsDataView = typeof DataView !== 'undefined';

  // All **ECMAScript 5+** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create,
      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

  // Create references to these builtin functions because we override them.
  var _isNaN = isNaN,
      _isFinite = isFinite;

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  // The largest integer that can be represented exactly.
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  }

  // Is a given variable an object?
  function isObject(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

  // Is a given value equal to null?
  function isNull(obj) {
    return obj === null;
  }

  // Is a given variable undefined?
  function isUndefined(obj) {
    return obj === void 0;
  }

  // Is a given value a boolean?
  function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  }

  // Is a given value a DOM element?
  function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
  }

  // Internal function for creating a `toString`-based type tester.
  function tagTester(name) {
    var tag = '[object ' + name + ']';
    return function(obj) {
      return toString.call(obj) === tag;
    };
  }

  var isString = tagTester('String');

  var isNumber = tagTester('Number');

  var isDate = tagTester('Date');

  var isRegExp = tagTester('RegExp');

  var isError = tagTester('Error');

  var isSymbol = tagTester('Symbol');

  var isArrayBuffer = tagTester('ArrayBuffer');

  var isFunction = tagTester('Function');

  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  var isFunction$1 = isFunction;

  var hasObjectTag = tagTester('Object');

  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
  // In IE 11, the most common among them, this problem also applies to
  // `Map`, `WeakMap` and `Set`.
  var hasStringTagBug = (
        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))
      ),
      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

  var isDataView = tagTester('DataView');

  // In IE 10 - Edge 13, we need a different heuristic
  // to determine whether an object is a `DataView`.
  function ie10IsDataView(obj) {
    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
  }

  var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);

  // Is a given value an array?
  // Delegates to ECMA5's native `Array.isArray`.
  var isArray = nativeIsArray || tagTester('Array');

  // Internal function to check whether `key` is an own property name of `obj`.
  function has(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  }

  var isArguments = tagTester('Arguments');

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  (function() {
    if (!isArguments(arguments)) {
      isArguments = function(obj) {
        return has(obj, 'callee');
      };
    }
  }());

  var isArguments$1 = isArguments;

  // Is a given object a finite number?
  function isFinite$1(obj) {
    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
  }

  // Is the given value `NaN`?
  function isNaN$1(obj) {
    return isNumber(obj) && _isNaN(obj);
  }

  // Predicate-generating function. Often useful outside of Underscore.
  function constant(value) {
    return function() {
      return value;
    };
  }

  // Common internal logic for `isArrayLike` and `isBufferLike`.
  function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
      var sizeProperty = getSizeProperty(collection);
      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
    }
  }

  // Internal helper to generate a function to obtain property `key` from `obj`.
  function shallowProperty(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  }

  // Internal helper to obtain the `byteLength` property of an object.
  var getByteLength = shallowProperty('byteLength');

  // Internal helper to determine whether we should spend extensive checks against
  // `ArrayBuffer` et al.
  var isBufferLike = createSizePropertyCheck(getByteLength);

  // Is a given value a typed array?
  var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
  function isTypedArray(obj) {
    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    // Otherwise, fall back on the above regular expression.
    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
  }

  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);

  // Internal helper to obtain the `length` property of an object.
  var getLength = shallowProperty('length');

  // Internal helper to create a simple lookup structure.
  // `collectNonEnumProps` used to depend on `_.contains`, but this led to
  // circular imports. `emulatedSet` is a one-off solution that only works for
  // arrays of strings.
  function emulatedSet(keys) {
    var hash = {};
    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
    return {
      contains: function(key) { return hash[key]; },
      push: function(key) {
        hash[key] = true;
        return keys.push(key);
      }
    };
  }

  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if
  // needed.
  function collectNonEnumProps(obj, keys) {
    keys = emulatedSet(keys);
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !keys.contains(prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  function keys(obj) {
    if (!isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  function isEmpty(obj) {
    if (obj == null) return true;
    // Skip the more expensive `toString`-based type checks if `obj` has no
    // `.length`.
    var length = getLength(obj);
    if (typeof length == 'number' && (
      isArray(obj) || isString(obj) || isArguments$1(obj)
    )) return length === 0;
    return getLength(keys(obj)) === 0;
  }

  // Returns whether an object has a given set of `key:value` pairs.
  function isMatch(object, attrs) {
    var _keys = keys(attrs), length = _keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  }

  // If Underscore is called as a function, it returns a wrapped object that can
  // be used OO-style. This wrapper holds altered versions of all functions added
  // through `_.mixin`. Wrapped objects may be chained.
  function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  }

  _.VERSION = VERSION;

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxies for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // Internal function to wrap or shallow-copy an ArrayBuffer,
  // typed array or DataView to a new view, reusing the buffer.
  function toBufferView(bufferSource) {
    return new Uint8Array(
      bufferSource.buffer || bufferSource,
      bufferSource.byteOffset || 0,
      getByteLength(bufferSource)
    );
  }

  // We use this string twice, so give it a name for minification.
  var tagDataView = '[object DataView]';

  // Internal recursive comparison function for `_.isEqual`.
  function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  }

  // Internal recursive comparison function for `_.isEqual`.
  function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    // Work around a bug in IE 10 - Edge 13.
    if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
      if (!isDataView$1(b)) return false;
      className = tagDataView;
    }
    switch (className) {
      // These types are compared by value.
      case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      case '[object ArrayBuffer]':
      case tagDataView:
        // Coerce to typed array so we can fall through.
        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays && isTypedArray$1(a)) {
        var byteLength = getByteLength(a);
        if (byteLength !== getByteLength(b)) return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
        areArrays = true;
    }
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&
                               isFunction$1(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var _keys = keys(a), key;
      length = _keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = _keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  }

  // Perform a deep comparison to check if two objects are equal.
  function isEqual(a, b) {
    return eq(a, b);
  }

  // Retrieve all the enumerable property names of an object.
  function allKeys(obj) {
    if (!isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }

  // Since the regular `Object.prototype.toString` type tests don't work for
  // some types in IE 11, we use a fingerprinting heuristic instead, based
  // on the methods. It's not great, but it's the best we got.
  // The fingerprint method lists are defined below.
  function ie11fingerprint(methods) {
    var length = getLength(methods);
    return function(obj) {
      if (obj == null) return false;
      // `Map`, `WeakMap` and `Set` have no enumerable keys.
      var keys = allKeys(obj);
      if (getLength(keys)) return false;
      for (var i = 0; i < length; i++) {
        if (!isFunction$1(obj[methods[i]])) return false;
      }
      // If we are testing against `WeakMap`, we need to ensure that
      // `obj` doesn't have a `forEach` method in order to distinguish
      // it from a regular `Map`.
      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
    };
  }

  // In the interest of compact minification, we write
  // each string in the fingerprints only once.
  var forEachName = 'forEach',
      hasName = 'has',
      commonInit = ['clear', 'delete'],
      mapTail = ['get', hasName, 'set'];

  // `Map`, `WeakMap` and `Set` each have slightly different
  // combinations of the above sublists.
  var mapMethods = commonInit.concat(forEachName, mapTail),
      weakMapMethods = commonInit.concat(mapTail),
      setMethods = ['add'].concat(commonInit, forEachName, hasName);

  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

  var isWeakSet = tagTester('WeakSet');

  // Retrieve the values of an object's properties.
  function values(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[_keys[i]];
    }
    return values;
  }

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of `_.object` with one argument.
  function pairs(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [_keys[i], obj[_keys[i]]];
    }
    return pairs;
  }

  // Invert the keys and values of an object. The values must be serializable.
  function invert(obj) {
    var result = {};
    var _keys = keys(obj);
    for (var i = 0, length = _keys.length; i < length; i++) {
      result[obj[_keys[i]]] = _keys[i];
    }
    return result;
  }

  // Return a sorted list of the function names available on the object.
  function functions(obj) {
    var names = [];
    for (var key in obj) {
      if (isFunction$1(obj[key])) names.push(key);
    }
    return names.sort();
  }

  // An internal function for creating assigner functions.
  function createAssigner(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  }

  // Extend a given object with all the properties in passed-in object(s).
  var extend = createAssigner(allKeys);

  // Assigns a given object with all the own properties in the passed-in
  // object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  var extendOwn = createAssigner(keys);

  // Fill in a given object with default properties.
  var defaults = createAssigner(allKeys, true);

  // Create a naked function reference for surrogate-prototype-swapping.
  function ctor() {
    return function(){};
  }

  // An internal function for creating a new object that inherits from another.
  function baseCreate(prototype) {
    if (!isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  }

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  function create(prototype, props) {
    var result = baseCreate(prototype);
    if (props) extendOwn(result, props);
    return result;
  }

  // Create a (shallow-cloned) duplicate of an object.
  function clone(obj) {
    if (!isObject(obj)) return obj;
    return isArray(obj) ? obj.slice() : extend({}, obj);
  }

  // Invokes `interceptor` with the `obj` and then returns `obj`.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
  }

  // Normalize a (deep) property `path` to array.
  // Like `_.iteratee`, this function can be customized.
  function toPath(path) {
    return isArray(path) ? path : [path];
  }
  _.toPath = toPath;

  // Internal wrapper for `_.toPath` to enable minification.
  // Similar to `cb` for `_.iteratee`.
  function toPath$1(path) {
    return _.toPath(path);
  }

  // Internal function to obtain a nested property in `obj` along `path`.
  function deepGet(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  }

  // Get the value of the (deep) property on `path` from `object`.
  // If any property in `path` does not exist or if the value is
  // `undefined`, return `defaultValue` instead.
  // The `path` is normalized through `_.toPath`.
  function get(object, path, defaultValue) {
    var value = deepGet(object, toPath$1(path));
    return isUndefined(value) ? defaultValue : value;
  }

  // Shortcut function for checking if an object has a given property directly on
  // itself (in other words, not on a prototype). Unlike the internal `has`
  // function, this public version can also traverse nested properties.
  function has$1(obj, path) {
    path = toPath$1(path);
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (!has(obj, key)) return false;
      obj = obj[key];
    }
    return !!length;
  }

  // Keep the identity function around for default iteratees.
  function identity(value) {
    return value;
  }

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  function matcher(attrs) {
    attrs = extendOwn({}, attrs);
    return function(obj) {
      return isMatch(obj, attrs);
    };
  }

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indices.
  function property(path) {
    path = toPath$1(path);
    return function(obj) {
      return deepGet(obj, path);
    };
  }

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  }

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `_.identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  function baseIteratee(value, context, argCount) {
    if (value == null) return identity;
    if (isFunction$1(value)) return optimizeCb(value, context, argCount);
    if (isObject(value) && !isArray(value)) return matcher(value);
    return property(value);
  }

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only `argCount` argument.
  function iteratee(value, context) {
    return baseIteratee(value, context, Infinity);
  }
  _.iteratee = iteratee;

  // The function we call internally to generate a callback. It invokes
  // `_.iteratee` if overridden, otherwise `baseIteratee`.
  function cb(value, context, argCount) {
    if (_.iteratee !== iteratee) return _.iteratee(value, context);
    return baseIteratee(value, context, argCount);
  }

  // Returns the results of applying the `iteratee` to each element of `obj`.
  // In contrast to `_.map` it returns an object.
  function mapObject(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var _keys = keys(obj),
        length = _keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = _keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  }

  // Predicate-generating function. Often useful outside of Underscore.
  function noop(){}

  // Generates a function for a given object that returns a given property.
  function propertyOf(obj) {
    if (obj == null) return noop;
    return function(path) {
      return get(obj, path);
    };
  }

  // Run a function **n** times.
  function times(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  }

  // Return a random integer between `min` and `max` (inclusive).
  function random(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  }

  // A (possibly faster) way to get the current timestamp as an integer.
  var now = Date.now || function() {
    return new Date().getTime();
  };

  // Internal helper to generate functions for escaping and unescaping strings
  // to/from HTML interpolation.
  function createEscaper(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  }

  // Internal list of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  // Function for escaping strings to HTML interpolation.
  var _escape = createEscaper(escapeMap);

  // Internal list of HTML entities for unescaping.
  var unescapeMap = invert(escapeMap);

  // Function for unescaping strings from HTML interpolation.
  var _unescape = createEscaper(unescapeMap);

  // By default, Underscore uses ERB-style template delimiters. Change the
  // following template settings to use alternative delimiters.
  var templateSettings = _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  var noMatch = /(.)^/;
  var escapes = {
    "'": "'",
    "\\": "\\",
    "\r": "r",
    "\n": "n",
    " ": "u2028",
    " ": "u2029"
  };
  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
  function escapeChar(match) {
    return "\\" + escapes[match];
  }
  function template(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = defaults({}, settings, _.templateSettings);
    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join("|") + "|$", "g");
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;
      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      return match;
    });
    source += "';\n";
    if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
    var render;
    try {
      render = new Function(settings.variable || "obj", "_", source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    var template = function (data) {
      return render.call(this, data, _);
    };
    var argument = settings.variable || "obj";
    template.source = "function(" + argument + "){\n" + source + "}";
    return template;
  }

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  function result(obj, path, fallback) {
    path = toPath$1(path);
    var length = path.length;
    if (!length) {
      return isFunction$1(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = isFunction$1(prop) ? prop.call(obj) : prop;
    }
    return obj;
  }

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }

  // Start chaining a wrapped Underscore object.
  function chain(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  }

  // Internal function to execute `sourceFunc` bound to `context` with optional
  // `args`. Determines whether to execute a function as a constructor or as a
  // normal function.
  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (isObject(result)) return result;
    return self;
  }

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. `_` acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  var partial = restArguments(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  partial.placeholder = _;

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally).
  var bind = restArguments(function(func, context, args) {
    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Internal helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var isArrayLike = createSizePropertyCheck(getLength);

  // Internal implementation of a recursive `flatten` function.
  function flatten(input, depth, strict, output) {
    output = output || [];
    if (!depth && depth !== 0) {
      depth = Infinity;
    } else if (depth <= 0) {
      return output.concat(input);
    }
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
        // Flatten current level of array or arguments object.
        if (depth > 1) {
          flatten(value, depth - 1, strict, output);
          idx = output.length;
        } else {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  }

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  var bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = bind(obj[key], obj);
    }
    return obj;
  });

  // Memoize an expensive function by storing its results.
  function memoize(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  }

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  var delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  var defer = partial(delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var _now = now();
      if (!previous && options.leading === false) previous = _now;
      var remaining = wait - (_now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = _now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  }

  // When a sequence of calls of the returned function ends, the argument
  // function is triggered. The end of a sequence is defined by the `wait`
  // parameter. If `immediate` is passed, the argument function will be
  // triggered at the beginning of the sequence instead of at the end.
  function debounce(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  }

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  function wrap(func, wrapper) {
    return partial(wrapper, func);
  }

  // Returns a negated version of the passed-in predicate.
  function negate(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  }

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  }

  // Returns a function that will only be executed on and after the Nth call.
  function after(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  // Returns a function that will only be executed up to (but not including) the
  // Nth call.
  function before(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  }

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  var once = partial(before, 2);

  // Returns the first key on an object that passes a truth test.
  function findKey(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = keys(obj), key;
    for (var i = 0, length = _keys.length; i < length; i++) {
      key = _keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  }

  // Internal function to generate `_.findIndex` and `_.findLastIndex`.
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a truth test.
  var findIndex = createPredicateIndexFinder(1);

  // Returns the last index on an array-like that passes a truth test.
  var findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  function sortedIndex(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  }

  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), isNaN$1);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  var indexOf = createIndexFinder(1, findIndex, sortedIndex);

  // Return the position of the last occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  var lastIndexOf = createIndexFinder(-1, findLastIndex);

  // Return the first value which passes a truth test.
  function find(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  }

  // Convenience version of a common use case of `_.find`: getting the first
  // object containing specific `key:value` pairs.
  function findWhere(obj, attrs) {
    return find(obj, matcher(attrs));
  }

  // The cornerstone for collection functions, an `each`
  // implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  function each(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var _keys = keys(obj);
      for (i = 0, length = _keys.length; i < length; i++) {
        iteratee(obj[_keys[i]], _keys[i], obj);
      }
    }
    return obj;
  }

  // Return the results of applying the iteratee to each element.
  function map(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  }

  // Internal helper to create a reducing function, iterating left or right.
  function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var _keys = !isArrayLike(obj) && keys(obj),
          length = (_keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[_keys ? _keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = _keys ? _keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  var reduce = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  var reduceRight = createReduce(-1);

  // Return all the elements that pass a truth test.
  function filter(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  }

  // Return all the elements for which a truth test fails.
  function reject(obj, predicate, context) {
    return filter(obj, negate(cb(predicate)), context);
  }

  // Determine whether all of the elements pass a truth test.
  function every(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  }

  // Determine if at least one element in the object passes a truth test.
  function some(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  }

  // Determine if the array or object contains a given item (using `===`).
  function contains(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return indexOf(obj, item, fromIndex) >= 0;
  }

  // Invoke a method (with arguments) on every item in a collection.
  var invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (isFunction$1(path)) {
      func = path;
    } else {
      path = toPath$1(path);
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `_.map`: fetching a property.
  function pluck(obj, key) {
    return map(obj, property(key));
  }

  // Convenience version of a common use case of `_.filter`: selecting only
  // objects containing specific `key:value` pairs.
  function where(obj, attrs) {
    return filter(obj, matcher(attrs));
  }

  // Return the maximum element (or element-based computation).
  function max(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  }

  // Return the minimum element (or element-based computation).
  function min(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  }

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `_.map`.
  function sample(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = values(obj);
      return obj[random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? clone(obj) : values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  }

  // Shuffle a collection.
  function shuffle(obj) {
    return sample(obj, Infinity);
  }

  // Sort the object's values by a criterion produced by an iteratee.
  function sortBy(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return pluck(map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  }

  // An internal function used for aggregate "group by" operations.
  function group(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  }

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  var groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for
  // when you know that your index values will be unique.
  var indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  var countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  // Split a collection into two arrays: one whose elements all pass the given
  // truth test, and one whose elements all do not pass the truth test.
  var partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Safely create a real, live array from anything iterable.
  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  function toArray(obj) {
    if (!obj) return [];
    if (isArray(obj)) return slice.call(obj);
    if (isString(obj)) {
      // Keep surrogate pair characters together.
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return map(obj, identity);
    return values(obj);
  }

  // Return the number of elements in a collection.
  function size(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : keys(obj).length;
  }

  // Internal `_.pick` helper function to determine whether `key` is an enumerable
  // property name of `obj`.
  function keyInObj(value, key, obj) {
    return key in obj;
  }

  // Return a copy of the object only containing the allowed properties.
  var pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (isFunction$1(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the disallowed properties.
  var omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (isFunction$1(iteratee)) {
      iteratee = negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !contains(keys, key);
      };
    }
    return pick(obj, iteratee, context);
  });

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  function initial(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  }

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. The **guard** check allows it to work with `_.map`.
  function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return initial(array, array.length - n);
  }

  // Returns everything but the first entry of the `array`. Especially useful on
  // the `arguments` object. Passing an **n** will return the rest N values in the
  // `array`.
  function rest(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  }

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return rest(array, Math.max(0, array.length - n));
  }

  // Trim out all falsy values from an array.
  function compact(array) {
    return filter(array, Boolean);
  }

  // Flatten out an array, either recursively (by default), or up to `depth`.
  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
  function flatten$1(array, depth) {
    return flatten(array, depth, false);
  }

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  var difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return filter(array, function(value){
      return !contains(rest, value);
    });
  });

  // Return a version of the array that does not contain the specified value(s).
  var without = restArguments(function(array, otherArrays) {
    return difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  function uniq(array, isSorted, iteratee, context) {
    if (!isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  }

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  var union = restArguments(function(arrays) {
    return uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  function intersection(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  }

  // Complement of zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  function unzip(array) {
    var length = array && max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = pluck(array, index);
    }
    return result;
  }

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  var zip = restArguments(unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.
  function object(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  }

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](https://docs.python.org/library/functions.html#range).
  function range(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  }

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  }

  // Helper function to continue chaining intermediate results.
  function chainResult(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  }

  // Add your own custom functions to the Underscore object.
  function mixin(obj) {
    each(functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  }

  // Add all mutator `Array` functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) {
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) {
          delete obj[0];
        }
      }
      return chainResult(this, obj);
    };
  });

  // Add all accessor `Array` functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) obj = method.apply(obj, arguments);
      return chainResult(this, obj);
    };
  });

  // Named Exports

  var allExports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VERSION: VERSION,
    restArguments: restArguments,
    isObject: isObject,
    isNull: isNull,
    isUndefined: isUndefined,
    isBoolean: isBoolean,
    isElement: isElement,
    isString: isString,
    isNumber: isNumber,
    isDate: isDate,
    isRegExp: isRegExp,
    isError: isError,
    isSymbol: isSymbol,
    isArrayBuffer: isArrayBuffer,
    isDataView: isDataView$1,
    isArray: isArray,
    isFunction: isFunction$1,
    isArguments: isArguments$1,
    isFinite: isFinite$1,
    isNaN: isNaN$1,
    isTypedArray: isTypedArray$1,
    isEmpty: isEmpty,
    isMatch: isMatch,
    isEqual: isEqual,
    isMap: isMap,
    isWeakMap: isWeakMap,
    isSet: isSet,
    isWeakSet: isWeakSet,
    keys: keys,
    allKeys: allKeys,
    values: values,
    pairs: pairs,
    invert: invert,
    functions: functions,
    methods: functions,
    extend: extend,
    extendOwn: extendOwn,
    assign: extendOwn,
    defaults: defaults,
    create: create,
    clone: clone,
    tap: tap,
    get: get,
    has: has$1,
    mapObject: mapObject,
    identity: identity,
    constant: constant,
    noop: noop,
    toPath: toPath,
    property: property,
    propertyOf: propertyOf,
    matcher: matcher,
    matches: matcher,
    times: times,
    random: random,
    now: now,
    escape: _escape,
    unescape: _unescape,
    templateSettings: templateSettings,
    template: template,
    result: result,
    uniqueId: uniqueId,
    chain: chain,
    iteratee: iteratee,
    partial: partial,
    bind: bind,
    bindAll: bindAll,
    memoize: memoize,
    delay: delay,
    defer: defer,
    throttle: throttle,
    debounce: debounce,
    wrap: wrap,
    negate: negate,
    compose: compose,
    after: after,
    before: before,
    once: once,
    findKey: findKey,
    findIndex: findIndex,
    findLastIndex: findLastIndex,
    sortedIndex: sortedIndex,
    indexOf: indexOf,
    lastIndexOf: lastIndexOf,
    find: find,
    detect: find,
    findWhere: findWhere,
    each: each,
    forEach: each,
    map: map,
    collect: map,
    reduce: reduce,
    foldl: reduce,
    inject: reduce,
    reduceRight: reduceRight,
    foldr: reduceRight,
    filter: filter,
    select: filter,
    reject: reject,
    every: every,
    all: every,
    some: some,
    any: some,
    contains: contains,
    includes: contains,
    include: contains,
    invoke: invoke,
    pluck: pluck,
    where: where,
    max: max,
    min: min,
    shuffle: shuffle,
    sample: sample,
    sortBy: sortBy,
    groupBy: groupBy,
    indexBy: indexBy,
    countBy: countBy,
    partition: partition,
    toArray: toArray,
    size: size,
    pick: pick,
    omit: omit,
    first: first,
    head: first,
    take: first,
    initial: initial,
    last: last,
    rest: rest,
    tail: rest,
    drop: rest,
    compact: compact,
    flatten: flatten$1,
    without: without,
    uniq: uniq,
    unique: uniq,
    union: union,
    intersection: intersection,
    difference: difference,
    unzip: unzip,
    transpose: unzip,
    zip: zip,
    object: object,
    range: range,
    chunk: chunk,
    mixin: mixin,
    'default': _
  });

  var _$1 = mixin(allExports);
  _$1._ = _$1;

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var Constants = function () {};
  /**
   * @namespace
   * API
   * @property {string} version - API version
   */


  Constants.API = {
    version: "[VERSION_API]"
  };
  /**
   * @namespace
   * LEVEL
   * @property {string} WARNING - Warning level
   * @property {string} ERROR - Error level
   * @property {string} DEBUG - Error level
   */

  Constants.LEVEL = {
    WARNING: "warning",
    ERROR: "error",
    DEBUG: "debug"
  };
  /**
   * @namespace
   * ANIMATION
   * @property {string} Inertia - Inertia animation
   * @property {string} Interpolated - Interpolated animation
   * @property {string} Path - Path animation
   * @property {string} Segmented - Segmented animation
   */

  Constants.ANIMATION = {
    Inertia: "Inertia",
    Interpolated: "Interpolated",
    Path: "Path",
    Segmented: "Segmented"
  };
  /**
   * @namespace
   * CONTEXT
   * @property {string} Planet - Planet context
   * @property {string} Sky - Sky context
   * @property {string} Ground - Ground context
   */

  Constants.CONTEXT = {
    Planet: "Planet",
    Sky: "Sky",
    Ground: "Ground"
  };
  /**
   * @namespace
   * GLOBE
   * @property {string} Planet - Planet
   * @property {string} Sky - Sky
   */

  Constants.GLOBE = {
    Planet: "Planet",
    Sky: "Sky"
  };
  /**
   * @namespace
   * LAYER
   * @property {string} WMS - Web Map Service
   * @property {string} WMTS - Web Map Tile Service
   * @property {string} WMSElevation - Web Map Service for elevation
   * @property {string} WCSElevation - Web Map Coverage for elevation
   * @property {string} GeoJSON - GeoJSON
   * @property {string} Vector - Vector
   * @property {string} Atmosphere - Atmosphere
   * @property {string} Bing - Microsoft BING
   * @property {string} GroundOverlay - GroundOverlay
   * @property {string} OSM - Open Street Map
   * @property {string} TileWireframe - TileWireframe
   * @property {string} HipsGrid - HipsGrid
   * @property {string} CoordinateGrid - CoordinateGrid
   * @property {string} Hips - Hierarchical Progressive Survey for images
   * @property {string} HipsCat - Hierarchical Progressive Survey for catalogue
   * @property {string} HipsFits - Hierarchical Progressive Survey for FITS
   * @property {string} Moc - Multiple Order Coverage
   * @property {string} OpenSearch - Open Search
   */

  Constants.LAYER = {
    AsynchroneWMS: "AsynchroneWMS",
    WMS: "WMS",
    WMTS: "WMTS",
    WMSElevation: "WMSElevation",
    WCSElevation: "WCSElevation",
    GeoJSON: "GeoJSON",
    Vector: "Vector",
    Atmosphere: "Atmosphere",
    Bing: "Bing",
    GroundOverlay: "GroundOverlay",
    OSM: "OSM",
    TileWireframe: "TileWireframe",
    HipsGrid: "HipsGrid",
    CoordinateGrid: "CoordinateGrid",
    HipsFits: "HipsFits",
    Hips: "Hips",
    HipsCat: "HipsCat",
    Moc: "Moc",
    OpenSearch: "OpenSearch"
  };
  /**
   * @namespace
   * GEOMETRY
   * @property {string} Point - Point
   * @property {string} MultiPoint - MultiPoint
   * @property {string} LineString - LineString
   * @property {string} MultiLineString - MultiLineString
   * @property {string} Polygon - Polygon
   * @property {string} MultiPolygon - MultiPolygon
   * @property {string} GeometryCollection - GeometryCollection
   */

  Constants.GEOMETRY = {
    Point: "Point",
    MultiPoint: "MultiPoint",
    LineString: "LineString",
    MultiLineString: "MultiLineString",
    Polygon: "Polygon",
    MultiPolygon: "MultiPolygon",
    GeometryCollection: "GeometryCollection"
  };
  /**
   * @namespace
   * PROJECTION
   * @property {string} Aitoff - Aitoff projection
   * @property {string} August - August projection
   * @property {string} Mercator - Mercator projection
   * @property {string} Mollweide - Mollweide projection
   * @property {string} Plate - Plate Carrée projection
   * @property {string} Azimuth - Azimuthal projection
   */

  Constants.PROJECTION = {
    Aitoff: "Aitoff",
    August: "August",
    Mercator: "Mercator",
    Mollweide: "Mollweide",
    Plate: "Plate Carrée",
    Azimuth: "Azimuth"
  };
  /**
   * @namespace
   * CRS
   * @property {string} Equatorial - Equatorial coordinate reference system
   * @property {string} Galactic - Galactic coordinate reference system
   * @property {string} WGS84 - CRS:84 coordinate reference system
   * @property {string} Mars_2000 - IAU2000:49901 coordinate reference system
   * @property {string} Mars_2000_old - IAU2000:49900 coordinate reference system
   * @property {string} Moon_2000 - IAU2000:30101 coordinate reference system
   * @property {string} Moon_2000_old - IAU2000:30100 coordinate reference system
   * @property {string} HorizontalLocal - Local reference system based on horizontal coordinates
   * @property {string} Sun - Sun Coordinate reference system
   */

  Constants.CRS = {
    Equatorial: "Equatorial",
    Galactic: "Galactic",
    WGS84: "CRS:84",
    Mars_2000: "IAU2000:49901",
    Mars_2000_old: "IAU2000:49900",
    Moon_2000: "IAU2000:30101",
    Moon_2000_old: "IAU2000:30100",
    HorizontalLocal: "HorizontalLocal",
    Sun: "IAU:Sun"
  };
  /**
   * @namespace
   * CRS_TO_CONTEXT
   * @property {string} Equatorial - Sky context
   * @property {string} Galactic - Sky context
   * @property {string} WGS84 - Planet context
   * @property {string} Mars_2000 - Planet context
   * @property {string} Mars_2000_old - Planet context
   * @property {string} Moon_2000 - Planet context
   * @property {string} Moon_2000_old - Planet context
   * @property {string} HorizontalLocal - Ground context
   * @property {string} Sun - Sun Coordinate reference system
   */

  Constants.CRS_TO_CONTEXT = {
    Equatorial: "Sky",
    Galactic: "Sky",
    "CRS:84": "Planet",
    "IAU2000:49901": "Planet",
    "IAU2000:49900": "Planet",
    "IAU2000:30101": "Planet",
    "IAU2000:30100": "Planet",
    HorizontalLocal: "Ground",
    "IAU:Sun": "Planet"
  };
  /**
   * @namespace
   * NAVIGATION
   * @property {string} AstroNavigation - 3D Navigation for sky
   * @property {string} PlanetNavigation - 3D Navigation for planet
   * @property {string} FlatNavigation - 2D Navigation for planet
   * @property {string} GroundNavigation - 3D Navigation for ground visualization
   */

  Constants.NAVIGATION = {
    AstroNavigation: "AstroNavigation",
    PlanetNavigation: "PlanetNavigation",
    FlatNavigation: "FlatNavigation",
    GroundNavigation: "GroundNavigation"
  };
  /**
   * @namespace
   * SERVICE
   * @property {string} FitsVisu - FITS visualization
   * @property {string} Histogram - Histogram values from a FITS file
   * @property {string} ImageProcessing - Image processing
   * @property {string} MeasureToolSky - Tool to measure the distance between two points on the sky
   * @property {string} MeasureToolPlanet - Tool to measure the distance between two points on a planet
   * @property {string} MocBase - MOC service
   * @property {string} MollweideViewer - Mollweide Viewer
   * @property {string} PickingManager - Picking Manager
   * @property {string} Samp - Samp
   * @property {string} SelectionTool - Selection Tool
   * @property {string} NameResolver - NameResolver
   * @property {string} ReverseNameResolver - ReverseNameResolver
   * @property {string} ExportTool - ExportTool
   */

  Constants.SERVICE = {
    FitsHips: "FitsHips",
    FitsVisu: "FitsVisu",
    Histogram: "Histogram",
    ImageProcessing: "ImageProcessing",
    MeasureToolSky: "MeasureToolSky",
    MeasureToolPlanet: "MeasureToolPlanet",
    MocBase: "MocBase",
    MollweideViewer: "MollweideViewer",
    PickingManager: "PickingManager",
    Samp: "Samp",
    SelectionTool: "SelectionTool",
    NameResolver: "NameResolver",
    ReverseNameResolver: "ReverseNameResolver",
    ExportTool: "ExportTool",
    TimeTravel: "TimeTravel"
  };
  /**
   * @namespace
   * HANDLER
   * @property {string} Touch - Touch device
   * @property {string} Keyboard - Keyboard device
   * @property {string} Mouse - Mouse device
   * @property {string} GoogleMouse - GoogleMouse device
   */

  Constants.HANDLER = {
    Touch: "Touch",
    Keyboard: "Keyboard",
    Mouse: "Mouse",
    GoogleMouse: "GoogleMouse"
  };
  /**
   * @namespace
   * PROVIDER
   * @property {string} Constellation - Constellation
   * @property {string} Json - Json
   * @property {string} Planet - Planet
   * @property {string} Star - Star
   * @property {string} Trajectory - Trajectory
   */

  Constants.PROVIDER = {
    Constellation: "Constellation",
    Planet: "Planet",
    Star: "Star",
    Crater: "Crater",
    Trajectory: "Trajectory"
  };
  /**
   * @namespace
   * MappingCrsHips2Mizar
   * @property {string} equatorial - Equatorial
   * @property {string} galactic - Galactic
   * @property {string} ecliptic - Ecliptic
   * @property {string} horizontalLocal - Equatorial
   */

  Constants.MappingCrsHips2Mizar = {
    equatorial: "Equatorial",
    galactic: "Galactic",
    ecliptic: "Ecliptic",
    "mars-panstimson": "Equatorial",
    horizontalLocal: "Equatorial"
  };
  /**
   * @namespace
   * UTILITY
   * @property {string} Fits - Fits utility
   * @property {string} Intersection - Intersection utility
   * @property {string} CreateStyle - CreateStyle utility
   * @property {string} FeatureStyle - FeatureStyle utility
   * @property {string} Utils - Utils utility
   */

  Constants.UTILITY = {
    Fits: "Fits",
    Intersection: "Intersection",
    Numeric: "Numeric",
    CreateStyle: "CreateStyle",
    FeatureStyle: "FeatureStyle",
    Utils: "Utils"
  };
  /**
   * @namespace
   * ANIMATION_STATUS
   * @property {string} STOPPED - animation is stopped
   * @property {string} RUNNING - animation is running
   * @property {string} PAUSED - animation is paused
   */

  Constants.ANIMATION_STATUS = {
    STOPPED: "STOPPED",
    RUNNING: "RUNNING",
    PAUSED: "PAUSED"
  };
  /**
   * @namespace
   * EVENT_MSG
   * @property {string} PLUGIN_NOT_FOUND - Plugin not found
   * @property {string} MIZAR_MODE_TOGGLE - Mizar mode, one value among {Constants.CONTEXT}
   * @property {string} LAYER_BACKGROUND_ADDED - Background Layer added
   * @property {string} LAYER_BACKGROUND_CHANGED - Background Layer changed
   * @property {string} LAYER_ADDED - Layer added
   * @property {string} LAYER_REMOVED - Layer removed
   * @property {string} LAYER_VISIBILITY_CHANGED - Visibility Layer changed
   * @property {string} LAYER_OPACITY_CHANGED - Opacity Layer changed
   * @property {string} LAYER_START_LOAD - Overlay rasters or vectors start to load
   * @property {string} LAYER_END_LOAD - Overlay rasters  or vectors finish to load
   * @property {string} LAYER_START_BACKGROUND_LOAD - Background rasters start to load
   * @property {string} LAYER_END_BACKGROUND_LOAD - Background rasters finish to load
   * @property {string} BASE_LAYERS_ERROR - Error at the initialisation of layer to render
   * @property {string} BASE_LAYERS_READY - Initialisation of the rendering is fine
   * @property {string} CRS_MODIFIED - Coordinate reference system is modified
   * @property {string} NAVIGATION_STARTED - Navigation started
   * @property {string} NAVIGATION_ENDED - Navigation ended
   * @property {string} NAVIGATION_MODIFIED - Navigation modified
   * @property {string} NAVIGATION_CHANGED_DISTANCE - Distance of the camera from the planet has changed
   * @property {string} IMAGE_DOWNLOADED - Image downloaded
   * @property {string} IMAGE_REMOVED - Image removed
   * @property {string} IMAGE_ADDED - Image added
   * @property {string} FEATURED_ADDED - Feature added
   * @property {string} GLOBAL_TIME_REWIND - global time is rewinded
   * @property {string} GLOBAL_TIME_FORWARD - global time is forwarded
   * @property {string} GLOBAL_TIME_SET - global time is set
   * @property {string} GLOBAL_TIME_CHANGED - global time has changed

   */

  Constants.EVENT_MSG = {
    PLUGIN_NOT_FOUND: "plugin:not_found",
    MIZAR_MODE_TOGGLE: "mizarMode:toggle",
    LAYER_BACKGROUND_ERROR: "backgroundLayer:error",
    LAYER_BACKGROUND_ADDED: "backgroundLayer:added",
    LAYER_BACKGROUND_CHANGED: "backgroundLayer:changed",
    LAYER_ADDED: "layer:added",
    LAYER_REMOVED: "layer:removed",
    LAYER_VISIBILITY_CHANGED: "visibility:changed",
    LAYER_OPACITY_CHANGED: "opacity:changed",
    LAYER_START_LOAD: "startLoad",
    LAYER_END_LOAD: "endLoad",
    LAYER_START_BACKGROUND_LOAD: "startBackgroundLoad",
    LAYER_END_BACKGROUND_LOAD: "endBackgroundLoad",
    LAYER_UPDATE_STATS_ATTRIBUTES: "updateStatsAttribute",
    LAYER_TOGGLE_WMS: "toggleWMS",
    BASE_LAYERS_ERROR: "baseLayersError",
    BASE_LAYERS_READY: "baseLayersReady",
    CRS_MODIFIED: "modifiedCrs",
    NAVIGATION_STARTED: "startNavigation",
    NAVIGATION_ENDED: "endNavigation",
    NAVIGATION_MODIFIED: "modifiedNavigation",
    NAVIGATION_CHANGED_DISTANCE: "navigation:changedDistance",
    IMAGE_DOWNLOADED: "image:downloaded",
    IMAGE_REMOVED: "image:removed",
    IMAGE_ADDED: "image:added",
    FEATURED_ADDED: "features:added",
    GLOBAL_TIME_REWIND: "globalTime:rewind",
    GLOBAL_TIME_FORWARD: "globalTime:forward",
    GLOBAL_TIME_SET: "globalTime:set",
    GLOBAL_TIME_CHANGED: "globalTime:changed" // temporary, need to be link to LAYERS_TIME_CHANGED after dev

  };
  /**
   * @namespace
   * DISPLAY_ORDER
   * @property {string} RENDERING - Special rendering index
   * @property {string} DEFAULT_RASTER - Default layer index (specially images)
   * @property {string} SELECTED_RASTER - Selected layer index (specially images)
   * @property {string} DEFAULT_VECTOR - Default vector index
   * @property {string} SELECTED_VECTOR - Selected vector index
   * @property {string} HIGHLIGHTED_VECTOR - Highlighted vector index
   * @property {string} SERVICE_VECTOR - Service index
   */

  Constants.DISPLAY = {
    RENDERING: -1,
    DEFAULT_RASTER: 0,
    SELECTED_RASTER: 10,
    DEFAULT_VECTOR: 20,
    SELECTED_VECTOR: 30,
    HIGHLIGHTED_VECTOR: 31,
    SERVICE_VECTOR: 40
  };
  /**
   * @namespace
   * INFORMATION_TYPE
   * @property {string} ATMOSPHERE - atmosphere data
   * @property {string} RASTER - raster data
   * @property {string} VECTOR - vector data
   */

  Constants.INFORMATION_TYPE = {
    ATMOSPHERE: "ATMOSPHERE",
    RASTER: "RASTER",
    VECTOR: "VECTOR"
  };
  /**
   * @namespace
   * TIME_STEP
   * @property {string} YEAR - years
   * @property {string} QUARTER - quarters
   * @property {string} MONTH - months
   * @property {string} WEEK - weeks
   * @property {string} DAY - days
   * @property {string} HOUR - hours
   * @property {string} MINUTE - minutes
   * @property {string} SECOND - seconds
   * @property {string} MILLISECOND - milliseconds
   * @property {string} ENUMERATED - null
   */

  Constants.TIME_STEP = {
    YEAR: "years",
    QUARTER: "quarters",
    MONTH: "months",
    WEEK: "weeks",
    DAY: "days",
    HOUR: "hours",
    MINUTE: "minutes",
    SECOND: "seconds",
    MILLISECOND: "milliseconds",
    ENUMERATED: null
  };
  /**
   * @namespace
   * TIME_MOMENT_STEP
   * @property {string} YEAR - year
   * @property {string} MONTH - month
   * @property {string} DAY - day
   * @property {string} HOUR - hour
   * @property {string} MINUTE - minute
   * @property {string} SECOND - second
   */

  Constants.TIME_MOMENT_STEP = {
    YEAR: "year",
    MONTH: "month",
    DAY: "day",
    HOUR: "hour",
    MINUTE: "minute",
    SECOND: "second"
  };
  /**
   * @namespace
   * UNIT_TIME_WMS
   * @property {string} YEAR - Y
   * @property {string} MONTH - M
   * @property {string} DAY - D
   * @property {string} HOUR - H
   * @property {string} MINUTE - M
   * @property {string} SECOND - S
   */

  Constants.UNIT_TIME_WMS = {
    YEAR: "Y",
    MONTH: "M",
    DAY: "D",
    HOUR: "H",
    MINUTE: "M",
    SECONDE: "S"
  };
  /**
   * @namespace
   * UNIT_RESOLUTION_WMS
   * @property {string} TIME - PT
   * @property {string} NOT_TIME - P
   */

  Constants.UNIT_RESOLUTION_WMS = {
    TIME: "PT",
    NOT_TIME: "P"
  };
  /**
   * @namespace
   * TIME
   * @property {string} DEFAULT_FORMAT - Do MMM Y HH:mm
   */

  Constants.TIME = {
    DEFAULT_FORMAT: "Do MMM Y HH:mm"
  };
  /**
   * @namespace
   * TILE
   * @property {string} GEO_TILE - GeoTile
   * @property {string} MERCATOR_TILE - MercatorTile
   * @property {string} HEALPIX_TILE - HealpixTile
   */

  Constants.TILE = {
    GEO_TILE: "GeoTile",
    MERCATOR_TILE: "MercatorTile",
    HEALPIX_TILE: "HealpixTile"
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
   Declare namespace for Numeric functions.
   TODO : Should be put into GlobWeb
   */
  var Numeric = {};
  /**************************************************************************************************************/

  /**
   Linear interpolation between [a, b], t must be [0, 1]
   */

  Numeric.lerp = function (t, a, b) {
    return a + (b - a) * t;
  };
  /**************************************************************************************************************/

  /**
   Cosine interpolation between [a, b], t must be [0, 1]
   */


  Numeric.coserp = function (t, a, b) {
    var t2 = (1 - Math.cos(t * Math.PI)) / 2;
    return a + (b - a) * t2;
  };
  /**************************************************************************************************************/

  /**
   Cubic interpolation between [a, b], t must be [0, 1]
   */


  Numeric.cubicInterpolation = function (t, startPos, startVel, endPos, endVel) {
    var t2 = t * t;
    var t3 = t2 * t; // Evaluate the position

    var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
    var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
    var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];
    var M01 = -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
    var M11 = -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
    var M21 = -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];
    var position = vec3.create();
    position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
    position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
    position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];
    return position;
  };
  /**************************************************************************************************************/

  /**
   Cubic interpolation between [a, b], t must be [0, 1]
   */


  Numeric.cubicInterpolationDerivative = function (t, startPos, startVel, endPos, endVel) {
    var t2 = t * t; // Evaluates the direction

    var M01 = 6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
    var M11 = 6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
    var M21 = 6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];
    var M02 = -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
    var M12 = -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
    var M22 = -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];
    var direction = vec3.create();
    direction[0] = M01 * t2 + M02 * t + startVel[0];
    direction[1] = M11 * t2 + M12 * t + startVel[1];
    direction[2] = M21 * t2 + M22 * t + startVel[2];
    return direction;
  };
  /**************************************************************************************************************/

  /**
   Map x between [xMin, xMax] to [0, 1]
   */


  Numeric.map01 = function (x, xMin, xMax) {
    return xMin !== xMax ? (x - xMin) / (xMax - xMin) : 0;
  };
  /**************************************************************************************************************/

  /*
   Map x between [xMin, xMax] to [outMin, outMax]
   */


  Numeric.mapLinear = function (x, xMin, xMax, outMin, outMax) {
    return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
  };
  /**************************************************************************************************************/


  Numeric.easeInQuad = function (t) {
    return t * t;
  };
  /**************************************************************************************************************/


  Numeric.easeOutQuad = function (t) {
    // use 1-(t^2) with input [-1, 0]
    var v = t - 1; // map [0 1] to [-1 0]

    return 1.0 - v * v;
  };
  /**************************************************************************************************************/

  /**
   Remap input t ([0, 1]) to a curve starting slowly
   and accelerating till 0.5 an decelerating till 1
   */


  Numeric.easeInOutQuad = function (t) {
    var out = t;

    if (out < 0.5) {
      // use (0.5*t^2) with input [0, 1]
      out = out + out; // map [0 0.5] outo [0 1]

      out = 0.5 * (out * out);
    } else {
      // use (0.5*(1-t)^2) with input [-1, 0]
      out = out + out - 2.0; // map [0.5 1] to [-1 0]

      out = 0.5 * (1.0 - out * out);
      out = 0.5 + out;
    }

    return out;
  };
  /**************************************************************************************************************/

  /*
   */


  Numeric.easeOutInQuad = function (t) {
    var out = t;

    if (out < 0.5) {
      // use (0.5*(1-t)^2) with input [-1, 0]
      out = out + out - 1.0; // map [0 0.5] to [-1 0]

      out = 0.5 * (1.0 - out * out);
    } else {
      // use (0.5*t^2) with input [0, 1]
      out = out + out - 1.0; // map [0.5 1] outo [0 1]

      out = 0.5 * (out * out);
      out = 0.5 + out;
    }

    return out;
  };
  /**************************************************************************************************************/

  /**
   Convert the given degree value in radian
   */


  Numeric.toRadian = function (degree) {
    return degree * Math.PI / 180.0;
  };
  /**************************************************************************************************************/

  /**
   Convert the given radian value in degree
   */


  Numeric.toDegree = function (radian) {
    return radian * 180.0 / Math.PI;
  };
  /**************************************************************************************************************/

  /**
   Line-line intersection
   rayDirection must be normalized.
   Returns t at which intersection occurs or -1 if no intersection.
   */


  Numeric.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (det === 0) {
      return [-1, -1];
    }

    var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    ua /= det;
    ub /= det;
    return [ua, ub]; //return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
  };
  /**************************************************************************************************************/

  /**
   *    Round the given number
   *
   *    @param num Number to round
   *    @param dec Number of decimals
   */


  Numeric.roundNumber = function (num, dec) {
    return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
  };
  /**
   * Return the sign of a value
   */


  Numeric.sign = function (v) {
    if (v < 0) return -1;else {
      if (v > 0) return 1;else return 0;
    }
  };

  Numeric.equals = function (a, b) {
    return Math.abs(a - b) < Number.EPSILON;
  };

  Numeric.shortestPath360 = function (startLongitude, endLongitude) {
    var startLongValue, endLongValue;

    if (Math.abs(endLongitude - startLongitude) < 180.0) {
      startLongValue = startLongitude;
      endLongValue = endLongitude;
    } else {
      if (startLongitude < endLongitude) {
        startLongValue = startLongitude + 360;
        endLongValue = endLongitude;
      } else {
        startLongValue = startLongitude;
        endLongValue = endLongitude + 360;
      }
    }

    return [startLongValue, endLongValue];
  };

  Numeric.shortestPath180 = function (startLongitude, endLongitude) {
    var startLongValue, endLongValue;

    if (Math.sign(startLongitude) * Math.sign(endLongitude) > 0 || Numeric.equals(startLongitude, 0) || Numeric.equals(endLongitude, 0)) {
      // 1st case:
      // Nothing to do because :
      // - the two values have the same sign
      // - and max(angle) <= 180 (longitude included in [-180,180]
      // so we have the shortest path
      startLongValue = startLongitude;
      endLongValue = endLongitude;
    } else {
      // we convert everything from [0 to 360]
      var longGeoCenter = (startLongitude + 360) % 360;
      var longGeoPos = (endLongitude + 360) % 360;
      var path = Numeric.shortestPath360(longGeoCenter, longGeoPos);
      startLongValue = path[0];
      endLongValue = path[1];
    }

    return [startLongValue, endLongValue];
  };

  Numeric.normalize2D = function (vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
    dest[0] = vec[0] / length;
    dest[1] = vec[1] / length;
    return dest;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   *    Module with constants
   */

  /**************************************************************************************************************/
  var HealPixTables = {
    ctab: [0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262, 263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283, 1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286, 1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520, 521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526, 527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546, 1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805, 1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816, 2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565, 2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584, 3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335, 3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314, 2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063, 2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082, 3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341, 3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855],
    utab: [0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277, 320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088, 1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301, 1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116, 4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369, 4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136, 5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381, 5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388, 16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469, 16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720, 16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473, 17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684, 17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485, 20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736, 20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817, 20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572, 21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781, 21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845],
    // coordinate of the lowest corner of each face
    jrll: [2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4],
    jpll: [1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7],
    xoffset: [-1, -1, 0, 1, 1, 1, 0, -1],
    yoffset: [0, 1, 1, 1, 0, -1, -1, -1],
    facearray: [[8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9], // S
    [5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8], // SE
    [-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1], // E
    [4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10], // SW
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], // center
    [1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4], // NE
    [-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1], // W
    [3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7], // NW
    [2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]],
    // N
    swaparray: [[0, 0, 3], // S
    [0, 0, 6], // SE
    [0, 0, 0], // E
    [0, 0, 5], // SW
    [0, 0, 0], // center
    [5, 0, 0], // NE
    [0, 0, 0], // W
    [6, 0, 0], // NW
    [3, 0, 0]],
    // N
    swap_cycle: [[], [0, 1, 8, 12, 16, 21, 40], [0, 1, 2, 40, 114], [0, 4, 160, 263], [0, 4, 30, 49, 51, 87, 526, 1027, 1105, 1387, 1807, 2637], [0, 8, 10, 18, 39, 74, 146, 307, 452, 4737], [0, 1, 2, 7, 9, 17, 80, 410, 1526, 1921, 32859, 33566, 38931], [0, 5, 6, 10, 12, 24, 27, 95, 372, 494, 924, 1409, 3492, 4248, 9137, 66043, 103369, 156899], [0, 1, 2, 3, 4, 45, 125, 351, 697, 24337, 102940, 266194, 341855, 419857], [0, 1, 2, 3, 9, 16, 1705, 2082, 2126, 8177, 12753, 15410, 52642, 80493, 83235, 88387, 99444, 1675361, 2495125], [0, 2, 6, 8, 9, 11, 20, 50, 93, 152, 183, 2137, 13671, 44794, 486954, 741908, 4803258, 5692573], [0, 1, 5, 6, 44, 53, 470, 2847, 3433, 4906, 13654, 14710, 400447, 1797382, 2744492, 18775974, 23541521], [0, 4, 9, 10, 16, 33, 83, 117, 318, 451, 5759, 10015, 128975, 171834, 211256, 347608, 1278690, 2154097, 2590798, 3427694, 5581717, 21012301, 27023976, 72522811, 95032729, 139166747, 171822389], [0, 5, 10, 267, 344, 363, 2968, 3159, 9083, 18437, 76602, 147614, 1246902, 1593138, 2035574, 6529391, 9511830, 11340287, 29565945, 281666026, 677946848]]
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   * @name Long
   * @class
   *   Long class for only unsigned integers
   *  Constructs a 64-bit two's-complement integer, given its low and high 32-bit
   *  values as *signed* integers.  See the from* functions below for more
   *  convenient ways of constructing Longs.
   *
   *  The internal representation of a long is the two given signed, 32-bit values.
   *  We use 32-bit pieces because these are the size of integers on which
   *  Javascript performs bit-operations.  For operations like addition and
   *  multiplication, we split each number into 16-bit pieces, which can easily be
   *  multiplied within Javascript's floating-point representation without overflow
   *  or change in sign.
   *
   *  In the algorithms below, we frequently reduce the negative case to the
   *  positive case by negating the input(s) and then post-processing the result.
   *  Note that we must ALWAYS check specially whether those values are MIN_VALUE
   *  (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
   *  a positive number, it overflows back into a negative).  Not handling this
   * case would often result in infinite recursion.
   * @constructor
   * @param {number} low  The low (signed) 32 bits of the long.
   * @param {number} high  The high (signed) 32 bits of the long.
   */
  var Long = function (low, high) {
    /**
     * @type {number}
     * @private
     */
    this.low_ = low | 0; // force into 32 signed bits.

    /**
     * @type {number}
     * @private
     */

    this.high_ = high | 0; // force into 32 signed bits.
  };
  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @private
   */


  Long.IntCache_ = {};
  /**
   * Returns a Long representing the given (32-bit) integer value.
   * @function fromInt
   * @memberof Long
   * @param {number} value The 32-bit integer in question.
   * @return {!Long} The corresponding Long value.
   */

  Long.fromInt = function (value) {
    if (-128 <= value && value < 128) {
      var cachedObj = Long.IntCache_[value];

      if (cachedObj) {
        return cachedObj;
      }
    }

    var obj = new Long(value | 0, value < 0 ? -1 : 0);

    if (-128 <= value && value < 128) {
      Long.IntCache_[value] = obj;
    }

    return obj;
  };
  /**
   * Returns a Long representing the given value, provided that it is a finite
   * number.  Otherwise, zero is returned.
   * @function fromNumber
   * @memberof Long
   * @param {number} value The number in question.
   * @return {!Long} The corresponding Long value.
   */


  Long.fromNumber = function (value) {
    if (isNaN(value) || !isFinite(value)) {
      return Long.ZERO;
    } else if (value <= -Long.TWO_PWR_63_DBL_) {
      return Long.MIN_VALUE;
    } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
      return Long.MAX_VALUE;
    } else if (value < 0) {
      return Long.fromNumber(-value).negate();
    } else {
      return new Long(value % Long.TWO_PWR_32_DBL_ | 0, value / Long.TWO_PWR_32_DBL_ | 0);
    }
  };
  /**
   * Returns a Long representing the 64-bit integer that comes by concatenating
   * the given high and low bits.  Each is assumed to use 32 bits.
   * @function fromBits
   * @memberof Long
   * @param {number} lowBits The low 32-bits.
   * @param {number} highBits The high 32-bits.
   * @return {!Long} The corresponding Long value.
   */


  Long.fromBits = function (lowBits, highBits) {
    return new Long(lowBits, highBits);
  };
  /**
   * Number used repeated below in calculations.  This must appear before the
   * first call to any from* function below.
   * @type {number}
   * @private
   */


  Long.TWO_PWR_16_DBL_ = 1 << 16;
  /**
   * @type {number}
   * @private
   */

  Long.TWO_PWR_24_DBL_ = 1 << 24;
  /**
   * @type {number}
   * @private
   */

  Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
  /**
   * @type {number}
   * @private
   */

  Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
  /**
   * @type {number}
   * @private
   */

  Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
  /** @type {!Long} */

  Long.ZERO = Long.fromInt(0);
  /** @type {!Long} */

  Long.ONE = Long.fromInt(1);
  /** @type {!Long} */

  Long.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0);
  /** @type {!Long} */

  Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
  /**
   * @type {!Long}
   * @private
   */

  Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
  /** @return {number} The value, assuming it is a 32-bit integer. */

  Long.prototype.toInt = function () {
    return this.low_;
  };
  /** @return {number} The closest floating-point representation to this value. */


  Long.prototype.toNumber = function () {
    return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  /** @return {number} The low 32-bits as an unsigned value. */


  Long.prototype.getLowBitsUnsigned = function () {
    return this.low_ >= 0 ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
  };
  /** @return {boolean} Whether this value is zero. */


  Long.prototype.isZero = function () {
    return this.high_ === 0 && this.low_ === 0;
  };
  /** @return {boolean} Whether this value is negative. */


  Long.prototype.isNegative = function () {
    return this.high_ < 0;
  };
  /** @return {boolean} Whether this value is odd. */


  Long.prototype.isOdd = function () {
    return (this.low_ & 1) === 1;
  };
  /**
   * @param {Long} other Long to compare against.
   * @return {boolean} Whether this Long equals the other.
   */


  Long.prototype.equals = function (other) {
    return this.high_ === other.high_ && this.low_ === other.low_;
  };
  /**
   * @param {Long} other Long to compare against.
   * @return {boolean} Whether this Long is less than the other.
   */


  Long.prototype.lessThan = function (other) {
    return this.compare(other) < 0;
  };
  /**
   * @param {Long} other Long to compare against.
   * @return {boolean} Whether this Long is greater than or equal to the other.
   */


  Long.prototype.greaterThanOrEqual = function (other) {
    return this.compare(other) >= 0;
  };
  /**
   * Compares this Long with the given one.
   * @function compare
   * @memberof Long.prototype
   * @return {number} 0 if they are the same, 1 if the this is greater, and -1
   *     if the given one is greater.
   */


  Long.prototype.compare = function (other) {
    if (this.equals(other)) {
      return 0;
    }

    var thisNeg = this.isNegative();
    var otherNeg = other.isNegative();

    if (thisNeg && !otherNeg) {
      return -1;
    }

    if (!thisNeg && otherNeg) {
      return 1;
    } // at this point, the signs are the same, so subtraction will not overflow


    if (this.subtract(other).isNegative()) {
      return -1;
    } else {
      return 1;
    }
  };
  /**
   * Return the negation
   * @function negate
   * @memberof Long.prototype
   * @return {!Long} The negation of this value.
   */


  Long.prototype.negate = function () {
    if (this.equals(Long.MIN_VALUE)) {
      return Long.MIN_VALUE;
    } else {
      return this.not().add(Long.ONE);
    }
  };
  /**
   * Returns the sum of this and the given Long.
   * @function add
   * @memberof Long.prototype
   * @param {Long} other Long to add to this one.
   * @return {!Long} The sum of this and the given Long.
   */


  Long.prototype.add = function (other) {
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xffff;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xffff;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xffff;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xffff;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 + b48;
    c48 &= 0xffff;
    return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  /**
   * Returns the difference of this and the given Long.
   * @function subtract
   * @memberof Long.prototype
   * @param {Long} other Long to subtract from this.
   * @return {!Long} The difference of this and the given Long.
   */


  Long.prototype.subtract = function (other) {
    return this.add(other.negate());
  };
  /**
   * Returns the product of this and the given long.
   * @function multiply
   * @memberof Long.prototype
   * @param {Long} other Long to multiply with this.
   * @return {!Long} The product of this and the other.
   */


  Long.prototype.multiply = function (other) {
    if (this.isZero()) {
      return Long.ZERO;
    } else if (other.isZero()) {
      return Long.ZERO;
    }

    if (this.equals(Long.MIN_VALUE)) {
      return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
    } else if (other.equals(Long.MIN_VALUE)) {
      return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
    }

    if (this.isNegative()) {
      if (other.isNegative()) {
        return this.negate().multiply(other.negate());
      } else {
        return this.negate().multiply(other).negate();
      }
    } else if (other.isNegative()) {
      return this.multiply(other.negate()).negate();
    } // If both longs are small, use float multiplication


    if (this.lessThan(Long.TWO_PWR_24_) && other.lessThan(Long.TWO_PWR_24_)) {
      return Long.fromNumber(this.toNumber() * other.toNumber());
    } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.


    var a48 = this.high_ >>> 16;
    var a32 = this.high_ & 0xffff;
    var a16 = this.low_ >>> 16;
    var a00 = this.low_ & 0xffff;
    var b48 = other.high_ >>> 16;
    var b32 = other.high_ & 0xffff;
    var b16 = other.low_ >>> 16;
    var b00 = other.low_ & 0xffff;
    var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xffff;
    return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32);
  };
  /** @return {!Long} The bitwise-NOT of this value. */


  Long.prototype.not = function () {
    return Long.fromBits(~this.low_, ~this.high_);
  };
  /**
   * Returns the bitwise-AND of this Long and the given one.
   * @function and
   * @memberof Long.prototype
   * @param {Long} other The Long with which to AND.
   * @return {!Long} The bitwise-AND of this and the other.
   */


  Long.prototype.and = function (other) {
    return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
  };
  /**
   * Returns the bitwise-OR of this Long and the given one.
   * @function or
   * @memberof Long.prototype
   * @param {Long} other The Long with which to OR.
   * @return {!Long} The bitwise-OR of this and the other.
   */


  Long.prototype.or = function (other) {
    return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
  };
  /**
   * Returns this Long with bits shifted to the right by the given amount, with
   * the new top bits matching the current sign bit.
   * @function shiftRightUnsigned
   * @memberof Long.prototype
   * @param {number} numBits The number of bits by which to shift.
   * @return {!Long} This shifted to the right by the given amount, with
   *     zeros placed into the new leading bits.
   */


  Long.prototype.shiftRightUnsigned = function (numBits) {
    numBits &= 63;

    if (numBits === 0) {
      return this;
    } else {
      var high = this.high_;

      if (numBits < 32) {
        var low = this.low_;
        return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
      } else if (numBits === 32) {
        return Long.fromBits(high, 0);
      } else {
        return Long.fromBits(high >>> numBits - 32, 0);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/
  var center, cosrad;

  var CircleFinder = function (point) {
    //CircleFinder.prototype.constructor.call(this, point);
    var np = point.length; //HealpixUtils.check(np >= 3, "too few points");

    center = vec3.add2(point[0], point[1]);
    center = vec3.normalize2(center);
    cosrad = vec3.dot2(point[0], center);

    for (var i = 2; i < np; ++i) {
      if (vec3.dot2(point[i], center) < cosrad) {
        // point outside the current circle
        this.getCircle(point, i);
      }
    }
  };
  /**************************************************************************************************************/


  CircleFinder.prototype.getCircle = function (point, q1, q2) {
    center = vec3.add2(point[q1], point[q2]);
    center = vec3.normalize2(center);
    cosrad = vec3.dot2(point[q1], center);

    for (var i = 0; i < q1; ++i) {
      if (vec3.dot2(point[i], center) < cosrad) {
        // point outside the current circle
        var subPoint = vec3.subtract2(point[q1], point[i]);
        var subPoint2 = vec3.subtract2(point[q2], point[i]);
        center = vec3.cross2(subPoint, subPoint2);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[q1], center);

        if (cosrad < 0) {
          center = vec3.flip(center);
          cosrad = -cosrad;
        }
      }
    }
  };
  /**************************************************************************************************************/


  CircleFinder.prototype.getCircle = function (point, q) {
    center = vec3.add2(point[0], point[q]);
    center = vec3.normalize2(center);
    cosrad = vec3.dot2(point[0], center);

    for (var i = 1; i < q; ++i) {
      if (vec3.dot2(point[i], center) < cosrad) {
        // point outside the current circle
        this.getCircle(point, i, q);
      }
    }
  };
  /**************************************************************************************************************/


  CircleFinder.prototype.getCenter = function () {
    return center;
  };

  CircleFinder.prototype.getCosRad = function () {
    return cosrad;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  let isDebug = false; // The main div for error

  const errorDiv = '<div id="errorDiv" style="text-align: left" title="Error"></div>'; // Create the div, use jQuery UI dialog

  let $text = "";
  let $buttonName = "";
  const $errorDiv = $__default['default'](errorDiv).appendTo("body").dialog({
    autoOpen: false,
    width: 500,
    minHeight: 300,
    maxHeight: 500,
    dialogClass: "errorBox",
    beforeClose: function (event, ui) {
      $text = "";
    }
  });
  let $active = false;

  const _consoleError = function (txt) {
    if (isDebug) {
      console.error(txt);
    }
  };

  const _consoleWarn = function (txt) {
    if (isDebug) {
      console.warn(txt);
    }
  };

  const _consoleLog = function (txt) {
    if (isDebug) {
      console.log(txt);
    }
  };

  const _recordError = function (html) {
    $text += html + "<br/>";

    if ($__default['default']("#warningContainer")) {
      $__default['default']("#warningContainer").show();
      $errorDiv.on("dialogclose", function (event) {
        if ($buttonName) {
          $buttonName.hide();
        }
      });
    }

    if ($active === true) {
      $errorDiv.html($text).dialog("open");
      $errorDiv.scrollTop(5000);
    }
  };

  const _computeMessageHTML = function (message, description) {
    if (description != null && message != null) {
      message = message + " - <font style='color:white'>";

      if (typeof description === "string") {
        message = message + description;
      } else if (description.message) {
        message = message + description.message;
      } else {
        message = message + JSON.stringify(description);
      }

      message = message + "</font>";
    }

    return message;
  };

  const _computeMessageASCII = function (message, description) {
    if (description != null && message != null) {
      if (typeof description === "string") {
        message = message + ":" + description;
      } else if (description.message) {
        message = message + ":" + description.message;
      } else {
        message = message + ":" + JSON.stringify(description);
      }
    }

    return message;
  };

  var ErrorDialog = {
    /**
     * Open dialog
     * @param {LEVEL} LEVEL Log level
     * @param {string} title error title
     * @param {string} description error description
     */
    open: function (LEVEL, title, description) {
      let message = "";

      if (LEVEL === Constants.LEVEL.WARNING) {
        message = message + "<font style='color:orange'>Warning : " + title + "</font>";

        _consoleWarn(_computeMessageASCII(title, description));

        _recordError(_computeMessageHTML(message, description));
      } else if (LEVEL === Constants.LEVEL.ERROR) {
        message = message + "<font style='color:red'>Error : " + title + "</font>";

        _consoleError(_computeMessageASCII(title, description));

        _recordError(_computeMessageHTML(message, description));
      } else if (LEVEL === Constants.LEVEL.DEBUG) {
        _consoleLog(_computeMessageASCII(title, description));
      } else {
        throw new TypeError("ErrorDialog.js: LEVEL must be set with a valid value");
      }
    },

    /**
     * View the messages in the GUI.
     */
    view: function () {
      $errorDiv.html($text).dialog("open");
      $errorDiv.scrollTop(5000);
      $active = true;
    },

    /**
     * Hides the GUI
     */
    hide: function () {
      $errorDiv.dialog("close");
      $active = false;
    },

    /**
     * GUI is active ?
     * @return {boolean} true when the GUI is shown otherwise false
     */
    isActive: function () {
      return $active;
    },

    /**
     * Sets the icon.
     * @param {string} ID
     */
    setIcon: function (buttonName) {
      $buttonName = $__default['default'](buttonName);
    },

    /**
     * Has error.
     * @returns {boolean} true when error otherise false
     */
    hasError: function () {
      return $text.length > 0;
    },

    /**
     * Returns the message
     * @returns {string} the message
     */
    getTxt: function () {
      return $text;
    },

    /**
     * Sets debug enable/disable.
     * By default debug is disable.
     * @param {boolean} debug Set to true to show debug message in the console otherwise False
     */
    setDebug: function (debug) {
      isDebug = debug;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  var HALF_PI = Math.PI * 0.5;

  var lonLat2ang = function (lon, lat) {
    if (lon < 0) {
      lon += 360;
    }

    var phi = lon * Math.PI / 180.0;
    var theta = (-lat + 90.0) * Math.PI / 180.0;
    return [phi, theta];
  };
  /**************************************************************************************************************/

  /** Returns the remainder of the division {@code v1/v2}.
   The result is non-negative.
   @param v1 dividend; can be positive or negative
   @param v2 divisor; must be positive
   @return Remainder of the division; positive and smaller than {@code v2} */


  var fmodulo = function (v1, v2) {
    if (v1 >= 0.0) {
      return v1 < v2 ? v1 : v1 % v2;
    }

    var tmp = v1 % v2 + v2;
    return tmp === v2 ? 0.0 : tmp;
  };
  /**************************************************************************************************************/


  var spread_bits = function (v) {
    return HealPixTables.utab[v & 0xff] | HealPixTables.utab[v >>> 8 & 0xff] << 16 | HealPixTables.utab[v >>> 16 & 0xff] << 32 | HealPixTables.utab[v >>> 24 & 0xff] << 48;
  };
  /**************************************************************************************************************/


  var xyf2nest = function (ix, iy, face_num, order) {
    return (face_num << 2 * order) + spread_bits(ix) + (spread_bits(iy) << 1);
  };
  /**************************************************************************************************************/


  var loc2pix = function (order, phi, theta) {
    var nside2 = Math.pow(2, order);
    var z = Math.cos(theta); //var phi = phi;

    var loc = {
      phi: phi,
      theta: theta,
      z: z
    };

    if (Math.abs(z) > 9.0 / 10.0) {
      loc.sth = Math.sin(theta);
      loc.have_sth = true;
    }

    var inv_halfpi = 2.0 / Math.PI;
    var tt = fmodulo(phi * inv_halfpi, 4.0); // in [0,4)

    var jp, jm, nSideMinusOne;
    var za = Math.abs(z);

    if (za <= 2.0 / 3.0) {
      // Equatorial region
      var temp1 = nside2 * (0.5 + tt);
      var temp2 = nside2 * (z * 0.75);
      jp = Long.fromNumber(temp1 - temp2);
      jm = Long.fromNumber(temp1 + temp2);
      var ifp = jp.shiftRightUnsigned(order);
      var ifm = jm.shiftRightUnsigned(order);
      var face_num;

      if (ifp.equals(ifm)) {
        face_num = ifp.or(Long.fromInt(4));
      } else {
        if (ifp.lessThan(ifm)) {
          face_num = ifp;
        } else {
          face_num = ifm.add(Long.fromInt(8));
        }
      }

      nSideMinusOne = Long.fromNumber(nside2 - 1);
      var ix = jm.and(nSideMinusOne);
      var iy = nSideMinusOne.subtract(jp.and(nSideMinusOne));
      return xyf2nest(ix.toInt(), iy.toInt(), face_num.toInt(), order);
    } // polar region, za > 2/3
    else {
        var ntt = parseInt(Math.min(3, parseInt(tt, 10)), 10);
        var tp = tt - ntt;
        var tmp = za < 9.0 / 10.0 || !loc.have_sth ? nside2 * Math.sqrt(3 * (1 - za)) : nside2 * loc.sth / Math.sqrt((1.0 + za) / 3.0);
        jp = Long.fromNumber(tp * tmp);
        jm = Long.fromNumber((1.0 - tp) * tmp);
        var lNside = Long.fromNumber(nside2);
        nSideMinusOne = Long.fromNumber(nside2 - 1.0);
        var lOne = Long.fromInt(1);

        if (jp.greaterThanOrEqual(lNside)) {
          jp = nSideMinusOne;
        }

        if (jm.greaterThanOrEqual(lNside)) {
          jm = nSideMinusOne;
        }

        if (z >= 0) {
          return xyf2nest(lNside.subtract(jm).subtract(lOne).toInt(), lNside.subtract(jp).subtract(lOne).toInt(), ntt, order);
        } else {
          return xyf2nest(jp.toInt(), jm.toInt(), ntt + 8, order);
        }
      }
  };

  var pstack = function (sz) {
    this.p = new Array(sz);
    this.o = new Array(sz);

    for (var i = 0; i < this.p.length; i++) {
      //this.p[i] = Long.fromInt(0);
      this.p[i] = 0;
      this.o[i] = 0;
    }

    this.s = this.m = 0;
  };

  pstack.prototype.push = function (p_, o_) {
    this.p[this.s] = p_;
    this.o[this.s] = o_;
    ++this.s;
  };

  pstack.prototype.otop = function () {
    return this.o[this.s - 1];
  };

  pstack.prototype.ptop = function () {
    return this.p[this.s - 1];
  };

  pstack.prototype.pop = function () {
    this.s--;
  };

  pstack.prototype.popToMark = function () {
    this.s = this.m;
  };

  pstack.prototype.mark = function () {
    this.m = this.s;
  };

  pstack.prototype.size = function () {
    return this.s;
  };
  /**************************************************************************************************************/


  var HEALPixBase = {
    init: function (options) {
      this.order_max = 29;
      this.bn = [];
      this.nside = null;

      try {
        for (var i = 0; i <= this.order_max; ++i) {
          this.bn[i] = this.createBoundaries(1.0 << i, "NESTED");
        }
      } catch (ex) {
        /*doesn't happen*/
      }
    },
    createBoundaries: function (nside_in, scheme_in) {
      this.nside = nside_in - 1;
      return this.calculateBoundaries(nside_in, scheme_in);
    },
    compress_bits: function (v) {
      var longV = Long.fromNumber(v);
      var longMask = Long.fromNumber(0x5555555555555);
      var raw = longV.and(longMask);
      var dec = raw.shiftRightUnsigned(15);
      raw = raw.or(dec);
      var raw1 = raw.and(Long.fromNumber(0xffff)).toInt();
      var dec2 = raw.shiftRightUnsigned(32);
      var raw2 = dec2.and(Long.fromNumber(0xffff)).toInt();
      return HealPixTables.ctab[raw1 & 0xff] | HealPixTables.ctab[raw1 >>> 8] << 4 | HealPixTables.ctab[raw2 & 0xff] << 16 | HealPixTables.ctab[raw2 >>> 8] << 20;
    },

    /**
     *    Function describing a location on the sphere
     */
    fxyf: function (_fx, _fy, _face) {
      var jr = HealPixTables.jrll[_face] - _fx - _fy;
      var z = 0;
      var phi = 0;
      var sth = 0;
      var have_sth = false;
      var nr, tmp;

      if (jr < 1) {
        nr = jr;
        tmp = nr * nr / 3.0;
        z = 1 - tmp;

        if (z > 0.99) {
          sth = Math.sqrt(tmp * (2.0 - tmp));
          have_sth = true;
        }
      } else if (jr > 3) {
        nr = 4 - jr;
        tmp = nr * nr / 3.0;
        z = tmp - 1;

        if (z < -0.99) {
          sth = Math.sqrt(tmp * (2.0 - tmp));
          have_sth = true;
        }
      } else {
        nr = 1;
        z = (2 - jr) * 2.0 / 3.0;
      }

      tmp = HealPixTables.jpll[_face] * nr + _fx - _fy;

      if (tmp < 0) {
        tmp += 8;
      }

      if (tmp >= 8) {
        tmp -= 8;
      }

      phi = nr < 1e-15 ? 0 : 0.5 * HALF_PI * tmp / nr;
      var st = have_sth ? sth : Math.sqrt((1.0 - z) * (1.0 + z));
      return [st * Math.cos(phi), st * Math.sin(phi), z];
    },

    /** Returns the maximum angular distance between a pixel center and its
       corners.
       @return number angular distance between a pixel center and its
       corners. */
    maxPixrad: function (order, nl4) {
      var nside2 = Math.pow(2, order);
      var va = vec3.createZPhi(2.0 / 3.0, Math.PI / nl4);
      var t1 = 1.0 - 1.0 / nside2;
      t1 *= t1;
      var vb = vec3.createZPhi(1 - t1 / 3, 0);
      return vec3.angle2(va, vb);
    },
    pix2vec: function (pix, boundaries) {
      var loc = this.pix2loc(pix, boundaries);
      var st = loc.have_sth ? loc.sth : Math.sqrt((1.0 - loc.z) * (1.0 + loc.z));
      return vec3.createFrom(st * Math.cos(loc.phi), st * Math.sin(loc.phi), loc.z);
    },
    pix2loc: function (pix, boundaries) {
      //var fact2 = 4.0 / pix;
      //var fact1 = (nside << 1) * fact2;
      //var nl2 = 2 * nside;
      //var nl3 = 3 * nside;
      //var nl4 = 4 * nside;
      //var npface = nside * nside;
      //var ncap = 2 * nside * (nside - 1); // pixels in each polar cap
      //var npix = 12 * npface;
      //var fact2 = 4.0 / npix;
      //var fact1 = (nside << 1) * fact2;
      var loc = {
        phi: null,
        sth: 0.0,
        have_sth: false,
        z: null
      };
      var xyf = this.nest2xyf(pix, boundaries.npface, boundaries.order);
      var jr = (HealPixTables.jrll[xyf.face] << boundaries.order) - xyf.ix - xyf.iy - 1;
      var nr, tmp;

      if (jr < boundaries.nside) {
        nr = jr;
        tmp = nr * nr * boundaries.fact2;
        loc.z = 1 - tmp;

        if (loc.z > 0.99) {
          loc.sth = Math.sqrt(tmp * (2.0 - tmp));
          loc.have_sth = true;
        }
      } else if (jr > boundaries.nl3) {
        nr = boundaries.nl4 - jr;
        tmp = nr * nr * boundaries.fact2;
        loc.z = tmp - 1;

        if (loc.z < -0.99) {
          loc.sth = Math.sqrt(tmp * (2.0 - tmp));
          loc.have_sth = true;
        }
      } else {
        nr = boundaries.nside;
        loc.z = (boundaries.nl2 - jr) * boundaries.fact1;
      }

      tmp = HealPixTables.jpll[xyf.face] * nr + xyf.ix - xyf.iy; //assert (tmp < 8 * nr); // must not happen

      if (tmp < 0) {
        tmp += 8 * nr;
      }

      loc.phi = nr === boundaries.nside ? 0.75 * HALF_PI * tmp * boundaries.fact1 : 0.5 * HALF_PI * tmp / nr;
      return loc;
    },
    nest2xyf: function (ipix, npface, order) {
      var pix = ipix & npface - 1;
      var ix = HEALPixBase.compress_bits(pix);
      var iy = HEALPixBase.compress_bits(pix >>> 1);
      var face = ipix >>> 2 * order;
      return {
        ix: ix,
        iy: iy,
        face: face
      };
    },

    /**
     *    Static function
     *    Convert nside to order
     *    (ilog2(nside))
     */
    nside2order: function (arg) {
      var res = 0;

      while (arg > 0x0000ffff) {
        res += 16;
        arg >>>= 16;
      }

      if (arg > 0x000000ff) {
        res |= 8;
        arg >>>= 8;
      }

      if (arg > 0x0000000f) {
        res |= 4;
        arg >>>= 4;
      }

      if (arg > 0x00000003) {
        res |= 2;
        arg >>>= 2;
      }

      if (arg > 0x00000001) {
        res |= 1;
      }

      return res;
    },
    calculateBoundaries: function (nside_in, scheme_in) {
      if (this.nside === nside_in) {
        return;
      }

      this.nside = nside_in;
      var order = this.nside2order(nside_in);

      if (scheme_in === "NESTED" && order < 0) {
        throw new Error("Nside must be a power of 2 for NESTED scheme");
      }

      var nl2 = 2 * this.nside;
      var nl3 = 3 * this.nside;
      var nl4 = 4 * this.nside;
      var npface = this.nside * this.nside;
      var ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap

      var npix = 12 * npface;
      var fact2 = 4.0 / npix;
      var fact1 = (this.nside << 1) * fact2;
      return {
        order: order,
        nside: this.nside,
        scheme: scheme_in,
        nl2: nl2,
        nl3: nl3,
        nl4: nl4,
        npface: npface,
        ncap: ncap,
        npix: npix,
        fact1: fact1,
        fact2: fact2
      };
    },
    // MATH lib from Java Astro lib
    convertPolygonToHealpixOrder: function (coordinates, fact, order) {
      var vertex = [];
      var factor = fact || 4;
      var healpixOrder = order || 5;

      _$1.each(coordinates, function (point) {
        var cPr = Math.PI / 180;
        var cd = Math.cos(point[1] * cPr);
        var x = Math.cos(point[0] * cPr) * cd;
        var y = Math.sin(point[0] * cPr) * cd;
        var z = Math.sin(point[1] * cPr);
        var theta = Math.atan2(Math.sqrt(x * x + y * y), z);
        var phi = Math.atan2(y, x);

        if (phi < 0.0) {
          phi += 2 * Math.PI;
        }

        if (phi >= 2 * Math.PI) {
          phi -= 2 * Math.PI;
        }

        vertex.push({
          theta: theta,
          phi: phi
        });
      });

      return this.queryPolygonInclusive(vertex, factor, healpixOrder);
    },
    queryPolygonInclusive: function (vertex, fact, healpixOrder) {
      Math.PI = 3.14159265358979323846;
      var halfpi = Math.PI / 2.0;
      var inclusive = fact !== 0;
      var nv = vertex.length;
      var ncirc = inclusive ? nv + 1 : nv;

      if (nv < 3) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixBase.js", "not enough vertices in polygon");
        return;
      }

      var vv = new Array(nv);
      var i;

      for (i = 0; i < nv; ++i) {
        vv[i] = vec3.createPhiTheta(vertex[i].phi, vertex[i].theta);
      }

      var normal = new Array(ncirc);
      var flip = 0;

      for (i = 0; i < nv; ++i) {
        normal[i] = vec3.cross2(vv[i], vv[(i + 1) % nv]); //var hnd = normal[i].dot(vv[(i + 2) % nv]);

        var hnd = vec3.dot2(normal[i], vv[(i + 2) % nv]);

        if (i === 0) {
          flip = hnd < 0.0 ? -1 : 1;
        }

        normal[i] = vec3.scale2(normal[i], flip / vec3.length2(normal[i]));
      }

      var rad = new Array(ncirc);
      this.fill(rad, halfpi);

      if (inclusive) {
        var cf = new CircleFinder(vv);
        normal[nv] = cf.getCenter();
        rad[nv] = Math.acos(cf.getCosRad());
      }

      var res = this.queryMultiDisc(normal, rad, fact, healpixOrder);
      ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixBase.js", res);
      return res;
    },
    fill: function (a, val) {
      for (var i = 0, len = a.length; i < len; i++) {
        a[i] = val;
      }
    },
    queryMultiDisc: function (norm, rad, fact, healpixOrder) {
      var order = healpixOrder;
      var inclusive = fact !== 0;
      var nv = norm.length; //HealpixUtils.check(nv == rad.length, "inconsistent input arrays");

      var res = [];
      var oplus = 0;

      if (inclusive) {
        //HealpixUtils.check((1L << (order_max - order)) >= fact, "invalid oversampling factor");
        //HealpixUtils.check((fact & (fact - 1)) == 0, "oversampling factor must be a power of 2");
        oplus = this.ilog2(fact);
      }

      var omax = order + oplus; // the order up to which we test

      var currentBoundaries; // TODO: ignore all disks with radius>=pi
      // building 3 dimensions array

      var crlimit = new Array(omax + 1);

      for (var i = 0; i < omax + 1; i++) {
        crlimit[i] = new Array(nv);

        for (var j = 0; j < nv; j++) {
          crlimit[i][j] = new Array(3);
        }
      }

      var options = {
        order: order
      };
      HEALPixBase.init(options); // set variables nl2, nl3, npix, nface...

      var o;

      for (o = 0; o <= omax; ++o // prepare data at the required orders
      ) {
        currentBoundaries = HEALPixBase.bn[o];
        var dr = HEALPixBase.maxPixrad(o, currentBoundaries.nl4); // safety distance

        for (i = 0; i < nv; ++i) {
          crlimit[o][i][0] = rad[i] + dr > Math.PI ? -1 : Math.cos(rad[i] + dr);
          crlimit[o][i][1] = o === 0 ? Math.cos(rad[i]) : crlimit[0][i][1];
          crlimit[o][i][2] = rad[i] - dr < 0.0 ? 1.0 : Math.cos(rad[i] - dr);
        }
      }

      var stk = new pstack(12 + 3 * omax);

      for (i = 0; i < 12; i++) {
        // insert the 12 base pixels in reverse order
        stk.push(11 - i, 0);
      }

      while (stk.size() > 0) {
        // as long as there are pixels on the stack
        // pop current pixel number and order from the stack
        var pix = stk.ptop();
        o = stk.otop();
        stk.pop();
        currentBoundaries = HEALPixBase.bn[o];
        var pv = HEALPixBase.pix2vec(pix, currentBoundaries);
        var zone = 3;

        for (i = 0; i < nv && zone > 0; ++i) {
          var crad = vec3.dot2(pv, norm[i]);

          for (var iz = 0; iz < zone; ++iz) {
            if (crad < crlimit[o][i][iz]) {
              zone = iz; //console.log("zone :" + zone + " pix:" + pix + " crad:" + crad);
            }
          }
        }

        if (zone > 0) {
          this.check_pixel(o, omax, zone, res, pix, stk, inclusive, healpixOrder);
        }
      }

      return res;
    },
    check_pixel: function (o, omax, zone, pixset, pix, stk, inclusive, healpixOrder) {
      var order = healpixOrder;
      var i;

      if (zone === 0) {
        return;
      }

      if (o < order) {
        if (zone >= 3) {
          // output all subpixels
          var sdist = 2 * (order - o); // the "bit-shift distance" between map orders

          var start = pix << sdist;
          var end = pix + 1 << sdist;

          for (i = start; i <= end; i++) {
            pixset.push(i);
          }
        } else {
          // (zone>=1)
          for (i = 0; i < 4; ++i) {
            stk.push(4 * pix + 3 - i, o + 1); // add children
          }
        }
      } else if (o > order) {
        // this implies that inclusive==true
        if (zone >= 2) {
          // pixel center in shape
          pixset.push(pix >>> 2 * (o - order)); // output the parent pixel at order

          stk.popToMark(); // unwind the stack
        } // (zone>=1): pixel center in safety range
        else {
            if (o < omax) {
              // check sublevels
              for (i = 0; i < 4; ++i) {
                // add children in reverse order
                stk.push(4 * pix + 3 - i, o + 1); // add children
              }
            } else {
              // at resolution limit
              pixset.push(pix >>> 2 * (o - order)); // output the parent pixel at order

              stk.popToMark(); // unwind the stack
            }
          }
      } // o==order
      else {
          if (zone >= 2) {
            pixset.push(pix);
          } else if (inclusive) {
            // and (zone>=1)
            if (order < omax) {
              // check sublevels
              stk.mark(); // remember current stack position

              for (i = 0; i < 4; ++i) {
                // add children in reverse order
                stk.push(4 * pix + 3 - i, o + 1); // add children
              }
            } else {
              // at resolution limit
              pixset.push(pix); // output the pixel
            }
          }
        }
    },
    ilog2: function (arg) {
      var res = 0;

      while (arg > 0x0000ffff) {
        res += 16;
        arg >>>= 16;
      }

      if (arg > 0x000000ff) {
        res |= 8;
        arg >>>= 8;
      }

      if (arg > 0x0000000f) {
        res |= 4;
        arg >>>= 4;
      }

      if (arg > 0x00000003) {
        res |= 2;
        arg >>>= 2;
      }

      if (arg > 0x00000001) {
        res |= 1;
      }

      return res;
    },

    /**
     *    Returns pixel index of point on sphere
     *
     *    @param order Tile order
     *    @param lon Longitude
     *    @param lat Latitude
     */
    lonLat2pix: function (order, lon, lat) {
      var loc = lonLat2ang(lon, lat);
      return loc2pix(order, loc[0], loc[1]);
    },

    /**
       Create the children of the given pixel
       */
    getChildren: function (npix) {
      return [npix * 4, npix * 4 + 1, npix * 4 + 2, npix * 4 + 3];
    },
    uniq2hpix: function (uniq, hpix) {
      if (hpix == null) {
        hpix = [];
      }

      hpix[0] = HEALPixBase.log2(uniq / 4) / 2;
      var nside = HEALPixBase.pow2(hpix[0]);
      hpix[1] = uniq - 4 * nside * nside;
      hpix[0] = parseInt(hpix[0], 10);
      return hpix;
    },
    log2: function (nside) {
      var i = 0;

      while (nside >>> ++i > 0) {// nop
      }

      return --i;
    },
    pow2: function (order) {
      return 1 << order;
    },

    /**
     * calculates angular resolution of the pixel map in arc seconds.
     *
     * @param nside
     * @return double resolution in arcsec
     */
    getPixRes: function (nside) {
      var rad2arcsec = 180.0 * 60.0 * 60.0 / Math.PI;
      return rad2arcsec * Math.sqrt(4 * Math.PI / (12 * nside * nside));
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var UtilsIntersection = {};

  UtilsIntersection.convertPolygonToHealpixOrder = function (coordinates, fact, order) {
    return HEALPixBase.convertPolygonToHealpixOrder(coordinates, fact, order);
  };
  /**
   * Check if a point lies on a line
   * @param point
   * @param segmentStart
   * @param segmentEnd
   * @returns {boolean}
   */


  UtilsIntersection.pointInLine = function (point, segmentStart, segmentEnd) {
    var deltax = segmentEnd[0] - segmentStart[0];
    var deltay, t;
    var liesInXDir = false;
    var isIntersect;

    if (deltax === 0) {
      liesInXDir = point[0] === segmentStart[0];
    } else {
      t = (point[0] - segmentStart[0]) / deltax;
      liesInXDir = t >= 0 && t <= 1;
    }

    if (liesInXDir) {
      deltay = segmentEnd[1] - segmentStart[1];

      if (deltax === 0) {
        isIntersect = point[1] === segmentStart[1];
      } else {
        t = (point[1] - segmentStart[1]) / deltay;
        isIntersect = t >= 0 && t <= 1;
      }
    } else {
      isIntersect = false;
    }

    return isIntersect;
  };
  /**
   *    Determine if a point lies inside a sphere of radius depending on viewport
   */


  UtilsIntersection.pointInSphere = function (ctx, point, sphere, pointTextureHeight) {
    var point3D = [];
    var sphere3D = []; // Compute pixel size vector to offset the points from the earth

    var pixelSizeVector = ctx.getRenderContext().computePixelSizeVector();
    ctx.getCoordinateSystem().get3DFromWorld(point, point3D);
    ctx.getCoordinateSystem().get3DFromWorld(sphere, sphere3D);
    var radius = pointTextureHeight * (pixelSizeVector[0] * sphere3D[0] + pixelSizeVector[1] * sphere3D[1] + pixelSizeVector[2] * sphere3D[2] + pixelSizeVector[3]); //Calculate the squared distance from the point to the center of the sphere

    var vecDist = [];
    vec3.subtract(point3D, sphere3D, vecDist);
    vecDist = vec3.dot(vecDist, vecDist); //Calculate if the squared distance between the sphere's center and the point
    //is less than the squared radius of the sphere

    if (vecDist < radius * radius) {
      return true;
    } //If not, return false


    return false;
  };
  /**
   * Convert spherical coordinate to cartesian
   */


  function to3D(pt) {
    var lon = Numeric.toRadian(pt[0]);
    var lat = Numeric.toRadian(pt[1]);
    var x = Math.cos(lat) * Math.cos(lon);
    var y = Math.cos(lat) * Math.sin(lon);
    var z = Math.sin(lat);
    return [x, y, z];
  }

  function greatArcIntersection(a0, a1, b0, b1) {
    var p = vec3.cross(a0, a1, []);
    var q = vec3.cross(b0, b1, []);
    var t = vec3.normalize(vec3.cross(p, q, []));
    var s1 = vec3.dot(vec3.cross(a0, p, []), t);
    var s2 = vec3.dot(vec3.cross(a1, p, []), t);
    var s3 = vec3.dot(vec3.cross(b0, q, []), t);
    var s4 = vec3.dot(vec3.cross(b1, q, []), t);
    var st = Numeric.sign(-s1) + Numeric.sign(s2) + Numeric.sign(-s3) + Numeric.sign(s4);
    return Math.abs(st) === 4;
  }
  /**
   * Point in ring with spherical geometry
   */


  UtilsIntersection.pointInRing = function (point, ring) {
    var nvert = ring.length;
    var nbinter = 0;
    var p0 = to3D(point);
    var p1 = to3D([point[0], point[1] + 90]);

    for (var i = 0; i < nvert - 1; i++) {
      if (greatArcIntersection(to3D(ring[i]), to3D(ring[i + 1]), p0, p1)) {
        nbinter++;
      }
    }

    return nbinter % 2 === 1;
  };
  /**
   * Checks if a value v is between the interval [min, max].
   * @function isValueBetween
   * @param {float} v - value
   * @param {float} min - min value
   * @param {float} max - max value
   * @return {boolean} true when v is between min and max otherwise talse
   */


  UtilsIntersection.isValueBetween = function (v, min, max) {
    return min <= v && v <= max;
  };
  /**
   * Checks is two bounding boxes intersect
   * @function boundsIntersects
   * @param {{west:float, north:float, east:float, south:float}} a - bounding box
   * @param {{west:float, north:float, east:float, south:float}} b - bounding box
   * @return {boolean} true when the two bounding boxes intersect otherwise false
   */


  UtilsIntersection.boundsIntersects = function (a, b) {
    if (a === null || b === null) {
      return false;
    }

    if (a.north == null || b.north == null) {
      return false;
    }

    var xOk = UtilsIntersection.isValueBetween(a.west, b.west, b.east) || UtilsIntersection.isValueBetween(a.east, b.west, b.east) || a.west <= b.west && a.east >= b.east;
    var yOk = UtilsIntersection.isValueBetween(a.north, b.south, b.north) || UtilsIntersection.isValueBetween(a.south, b.south, b.north) || a.south <= b.south && a.north >= b.north;
    return xOk && yOk;
  };
  /**
   * Returns true when t1 intersects with t2 otherwise false
   * @function tileIntersectHealpixTile
   * @param {Tile} t1
   * @param {Tile} t2
   * @returns {boolean} true when t1 intersects with t2 otherwise false
   */


  UtilsIntersection.tileIntersectHealpixTile = function (t1, t2) {
    if (t1 === null || t2 === null) {
      return false;
    }

    var result;

    if (t1.level === t2.level) {
      result = t1.pixelIndex === t2.pixelIndex;
    } else if (t1.level > t2.level) {
      var diffLevel = t1.level - t2.level;
      result = t1.pixelIndex >> Math.pow(2, diffLevel) === t2.pixelIndex;
    } else {
      diffLevel = t2.level - t1.level;
      result = t2.pixelIndex >> Math.pow(2, diffLevel) === t1.pixelIndex;
    }

    return result;
  };
  /**
   * Returns true when t1 intersects with t2 otherwise false
   * @function tileIntersectGeoTile
   * @param {Tile} t1
   * @param {Tile} t2
   * @returns {boolean} true when t1 intersects with t2 otherwise false
   */


  UtilsIntersection.tileIntersectGeoTile = function (t1, t2) {
    if (t1 === null || t2 === null) {
      return false;
    }

    var result;

    if (t1.level === t2.level) {
      result = t1.x === t2.x && t1.y === t2.y;
    } else if (t1.level > t2.level) {
      var diffLevel = t1.level - t2.level;
      var x1 = Math.pow(2, diffLevel) * t2.x;
      var x2 = Math.pow(2, diffLevel) * (t2.x + 1) - 1;
      var y1 = Math.pow(2, diffLevel) * t2.y;
      var y2 = Math.pow(2, diffLevel) * (t2.y + 1) - 1;
      result = UtilsIntersection.isValueBetween(t1.x, x1, x2) && UtilsIntersection.isValueBetween(t1.y, y1, y2);
    } else {
      diffLevel = t2.level - t1.level;
      x1 = Math.pow(2, diffLevel) * t1.x;
      x2 = Math.pow(2, diffLevel) * (t1.x + 1) - 1;
      y1 = Math.pow(2, diffLevel) * t1.y;
      y2 = Math.pow(2, diffLevel) * (t1.y + 1) - 1;
      result = UtilsIntersection.isValueBetween(t2.x, x1, x2) && UtilsIntersection.isValueBetween(t2.y, y1, y2);
    }

    return result;
  };
  /**
   * Returns true when t1 intersects with t2 otherwise false
   * @function tileIntersect
   * @param {Tile} t1
   * @param {Tile} t2
   * @returns {boolean} true when t1 intersects with t2 otherwise false
   * @throws ReferenceError - Unknown tiling
   */


  UtilsIntersection.tileIntersect = function (t1, t2) {
    if (t1 === null || t2 === null) {
      return false;
    }

    var result;

    if (t1.type === Constants.TILE.GEO_TILE || t1.type === Constants.TILE.MERCATOR_TILE) {
      result = UtilsIntersection.tileIntersectGeoTile(t1, t2);
    } else if (t1.type === Constants.TILE.HEALPIX_TILE) {
      result = UtilsIntersection.tileIntersectHealpixTile(t1, t2);
    } else {
      throw new ReferenceError("Unknown tiling", "UtilsIntersection.js");
    }

    return result;
  };
  /**
   * Checks is one tile intersects intersect with a set of tiles
   * @function tileIntersects
   * @param {Tile} a - tile
   * @param {Tile[]} b - index
   * @return {boolean} true when intersection otherwise false
   */


  UtilsIntersection.tileIntersects = function (a, b) {
    if (a === null || b === null) {
      return false;
    }

    var result = false;

    for (var i = 0; i < b.length && !result; i++) {
      var tile = b[i];
      result = UtilsIntersection.tileIntersect(a, tile);
    }

    return result;
  };
  /**
   * Checks if the coordinates cross the date line.
   * @function isCrossDateLine
   * @param {float} minLong - min longitude
   * @param {float} maxLong - max longitude
   * @return {boolean} true when the coordinates cross the date line otherwise false
   */


  UtilsIntersection.isCrossDateLine = function (minLong, maxLong) {
    return Math.abs(minLong - maxLong) > 180;
  };
  /**
   * Checks if the 2d screen point is inside (meter-sized) billboard described
   * by its origin  (given by o, see below) and its size in meters.
   *
   *     *---------*        *---------*
   *     |         |        |         |
   *     |         |        |    o    |
   *     |         |        |         |
   *     *----o----*        *---------*
   *    planet context      sky context
   *
   * @function isInBillboard
   * @param {Geometry} geometry The geometry to test, in geo coordinates
   * @param {Array(float)} origin The origin of the rectangle, in geo coordinates
   * @param {Array(float)} size The size of the rectangle, in meters
   * @param {Array(float)} eventPos The click position
   *
   * @return {boolean} true when the point is inside the given billboard
   */


  UtilsIntersection.isInBillboard = function (pickPoint, originGeometry, size, eventPos) {
    // point is in 2d screen position, hence we need to convert origin and size
    // (which is in geo coordinates) to screen.
    if (!originGeometry._bucket || !originGeometry._bucket.renderer) {
      return false;
    }

    const from3dToScreenSpace = function (point) {
      var result = vec3.create();
      const viewMatrix = rc.viewMatrix;
      const projMatrix = rc.projectionMatrix;
      const viewProjMatrix = mat4.create();
      mat4.multiply(projMatrix, viewMatrix, viewProjMatrix);
      const p = [point[0], point[1], point[2], 1.0];
      mat4.project(viewProjMatrix, p, result);
      const w = rc.canvas.clientWidth;
      const h = rc.canvas.clientHeight;
      result[0] = (result[0] + 1.0) * 0.5 * w;
      result[1] = (1.0 - result[1]) * 0.5 * h;
      return result;
    };

    const renderer = originGeometry._bucket.renderer;
    const globe = renderer.globe;
    const crs = globe.getCoordinateSystem();
    const rc = renderer.tileManager.renderContext; // Compute mouse position. We do not always use eventPos, to keep the z position.

    var mouse2d;

    if (pickPoint) {
      const pickPoint3D = crs.get3DFromWorld(pickPoint);
      mouse2d = from3dToScreenSpace(pickPoint3D);
    } else {
      mouse2d = [eventPos[0], eventPos[1], -1.0];
    } // Get the "center" of the billboard in 3D


    const elevation = crs.getType() === Constants.CONTEXT.Planet ? crs.getElevation(globe, originGeometry) + 200 : 0.0; // match the rendering

    const originGeo = [originGeometry.coordinates[0], originGeometry.coordinates[1], elevation];
    const origin3d = crs.get3DFromWorldInCrs(originGeo, originGeometry.crs.properties.name);
    const origin2d = from3dToScreenSpace(origin3d); // Compute top left and bottom right corners

    const camRight = vec3.create([rc.viewMatrix[0], rc.viewMatrix[4], rc.viewMatrix[8]]);
    const camUp = vec3.create([rc.viewMatrix[1], rc.viewMatrix[5], rc.viewMatrix[9]]);
    const scaleRadius = crs.getGeoide().getHeightScale();
    var billboardSize;
    var topLeftLocal;
    var bottomRightLocal;

    if (crs.getType() === Constants.CONTEXT.Planet) {
      billboardSize = vec3.create([size[0] * scaleRadius, size[1] * scaleRadius, 1.0]);
      topLeftLocal = vec3.create([-0.5, 1.0, 0.0]);
      bottomRightLocal = vec3.create([0.5, 0.0, 0.0]);
    } else {
      const thetaToDist = 2.0 * Math.PI * scaleRadius / 360.0;
      billboardSize = vec3.create([size[0] * thetaToDist, size[1] * thetaToDist, 1.0]);
      topLeftLocal = vec3.create([-0.5, 0.5, 0.0]);
      bottomRightLocal = vec3.create([0.5, -0.5, 0.0]);
    }

    const billboardTo3d = function (o, p, size, camRight, camUp) {
      var x = vec3.create();
      vec3.scale(camRight, p[0], x);
      vec3.scale(x, size[0]);
      var y = vec3.create();
      vec3.scale(camUp, p[1], y);
      vec3.scale(y, size[1]);
      var result = vec3.create();
      vec3.add(o, x, result);
      vec3.add(result, y);
      return result;
    };

    const topLeft3d = billboardTo3d(origin3d, topLeftLocal, billboardSize, camRight, camUp);
    const topLeft2d = from3dToScreenSpace(topLeft3d);
    const bottomRight3d = billboardTo3d(origin3d, bottomRightLocal, billboardSize, camRight, camUp);
    const bottomRight2d = from3dToScreenSpace(bottomRight3d);
    const left = topLeft2d[0];
    const right = bottomRight2d[0];
    const top = topLeft2d[1];
    const bottom = bottomRight2d[1];
    var isIntersected = false; // Check if point is in the 2d bounds

    if (mouse2d[0] > left && mouse2d[0] < right && mouse2d[1] > top && mouse2d[1] < bottom) {
      if (crs.getType() === Constants.CONTEXT.Sky) {
        isIntersected = true;
      } else if (mouse2d[2] < 0.0 || mouse2d[2] > origin2d[2]) {
        // Check the z value, we do not want to pick a point behind the terrain
        // If the z is negative, that means we are picking outside the terrain,
        // so we always have an intersection
        isIntersected = true;
      }
    }

    return isIntersected;
  };

  var NetworkError = function () {
    var superInstance = Error.apply(null, arguments);
    this.name = "NetworkError";
    this.code = arguments.length > 2 ? arguments[2] : null;
    copyOwnPropertiesFrom(this, superInstance);
    this.layerDescription = null;
  };

  function copyOwnPropertiesFrom(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (propKey) {
      var desc = Object.getOwnPropertyDescriptor(source, propKey);
      Object.defineProperty(target, propKey, desc);
    });
    return target;
  }

  NetworkError.prototype = Object.create(Error.prototype);
  NetworkError.prototype.constructor = NetworkError;

  NetworkError.prototype.setLayerDescription = function (layerDescription) {
    this.layerDescription = layerDescription;
  };

  NetworkError.prototype.getLayerDescription = function () {
    return this.layerDescription;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var _proxyUse = false;
  var _proxyUrl = "";
  var Proxy = {
    /**
     * Sets the use of the proxy.
     * @function setProxyUse
     * @param {boolean} proxyUse Set to true to use a defined proxy otherwise false.
     * @throws {TypeError} proxyUse must be a boolean
     */
    setProxyUse: function (proxyUse) {
      if (typeof proxyUse !== "boolean") {
        throw new TypeError("Proxy.js: proxyUse must be a boolean");
      }

      _proxyUse = proxyUse;
    },

    /**
     * Sets the proxy URL.
     * The proxy should look like http://localhost:8081/?url=
     * @function setProxyUrl
     * @param {string} proxyUrl proxy URL;
     * @throws {TypeError} proxyUrl must be a string
     */
    setProxyUrl: function (proxyUrl) {
      if (typeof proxyUrl !== "string") {
        throw new TypeError("Proxy.js: proxyUrl must be a string");
      }

      _proxyUrl = proxyUrl;
    },

    /**
     * Proxyfy the url is the proxy is used.
     * @function proxify
     * @param {string} url URL to proxify
     * @returns {string} the proxified URL.
     */
    proxify: function (url) {
      if (typeof url !== "string") {
        return url;
      }

      var proxifiedUrl;

      if (_proxyUse === true) {
        if (url.toLowerCase().startsWith("http") === false) {
          proxifiedUrl = url;
        } else if (url.startsWith(_proxyUrl)) {
          proxifiedUrl = url; // No change, proxy always set
        } else {
          proxifiedUrl = _proxyUrl + encodeURIComponent(url); // Add proxy redirection
        }
      } else {
        proxifiedUrl = url;
      }

      return proxifiedUrl;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var Utils = {};
  /**
   * Inherits from an object
   */

  Utils.inherits = function (base, sub) {
    function tempCtor() {}

    tempCtor.prototype = base.prototype;
    sub.prototype = new tempCtor();
    sub.prototype.constructor = sub;
  };
  /**
   *    HSV values in [0..1[
   *    returns [r, g, b] values from 0 to 255
   */


  function hsv_to_rgb(h, s, v) {
    var h_i = Math.floor(h * 6);
    var f = h * 6 - h_i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var r;
    var g;
    var b;

    switch (h_i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;

      default:
        r = 1;
        g = 1;
        b = 1;
    }

    return [r, g, b];
  }
  /**
   * Generates eye-friendly color based on hsv.
   * @return {int[]} rgb array
   */


  Utils.generateColor = function () {
    //use golden ratio
    var golden_ratio_conjugate = 0.618033988749895;
    var h = Math.random();
    h += golden_ratio_conjugate;
    h %= 1;
    return hsv_to_rgb(h, 0.5, 0.95);
  };
  /**
   * Format the given feature identifier to remove special caracters(as ?, [, ], ., etc..) which cannot be used as HTML id's
   * @param {string} id - identifier
   * @return {string} HTML identifier
   */


  Utils.formatId = function (id) {
    var result;

    if (typeof id === "string") {
      result = id.replace(/\s{1,}|\.{1,}|\[{1,}|\]{1,}|\({1,}|\){1,}|~{1,}|\+{1,}|°{1,}|-{1,}|'{1,}|"{1,}/g, "");
    } else {
      result = id;
    }

    return result;
  };
  /**
   * Checks if a value v is between the interval [min, max].
   * @function isValueBetween
   * @param {float} v - value
   * @param {float} min - min value
   * @param {float} max - max value
   * @return {boolean} true when v is between min and max otherwise false
   */


  Utils.isValueBetween = function (v, min, max) {
    return v >= min && v <= max;
  };
  /**
   * Computes base URL from getCapabilities URL.
   * @function computeBaseUrlFromCapabilities
   * @param {string} capabilitiesUrl - getCapabilities URL
   * @param {string[]} parameters - parameters of the getCapabilities
   * @return {string} base URL
   */


  Utils.computeBaseUrlFromCapabilities = function (capabilitiesUrl, parameters) {
    Utils.assert(capabilitiesUrl !== null && capabilitiesUrl.length !== 0, "capabilitiesUrl must not be empty", "Utils.js");
    var url = capabilitiesUrl;

    if (url.indexOf("?") > -1) {
      url = url.substr(0, url.indexOf("?"));
    } // url cannot be undefined because we need to query a getCapabilities or something else with a parameter


    var queryString = capabilitiesUrl.replace(url + "?", "") || capabilitiesUrl;
    var query = Utils.parseQuery(queryString); // we delete all parameters required by a standard.

    for (var i = 0; i < parameters.length; i++) {
      var parameter = parameters[i];
      delete query[parameter];
    } // we build the new Url with remaining parameters.


    var nbParameter = 0;

    for (var key in query) {
      var value = query[key];

      if (nbParameter == 0) {
        url = url + "?" + key + "=" + value;
      } else {
        url = url + "&" + key + "=" + value;
      }

      nbParameter++;
    }

    return url;
  };
  /**
   * Parse query url.
   * @function parseQuery
   * @param {string} str - url
   * @return {{}} a hash of parameter/value
   */


  Utils.parseQuery = function (str) {
    if (typeof str != "string" || str.length == 0) return {};
    var s = str.split("&");
    var s_length = s.length;
    var bit,
        query = {},
        first,
        second;

    for (var i = 0; i < s_length; i++) {
      bit = s[i].split("=");
      first = decodeURIComponent(bit[0]);
      if (first.length == 0) continue;
      second = decodeURIComponent(bit[1]);
      if (typeof query[first] == "undefined") query[first] = second;else if (query[first] instanceof Array) query[first].push(second);else query[first] = [query[first], second];
    }

    return query;
  };
  /**
   * Add parameter to
   * @function addParameterTo
   * @param {string} url - parameter url
   * @param {string} name - parameter name
   * @param {string} value - parameter value
   * @return {string} url updated
   */


  Utils.addParameterTo = function (url, name, value) {
    var separator = "&";

    if (typeof url !== "string" || url.indexOf("?", 0) === -1) {
      separator = "?";
    }

    return url + separator + name + "=" + value;
  };
  /**
   * Parses the base URL.
   * @function parseBaseURL
   * @param {string} url - the URL
   * @return {string} the base URL
   */


  Utils.parseBaseURL = function (url) {
    var result;
    var index = url.indexOf("?");

    if (index == -1) {
      result = url;
    } else {
      result = url.substring(0, url.indexOf("?") + 1);
    }

    return result;
  };
  /**
   * Parses the query string and returns the parameters of the URL.
   * @function parseQueryString
   * @param {string} url - query string
   * @return {{}} parameters of the query string
   */


  Utils.parseQueryString = function (url) {
    var queryString = url.substring(url.indexOf("?") + 1).split("&");
    var params = {};
    var pair; // march and parse

    for (var i = queryString.length - 1; i >= 0; i--) {
      pair = queryString[i].split("=");
      params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
    }

    return params;
  };
  /**
   * Request an URL.
   * @function requestUrl
   * @param {string} url - URL to request
   * @param {string} datatype - datatype of the response
   * @param {string} acceptDatatype - value for the Accept keyword in the header
   * @param {Object} options - options for callback (set to null if no options)
   * @param {Utils~requestCallback} callback - The callback that handles the response.
   * @param {Utils~requestFallback} [fallBack] - The fallback that handles the error.
   * @param {Utils~requestComplete} [complete] - The completeback that is executed afet the callback/fallback
   */


  Utils.requestUrl = function (url, datatype, acceptDatatype, options, callback, fallBack, complete) {
    $__default['default'].ajax({
      type: "GET",
      url: Proxy.proxify(url),
      dataType: datatype,
      beforeSend: function (xhr) {
        xhr.setRequestHeader("Accept", acceptDatatype);
      },
      success: function (response) {
        if (callback) {
          callback(response, options);
        }
      },
      error: function (xhr, ajaxOptions, thrownError) {
        var message;
        var code;

        if (xhr.status === 0) {
          message = "Unreachable URL or No 'Access-Control-Allow-Origin' header is present on the " + url;
          code = 0;
        } else {
          message = thrownError.message ? thrownError.message : thrownError;
          code = thrownError.code ? thrownError.code : -1;

          if (typeof ajaxOptions === "string") {
            message = ajaxOptions + ": " + message;
          }
        }

        if (fallBack) {
          fallBack(new NetworkError(message, "Utils.js", code));
        }
      },
      complete: function (xhr, textSatus) {
        if (complete) {
          complete(xhr, textSatus);
        }
      }
    });
  };
  /**
   * This callback process the response when the request is a success.
   * @callback Utils~requestCallback
   * @param {Object} response - the response of the server
   * @param {Object} options - options
   */

  /**
   * This fallback process the error of the server.
   * @callback Utils~requestFallback
   * @param {string} error
   */

  /**
   * A function to be called when the request finishes (after success and error callbacks are executed).
   * The function gets passed two arguments: The jqXHR (in jQuery 1.4.x, XMLHTTPRequest) object and a
   * string categorizing the status of the request ("success", "notmodified", "nocontent", "error",
   * "timeout", "abort", or "parsererror").
   * @callback Utils~requestComplete
   * @param {Object} xhr - xhr object
   * @param {string} status - status text
   */

  /**
   * Converts UTC hms from date to hours.
   * @function _UT
   * @param {date} date - date
   * @returns {number} hours
   * @private
   */


  function _UT(date) {
    var hour = date.getUTCHours();
    var min = date.getUTCMinutes();
    var sec = date.getUTCSeconds();
    return hour + min / 60 + sec / 3600;
  }
  /**
   * Computes Julian day number at 0 hr UT.
   * @function _J0
   * @param {date} date - date
   * @returns {number} Julian day number at 0 hr UT
   * @private
   */


  function _J0(date) {
    var year = date.getUTCFullYear();
    var month = date.getUTCMonth() + 1;
    var day = date.getUTCDate(); //var UT = _UT(date);
    //TODO check 1721013.5 should be -730531.5 !!!

    return 367 * year - Math.floor(7 / 4 * (year + Math.floor((month + 9) / 12))) + Math.floor(275 * month / 9) + day + 1721013.5;
  }
  /**
   * Computes Julian day.
   * @function JD
   * @param {date} date - date
   * @returns {number} julian day
   * @private
   */


  Utils.JD = function (date) {
    return _J0(date) + _UT(date) / 24;
  };
  /**
   * Computes the Greenwich sidereal time at 0 hr UT.
   * See equation [Seidelmann,1992]
   * @function _GST0
   * @param date date
   * @returns {number} the Greenwich sidereal time at 0 hr UT
   * @private
   */


  function _GST0(date) {
    //JC is Julian centuries between the Julian day J0 and J2000(2,451,545.0)
    var julianCentury = (_J0(date) - 2451545.0) / 36525;
    var GST0 = 100.4606184 + 36000.77004 * julianCentury + 0.000387933 * julianCentury * julianCentury - 2.583e-8 * julianCentury * julianCentury * julianCentury;
    return GST0 % 360;
  }
  /**
   * Computes the Greenwich sidereal time at any other UT time.
   * @function GST
   * @param {date} date - date
   * @returns {number} the Greenwich sidereal time at any other UT time
   */


  Utils.GST = function (date) {
    return (_GST0(date) + 360.98564724 * _UT(date) / 24) % 360;
  };
  /**
   * Computes the local sidereal time.
   * @function LST
   * @param {date} date - date
   * @param {float} longitude - longitude
   * @returns {number}
   */


  Utils.LST = function (date, longitude) {
    return (Utils.GST(date) + longitude) % 360;
  };
  /**
   * Computes the Sidereal Hour Angle
   * @function SHA
   * @param {float} ra - right ascension in decimal degree
   * @returns {number} SHA in decimal degree
   */


  Utils.SHA = function (ra) {
    return 360.0 - 15.0 * ra * 24.0 / 360.0;
  };
  /**
   * Computes the GHA (Greenwich Hour Angle).
   * GHA indicates the position past the plane of the Greenwich meridian measured in degrees. Equivalent to longitude on earth.
   * @function GHA
   * @param {date} date - date
   * @param {float} ra - right ascension in decimal degree
   * @returns {number} Greenwich Hour Angle in decimal degree
   */


  Utils.GHA = function (date, ra) {
    var GHA_Aries = 15.0 * Utils.GST(date) * 24.0 / 360.0;
    return (Utils.SHA(ra) + GHA_Aries) % 360;
  };
  /**
   * Converts longitude/latitude to XYZ
   * @function longLat2XYZ
   * @param {float} longitude - longitude in decimal degree
   * @param {float} latitude - latitude in decimal degree
   * @returns {{x: float, y: float, z: float}} the cartesian coordinates
   */


  Utils.longLat2XYZ = function (longitude, latitude) {
    var latInRadians = Numeric.toRadian(latitude);
    var longInRadians = Numeric.toRadian(longitude);
    var cosLat = Math.cos(latInRadians);
    return {
      x: cosLat * Math.cos(longInRadians),
      y: cosLat * Math.sin(longInRadians),
      z: Math.sin(latInRadians)
    };
  };
  /**
   * Computes the distance of the camera in meters for which the bbox of the target is the camera FOV.
   * @function computeDistanceCameraFromBbox
   * @param {float[]} bbox - bbox of the target
   * @param {float} fov - camera FOV
   * @param {float} planetRadius - planet radius in meters
   * @param {boolean} isFlat - is it a projected CRS
   * @return {float} the distance of the camera in meters.
   */


  Utils.computeDistanceCameraFromBbox = function (bbox, fov, planetRadius, isFlat) {
    var angularDistance1 = Math.abs(bbox[2] - bbox[0]);
    var angularDistance2 = Math.abs(bbox[3] - bbox[1]);
    var angularDistance = Math.max(angularDistance1, angularDistance2);
    var visibleAngularDistance;

    if (isFlat) {
      visibleAngularDistance = angularDistance;
    } else if (angularDistance > 180) {
      visibleAngularDistance = 180;
    } else {
      visibleAngularDistance = angularDistance;
    } //     *            *Center       *
    //      *         * |  *         *
    //        *     *   | a  *     *
    //          * * --b------ *  *
    //           * *          **
    //            *   *   *  *
    //             *    | distance surface/camera
    //               *  |  *
    //                 * *
    //                  Camera


    var a = planetRadius * Math.cos(Numeric.toRadian(0.5 * visibleAngularDistance));
    var b = planetRadius * Math.sin(Numeric.toRadian(0.5 * visibleAngularDistance));
    var c = b / Math.tan(Numeric.toRadian(0.5 * fov));
    var distance = c - (planetRadius - a);
    return distance;
  };
  /**
   * Returns the time format based on time pattern.
   * @function formatResolution
   * @param {string} time pattern
   * @return {TIME_STEP} time format
   * @throws {Error} pattern not supported
   */


  Utils.formatResolution = function (format) {
    var timeResolution;

    if (Utils.aContainsB.call(this, format, "ss")) {
      timeResolution = Constants.TIME_STEP.SECOND;
    } else if (Utils.aContainsB.call(this, format, "mm")) {
      timeResolution = Constants.TIME_STEP.MINUTE;
    } else if (Utils.aContainsB.call(this, format, "HH")) {
      timeResolution = Constants.TIME_STEP.HOUR;
    } else if (Utils.aContainsB.call(this, format, "DD")) {
      timeResolution = Constants.TIME_STEP.DAY;
    } else if (Utils.aContainsB.call(this, format, "MM")) {
      timeResolution = Constants.TIME_STEP.MONTH;
    } else if (Utils.aContainsB.call(this, format, "YYYY")) {
      timeResolution = Constants.TIME_STEP.YEAR;
    } else {
      throw new Error("Pattern not supported", "Utils.js");
    }

    return timeResolution;
  };
  /**
   * Checks if a is contained in the array b.
   * @function aContainsB
   * @param {object} a - element
   * @param {Array} b - array
   * @return true when a is contained in b otherwise false
   */


  Utils.aContainsB = function (a, b) {
    return a.indexOf(b) >= 0;
  };
  /**
   * Convers the time to Moment js.
   * @function convertToMoment
   * @param {Moment|Date} time - time to convert
   * @return {Moment} time as Moment js
   */


  Utils.convertToMoment = function (time) {
    return time instanceof Moment__default['default']() ? time : Moment__default['default']().utc(time);
  };
  /**
   * Checks if "passive" is supported by.
   * @function isPassiveSupported
   * @return {Boolean} true when "passive" mode is supported otherwise false
   */


  Utils.isPassiveSupported = function () {
    var passiveSupported = false;

    try {
      var options = Object.defineProperty({}, "passive", {
        get: function () {
          passiveSupported = true;
          return passiveSupported;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }

    return passiveSupported;
  };
  /**
   * Assert function.
   * @param {Boolean} condition test condition
   * @param {string} message Output when the assert is not true
   * @param {string} [filename] where the error occurs
   * @throws {Error} sent message when the condition is false
   */


  Utils.assert = function (condition, message, filename) {
    if (!condition) {
      if (filename == null) {
        message = filename + ": " + message;
      }

      throw new Error("Assert failed" + (typeof message !== "undefined" ? " - " + message : ""));
    }
  };
  /**
   * Process all geometries excepted a point.
   * @param {Object} geometry - geometry
   * @returns {Object|undefined} bbox - The bounding box of the geometry when a problem happens with the geometry.
   * @returns {number} bbox.north - The northest latitude.
   * @returns {number} bbox.south - The southest latitude.
   * @returns {number} bbox.west - The westest longitude.
   * @returns {number} bbox.east - The eastest longitude.
   * @throws ReferenceError - Unknown geometry type
   */


  function _processBboxForShape(geometry) {
    var coords;
    var checkDateLine;
    var numOuterRings = geometry.type === Constants.GEOMETRY.MultiPolygon || geometry.type === Constants.GEOMETRY.MultiLineString ? geometry.coordinates.length : 1;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = -1 * Number.MAX_VALUE;
    var maxY = -1 * Number.MAX_VALUE;

    for (var j = 0; j < numOuterRings; j++) {
      switch (geometry.type) {
        case Constants.GEOMETRY.MultiPoint:
          coords = geometry.coordinates;
          checkDateLine = false;
          break;

        case Constants.GEOMETRY.Polygon:
          coords = geometry.coordinates[0];
          checkDateLine = true;
          break;

        case Constants.GEOMETRY.MultiPolygon:
          coords = geometry.coordinates[j][0];
          checkDateLine = true;
          break;

        case Constants.GEOMETRY.LineString:
          coords = geometry.coordinates;
          checkDateLine = true;
          break;

        case Constants.GEOMETRY.MultiLineString:
          coords = geometry.coordinates[j];
          checkDateLine = true;
          break;

        default:
          throw new ReferenceError("Unknown geometry type : " + geometry.type, "Utils.js");
      }

      for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i][0]);
        minY = Math.min(minY, coords[i][1]);
        maxX = Math.max(maxX, coords[i][0]);
        maxY = Math.max(maxY, coords[i][1]); // Check if the coordinates cross dateline

        if (checkDateLine && i > 0 && UtilsIntersection.isCrossDateLine(coords[i - 1][0], coords[i][0])) {
          minX = -180;
          maxX = 180;
        }
      }
    }

    return {
      north: maxY,
      south: minY,
      west: minX,
      east: maxX
    };
  }
  /**
   * Computes the bounding box of the geometry.
   * @param {Object} geometry
   * @returns {Object} bbox - The bounding box of the geometry
   * when a problem happens with the geometry.
   * @returns {number} bbox.north - The northest latitude.
   * @returns {number} bbox.south - The southest latitude.
   * @returns {number} bbox.west - The westest longitude.
   * @returns {number} bbox.east - The eastest longitude.
   * @throws ReferenceError - Unknown geometry type
   */


  Utils.getBBox = function (geometry) {
    Utils.assert(geometry && geometry.type && geometry.coordinates && geometry.coordinates.length !== 0, "coordinates and type must be provided in the geometry", "Utils.js");
    var bbox;

    if (geometry.type === Constants.GEOMETRY.Point) {
      var coords = geometry.coordinates;
      bbox = {
        west: coords[0],
        north: coords[1],
        east: coords[0],
        south: coords[1]
      };
    } else {
      bbox = _processBboxForShape(geometry);
    }

    return bbox;
  };
  /*	This work is licensed under Creative Commons GNU LGPL License.

      License: http://creativecommons.org/licenses/LGPL/2.1/
  Version: 0.9
      Author:  Stefan Goessner/2006
      Web:     http://goessner.net/ 
  */


  function parseXml(xml) {
    var dom = null;

    if (window.DOMParser) {
      try {
        dom = new DOMParser().parseFromString(xml, "text/xml");
      } catch (e) {
        dom = null;
      }
    } else if (window.ActiveXObject) {
      try {
        dom = new window.ActiveXObject("Microsoft.XMLDOM");
        dom.async = false;
        if (!dom.loadXML(xml)) // parse error ..
          window.alert(dom.parseError.reason + dom.parseError.srcText);
      } catch (e) {
        dom = null;
      }
    } else alert("cannot parse xml string!");

    return dom;
  }
  /*	This work is licensed under Creative Commons GNU LGPL License.

      License: http://creativecommons.org/licenses/LGPL/2.1/
  Version: 0.9
      Author:  Stefan Goessner/2006
      Web:     http://goessner.net/ 
  */


  Utils.xml2json = function (xmlString, tab) {
    var xml = parseXml(xmlString);
    var X = {
      toObj: function (xml) {
        var o = {};

        if (xml.nodeType == 1) {
          // element node ..
          if (xml.attributes.length) // element with attributes  ..
            for (var i = 0; i < xml.attributes.length; i++) o["@" + xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue || "").toString();

          if (xml.firstChild) {
            // element has child nodes ..
            var textChild = 0,
                cdataChild = 0,
                hasElementChild = false;

            for (var n = xml.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == 1) hasElementChild = true;else if (n.nodeType == 3 && n.nodeValue.match(/[^ \f\n\r\t\v]/)) textChild++; // non-whitespace text
              else if (n.nodeType == 4) cdataChild++; // cdata section node
            }

            if (hasElementChild) {
              if (textChild < 2 && cdataChild < 2) {
                // structured element with evtl. a single text or/and cdata node ..
                X.removeWhite(xml);

                for (n = xml.firstChild; n; n = n.nextSibling) {
                  if (n.nodeType == 3) // text node
                    o["#text"] = X.escape(n.nodeValue);else if (n.nodeType == 4) // cdata node
                    o["#cdata"] = X.escape(n.nodeValue);else if (o[n.nodeName]) {
                    // multiple occurence of element ..
                    if (o[n.nodeName] instanceof Array) o[n.nodeName][o[n.nodeName].length] = X.toObj(n);else o[n.nodeName] = [o[n.nodeName], X.toObj(n)];
                  } // first occurence of element..
                  else o[n.nodeName] = X.toObj(n);
                }
              } else {
                // mixed content
                if (!xml.attributes.length) o = X.escape(X.innerXml(xml));else o["#text"] = X.escape(X.innerXml(xml));
              }
            } else if (textChild) {
              // pure text
              if (!xml.attributes.length) o = X.escape(X.innerXml(xml));else o["#text"] = X.escape(X.innerXml(xml));
            } else if (cdataChild) {
              // cdata
              if (cdataChild > 1) o = X.escape(X.innerXml(xml));else for (n = xml.firstChild; n; n = n.nextSibling) o["#cdata"] = X.escape(n.nodeValue);
            }
          }

          if (!xml.attributes.length && !xml.firstChild) o = null;
        } else if (xml.nodeType == 9) {
          // document.node
          o = X.toObj(xml.documentElement);
        } else alert("unhandled node type: " + xml.nodeType);

        return o;
      },
      toJson: function (o, name, ind) {
        var json = name ? '"' + name + '"' : "";

        if (o instanceof Array) {
          for (var i = 0, n = o.length; i < n; i++) o[i] = X.toJson(o[i], "", ind + "\t");

          json += (name ? ":[" : "[") + (o.length > 1 ? "\n" + ind + "\t" + o.join(",\n" + ind + "\t") + "\n" + ind : o.join("")) + "]";
        } else if (o == null) json += (name && ":") + "null";else if (typeof o == "object") {
          var arr = [];

          for (var m in o) arr[arr.length] = X.toJson(o[m], m, ind + "\t");

          json += (name ? ":{" : "{") + (arr.length > 1 ? "\n" + ind + "\t" + arr.join(",\n" + ind + "\t") + "\n" + ind : arr.join("")) + "}";
        } else if (typeof o == "string") json += (name && ":") + '"' + o.toString() + '"';else json += (name && ":") + o.toString();

        return json;
      },
      innerXml: function (node) {
        var s = "";
        if ("innerHTML" in node) s = node.innerHTML;else {
          var asXml = function (n) {
            var s = "";

            if (n.nodeType == 1) {
              s += "<" + n.nodeName;

              for (var i = 0; i < n.attributes.length; i++) s += " " + n.attributes[i].nodeName + '="' + (n.attributes[i].nodeValue || "").toString() + '"';

              if (n.firstChild) {
                s += ">";

                for (var c = n.firstChild; c; c = c.nextSibling) s += asXml(c);

                s += "</" + n.nodeName + ">";
              } else s += "/>";
            } else if (n.nodeType == 3) s += n.nodeValue;else if (n.nodeType == 4) s += "<![CDATA[" + n.nodeValue + "]]>";

            return s;
          };

          for (var c = node.firstChild; c; c = c.nextSibling) s += asXml(c);
        }
        return s;
      },
      escape: function (txt) {
        return txt.replace(/[\\]/g, "\\\\").replace(/[\"]/g, '\\"').replace(/[\n]/g, "\\n").replace(/[\r]/g, "\\r");
      },
      removeWhite: function (e) {
        e.normalize();

        for (var n = e.firstChild; n;) {
          if (n.nodeType == 3) {
            // text node
            if (!n.nodeValue.match(/[^ \f\n\r\t\v]/)) {
              // pure whitespace text node
              var nxt = n.nextSibling;
              e.removeChild(n);
              n = nxt;
            } else n = n.nextSibling;
          } else if (n.nodeType == 1) {
            // element node
            X.removeWhite(n);
            n = n.nextSibling;
          } // any other node
          else n = n.nextSibling;
        }

        return e;
      }
    };
    if (xml.nodeType == 9) // document node
      xml = xml.documentElement;
    var json = X.toObj(X.removeWhite(xml));
    return json;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
   @name Event
   @class
       A light-weight event object.
   */
  var Event = function () {
    // Event callbacks
    this.callbacks = {};
  };
  /**************************************************************************************************************/

  /**
   Subscribe to an event

   @param name Event name
   <ul>
   <li>startNavigation : called when navigation is started (by the user or through animation)</li>
   <li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
   <li>baseLayersReady : called when the base layers are ready to be displayed</li>
   <li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
   <li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
   <li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
   <li>startLoad : called when a layer start to be loaded</li>
   <li>endLoad : called when layer end loading</li>
   </ul>
   @param callback Callback function
   */


  Event.prototype.subscribe = function (name, callback) {
    if (!this.callbacks[name]) {
      this.callbacks[name] = [callback];
    } else {
      this.callbacks[name].push(callback);
    }
  };
  /**************************************************************************************************************/

  /**
   Unsubscribe to an event

   @param name Event name {@link Globe#subscribe}
   @param callback Callback function
   */


  Event.prototype.unsubscribe = function (name, callback) {
    if (this.callbacks[name]) {
      var i = this.callbacks[name].indexOf(callback);

      if (i !== -1) {
        this.callbacks[name].splice(i, 1);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   Publish an event

   @param name Event name
   @param context Context
   */


  Event.prototype.publish = function (name, context) {
    if (this.callbacks[name]) {
      var cbs = this.callbacks[name];

      for (var i = 0; i < cbs.length; i++) {
        cbs[i](context);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
  	 @name BoundingBox
  	 @class
  	  Bounding Box
  	 @param {float[]} min Min corner as 3D point (array of 3 float)
  	 @param {float[]} max Max corner as 3D point (array of 3 float)
  	 @constructor
  	 */
  var BoundingBox = function (min, max) {
    if (min) {
      this.min = vec3.create(min);
    }

    if (max) {
      this.max = vec3.create(max);
    }
  };
  /**
  	Extent the bounding box with the given point
  	@function extend
  	@memberof BoundingBox.prototype
  	@param {float} x Coord x of extent point
  	@param {float} y Coord y of extent point
  	@param {float} z Coord z of extent point
  */


  BoundingBox.prototype.extend = function (x, y, z) {
    if (!this.min) {
      this.min = vec3.create();
      this.max = vec3.create();
      this.min[0] = x;
      this.min[1] = y;
      this.min[2] = z;
      this.max[0] = x;
      this.max[1] = y;
      this.max[2] = z;
    } else {
      if (x < this.min[0]) {
        this.min[0] = x;
      }

      if (y < this.min[1]) {
        this.min[1] = y;
      }

      if (z < this.min[2]) {
        this.min[2] = z;
      }

      if (x > this.max[0]) {
        this.max[0] = x;
      }

      if (y > this.max[1]) {
        this.max[1] = y;
      }

      if (z > this.max[2]) {
        this.max[2] = z;
      }
    }
  };
  /**
   	Compute the bounding box from an array of vertices
   	@function compute
   	@memberof BoundingBox.prototype
   	@param {float[]} vertices All coords as array of multiple of 3 float)
   	@param {float} length Vertices array length
   	@param {float} stride Stride (3 by default)
   */


  BoundingBox.prototype.compute = function (vertices, length, stride) {
    if (!this.min) {
      this.min = vec3.create();
      this.max = vec3.create();
    }

    this.min[0] = vertices[0];
    this.min[1] = vertices[1];
    this.min[2] = vertices[2];
    this.max[0] = vertices[0];
    this.max[1] = vertices[1];
    this.max[2] = vertices[2];
    var i, j;
    var st = stride || 3;
    var ll = length || vertices.length;

    for (i = st; i < ll; i += st) {
      for (j = 0; j < 3; j++) {
        if (vertices[i + j] < this.min[j]) {
          this.min[j] = vertices[i + j];
        }

        if (vertices[i + j] > this.max[j]) {
          this.max[j] = vertices[i + j];
        }
      }
    }
  };
  /**
   	Get the corner of a bounding box
   	@function getCorner
   	@memberof BoundingBox.prototype
   	@param {float} pos Position
   	@return {?} Corner
   */


  BoundingBox.prototype.getCorner = function (pos) {
    return [pos & 1 ? this.max[0] : this.min[0], pos & 2 ? this.max[1] : this.min[1], pos & 4 ? this.max[2] : this.min[2]];
  };
  /**
   	Get the center of a bounding box
   	@function getCenter
   	@memberof BoundingBox.prototype
   	@return {?} Center
   */


  BoundingBox.prototype.getCenter = function () {
    return [(this.max[0] + this.min[0]) * 0.5, (this.max[1] + this.min[1]) * 0.5, (this.max[2] + this.min[2]) * 0.5];
  };
  /**
   	Get the radius of a bounding box
   	@function getRadius
   	@memberof BoundingBox.prototype
   	@return {float} Radius
   */


  BoundingBox.prototype.getRadius = function () {
    var vec = vec3.create();
    vec3.subtract(this.max, this.min, vec);
    return 0.5 * vec3.length(vec);
  };

  // jshint ignore: start

  /*
   * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
   *
   * This software is provided 'as-is', without any express or implied
   * warranty. In no event will the authors be held liable for any damages
   * arising from the use of this software.
   *
   * Permission is granted to anyone to use this software for any purpose,
   * including commercial applications, and to alter it and redistribute it
   * freely, subject to the following restrictions:
   *
   *    1. The origin of this software must not be misrepresented; you must not
   *    claim that you wrote the original software. If you use this software
   *    in a product, an acknowledgment in the product documentation would be
   *    appreciated but is not required.
   *
   *    2. Altered source versions must be plainly marked as such, and must not
   *    be misrepresented as being the original software.
   *
   *    3. This notice may not be removed or altered from any source
   *    distribution.
   */
  // Modification to plain glMatrix
  //	- Always use Array for MatrixType
  //	- Remove export management
  //	- Remove vec2, mat2, mat3, vec4
  //	- Comments some not needed functions
  //	- Add mat4.project and mat4.rotateVec3
  // Tweak to your liking
  var FLOAT_EPSILON = 0.000001;
  /**
   * @class System-specific optimal array type
   * @name MatrixArray
   */

  var MatrixArray = Array;
  /**
   * @class 3 Dimensional Vector
   * @name vec3
   */

  var vec3$1 = {};
  /**
   * Creates a new instance of a vec3 using the default array type
   * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
   *
   * @param {vec3} [vec] vec3 containing values to initialize with
   *
   * @returns {vec3} New vec3
   */

  vec3$1.create = function (vec) {
    var dest = new MatrixArray(3);

    if (vec) {
      dest[0] = vec[0];
      dest[1] = vec[1];
      dest[2] = vec[2];
    } else {
      dest[0] = dest[1] = dest[2] = 0;
    }

    return dest;
  };
  /**
   * Creates a new instance of a vec3, initializing it with the given arguments
   *
   * @param {number} x X value
   * @param {number} y Y value
   * @param {number} z Z value

   * @returns {vec3} New vec3
   */


  vec3$1.createFrom = function (x, y, z) {
    var dest = new MatrixArray(3);
    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
    return dest;
  };
  /**
   * Copies the values of one vec3 to another
   *
   * @param {vec3} vec vec3 containing values to copy
   * @param {vec3} dest vec3 receiving copied values
   *
   * @returns {vec3} dest
   */


  vec3$1.set = function (vec, dest) {
    dest[0] = vec[0];
    dest[1] = vec[1];
    dest[2] = vec[2];
    return dest;
  };
  /**
   * Compares two vectors for equality within a certain margin of error
   *
   * @param {vec3} a First vector
   * @param {vec3} b Second vector
   *
   * @returns {Boolean} true if a is equivalent to b
   */


  vec3$1.equal = function (a, b) {
    return a === b || Math.abs(a[0] - b[0]) < FLOAT_EPSILON && Math.abs(a[1] - b[1]) < FLOAT_EPSILON && Math.abs(a[2] - b[2]) < FLOAT_EPSILON;
  };
  /**
   * Performs a vector addition
   *
   * @param {vec3} vec First operand
   * @param {vec3} vec2 Second operand
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.add = function (vec, vec2, dest) {
    if (!dest || vec === dest) {
      vec[0] += vec2[0];
      vec[1] += vec2[1];
      vec[2] += vec2[2];
      return vec;
    }

    dest[0] = vec[0] + vec2[0];
    dest[1] = vec[1] + vec2[1];
    dest[2] = vec[2] + vec2[2];
    return dest;
  };
  /**
   * Performs a vector subtraction
   *
   * @param {vec3} vec First operand
   * @param {vec3} vec2 Second operand
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.subtract = function (vec, vec2, dest) {
    if (!dest || vec === dest) {
      vec[0] -= vec2[0];
      vec[1] -= vec2[1];
      vec[2] -= vec2[2];
      return vec;
    }

    dest[0] = vec[0] - vec2[0];
    dest[1] = vec[1] - vec2[1];
    dest[2] = vec[2] - vec2[2];
    return dest;
  };
  /**
   * Performs a vector multiplication
   *
   * @param {vec3} vec First operand
   * @param {vec3} vec2 Second operand
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.multiply = function (vec, vec2, dest) {
    if (!dest || vec === dest) {
      vec[0] *= vec2[0];
      vec[1] *= vec2[1];
      vec[2] *= vec2[2];
      return vec;
    }

    dest[0] = vec[0] * vec2[0];
    dest[1] = vec[1] * vec2[1];
    dest[2] = vec[2] * vec2[2];
    return dest;
  };
  /**
   * Negates the components of a vec3
   *
   * @param {vec3} vec vec3 to negate
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.negate = function (vec, dest) {
    if (!dest) {
      dest = vec;
    }

    dest[0] = -vec[0];
    dest[1] = -vec[1];
    dest[2] = -vec[2];
    return dest;
  };
  /**
   * Multiplies the components of a vec3 by a scalar value
   *
   * @param {vec3} vec vec3 to scale
   * @param {number} val Value to scale by
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.scale = function (vec, val, dest) {
    if (!dest || vec === dest) {
      vec[0] *= val;
      vec[1] *= val;
      vec[2] *= val;
      return vec;
    }

    dest[0] = vec[0] * val;
    dest[1] = vec[1] * val;
    dest[2] = vec[2] * val;
    return dest;
  };
  /**
   * Generates a unit vector of the same direction as the provided vec3
   * If vector length is 0, returns [0, 0, 0]
   *
   * @param {vec3} vec vec3 to normalize
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.normalize = function (vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2],
        len = Math.sqrt(x * x + y * y + z * z);

    if (!len) {
      dest[0] = 0;
      dest[1] = 0;
      dest[2] = 0;
      return dest;
    } else if (len === 1) {
      dest[0] = x;
      dest[1] = y;
      dest[2] = z;
      return dest;
    }

    len = 1 / len;
    dest[0] = x * len;
    dest[1] = y * len;
    dest[2] = z * len;
    return dest;
  };
  /**
   * Generates the cross product of two vec3s
   *
   * @param {vec3} vec First operand
   * @param {vec3} vec2 Second operand
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.cross = function (vec, vec2, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2],
        x2 = vec2[0],
        y2 = vec2[1],
        z2 = vec2[2];
    dest[0] = y * z2 - z * y2;
    dest[1] = z * x2 - x * z2;
    dest[2] = x * y2 - y * x2;
    return dest;
  };
  /**
   * Caclulates the length of a vec3
   *
   * @param {vec3} vec vec3 to calculate length of
   *
   * @returns {number} Length of vec
   */


  vec3$1.length = function (vec) {
    var x = vec[0],
        y = vec[1],
        z = vec[2];
    return Math.sqrt(x * x + y * y + z * z);
  };
  /**
   * Caclulates the squared length of a vec3
   *
   * @param {vec3} vec vec3 to calculate squared length of
   *
   * @returns {number} Squared Length of vec
   */


  vec3$1.squaredLength = function (vec) {
    var x = vec[0],
        y = vec[1],
        z = vec[2];
    return x * x + y * y + z * z;
  };
  /**
   * Caclulates the dot product of two vec3s
   *
   * @param {vec3} vec First operand
   * @param {vec3} vec2 Second operand
   *
   * @returns {number} Dot product of vec and vec2
   */


  vec3$1.dot = function (vec, vec2) {
    return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
  };
  /**
   * Generates a unit vector pointing from one vector to another
   *
   * @param {vec3} vec Origin vec3
   * @param {vec3} vec2 vec3 to point to
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */

  /*   vec3.direction = function (vec, vec2, dest) {
   if (!dest) { dest = vec; }

   var x = vec[0] - vec2[0],
   y = vec[1] - vec2[1],
   z = vec[2] - vec2[2],
   len = Math.sqrt(x * x + y * y + z * z);

   if (!len) {
   dest[0] = 0;
   dest[1] = 0;
   dest[2] = 0;
   return dest;
   }

   len = 1 / len;
   dest[0] = x * len;
   dest[1] = y * len;
   dest[2] = z * len;
   return dest;
   };*/

  /**
   * Performs a linear interpolation between two vec3
   *
   * @param {vec3} vec First vector
   * @param {vec3} vec2 Second vector
   * @param {number} t Interpolation amount between the two inputs
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  vec3$1.lerp = function (vec, vec2, t, dest) {
    if (!dest) {
      dest = vec;
    }

    const oneMinusT = 1 - t;
    dest[0] = oneMinusT * vec[0] + t * vec2[0];
    dest[1] = oneMinusT * vec[1] + t * vec2[1];
    dest[2] = oneMinusT * vec[2] + t * vec2[2];
    return dest;
  };
  /**
   * Calculates the euclidian distance between two vec3
   *
   * Params:
   * @param {vec3} vec First vector
   * @param {vec3} vec2 Second vector
   *
   * @returns {number} Distance between vec and vec2
   */


  vec3$1.dist = function (vec, vec2) {
    var x = vec2[0] - vec[0],
        y = vec2[1] - vec[1],
        z = vec2[2] - vec[2];
    return Math.sqrt(x * x + y * y + z * z);
  };
  /** Vector cross product.
   @param v1 vector
   @param v2 another vector
   @return number vector cross product between this vector and {@code v}
   */


  vec3$1.angle = function (v1, v2) {
    return Math.atan2(vec3$1.length(vec3$1.cross(v1, v2)), vec3$1.dot(v1, v2));
  }; // Pre-allocated to prevent unecessary garbage collection
  //var unprojectMat = null;
  //var unprojectVec = new MatrixArray(4);

  /**
   * Projects the specified vec3 from screen space into object space
   * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
   *
   * @param {vec3} vec Screen-space vector to project
   * @param {mat4} view View matrix
   * @param {mat4} proj Projection matrix
   * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
   * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */

  /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
   if (!dest) { dest = vec; }

   if(!unprojectMat) {
   unprojectMat = mat4.create();
   }

   var m = unprojectMat;
   var v = unprojectVec;

   v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
   v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
   v[2] = 2.0 * vec[2] - 1.0;
   v[3] = 1.0;

   mat4.multiply(proj, view, m);
   if(!mat4.inverse(m)) { return null; }

   mat4.multiplyVec4(m, v);
   if(v[3] === 0.0) { return null; }

   dest[0] = v[0] / v[3];
   dest[1] = v[1] / v[3];
   dest[2] = v[2] / v[3];

   return dest;
   };*/

  /*    var xUnitVec3 = vec3.createFrom(1,0,0);
   var yUnitVec3 = vec3.createFrom(0,1,0);
   var zUnitVec3 = vec3.createFrom(0,0,1);

   var tmpvec3 = vec3.create();*/

  /**
   * Generates a quaternion of rotation between two given normalized vectors
   *
   * @param {vec3} a Normalized source vector
   * @param {vec3} b Normalized target vector
   * @param {quat4} [dest] quat4 receiving operation result.
   *
   * @returns {quat4} dest if specified, a new quat4 otherwise
   */

  /*    vec3.rotationTo = function (a, b, dest) {
   if (!dest) { dest = quat4.create(); }

   var d = vec3.dot(a, b);
   var axis = tmpvec3;
   if (d >= 1.0) {
   quat4.set(identityQuat4, dest);
   } else if (d < (0.000001 - 1.0)) {
   vec3.cross(xUnitVec3, a, axis);
   if (vec3.length(axis) < 0.000001)
   vec3.cross(yUnitVec3, a, axis);
   if (vec3.length(axis) < 0.000001)
   vec3.cross(zUnitVec3, a, axis);
   vec3.normalize(axis);
   quat4.fromAngleAxis(Math.PI, axis, dest);
   } else {
   var s = Math.sqrt((1.0 + d) * 2.0);
   var sInv = 1.0 / s;
   vec3.cross(a, b, axis);
   dest[0] = axis[0] * sInv;
   dest[1] = axis[1] * sInv;
   dest[2] = axis[2] * sInv;
   dest[3] = s * 0.5;
   quat4.normalize(dest);
   }
   if (dest[3] > 1.0) dest[3] = 1.0;
   else if (dest[3] < -1.0) dest[3] = -1.0;
   return dest;
   };*/

  /**
   * Returns a string representation of a vector
   *
   * @param {vec3} vec Vector to represent as a string
   *
   * @returns {string} String representation of vec
   */


  vec3$1.str = function (vec) {
    return "[" + vec[0] + ", " + vec[1] + ", " + vec[2] + "]";
  }; // Vec3 lib used for Astro Math lib


  vec3$1.createZPhi = function (z, phi) {
    var sth = Math.sqrt((1.0 - z) * (1.0 + z));
    var x = sth * Math.cos(phi);
    var y = sth * Math.sin(phi);
    return vec3$1.createFrom(x, y, z);
  };

  vec3$1.createPhiTheta = function (phi, theta) {
    var sth = Math.sin(theta);
    var x = sth * Math.cos(phi);
    var y = sth * Math.sin(phi);
    var z = sth * Math.cos(theta);
    return vec3$1.createFrom(x, y, z);
  };

  vec3$1.add2 = function (vec, vec2) {
    var x1 = vec[0];
    var y1 = vec[1];
    var z1 = vec[2];
    var x2 = vec2[0];
    var y2 = vec2[1];
    var z2 = vec2[2];
    return [x1 + x2, y1 + y2, z1 + z2];
  };

  vec3$1.subtract2 = function (vec, vec2) {
    var x1 = vec[0];
    var y1 = vec[1];
    var z1 = vec[2];
    var x2 = vec2[0];
    var y2 = vec2[1];
    var z2 = vec2[2];
    return [x1 - x2, y1 - y2, z1 - z2];
  };

  vec3$1.flip = function (vec) {
    var x = vec[0];
    var y = vec[1];
    var z = vec[2];
    return [x = -x, y = -y, z = -z];
  };

  vec3$1.scale2 = function (vec, val) {
    var x = vec.x;
    var y = vec.y;
    var z = vec.z;
    return {
      x: x * val,
      y: y *= val,
      z: z *= val
    };
  };

  vec3$1.normalize2 = function (vec) {
    var x = vec[0];
    var y = vec[1];
    var z = vec[2];
    var d = 1.0 / Math.sqrt(x * x + y * y + z * z);
    return [x *= d, y *= d, z *= d];
  };

  vec3$1.cross2 = function (vec, vec2) {
    return {
      x: vec[1] * vec2[2] - vec2[1] * vec[2],
      y: vec[2] * vec2[0] - vec2[2] * vec[0],
      z: vec[0] * vec2[1] - vec2[0] * vec[1]
    };
  };

  vec3$1.length2 = function (vec) {
    var x = vec.x,
        y = vec.y,
        z = vec.z;
    return Math.sqrt(x * x + y * y + z * z);
  };

  vec3$1.dot2 = function (vec, vec2) {
    var x1 = vec.x !== undefined ? vec.x : vec[0];
    var y1 = vec.y !== undefined ? vec.y : vec[1];
    var z1 = vec.z !== undefined ? vec.z : vec[2];
    var x2 = vec2.x !== undefined ? vec2.x : vec2[0];
    var y2 = vec2.y !== undefined ? vec2.y : vec2[1];
    var z2 = vec2.z !== undefined ? vec2.z : vec2[2];
    return x1 * x2 + y1 * y2 + z1 * z2;
  };

  vec3$1.angle2 = function (v1, v2) {
    return Math.atan2(vec3$1.length2(vec3$1.cross2(v1, v2)), vec3$1.dot2(v1, v2));
  }; //

  /**
   * @class 3x3 Matrix
   * @name mat3
   */


  var mat3 = {};
  /**
   * Creates a new isntance of mat3
   *
   * @param {mat3} [mat] mat3 containing values to initialize with
   *
   * @returns {mat3} a new 3x3 matrix
   */

  mat3.create = function (mat) {
    var dest = new MatrixArray(9);

    if (mat) {
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[8] = mat[8];
    }

    return dest;
  };
  /**
   * @class 4x4 Matrix
   * @name mat4
   */


  var mat4$1 = {};
  /**
   * Creates a new instance of a mat4 using the default array type
   * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
   *
   * @param {mat4} [mat] mat4 containing values to initialize with
   *
   * @returns {mat4} New mat4
   */

  mat4$1.create = function (mat) {
    var dest = new MatrixArray(16);

    if (mat) {
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[8] = mat[8];
      dest[9] = mat[9];
      dest[10] = mat[10];
      dest[11] = mat[11];
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
    }

    return dest;
  };
  /**
   * Creates a new instance of a mat4, initializing it with the given arguments
   *
   * @param {number} m00
   * @param {number} m01
   * @param {number} m02
   * @param {number} m03
   * @param {number} m10
   * @param {number} m11
   * @param {number} m12
   * @param {number} m13
   * @param {number} m20
   * @param {number} m21
   * @param {number} m22
   * @param {number} m23
   * @param {number} m30
   * @param {number} m31
   * @param {number} m32
   * @param {number} m33

   * @returns {mat4} New mat4
   */

  /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
   var dest = new MatrixArray(16);

   dest[0] = m00;
   dest[1] = m01;
   dest[2] = m02;
   dest[3] = m03;
   dest[4] = m10;
   dest[5] = m11;
   dest[6] = m12;
   dest[7] = m13;
   dest[8] = m20;
   dest[9] = m21;
   dest[10] = m22;
   dest[11] = m23;
   dest[12] = m30;
   dest[13] = m31;
   dest[14] = m32;
   dest[15] = m33;

   return dest;
   };*/

  /**
   * Copies the values of one mat4 to another
   *
   * @param {mat4} mat mat4 containing values to copy
   * @param {mat4} dest mat4 receiving copied values
   *
   * @returns {mat4} dest
   */


  mat4$1.set = function (mat, dest) {
    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[3];
    dest[4] = mat[4];
    dest[5] = mat[5];
    dest[6] = mat[6];
    dest[7] = mat[7];
    dest[8] = mat[8];
    dest[9] = mat[9];
    dest[10] = mat[10];
    dest[11] = mat[11];
    dest[12] = mat[12];
    dest[13] = mat[13];
    dest[14] = mat[14];
    dest[15] = mat[15];
    return dest;
  };
  /**
   * Compares two matrices for equality within a certain margin of error
   *
   * @param {mat4} a First matrix
   * @param {mat4} b Second matrix
   *
   * @returns {Boolean} true if a is equivalent to b
   */


  mat4$1.equal = function (a, b) {
    return a === b || Math.abs(a[0] - b[0]) < FLOAT_EPSILON && Math.abs(a[1] - b[1]) < FLOAT_EPSILON && Math.abs(a[2] - b[2]) < FLOAT_EPSILON && Math.abs(a[3] - b[3]) < FLOAT_EPSILON && Math.abs(a[4] - b[4]) < FLOAT_EPSILON && Math.abs(a[5] - b[5]) < FLOAT_EPSILON && Math.abs(a[6] - b[6]) < FLOAT_EPSILON && Math.abs(a[7] - b[7]) < FLOAT_EPSILON && Math.abs(a[8] - b[8]) < FLOAT_EPSILON && Math.abs(a[9] - b[9]) < FLOAT_EPSILON && Math.abs(a[10] - b[10]) < FLOAT_EPSILON && Math.abs(a[11] - b[11]) < FLOAT_EPSILON && Math.abs(a[12] - b[12]) < FLOAT_EPSILON && Math.abs(a[13] - b[13]) < FLOAT_EPSILON && Math.abs(a[14] - b[14]) < FLOAT_EPSILON && Math.abs(a[15] - b[15]) < FLOAT_EPSILON;
  };
  /**
   * Sets a mat4 to an identity matrix
   *
   * @param {mat4} dest mat4 to set
   *
   * @returns {mat4} dest
   */


  mat4$1.identity = function (dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    dest[0] = 1;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = 1;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = 0;
    dest[9] = 0;
    dest[10] = 1;
    dest[11] = 0;
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;
    return dest;
  };
  /**
   * Transposes a mat4 (flips the values over the diagonal)
   *
   * @param {mat4} mat mat4 to transpose
   * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
   *
   * @param {mat4} dest is specified, mat otherwise
   */


  mat4$1.transpose = function (mat, dest) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (!dest || mat === dest) {
      var a01 = mat[1],
          a02 = mat[2],
          a03 = mat[3],
          a12 = mat[6],
          a13 = mat[7],
          a23 = mat[11];
      mat[1] = mat[4];
      mat[2] = mat[8];
      mat[3] = mat[12];
      mat[4] = a01;
      mat[6] = mat[9];
      mat[7] = mat[13];
      mat[8] = a02;
      mat[9] = a12;
      mat[11] = mat[14];
      mat[12] = a03;
      mat[13] = a13;
      mat[14] = a23;
      return mat;
    }

    dest[0] = mat[0];
    dest[1] = mat[4];
    dest[2] = mat[8];
    dest[3] = mat[12];
    dest[4] = mat[1];
    dest[5] = mat[5];
    dest[6] = mat[9];
    dest[7] = mat[13];
    dest[8] = mat[2];
    dest[9] = mat[6];
    dest[10] = mat[10];
    dest[11] = mat[14];
    dest[12] = mat[3];
    dest[13] = mat[7];
    dest[14] = mat[11];
    dest[15] = mat[15];
    return dest;
  };
  /**
   * Calculates the determinant of a mat4
   *
   * @param {mat4} mat mat4 to calculate determinant of
   *
   * @returns {number} determinant of mat
   */


  mat4$1.determinant = function (mat) {
    // Cache the matrix values (makes for huge speed increases!)
    var a00 = mat[0],
        a01 = mat[1],
        a02 = mat[2],
        a03 = mat[3],
        a10 = mat[4],
        a11 = mat[5],
        a12 = mat[6],
        a13 = mat[7],
        a20 = mat[8],
        a21 = mat[9],
        a22 = mat[10],
        a23 = mat[11],
        a30 = mat[12],
        a31 = mat[13],
        a32 = mat[14],
        a33 = mat[15];
    return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 + a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 + a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 + a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 + a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 + a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
  };
  /**
   * Calculates the inverse matrix of a mat4
   *
   * @param {mat4} mat mat4 to calculate inverse of
   * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
   *
   * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
   */


  mat4$1.inverse = function (mat, dest) {
    if (!dest) {
      dest = mat;
    } // Cache the matrix values (makes for huge speed increases!)


    var a00 = mat[0],
        a01 = mat[1],
        a02 = mat[2],
        a03 = mat[3],
        a10 = mat[4],
        a11 = mat[5],
        a12 = mat[6],
        a13 = mat[7],
        a20 = mat[8],
        a21 = mat[9],
        a22 = mat[10],
        a23 = mat[11],
        a30 = mat[12],
        a31 = mat[13],
        a32 = mat[14],
        a33 = mat[15],
        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,
        d = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06,
        invDet; // Calculate the determinant

    if (!d) {
      return null;
    }

    invDet = 1 / d;
    dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
    dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
    dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
    dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
    dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
    dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
    dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
    dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
    dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
    dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
    dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
    dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
    dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
    dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
    dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
    dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
    return dest;
  };
  /**
   * Copies the upper 3x3 elements of a mat4 into another mat4
   *
   * @param {mat4} mat mat4 containing values to copy
   * @param {mat4} [dest] mat4 receiving copied values
   *
   * @returns {mat4} dest is specified, a new mat4 otherwise
   */


  mat4$1.toRotationMat = function (mat, dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[3];
    dest[4] = mat[4];
    dest[5] = mat[5];
    dest[6] = mat[6];
    dest[7] = mat[7];
    dest[8] = mat[8];
    dest[9] = mat[9];
    dest[10] = mat[10];
    dest[11] = mat[11];
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;
    return dest;
  };
  /**
   * Copies the upper 3x3 elements of a mat4 into a mat3
   *
   * @param {mat4} mat mat4 containing values to copy
   * @param {mat3} [dest] mat3 receiving copied values
   *
   * @returns {mat3} dest is specified, a new mat3 otherwise
   */


  mat4$1.toMat3 = function (mat, dest) {
    if (!dest) {
      dest = mat3.create();
    }

    dest[0] = mat[0];
    dest[1] = mat[1];
    dest[2] = mat[2];
    dest[3] = mat[4];
    dest[4] = mat[5];
    dest[5] = mat[6];
    dest[6] = mat[8];
    dest[7] = mat[9];
    dest[8] = mat[10];
    return dest;
  };
  /**
   * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
   * The resulting matrix is useful for calculating transformed normals
   *
   * Params:
   * @param {mat4} mat mat4 containing values to invert and copy
   * @param {mat3} [dest] mat3 receiving values
   *
   * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
   */

  /*   mat4.toInverseMat3 = function (mat, dest) {
   // Cache the matrix values (makes for huge speed increases!)
   var a00 = mat[0], a01 = mat[1], a02 = mat[2],
   a10 = mat[4], a11 = mat[5], a12 = mat[6],
   a20 = mat[8], a21 = mat[9], a22 = mat[10],

   b01 = a22 * a11 - a12 * a21,
   b11 = -a22 * a10 + a12 * a20,
   b21 = a21 * a10 - a11 * a20,

   d = a00 * b01 + a01 * b11 + a02 * b21,
   id;

   if (!d) { return null; }
   id = 1 / d;

   if (!dest) { dest = mat3.create(); }

   dest[0] = b01 * id;
   dest[1] = (-a22 * a01 + a02 * a21) * id;
   dest[2] = (a12 * a01 - a02 * a11) * id;
   dest[3] = b11 * id;
   dest[4] = (a22 * a00 - a02 * a20) * id;
   dest[5] = (-a12 * a00 + a02 * a10) * id;
   dest[6] = b21 * id;
   dest[7] = (-a21 * a00 + a01 * a20) * id;
   dest[8] = (a11 * a00 - a01 * a10) * id;

   return dest;
   };*/

  /**
   * Performs a matrix multiplication
   *
   * @param {mat4} mat First operand
   * @param {mat4} mat2 Second operand
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.multiply = function (mat, mat2, dest) {
    if (!dest) {
      dest = mat;
    } // Cache the matrix values (makes for huge speed increases!)


    var a00 = mat[0],
        a01 = mat[1],
        a02 = mat[2],
        a03 = mat[3];
    var a10 = mat[4],
        a11 = mat[5],
        a12 = mat[6],
        a13 = mat[7];
    var a20 = mat[8],
        a21 = mat[9],
        a22 = mat[10],
        a23 = mat[11];
    var a30 = mat[12],
        a31 = mat[13],
        a32 = mat[14],
        a33 = mat[15]; // Cache only the current line of the second matrix

    var b0 = mat2[0],
        b1 = mat2[1],
        b2 = mat2[2],
        b3 = mat2[3];
    dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = mat2[4];
    b1 = mat2[5];
    b2 = mat2[6];
    b3 = mat2[7];
    dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = mat2[8];
    b1 = mat2[9];
    b2 = mat2[10];
    b3 = mat2[11];
    dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = mat2[12];
    b1 = mat2[13];
    b2 = mat2[14];
    b3 = mat2[15];
    dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return dest;
  };
  /**
   * Transforms a vec3 with the given matrix
   * 4th vector component is implicitly '1'
   *
   * @param {mat4} mat mat4 to transform the vector with
   * @param {vec3} vec vec3 to transform
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec3} dest if specified, vec otherwise
   */


  mat4$1.multiplyVec3 = function (mat, vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2];
    dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
    dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
    dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
    return dest;
  };
  /**
   * Transforms a vec4 with the given matrix
   *
   * @param {mat4} mat mat4 to transform the vector with
   * @param {vec4} vec vec4 to transform
   * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
   *
   * @returns {vec4} dest if specified, vec otherwise
   */


  mat4$1.multiplyVec4 = function (mat, vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2],
        w = vec[3];
    dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
    dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
    dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
    dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;
    return dest;
  };
  /**
   Project a vec3
   */


  mat4$1.project = function (mat, vec, dest) {
    if (!dest) {
      dest = vec;
    }

    mat4$1.multiplyVec4(mat, vec, dest);
    var iw = 1.0 / dest[3];
    dest[0] *= iw;
    dest[1] *= iw;
    dest[2] *= iw;
    return dest;
  };
  /**
   * mat4.rotateVec3
   * Rotate a vec3 with the given matrix
   *
   * Params:
   * mat - mat4 to transform the vector with
   * vec - vec3 to transform
   * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
   *
   * Returns:
   * dest if specified, vec otherwise
   */


  mat4$1.rotateVec3 = function (mat, vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2];
    dest[0] = mat[0] * x + mat[4] * y + mat[8] * z;
    dest[1] = mat[1] * x + mat[5] * y + mat[9] * z;
    dest[2] = mat[2] * x + mat[6] * y + mat[10] * z;
    return dest;
  };
  /**
   * Translates a matrix by the given vector
   *
   * @param {mat4} mat mat4 to translate
   * @param {vec3} vec vec3 specifying the translation
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.translate = function (mat, vec, dest) {
    var x = vec[0],
        y = vec[1],
        z = vec[2],
        a00,
        a01,
        a02,
        a03,
        a10,
        a11,
        a12,
        a13,
        a20,
        a21,
        a22,
        a23;

    if (!dest || mat === dest) {
      mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
      mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
      mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
      mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
      return mat;
    }

    a00 = mat[0];
    a01 = mat[1];
    a02 = mat[2];
    a03 = mat[3];
    a10 = mat[4];
    a11 = mat[5];
    a12 = mat[6];
    a13 = mat[7];
    a20 = mat[8];
    a21 = mat[9];
    a22 = mat[10];
    a23 = mat[11];
    dest[0] = a00;
    dest[1] = a01;
    dest[2] = a02;
    dest[3] = a03;
    dest[4] = a10;
    dest[5] = a11;
    dest[6] = a12;
    dest[7] = a13;
    dest[8] = a20;
    dest[9] = a21;
    dest[10] = a22;
    dest[11] = a23;
    dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
    dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
    dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
    dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
    return dest;
  };
  /**
   * Scales a matrix by the given vector
   *
   * @param {mat4} mat mat4 to scale
   * @param {vec3} vec vec3 specifying the scale for each axis
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @param {mat4} dest if specified, mat otherwise
   */


  mat4$1.scale = function (mat, vec, dest) {
    var x = vec[0],
        y = vec[1],
        z = vec[2];

    if (!dest || mat === dest) {
      mat[0] *= x;
      mat[1] *= x;
      mat[2] *= x;
      mat[3] *= x;
      mat[4] *= y;
      mat[5] *= y;
      mat[6] *= y;
      mat[7] *= y;
      mat[8] *= z;
      mat[9] *= z;
      mat[10] *= z;
      mat[11] *= z;
      return mat;
    }

    dest[0] = mat[0] * x;
    dest[1] = mat[1] * x;
    dest[2] = mat[2] * x;
    dest[3] = mat[3] * x;
    dest[4] = mat[4] * y;
    dest[5] = mat[5] * y;
    dest[6] = mat[6] * y;
    dest[7] = mat[7] * y;
    dest[8] = mat[8] * z;
    dest[9] = mat[9] * z;
    dest[10] = mat[10] * z;
    dest[11] = mat[11] * z;
    dest[12] = mat[12];
    dest[13] = mat[13];
    dest[14] = mat[14];
    dest[15] = mat[15];
    return dest;
  };
  /**
   * Rotates a matrix by the given angle around the specified axis
   * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
   *
   * @param {mat4} mat mat4 to rotate
   * @param {number} angle Angle (in radians) to rotate
   * @param {vec3} axis vec3 representing the axis to rotate around
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.rotate = function (mat, angle, axis, dest) {
    var x = axis[0],
        y = axis[1],
        z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s,
        c,
        t,
        a00,
        a01,
        a02,
        a03,
        a10,
        a11,
        a12,
        a13,
        a20,
        a21,
        a22,
        a23,
        b00,
        b01,
        b02,
        b10,
        b11,
        b12,
        b20,
        b21,
        b22;

    if (!len) {
      return null;
    }

    if (len !== 1) {
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
    }

    s = Math.sin(angle);
    c = Math.cos(angle);
    t = 1 - c;
    a00 = mat[0];
    a01 = mat[1];
    a02 = mat[2];
    a03 = mat[3];
    a10 = mat[4];
    a11 = mat[5];
    a12 = mat[6];
    a13 = mat[7];
    a20 = mat[8];
    a21 = mat[9];
    a22 = mat[10];
    a23 = mat[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;

    if (!dest) {
      dest = mat;
    } else if (mat !== dest) {
      // If the source and destination differ, copy the unchanged last row
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
    } // Perform rotation-specific matrix multiplication


    dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
    dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
    dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
    dest[3] = a03 * b00 + a13 * b01 + a23 * b02;
    dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
    dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
    dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
    dest[7] = a03 * b10 + a13 * b11 + a23 * b12;
    dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
    dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
    dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
    dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return dest;
  };
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} mat mat4 to rotate
   * @param {number} angle Angle (in radians) to rotate
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.rotateX = function (mat, angle, dest) {
    var s = Math.sin(angle),
        c = Math.cos(angle),
        a10 = mat[4],
        a11 = mat[5],
        a12 = mat[6],
        a13 = mat[7],
        a20 = mat[8],
        a21 = mat[9],
        a22 = mat[10],
        a23 = mat[11];

    if (!dest) {
      dest = mat;
    } else if (mat !== dest) {
      // If the source and destination differ, copy the unchanged rows
      dest[0] = mat[0];
      dest[1] = mat[1];
      dest[2] = mat[2];
      dest[3] = mat[3];
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
    } // Perform axis-specific matrix multiplication


    dest[4] = a10 * c + a20 * s;
    dest[5] = a11 * c + a21 * s;
    dest[6] = a12 * c + a22 * s;
    dest[7] = a13 * c + a23 * s;
    dest[8] = a10 * -s + a20 * c;
    dest[9] = a11 * -s + a21 * c;
    dest[10] = a12 * -s + a22 * c;
    dest[11] = a13 * -s + a23 * c;
    return dest;
  };
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} mat mat4 to rotate
   * @param {number} angle Angle (in radians) to rotate
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.rotateY = function (mat, angle, dest) {
    var s = Math.sin(angle),
        c = Math.cos(angle),
        a00 = mat[0],
        a01 = mat[1],
        a02 = mat[2],
        a03 = mat[3],
        a20 = mat[8],
        a21 = mat[9],
        a22 = mat[10],
        a23 = mat[11];

    if (!dest) {
      dest = mat;
    } else if (mat !== dest) {
      // If the source and destination differ, copy the unchanged rows
      dest[4] = mat[4];
      dest[5] = mat[5];
      dest[6] = mat[6];
      dest[7] = mat[7];
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
    } // Perform axis-specific matrix multiplication


    dest[0] = a00 * c + a20 * -s;
    dest[1] = a01 * c + a21 * -s;
    dest[2] = a02 * c + a22 * -s;
    dest[3] = a03 * c + a23 * -s;
    dest[8] = a00 * s + a20 * c;
    dest[9] = a01 * s + a21 * c;
    dest[10] = a02 * s + a22 * c;
    dest[11] = a03 * s + a23 * c;
    return dest;
  };
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} mat mat4 to rotate
   * @param {number} angle Angle (in radians) to rotate
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
   *
   * @returns {mat4} dest if specified, mat otherwise
   */


  mat4$1.rotateZ = function (mat, angle, dest) {
    var s = Math.sin(angle),
        c = Math.cos(angle),
        a00 = mat[0],
        a01 = mat[1],
        a02 = mat[2],
        a03 = mat[3],
        a10 = mat[4],
        a11 = mat[5],
        a12 = mat[6],
        a13 = mat[7];

    if (!dest) {
      dest = mat;
    } else if (mat !== dest) {
      // If the source and destination differ, copy the unchanged last row
      dest[8] = mat[8];
      dest[9] = mat[9];
      dest[10] = mat[10];
      dest[11] = mat[11];
      dest[12] = mat[12];
      dest[13] = mat[13];
      dest[14] = mat[14];
      dest[15] = mat[15];
    } // Perform axis-specific matrix multiplication


    dest[0] = a00 * c + a10 * s;
    dest[1] = a01 * c + a11 * s;
    dest[2] = a02 * c + a12 * s;
    dest[3] = a03 * c + a13 * s;
    dest[4] = a00 * -s + a10 * c;
    dest[5] = a01 * -s + a11 * c;
    dest[6] = a02 * -s + a12 * c;
    dest[7] = a03 * -s + a13 * c;
    return dest;
  };
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */


  mat4$1.frustum = function (left, right, bottom, top, near, far, dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    var rl = right - left,
        tb = top - bottom,
        fn = far - near;
    dest[0] = near * 2 / rl;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = near * 2 / tb;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = (right + left) / rl;
    dest[9] = (top + bottom) / tb;
    dest[10] = -(far + near) / fn;
    dest[11] = -1;
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = -(far * near * 2) / fn;
    dest[15] = 0;
    return dest;
  };
  /**
   * Generates a perspective projection matrix with the given bounds
   *
   * @param {number} fovy Vertical field of view
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */


  mat4$1.perspective = function (fovy, aspect, near, far, dest) {
    var top = near * Math.tan(fovy * Math.PI / 360.0),
        right = top * aspect;
    return mat4$1.frustum(-right, right, -top, top, near, far, dest);
  };
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */


  mat4$1.ortho = function (left, right, bottom, top, near, far, dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    var rl = right - left,
        tb = top - bottom,
        fn = far - near;
    dest[0] = 2 / rl;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 0;
    dest[4] = 0;
    dest[5] = 2 / tb;
    dest[6] = 0;
    dest[7] = 0;
    dest[8] = 0;
    dest[9] = 0;
    dest[10] = -2 / fn;
    dest[11] = 0;
    dest[12] = -(left + right) / rl;
    dest[13] = -(top + bottom) / tb;
    dest[14] = -(far + near) / fn;
    dest[15] = 1;
    return dest;
  };
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis
   *
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing "up"
   * @param {mat4} [dest] mat4 frustum matrix will be written into
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */


  mat4$1.lookAt = function (eye, center, up, dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    var x0,
        x1,
        x2,
        y0,
        y1,
        y2,
        z0,
        z1,
        z2,
        len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (eyex === centerx && eyey === centery && eyez === centerz) {
      return mat4$1.identity(dest);
    } //vec3.direction(eye, center, z);


    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz; // normalize (no check needed for 0 because of early return)

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len; //vec3.normalize(vec3.cross(up, z, x));

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    } //vec3.normalize(vec3.cross(z, x, y));


    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    dest[0] = x0;
    dest[1] = y0;
    dest[2] = z0;
    dest[3] = 0;
    dest[4] = x1;
    dest[5] = y1;
    dest[6] = z1;
    dest[7] = 0;
    dest[8] = x2;
    dest[9] = y2;
    dest[10] = z2;
    dest[11] = 0;
    dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    dest[15] = 1;
    return dest;
  };
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     var quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {quat4} quat Rotation quaternion
   * @param {vec3} vec Translation vector
   * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */

  /*    mat4.fromRotationTranslation = function (quat, vec, dest) {
   if (!dest) { dest = mat4.create(); }

   // Quaternion math
   var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
   x2 = x + x,
   y2 = y + y,
   z2 = z + z,

   xx = x * x2,
   xy = x * y2,
   xz = x * z2,
   yy = y * y2,
   yz = y * z2,
   zz = z * z2,
   wx = w * x2,
   wy = w * y2,
   wz = w * z2;

   dest[0] = 1 - (yy + zz);
   dest[1] = xy + wz;
   dest[2] = xz - wy;
   dest[3] = 0;
   dest[4] = xy - wz;
   dest[5] = 1 - (xx + zz);
   dest[6] = yz + wx;
   dest[7] = 0;
   dest[8] = xz + wy;
   dest[9] = yz - wx;
   dest[10] = 1 - (xx + yy);
   dest[11] = 0;
   dest[12] = vec[0];
   dest[13] = vec[1];
   dest[14] = vec[2];
   dest[15] = 1;

   return dest;
   };*/

  /**
   * Returns a string representation of a mat4
   *
   * @param {mat4} mat mat4 to represent as a string
   *
   * @returns {string} String representation of mat
   */


  mat4$1.str = function (mat) {
    return "[" + mat[0] + ", " + mat[1] + ", " + mat[2] + ", " + mat[3] + ", " + mat[4] + ", " + mat[5] + ", " + mat[6] + ", " + mat[7] + ", " + mat[8] + ", " + mat[9] + ", " + mat[10] + ", " + mat[11] + ", " + mat[12] + ", " + mat[13] + ", " + mat[14] + ", " + mat[15] + "]";
  };
  /**
   * @class Quaternion
   * @name quat4
   */


  var quat4$1 = {};
  /**
   * Creates a new instance of a quat4 using the default array type
   * Any javascript array containing at least 4 numeric elements can serve as a quat4
   *
   * @param {quat4} [quat] quat4 containing values to initialize with
   *
   * @returns {quat4} New quat4
   */

  quat4$1.create = function (quat) {
    var dest = new MatrixArray(4);

    if (quat) {
      dest[0] = quat[0];
      dest[1] = quat[1];
      dest[2] = quat[2];
      dest[3] = quat[3];
    } else {
      dest[0] = dest[1] = dest[2] = dest[3] = 0;
    }

    return dest;
  };
  /**
   * Creates a new instance of a quat4, initializing it with the given arguments
   *
   * @param {number} x X value
   * @param {number} y Y value
   * @param {number} z Z value
   * @param {number} w W value

   * @returns {quat4} New quat4
   */


  quat4$1.createFrom = function (x, y, z, w) {
    var dest = new MatrixArray(4);
    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
    dest[3] = w;
    return dest;
  };
  /**
   * Copies the values of one quat4 to another
   *
   * @param {quat4} quat quat4 containing values to copy
   * @param {quat4} dest quat4 receiving copied values
   *
   * @returns {quat4} dest
   */


  quat4$1.set = function (quat, dest) {
    dest[0] = quat[0];
    dest[1] = quat[1];
    dest[2] = quat[2];
    dest[3] = quat[3];
    return dest;
  };
  /**
   * Compares two quaternions for equality within a certain margin of error
   *
   * @param {quat4} a First vector
   * @param {quat4} b Second vector
   *
   * @returns {Boolean} true if a is equivalent to b
   */


  quat4$1.equal = function (a, b) {
    return a === b || Math.abs(a[0] - b[0]) < FLOAT_EPSILON && Math.abs(a[1] - b[1]) < FLOAT_EPSILON && Math.abs(a[2] - b[2]) < FLOAT_EPSILON && Math.abs(a[3] - b[3]) < FLOAT_EPSILON;
  };
  /**
   * Creates a new identity Quat4
   *
   * @param {quat4} [dest] quat4 receiving copied values
   *
   * @returns {quat4} dest is specified, new quat4 otherwise
   */


  quat4$1.identity = function (dest) {
    if (!dest) {
      dest = quat4$1.create();
    }

    dest[0] = 0;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 1;
    return dest;
  }; //var identityQuat4 = quat4.identity();

  /**
   * Calculates the W component of a quat4 from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   *
   * @param {quat4} quat quat4 to calculate W component of
   * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.calculateW = function (quat, dest) {
    var x = quat[0],
        y = quat[1],
        z = quat[2];

    if (!dest || quat === dest) {
      quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
      return quat;
    }

    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
    dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return dest;
  };
  /**
   * Calculates the dot product of two quaternions
   *
   * @param {quat4} quat First operand
   * @param {quat4} quat2 Second operand
   *
   * @return {number} Dot product of quat and quat2
   */


  quat4$1.dot = function (quat, quat2) {
    return quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3];
  };
  /**
   * Calculates the inverse of a quat4
   *
   * @param {quat4} quat quat4 to calculate inverse of
   * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.inverse = function (quat, dest) {
    var q0 = quat[0],
        q1 = quat[1],
        q2 = quat[2],
        q3 = quat[3],
        dot = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3,
        invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    if (!dest || quat === dest) {
      quat[0] *= -invDot;
      quat[1] *= -invDot;
      quat[2] *= -invDot;
      quat[3] *= invDot;
      return quat;
    }

    dest[0] = -quat[0] * invDot;
    dest[1] = -quat[1] * invDot;
    dest[2] = -quat[2] * invDot;
    dest[3] = quat[3] * invDot;
    return dest;
  };
  /**
   * Calculates the conjugate of a quat4
   * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
   *
   * @param {quat4} quat quat4 to calculate conjugate of
   * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.conjugate = function (quat, dest) {
    if (!dest || quat === dest) {
      quat[0] *= -1;
      quat[1] *= -1;
      quat[2] *= -1;
      return quat;
    }

    dest[0] = -quat[0];
    dest[1] = -quat[1];
    dest[2] = -quat[2];
    dest[3] = quat[3];
    return dest;
  };
  /**
   * Calculates the length of a quat4
   *
   * Params:
   * @param {quat4} quat quat4 to calculate length of
   *
   * @returns Length of quat
   */


  quat4$1.length = function (quat) {
    var x = quat[0],
        y = quat[1],
        z = quat[2],
        w = quat[3];
    return Math.sqrt(x * x + y * y + z * z + w * w);
  };
  /**
   * Generates a unit quaternion of the same direction as the provided quat4
   * If quaternion length is 0, returns [0, 0, 0, 0]
   *
   * @param {quat4} quat quat4 to normalize
   * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.normalize = function (quat, dest) {
    if (!dest) {
      dest = quat;
    }

    var x = quat[0],
        y = quat[1],
        z = quat[2],
        w = quat[3],
        len = Math.sqrt(x * x + y * y + z * z + w * w);

    if (len === 0) {
      dest[0] = 0;
      dest[1] = 0;
      dest[2] = 0;
      dest[3] = 0;
      return dest;
    }

    len = 1 / len;
    dest[0] = x * len;
    dest[1] = y * len;
    dest[2] = z * len;
    dest[3] = w * len;
    return dest;
  };
  /**
   * Performs quaternion addition
   *
   * @param {quat4} quat First operand
   * @param {quat4} quat2 Second operand
   * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.add = function (quat, quat2, dest) {
    if (!dest || quat === dest) {
      quat[0] += quat2[0];
      quat[1] += quat2[1];
      quat[2] += quat2[2];
      quat[3] += quat2[3];
      return quat;
    }

    dest[0] = quat[0] + quat2[0];
    dest[1] = quat[1] + quat2[1];
    dest[2] = quat[2] + quat2[2];
    dest[3] = quat[3] + quat2[3];
    return dest;
  };
  /**
   * Performs a quaternion multiplication
   *
   * @param {quat4} quat First operand
   * @param {quat4} quat2 Second operand
   * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.multiply = function (quat, quat2, dest) {
    if (!dest) {
      dest = quat;
    }

    var qax = quat[0],
        qay = quat[1],
        qaz = quat[2],
        qaw = quat[3],
        qbx = quat2[0],
        qby = quat2[1],
        qbz = quat2[2],
        qbw = quat2[3];
    dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return dest;
  };
  /**
   * Transforms a vec3 with the given quaternion
   *
   * @param {quat4} quat quat4 to transform the vector with
   * @param {vec3} vec vec3 to transform
   * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
   *
   * @returns dest if specified, vec otherwise
   */


  quat4$1.multiplyVec3 = function (quat, vec, dest) {
    if (!dest) {
      dest = vec;
    }

    var x = vec[0],
        y = vec[1],
        z = vec[2],
        qx = quat[0],
        qy = quat[1],
        qz = quat[2],
        qw = quat[3],
        // calculate quat * vec
    ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return dest;
  };
  /**
   * Multiplies the components of a quaternion by a scalar value
   *
   * @param {quat4} quat to scale
   * @param {number} val Value to scale by
   * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.scale = function (quat, val, dest) {
    if (!dest || quat === dest) {
      quat[0] *= val;
      quat[1] *= val;
      quat[2] *= val;
      quat[3] *= val;
      return quat;
    }

    dest[0] = quat[0] * val;
    dest[1] = quat[1] * val;
    dest[2] = quat[2] * val;
    dest[3] = quat[3] * val;
    return dest;
  };
  /**
   * Calculates a 4x4 matrix from the given quat4
   *
   * @param {quat4} quat quat4 to create matrix from
   * @param {mat4} [dest] mat4 receiving operation result
   *
   * @returns {mat4} dest if specified, a new mat4 otherwise
   */


  quat4$1.toMat4 = function (quat, dest) {
    if (!dest) {
      dest = mat4$1.create();
    }

    var x = quat[0],
        y = quat[1],
        z = quat[2],
        w = quat[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;
    dest[0] = 1 - (yy + zz);
    dest[1] = xy + wz;
    dest[2] = xz - wy;
    dest[3] = 0;
    dest[4] = xy - wz;
    dest[5] = 1 - (xx + zz);
    dest[6] = yz + wx;
    dest[7] = 0;
    dest[8] = xz + wy;
    dest[9] = yz - wx;
    dest[10] = 1 - (xx + yy);
    dest[11] = 0;
    dest[12] = 0;
    dest[13] = 0;
    dest[14] = 0;
    dest[15] = 1;
    return dest;
  };
  /**
   * Performs a spherical linear interpolation between two quat4
   *
   * @param {quat4} quat First quaternion
   * @param {quat4} quat2 Second quaternion
   * @param {number} slerp Interpolation amount between the two inputs
   * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
   *
   * @returns {quat4} dest if specified, quat otherwise
   */


  quat4$1.slerp = function (quat, quat2, slerp, dest) {
    if (!dest) {
      dest = quat;
    }

    var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
        halfTheta,
        sinHalfTheta,
        ratioA,
        ratioB;

    if (Math.abs(cosHalfTheta) >= 1.0) {
      if (dest !== quat) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];
      }

      return dest;
    }

    halfTheta = Math.acos(cosHalfTheta);
    sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    if (Math.abs(sinHalfTheta) < 0.001) {
      dest[0] = quat[0] * 0.5 + quat2[0] * 0.5;
      dest[1] = quat[1] * 0.5 + quat2[1] * 0.5;
      dest[2] = quat[2] * 0.5 + quat2[2] * 0.5;
      dest[3] = quat[3] * 0.5 + quat2[3] * 0.5;
      return dest;
    }

    ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
    ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;
    dest[0] = quat[0] * ratioA + quat2[0] * ratioB;
    dest[1] = quat[1] * ratioA + quat2[1] * ratioB;
    dest[2] = quat[2] * ratioA + quat2[2] * ratioB;
    dest[3] = quat[3] * ratioA + quat2[3] * ratioB;
    return dest;
  };
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * If dest is omitted, a new quaternion will be created.
   *
   * @param {mat3}  mat    the rotation matrix
   * @param {quat4} [dest] an optional receiving quaternion
   *
   * @returns {quat4} the quaternion constructed from the rotation matrix
   *
   */


  quat4$1.fromRotationMatrix = function (mat, dest) {
    if (!dest) dest = quat4$1.create(); // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".

    var fTrace = mat[0] + mat[4] + mat[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      dest[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      dest[0] = (mat[7] - mat[5]) * fRoot;
      dest[1] = (mat[2] - mat[6]) * fRoot;
      dest[2] = (mat[3] - mat[1]) * fRoot;
    } else {
      // |w| <= 1/2
      var s_iNext = quat4$1.fromRotationMatrix.s_iNext = quat4$1.fromRotationMatrix.s_iNext || [1, 2, 0];
      var i = 0;
      if (mat[4] > mat[0]) i = 1;
      if (mat[8] > mat[i * 3 + i]) i = 2;
      var j = s_iNext[i];
      var k = s_iNext[j];
      fRoot = Math.sqrt(mat[i * 3 + i] - mat[j * 3 + j] - mat[k * 3 + k] + 1.0);
      dest[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      dest[3] = (mat[k * 3 + j] - mat[j * 3 + k]) * fRoot;
      dest[j] = (mat[j * 3 + i] + mat[i * 3 + j]) * fRoot;
      dest[k] = (mat[k * 3 + i] + mat[i * 3 + k]) * fRoot;
    }

    return dest;
  };
  /**
   * Sets a quat4 to the Identity and returns it.
   *
   * @param {quat4} [dest] quat4 to set. If omitted, a
   * new quat4 will be created.
   *
   * @returns {quat4} dest
   */


  quat4$1.identity = function (dest) {
    if (!dest) dest = quat4$1.create();
    dest[0] = 0;
    dest[1] = 0;
    dest[2] = 0;
    dest[3] = 1;
    return dest;
  };
  /**
   * Sets a quat4 from the given angle and rotation axis,
   * then returns it. If dest is not given, a new quat4 is created.
   *
   * @param {Number} angle  the angle in radians
   * @param {vec3}   axis   the axis around which to rotate
   * @param {quat4}  [dest] the optional quat4 to store the result
   *
   * @returns {quat4} dest
   **/


  quat4$1.fromAngleAxis = function (angle, axis, dest) {
    // The quaternion representing the rotation is
    //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
    if (!dest) dest = quat4$1.create();
    var half = angle * 0.5;
    var s = Math.sin(half);
    dest[3] = Math.cos(half);
    dest[0] = s * axis[0];
    dest[1] = s * axis[1];
    dest[2] = s * axis[2];
    return dest;
  };
  /**
   * Stores the angle and axis in a vec4, where the XYZ components represent
   * the axis and the W (4th) component is the angle in radians.
   *
   * If dest is not given, src will be modified in place and returned, after
   * which it should not be considered not a quaternion (just an axis and angle).
   *
   * @param {quat4} quat   the quaternion whose angle and axis to store
   * @param {vec4}  [dest] the optional vec4 to receive the data
   *
   * @returns {vec4} dest
   */


  quat4$1.toAngleAxis = function (src, dest) {
    if (!dest) dest = src; // The quaternion representing the rotation is
    //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

    var sqrlen = src[0] * src[0] + src[1] * src[1] + src[2] * src[2];

    if (sqrlen > 0) {
      dest[3] = 2 * Math.acos(src[3]);
      var invlen = 1.0 / Math.sqrt(sqrlen);
      dest[0] = src[0] * invlen;
      dest[1] = src[1] * invlen;
      dest[2] = src[2] * invlen;
    } else {
      // angle is 0 (mod 2*pi), so any axis will do
      dest[3] = 0;
      dest[0] = 1;
      dest[1] = 0;
      dest[2] = 0;
    }

    return dest;
  };
  /**
   * Returns a string representation of a quaternion
   *
   * @param {quat4} quat quat4 to represent as a string
   *
   * @returns {string} String representation of quat
   */


  quat4$1.str = function (quat) {
    return "[" + quat[0] + ", " + quat[1] + ", " + quat[2] + ", " + quat[3] + "]";
  };
  /*
   * Exports
   */


  window.vec3 = vec3$1;
  window.mat4 = mat4$1;
  window.quat4 = quat4$1;

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       Tile constructor
       @name Tile
       @constructor
       */

  var Tile = function () {
    // Parent/child relationship
    this.parent = null;
    this.parentIndex = -1;
    this.children = null; // Graphics data to render the tile

    this.vertices = null;
    this.texture = null;
    this.vertexBuffer = null;
    this.texTransform = [1.0, 1.0, 0.0, 0.0]; // Tile spatial data

    this.matrix = null;
    this.inverseMatrix = null;
    this.bbox = new BoundingBox(); // For culling

    this.radius = 0.0;
    this.distance = 0.0;
    this.closestPointToEye = [0.0, 0.0, 0.0]; // Specific object to store extension from renderers

    this.extension = {}; // For debug
    //this.color = [ Math.random(), Math.random(), Math.random() ];

    this.state = Tile.State.NONE; // Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...

    this.config = null;
  };
  /**************************************************************************************************************/

  /**
   *    Tile state enumerations
   */


  Tile.State = {
    ERROR: -10,
    NONE: 0,
    REQUESTED: 1,
    LOADING: 2,
    LOADED: 3
  };
  /**************************************************************************************************************/

  /**
   * Compute position on the tile using normalized coordinate between [0,size-1]
   */

  Tile.prototype.computePosition = function (u, v) {
    var size = this.config.tesselation;
    u = Math.min(size - 1, Math.max(0, u));
    v = Math.min(size - 1, Math.max(0, v));
    var vFloor = Math.floor(v);
    var vFrac = v - vFloor;
    var uFloor = Math.floor(u);
    var uFrac = u - uFloor;
    var vertexSize = this.config.vertexSize;
    var vertexOffset = vertexSize * (vFloor * size + uFloor);
    var vec = [0.0, 0.0, 0.0];

    for (var i = 0; i < 3; i++) {
      vec[i] = (1.0 - vFrac) * (1.0 - uFrac) * this.vertices[vertexOffset + i] + vFrac * (1.0 - uFrac) * this.vertices[vertexOffset + vertexSize * size + i] + vFrac * uFrac * this.vertices[vertexOffset + vertexSize * size + vertexSize + i] + (1.0 - vFrac) * uFrac * this.vertices[vertexOffset + vertexSize + i];
    }

    return vec;
  };
  /**************************************************************************************************************/

  /**
   *    Initialize the tile from its parent
   */


  Tile.prototype.initFromParent = function (parent, i, j) {
    this.parent = parent;
    this.parentIndex = j * 2 + i;
    this.matrix = parent.matrix;
    this.inverseMatrix = parent.inverseMatrix;
    this.texture = parent.texture;
    this.config = parent.config;
    this.vertexBuffer = parent.vertexBuffer; // Recompute the bounding box
    // Very fast and coarse version but it does not work with HEALPix tiling
    //var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
    //var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
    //var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
    //var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];

    var size = this.config.tesselation;
    var halfTesselation = (size - 1) / 2;

    for (var n = 0; n <= halfTesselation; n++) {
      var offset = this.config.vertexSize * ((n + j * halfTesselation) * size + i * halfTesselation);

      for (var k = 0; k <= halfTesselation; k++) {
        this.bbox.extend(parent.vertices[offset], parent.vertices[offset + 1], parent.vertices[offset + 2]);
        offset += this.config.vertexSize;
      }
    } // Compute the bounding box


    this.radius = this.bbox.getRadius(); // Init extension

    for (var x in parent.extension) {
      if (parent.extension.hasOwnProperty(x)) {
        var e = parent.extension[x];

        if (e.initChild) {
          e.initChild(this, i, j);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   *    Test if the tile needs to be refined
   */


  Tile.prototype.needsToBeRefined = function (renderContext) {
    if (this.distance < this.radius) {
      return true;
    } // Approximate the radius of one texel : the radius of the tile divided by the image size
    // The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
    // and the radius (ie maximum width/length) is too pessimistic


    var radius = 0.25 * (this.bbox.max[0] - this.bbox.min[0] + (this.bbox.max[1] - this.bbox.min[1])) / this.imageSize; // Transform the closest point from the eye in world coordinates

    var mat = this.matrix;
    var c = this.closestPointToEye;
    var px = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
    var py = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
    var pz = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14]; // Compute the pixel size of the radius texel

    var pixelSizeVector = renderContext.pixelSizeVector;
    var pixelSize = radius / (px * pixelSizeVector[0] + py * pixelSizeVector[1] + pz * pixelSizeVector[2] + pixelSizeVector[3]); // Check if pixel radius of a texel is superior to the treshold
    // The pixel size can be negative when the closest point is close to the near plane, so take absolute value

    return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
  };
  /**************************************************************************************************************/

  /**
   *    Test if the tile is culled given the current view parameters
   */


  Tile.prototype.isCulled = function (renderContext) {
    // Compute the eye in tile local space
    var mat = this.inverseMatrix;
    var c = renderContext.eyePosition;

    if (!mat) {
      return false;
    }

    var ex = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
    var ey = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
    var ez = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14]; // If the eye is in the radius of the tile, consider the tile is not culled

    this.distance = Math.sqrt(ex * ex + ey * ey + ez * ez);

    if (this.distance < this.radius) {
      this.distance = 0.0;
      return false;
    } else {
      var pt = this.closestPointToEye; // Compute closest point to eye with the bbox of the tile

      pt[0] = Math.min(Math.max(ex, this.bbox.min[0]), this.bbox.max[0]);
      pt[1] = Math.min(Math.max(ey, this.bbox.min[1]), this.bbox.max[1]);
      pt[2] = Math.min(Math.max(ez, this.bbox.min[2]), this.bbox.max[2]); // Compute horizontal culling only if the eye is "behind" the tile
      // and the coordinate system is not a plane(no need to compute horizon culling on plane)

      if (ez < 0.0 && !this.config.coordinateSystem.isFlat()) {
        const eyeGeoAltitude = this.config.coordinateSystem.from3DToGeo(c)[2];

        if (eyeGeoAltitude > 0) {
          // Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
          var vx = pt[0];
          var vy = pt[1];
          var vz = pt[2] + this.config.coordinateSystem.geoide.radius;
          var vl = Math.sqrt(vx * vx + vy * vy + vz * vz);
          vx /= vl;
          vy /= vl;
          vz /= vl; // Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
          // The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.

          var edx = ex - vx * this.config.coordinateSystem.geoide.radius;
          var edy = ey - vy * this.config.coordinateSystem.geoide.radius;
          var edz = ez - (vz - 1.0) * this.config.coordinateSystem.geoide.radius; // Compute dot product between eye direction and the vertical at the point

          var el = Math.sqrt(edx * edx + edy * edy + edz * edz);
          var eDv = (edx * vx + edy * vy + edz * vz) / el;
          eDv *= this.config.cullSign;

          if (eDv < -0.05) {
            return true;
          }
        }
      } // Compute local frustum


      var localFrustum = renderContext.localFrustum;
      localFrustum.inverseTransform(renderContext.worldFrustum, this.matrix); // Check if the tile is inside the frustum

      return !localFrustum.containsBoundingBox(this.bbox);
    }
  };
  /**************************************************************************************************************/

  /**
   *    Dispose the tile
   */


  Tile.prototype.dispose = function (renderContext, tilePool) {
    // Dispose extension even if tile isn't loaded because it can be culled
    for (var x in this.extension) {
      if (this.extension[x].dispose) {
        this.extension[x].dispose(renderContext, tilePool);
      }
    }

    if (this.state === Tile.State.LOADED) {
      tilePool.disposeGLBuffer(this.vertexBuffer);

      if (this.texture) {
        tilePool.disposeGLTexture(this.texture);
      }

      this.vertexBuffer = null;
      this.texture = null;
      this.parent = null;
      this.state = Tile.State.NONE;
    }
  };
  /**************************************************************************************************************/

  /**
   *    Delete the children
   */


  Tile.prototype.deleteChildren = function (renderContext, tilePool) {
    if (this.children) {
      for (var i = 0; i < 4; i++) {
        // Recursively delete its children
        this.children[i].deleteChildren(renderContext, tilePool); // Dispose its ressources (WebGL)

        this.children[i].dispose(renderContext, tilePool);
      } // Cleanup the tile


      this.children = null;
    }
  };
  /**************************************************************************************************************/

  /**
   *    Build skirt vertices
   */


  Tile.prototype.buildSkirtVertices = function (center, srcOffset, srcStep, dstOffset) {
    var vertices = this.vertices;
    var skirtHeight = this.radius * 0.05;
    var size = this.config.tesselation;

    for (var i = 0; i < size; i++) {
      /*		//Not optimized version of skirt computation
               var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
               var dir = vec3.subtract( srcPos, center, vec3.create() );
               vec3.normalize(dir);
               vec3.scale( dir, skirtHeight );
               vec3.subtract( srcPos, dir );*/
      // Optimized version of skirt computation
      var x = vertices[srcOffset] - center[0];
      var y = vertices[srcOffset + 1] - center[1];
      var z = vertices[srcOffset + 2] - center[2];
      var scale = skirtHeight / Math.sqrt(x * x + y * y + z * z);
      x *= scale;
      y *= scale;
      z *= scale;
      vertices[dstOffset] = vertices[srcOffset] - x;
      vertices[dstOffset + 1] = vertices[srcOffset + 1] - y;
      vertices[dstOffset + 2] = vertices[srcOffset + 2] - z;

      for (var n = 3; n < this.config.vertexSize; n++) {
        vertices[dstOffset + n] = vertices[srcOffset + n];
      }

      dstOffset += this.config.vertexSize;
      srcOffset += srcStep;
    }
  };
  /**************************************************************************************************************/

  /**
   *    Generate normals for a tile
   */


  Tile.prototype.generateNormals = function () {
    var size = this.config.tesselation;
    var vertexSize = this.config.vertexSize;
    var lineSize = vertexSize * size;
    var vo = 0;

    for (var j = 0; j < size; j++) {
      var vp1 = j === size - 1 ? 0 : lineSize;
      var vm1 = j === 0 ? 0 : -lineSize;

      for (var i = 0; i < size; i++) {
        var up1 = i === size - 1 ? 0 : vertexSize;
        var um1 = i === 0 ? 0 : -vertexSize;
        var u = [this.vertices[vo + up1] - this.vertices[vo + um1], this.vertices[vo + up1 + 1] - this.vertices[vo + um1 + 1], this.vertices[vo + up1 + 2] - this.vertices[vo + um1 + 2]];
        var v = [this.vertices[vo + vp1] - this.vertices[vo + vm1], this.vertices[vo + vp1 + 1] - this.vertices[vo + vm1 + 1], this.vertices[vo + vp1 + 2] - this.vertices[vo + vm1 + 2]];
        var normal = vec3.cross(u, v, []);
        vec3.normalize(normal);
        this.vertices[vo + 3] = normal[0];
        this.vertices[vo + 4] = normal[1];
        this.vertices[vo + 5] = normal[2];
        vo += vertexSize;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   *    Generate the tile
   */


  Tile.prototype.generate = function (tilePool, image, elevations) {
    // Generate the vertices
    this.vertices = this.generateVertices(elevations); // Compute the bounding box

    var size = this.config.tesselation;
    var vertexSize = this.config.vertexSize;
    this.bbox.compute(this.vertices, vertexSize * size * size, vertexSize);
    this.radius = this.bbox.getRadius(); // Compute normals if needed

    if (this.config.normals) {
      this.generateNormals();
    } // Compute skirt from vertices


    if (this.config.skirt) {
      // Compute local earth center, used to generate skirts
      var localEarthCenter = [0.0, 0.0, 0.0];
      mat4.multiplyVec3(this.inverseMatrix, localEarthCenter); // Skirts

      var dstOffset = vertexSize * (size * size); // TOP

      this.buildSkirtVertices(localEarthCenter, 0, vertexSize, dstOffset);
      dstOffset += vertexSize * size; // BOTTOM

      this.buildSkirtVertices(localEarthCenter, vertexSize * (size * (size - 1)), vertexSize, dstOffset);
      dstOffset += vertexSize * size; // LEFT

      this.buildSkirtVertices(localEarthCenter, 0, vertexSize * size, dstOffset);
      dstOffset += vertexSize * size; // RIGHT

      this.buildSkirtVertices(localEarthCenter, vertexSize * (size - 1), vertexSize * size, dstOffset); // These skirts are only used by children tile

      dstOffset += vertexSize * size; // CENTER

      this.buildSkirtVertices(localEarthCenter, vertexSize * (size * (size - 1) / 2), vertexSize, dstOffset);
      dstOffset += vertexSize * size; // MIDDLE

      this.buildSkirtVertices(localEarthCenter, vertexSize * ((size - 1) / 2), vertexSize * size, dstOffset);
    } // Avoid double creation of vertex buffer for level0Tiles generation


    if (this.vertexBuffer !== null && this.parent === null) {
      tilePool.disposeGLBuffer(this.vertexBuffer);
    }

    this.vertexBuffer = tilePool.createGLBuffer(this.vertices); // Create texture

    if (image) {
      this.texture = tilePool.createGLTexture(image);
      this.imageSize = this.config.imageSize;
    }

    this.state = Tile.State.LOADED;
  };
  /**************************************************************************************************************/


  Tile.prototype.intersect = function (ray, indices, rc) {
    if (this.isCulled(rc)) {
      return -1;
    } // We intersect, check the children recursively for a finer result


    var minChildrenIntersection;

    if (this.children) {
      for (var i = 0; i < this.children.length; ++i) {
        const child = this.children[i];

        if (child.vertices) {
          const intersection = child.intersect(ray, indices, rc);

          if (intersection >= 0 && (!minChildrenIntersection || intersection < minChildrenIntersection)) {
            minChildrenIntersection = intersection;
          }
        }
      }
    } // Children will be more fine-grained


    var final_t;

    if (minChildrenIntersection && minChildrenIntersection >= 0) {
      final_t = minChildrenIntersection;
    } else if (this.vertices == null) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Tile.js", "vertices is null");
    } else {
      var intersection = null;

      for (var j = 0; indices && j < indices.length / 3; ++j) {
        const i0 = indices[j * 3 + 0] * 3;
        const i1 = indices[j * 3 + 1] * 3;
        const i2 = indices[j * 3 + 2] * 3;
        var v0 = [this.vertices[i0 + 0], this.vertices[i0 + 1], this.vertices[i0 + 2]];
        var v1 = [this.vertices[i1 + 0], this.vertices[i1 + 1], this.vertices[i1 + 2]];
        var v2 = [this.vertices[i2 + 0], this.vertices[i2 + 1], this.vertices[i2 + 2]];
        v0 = mat4.multiplyVec3(this.matrix, v0);
        v1 = mat4.multiplyVec3(this.matrix, v1);
        v2 = mat4.multiplyVec3(this.matrix, v2);
        var verts = [v0[0], v0[1], v0[2], v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]];
        const tmp_i = ray.triangleIntersectOptimized(verts, 0, 3, 6);

        if (tmp_i) {
          if (!intersection || tmp_i.t < intersection.t) {
            intersection = tmp_i;
          }
        }
      }

      if (intersection) {
        final_t = intersection.t;
      }
    }

    if (!final_t) {
      return -1;
    }

    const result = final_t;
    return result;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   @name GeoBound
   @class
       Geo Bound
   @param {float} w West
   @param {float} s South
   @param {float} e East
   @param {float} n North
   @constructor
   */

  var GeoBound = function (w, s, e, n) {
    this.south = s;
    this.west = w;
    this.north = n;
    this.east = e;
  };
  /**
   Get geo center
   @function getCenter
   @memberof GeoBound.prototype
   @return {float[]} Geo center as array of 2 float
   */


  GeoBound.prototype.getCenter = function () {
    return [(this.east + this.west) * 0.5, (this.south + this.north) * 0.5, 0.0];
  };
  /**
   Get North
   @function getNorth
   @memberof GeoBound.prototype
   @return {float} North
   */


  GeoBound.prototype.getNorth = function () {
    return this.north;
  };
  /**
   Set North
   @function setNorth
   @memberof GeoBound.prototype
   @param {float} val
   */


  GeoBound.prototype.setNorth = function (val) {
    this.north = val;
  };
  /**
   Get South
   @function getSouth
   @memberof GeoBound.prototype
   @return {float} South
   */


  GeoBound.prototype.getSouth = function () {
    return this.south;
  };
  /**
   Set South
   @function setSouth
   @memberof GeoBound.prototype
   @param {float} val
   */


  GeoBound.prototype.setSouth = function (val) {
    this.south = val;
  };
  /**
   Get West
   @function getWest
   @memberof GeoBound.prototype
   @return {float} West
   */


  GeoBound.prototype.getWest = function () {
    return this.west;
  };
  /**
   Set West
   @function setWest
   @memberof GeoBound.prototype
   @param {float} val
   */


  GeoBound.prototype.setWest = function (val) {
    this.west = val;
  };
  /**
   Get East
   @function getEast
   @memberof GeoBound.prototype
   @return {float} East
   */


  GeoBound.prototype.getEast = function () {
    return this.east;
  };
  /**
   Set East
   @function setEast
   @memberof GeoBound.prototype
   @param {float} val
   */


  GeoBound.prototype.setEast = function (val) {
    this.east = val;
  };
  /**
   Compute the geo bound from coordinates
   @function computeFromCoordinates
   @memberof GeoBound.prototype
   @param {float[][]} coordinates Coordinates as bi-dimensionnal array of float
   */


  GeoBound.prototype.computeFromCoordinates = function (coordinates) {
    this.west = coordinates[0][0];
    this.east = coordinates[0][0];
    this.south = coordinates[0][1];
    this.north = coordinates[0][1];

    for (var i = 1; i < coordinates.length; i++) {
      this.west = Math.min(this.west, coordinates[i][0]);
      this.east = Math.max(this.east, coordinates[i][0]);
      this.south = Math.min(this.south, coordinates[i][1]);
      this.north = Math.max(this.north, coordinates[i][1]);
    }
  };

  function transformCoordinates(coordinates, crsID, globeCrs) {
    var len = coordinates.length,
        convertedCoord = new Array(len); // boost in Safari

    for (var i = 0; i < len; ++i) {
      convertedCoord[i] = coordinates[i].slice(0);
    }

    convertedCoord[0][0] = globeCrs.convert(coordinates[0][0], crsID, globeCrs.getGeoideName());
    convertedCoord[0][1] = globeCrs.convert(coordinates[0][1], crsID, globeCrs.getGeoideName());

    for (var j = 1; j < coordinates.length; j++) {
      convertedCoord[j][0] = globeCrs.convert(coordinates[j][0], crsID, globeCrs.getGeoideName());
      convertedCoord[j][1] = globeCrs.convert(coordinates[j][1], crsID, globeCrs.getGeoideName());
    }

    return convertedCoord;
  }

  GeoBound.prototype.computeFromCoordinatesInCrsTo = function (coordinates, crsID, globeCrs) {
    var coords;

    if (crsID === globeCrs.getGeoideName()) {
      coords = coordinates;
    } else {
      coords = transformCoordinates(coordinates, crsID, globeCrs);
    }

    this.computeFromCoordinates(coords);
    return coords;
  };
  /**
   Check if a point is inside the given bound
   @function isPointInside
   @memberof GeoBound.prototype
   @param {Array} point The point
   @return {Boolean} return the test
   */


  GeoBound.prototype.isPointInside = function (point) {
    return point[0] >= this.west && point[0] <= this.east && point[1] >= this.south && point[1] <= this.north;
  };
  /**
   Intersects this geo bound with another one
   @function intersects
   @memberof GeoBound.prototype
   @param {GeoBound} geoBound Geo bound
   @return {Boolean} Intersects ?
   */


  GeoBound.prototype.intersects = function (geoBound) {
    if (this.west >= geoBound.east || this.east <= geoBound.west) {
      return false;
    }

    return !(this.south >= geoBound.north || this.north <= geoBound.south);
  };
  /**
   Intersects this geo bound with GeoJSON geometry
   @function intersectsGeometry
   @memberof GeoBound.prototype
   @param {JSON} geometry GeoJSON geometry
   @return {Boolean} Intersects ?
   */


  GeoBound.prototype.intersectsGeometry = function (geometry) {
    var isIntersected = false;
    var i, j;
    var geoBound = new GeoBound();
    var coords = geometry.coordinates;

    switch (geometry.type) {
      case Constants.GEOMETRY.LineString:
        geoBound.computeFromCoordinates(coords);
        isIntersected |= this.intersects(geoBound);
        break;

      case Constants.GEOMETRY.Polygon:
        // Don't take care about holes
        for (i = 0; i < coords.length && !isIntersected; i++) {
          geoBound.computeFromCoordinates(coords[i]);
          isIntersected |= this.intersects(geoBound);
        }

        break;

      case Constants.GEOMETRY.MultiLineString:
        for (i = 0; i < coords.length && !isIntersected; i++) {
          geoBound.computeFromCoordinates(coords[i]);
          isIntersected |= this.intersects(geoBound);
        }

        break;

      case Constants.GEOMETRY.MultiPolygon:
        for (i = 0; i < coords.length && !isIntersected; i++) {
          for (j = 0; j < coords[i].length && !isIntersected; j++) {
            geoBound.computeFromCoordinates(coords[i][j]);
            isIntersected |= this.intersects(geoBound);
          }
        }

        break;
    }

    return isIntersected;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /** @constructor
       Tile constructor
       */

  var GeoTile = function (geoBound, level, x, y) {
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
    this.bound = this.geoBound = geoBound;
    this.level = level;
    this.x = x;
    this.y = y;
    this.key = this.level + "#" + this.x + "#" + this.y;
    this.type = Constants.TILE.GEO_TILE;
  };
  /**************************************************************************************************************/

  /** inherits from Tile */


  GeoTile.prototype = new Tile();
  /**************************************************************************************************************/

  /** @export
       Get elevation at a geo position
       */

  GeoTile.prototype.getElevation = function (lon, lat) {
    // Get the lon/lat in coordinates between [0,1] in the tile
    var u = (lon - this.geoBound.getWest()) / (this.geoBound.getEast() - this.geoBound.getWest());
    var v = (lat - this.geoBound.getNorth()) / (this.geoBound.getSouth() - this.geoBound.getNorth()); // Quick fix when lat is on the border of the tile

    var childIndex = (v >= 1 ? 1 : Math.floor(2 * v)) * 2 + Math.floor(2 * u);

    if (this.children && this.children[childIndex] && this.children[childIndex].state === Tile.State.LOADED) {
      return this.children[childIndex].getElevation(lon, lat);
    }

    var tess = this.config.tesselation;
    var i = Math.floor(u * tess);
    var j = Math.floor(v * tess);
    var vo = this.config.vertexSize * (j * tess + i);
    var vertex = [this.vertices[vo], this.vertices[vo + 1], this.vertices[vo + 2]];
    mat4.multiplyVec3(this.matrix, vertex);
    var geo = this.config.coordinateSystem.getWorldFrom3D(vertex);
    return geo[2];
  };

  GeoTile.prototype.getKey = function () {
    return this.key;
  };
  /**************************************************************************************************************/

  /**
       Create the children
       */


  GeoTile.prototype.createChildren = function () {
    // Create the children
    var lonCenter = (this.geoBound.getEast() + this.geoBound.getWest()) * 0.5;
    var latCenter = (this.geoBound.getNorth() + this.geoBound.getSouth()) * 0.5;
    var level = this.level + 1;
    var tile00 = new GeoTile(new GeoBound(this.geoBound.getWest(), latCenter, lonCenter, this.geoBound.getNorth()), level, 2 * this.x, 2 * this.y);
    var tile10 = new GeoTile(new GeoBound(lonCenter, latCenter, this.geoBound.getEast(), this.geoBound.getNorth()), level, 2 * this.x + 1, 2 * this.y);
    var tile01 = new GeoTile(new GeoBound(this.geoBound.getWest(), this.geoBound.getSouth(), lonCenter, latCenter), level, 2 * this.x, 2 * this.y + 1);
    var tile11 = new GeoTile(new GeoBound(lonCenter, this.geoBound.getSouth(), this.geoBound.getEast(), latCenter), level, 2 * this.x + 1, 2 * this.y + 1);
    tile00.initFromParent(this, 0, 0);
    tile10.initFromParent(this, 1, 0);
    tile01.initFromParent(this, 0, 1);
    tile11.initFromParent(this, 1, 1);
    this.children = [tile00, tile10, tile01, tile11];
  };
  /**************************************************************************************************************/

  /**
       Convert coordinates in longitude,latitude to coordinate in "tile space"
       Tile space means coordinates are between [0,tesselation-1] if inside the tile
       Used by renderers algorithm to clamp coordinates on the tile
       */


  GeoTile.prototype.lonlat2tile = function (coordinates) {
    var ul = this.geoBound.getEast() - this.geoBound.getWest();
    var vl = this.geoBound.getSouth() - this.geoBound.getNorth();
    var factor = this.config.tesselation - 1;
    var tileCoords = [];

    for (var i = 0; i < coordinates.length; i++) {
      var u = factor * (coordinates[i][0] - this.geoBound.getWest()) / ul;
      var v = factor * (coordinates[i][1] - this.geoBound.getNorth()) / vl;
      tileCoords.push([u, v]);
    }

    return tileCoords;
  };
  /**************************************************************************************************************/

  /**
       Generate vertices for tile
       */


  GeoTile.prototype.generateVertices = function (elevations) {
    // Compute tile matrix
    this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
    var invMatrix = mat4.create();
    mat4.inverse(this.matrix, invMatrix);
    this.inverseMatrix = invMatrix; // Build the vertices

    var vertexSize = this.config.vertexSize;
    var size = this.config.tesselation;
    var vertices = new Float32Array(vertexSize * size * (size + 6));
    var lonStep = (this.geoBound.getEast() - this.geoBound.getWest()) / (size - 1);
    var latStep = (this.geoBound.getSouth() - this.geoBound.getNorth()) / (size - 1); //var radius = this.config.coordinateSystem.getGeoide().getRadius();
    //var scale = this.config.coordinateSystem.getGeoide().getHeightScale();

    var offset = 0; // Optimized build for sphere coordinates : uncomment if needed

    var lat = this.geoBound.getNorth();
    /* * Math.PI / 180.0*/
    // latStep = latStep * Math.PI / 180.0;
    // lonStep = lonStep * Math.PI / 180.0;

    var pos3d = [0.0, 0.0, 0.0];

    for (var j = 0; j < size; j++) {
      //var cosLat = Math.cos( lat );
      //var sinLat = Math.sin( lat );
      var lon = this.geoBound.getWest();
      /* * Math.PI / 180.0*/

      for (var i = 0; i < size; i++) {
        // var height = elevations ? scale * elevations[ offset ] : 0.0;
        // var x = (radius + height) * Math.cos( lon ) * cosLat;
        // var y = (radius + height) * Math.sin( lon ) * cosLat;
        // var z = (radius + height) * sinLat;
        var height = elevations ? elevations[offset] : 0.0;
        this.config.coordinateSystem.get3DFromWorld([lon, lat, height], pos3d);
        var x = pos3d[0];
        var y = pos3d[1];
        var z = pos3d[2];
        var vi = offset * vertexSize;
        vertices[vi] = invMatrix[0] * x + invMatrix[4] * y + invMatrix[8] * z + invMatrix[12];
        vertices[vi + 1] = invMatrix[1] * x + invMatrix[5] * y + invMatrix[9] * z + invMatrix[13];
        vertices[vi + 2] = invMatrix[2] * x + invMatrix[6] * y + invMatrix[10] * z + invMatrix[14];
        offset++;
        lon += lonStep;
      }

      lat += latStep;
    }

    return vertices;
  };
  /**************************************************************************************************************/

  /** @constructor
       GeoTiling constructor
       */


  var GeoTiling = function (nx, ny) {
    this.level0NumTilesX = nx;
    this.level0NumTilesY = ny;
  };
  /**************************************************************************************************************/

  /**
       Generate the tiles for level zero
       */


  GeoTiling.prototype.generateLevelZeroTiles = function (config) {
    config.skirt = !config.coordinateSystem.isFlat();
    config.cullSign = 1;
    config.srs = "CRS:84";
    var level0Tiles = [];
    var latStep = (config.coordinateSystem.getGeoBound().getNorth() - config.coordinateSystem.getGeoBound().getSouth()) / this.level0NumTilesY;
    var lonStep = (config.coordinateSystem.getGeoBound().getEast() - config.coordinateSystem.getGeoBound().getWest()) / this.level0NumTilesX; // Manage (just for latitude) a partial GeoTiling cover (not only 360 * 180)

    this.latStart = config.coordinateSystem.getGeoBound().getSouth();
    this.latDelta = config.coordinateSystem.getGeoBound().getNorth() - config.coordinateSystem.getGeoBound().getSouth();

    for (var j = 0; j < this.level0NumTilesY; j++) {
      for (var i = 0; i < this.level0NumTilesX; i++) {
        var geoBound = new GeoBound(config.coordinateSystem.getGeoBound().getWest() + i * lonStep, config.coordinateSystem.getGeoBound().getNorth() - (j + 1) * latStep, config.coordinateSystem.getGeoBound().getWest() + (i + 1) * lonStep, config.coordinateSystem.getGeoBound().getNorth() - j * latStep);
        var tile = new GeoTile(geoBound, 0, i, j);
        tile.config = config;
        level0Tiles.push(tile);
      }
    }

    return level0Tiles;
  };
  /**************************************************************************************************************/

  /**
       Locate a level zero tile
       */


  GeoTiling.prototype._lon2LevelZeroIndex = function (lon) {
    return Math.min(this.level0NumTilesX - 1, Math.floor((lon + 180) * this.level0NumTilesX / 360));
  };
  /**************************************************************************************************************/

  /**
       Locate a level zero tile
       */


  GeoTiling.prototype._lat2LevelZeroIndex = function (lat) {
    // Take into account a partial bbox for GeoTiling
    var topLat = this.latStart + this.latDelta;
    return Math.min(this.level0NumTilesY - 1, Math.floor((topLat - lat) * this.level0NumTilesY / this.latDelta));
  };
  /**************************************************************************************************************/

  /**
       Locate a level zero tile
       */


  GeoTiling.prototype.lonlat2LevelZeroIndex = function (lon, lat) {
    return this._lat2LevelZeroIndex(lat) * this.level0NumTilesX + this._lon2LevelZeroIndex(lon);
  };
  /**************************************************************************************************************/

  /**
       Get the overlapped tile by the given geometry
       */


  GeoTiling.prototype.getOverlappedLevelZeroTiles = function (geometry) {
    var tileIndices = [];
    var bbox = Utils.getBBox(geometry);

    var i1 = this._lon2LevelZeroIndex(bbox.west);

    var j1 = this._lat2LevelZeroIndex(bbox.north);

    var i2 = this._lon2LevelZeroIndex(bbox.east);

    var j2 = this._lat2LevelZeroIndex(bbox.south);

    for (var j = j1; j <= j2; j++) {
      for (var i = i1; i <= i2; i++) {
        tileIndices.push(j * this.level0NumTilesX + i);
      }
    }

    return tileIndices;
  };
  /**************************************************************************************************************/

  /**
       Return tile of given longitude/latitude from tiles array if exists, null otherwise
       */


  GeoTiling.prototype.findInsideTile = function (lon, lat, tiles) {
    var tile = null;

    for (var i = 0; i < tiles.length; i++) {
      tile = tiles[i];
      var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);

      if (index === tile.pixelIndex) {
        return tile;
      }
    } // index not found, check with lon lat


    for (i = 0; i < tiles.length; i++) {
      tile = tiles[i];
      var found = lat <= tile.bound.north && lat >= tile.bound.south && lon <= tile.bound.east && lon >= tile.bound.west;

      if (found === true) {
        return tile;
      }
    }

    return null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
   @constructor
   TilePool constructor
   */
  var TilePool = function (rc) {
    // Private properties
    var gl = rc.gl;
    var glTexturePools = {};
    var glBuffers = [];
    var self = this; // Choose floating point texture filtering depending on extension support

    var float_linear_ext = gl.getExtension("OES_texture_float_linear");
    var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST; // Public properties

    this.numCreatedTextures = 0;
    this.numReusedTextures = 0; // Private methods

    /**************************************************************************************************************/

    /**
       Create a new GL texture
       */

    var createNewGLTexture = function (image, texturePool) {
      var glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);

      if (image.dataType === "byte") {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
      }

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      glTexture.pool = texturePool;
      self.numCreatedTextures++;
      return glTexture;
    };
    /**************************************************************************************************************/

    /**
       Reuse a GL texture
       */


    var reuseGLTexture = function (image, texturePool) {
      var glTexture = texturePool.pop();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);

      if (image.dataType === "byte") {
        //gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
      }

      self.numReusedTextures++;
      return glTexture;
    };
    /**
     * Get or create a texture pool for the given image
     */


    var getOrCreateTexturePool = function (image) {
      var key = image.dataType + image.width;

      if (!glTexturePools[key]) {
        glTexturePools[key] = [];
      }

      return glTexturePools[key];
    }; // Public methods

    /**************************************************************************************************************/

    /**
       Create a GL texture to be used by a tile
       */


    this.createGLTexture = function (image) {
      var texturePool = getOrCreateTexturePool(image);

      if (texturePool.length > 0) {
        return reuseGLTexture(image, texturePool);
      } else {
        return createNewGLTexture(image, texturePool);
      }
    };
    /**************************************************************************************************************/

    /**
       Create a GL texture to be used by a tile
       */


    this.createGLBuffer = function (vertices) {
      var vb;

      if (glBuffers.length > 0) {
        vb = glBuffers.pop();
      } else {
        vb = gl.createBuffer();
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, vb);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      return vb;
    };
    /**************************************************************************************************************/

    /**
       Dispose a texture
       */


    this.disposeGLTexture = function (texture) {
      texture.pool.push(texture);
    };
    /**************************************************************************************************************/

    /**
       Dispose a texture
       */


    this.disposeGLBuffer = function (buffer) {
      glBuffers.push(buffer);
    };
    /**************************************************************************************************************/

    /**
       Dispose all
       */


    this.disposeAll = function () {
      var i;

      for (var key in glTexturePools) {
        if (glTexturePools.hasOwnProperty(key)) {
          var glTextures = glTexturePools[key];

          for (i = 0; i < glTextures.length; i++) {
            gl.deleteTexture(glTextures[i]);
          }
        }
      }

      glTexturePools = {};

      for (i = 0; i < glBuffers.length; i++) {
        gl.deleteBuffer(glBuffers[i]);
      }

      glBuffers.length = 0;
    };
    /**************************************************************************************************************/

  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   *    @constructor
   *    ImageRequest constructor
   */

  var ImageRequest = function (options) {
    this.successCallback = options.successCallback;
    this.failCallback = options.failCallback;
    this.abortCallback = options.abortCallback;
    this.image = null;
  };
  /**************************************************************************************************************/

  /**
   *    Send image request
   */


  ImageRequest.prototype.send = function (url, crossOrigin) {
    this.image = new Image();
    this.image.crossOrigin = crossOrigin;
    this.image.dataType = "byte";
    var self = this;

    this.image.onload = function () {
      var isComplete = self.image.naturalWidth !== 0 && self.image.complete;

      if (isComplete) {
        self.successCallback(self);
      }
    };

    this.image.onerror = this.failCallback.bind(this);
    this.image.src = Proxy.proxify(url);
  };
  /**************************************************************************************************************/

  /**
   *    Abort image request
   */


  ImageRequest.prototype.abort = function () {
    if (this.abortCallback) {
      this.abortCallback(this);
    }

    this.image.src = "";
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**************************************************************************************************************/

  /** @constructor
   TileRequest constructor
   */

  var TileRequest = function (tileManager) {
    // Private variables
    var _imageLoaded = false;
    var _elevationLoaded = true;

    var _xhr = new XMLHttpRequest();

    var _imageRequest; // Public variables


    this.tile = null;
    this.elevations = null;
    this.image = null;
    var self = this;
    /**
       Handle when elevation is loaded
       */

    var _handleLoadedElevation = function () {
      self.elevations = tileManager.elevationProvider.parseElevations(_xhr.responseText);
      _elevationLoaded = true;

      if (_imageLoaded) {
        tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
        tileManager.completedRequests.push(self);
        tileManager.renderContext.requestFrame();
      }
    };
    /**************************************************************************************************************/

    /**
       Handle when loading elevation failed
       */


    var _handleErrorElevation = function () {
      self.elevations = null;
      _elevationLoaded = true;

      if (_imageLoaded) {
        tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
        tileManager.completedRequests.push(self);
        tileManager.renderContext.requestFrame();
      }
    }; // Setup the XHR callback


    _xhr.onreadystatechange = function (e) {
      if (_xhr.readyState === 4) {
        if (_xhr.status === 200) {
          _handleLoadedElevation();
        } else {
          _handleErrorElevation();
        }
      }
    };
    /**************************************************************************************************************/

    /**
       Handle when image is loaded
       */


    var _handleLoadedImage = function () {
      // The method can be called twice when the image is in the cache (see launch())
      if (!_imageLoaded) {
        _imageLoaded = true;

        if (_elevationLoaded) {
          // Call post-process function if defined
          if (tileManager.imageryProvider && tileManager.imageryProvider.handleImage) {
            tileManager.imageryProvider.handleImage(_imageRequest);
          }

          tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
          tileManager.completedRequests.push(self);
          tileManager.renderContext.requestFrame();
        }

        self.image = _imageRequest.image;
      }
    };
    /**************************************************************************************************************/

    /**
       Handle when loading image failed
       */


    var _handleErrorImage = function () {
      self.tile.state = Tile.State.ERROR;
      tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
      tileManager.availableRequests.push(self);
    };
    /**************************************************************************************************************/

    /**
       Abort request
       */


    var _handleAbort = function () {
      self.tile.state = Tile.State.NONE;
      tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
      tileManager.availableRequests.push(self);
    };
    /**************************************************************************************************************/

    /**
       Launch the HTTP request for a tile
       */


    this.launch = function (tile) {
      tile.state = Tile.State.LOADING;
      this.tile = tile;
      tileManager.pendingRequests.push(this);
      this.image = null;
      this.elevations = null; // Request the elevation if needed

      if (tileManager.elevationProvider && tileManager.elevationProvider.getUrl(tile) != null) {
        // TODO : handle the elevations coming from cache
        _elevationLoaded = false;

        _xhr.open("GET", tileManager.elevationProvider.getUrl(tile)); // Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top


        var useCredentials = tileManager.elevationProvider.crossOrigin === "use-credentials";
        _xhr.withCredentials = useCredentials;

        _xhr.send();
      } else {
        _elevationLoaded = true;
      }

      if (tileManager.imageryProvider && tileManager.imageryProvider.getUrl(tile)) {
        if (!_imageRequest) {
          _imageRequest = new ImageRequest({
            successCallback: function () {
              _handleLoadedImage();

              if (tileManager.imageryProvider.cache) {
                tileManager.imageryProvider.cache.storeInCache(self);
              }
            },
            failCallback: _handleErrorImage,
            abortCallback: _handleAbort
          });
        } // Check if the image isn't already loaded in cache


        var cachedTileRequest;

        if (tileManager.imageryProvider.cache) {
          cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(tile);
        }

        _imageLoaded = false;

        if (cachedTileRequest) {
          _imageRequest.image = cachedTileRequest.image;

          _handleLoadedImage();
        } else {
          // Tile not found in cache or cache isn't activated, send the request
          _imageRequest.send(tileManager.imageryProvider.getUrl(tile), tileManager.imageryProvider.crossOrigin);
        }
      } else {
        _imageLoaded = true;
      } // Check if there is nothing to load


      if (!tileManager.imageryProvider && !tileManager.elevationProvider) {
        tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(this), 1);
        tileManager.completedRequests.push(this);
      }
    };
    /**************************************************************************************************************/

    /**
     *    Abort launched request
     */


    this.abort = function () {
      if (_imageRequest) {
        _imageRequest.abort();
      }
    };
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
   @constructor TileIndexBuffer
   TileIndexBuffer
   */
  var TileIndexBuffer = function (renderContext, config) {
    this.renderContext = renderContext;
    this.config = config;
    this.solidIndexBuffer = null;
    this.indices = null;
    this.subSolidIndexBuffer = [null, null, null, null];
    this.subIndices = [null, null, null, null];
  };
  /**************************************************************************************************************/

  /**
   * Reset the index buffers.
   */


  TileIndexBuffer.prototype.reset = function () {
    var gl = this.renderContext.gl;

    for (var i = 0; i < 4; i++) {
      if (this.subSolidIndexBuffer[i]) {
        gl.deleteBuffer(this.subSolidIndexBuffer[i]);
        this.subSolidIndexBuffer[i] = null;
      }
    }

    if (this.solidIndexBuffer) {
      gl.deleteBuffer(this.solidIndexBuffer);
      this.solidIndexBuffer = null;
    }
  };
  /**************************************************************************************************************/

  /**
   *    Get index buffer for sub solid
   */


  TileIndexBuffer.prototype.getSubSolid = function (ii) {
    if (this.subSolidIndexBuffer[ii] === null) {
      var i = ii % 2;
      var j = Math.floor(ii / 2);
      var n, k;
      var size = this.config.tesselation;
      var halfTesselation = (size - 1) / 2; // Build the sub grid for 'inside' tile

      var indices = [];

      for (n = halfTesselation * j; n < halfTesselation * (j + 1); n++) {
        for (k = halfTesselation * i; k < halfTesselation * (i + 1); k++) {
          indices.push(n * size + k);
          indices.push((n + 1) * size + k);
          indices.push(n * size + k + 1);
          indices.push(n * size + k + 1);
          indices.push((n + 1) * size + k);
          indices.push((n + 1) * size + k + 1);
        }
      }

      this.subIndices[ii] = indices;

      if (this.config.skirt) {
        // Build skirts
        // Top skirt
        var start = j === 0 ? size * size : size * size + 4 * size;
        var src = j === 0 ? 0 : halfTesselation * size;

        for (n = halfTesselation * i; n < halfTesselation * (i + 1); n++) {
          indices.push(start + n);
          indices.push(src + n);
          indices.push(start + n + 1);
          indices.push(start + n + 1);
          indices.push(src + n);
          indices.push(src + n + 1);
        } // Bottom skirt


        start = j === 0 ? size * size + 4 * size : size * size + size;
        src = j === 0 ? halfTesselation * size : (size - 1) * size;

        for (n = halfTesselation * i; n < halfTesselation * (i + 1); n++) {
          indices.push(src + n);
          indices.push(start + n);
          indices.push(src + n + 1);
          indices.push(src + n + 1);
          indices.push(start + n);
          indices.push(start + n + 1);
        } // Left skirt


        start = i === 0 ? size * size + 2 * size : size * size + 5 * size;
        src = i === 0 ? 0 : halfTesselation;

        for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
          indices.push(start + k);
          indices.push(start + k + 1);
          indices.push(src + k * size);
          indices.push(src + k * size);
          indices.push(start + k + 1);
          indices.push(src + (k + 1) * size);
        } // Right skirt


        start = i === 0 ? size * size + 5 * size : size * size + 3 * size;
        src = i === 0 ? halfTesselation : size - 1;

        for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
          indices.push(k * size + src);
          indices.push((k + 1) * size + src);
          indices.push(start + k);
          indices.push(start + k);
          indices.push((k + 1) * size + src);
          indices.push(start + k + 1);
        }
      }

      var gl = this.renderContext.gl;
      var ib = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      ib.numIndices = indices.length;
      this.subSolidIndexBuffer[ii] = ib;
    }

    return this.subSolidIndexBuffer[ii];
  };
  /**************************************************************************************************************/

  /*
   Build index buffer
   */


  TileIndexBuffer.prototype.getSolid = function () {
    if (this.solidIndexBuffer === null) {
      var i, j;
      var size = this.config.tesselation;
      this.indices = []; // Build the grid

      for (j = 0; j < size - 1; j++) {
        for (i = 0; i < size - 1; i++) {
          this.indices.push(j * size + i);
          this.indices.push((j + 1) * size + i);
          this.indices.push(j * size + i + 1);
          this.indices.push(j * size + i + 1);
          this.indices.push((j + 1) * size + i);
          this.indices.push((j + 1) * size + i + 1);
        }
      }

      if (this.config.skirt) {
        // Top skirt
        var start = size * size;

        for (i = 0; i < size - 1; i++) {
          this.indices.push(start + i);
          this.indices.push(i);
          this.indices.push(start + i + 1);
          this.indices.push(start + i + 1);
          this.indices.push(i);
          this.indices.push(i + 1);
        } // Bottom skirt


        start += size;

        for (i = 0; i < size - 1; i++) {
          this.indices.push((size - 1) * size + i);
          this.indices.push(start + i);
          this.indices.push((size - 1) * size + i + 1);
          this.indices.push((size - 1) * size + i + 1);
          this.indices.push(start + i);
          this.indices.push(start + i + 1);
        } // Left skirt


        start += size;

        for (j = 0; j < size - 1; j++) {
          this.indices.push(start + j);
          this.indices.push(start + j + 1);
          this.indices.push(j * size);
          this.indices.push(j * size);
          this.indices.push(start + j + 1);
          this.indices.push((j + 1) * size);
        } // Right skirt


        start += size;

        for (j = 0; j < size - 1; j++) {
          this.indices.push(j * size + size - 1);
          this.indices.push((j + 1) * size + size - 1);
          this.indices.push(start + j);
          this.indices.push(start + j);
          this.indices.push((j + 1) * size + size - 1);
          this.indices.push(start + j + 1);
        }
      }

      var gl = this.renderContext.gl;
      var ib = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
      this.numIndices = this.indices.length;
      this.solidIndexBuffer = ib;
      this.solidIndexBuffer.numIndices = this.indices.length;
    }

    return this.solidIndexBuffer;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
  	 @name Program
  	 @class
  	   Program constructor
  	 @param renderContext
  	 @constructor
  	 */

  var Program = function (renderContext) {
    this.renderContext = renderContext;
    this.glProgram = null;
    this.attributes = {};
    this.uniforms = {};
    this.numActiveAttribArray = 0;
  };
  /**************************************************************************************************************/

  /**
   * Creates a shader of the given type from the given source string
   * @function createShader
   * @memberof Program.prototype
   * @param type
   * @param source
   * @return Shader
   */


  Program.prototype.createShader = function (type, source) {
    var gl = this.renderContext.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", "Shader compilation error: " + gl.getShaderInfoLog(shader));
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", source);
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };
  /**************************************************************************************************************/

  /**
   * Create the program from source shaders
   * @function createFromSource
   * @memberof Program.prototype
   * @param vertexSource
   * @param fragmentSource
   * @return {Boolean}
   */


  Program.prototype.createFromSource = function (vertexSource, fragmentSource) {
    var gl = this.renderContext.gl; //  Create the gl shaders from the source

    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);

    if (vertexShader === null || fragmentShader === null) {
      return false;
    }

    var i; // Create the program and attach the shaderss

    this.glProgram = gl.createProgram();
    gl.attachShader(this.glProgram, vertexShader);
    gl.attachShader(this.glProgram, fragmentShader); // Link and test the program is ok

    gl.linkProgram(this.glProgram);

    if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Program.js", "Program link error: " + gl.getProgramInfoLog(this.glProgram));
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      gl.deleteProgram(this.glProgram);
      this.glProgram = null;
      return false;
    } // Get vertex attributes used in the program, stored them in an attributes object


    var attributeCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_ATTRIBUTES);
    this.numActiveAttribArray = 0;

    for (i = 0; i < attributeCount; ++i) {
      var attribute = gl.getActiveAttrib(this.glProgram, i);
      var loc = gl.getAttribLocation(this.glProgram, attribute.name);
      this.attributes[attribute.name] = loc;

      if (loc + 1 > this.numActiveAttribArray) {
        this.numActiveAttribArray = loc + 1;
      }
    } // Get uniforms used in the program, stored them in an uniforms object


    var uniformCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_UNIFORMS);

    for (i = 0; i < uniformCount; ++i) {
      var uniform = gl.getActiveUniform(this.glProgram, i);
      this.uniforms[uniform.name] = gl.getUniformLocation(this.glProgram, uniform.name);
    }

    return true;
  };
  /**************************************************************************************************************/

  /**
   * Load from file (must be located on the server)
   * @function loadFromFile
   * @memberof Program.prototype
   * @param vertexFile
   * @param fragmentFile
   * @return {Boolean}
   */


  Program.prototype.loadFromFile = function (vertexFile, fragmentFile) {
    var xhr = new XMLHttpRequest();
    xhr.open("get", Proxy.proxify(this.renderContext.shadersPath + vertexFile), false);
    xhr.send(null);
    var vertexSource = xhr.responseText;
    xhr.open("get", Proxy.proxify(this.renderContext.shadersPath + fragmentFile), false);
    xhr.send(null);
    var fragmentSource = xhr.responseText;
    return this.createFromSource(vertexSource, fragmentSource);
  };
  /**************************************************************************************************************/

  /**
   * Apply the programs
   * @function apply
   * @memberof Program.prototype
   */


  Program.prototype.apply = function () {
    var rc = this.renderContext;
    var gl = rc.gl;
    var i; // Bind program

    gl.useProgram(this.glProgram);

    for (i = rc.numActiveAttribArray; i < this.numActiveAttribArray; i++) {
      gl.enableVertexAttribArray(i);
    }

    for (i = this.numActiveAttribArray; i < rc.numActiveAttribArray; i++) {
      gl.disableVertexAttribArray(i);
    }

    rc.numActiveAttribArray = this.numActiveAttribArray;
  };
  /**************************************************************************************************************/

  /**
   * Dispose the program
   * @function dispose
   * @memberof Program.prototype
   */


  Program.prototype.dispose = function () {
    this.renderContext.gl.deleteProgram(this.glProgram);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * baseLayersError.
   *
   * @event Context#baseLayersError
   * @type {Layer}
   */

  /**
   * baseLayersReady.
   *
   * @event Context#baseLayersReady
   * @type {Layer}
   */

  /**
   * startBackgroundLoad.
   * Called when background layers (imagery and/or elevation) start to be loaded
   * @event Context#startBackgroundLoad
   */

  /**
   * endBackgroundLoad.<br/>
   * Called when background layers (imagery and/or elevation) end loading
   * @event Context#endBackgroundLoad
   */

  /** @constructor
   * TileManager constructor
   *
   * Take in parameters its parent : can be a globe or a sky
   */

  var TileManager = function (parent, options) {
    //TOOD f(tile)
    // this.processedLevel = 0;
    this.parent = parent;
    this.publishEvent = options.publishEvent;
    this.renderContext = this.parent.renderContext; // Create a new tile pool or use the one from the parent

    this.tilePool = parent.tilePool || new TilePool(this.renderContext);
    this.tiling = new GeoTiling(4, 2); // Use geo tiling by default

    this.imageryProvider = null;
    this.elevationProvider = null;
    this.tilesToRender = [];
    this.visibleTiles = [];
    this.tilesToRequest = [];
    this.postRenderers = []; // Init default texture

    var gl = this.renderContext.gl;
    this.defaultTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
    var defaultColor = options.defaultColor ? options.defaultColor : [200, 200, 200, 255];
    var pixel = new Uint8Array(defaultColor);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel); // Tile requests : limit to 4 at a given time

    this.maxRequests = 4;
    this.availableRequests = [];

    for (var i = this.maxRequests; i--;) {
      this.availableRequests[i] = new TileRequest(this);
    }

    this.pendingRequests = [];
    this.completedRequests = [];
    this.level0TilesLoaded = false; // Configuration for tile

    this.tileConfig = {
      tesselation: 9,
      skirt: true,
      cullSign: 1.0,
      imageSize: 256,
      vertexSize: this.renderContext.lighting ? 6 : 3,
      normals: this.renderContext.lighting,
      coordinateSystem: this.parent.coordinateSystem
    };
    this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool); // Shared index and texture coordinate buffer : all tiles uses the same

    this.tcoordBuffer = null;
    this.tileIndexBuffer = new TileIndexBuffer(this.renderContext, this.tileConfig); // HACK : to fix sky rendering, sets to false

    this.renderTileWithoutTexture = options.hasOwnProperty("renderTileWithoutTexture") ? options.renderTileWithoutTexture : true; // For debug

    this.freeze = false; // Stats

    this.numTilesGenerated = 0;
    this.frameNumber = 0;
    this.vertexShader = "attribute vec3 vertex;\n";
    this.vertexShader += "attribute vec2 tcoord;\n";
    this.vertexShader += "uniform mat4 modelViewMatrix;\n";
    this.vertexShader += "uniform mat4 projectionMatrix;\n";
    this.vertexShader += "varying vec2 texCoord;\n";

    if (this.renderContext.lighting) {
      this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n";
    }

    this.vertexShader += "void main(void) \n";
    this.vertexShader += "{\n";
    this.vertexShader += "gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";

    if (this.renderContext.lighting) {
      this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
    }

    this.vertexShader += "texCoord = tcoord;\n";
    this.vertexShader += "}\n";
    this.fragmentShader = "precision lowp float; \n";
    this.fragmentShader += "varying vec2 texCoord;\n";

    if (this.renderContext.lighting) {
      this.fragmentShader += "varying vec3 color;\n";
    }

    this.fragmentShader += "uniform sampler2D colorTexture;\n";
    this.fragmentShader += "void main(void)\n";
    this.fragmentShader += "{\n";
    this.fragmentShader += "	gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";

    if (this.renderContext.lighting) {
      this.fragmentShader += "  gl_FragColor.rgb *= color;\n";
    }

    this.fragmentShader += "  gl_FragColor.a = 1.0;\n";
    this.fragmentShader += "}\n";
    this.program = new Program(this.renderContext);
    this.program.createFromSource(this.vertexShader, this.fragmentShader);
  };
  /**
   * Updates overlay of the layer with the updated layer
   * @param renderable renderer related to the current layer
   * @param layer updated layer
   * @private
   */


  function _updateOverlay(renderable, layer) {
    var bucket;

    if (renderable) {
      bucket = renderable.bucket;
    } else if (layer) {
      bucket = layer._bucket;
    } else {
      return;
    }

    if (!bucket) {
      return;
    }

    var renderer = bucket.renderer;

    if (!renderer) {
      return;
    }

    if (renderer.updateOverlay) {
      renderer.updateOverlay(bucket.layer);
    } else {
      renderer.removeOverlay(bucket.layer);
      renderer.addOverlay(bucket.layer);
    }
  }

  function _abortTilesForLayer(tiles, layer, callback) {
    for (var i = tiles.length; i--;) {
      var tile = tiles[i];
      var extension = tile.extension;

      if (extension && extension.renderer) {
        var renderables = extension.renderer.renderables;

        for (var renderableIdx = renderables.length; renderableIdx--;) {
          var renderable = renderables[renderableIdx];

          if (renderable.bucket.layer.ID === layer.getID()) {
            _abortBucketRequests.call(this, renderable.bucket);

            if (callback) {
              callback(renderable, layer);
            }

            break;
          }
        }
      }
    }
  }

  function _abortBucketRequests(bucket) {
    var renderer = bucket.renderer;
    var imageRequests = renderer.imageRequests;

    if (imageRequests) {
      for (var i = imageRequests.length; i--;) {
        var request = imageRequests[i];

        if (request.renderable) {
          request.abort();
        }
      }
    }
  }
  /**************************************************************************************************************/

  /**
   * Add post renderer
   */


  TileManager.prototype.addPostRenderer = function (renderer) {
    this.postRenderers.push(renderer);
    this.postRenderers.sort(function (r1, r2) {
      var z1 = r1.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
      var z2 = r2.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
      return z1 - z2;
    });

    if (renderer.generate) {
      this.visitTiles(function (tile) {
        renderer.generate(tile);
      });
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove a post renderer
   */


  TileManager.prototype.removePostRenderer = function (renderer) {
    var rendererIndex = this.postRenderers.indexOf(renderer);

    if (rendererIndex !== -1) {
      // Remove the renderer from all the tiles if it has a cleanupTile method
      if (renderer.cleanupTile) {
        this.visitTiles(function (tile) {
          renderer.cleanupTile(tile);
        });
      } // Remove renderer from the list


      this.postRenderers.splice(rendererIndex, 1);
    }
  };
  /**************************************************************************************************************/

  /**
   * Set the imagery provider to be used
   */


  TileManager.prototype.setImageryProvider = function (ip) {
    this.reset();
    this.imageryProvider = ip;

    if (ip) {
      // Clean tile pool
      this.tilePool.disposeAll();
      this.tiling = ip.tiling; // Rebuild level zero tiles

      this.tileConfig.imageSize = ip.tilePixelSize;
      this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool); // Update program

      if (ip.customShader) {
        this.program.dispose();
        this.program = new Program(this.renderContext); // Memorize current fragment shader

        this.currentFragmentShader = ip.customShader.fragmentCode ? ip.customShader.fragmentCode : this.fragmentShader;
        this.program.createFromSource(ip.customShader.vertexCode ? ip.customShader.vertexCode : this.vertexShader, this.currentFragmentShader);
      } else {
        // Revert to default if needed
        if (this.currentFragmentShader !== null) {
          this.program.dispose();
          this.program = new Program(this.renderContext);
          this.program.createFromSource(this.vertexShader, this.fragmentShader);
          this.currentFragmentShader = null;
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Set the elevation provider to be used
   */


  TileManager.prototype.setElevationProvider = function (tp) {
    this.reset();
    this.elevationProvider = tp;
    var newTesselation = tp ? tp.tilePixelSize : 9;

    if (newTesselation !== this.tileConfig.tesselation) {
      this.tileConfig.tesselation = newTesselation; // Reset the shared buffers : texture coordinate and indices

      var gl = this.renderContext.gl;
      this.tileIndexBuffer.reset();

      if (this.tcoordBuffer) {
        gl.deleteBuffer(this.tcoordBuffer);
        this.tcoordBuffer = null;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Reset the tile manager : unload all tiles
   */


  TileManager.prototype.reset = function () {
    // Abort all pending requests
    this.abortRequests(); // Reset all level zero tiles : destroy render data, and reset state to NONE

    for (var i = this.level0Tiles.length; i--;) {
      this.level0Tiles[i].deleteChildren(this.renderContext, this.tilePool);
      this.level0Tiles[i].dispose(this.renderContext, this.tilePool);
    }

    this.tileIndexBuffer.reset();
    this.level0TilesLoaded = false;
  };
  /**************************************************************************************************************/

  /**
   *    Abort all pending requests
   */


  TileManager.prototype.abortRequests = function () {
    for (var i = this.pendingRequests.length; i--;) {
      this.pendingRequests[i].abort();
    }
  };

  TileManager.prototype.abortLayerRequests = function (layer, callback) {
    //TODO Ce n'est pas sur pendingRequest mais sur les tiles de pending request
    //_abortTilesForLayer.call(this, this.pendingRequests, layer);
    this.abortRequests();

    _abortTilesForLayer.call(this, this.visibleTiles, layer, callback);
  };
  /**
   * Updates the visible tiles of the layer.
   * @param layer the layer where the tiles must be updated
   */


  TileManager.prototype.updateVisibleTiles = function (layer) {
    this.abortLayerRequests(layer);

    _updateOverlay(null, layer);
  };
  /**************************************************************************************************************/

  /**
   * Tile visitor
   * @param callback - Callback function on tile
   */


  TileManager.prototype.visitTiles = function (callback) {
    // Store the tiles to process in an array, first copy level0 tiles
    var tilesToProcess = this.level0Tiles.concat([]);

    while (tilesToProcess.length > 0) {
      // Retrieve the first tile and remove it from the array
      var tile = tilesToProcess.shift();
      callback(tile); // Add tile children to array to be processed later

      if (tile.children) {
        tilesToProcess.push(tile.children[0]);
        tilesToProcess.push(tile.children[1]);
        tilesToProcess.push(tile.children[2]);
        tilesToProcess.push(tile.children[3]);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Traverse tiless tiles
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   */


  TileManager.prototype.traverseTiles = function () {
    this.tilesToRender.length = 0;
    this.visibleTiles.length = 0;
    this.tilesToRequest.length = 0;
    this.numTraversedTiles = 0;
    var i, tile; // First load level 0 tiles if needed

    if (!this.level0TilesLoaded) {
      this.level0TilesLoaded = true;

      for (i = this.level0Tiles.length; i--;) {
        tile = this.level0Tiles[i];
        var tileIsLoaded = tile.state === Tile.State.LOADED; // Update frame number

        tile.frameNumber = this.frameNumber;
        this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;

        if (!tileIsLoaded) {
          // Request tile if necessary
          if (tile.state === Tile.State.NONE) {
            tile.state = Tile.State.REQUESTED;
            this.tilesToRequest.push(tile);
          } else if (tile.state === Tile.State.ERROR && this.imageryProvider) {
            this.publishEvent(Constants.EVENT_MSG.BASE_LAYERS_ERROR, this.imageryProvider);
          }
        }
      }

      if (this.level0TilesLoaded && this.imageryProvider) {
        this.publishEvent(Constants.EVENT_MSG.BASE_LAYERS_READY, this.imageryProvider);
      }
    } // Traverse tiles


    if (this.level0TilesLoaded) {
      // Normal traversal, iterate through level zero tiles and process them recursively
      for (i = this.level0Tiles.length; i--;) {
        tile = this.level0Tiles[i];

        if (!tile.isCulled(this.renderContext)) {
          this.processTile(tile, 0);
        } else {
          // Delete its children
          tile.deleteChildren(this.renderContext, this.tilePool);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Process a tile
   */


  TileManager.prototype.processTile = function (tile, level) {
    this.numTraversedTiles++; // Update frame number

    tile.frameNumber = this.frameNumber;
    var isLeaf = true; // Request the tile if needed

    if (tile.state === Tile.State.NONE) {
      tile.state = Tile.State.REQUESTED; // Add it to the request

      this.tilesToRequest.push(tile);
    } // Check if the tiles needs to be refined
    // We only refine loaded tile


    if (tile.state === Tile.State.LOADED) {
      if (this.imageryProvider) {
        isLeaf = level >= this.imageryProvider.numberOfLevels;
      } else {
        isLeaf = false;
      }

      isLeaf |= !tile.needsToBeRefined(this.renderContext);
    }

    if (isLeaf) {
      // Push the tiles to render only if the texture is valid or there is no imagery provider defined
      if (tile.texture || this.renderTileWithoutTexture) {
        this.tilesToRender.push(tile);
      }

      this.visibleTiles.push(tile);
    } else {
      // Create the children if needed
      if (tile.children === null) {
        tile.createChildren();
      }

      for (var i = 0; i < 4; i++) {
        if (!tile.children[i].isCulled(this.renderContext)) {
          this.processTile(tile.children[i], level + 1);
        } else {
          tile.children[i].deleteChildren(this.renderContext, this.tilePool);
        }
      }
    } // Traverse extension


    for (var x in tile.extension) {
      if (tile.extension.hasOwnProperty(x)) {
        var e = tile.extension[x];

        if (e.traverse) {
          e.traverse(tile, isLeaf);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Generate tile
   */


  TileManager.prototype.generateTile = function (tile, tileRequest) {
    tile.generate(this.tilePool, tileRequest.image, tileRequest.elevations); // Now post renderers can generate their data on the new tile

    for (var i = this.postRenderers.length; i--;) {
      if (this.postRenderers[i].generate) {
        this.postRenderers[i].generate(tile);
      }
    }

    this.numTilesGenerated++;
    this.renderContext.requestFrame();
  };
  /**************************************************************************************************************/

  /**
   * Generate tiles
   * @fires Context#endBackgroundLoad
   */


  TileManager.prototype.generateReceivedTiles = function () {
    while (this.completedRequests.length > 0) {
      var tileRequest = this.completedRequests.pop();
      var tile = tileRequest.tile;

      if (tile.frameNumber === this.frameNumber) {
        this.generateTile(tile, tileRequest);
      } else {
        tile.state = Tile.State.NONE;
      }

      this.availableRequests.push(tileRequest);
    } // All requests have been processed, send endBackgroundLoad event


    if (this.availableRequests.length === this.maxRequests && this.imageryProvider) {
      this.publishEvent(Constants.EVENT_MSG.LAYER_END_BACKGROUND_LOAD);
    }
  };
  /**************************************************************************************************************/

  /**
   * Render tiles
   */


  TileManager.prototype.renderTiles = function () {
    var rc = this.renderContext;
    var gl = rc.gl;
    var i, tile; // Compute near/far from tiles
    //var nr;
    //var fr;

    if (this.tileConfig.cullSign < 0) {
      // When in "Astro" mode, do not compute near/far from tiles not really needed
      // And the code used for "Earth" does not works really well, when the earth is seen from inside...
      // rc.near = Math.max(
      //     rc.minNear,
      //     0.2 * this.tileConfig.coordinateSystem.geoide.radius
      // );
      rc.far = Math.max(rc.minFar, 1.1 * this.tileConfig.coordinateSystem.geoide.radius);
    }

    if (this.tilesToRender.length !== 0) {
      // Set state (depends if geo or astro)
      if (this.tileConfig.cullSign < 0) {
        gl.depthMask(false);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
      } else {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0, 4);
      } // Check if the program of imagery provider changed
      // Only for fragment shader for now


      if (this.currentFragmentShader && this.currentFragmentShader !== this.imageryProvider.customShader.fragmentCode) {
        this.program.dispose();
        this.program = new Program(this.renderContext);
        this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader;
        this.program.createFromSource(this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader, this.currentFragmentShader);
      } // Setup program


      this.program.apply();
      var attributes = this.program.attributes; // Update projection matrix with new near and far values

      mat4.perspective(rc.fov, rc.canvas.width / rc.canvas.height, rc.near, rc.far, rc.projectionMatrix); // Update uniforms if needed

      if (this.imageryProvider && this.imageryProvider.customShader) {
        this.imageryProvider.customShader.updateUniforms(gl, this.program);
      } // Setup state


      gl.activeTexture(gl.TEXTURE0);
      gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, rc.projectionMatrix);
      gl.uniform1i(this.program.uniforms.colorTexture, 0); // Bind the texture coordinate buffer (shared between all tiles

      if (!this.tcoordBuffer) {
        this.buildSharedTexCoordBuffer();
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
      gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
      var currentIB = null;

      for (i = this.tilesToRender.length; i--;) {
        tile = this.tilesToRender[i];
        var isLoaded = tile.state === Tile.State.LOADED;
        var isLevelZero = tile.parentIndex === -1; // Bind tile texture if defined, the default texture otherwise

        if (tile.texture) {
          gl.bindTexture(gl.TEXTURE_2D, tile.texture);
        } else {
          gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
        } // Update uniforms for modelview matrix


        mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
        gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, rc.modelViewMatrix); // Bind the vertex buffer

        gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 4 * this.tileConfig.vertexSize, 0);

        if (this.tileConfig.normals) {
          gl.vertexAttribPointer(attributes.normal, 3, gl.FLOAT, false, 4 * this.tileConfig.vertexSize, 12);
        }

        var indexBuffer = isLoaded || isLevelZero ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(tile.parentIndex); // Bind the index buffer only if different (index buffer is shared between tiles)

        if (currentIB !== indexBuffer) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
          currentIB = indexBuffer;
        } // Finally draw the tiles


        gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
      }

      if (this.tileConfig.cullSign < 0) {
        gl.depthMask(true);
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
    }

    for (i = this.postRenderers.length; i--;) {
      this.postRenderers[i].render(this.visibleTiles);
    }
  }; // Internal function to sort tiles


  var _sortTilesByDistance = function (t1, t2) {
    return t1.distance - t2.distance;
  };
  /**************************************************************************************************************/

  /**
   * Request tiles
   * @fires Context#startBackgroundLoad
   */


  TileManager.prototype.launchRequests = function () {
    // Process request
    this.tilesToRequest.sort(_sortTilesByDistance);
    var trl = this.tilesToRequest.length;

    for (var i = trl; i--;) {
      var tile = this.tilesToRequest[i];

      if (this.availableRequests.length > 0) {
        // Check to limit the number of requests done per frame
        // First launch request, send an event
        if (this.availableRequests.length === this.maxRequests && this.imageryProvider) {
          this.publishEvent(Constants.EVENT_MSG.LAYER_START_BACKGROUND_LOAD);
        }

        var tileRequest = this.availableRequests.pop();
        tileRequest.launch(tile);
      } else {
        tile.state = Tile.State.NONE;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Render the tiles
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   */


  TileManager.prototype.render = function () {
    /*           console.log("TileManager.prototype.render",this.tileConfig.coordSystem);
               if (this.tileConfig.coordSystem === "GAL") {
               console.log("No rendering");
               return;
               }
               console.log("============================================");
               */
    if (this.imageryProvider && !this.imageryProvider._ready) {
      return;
    } // Specific case when the image provider has a level zero image : generate the texture for each level zero tile


    if (!this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage) {
      this.imageryProvider.generateLevel0Textures(this.level0Tiles, this.tilePool);

      for (var n = this.level0Tiles.length; n--;) {
        var tile = this.level0Tiles[n]; // Generate the tile without tile request

        this.generateTile(tile, {});
      }

      this.level0TilesLoaded = true;
      this.publishEvent(Constants.EVENT_MSG.BASE_LAYERS_READY, this.imageryProvider);
    }

    var stats = this.renderContext.stats;

    if (!this.freeze) {
      if (stats) {
        stats.start("traverseTime");
      }

      this.traverseTiles();

      if (stats) {
        stats.end("traverseTime");
      }
    }

    if (this.level0TilesLoaded || !this.imageryProvider) {
      if (stats) {
        stats.start("renderTime");
      }

      this.renderTiles();

      if (stats) {
        stats.end("renderTime");
      }
    }

    if (stats) {
      stats.start("generateTime");
    }

    this.generateReceivedTiles();

    if (stats) {
      stats.end("generateTime");
    }

    if (stats) {
      stats.start("requestTime");
    }

    this.launchRequests();

    if (stats) {
      stats.end("requestTime");
    }

    this.frameNumber++;
  };
  /**************************************************************************************************************/

  /**
   * Returns visible tile for given longitude/latitude, null otherwise
   */


  TileManager.prototype.getVisibleTile = function (lon, lat) {
    return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
  };
  /**************************************************************************************************************/

  /**
   * Build shared texture coordinate buffer
   */


  TileManager.prototype.buildSharedTexCoordBuffer = function () {
    var size = this.tileConfig.tesselation;
    var skirt = this.tileConfig.skirt;
    var bufferSize = 2 * size * size;

    if (skirt) {
      bufferSize += 2 * size * 6;
    }

    var tcoords = new Float32Array(bufferSize);
    var step = 1.0 / (size - 1);
    var offset = 0;
    var u, v;
    var i, j;
    v = 0.0;

    for (j = 0; j < size; j++) {
      u = 0.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        offset += 2;
        u += step;
      }

      v += step;
    }

    if (skirt) {
      // Top skirt
      u = 0.0;
      v = 0.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        u += step;
        offset += 2;
      } // Bottom skirt


      u = 0.0;
      v = 1.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        u += step;
        offset += 2;
      } // Left skirt


      u = 0.0;
      v = 0.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        v += step;
        offset += 2;
      } // Right skirt


      u = 1.0;
      v = 0.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        v += step;
        offset += 2;
      } // Center skirt


      u = 0.0;
      v = 0.5;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        u += step;
        offset += 2;
      } // Middle skirt


      u = 0.5;
      v = 0.0;

      for (i = 0; i < size; i++) {
        tcoords[offset] = u;
        tcoords[offset + 1] = v;
        v += step;
        offset += 2;
      }
    }

    var gl = this.renderContext.gl;
    var tcb = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
    gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);
    this.tcoordBuffer = tcb;
  };
  /**
   * Set freeze
   * @function setFreeze
   * @memberof TileManager.prototype
   * @param {Boolean} freeze Freeze active or not
   */


  TileManager.prototype.setFreeze = function (freeze) {
    this.freeze = freeze;
  };
  /**
   * Get freeze
   * @function getFreeze
   * @memberof TileManager.prototype
   * @return {Boolean} Freeze active or not
   */


  TileManager.prototype.getFreeze = function () {
    return this.freeze;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
    @name RendererTileData
    @class
  	  RendererTileData constructor
      Contains a list of renderables for the tiles
    @param manager
    @constructor
    */
  var RendererTileData = function (manager) {
    this.manager = manager;
    this.renderables = [];
  };
  /**************************************************************************************************************/

  /**
   * Initialize a child tile
   * @function initChild
   * @memberof RendererTileData.prototype
   * @param childTile
   * @param i
   * @param j
   */


  RendererTileData.prototype.initChild = function (childTile, i, j) {
    var childData;

    for (var n = 0; n < this.renderables.length; n++) {
      if (this.renderables[n].initChild) {
        var r = this.renderables[n].initChild(i, j, childTile);

        if (r) {
          if (!childData) {
            childData = childTile.extension.renderer = new RendererTileData(this.manager);
          }

          childData.renderables.push(r);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Traverse the renderer data
   * @function traverse
   * @memberof RendererTileData.prototype
   * @param {Tile} tile Tile
   * @param isLeaf
   */


  RendererTileData.prototype.traverse = function (tile, isLeaf) {
    for (var i = 0; i < this.renderables.length; i++) {
      var renderable = this.renderables[i];
      var bucket = renderable.bucket;

      if (bucket.layer.isVisible() && bucket.layer.getOpacity() > 0) {
        if (renderable.traverse) {
          renderable.traverse(this.manager, tile, isLeaf);
        } else {
          if (renderable.hasChildren && !isLeaf) {
            continue;
          }

          this.manager.renderables.push(renderable);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Get a renderable from the tile, given the bucket
   * @function getRenderable
   * @memberof RendererTileData.prototype
   * @param {Bucket} bucket Bucket
   * @return Renderable
   */


  RendererTileData.prototype.getRenderable = function (bucket) {
    for (var i = 0; i < this.renderables.length; i++) {
      if (bucket === this.renderables[i].bucket) {
        return this.renderables[i];
      }
    }

    return null;
  };
  /**************************************************************************************************************/

  /**
   * Dispose renderable data from tile
   * @function dispose
   * @memberof RendererTileData.prototype
   * @param renderContext
   * @param tilePool
   */


  RendererTileData.prototype.dispose = function (renderContext, tilePool) {
    for (var i = 0; i < this.renderables.length; i++) {
      this.renderables[i].dispose(renderContext, tilePool);
    }

    this.renderables.length = 0;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       @name RasterOverlayRenderer
       @class
           RasterOverlayRenderer constructor
       @param {AbstractGlobe} globe AbstractGLobe
       @constructor
       */

  var RasterOverlayRenderer = function (globe) {
    this.vertexShader = "attribute vec3 vertex;\n";
    this.vertexShader += "attribute vec2 tcoord;\n";
    this.vertexShader += "uniform mat4 modelViewMatrix;\n";
    this.vertexShader += "uniform mat4 projectionMatrix;\n";
    this.vertexShader += "uniform vec4 textureTransform; \n";
    this.vertexShader += "varying vec2 texCoord;\n";
    this.vertexShader += "void main(void) \n";
    this.vertexShader += "{\n";
    this.vertexShader += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
    this.vertexShader += "	texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n";
    this.vertexShader += "}\n";
    this.fragmentShader = "precision lowp float;\n";
    this.fragmentShader += "varying vec2 texCoord;\n";
    this.fragmentShader += "uniform sampler2D overlayTexture;\n";
    this.fragmentShader += "uniform float opacity; \n";
    this.fragmentShader += "uniform vec3 levelColRow;\n";
    this.fragmentShader += "void main(void)\n";
    this.fragmentShader += "{\n";
    this.fragmentShader += "	gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n";
    this.fragmentShader += "	gl_FragColor.a *= opacity; \n"; // this.fragmentShader += "    gl_FragColor.rgb = levelColRow / vec3(16.0);\n";
    // this.fragmentShader += "    gl_FragColor.a = min(gl_FragColor.a + 0.8, 1.0);\n";

    this.fragmentShader += "}\n";
    this.lerpFragmentShader = `precision lowp float;

            varying vec2 texCoord;
            uniform sampler2D fromOverlayTexture;
            uniform sampler2D toOverlayTexture;
            uniform float time;
            uniform float totalTime;
            uniform float opacity;

            void main() {
                vec4 fromColor = texture2D(fromOverlayTexture, texCoord.xy);
                vec4 toColor = texture2D(toOverlayTexture, texCoord.xy);
                gl_FragColor = mix(fromColor, toColor, time / totalTime);
                gl_FragColor.a *= opacity;
                // gl_FragColor.rgba = vec4(0, 1, 0, opacity);
            }`;
    this.rendererManager = globe.getRendererManager();
    this.tileManager = globe.tileManager;
    this.programs = [];
    this.program = this.createProgram({
      vertexCode: this.vertexShader,
      fragmentCode: this.fragmentShader,
      updateUniforms: null
    });
    this.lerpProgram = this.createProgram({
      vertexCode: this.vertexShader,
      fragmentCode: this.lerpFragmentShader,
      updateUniforms: null
    });
    this.buckets = [];
    this.imageRequests = [];
    this.frameNumber = 0;
    this.oldRenderables = {};
    var self = this;

    for (var i = 0; i < 4; i++) {
      var imageRequest = new ImageRequest({
        successCallback: function () {
          if (this.renderable) {
            if (this.renderable.bucket.layer.handleImage) {
              this.renderable.bucket.layer.handleImage(this);
            }

            this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(this.image);
            this.renderable.texture = this.renderable.ownTexture;
            this.renderable.uvScale = 1.0;
            this.renderable.uTrans = 0.0;
            this.renderable.vTrans = 0.0;
            this.renderable.updateChildrenTexture();
            this.renderable.onRequestFinished(true);
            const {
              level,
              x,
              y
            } = this.renderable.tile;

            try {
              const oldRenderable = self.oldRenderables[level][x][y];

              if (oldRenderable && oldRenderable.ownTexture) {
                this.renderable.oldRenderable = oldRenderable;
                this.renderable.needsLerp = false; // origin : true => Set to false to fix a problem with the interpollation

                this.renderable.time = 0.0;
              }
            } catch (error) {// Nothing to do
            }

            this.renderable = null;
            self.tileManager.renderContext.requestFrame();
          }
        },
        failCallback: function () {
          if (this.renderable) {
            this.renderable.onRequestFinished(true);
            this.renderable = null;
          }
        },
        abortCallback: function () {
          //console.log("Raster overlay request abort.");
          if (this.renderable) {
            this.renderable.onRequestFinished(false);
            this.renderable = null;
          }
        }
      });
      this.imageRequests.push(imageRequest);
    }
  };
  /**************************************************************************************************************/

  /**
       @name RasterOverlayRenderable
       @class
           Create a renderable for the overlay.
       There is one renderable per overlay and per tile.
       @param {Bucket} bucket Bucket
       @constructor
       */


  var RasterOverlayRenderable = function (bucket) {
    this.bucket = bucket;
    this.bucket.renderables.push(this);
    this.ownTexture = null;
    this.texture = null;
    this.oldRenderable = null;
    this.needsLerp = false;
    this.time = 0.0;
    this.request = null;
    this.requestFinished = false;
    this.tile = null;
    this.uvScale = 1.0;
    this.uTrans = 0.0;
    this.vTrans = 0.0;
  };
  /**************************************************************************************************************/

  /**
   * Called when a request is started
   * @function onRequestStarted
   * @memberof RasterOverlayRenderable.prototype
   * @param {string}request Request
   * @fires Context#startLoad
   */


  RasterOverlayRenderable.prototype.onRequestStarted = function (request) {
    this.request = request;
    this.requestFinished = false;
    var layer = this.bucket.layer;

    if (layer._numRequests === 0) {
      layer.globe.publishEvent(Constants.EVENT_MSG.LAYER_START_LOAD, layer);
    }

    layer._numRequests++;
  };
  /**************************************************************************************************************/

  /**
   * Called when a request is finished
   * @function onRequestFinished
   * @memberof RasterOverlayRenderable.prototype
   * @param completed
   * @fires Context#endLoad
   */


  RasterOverlayRenderable.prototype.onRequestFinished = function (completed) {
    this.request = null;
    this.requestFinished = completed;
    var layer = this.bucket.layer;
    layer._numRequests--;

    if (layer.getGlobe() && layer._numRequests === 0) {
      layer.getGlobe().publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, layer);
    }
  };
  /**************************************************************************************************************/

  /**
   * Initialize a child renderable
   * @function initChild
   * @memberof RasterOverlayRenderable.prototype
   * @param i
   * @param j
   * @param childTile
   */


  RasterOverlayRenderable.prototype.initChild = function (i, j, childTile) {
    // Request finished and no texture  : no init needed for children

    /*	// TODO : does not work because sometimes level 0 cannot be loaded
           if (this.requestFinished && !this.ownTexture)
           return null;*/
    var renderable = this.bucket.createRenderable();
    renderable.tile = childTile;

    if (this.texture) {
      renderable.texture = this.texture;
      renderable.uvScale = this.uvScale;
      renderable.uTrans = this.uTrans;
      renderable.vTrans = this.vTrans;
    }

    return renderable;
  };
  /**************************************************************************************************************/

  /**
   * Generate child renderable
   * @function generateChild
   * @memberof RasterOverlayRenderable.prototype
   * @param {Tile} tile Tile
   */


  RasterOverlayRenderable.prototype.generateChild = function (tile) {
    // Request finished and no texture  : no generate needed for children

    /*	// TODO : does not work because sometimes level 0 cannot be loaded
           if (this.requestFinished && !this.ownTexture)
           return;*/
    var r = this.bucket.renderer;
    r.addOverlayToTile(tile, this.bucket, this);
  };
  /**************************************************************************************************************/

  /**
   * Update the children texture
   * @function updateChildrenTexture
   * @memberof RasterOverlayRenderable.prototype
   */


  RasterOverlayRenderable.prototype.updateChildrenTexture = function () {
    if (this.tile.children) {
      for (var i = 0; i < 4; i++) {
        var rd = this.tile.children[i].extension.renderer;

        if (rd) {
          var cr = rd.getRenderable(this.bucket);

          if (cr && !cr.ownTexture) {
            cr.updateTextureFromParent(this);
            cr.updateChildrenTexture();
          }
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Update texture from its parent
   * @function updateTextureFromParent
   * @memberof RasterOverlayRenderable.prototype
   * @param parent
   */


  RasterOverlayRenderable.prototype.updateTextureFromParent = function (parent) {
    if (this.tile.state === Tile.State.LOADED) {
      this.texture = parent.texture;
      this.uvScale = parent.uvScale * 0.5;
      this.uTrans = parent.uTrans;
      this.vTrans = parent.vTrans;
      this.uTrans += this.tile.parentIndex & 1 ? this.uvScale : 0;
      this.vTrans += this.tile.parentIndex & 2 ? this.uvScale : 0;
    } else {
      this.texture = parent.texture;
      this.uvScale = parent.uvScale;
      this.uTrans = parent.uTrans;
      this.vTrans = parent.vTrans;
    }
  };
  /**************************************************************************************************************/

  /**
       * Traverse renderable : add it to renderables list if there is a texture
       Request the texture
       * @function traverse
       * @memberof RasterOverlayRenderable.prototype
       * @param manager
       * @param {Tile} tile Tile
       * @param {Boolean} isLeaf
       */


  RasterOverlayRenderable.prototype.traverse = function (manager, tile, isLeaf) {
    if (isLeaf && this.texture) {
      manager.renderables.push(this);
    } else if (isLeaf) {
      const oldRenderables = this.bucket.renderer.oldRenderables;

      try {
        const oldRenderable = oldRenderables[tile.level][tile.x][tile.y];

        if (oldRenderable && oldRenderable.ownTexture) {
          const renderable = Object.assign({}, this);
          renderable.texture = oldRenderable.ownTexture;
          manager.renderables.push(renderable);
        }
      } catch (error) {// do nothing
      }
    }

    if (!this.requestFinished && this.tile.state === Tile.State.LOADED) {
      this.bucket.renderer.requestOverlayTextureForTile(this);
    }
  };
  /**************************************************************************************************************/

  /**
   * Dispose the renderable
   * @function dispose
   * @memberof RasterOverlayRenderable.prototype
   * @param renderContext
   * @param tilePool
   */


  RasterOverlayRenderable.prototype.dispose = function (renderContext, tilePool) {
    if (this.ownTexture) {
      tilePool.disposeGLTexture(this.ownTexture);
      this.ownTexture = null;
    }
  };
  /**************************************************************************************************************/

  /**
       @name Bucket
       @class
           Bucket constructor for RasterOverlay
       @param layer
       @constructor
       */


  var Bucket = function (layer) {
    this.layer = layer;
    this.renderer = null;
    this.style = layer.style;
    this.renderables = [];
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof Bucket.prototype
   * @return {RasterOverlayRenderable} Renderable
   */


  Bucket.prototype.createRenderable = function () {
    return new RasterOverlayRenderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Add an overlay into the renderer.
   * The overlay is added to all loaded tiles.
   * @function addOverlay
   * @memberof RasterOverlayRenderer.prototype
   * @param overlay
   */


  RasterOverlayRenderer.prototype.addOverlay = function (overlay) {
    // Initialize num requests to 0
    overlay._numRequests = 0;
    var bucket = new Bucket(overlay);
    bucket.renderer = this;
    bucket.id = this.rendererManager.bucketId++;
    this.buckets.push(bucket);
    overlay._bucket = bucket;

    for (var i = 0; i < this.tileManager.level0Tiles.length; i++) {
      var tile = this.tileManager.level0Tiles[i];

      if (tile.state === Tile.State.LOADED) {
        this.addOverlayToTile(tile, bucket);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove an overlay
   * The overlay is removed from all loaded tiles.
   * @function removeOverlay
   * @memberof RasterOverlayRenderer.prototype
   * @param overlay
   */


  RasterOverlayRenderer.prototype.removeOverlay = function (overlay, noDispose) {
    var index = this.buckets.indexOf(overlay._bucket);
    this.buckets.splice(index, 1);
    var rc = this.tileManager.renderContext;
    var tp = this.tileManager.tilePool;
    this.tileManager.visitTiles(function (tile) {
      var rs = tile.extension.renderer;
      var renderable = rs ? rs.getRenderable(overlay._bucket) : null;

      if (renderable) {
        // Remove the renderable
        var index = rs.renderables.indexOf(renderable);
        rs.renderables.splice(index, 1);

        if (!noDispose) {
          // Dispose its data
          renderable.dispose(rc, tp);
        } // Remove tile data if not needed anymore


        if (rs.renderables.length === 0) {
          delete tile.extension.renderer;
        }
      }
    });
  };
  /**************************************************************************************************************/


  RasterOverlayRenderer.prototype.updateOverlay = function (overlay) {
    var oldBucket = overlay._bucket;
    var rc = this.tileManager.renderContext;
    var tp = this.tileManager.tilePool;

    if (oldBucket) {
      for (var j = 0; j < oldBucket.renderables.length; ++j) {
        const renderable = oldBucket.renderables[j];

        if (renderable.ownTexture) {
          const {
            level,
            x,
            y
          } = renderable.tile; // If there is already old data, dispose it

          try {
            const oldRenderable = this.oldRenderables[level][x][y];
            oldRenderable.dispose(rc, tp);
          } catch (e) {// No-op
          }

          if (!this.oldRenderables[level]) this.oldRenderables[level] = {};
          if (!this.oldRenderables[level][x]) this.oldRenderables[level][x] = {};
          this.oldRenderables[level][x][y] = renderable;
        }
      }
    }

    this.removeOverlay(overlay, true);

    if (overlay.containsDimension("time") && overlay.time && !overlay.time.isInTimeDefinition(overlay.getDimensions().time.value)) ; else {
      this.addOverlay(overlay);
    }
  };
  /**************************************************************************************************************/

  /**
   * Add an overlay into a tile.
   * Create tile data if needed, and create the renderable for the overlay.
   * @function addOverlayToTile
   * @memberof RasterOverlayRenderer.prototype
   * @param tile
   * @param bucket
   * @param parentRenderable
   */


  RasterOverlayRenderer.prototype.addOverlayToTile = function (tile, bucket, parentRenderable) {
    if (!this.overlayIntersects(tile.geoBound, bucket.layer)) {
      return;
    }

    if (!tile.extension.renderer) {
      tile.extension.renderer = new RendererTileData(this.rendererManager);
    }

    var renderable = bucket.createRenderable();
    renderable.tile = tile;
    tile.extension.renderer.renderables.push(renderable);

    if (parentRenderable && parentRenderable.texture) {
      renderable.updateTextureFromParent(parentRenderable);
    }

    if (tile.children) {
      // Add the overlay to loaded children
      for (var i = 0; i < 4; i++) {
        if (tile.children[i].state === Tile.State.LOADED) {
          this.addOverlayToTile(tile.children[i], bucket, renderable);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Create an interpolated for polygon clipping
   */


  var _createInterpolatedVertex = function (t, p1, p2) {
    return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
  };
  /**************************************************************************************************************/

  /**
   * Clip polygon to a side (used by bound-overlay intersection)
   * @function clipPolygonToSide
   * @memberof RasterOverlayRenderer.prototype
   * @param coord
   * @param sign
   * @param value
   * @param polygon
   */


  RasterOverlayRenderer.prototype.clipPolygonToSide = function (coord, sign, value, polygon) {
    var clippedPolygon = [];
    var t, newPoint; // iterate through vertices

    for (var i = 0; i < polygon.length; i++) {
      var p1 = polygon[i];
      var p2 = polygon[(i + 1) % polygon.length];
      var val1 = p1[coord];
      var val2 = p2[coord]; // test containement

      var firstInside = (val1 - value) * sign >= 0.0;
      var secondInside = (val2 - value) * sign >= 0.0; // output vertices for inside polygon

      if (!firstInside && secondInside) {
        t = (value - val1) / (val2 - val1);
        newPoint = _createInterpolatedVertex(t, p1, p2);
        clippedPolygon.push(newPoint);
        clippedPolygon.push(p2);
      } else if (firstInside && secondInside) {
        clippedPolygon.push(p2);
      } else if (firstInside && !secondInside) {
        t = (value - val1) / (val2 - val1);
        newPoint = _createInterpolatedVertex(t, p1, p2);
        clippedPolygon.push(newPoint);
      }
    }

    return clippedPolygon;
  };
  /**************************************************************************************************************/

  /**
   * Check the intersection between a geo bound and an overlay
   * @function overlayIntersects
   * @memberof RasterOverlayRenderer.prototype
   * @param bound
   * @param overlay
   * @return {Boolean} Is intersects ?
   */


  RasterOverlayRenderer.prototype.overlayIntersects = function (bound, overlay) {
    if (overlay.coordinates) {
      var c;
      c = this.clipPolygonToSide(0, 1, bound.west, overlay.coordinates);
      c = this.clipPolygonToSide(0, -1, bound.east, c);
      c = this.clipPolygonToSide(1, 1, bound.south, c);
      c = this.clipPolygonToSide(1, -1, bound.north, c);
      return c.length > 0;
    } else if (overlay.geoBound) {
      return overlay.geoBound.intersects(bound);
    } // No geobound or coordinates : always return true


    return true;
  };
  /**************************************************************************************************************/

  /**
   * Generate Raster overlay data on the tile.
   * The method is called by TileManager when a new tile has been generated.
   * @function generateLevelZero
   * @memberof RasterOverlayRenderer.prototype
   * @param {Tile} tile Tile
   */


  RasterOverlayRenderer.prototype.generateLevelZero = function (tile) {
    // Traverse all overlays
    for (var i = 0; i < this.buckets.length; i++) {
      this.addOverlayToTile(tile, this.buckets[i]);
    }
  };
  /**************************************************************************************************************/

  /**
   * Request the overlay texture for a tile
   * @function requestOverlayTextureForTile
   * @memberof RasterOverlayRenderer.prototype
   * @param renderable
   */


  RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function (renderable) {
    if (!renderable.request) {
      var imageRequest;

      for (var i = 0; i < this.imageRequests.length; i++) {
        if (!this.imageRequests[i].renderable) {
          imageRequest = this.imageRequests[i];
          break;
        }
      }

      if (imageRequest) {
        var url = renderable.bucket.layer.getUrl(renderable.tile);

        if (url !== null) {
          renderable.onRequestStarted(imageRequest);
          imageRequest.renderable = renderable;
          imageRequest.frameNumber = this.frameNumber;
          imageRequest.send(renderable.bucket.layer.getUrl(renderable.tile), renderable.bucket.layer.crossOrigin);
        }
      }
    } else {
      renderable.request.frameNumber = this.frameNumber;
    }
  };
  /**************************************************************************************************************/

  /**
   * Create program from customShader object
   * @function createProgram
   * @memberof RasterOverlayRenderer.prototype
   * @param customShader
   * @return {Program} Program
   */


  RasterOverlayRenderer.prototype.createProgram = function (customShader) {
    var program = new Program(this.tileManager.renderContext);
    program.createFromSource(this.vertexShader, customShader.fragmentCode); // Add program

    program.id = this.programs.length;
    this.programs.push({
      fragmentCode: customShader.fragmentCode,
      program: program
    });
    return program;
  };
  /**************************************************************************************************************/

  /**
   * Get program if known by renderer, create otherwise
   * @function getProgram
   * @memberof RasterOverlayRenderer.prototype
   * @param customShader
   * @return {Program} Program
   */


  RasterOverlayRenderer.prototype.getProgram = function (customShader) {
    var program;

    for (var id = 0; id < this.programs.length; id++) {
      if (this.programs[id].fragmentCode === customShader.fragmentCode) {
        program = this.programs[id].program;
      }
    }

    if (!program) {
      program = this.createProgram(customShader);
    }

    return program;
  };
  /**************************************************************************************************************/

  /**
   *    Render the raster overlays for the given tiles
   * @function render
   * @memberof RasterOverlayRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  RasterOverlayRenderer.prototype.render = function (renderables, start, end) {
    var rc = this.tileManager.renderContext;
    var gl = rc.gl; // Update gl states

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL);
    var modelViewMatrix = mat4.create();
    var currentIB = null;
    var currentProgram = null;

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      var bucket = renderable.bucket;
      var layer = bucket.layer;
      var updateUniforms;
      var program;

      if (layer.customShader) {
        program = this.getProgram(layer.customShader);
        updateUniforms = layer.customShader.updateUniforms;
      } else if (renderable.needsLerp) {
        program = this.getProgram({
          vertexCode: this.vertexShader,
          fragmentCode: this.lerpFragmentShader,
          updateUniforms: null
        });
      } else {
        program = this.getProgram({
          vertexCode: this.vertexShader,
          fragmentCode: this.fragmentShader,
          updateUniforms: null
        });
      } // Apply program if changed


      if (program !== currentProgram) {
        currentProgram = program;
        program.apply();
        gl.uniformMatrix4fv(program.uniforms.projectionMatrix, false, rc.projectionMatrix);

        if (renderable.needsLerp) {
          gl.uniform1i(program.uniforms.fromOverlayTexture, 0);
          gl.uniform1i(program.uniforms.toOverlayTexture, 1);
        } else {
          gl.uniform1i(program.uniforms.overlayTexture, 0);
        } // Bind tcoord buffer


        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
        gl.vertexAttribPointer(program.attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
      }

      if (updateUniforms) {
        updateUniforms(gl, program);
      } // Bind the vertex buffer


      gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
      gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 4 * renderable.tile.config.vertexSize, 0); // Bind the index buffer only if different (index buffer is shared between tiles)

      var indexBuffer = renderable.tile.state === Tile.State.LOADED ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(renderable.tile.parentIndex);

      if (currentIB !== indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        currentIB = indexBuffer;
      } // Bind the tile tile matrix


      mat4.multiply(rc.viewMatrix, renderable.tile.matrix, modelViewMatrix);
      gl.uniformMatrix4fv(program.uniforms.modelViewMatrix, false, modelViewMatrix);
      gl.uniform1f(program.uniforms.opacity, layer.getOpacity());
      gl.uniform4f(program.uniforms.textureTransform, renderable.uvScale, renderable.uvScale, renderable.uTrans, renderable.vTrans);
      gl.uniform3f(program.uniforms.levelColRow, renderable.tile.level, renderable.tile.x, renderable.tile.y);

      if (renderable.needsLerp) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, renderable.oldRenderable.texture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, renderable.texture);
        gl.uniform1f(program.uniforms.time, renderable.time);
        gl.uniform1f(program.uniforms.totalTime, 500);
      } else {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, renderable.texture || renderable.oldRenderable.texture);
      }

      if (renderable.needsLerp) {
        renderable.time += rc.deltaTime;

        if (renderable.time > 500) {
          renderable.needsLerp = false;
          renderable.oldRenderable = null;
        }
      } // Finally draw the tiles


      gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
    } // reset gl states


    gl.disable(gl.BLEND); //gl.disable(gl.POLYGON_OFFSET_FILL);

    gl.depthFunc(gl.LESS);
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof RasterOverlayRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Can apply ?
   */


  RasterOverlayRenderer.prototype.canApply = function (type, style) {
    return false;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**
  	@name GroundOverlayRenderer
  	@class
  	 GroundOverlayRenderer constructor
  	@param {TileManager} tileManager Tile manager
  	@constructor
  	*/

  var GroundOverlayRenderer = function (tileManager) {
    this.enabled = true;
    this.renderContext = tileManager.renderContext;
    this.tileManager = tileManager;
    var vertexShader = "attribute vec3 vertex;\n";
    vertexShader += "attribute vec2 tcoord;\n";
    vertexShader += "uniform mat4 modelViewMatrix;\n";
    vertexShader += "uniform mat4 projectionMatrix;\n";
    vertexShader += "uniform vec4 extent; \n";
    vertexShader += "varying vec2 texCoord;\n";
    vertexShader += "void main(void) \n";
    vertexShader += "{\n";
    vertexShader += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
    vertexShader += "	texCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n";
    vertexShader += "	texCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n";
    vertexShader += "}\n";
    var fragmentShader = "#ifdef GL_ES\n";
    fragmentShader += "precision highp float;\n";
    fragmentShader += "#endif\n";
    fragmentShader += "\n";
    fragmentShader += "varying vec2 texCoord;\n";
    fragmentShader += "uniform sampler2D overlayTexture;\n";
    fragmentShader += "uniform mat3 transform;\n";
    fragmentShader += "uniform float opacity; \n";
    fragmentShader += "\n";
    fragmentShader += "void main(void)\n";
    fragmentShader += "{\n";
    fragmentShader += "	vec3 tc = transform * vec3(texCoord,1.0); \n";
    fragmentShader += "	tc.xy /= tc.z; \n";
    fragmentShader += "	gl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n";
    fragmentShader += "	gl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n";
    fragmentShader += "}\n";
    this.program = new Program(this.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
    this.groundOverlays = [];
  }; //*************************************************************************

  /*
  	Render the ground overlays above the tiles in parameter
   */


  GroundOverlayRenderer.prototype.render = function (tiles) {
    if (this.enabled === false) {
      // Disabled, so no rendering
      return;
    }

    var gl = this.renderContext.gl; // Setup program

    this.program.apply();
    var attributes = this.program.attributes;
    gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, this.renderContext.projectionMatrix);
    gl.uniform1i(this.program.uniforms.overlayTexture, 0);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL);
    gl.depthMask(false);
    var modelViewMatrix = mat4.create();
    var currentIB = null;

    for (var j = 0; j < this.groundOverlays.length; j++) {
      var go = this.groundOverlays[j]; // Image is not loaded, nothing to be done

      if (!go.image.complete) {
        continue;
      }

      if (!go.texture) {
        go.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(go.image, go.flipY);
      }

      var initialized = false;

      for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];

        if (go.geoBound.intersects(tile.geoBound)) {
          if (!initialized) {
            gl.uniformMatrix3fv(this.program.uniforms.transform, false, go.inverseTransform);
            gl.uniform1f(this.program.uniforms.opacity, go.getOpacity());
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, go.texture);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
            gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
            initialized = true;
          }

          var extent = tile.state === Tile.State.LOADED ? tile.bound : tile.parent.bound;
          gl.uniform4f(this.program.uniforms.extent, extent.west, extent.east, extent.north, extent.south);
          mat4.multiply(this.renderContext.viewMatrix, tile.matrix, modelViewMatrix);
          gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, modelViewMatrix); // Bind the vertex buffer

          gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
          gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0); // Bind the index buffer only if different (index buffer is shared between tiles)

          var indexBuffer = tile.state === Tile.State.LOADED ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(tile.parentIndex);

          if (currentIB !== indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            currentIB = indexBuffer;
          } // Finally draw the tiles


          gl.drawElements(gl.TRIANGLES, indexBuffer.numIndices, gl.UNSIGNED_SHORT, 0);
        }
      }
    }

    gl.disable(gl.BLEND);
    gl.depthMask(true);
  }; //*************************************************************************

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   @name RendererManager
   @class
       RendererManager constructor
   @param {AbstractGlobe} globe AbstractGlobe
   @constructor
   */

  var RendererManager = function (globe) {
    // Create the registered renderers
    this.renderers = [];

    for (var i = 0; i < RendererManager.factory.length; i++) {
      this.renderers.push(RendererManager.factory[i](globe));
    } // The array of renderables used during rendering


    this.renderables = []; // To uniquely identify buckets created by the renderers

    this.bucketId = 0;
  };
  /**************************************************************************************************************/

  /**
   The factory for renderers
   */


  RendererManager.factory = [];
  /**************************************************************************************************************/

  /**
   * Set the selected layer on the top.
   * @function setSelectedRasterBucket
   * @memberof RendererManager.prototype
   * @param selectedLayer Layer to draw on the top
   */

  RendererManager.prototype.setSelectedRasterBucket = function (selectedLayer) {
    var rendererIdx = this.renderers.length;

    while (rendererIdx--) {
      var renderer = this.renderers[rendererIdx];

      if (renderer instanceof RasterOverlayRenderer || renderer instanceof GroundOverlayRenderer) {
        var buckets = renderer.buckets;
        var bucketIdx = buckets.length;

        while (bucketIdx--) {
          var bucket = buckets[bucketIdx];
          var layer = bucket.layer;

          if (bucket.style.zIndex == Constants.DISPLAY.SELECTED_RASTER && bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER) {
            bucket.style.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
          }

          if (layer.getID() === selectedLayer.getID() && bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER) {
            bucket.style.zIndex = Constants.DISPLAY.SELECTED_RASTER;
          }
        }
      }
    }
  };
  /**
   * Get a renderer
   * @function getRenderer
   * @memberof RendererManager.prototype
   * @param geometry
   * @param style
   * @return Renderer
   */


  RendererManager.prototype.getRenderer = function (geometry, style) {
    for (var i = 0; i < this.renderers.length; i++) {
      if (this.renderers[i].canApply(geometry.type, style)) {
        return this.renderers[i];
      }
    }

    return null;
  };
  /**************************************************************************************************************/

  /**
   *    Generate the tile data
   * @function generate
   * @memberof RendererManager.prototype
   * @param {Tile} tile Tile
   */


  RendererManager.prototype.generate = function (tile) {
    var i;

    if (!tile.parent) {
      for (i = 0; i < this.renderers.length; i++) {
        this.renderers[i].generateLevelZero(tile);
      }
    } else {
      var tileData = tile.parent.extension.renderer;

      if (tileData) {
        // delete renderer created at init time
        delete tile.extension.renderer; // Now generate renderables

        for (i = 0; i < tileData.renderables.length; i++) {
          var renderable = tileData.renderables[i];

          if (renderable.generateChild) {
            renderable.generateChild(tile);
          }
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to the renderer
   * @function addGeometry
   * @memberof RendererManager.prototype
   * @param layer
   * @param geometry
   * @param style
   */


  RendererManager.prototype.addGeometry = function (layer, geometry, style) {
    var renderer = this.getRenderer(geometry, style);

    if (renderer) {
      renderer.addGeometry(layer, geometry, style);
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "RendererManager.js", "No renderer for RendererManager");
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from the renderer
   * @function removeGeometry
   * @memberof RendererManager.prototype
   * @param geometry
   * @param layer
   * @return {Boolean}
   */


  RendererManager.prototype.removeGeometry = function (geometry, layer) {
    var bucket = geometry._bucket;

    if (bucket && bucket.layer === layer) {
      /*if (layer.type === "OpenSearch") {
           if (bucket.renderer.removeGeometryOneLevel(geometry) !== "undefined") {
           bucket.renderer.removeGeometryOneLevel(geometry);
           return true;
           }
           }*/
      bucket.renderer.removeGeometry(geometry);
      return true;
    }

    return false;
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to a tile
   * @function addGeometryToTile
   * @memberof RendererManager.prototype
   * @param layer
   * @param geometry
   * @param style
   * @param {Tile} tile Tile
   */


  RendererManager.prototype.addGeometryToTile = function (layer, geometry, style, tile) {
    var renderer = this.getRenderer(geometry, style);
    renderer.addGeometryToTile(layer, geometry, style, tile);
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from a tile
   * @function removeGeometryFromTile
   * @memberof RendererManager.prototype
   * @param geometry
   * @param {Tile} tile Tile
   */


  RendererManager.prototype.removeGeometryFromTile = function (geometry, tile) {
    var bucket = geometry._bucket;
    bucket.renderer.removeGeometryFromTile(geometry, tile, false);
  };
  /**************************************************************************************************************/

  /**
   * Function to sort with zIndex, then bucket
   */


  var renderableSort = function (r1, r2) {
    var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;

    if (zdiff === 0) {
      return r1.bucket.id - r2.bucket.id;
    } else {
      return zdiff;
    }
  };
  /**************************************************************************************************************/

  /**
   * Render all
   * @function render
   * @memberof RendererManager.prototype
   */


  RendererManager.prototype.render = function () {
    // Add main renderables
    var i, j;

    for (j = 0; j < this.renderers.length; j++) {
      var buckets = this.renderers[j].buckets;

      for (i = 0; i < buckets.length; i++) {
        if (buckets[i].layer.isVisible() && buckets[i].mainRenderable) {
          this.renderables.push(buckets[i].mainRenderable);
        }
      }
    } // Renderable sort


    this.renderables.sort(renderableSort); //var renderCall = 0;

    i = 0;

    while (i < this.renderables.length) {
      j = i + 1;
      var currentRenderer = this.renderables[i].bucket.renderer;

      while (j < this.renderables.length && this.renderables[j].bucket.renderer === currentRenderer) {
        j++;
      } //var minLevel =  (this.renderables[i].bucket.layer.minLevel) ? this.renderables[i].bucket.layer.minLevel : 0;
      //var processedLevel = this.renderables[i].bucket.renderer.tileManager.processedLevel;
      //if(minLevel <= processedLevel) {


      currentRenderer.render(this.renderables, i, j); //}
      //renderCall++;

      i = j;
    } //console.log( "# of render calls "  + renderCall );


    this.renderables.length = 0;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
  	 @name Ray
  	 @class
  	   Ray constructor
  	 @param origin
  	 @param dir
  	 @constructor
  	 */

  var Ray = function (orig, dir) {
    this.orig = orig;
    this.dir = dir;
  };
  /**************************************************************************************************************/

  /**
   * Create a ray from a pixel
   * @function createFromPixel
   * @memberof Ray
   * @param renderContext
   * @param x
   * @param y
   * @return {Ray} Ray
   */


  Ray.createFromPixel = function (renderContext, x, y) {
    // reverse y because (0,0) is top left but opengl's normalized
    // device coordinate (-1,-1) is bottom left
    var nx = x / renderContext.canvas.width * 2.0 - 1.0;
    var ny = -(y / renderContext.canvas.height * 2.0 - 1.0);
    var inverseViewProjectionMatrix = mat4.create();
    mat4.inverse(renderContext.viewProjectionMatrix, inverseViewProjectionMatrix); // Transform pos to world using inverse viewProjection matrix

    var pos3D = mat4.multiplyVec4(inverseViewProjectionMatrix, [nx, ny, -1, 1]);
    pos3D[0] /= pos3D[3];
    pos3D[1] /= pos3D[3];
    pos3D[2] /= pos3D[3]; // console.log('Old EP ' + renderContext.eyePosition );

    var inverseViewMatrix = mat4.create();
    mat4.inverse(renderContext.viewMatrix, inverseViewMatrix);
    vec3.set([0.0, 0.0, 0.0], renderContext.eyePosition);
    mat4.multiplyVec3(inverseViewMatrix, renderContext.eyePosition); // console.log('New EP ' + renderContext.eyePosition );

    var orig = vec3.create(renderContext.eyePosition);
    var dir = vec3.subtract(pos3D, renderContext.eyePosition, vec3.create());
    vec3.normalize(dir);
    return new Ray(orig, dir);
  };
  /**************************************************************************************************************/

  /**
   * Create a ray from an event
   * @function createFromEvent
   * @memberof Ray
   * @param renderContext
   * @param event
   * @return {Ray} Ray
   */


  Ray.createFromEvent = function (renderContext, event) {
    var pos = renderContext.getXYRelativeToCanvas(event);
    return Ray.createFromPixel(pos[0], pos[1]);
  };
  /**************************************************************************************************************/

  /**
   * Intersection object returned
   * @function Intersection
   * @memberof Ray
   * @param t
   */


  Ray.Intersection = function (t) {
    this.t = t;
    this.geometry = null;
  };
  /**************************************************************************************************************/

  /**
   * Compute a point on the ray given its t parameter
   * @function computePoint
   * @memberof Ray.prototype
   * @param t
   * @return Point
   */


  Ray.prototype.computePoint = function (t) {
    var pt = vec3.create();
    vec3.scale(this.dir, t, pt);
    vec3.add(pt, this.orig);
    return pt;
  };
  /**************************************************************************************************************/

  /**
   *	Compute intersection between a plan and ray
   * @function planeIntersect
   * @memberof Ray.prototype
   * @param {vec3} pt
   * @param {vec3} normal
   * @return {number}The nearest intersection, < 0 if no intersection
   */


  Ray.prototype.planeIntersect = function (pt, normal) {
    // Assuming vectors are all normalized
    var denom = vec3.dot(normal, this.dir);
    var epsilon = 1e-6;

    if (Math.abs(denom) > epsilon) {
      var p0l0 = vec3.create();
      vec3.subtract(pt, this.orig, p0l0);
      var t = vec3.dot(p0l0, normal) / denom;
      return t;
    }

    return -1;
  };
  /**************************************************************************************************************/

  /**
   * Compute intersection between a sphere and ray
   * @function sphereIntersect
   * @memberof Ray.prototype
   * @param center
   * @param radius
   * @return the nearest intersection, < 0 if no intersection
   */


  Ray.prototype.sphereIntersect = function (center, radius) {
    // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection
    var rs = vec3.subtract(this.orig, center, vec3.create()); // rayDirection is normalized so a = 1
    // var a = vec3.dot(rayDirection, rayDirection);

    var b = 2.0 * vec3.dot(this.dir, rs);
    var c = vec3.dot(rs, rs) - radius * radius; // as a == 1, discriminant = b^2 - (4*c)
    // var discr = (b*b) - (4*a*c);

    var discr = b * b - 4 * c;

    if (discr < 0) {
      return -1;
    } // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1


    discr = Math.sqrt(discr);
    var tNear = (-b - discr) / 2;
    var tFar = (-b + discr) / 2;

    if (tNear > tFar) {
      // Swap t values
      var tmp = tNear;
      tNear = tFar;
      tFar = tmp;
    }

    if (tFar < 0) {
      // Hit is beyond ray origin
      return -1;
    }

    return tNear < 0 ? tFar : tNear;
  };
  /**************************************************************************************************************/


  var EPS = 1e-15;
  /**
    * Ray triangle intersection optimized
    * @function triangleIntersectOptimized
    * @memberof Ray.prototype
    * @param verts
    * @param i0
    * @param i1
    * @param i2
    * @return the nearest intersection, null if no intersection

    */

  Ray.prototype.triangleIntersectOptimized = function (verts, i0, i1, i2) {
    var e1x = verts[i1] - verts[i0];
    var e1y = verts[i1 + 1] - verts[i0 + 1];
    var e1z = verts[i1 + 2] - verts[i0 + 2];
    var e2x = verts[i2] - verts[i0];
    var e2y = verts[i2 + 1] - verts[i0 + 1];
    var e2z = verts[i2 + 2] - verts[i0 + 2];
    var px = this.dir[1] * e2z - this.dir[2] * e2y;
    var py = this.dir[2] * e2x - this.dir[0] * e2z;
    var pz = this.dir[0] * e2y - this.dir[1] * e2x;
    var det = e1x * px + e1y * py + e1z * pz;

    if (det > -EPS && det < EPS) {
      return null;
    }

    var inv_det = 1.0 / det;
    var tx = this.orig[0] - verts[i0];
    var ty = this.orig[1] - verts[i0 + 1];
    var tz = this.orig[2] - verts[i0 + 2];
    var u = (tx * px + ty * py + tz * pz) * inv_det;

    if (u < 0.0 || u > 1.0) {
      return null;
    }

    var qx = ty * e1z - tz * e1y;
    var qy = tz * e1x - tx * e1z;
    var qz = tx * e1y - ty * e1x;
    var v = (this.dir[0] * qx + this.dir[1] * qy + this.dir[2] * qz) * inv_det;

    if (v < 0.0 || u + v > 1.0) {
      return null;
    }

    var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;

    if (t >= 0) {
      return new Ray.Intersection(t);
    } else {
      return null;
    }
  };
  /**************************************************************************************************************/

  /**
   * @function nodeIntersect
   * @memberof Ray.prototype
   * @param node
   * @param intersects
   * @return Intersects
   */


  Ray.prototype.nodeIntersect = function (node, intersects) {
    var i;
    intersects = intersects || [];

    for (i = 0; i < node.children.length; i++) {
      node.children[i].intersectWith(this, intersects);
    }

    for (i = 0; i < node.geometries.length; i++) {
      this.geometryIntersect(node.geometries[i], intersects);
    }

    intersects.sort(function (a, b) {
      return a.t - b.t;
    });
    return intersects;
  };
  /**
   * @function lodNodeIntersect
   * @memberof Ray.prototype
   * @param node
   * @param intersects
   * @return Intersects
   */


  Ray.prototype.lodNodeIntersect = function (node, intersects) {
    var i;
    intersects = intersects || [];

    if (this.sphereIntersect(node.center, node.radius) >= 0) {
      if (node.children.length > 0 && node.childToLoad === 0) {
        for (i = 0; i < node.children.length; i++) {
          this.lodNodeIntersect(node.children[i], intersects);
        }
      } else {
        for (i = 0; i < node.geometries.length; i++) {
          this.geometryIntersect(node.geometries[i], intersects);
        }
      }
    }

    return intersects;
  };
  /**
   * @function geometryIntersect
   * @memberof Ray.prototype
   * @param geometry
   * @param intersects
   * @return Intersects
   */


  Ray.prototype.geometryIntersect = function (geometry, intersects) {
    var indices = geometry.mesh.indices;

    for (var i = 0; i < indices.length; i += 3) {
      var intersect = this.triangleIntersectOptimized(geometry.mesh.vertices, geometry.mesh.numElements * indices[i], geometry.mesh.numElements * indices[i + 1], geometry.mesh.numElements * indices[i + 2]);

      if (intersect) {
        intersect.geometry = geometry;
        intersects.push(intersect);
      }
    }
  };

  var Geoide = function (options) {
    this.radius = options && options.hasOwnProperty("radius") ? options.radius : null;
    this.realPlanetRadius = options && options.hasOwnProperty("realPlanetRadius") ? options.realPlanetRadius : null;

    if (this.radius === null || this.realPlanetRadius === null) {
      throw new ReferenceError("Radius and realPlanetRadius must be set to define a geoide", "Geoide.js");
    }

    this.heightScale = this.radius / this.realPlanetRadius;
  };

  Geoide.prototype.getRealPlanetRadius = function () {
    return this.realPlanetRadius;
  };

  Geoide.prototype.getRadius = function () {
    return this.radius;
  };

  Geoide.prototype.getHeightScale = function () {
    return this.heightScale;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**************************************************************************************************************/

  /** The Constant twoPi. */

  var twoPi = 2.0 * Math.PI;
  /** The Constant fourPi. */

  var fourPi = 4.0 * Math.PI;
  /** The Constant psi. */

  var psi = [[0.57595865315, 4.9261918136, 0.0, 0.0, 0.11129056012, 4.7005372834], [0.574770433, 4.9368292465, 0.0, 0.0, 0.11142137093, 4.71279419371]];
  /** The Constant stheta. */

  var stheta = [[0.88781538514, -0.88781538514, 0.39788119938, -0.39788119938, 0.86766174755, -0.86766174755], [0.88998808748, -0.88998808748, 0.39777715593, -0.39777715593, 0.86766622025, -0.86766622025]];
  /** The Constant ctheta. */

  var ctheta = [[0.46019978478, 0.46019978478, 0.9174369467, 0.9174369467, 0.49715499774, 0.49715499774], [0.45598377618, 0.45598377618, 0.91748206207, 0.91748206207, 0.49714719172, 0.49714719172]];
  /** The Constant phi. */

  var phi = [[4.9261918136, 0.57595865315, 0.0, 0.0, 4.7005372834, 0.11129056012], [4.9368292465, 0.574770433, 0.0, 0.0, 4.71279419371, 0.11142137093]];
  var AstroCoordTransform = {
    /**Transforms an angular position in radians in a given coordinate system to a position
       in an other coordinate system, also in radians. RA-Dec position are intended in
       Equinox J2000
        @param {float[]} pos Angular position [phi, theta]
       @param trType Transform type
       */
    transform: function (pos, trType) {
      var ao, bo, a, b, sb, cb, cbsa;
      var J2000 = 1; //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

      a = pos[0] - phi[J2000][trType];
      b = pos[1];
      sb = Math.sin(b);
      cb = Math.cos(b);
      cbsa = cb * Math.sin(a);
      b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
      b = Math.max(-1.0, Math.min(b, 1.0));
      bo = Math.asin(b);
      a = Math.atan2(ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb, cb * Math.cos(a));
      ao = (a + psi[J2000][trType] + fourPi) % twoPi;
      return [ao, bo]; // phi, theta
    },

    /**Transforms an angular position in degrees in a given coordinate system to a position
       in an other coordinate systems, also in degrees. RA-Dec position are intended in
       Equinox J2000
        @param {float[]} pos Angular position [phi, theta]
       @param trType Transform type
       */
    transformInDeg: function (pos, trType) {
      var ao, bo, a, b, sb, cb, cbsa;
      var J2000 = 1; //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

      a = Numeric.toRadian(pos[0]) - phi[J2000][trType];
      b = Numeric.toRadian(pos[1]);
      sb = Math.sin(b);
      cb = Math.cos(b);
      cbsa = cb * Math.sin(a);
      b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
      b = Math.max(-1.0, Math.min(b, 1.0));
      bo = Numeric.toDegree(Math.asin(b));
      a = Math.atan2(ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb, cb * Math.cos(a));
      ao = Numeric.toDegree((a + psi[J2000][trType] + fourPi) % twoPi);
      return [ao, bo];
    }
  };
  /**
   *    Transform type enumerations
   */

  AstroCoordTransform.Type = {
    EQ2GAL: 0,
    //RA-Dec (2000) -> Galactic
    GAL2EQ: 1,
    //Galactic      -> RA-Dec
    EQ2ECL: 2,
    //RA-Dec        -> Ecliptic
    ECL2EQ: 3,
    //Ecliptic      -> RA-Dec
    ECL2GAL: 4,
    //Ecliptic      -> Galactic
    GAL2ECL: 5 //Galactic      -> Ecliptic

  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Abstract coordinate reference system configuration
   * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
   * @property {CRS} geoideName - name of the coordinate reference system
   * @property {CONTEXT} type - Type of the CRS
   * @property {GeoBound} geoBound - Geographical bounding box
   */

  /**
   * @name AbstractCrs
   * @class
   * Creates an coordinate reference system for a globe and data.
   *
   * A coordinate reference system is a coordinate system that is related to an object
   * by a {@link Geoide geodetic datum}.
   *
   * A coordinate system is a set of mathematical rules for specifying how coordinates are to be assigned to points
   * @param {AbstractCrs.configuration} options - Options for the coordinate reference system.
   * @throws {ReferenceError} Will throw when option.geoideName, options.geoBound and options.type are not defined
   * @implements {Crs}
   */

  var AbstractCrs = function (options) {
    this.flat = false;
    this.geoide = null;
    this.type = null;
    this.geoBound = null; // If geoideName is specified, use it

    if (options && options.geoideName && options.type && options.geoBound) {
      this.geoide = new Geoide(options);
      this.geoideName = options.geoideName;
      this.type = options.type;
      this.geoBound = options.geoBound;
    } else {
      throw new ReferenceError("The geoide's parameters, the geoBound and the type of context must be defined", AbstractCrs.js);
    }
  };
  /**
   * @function isFlat
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.isFlat = function () {
    return this.flat;
  };
  /**
   * @function getVerticalAt3D
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getVerticalAt3D = function (pos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    if (this.isFlat()) {
      dest[0] = 0.0;
      dest[1] = 0.0;
      dest[2] = 1.0;
    } else {
      vec3.normalize(pos, dest);
    }

    return dest;
  };
  /**
   * @function fromGeoTo3D
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.fromGeoTo3D = function (geo, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    if (!geo || geo.length < 2) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractCrs.js", "geo is 2D or does not exist");
      dest[0] = 0;
      dest[1] = 0;
      dest[2] = 0;
      return dest;
    }

    var longInRad = Numeric.toRadian(geo[0]);
    var latInRad = Numeric.toRadian(geo[1]);
    var cosLat = Math.cos(latInRad); // Take height into account

    var height = geo.length > 2 ? this.geoide.getHeightScale() * geo[2] : 0;
    var radius = this.geoide.getRadius() + height;
    dest[0] = radius * Math.cos(longInRad) * cosLat;
    dest[1] = radius * Math.sin(longInRad) * cosLat;
    dest[2] = radius * Math.sin(latInRad);
    return dest;
  };
  /**
   * @function from3DToGeo
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.from3DToGeo = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var r = Math.sqrt(position3d[0] * position3d[0] + position3d[1] * position3d[1] + position3d[2] * position3d[2]);
    var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
    var lat = Math.asin(position3d[2] / r);
    dest[0] = Numeric.toDegree(lon);
    dest[1] = Numeric.toDegree(lat);
    dest[2] = this.geoide.getRealPlanetRadius() * (r - this.geoide.getRadius());
    return dest;
  };
  /**
   * @function getLocalTransform
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getLocalTransform = function (geo, dest) {
    if (!dest) {
      dest = mat4.create();
    }

    var longitude = Numeric.toRadian(geo[0]);
    var latitude = Numeric.toRadian(geo[1]);
    var up = [Math.cos(longitude) * Math.cos(latitude), Math.sin(longitude) * Math.cos(latitude), Math.sin(latitude)];
    var east = [-Math.sin(longitude), Math.cos(longitude), 0];
    var north = vec3.create();
    vec3.cross(up, east, north);
    dest[0] = east[0];
    dest[1] = east[1];
    dest[2] = east[2];
    dest[3] = 0.0;
    dest[4] = north[0];
    dest[5] = north[1];
    dest[6] = north[2];
    dest[7] = 0.0;
    dest[8] = up[0];
    dest[9] = up[1];
    dest[10] = up[2];
    dest[11] = 0.0;
    dest[12] = 0.0;
    dest[13] = 0.0;
    dest[14] = 0.0;
    dest[15] = 1.0;
    return dest;
  };
  /**
   * @function getLHVTransform
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getLHVTransform = function (geo, dest) {
    if (!dest) {
      dest = mat4.create();
    }

    var longitude = Numeric.toRadian(geo[0]);
    var latitude = Numeric.toRadian(geo[1]);
    var up = [Math.cos(longitude) * Math.cos(latitude), Math.sin(longitude) * Math.cos(latitude), Math.sin(latitude)];
    var east = [-Math.sin(longitude), Math.cos(longitude), 0];
    var north = vec3.create();
    vec3.cross(up, east, north);
    var pt = this.get3DFromWorld(geo);
    dest[0] = east[0];
    dest[1] = east[1];
    dest[2] = east[2];
    dest[3] = 0.0;
    dest[4] = north[0];
    dest[5] = north[1];
    dest[6] = north[2];
    dest[7] = 0.0;
    dest[8] = up[0];
    dest[9] = up[1];
    dest[10] = up[2];
    dest[11] = 0.0;
    dest[12] = pt[0];
    dest[13] = pt[1];
    dest[14] = pt[2];
    dest[15] = 1.0;
    return dest;
  };
  /**
   * @function getSideVector
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getSideVector = function (matrix, v) {
    v[0] = matrix[0];
    v[1] = matrix[1];
    v[2] = matrix[2];
    return v;
  };
  /**
   * @function getFrontVector
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getFrontVector = function (matrix, v) {
    v[0] = matrix[4];
    v[1] = matrix[5];
    v[2] = matrix[6];
    return v;
  };
  /**
   * @function getUpVector
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getUpVector = function (matrix, v) {
    v[0] = matrix[8];
    v[1] = matrix[9];
    v[2] = matrix[10];
    return v;
  };
  /**
   * @function formatCoordinates
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype.formatCoordinates = function (geo) {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function getGeoide
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getGeoide = function () {
    return this.geoide;
  };
  /**
   * @function getGeoideName
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getGeoideName = function () {
    return this.geoideName;
  };
  /**
   * @function getType
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getType = function () {
    return this.type;
  };
  /**
   * @function getElevation
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getElevation = function (globe, geoPos) {
    return globe.getElevation(geoPos.coordinates[0], geoPos.coordinates[1]);
  };
  /**
   * @function getWorldFrom3D
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getWorldFrom3D = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var geoPos = this.from3DToGeo(position3d);

    this._setupPosAfterTrans(geoPos);

    dest[0] = geoPos[0];
    dest[1] = geoPos[1];
    dest[2] = geoPos.length > 2 ? geoPos[2] : 0;
    return dest;
  };
  /**
   * @function get3DFromWorld
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.get3DFromWorld = function (posWorld, dest) {
    if (!dest) {
      dest = vec3.create();
    }

    var pos = posWorld.slice(0);

    this._setupPosBeforeTrans(pos);

    this.fromGeoTo3D(pos, dest);
    return dest;
  };
  /**
   * @function get3DFromWorldInCrs
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.get3DFromWorldInCrs = function (posWorld, posCrsID, dest) {
    if (!dest) {
      dest = vec3.create();
    }

    var posWorldInCurrentCrs = this.convert(posWorld, posCrsID, this.getGeoideName());
    this.get3DFromWorld(posWorldInCurrentCrs, dest);
    return dest;
  };
  /**
   * @function getSexagesimalFromDeg
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getSexagesimalFromDeg = function (degPos, dest) {
    dest = dest || [];
    var deg = degPos[0]; // RA

    if (deg < 0) {
      deg += 360;
    }

    dest[0] = this.fromDegreesToHMS(deg);
    dest[1] = this.fromDegreesToDMS(degPos[1]);
    return dest;
  };
  /**
   * @function getDecimalDegFromSexagesimal
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getDecimalDegFromSexagesimal = function (sexagesimalPos, dest) {
    dest = dest || []; // we use string because : parseFloat("-0") returns 0..

    function sign(stringDegree) {
      return stringDegree[0] === "-" ? -1 : 1;
    }

    var longitude = sexagesimalPos[0].split(" "); // long

    var deg = parseFloat(longitude[0]);
    var min = parseFloat(longitude[1]);
    var sec = parseFloat(longitude[2]);
    dest[0] = (deg + min / 60 + sec / 3600) * 15.0;
    var latitude = sexagesimalPos[1].split(" "); // lat

    deg = parseFloat(latitude[0]);
    min = parseFloat(latitude[1]);
    sec = parseFloat(latitude[2]);
    dest[1] = sign(latitude[0]) * (Math.abs(deg) + min / 60 + sec / 3600);
    return dest;
  };
  /**
   * @function convert
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.convert = function (geo, from, to) {
    // No conversion needed
    if (from === to) {
      return geo;
    }

    var convertedGeo = null;
    var convertType = null;

    switch (from + "2" + to) {
      case Constants.CRS.Galactic + "2" + Constants.CRS.Equatorial:
        convertType = AstroCoordTransform.Type.GAL2EQ;
        convertedGeo = AstroCoordTransform.transformInDeg(geo, convertType);
        break;

      case Constants.CRS.Equatorial + "2" + Constants.CRS.Galactic:
        convertType = AstroCoordTransform.Type.EQ2GAL;
        convertedGeo = AstroCoordTransform.transformInDeg(geo, convertType);

        if (convertedGeo[0] < 0) {
          // TODO : Check if convertedGeo can be negative
          ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractCRs.js", "EQ2GAL transformation returned negative value");
          convertedGeo[0] += 360;
        }

        break;

      case Constants.CRS.Mars_2000 + "2" + Constants.CRS.Mars_2000_old:
      case Constants.CRS.Mars_2000_old + "2" + Constants.CRS.Mars_2000:
        convertedGeo = geo;
        break;

      case Constants.CRS.Moon_2000 + "2" + Constants.CRS.Moon_2000_old:
      case Constants.CRS.Moon_2000_old + "2" + Constants.CRS.Moon_2000:
        convertedGeo = geo;
        break;

      default:
        throw new RangeError("AbstractCrs.js: Conversion " + from + " to " + to + " is not implemented");
    }

    return convertedGeo;
  };
  /**
   * Adds a zero before the number < 10
   * @function _pad2Digits
   * @param number number to format
   * @returns {string}
   * @private
   */


  AbstractCrs.prototype._pad2Digits = function (number) {
    return number < 10 ? "0" + number : number;
  };
  /**
   * @function fromDegreesToHMS
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.fromDegreesToHMS = function (degree) {
    var localDegree = degree / 15;
    var absLon = Math.abs(localDegree);
    var hours = Math.floor(absLon);
    var decimal = (absLon - hours) * 60;
    var min = Math.floor(decimal);
    var sec = (decimal - min) * 60;
    return this._pad2Digits(hours) + "h " + this._pad2Digits(min) + "m " + this._pad2Digits(Numeric.roundNumber(sec, 2)) + "s";
  };
  /**
   * @function fromDegreesToDMS
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.fromDegreesToDMS = function (degree) {
    function stringSign(val) {
      return val >= 0 ? "+" : "-";
    }

    var absLat = Math.abs(degree);
    var deg = Math.floor(absLat);
    var decimal = (absLat - deg) * 60;
    var min = Math.floor(decimal);
    var sec = (decimal - min) * 60;
    return stringSign(degree) + this._pad2Digits(deg) + String.fromCharCode(176) + " " + this._pad2Digits(min) + "' " + this._pad2Digits(Numeric.roundNumber(sec, 2)) + '"';
  };
  /**
   * @function _setupPosBeforeTrans
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype._setupPosBeforeTrans = function (posWorld) {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function _setupPosAfterTrans
   * @memberof AbstractCrs#
   * @bastract
   */


  AbstractCrs.prototype._setupPosAfterTrans = function (posWorld) {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function getGeoBound
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.getGeoBound = function () {
    return this.geoBound;
  };
  /**
   * @function getName
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype.getName = function () {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function getDescription
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype.getDescription = function () {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function getLongitudeLabel
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype.getLongitudeLabel = function () {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function getLatitudeLabel
   * @memberof AbstractCrs#
   * @abstract
   */


  AbstractCrs.prototype.getLatitudeLabel = function () {
    throw new SyntaxError("Not implemented");
  };
  /**
   * @function isProjected
   * @memberof AbstractCrs#
   * @return {boolean} true when the Crs is projected in 2D otherwise false.
   */


  AbstractCrs.prototype.isProjected = function () {
    return false;
  };
  /**
   * @function destroy
   * @memberof AbstractCrs#
   */


  AbstractCrs.prototype.destroy = function () {
    this.flat = null;
    this.geoide = null;
    this.type = null;
    this.geoBound = null;
    this.projected = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const DESCRIPTION = "WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which " + "the geographic longitude increases to the east. The geographic latitude is measured in degrees north or south " + "of the Earth equator. In Mizar, the latitudes are projected on a sphere";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL = "Long";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL = "Lat";
  /**
   * @name WGS84Crs
   * @class
   * WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which the
   * geographic longitude increases to the east. The geographic latitude is measured in degrees north or south
   * of the Earth equator.
   * <br/>
   * <img src="../doc/images/earth.jpg" width="200px"/>
   * <br/>
   * WGS84Crs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = CRS:84</li>
   *     <li>radius = 1</li>
   *     <li>realPlanetRadius = 6378137 meters</li>
   *     <li>type = Planet</li>
   *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - No option to give.
   * @constructor
   * @memberof module:Crs
   */

  var WGS84Crs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.WGS84,
      radius: 1.0,
      realPlanetRadius: 6378137,
      type: Constants.CONTEXT.Planet,
      geoBound: new GeoBound(-180, -90, 180, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, WGS84Crs);
  /**************************************************************************************************************/

  /**
   * Formats the coordinates (longitude, latitude) as (x.xxx&deg, y.yyy&deg).
   * @function formatCoordinates
   * @memberof WGS84Crs#
   * @param {float[]} geo the spatial position in degree
   * @return {string[]} the formatted chain
   */

  WGS84Crs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    var longitude = Numeric.roundNumber(geo[0], 3);
    var latitude = Numeric.roundNumber(geo[1], 3);
    astro[0] = this.getLatitudeLabel() + " = ";
    astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
    astro[1] = this.getLongitudeLabel() + " = ";
    astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof WGS84Crs#
   */


  WGS84Crs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL;
  };
  /**
   * @function getLatitudeLabel
   * @memberof WGS84Crs#
   */


  WGS84Crs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL;
  };
  /**
   * @function _setupPosAfterTrans
   * @memberof WGS84Crs#
   * Do nothing
   * @param posWorld
   * @private
   */


  WGS84Crs.prototype._setupPosAfterTrans = function (posWorld) {//Do Nothing
  };
  /**
   * Do nothing
   * @function _setupPosBeforeTrans
   * @memberof WGS84Crs#
   * @param posWorld
   * @private
   */


  WGS84Crs.prototype._setupPosBeforeTrans = function (posWorld) {//Do Nothing
  };
  /**
   * @function getName
   * @memberof WGS84Crs#
   */


  WGS84Crs.prototype.getName = function () {
    return Constants.CRS.WGS84;
  };
  /**
   * @function getDescription
   * @memberof WGS84Crs#
   */


  WGS84Crs.prototype.getDescription = function () {
    return DESCRIPTION;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$1 = "Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in " + "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " + "north or south of the Mars equator.";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$1 = "Long";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$1 = "Lat";
  /**
   * @name Mars2000Crs
   * @class
   * Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in which the
   * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
   * of the Mars equator.
   * <br/>
   * Mars2000Crs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = IAU2000:49901</li>
   *     <li>radius = 1.0</li>
   *     <li>realPlanetRadius = 3396190</li>
   *     <li>type = Planet</li>
   *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - No option to give.
   * @constructor
   * @memberof module:Crs
   */

  var Mars2000Crs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.Mars_2000,
      radius: 1.0,
      realPlanetRadius: 3396190,
      type: Constants.CONTEXT.Planet,
      geoBound: new GeoBound(-180, -90, 180, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, Mars2000Crs);
  /**************************************************************************************************************/

  /**
   * Formats coordinates as (x.xxx N, y.yyy E).
   * @function formatCoordinates
   * @memberof Mars2000Crs
   * @param {float[]} geo the spatial position in degree
   * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
   */

  Mars2000Crs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    var longitude = Numeric.roundNumber(geo[0], 3);
    var latitude = Numeric.roundNumber(geo[1], 3);
    astro[0] = this.getLatitudeLabel() + " = ";
    astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
    astro[1] = this.getLongitudeLabel() + " = ";
    astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof Mars2000Crs#
   */


  Mars2000Crs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$1;
  };
  /**
   * @function getLatitudeLabel
   * @memberof Mars2000Crs#
   */


  Mars2000Crs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$1;
  };
  /**
   * Do nothing
   * @function _setupPosAfterTrans
   * @memberof Mars2000Crs
   * @private
   */


  Mars2000Crs.prototype._setupPosAfterTrans = function (posWorld) {//Do Nothing
  };
  /**
   * Do nothing
   * @function _setupPosBeforeTrans
   * @memberof Mars2000Crs
   * @private
   */


  Mars2000Crs.prototype._setupPosBeforeTrans = function (posWorld) {//Do Nothing
  };
  /**
   * @function getName
   * @memberof Mars2000Crs#
   */


  Mars2000Crs.prototype.getName = function () {
    return Constants.CRS.Mars_2000;
  };
  /**
   * @function getDescription
   * @memberof Mars2000Crs#
   */


  Mars2000Crs.prototype.getDescription = function () {
    return DESCRIPTION$1;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$2 = "Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in " + "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " + "north or south of the Moon equator.";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$2 = "Long";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$2 = "Lat";
  /**
   * @name Moon2000Crs
   * @class
   * Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in which the
   * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
   * of the Moon equator.
   * <br/>
   * Moon2000Crs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = IAU2000:30101</li>
   *     <li>radius = 1.0</li>
   *     <li>realPlanetRadius = 1737400</li>
   *     <li>type = Planet</li>
   *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - No option to give.
   * @constructor
   * @memberof module:Crs
   */

  var Moon2000Crs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.Moon_2000,
      radius: 1.0,
      realPlanetRadius: 1737400,
      type: Constants.CONTEXT.Planet,
      geoBound: new GeoBound(-180, -90, 180, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, Moon2000Crs);
  /**************************************************************************************************************/

  /**
   * Formats coordinates as (x.xxx N, y.yyy E).
   * @function formatCoordinates
   * @memberof Moon2000Crs
   * @param {float[]} geo the spatial position in degree
   * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
   */

  Moon2000Crs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    var longitude = Numeric.roundNumber(geo[0], 3);
    var latitude = Numeric.roundNumber(geo[1], 3);
    astro[0] = this.getLatitudeLabel() + " = ";
    astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
    astro[1] = this.getLongitudeLabel() + " = ";
    astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof Moon2000Crs#
   */


  Moon2000Crs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$2;
  };
  /**
   * @function getLatitudeLabel
   * @memberof Moon2000Crs#
   */


  Moon2000Crs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$2;
  };
  /**
   * Do nothing
   * @function _setupPosAfterTrans
   * @memberof Moon2000Crs
   * @private
   */


  Moon2000Crs.prototype._setupPosAfterTrans = function (posWorld) {//Do Nothing
  };
  /**
   * Do nothing
   * @function _setupPosBeforeTrans
   * @memberof Moon2000Crs
   * @private
   */


  Moon2000Crs.prototype._setupPosBeforeTrans = function (posWorld) {//Do Nothing
  };
  /**
   * @function getName
   * @memberof Moon2000Crs#
   */


  Moon2000Crs.prototype.getName = function () {
    return Constants.CRS.Moon_2000;
  };
  /**
   * @function getDescription
   * @memberof Moon2000Crs#
   */


  Moon2000Crs.prototype.getDescription = function () {
    return DESCRIPTION$2;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$3 = "System in which a celestial object's position on the celestial " + "sphere is described in terms of its declination and right ascension, measured with respect to the celestial " + "equator. Declination and right ascension correspond directly to geographic latitude and longitude as " + "projected outward onto the celestial sphere. Declination is measured in degrees north or south of the " + "celestial equator but right ascension  is measured in hours, minutes, and seconds eastward along the " + "celestial equator from the point of the vernal equinox. Because the celestial equator moves among the fixed " + "stars with the precession of the Earth's poles, an object's declination and right ascension change " + "gradually over time, and coordinates in the equatorial system must be specified for particular years. By " + "Default J2000 is used";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$3 = "&alpha;";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$3 = "&delta;";
  /**
   * @name EquatorialCrs
   * @class
   * System in which a celestial object's position on the celestial
   * sphere is described in terms of its declination and right ascension, measured with respect to the celestial equator.
   * Declination and right ascension correspond directly to geographic latitude and longitude as projected outward onto
   * the celestial sphere. Declination is measured in degrees north or south of the celestial equator but right ascension
   * is measured in hours, minutes, and seconds eastward along the celestial equator from the point of the vernal equinox.
   * Because the celestial equator moves among the fixed stars with the precession of the Earth's poles, an object's
   * declination and right ascension change gradually over time, and coordinates in the equatorial system must be
   * specified for particular years.
   * <br/>
   * <i>source : equatorial coordinate system. Dictionary.com. The American Heritage® Science Dictionary.
   * Houghton Mifflin Company. http://www.dictionary.com/browse/equatorial-coordinate-system (accessed: March 5, 2017).</i>
   * <br/>
   * <img src="../doc/images/equatorial.png"/>
   * <br/>
   * EquatorialCrs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = Equatorial</li>
   *     <li>radius = 10.0</li>
   *     <li>realPlanetRadius = 1.0</li>
   *     <li>type = Sky</li>
   *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param {Object} options - No option to give
   * @constructor
   * @see {@link https://en.wikipedia.org/wiki/Equatorial_coordinate_system Wikipedia}
   * @memberof module:Crs
   */

  var EquatorialCrs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.Equatorial,
      radius: 10.0,
      realPlanetRadius: 1.0,
      type: Constants.CONTEXT.Sky,
      geoBound: new GeoBound(0, -90, 360, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, EquatorialCrs);
  /**************************************************************************************************************/

  /**
   * @function transformVec
   * @memberof EquatorialCrs#
   */

  EquatorialCrs.prototype.transformVec = function (vec) {
    var transformMatrix = this.computeTransformMatrix();
    var res = [];
    mat4.multiplyVec3(transformMatrix, vec, res);
    return res;
  };
  /**
   * @function computeTransformMatrix
   * @memberof EquatorialCrs#
   */


  EquatorialCrs.prototype.computeTransformMatrix = function () {
    var transformMatrix = [];
    var galNorth = this.convert([0, 90], Constants.CRS.Galactic, Constants.CRS.Equatorial);
    var gal3DNorth = this.fromGeoTo3D(galNorth);
    var galCenter = this.convert([0, 0], Constants.CRS.Galactic, Constants.CRS.Equatorial);
    var gal3DCenter = this.fromGeoTo3D(galCenter);
    var galEast = this.convert([90, 0], Constants.CRS.Galactic, Constants.CRS.Equatorial);
    var gal3DEast = this.fromGeoTo3D(galEast);
    transformMatrix[0] = gal3DCenter[0];
    transformMatrix[1] = gal3DCenter[1];
    transformMatrix[2] = gal3DCenter[2];
    transformMatrix[3] = 0.0;
    transformMatrix[4] = gal3DEast[0];
    transformMatrix[5] = gal3DEast[1];
    transformMatrix[6] = gal3DEast[2];
    transformMatrix[7] = 0.0;
    transformMatrix[8] = gal3DNorth[0];
    transformMatrix[9] = gal3DNorth[1];
    transformMatrix[10] = gal3DNorth[2];
    transformMatrix[11] = 0.0;
    transformMatrix[12] = 0.0;
    transformMatrix[13] = 0.0;
    transformMatrix[14] = 0.0;
    transformMatrix[15] = 1.0;
    return transformMatrix;
  };
  /**
   * @function formatCoordinates
   * @memberof EquatorialCrs#
   */


  EquatorialCrs.prototype.formatCoordinates = function (geo) {
    var sexa = this.getSexagesimalFromDeg(geo);
    var dest = [];
    dest[0] = this.getLongitudeLabel() + " = " + sexa[0];
    dest[1] = this.getLatitudeLabel() + " = " + sexa[1];
    return dest;
  };
  /**
   * @function getLongitudeLabel
   * @memberof EquatorialCrs#
   */


  EquatorialCrs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$3;
  };
  /**
   * @function getLatitudeLabel
   * @memberof EquatorialCrs#
   */


  EquatorialCrs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$3;
  };
  /**
   * @function _setupPosAfterTrans
   * @memberof EquatorialCrs#
   * @private
   */


  EquatorialCrs.prototype._setupPosAfterTrans = function (posWorld) {
    if (posWorld[0] < 0) {
      posWorld[0] += 360.0;
    }
  };
  /**
   * @function _setupPosBeforeTrans
   * @memberof EquatorialCrs#
   * @private
   */


  EquatorialCrs.prototype._setupPosBeforeTrans = function (posWorld) {
    if (posWorld[0] > 180) {
      posWorld[0] -= 360.0;
    }
  };
  /**
   * @function getName
   * @memberof EquatorialCrs#
   */


  EquatorialCrs.prototype.getName = function () {
    return Constants.CRS.Equatorial;
  };
  /**
   * @function getDescription
   * @memberof EquatorialCrs#
   * @abstract
   */


  EquatorialCrs.prototype.getDescription = function () {
    return DESCRIPTION$3;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$4 = "System in which a celestial object's position on the celestial sphere is described in " + "relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured along the " + "galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way. The " + "galactic equator, also called the galactic circle, is inclined at an angle of approximately 62° to the " + "celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in " + "the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line " + "through the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic " + "latitude is measured in degrees north or south of the galactic equator toward the galactic poles.";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$4 = "l";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$4 = "b";
  /**
   * @name GalacticCrs
   * @class
   * System in which a celestial object's position on the celestial
   * sphere is described in relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured
   * along the galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way.
   * The galactic equator, also called the galactic circle, is inclined at an angle of approximately 62° to the
   * celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in
   * the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line through
   * the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic latitude is
   * measured in degrees north or south of the galactic equator toward the galactic poles.
   * <br/>
   * <i>source : galactic coordinate system. Dictionary.com. The American Heritage® Science Dictionary.
   * Houghton Mifflin Company. http://www.dictionary.com/browse/galactic-coordinate-system (accessed: March 5, 2017).</i>
   * <br/>
   * <img src="../doc/images/galactic.png"/>
   * <br/>
   * GalacticCrs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = Galactic</li>
   *     <li>radius = 10.0</li>
   *     <li>realPlanetRadius = 1.0</li>
   *     <li>type = Sky</li>
   *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - no option to give.
   * @constructor
   * @see {@link https://en.wikipedia.org/wiki/Galactic_coordinate_system Wikipedia}
   * @memberof module:Crs
   */

  var GalacticCrs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.Galactic,
      radius: 10.0,
      realPlanetRadius: 1.0,
      type: Constants.CONTEXT.Sky,
      geoBound: new GeoBound(0, -90, 360, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, GalacticCrs);
  /**************************************************************************************************************/

  /**
   * @function formatCoordinates
   * @memberof GalacticCrs#
   */

  GalacticCrs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    astro[0] = this.getLongitudeLabel() + " = " + Numeric.roundNumber(geo[0], 3);
    astro[0] += "&deg;";
    astro[1] = this.getLatitudeLabel() + " = " + Numeric.roundNumber(geo[1], 3);
    astro[1] += "&deg;";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof GalacticCrs#
   */


  GalacticCrs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$4;
  };
  /**
   * @function getLatitudeLabel
   * @memberof GalacticCrs#
   */


  GalacticCrs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$4;
  };
  /**
   * @function _setupPosAfterTrans
   * @memberof GalacticCrs#
   * @private
   */


  GalacticCrs.prototype._setupPosAfterTrans = function (posWorld) {
    if (posWorld[0] < 0) {
      posWorld[0] += 360.0;
    }

    posWorld = this.convert(posWorld, Constants.CRS.Equatorial, Constants.CRS.Galactic);
  };
  /**
   * @function _setupPosBeforeTrans
   * @memberof GalacticCrs#
   * @rpivate
   */


  GalacticCrs.prototype._setupPosBeforeTrans = function (posWorld) {
    posWorld = this.convert(posWorld, Constants.CRS.Galactic, Constants.CRS.Equatorial);

    if (posWorld[0] > 180) {
      posWorld[0] -= 360.0;
    }
  };
  /**
   * @function getName
   * @memberof GalacticCrs#
   */


  GalacticCrs.prototype.getName = function () {
    return Constants.CRS.Galactic;
  };
  /**
   * @function getName
   * @memberof GalacticCrs#
   */


  GalacticCrs.prototype.getDescription = function () {
    return DESCRIPTION$4;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * Base projection configuration
   * @typedef {Object} AbstractProjection.configuration
   * @property {PROJECTION} projectionName - Name of the projection
   */

  /**
   * @name AbstractProjection
   * @class
   *   Abstract class for projections.
   * A map projection is one of many methods used to represent the 3-dimensional surface of the earth or other round body
   * on a 2-dimensional plane in cartography. The creation of a map projection involves two steps :
   * <ul>
   *     <li>selection of a model for the shape of the body (choosing between a sphere or ellipsoid),</li>
   *     <li>transform planetographic coordinates to plane coordinates.</li>
   * </ul>
   * @param {float[]} projectionCenter - the projection center as (longitude, latitude)
   * @param {float[]} geoBound - Geo boundary as [minLongitude, minLatitude, maxLongitude, maxLatitude]
   * @param {AbstractProjection.configuration} options - Not used currently
   * @constructor
   * @implements {Projection}
   */

  var AbstractProjection = function (projectionCenter, geoBound, options) {
    this.geoBound = new GeoBound(geoBound[0], geoBound[1], geoBound[2], geoBound[3]);
    this.projectionCenter = projectionCenter;
    this.options = options || {};
  };
  /**
   * @function getProjectionCenter
   * @memberof AbstractProjection#
   */


  AbstractProjection.prototype.getProjectionCenter = function () {
    return this.projectionCenter;
  };
  /**
   * @function getGeoBound
   * @memberof AbstractProjection#
   */


  AbstractProjection.prototype.getGeoBound = function () {
    return this.geoBound;
  };
  /**
   * @function unProject
   * @memberof AbstractProjection#
   * @abstract
   */


  AbstractProjection.prototype.unProject = function (position3d, dest) {
    throw new SyntaxError("AbstractNavigation.js: unProject not implemented");
  };
  /**
   * @function project
   * @memberof AbstractProjection#
   * @abstract
   */


  AbstractProjection.prototype.project = function (geoPos, dest) {
    throw new SyntaxError("AbstractNavigation.js: project not implemented");
  };
  /**
   * @function getName
   * @memberof AbstractProjection#
   * @abstract
   */


  AbstractProjection.prototype.getName = function () {
    throw new SyntaxError("AbstractNavigation.js: getName not implemented");
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * @name AitoffProjection
   * @class
   *    The Aitoff coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   *  <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
   *  <li>a projection : the Aitoff projection.</li>
   * </ul>
   *
   * The Aitoff projection is a modified azimuthal map projection first proposed by David A. Aitoff in 1889.
   * Based on the equatorial form of the azimuthal equidistant projection, Aitoff halved longitudes from the central
   * meridian, projected by the azimuthal equidistant, and then stretched the result horizontally into a 2:1 ellipse.
   * <img src="../doc/images/aitoff.png" width="200px"/>
   *
   *
   * @see {@link https://en.wikipedia.org/wiki/Aitoff_projection}
   * @augments AbstractProjection
   * @param {AbstractProjection.configuration} [options] - Aitoff projection configuration.
   * @constructor
   * @memberof module:Projection
   */

  var AitoffProjection = function (options) {
    AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -90, 180, 90], options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, AitoffProjection);
  /**************************************************************************************************************/

  /**
   *    Inverse sampling function(sinc)
   */

  var _sinci = function (x) {
    return x ? x / Math.sin(x) : 1;
  };
  /**
   * @function unProject
   * @memberof AitoffProjection#
   */


  AitoffProjection.prototype.unProject = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var epsilon = 0.005;
    var deltaLambda;
    var deltaPhi; // Abort if [x, y] is not within an ellipse centered at [0, 0] with
    // semi-major axis pi and semi-minor axis pi/2.

    if (position3d[0] * position3d[0] + 4 * position3d[1] * position3d[1] > Math.PI * Math.PI + epsilon) {
      return;
    }

    var lambda = position3d[0],
        phi = position3d[1],
        i = 25;

    do {
      var sinLambda = Math.sin(lambda),
          sinLambda_2 = Math.sin(lambda / 2),
          cosLambda_2 = Math.cos(lambda / 2),
          sinPhi = Math.sin(phi),
          cosPhi = Math.cos(phi),
          sin_2phi = Math.sin(2 * phi),
          sin2phi = sinPhi * sinPhi,
          cos2phi = cosPhi * cosPhi,
          sin2lambda_2 = sinLambda_2 * sinLambda_2,
          F,
          C = 1 - cos2phi * cosLambda_2 * cosLambda_2,
          E = C ? Math.acos(cosPhi * cosLambda_2) * Math.sqrt(F = 1 / C) : F = 0,
          fx = 2 * E * cosPhi * sinLambda_2 - position3d[0],
          fy = E * sinPhi - position3d[1],
          deltaXLambda = F * (cos2phi * sin2lambda_2 + E * cosPhi * cosLambda_2 * sin2phi),
          deltaXPhi = F * (0.5 * sinLambda * sin_2phi - E * 2 * sinPhi * sinLambda_2),
          deltaYLambda = F * 0.25 * (sin_2phi * sinLambda_2 - E * sinPhi * cos2phi * sinLambda),
          deltaYPhi = F * (sin2phi * cosLambda_2 + E * sin2lambda_2 * cosPhi),
          denominator = deltaXPhi * deltaYLambda - deltaYPhi * deltaXLambda;

      if (!denominator) {
        break;
      }

      deltaLambda = (fy * deltaXPhi - fx * deltaYPhi) / denominator;
      deltaPhi = (fx * deltaYLambda - fy * deltaXLambda) / denominator;
      lambda -= deltaLambda;
      phi -= deltaPhi;
    } while ((Math.abs(deltaLambda) > epsilon || Math.abs(deltaPhi) > epsilon) && --i > 0);

    dest[0] = Numeric.toDegree(lambda);
    dest[1] = Numeric.toRadian(phi);
    dest[2] = position3d[2];
    return dest;
  };
  /**
   * @function project
   * @memberof AitoffProjection#
   */


  AitoffProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var lambda = Numeric.toRadian(geoPos[0]); // longitude

    var phi = Numeric.toRadian(geoPos[1]); // latitude

    var cosPhi = Math.cos(phi);

    var sinciAlpha = _sinci(Math.acos(cosPhi * Math.cos(lambda /= 2)));

    dest[0] = 2 * cosPhi * Math.sin(lambda) * sinciAlpha;
    dest[1] = Math.sin(phi) * sinciAlpha;
    dest[2] = geoPos[2]; // Triple winkel: mode
    // TODO: inverse
    // dest[0] = (dest[0] + lambda / Math.PI/2) / 2;
    // dest[1] = (dest[1] + phi) / 2;

    return dest;
  };
  /**
   * @function getName
   * @memberof AitoffProjection#
   */


  AitoffProjection.prototype.getName = function () {
    return Constants.PROJECTION.Aitoff;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * @name AugustProjection
   * @class
   *    The August coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
   * <li>a projection : the August projection.</li>
   * </ul>
   * <img src="../doc/images/august.png" width="200px">
   * @augments AbstractProjection
   * @param {AbstractProjection.configuration} [options] - August projection configuration.
   * @constructor
   * @memberof module:Projection
   */

  var AugustProjection = function (options) {
    AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -90, 180, 90], options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, AugustProjection);
  /**************************************************************************************************************/

  /**
   * @function unProject
   * @memberof AugustProjection#
   * @throws "must be implemented"
   */

  AugustProjection.prototype.unProject = function (position3d, dest) {
    throw new SyntaxError("must be implemented");
  };
  /**
   * @function project
   * @memberof AugustProjection#
   */


  AugustProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var lambda = Numeric.toRadian(geoPos[0]); // longitude

    var phi = Numeric.toRadian(geoPos[1]); // latitude

    var tanPhi = Math.tan(phi / 2),
        k = Math.sqrt(1 - tanPhi * tanPhi),
        c = 1 + k * Math.cos(lambda /= 2),
        x = Math.sin(lambda) * k / c,
        y = tanPhi / c,
        x2 = x * x,
        y2 = y * y;
    dest[0] = 4 / 3 * x * (3 + x2 - 3 * y2);
    dest[1] = 4 / 3 * y * (3 + 3 * x2 - y2);
    dest[2] = geoPos[2];
    return dest;
  };
  /**
   * @function getName
   * @memberof AugustProjection#
   */


  AugustProjection.prototype.getName = function () {
    return Constants.PROJECTION.August;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * Mercator projection configuration
   * @typedef {AbstractProjection.configuration} AbstractProjection.mercator_configuration
   * @property {float} [lambda0 = 0.0] - the longitude of an arbitrary central meridian usually(but not always) Greenwich, in degrees
   * (default value is 0)
   */

  /**
   * @name MercatorProjection
   * @class
   *    The Mercator coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   * <li>a reference frame : the reference geoide, which is set as parameter of the options object,</li>
   * <li>a projection : the Mercator projection.</li>
   * </ul>
   * The Mercator projection is a cylindrical map projection presented by the Flemish geographer and cartographer
   * Gerardus Mercator in 1569. It became the standard map projection for nautical purposes because of its ability to
   * represent lines of constant course<br/>
   * <img src="../doc/images/mercator.png" width="200px"/>
   * @augments AbstractProjection
   * @param {AbstractProjection.mercator_configuration} [options] - Mercator projection configuration.
   * @see {@link https://en.wikipedia.org/wiki/Mercator_projection}
   * @constructor
   * @memberof module:Projection
   */

  var MercatorProjection = function (options) {
    AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -80, 180, 84], options);
    this.lambda0 = options && options.lambda0 ? options.lambda0 : 0.0; // Greenwich (i.e., zero)
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, MercatorProjection);
  /**************************************************************************************************************/

  /**
   *  Hyperbolic sine
   */

  var _sinh = function (x) {
    var expY = Math.exp(x);
    return (expY - 1 / expY) / 2;
  };
  /**
   * @function unProject
   * @memberof MercatorProjection#
   */


  MercatorProjection.prototype.unProject = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    dest[0] = this.lambda0 + Numeric.toDegree(position3d[0]);
    dest[1] = Numeric.toDegree(Math.atan(_sinh(position3d[1])));
    dest[2] = position3d[2];
    if (Math.abs(dest[1]) > 85.05) return null;
    return dest;
  };
  /**
   * @function project
   * @memberof MercatorProjection#
   */


  MercatorProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    } // Clamp latitude values, since mercator converges to infinity at poles


    if (geoPos[1] > 85.05) {
      geoPos[1] = 85.05;
    }

    if (geoPos[1] < -85.05) {
      geoPos[1] = -85.05;
    }

    var longInRad = Numeric.toRadian(geoPos[0]); // longitude

    var latInRad = Numeric.toRadian(geoPos[1]); // latitude

    var x = longInRad - Numeric.toRadian(this.lambda0);
    var y = Math.log(Math.tan(latInRad) + 1 / Math.cos(latInRad));
    dest[0] = x;
    dest[1] = y;
    dest[2] = geoPos[2];
    return dest;
  };
  /**
   * @function getName
   * @memberof MercatorProjection#
   */


  MercatorProjection.prototype.getName = function () {
    return Constants.PROJECTION.Mercator;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * @name MollweideProjection
   * @class
   *    The Mollweide coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
   * <li>a projection : the Mollweide projection.</li>
   * </ul>
   * The Mollweide projection is an equal-area, pseudocylindrical map projection generally used for global maps of
   * the world or night sky.<br/>
   * <img src="../doc/images/mollweide.png" width="200px"/>
   * @augments AbstractProjection
   * @param {AbstractProjection.configuration} [options] - No options.
   * @constructor
   * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
   * @memberof module:Projection
   */

  var MollweideProjection = function (options) {
    AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -90, 180, 90], options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, MollweideProjection);
  /**************************************************************************************************************/

  /**
   *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
   *  @see https://en.wikipedia.org/wiki/Mollweide_projection
   */

  function _findTheta(lat) {
    // Avoid divide by zero
    if (Math.abs(lat) === Math.PI / 2) {
      return lat;
    }

    var epsilon = 0.001;
    var thetaN = lat; // n

    var thetaN1; // n+1

    do {
      var twoThetaN = 2 * thetaN;
      thetaN = thetaN1;

      if (!thetaN) {
        thetaN = lat;
      }

      thetaN1 = twoThetaN / 2 - (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) / (2 + 2 * Math.cos(twoThetaN));
    } while (Math.abs(thetaN1 - thetaN) >= epsilon);

    return thetaN1;
  }
  /**
   * @function unProject
   * @memberof MollweideProjection#
   */


  MollweideProjection.prototype.unProject = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var auxTheta = Math.asin(position3d[1] / Math.sqrt(2));
    var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
    var lambda = Math.PI * position3d[0] / (2 * Math.sqrt(2) * Math.cos(auxTheta));
    dest[0] = Numeric.toDegree(lambda);
    dest[1] = Numeric.toDegree(phi);
    dest[2] = position3d[2];
    return dest;
  };
  /**
   * @function project
   * @memberof MollweideProjection#
   */


  MollweideProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var lambda = Numeric.toRadian(geoPos[0]); // longitude

    var theta0 = Numeric.toRadian(geoPos[1]); // latitude

    var auxTheta = _findTheta(theta0); // Transfrom to Mollweide coordinate system


    var mollX = 2 * Math.sqrt(2) / Math.PI * lambda * Math.cos(auxTheta);
    var mollY = Math.sqrt(2) * Math.sin(auxTheta);
    dest[0] = mollX;
    dest[1] = mollY;
    dest[2] = geoPos[2];
    return dest;
  };
  /**
   * @function getName
   * @memberof MollweideProjection#
   */


  MollweideProjection.prototype.getName = function () {
    return Constants.PROJECTION.Mollweide;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   * @name PlateProjection
   * @class
   *    The Plate coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
   * <li>a projection : the Plate carrée projection.</li>
   * </ul>
   * <img src="../doc/images/platecarré.png" width="200px"/>
   * @augments AbstractProjection
   * @param {AbstractProjection.configuration} [options] - No options.
   * @constructor
   * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
   * @memberof module:Projection
   */

  var PlateProjection = function (options) {
    AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -90, 180, 90], options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, PlateProjection);
  /**************************************************************************************************************/

  /**
   * @function unProject
   * @memberof PlateProjection#
   */

  PlateProjection.prototype.unProject = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    dest[0] = Numeric.toDegree(position3d[0]);
    dest[1] = Numeric.toDegree(position3d[1]);
    dest[2] = position3d[2];
    return dest;
  };
  /**
   * @function project
   * @memberof PlateProjection#
   */


  PlateProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    dest[0] = Numeric.toRadian(geoPos[0]);
    dest[1] = Numeric.toRadian(geoPos[1]);
    dest[2] = geoPos[2];
    return dest;
  };
  /**
   * @function getName
   * @memberof PlateProjection#
   */


  PlateProjection.prototype.getName = function () {
    return Constants.PROJECTION.Plate;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Azimuthal projection configuration
   * @typedef {AbstractProjection.configuration} AbstractProjection.azimuth_configuration
   * @property {string} [pole = "north"] - Projection center. It can be "north" or "south"
   */

  /**
   * @name AzimuthProjection
   * @class
   *    The Azimuth coordinate system is a coordinate reference system. It is composed of :
   * <ul>
   * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
   * <li>a projection : the Azimuth projection.</li>
   * </ul>
   * <img src="../doc/images/azimuth.png" width="200px"/>
   *
   * @see {@link https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection}
   * @augments AbstractProjection
   * @param {AbstractProjection.azimuth_configuration} [options] - Azimuthal projection configuration.
   * @constructor
   * @memberof module:Projection
   */

  var AzimuthProjection = function (options) {
    this.pole = options && options.pole || "north";
    var geoBound;
    var projectionCenter;

    if (this.pole === "south") {
      geoBound = [-180, -90, 180, 0];
      projectionCenter = [0, -90];
    } else {
      geoBound = [-180, 0, 180, 90];
      projectionCenter = [0, 90];
      this.pole = "north";
    }

    AbstractProjection.prototype.constructor.call(this, projectionCenter, geoBound, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProjection, AzimuthProjection);
  /**************************************************************************************************************/

  /**
   * @function unProject
   * @memberof AzimuthProjection#
   */

  AzimuthProjection.prototype.unProject = function (position3d, dest) {
    var p = Math.sqrt(position3d[0] * position3d[0] + position3d[1] * position3d[1]);
    var o = Math.atan2(position3d[0], -position3d[1]);
    p = Numeric.toDegree(p);
    o = Numeric.toDegree(o);
    o *= this.pole === "south" ? -1 : 1;
    if (p > 90) return null;

    if (!dest) {
      dest = new Array(3);
    }

    dest[0] = o;
    dest[1] = this.pole === "south" ? p - 90 : 90 - p;
    dest[2] = position3d[2];
    return dest;
  };
  /**
   * @function project
   * @memberof AzimuthProjection#
   */


  AzimuthProjection.prototype.project = function (geoPos, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    var p = this.pole === "south" ? 90 + geoPos[1] : 90 - geoPos[1];
    p = Numeric.toRadian(p);
    var o = Numeric.toRadian(geoPos[0]);
    o *= this.pole === "south" ? -1 : 1;
    dest[0] = p * Math.sin(o);
    dest[1] = -p * Math.cos(o);
    dest[2] = geoPos[2];
    return dest;
  };
  /**
   * @function getName
   * @memberof AzimuthProjection#
   */


  AzimuthProjection.prototype.getName = function () {
    return Constants.PROJECTION.Azimuth;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Creates a projection based on the name of the projection and its options.
   * @param {PROJECTION} projectionName - Name of the projection
   * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options for the projection
   * @returns {Projection} projection
   * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
   * @private
   */

  function _createProjection(projectionName, options) {
    var cs;

    switch (projectionName) {
      case Constants.PROJECTION.Aitoff:
        cs = new AitoffProjection(options);
        break;

      case Constants.PROJECTION.August:
        cs = new AugustProjection(options);
        break;

      case Constants.PROJECTION.Azimuth:
        cs = new AzimuthProjection(options);
        break;

      case Constants.PROJECTION.Mercator:
        cs = new MercatorProjection(options);
        break;

      case Constants.PROJECTION.Mollweide:
        cs = new MollweideProjection(options);
        break;

      case Constants.PROJECTION.Plate:
        cs = new PlateProjection(options);
        break;

      default:
        throw new RangeError("ProjectionFactory.js: Unable to create the projection " + options.projectionName);
    }

    return cs;
  }

  var ProjectionFactory = {
    /**
     * Create a projection
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options.
     * @return {Projection}
     * @throws {ReferenceError} Will throw when options.projectionName is not defined
     * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
     * @alias module:Projection.ProjectionFactory.create
     */
    create: function (options) {
      var cs;

      if (options && options.projectionName) {
        cs = _createProjection(options.projectionName, options);
      } else {
        throw new ReferenceError("Unable to get options.projectionName", "ProjectionFactory.js");
      }

      return cs;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * ProjectedCrs configuration
   * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
   * @property {CRS} geoideName - name of the coordinate reference system
   * @property {CONTEXT} type - Type of the CRS
   * @property {GeoBound} geoBound - Geographical bounding box
   */

  /**
   * @name ProjectedCrs
   * @class
   * A coordinate reference system projected on a 2D map.
   * @augments AbstractCrs
   * @param {Crs} cs - coordinate reference system
   * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - projection configuration
   * @constructor
   * @memberof module:Crs
   * @throws {ReferenceError} Will throw when options.projectionName is not defined
   * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
   */

  var ProjectedCrs = function (cs, options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: cs.getGeoideName(),
      radius: cs.getGeoide().getRadius(),
      realPlanetRadius: cs.getGeoide().getRealPlanetRadius(),
      type: cs.getType(),
      geoBound: cs.getGeoBound()
    });
    this.cs = cs;
    this.projection = ProjectionFactory.create(options);
    this.geoBound.setWest(this.projection.getGeoBound().getWest());
    this.geoBound.setSouth(this.projection.getGeoBound().getSouth());
    this.geoBound.setEast(this.projection.getGeoBound().getEast());
    this.geoBound.setNorth(this.projection.getGeoBound().getNorth());
    this.flat = true;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, ProjectedCrs);
  /**************************************************************************************************************/

  /**
   * Formats the coordinates
   * @function formatCoordinates
   * @memberof ProjectedCrs
   * @param geo the spatial position in degrees
   * @return {string[]} the format coordinates of the geoide given in parameter
   */

  ProjectedCrs.prototype.formatCoordinates = function (geo) {
    return this.cs.formatCoordinates(geo);
  };
  /**
   * @function getLongitudeLabel
   * @memberof ProjectedCrs#
   */


  ProjectedCrs.prototype.getLongitudeLabel = function () {
    return this.cs.getLongitudeLabel();
  };
  /**
   * @function getLatitudeLabel
   * @memberof ProjectedCrs#
   */


  ProjectedCrs.prototype.getLatitudeLabel = function () {
    return this.cs.getLatitudeLabel();
  };
  /**
   * Returns the physical position in degrees.
   * @function getWorldFrom3D
   * @memberof ProjectedCrs
   * @param position3d the position in 3D
   * @param {float[]} dest the physical position
   * @return {float[]} the physical position
   */


  ProjectedCrs.prototype.getWorldFrom3D = function (position3d, dest) {
    if (!dest) {
      dest = new Array(3);
    }

    this.projection.unProject(position3d, dest);

    this.cs._setupPosAfterTrans(dest);

    dest[2] = dest[2] / this.geoide.getHeightScale();
    return dest;
  };
  /**
   * Returns the 3D position from physical position
   * @param posWorld physical position
   * @param {float[]}dest the 3D position
   * @return {float[]} the 3D position
   */


  ProjectedCrs.prototype.get3DFromWorld = function (posWorld, dest) {
    if (!dest) {
      dest = vec3.create();
    }

    var pos = posWorld.slice(0);

    this.cs._setupPosBeforeTrans(pos);

    this.projection.project(pos, dest);
    dest[2] = dest[2] ? dest[2] * this.geoide.getHeightScale() : 0.0;
    return dest;
  };
  /**
   * Returns the local transformation
   * @function getLocalTransform
   * @memberof ProjectedCrs#
   * @param {Array} geo
   * @param {Array} dest
   * @return {Array} dest Matrix as 16 values
   */


  ProjectedCrs.prototype.getLocalTransform = function (geo, dest) {
    if (!dest) {
      dest = mat4.create();
    }

    mat4.identity(dest);
    return dest;
  };
  /**************************************************************************************************************/

  /**
   * Returns the LHV transformation
   * @function getLHVTransform
   * @memberof ProjectedCrs
   * @param {Array} geo
   * @param {Array} dest
   * @return {Array} dest Matrix as 16 values
   */


  ProjectedCrs.prototype.getLHVTransform = function (geo, dest) {
    if (!dest) {
      dest = mat4.create();
    }

    var pt = this.projection.project(geo);
    mat4.identity(dest);
    dest[12] = pt[0];
    dest[13] = pt[1];
    dest[14] = pt[2] ? pt[2] * this.geoide.getHeightScale() : 0.0;
    dest[15] = 1.0;
    return dest;
  };
  /**
   * Returns the projection.
   * @function getProjection
   * @memberof ProjectedCrs
   * @returns {AbstractProjection} the used projection
   */


  ProjectedCrs.prototype.getProjection = function () {
    return this.projection;
  };
  /**
   * @function getName
   * @memberof ProjectedCrs#
   */


  ProjectedCrs.prototype.getName = function () {
    return this.cs.getName();
  };
  /**
   * @function getDescription
   * @memberof ProjectedCrs#
   */


  ProjectedCrs.prototype.getDescription = function () {
    return this.cs.getDescription();
  };
  /**
   * @function isProjected
   * @memberof ProjectedCrs#
   * @return {boolean} true.
   */


  ProjectedCrs.prototype.isProjected = function () {
    return true;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$5 = "System in which an local object's position is described in the observer's local horizon." + "It is expressed in terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90° " + "(nadir) to 90° (zenith) but azimuth is measured in degrees eastward along the horizon from the North";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$5 = "Az";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$5 = "Alt";
  /**
   * @name HorizontalLocalCrs
   * @class
   * System in which an local object's position is described in the observer's local horizon. It is expressed in
   * terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90° (nadir) to 90° (zenith)
   * but azimuth is measured in degrees eastward along the horizon from the North.
   * <br/>
   * HorizontalLocalCrs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = HorizontalLocal</li>
   *     <li>radius = 1.0</li>
   *     <li>realPlanetRadius = 1</li>
   *     <li>type = Planet</li>
   *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - No option to give.
   * @constructor
   * @memberof module:Crs
   */

  var HorizontalLocalCrs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.HorizontalLocal,
      radius: 1.0,
      realPlanetRadius: 1,
      type: Constants.CONTEXT.Ground,
      geoBound: new GeoBound(0, -90, 360, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, HorizontalLocalCrs);
  /**************************************************************************************************************/

  /**
   * Formats coordinates as (x.xxx N, y.yyy E).
   * @function formatCoordinates
   * @memberof HorizontalLocalCrs
   * @param {float[]} geo the spatial position in degree
   * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
   */

  HorizontalLocalCrs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    var azimuth = Numeric.roundNumber(geo[0], 3);
    var altitude = Numeric.roundNumber(geo[1], 3);
    astro[0] = this.getLongitudeLabel() + " = " + azimuth;
    astro[0] += "&deg;";
    astro[1] = this.getLatitudeLabel() + " = " + altitude;
    astro[1] += "&deg;";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof HorizontalLocalCrs#
   */


  HorizontalLocalCrs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$5;
  };
  /**
   * @function getLatitudeLabel
   * @memberof HorizontalLocalCrs#
   */


  HorizontalLocalCrs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$5;
  };
  /**
   * Do nothing
   * @function _setupPosAfterTrans
   * @memberof HorizontalLocalCrs
   * @private
   */


  HorizontalLocalCrs.prototype._setupPosAfterTrans = function (posWorld) {
    if (posWorld[0] < 0) {
      posWorld[0] = -1 * posWorld[0];
    } else {
      posWorld[0] = 360 - posWorld[0];
    }
  };
  /**
   * Do nothing
   * @function _setupPosBeforeTrans
   * @memberof HorizontalLocalCrs
   * @private
   */


  HorizontalLocalCrs.prototype._setupPosBeforeTrans = function (posWorld) {
    if (posWorld[0] < 180) {
      posWorld[0] = -1 * posWorld[0];
    } else {
      posWorld[0] = 360 - posWorld[0];
    }
  };
  /**
   * @function getName
   * @memberof HorizontalLocalCrs#
   */


  HorizontalLocalCrs.prototype.getName = function () {
    return Constants.CRS.HorizontalLocal;
  };
  /**
   * @function getDescription
   * @memberof HorizontalLocalCrs#
   */


  HorizontalLocalCrs.prototype.getDescription = function () {
    return DESCRIPTION$5;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @constant
   * @type {string}
   */

  const DESCRIPTION$6 = "Sun coordinate Reference System is a coordinate system using the Sun sphere and in " + "which the heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees " + "north or south of the Sun equator.";
  /**
   * @constant
   * @type {string}
   */

  const LONGITUDE_LABEL$6 = "Long";
  /**
   * @constant
   * @type {string}
   */

  const LATITUDE_LABEL$6 = "Lat";
  /**
   * @name SunCrs
   * @class
   * Sun  coordinate Reference System is a coordinate system using the Sun sphere and in which the
   * heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees north or south
   * of the Sun equator.
   * <br/>
   * SunCrs is initialized with the following parameters :
   * <ul>
   *     <li>geoideName = IAU:Sun</li>
   *     <li>radius = 1.0</li>
   *     <li>realPlanetRadius = 696342000</li>
   *     <li>type = Planet</li>
   *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
   * </ul>
   * @augments AbstractCrs
   * @param options - No option to give.
   * @constructor
   * @memberof module:Crs
   */

  var SunCrs = function (options) {
    AbstractCrs.prototype.constructor.call(this, {
      geoideName: Constants.CRS.Sun,
      radius: 1.0,
      realPlanetRadius: 696342000,
      type: Constants.CONTEXT.Planet,
      geoBound: new GeoBound(-180, -90, 180, 90)
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractCrs, SunCrs);
  /**************************************************************************************************************/

  /**
   * Formats coordinates as (x.xxx N, y.yyy E).
   * @function formatCoordinates
   * @memberof SunCrs
   * @param {float[]} geo the spatial position in degree
   * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
   */

  SunCrs.prototype.formatCoordinates = function (geo) {
    var astro = [];
    var longitude = Numeric.roundNumber(geo[0], 3);
    var latitude = Numeric.roundNumber(geo[1], 3);
    astro[0] = this.getLatitudeLabel() + " = ";
    astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
    astro[1] = this.getLongitudeLabel() + " = ";
    astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
    return astro;
  };
  /**
   * @function getLongitudeLabel
   * @memberof SunCrs#
   */


  SunCrs.prototype.getLongitudeLabel = function () {
    return LONGITUDE_LABEL$6;
  };
  /**
   * @function getLatitudeLabel
   * @memberof SunCrs#
   */


  SunCrs.prototype.getLatitudeLabel = function () {
    return LATITUDE_LABEL$6;
  };
  /**
   * Do nothing
   * @function _setupPosAfterTrans
   * @memberof SunCrs#
   * @private
   */


  SunCrs.prototype._setupPosAfterTrans = function (posWorld) {//Do Nothing
  };
  /**
   * Do nothing
   * @function _setupPosBeforeTrans
   * @memberof SunCrs#
   * @private
   */


  SunCrs.prototype._setupPosBeforeTrans = function (posWorld) {//Do Nothing
  };
  /**
   * @function getName
   * @memberof SunCrs#
   */


  SunCrs.prototype.getName = function () {
    return Constants.CRS.Sun;
  };
  /**
   * @function getDescription
   * @memberof SunCrs#
   */


  SunCrs.prototype.getDescription = function () {
    return DESCRIPTION$6;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Creates a coordinate reference system based on its geoide name and its options.
   * @param {CRS} geoideName
   * @param {AbstractCrs.crsFactory} options - options to create a coordinate reference system
   * @returns {Crs} the created coordinate reference system
   * @throws {RangeError} Will throw an error when geoideName  is not part of {@link CRS}
   * @private
   */

  function _createCrs(geoideName, options) {
    var cs;

    switch (geoideName) {
      case Constants.CRS.Equatorial:
        cs = new EquatorialCrs(options);
        break;

      case Constants.CRS.Galactic:
        cs = new GalacticCrs(options);
        break;
      // For Earth

      case Constants.CRS.WGS84:
        cs = new WGS84Crs(options);
        break;
      // For Mars

      case Constants.CRS.Mars_2000_old:
      case Constants.CRS.Mars_2000:
        cs = new Mars2000Crs(options);
        break;
      // For Moon

      case Constants.CRS.Moon_2000_old:
      case Constants.CRS.Moon_2000:
        cs = new Moon2000Crs(options);
        break;
      // For Ground

      case Constants.CRS.HorizontalLocal:
        cs = new HorizontalLocalCrs(options);
        break;
      // For Sun

      case Constants.CRS.Sun:
        cs = new SunCrs(options);
        break;
      // Unknown geoide name

      default:
        throw new RangeError("CoordinateSystemFactory.js: Datum " + geoideName + " not implemented");
    }

    return cs;
  }

  var CoordinateSystemFactory = {
    /**
     * Data model to create a coordinate reference system through the factory
     * @typedef {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} AbstractCrs.crsFactory
     * @property {CRS} options.geoideName - name of the geoide
     */

    /**
     * Factory for CRS.
     * @param {AbstractCrs.crsFactory} options - Options to create a coordinate reference system
     * @return {Crs} Object to handle CRS
     * @alias module:Crs.CoordinateSystemFactory.create
     * @throws {ReferenceError} Will throw an error when options.geoideName is not defined
     * @throws {RangeError} Will throw an error when options.geoideName  is not part of {@link CRS}
     * @throws {RangeError} Will throw an error when options.projectionName is not part of {@link PROJECTION}
     */
    create: function (options) {
      var cs;

      if (options.geoideName) {
        cs = _createCrs(options.geoideName, options);
      } else {
        throw new ReferenceError("geoideName not defined in " + JSON.stringify(options), "CoordinateSystemFactory.js");
      }

      if (options.projectionName) {
        cs = new ProjectedCrs(cs, options);
      }

      return cs;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
     @name Plane
     @class
     		Plane constructor
     @constructor
    */

  var Plane = function () {
    this.normal = vec3.create([0.0, 0.0, 0.0]);
    this.d = 0.0;
  };
  /**************************************************************************************************************/

  /**
   * Plane init from 3 points
   * @function init
   * @memberof Plane.prototype
   * @param v1 Point 1
   * @param v2 Point 2
   * @param v3 Point 3
   */


  Plane.prototype.init = function (v1, v2, v3) {
    var vu = [];
    var vv = [];
    vec3.subtract(v2, v1, vu);
    vec3.subtract(v3, v1, vv);
    vec3.cross(vu, vv, this.normal);
    vec3.normalize(this.normal);
    this.d = -vec3.dot(v1, this.normal);
  };
  /**************************************************************************************************************/

  /**
   * Transform the plane with the given matrix
   * @function transform
   * @memberof Plane.prototype
   * @param matrix Transformation matrix
   */


  Plane.prototype.transform = function (matrix) {
    var vec = [this.normal[0], this.normal[1], this.normal[2], this.d];
    mat4.multiplyVec4(matrix, vec);
    this.normal[0] = vec[0];
    this.normal[1] = vec[1];
    this.normal[2] = vec[2];
    this.d = vec[3];
  };
  /**************************************************************************************************************/

  /**
   * Intersection test between plane and bounding sphere.
   * @function intersectSphere
   * @memberof Plane.prototype
   * @param center Center
   * @param radius Radius
   * @return {Integer}
   * <ul>
   *   <li>1 if the bounding sphere is completely above plane,</li>
   *   <li>0 if the bounding sphere intersects the plane,</li>
   *   <li>-1 if the bounding sphere is completely below the plane.</li>
   * </ul>
   */


  Plane.prototype.intersectSphere = function (center, radius) {
    var dist = vec3.dot(center, this.normal) + this.d;

    if (dist > radius) {
      return 1;
    } else {
      if (dist < -radius) {
        return -1;
      } else {
        return 0;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Return the distance between a point and the plane
   * @function distance
   * @memberof Plane.prototype
   * @param point Point
   * @return {Float} Distance
   */


  Plane.prototype.distance = function (point) {
    return point[0] * this.normal[0] + point[1] * this.normal[1] + point[2] * this.normal[2] + this.d;
  };
  /**************************************************************************************************************/

  /**
   * Intersection test between plane and bounding box.
   * @function intersectBoundingBox
   * @memberof Plane.prototype
   * @param {BoundingBox} bbox Bounding box
   * @return {Integer}
   * <ul>
   *   <li>1 if the bbox is completely above plane,</li>
   *   <li>0 if the bbox intersects the plane,</li>
   *   <li>-1 if the bbox is completely below the plane.</li>
   * </ul>
   */


  Plane.prototype.intersectBoundingBox = function (bbox) {
    var upperBBCorner = (this.normal[0] >= 0.0 ? 1 : 0) | (this.normal[1] >= 0.0 ? 2 : 0) | (this.normal[2] >= 0.0 ? 4 : 0);
    var lowerBBCorner = ~upperBBCorner & 7; // if lowest point above plane than all above.

    if (this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) {
      return 1;
    } // if highest point is below plane then all below.


    if (this.distance(bbox.getCorner(upperBBCorner)) < 0.0) {
      return -1;
    } // d_lower<=0.0f && d_upper>=0.0f
    // therefore must be crossing plane.


    return 0;
  };
  /**************************************************************************************************************/

  /**
     @name Frustum
     @class
     		Frustum constructor
     @constructor
    */


  var Frustum = function () {
    // The frustum does not contains near and far plane, because near and far are computed during rendering.
    // Some tests have been done with a near plane but are not really useful
    this.planes = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
  };
  /**************************************************************************************************************/

  /**
   * Compute the frustum from the given projection matrix
   * @function compute
   * @memberof Frustum.prototype
   * @param projectionMatrix Projection matrix
   */


  Frustum.prototype.compute = function (projectionMatrix) {
    var inverseProjectionMatrix = mat4.create();
    mat4.inverse(projectionMatrix, inverseProjectionMatrix);
    var bottomleft = mat4.project(inverseProjectionMatrix, [-1.0, -1.0, -1.0, 1.0]);
    var topleft = mat4.project(inverseProjectionMatrix, [-1.0, 1.0, -1.0, 1.0]);
    var topright = mat4.project(inverseProjectionMatrix, [1.0, 1.0, -1.0, 1.0]);
    var bottomright = mat4.project(inverseProjectionMatrix, [1.0, -1.0, -1.0, 1.0]);
    this.planes[0].init([0.0, 0.0, 0.0], bottomleft, topleft);
    this.planes[1].init([0.0, 0.0, 0.0], topleft, topright);
    this.planes[2].init([0.0, 0.0, 0.0], topright, bottomright);
    this.planes[3].init([0.0, 0.0, 0.0], bottomright, bottomleft); // A plane for near plane if needed

    this.planes[4].init(bottomleft, topleft, topright);
  };
  /**************************************************************************************************************/

  /**
   * Transform the frustum with the given matrix
   * @function transform
   * @memberof Frustum.prototype
   * @param frustum
   * @param matrix Matrix
   */


  Frustum.prototype.transform = function (frustum, matrix) {
    var mat = mat4.create();
    mat4.inverse(matrix, mat);
    this.inverseTransform(frustum, mat);
  };
  /**************************************************************************************************************/

  /**
   * Inverse transform the frustum with the given matrix
   * @function inverseTransform
   * @memberof Frustum.prototype
   * @param frustum
   * @param matrix Matrix
   */


  Frustum.prototype.inverseTransform = function (frustum, matrix) {
    // Optimized implementation
    for (var i = 0; i < frustum.planes.length; i++) {
      var plane = frustum.planes[i];
      var x = plane.normal[0];
      var y = plane.normal[1];
      var z = plane.normal[2];
      var w = plane.d;
      plane = this.planes[i];
      plane.normal[0] = matrix[0] * x + matrix[1] * y + matrix[2] * z + matrix[3] * w;
      plane.normal[1] = matrix[4] * x + matrix[5] * y + matrix[6] * z + matrix[7] * w;
      plane.normal[2] = matrix[8] * x + matrix[9] * y + matrix[10] * z + matrix[11] * w;
      plane.d = matrix[12] * x + matrix[13] * y + matrix[14] * z + matrix[15] * w;
    }
  };
  /**************************************************************************************************************/

  /**
   * Intersection test between frustum and bounding sphere.
   * @function containsSphere
   * @memberof Frustum.prototype
   * @param {Array} center Center
   * @param {Float} radius Radius
   * @return {Integer}
   * <ul>
   *   <li>1 if the bounding sphere is completely inside the frustum,</li>
   *   <li>0 if the bounding sphere intersects the frustum,</li>
   *   <li>-1 if the bounding sphere is completely outside the frustum.</li>
   * </ul>
   */


  Frustum.prototype.containsSphere = function (center, radius) {
    var flag = 1;

    for (var i = 0; i < this.planes.length; i++) {
      var pn = this.planes[i].normal; // Compute distance between center and plane (inline to be more efficient)

      var dist = center[0] * pn[0] + center[1] * pn[1] + center[2] * pn[2] + this.planes[i].d;

      if (dist <= radius) {
        if (dist < -radius) {
          return -1;
        } else {
          flag = 0;
        }
      }
    }

    return flag;
  };
  /**************************************************************************************************************/

  /**
   * Test if the frustum contains the given bounding box
   * @function containsBoundingBox
   * @memberof Frustum.prototype
   * @param {BoundingBox} bbox Bounding box
   * @return {boolean} Contains ?
   */


  Frustum.prototype.containsBoundingBox = function (bbox) {
    // Optimized implementation
    for (var i = 0; i < this.planes.length; i++) {
      var plane = this.planes[i]; // Get the closest point on the bbox

      var bbx = plane.normal[0] >= 0.0 ? bbox.max[0] : bbox.min[0];
      var bby = plane.normal[1] >= 0.0 ? bbox.max[1] : bbox.min[1];
      var bbz = plane.normal[2] >= 0.0 ? bbox.max[2] : bbox.min[2]; // Compute the distance

      var distance = bbx * plane.normal[0] + bby * plane.normal[1] + bbz * plane.normal[2] + plane.d; // if highest point is below plane then all below.

      if (distance < 0.0) {
        return false;
      }
    }

    return true;
  };
  /**************************************************************************************************************/
  // Export plane


  Frustum.Plane = Plane;

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       @name RenderContext
       @class
           RenderContext constructor
       @param options Configuration properties for the Planet :
       <ul>
       <li>shadersPath : Shaders directory path ( "../shaders/" as default)</li>
       <li>tileErrorTreshold : Tile error treshold (4 as default)</li>
       <li>lighting : Lighting ? (false as default))</li>
       <li>continuousRendering : Have to continuously render ? (false as default)</li>
       </ul>
       @constructor
       */

  var RenderContext = function (options) {
    this.activeAnimations = [];
    this.shadersPath = options.shadersPath || "../shaders/";
    this.tileErrorTreshold = options.tileErrorTreshold || 4;
    this.lighting = options.lighting || false;
    this.continuousRendering = options.continuousRendering || false;
    this.stats = null;
    this.isActive = true; // Init GL

    var canvas = null; // Check canvas options

    if (!options.canvas) {
      throw new ReferenceError("Mizar : no canvas in options");
    }

    if (typeof options.canvas === "string") {
      //canvas = document.getElementById(options.canvas);
      canvas = $__default['default'](options.canvas);
    } else {
      canvas = options.canvas;
    } // Check canvas is valid


    if (!(canvas instanceof HTMLCanvasElement)) {
      throw new TypeError("Mizar : invalid canvas");
    } // Create the webl context


    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    var gl = null;

    for (var ii = 0; ii < names.length && gl === null; ++ii) {
      try {
        gl = canvas.getContext(names[ii], RenderContext.contextAttributes);
      } catch (e) {
        /* continue regardless of error */
      }
    }

    if (gl === null) {
      throw new ReferenceError("Mizar : WebGL context cannot be initialized");
    }

    if (options.backgroundColor) {
      var color = options.backgroundColor;
      gl.clearColor(color[0], color[1], color[2], color[3]);
    } else {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
    }

    gl.getExtension("OES_element_index_uint");
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE); // Store local variable into static object

    this.viewMatrix = mat4.create();
    this.modelViewMatrix = mat4.create();
    this.projectionMatrix = mat4.create();
    this.viewProjectionMatrix = mat4.create();
    this.gl = gl;
    this.canvas = canvas;
    this.frustum = new Frustum();
    this.worldFrustum = new Frustum();
    this.localFrustum = new Frustum();
    this.eyePosition = vec3.create();
    this.eyeDirection = vec3.create();
    this.minNear = options.minNear || 1e-10;
    this.minFar = options.minFar || 0; // No limit on far

    this.near = 1.0;
    this.far = 6.0;
    this.numActiveAttribArray = 0;
    this.frameRequested = false;
    this.fov = 45;
    this.renderers = [];
    this.cameraUpdateFunction = null;
    this.lastFrameTime = null;
    this.currentFrameTime = null;
    this.totalElapsedTime = 0.0;
    this.deltaTime = 0.0; // Initialize the window requestAnimationFrame

    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function () {
        return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
          window.setTimeout(callback, 1000 / 60);
        };
      }();
    }

    var self = this;

    this.frameCallback = function () {
      self.frame();
    };
  };
  /**************************************************************************************************************/

  /**
       The context attributes used when creating WebGL context, see WebGL specification.
       Can be changed by the renderers if needed, or by an external interface.
       */


  RenderContext.contextAttributes = {};
  /**************************************************************************************************************/

  /**
   * Request a frame
   * @function requestFrame
   * @memberof RenderContext.prototype
   */

  RenderContext.prototype.requestFrame = function () {
    if (!this.frameRequested) {
      window.requestAnimationFrame(this.frameCallback);
      this.frameRequested = true;
    }
  };
  /**************************************************************************************************************/

  /**
   * Deactivate render context
   * @function deactivate
   * @memberof RenderContext.prototype
   */


  RenderContext.prototype.deactivate = function () {
    this.isActive = false;
    this.frameRequested = false;
  };
  /**************************************************************************************************************/

  /**
   * Activate render context
   * @function activate
   * @memberof RenderContext.prototype
   */


  RenderContext.prototype.activate = function () {
    this.isActive = true;
  };
  /**************************************************************************************************************/

  /**
   * Frame of the application
   * @function frame
   * @memberof RenderContext.prototype
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   */


  RenderContext.prototype.frame = function () {
    if (this.isActive) {
      // Reset frame requested flag first
      this.frameRequested = false;
      var gl = this.gl;
      var i;

      if (this.stats) {
        this.stats.start("globalRenderTime");
      } // Update frame time infos


      this.lastFrameTime = this.currentFrameTime;
      this.currentFrameTime = Date.now();

      if (!this.lastFrameTime) {
        this.lastFrameTime = this.currentFrameTime;
      }

      const dt = this.currentFrameTime - this.lastFrameTime;
      this.totalElapsedTime += dt;
      this.deltaTime = dt; // Update active animations

      if (this.activeAnimations.length > 0) {
        for (i = 0; i < this.activeAnimations.length; i++) {
          this.activeAnimations[i].update(this.currentFrameTime);
        }
      } // Clear the buffer


      if (RenderContext.contextAttributes.stencil) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      } else {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      } // Check canvas size is valid


      if (this.canvas.width === 0 || this.canvas.height === 0) {
        return;
      }

      gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      gl.enable(WebGLRenderingContext.SCISSOR_TEST);
      gl.scissor(0, 0, this.canvas.width, this.canvas.height); // Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...

      if (this.cameraUpdateFunction) {
        this.cameraUpdateFunction();
      }

      this.updateViewDependentProperties(); // Call render method of all registered renderers

      for (i = 0; i < this.renderers.length; i++) {
        this.renderers[i].render();
      }

      if (this.stats) {
        this.stats.end("globalRenderTime");
      } // Request next frame


      if (this.continuousRendering) {
        this.requestFrame();
      } else if (this.activeAnimations.length > 0) {
        this.requestFrame();
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Update properies that depends on the view matrix
   * @function updateViewDependentProperties
   * @memberof RenderContext.prototype
   */


  RenderContext.prototype.updateViewDependentProperties = function () {
    var inverseViewMatrix = mat4.create();
    mat4.inverse(this.viewMatrix, inverseViewMatrix);
    vec3.set([0.0, 0.0, 0.0], this.eyePosition);
    mat4.multiplyVec3(inverseViewMatrix, this.eyePosition);
    vec3.set([0.0, 0.0, -1.0], this.eyeDirection);
    mat4.rotateVec3(inverseViewMatrix, this.eyeDirection); // Init projection matrix

    mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.near, this.far, this.projectionMatrix); // No need to do this computation every time

    mat4.multiply(this.projectionMatrix, this.viewMatrix, this.viewProjectionMatrix); // Compute the frustum from the projection matrix

    this.frustum.compute(this.projectionMatrix); // Compute the world frustum

    this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix); // Compute the pixel size vector from the current view/projection matrix

    this.pixelSizeVector = this.computePixelSizeVector();
  };
  /**************************************************************************************************************/

  /**
   * Get mouse coordinates relative to the canvas element
   * @function getXYRelativeToCanvas
   * @memberof RenderContext.prototype
   * @param event
   * @return Coordinates
   */


  RenderContext.prototype.getXYRelativeToCanvas = function (event) {
    // cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
    var pos = [];

    if (event.pageX || event.pageY) {
      pos[0] = event.pageX;
      pos[1] = event.pageY;
    } else {
      pos[0] = event.offsetX + document.body.scrollLeft + document.documentElement.scrollLeft;
      pos[1] = event.offsetY + document.body.scrollTop + document.documentElement.scrollTop;
    }

    var element = this.canvas;

    while (element) {
      pos[0] -= element.offsetLeft;
      pos[1] -= element.offsetTop;
      element = element.offsetParent;
    }

    return pos;
  };
  /**************************************************************************************************************/

  /**
   * Compute the pixel size vector
   * @function computePixelSizeVector
   * @memberof RenderContext.prototype
   * @param mv
   * @return pixelSizeVector
   */


  RenderContext.prototype.computePixelSizeVector = function (mv) {
    // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
    // here we do it in short hand with the knowledge of how the window matrix is formed
    // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
    // Robert Osfield, June 2002.
    var width = this.canvas.width;
    var height = this.canvas.height;
    var P = this.projectionMatrix;
    var V = mv || this.viewMatrix; // scaling for horizontal pixels

    var P00 = P[0] * width * 0.5;
    var P20_00 = P[8] * width * 0.5 + P[11] * width * 0.5;
    var scale_00 = [V[0] * P00 + V[2] * P20_00, V[4] * P00 + V[6] * P20_00, V[8] * P00 + V[10] * P20_00]; // scaling for vertical pixels

    var P10 = P[5] * height * 0.5;
    var P20_10 = P[9] * height * 0.5 + P[11] * height * 0.5;
    var scale_10 = [V[1] * P10 + V[2] * P20_10, V[5] * P10 + V[6] * P20_10, V[9] * P10 + V[10] * P20_10];
    var P23 = P[11];
    var P33 = P[15];
    var pixelSizeVector = [V[2] * P23, V[6] * P23, V[10] * P23, V[14] * P23 + V[15] * P33];
    var scaleRatio = 0.7071067811 / Math.sqrt(vec3.dot(scale_00, scale_00) + vec3.dot(scale_10, scale_10));
    pixelSizeVector[0] *= scaleRatio;
    pixelSizeVector[1] *= scaleRatio;
    pixelSizeVector[2] *= scaleRatio;
    pixelSizeVector[3] *= scaleRatio;
    return pixelSizeVector;
  };
  /**************************************************************************************************************/

  /**
   * Get pixel from 3D
   * TODO: move it to Planet/Sky too ?
   * @function getPixelFrom3D
   * @memberof RenderContext.prototype
   * @param x
   * @param y
   * @param z
   * @return {Array} Point as array of 2 float
   */


  RenderContext.prototype.getPixelFrom3D = function (x, y, z) {
    var viewProjectionMatrix = mat4.create();
    mat4.multiply(this.projectionMatrix, this.viewMatrix, viewProjectionMatrix); // transform world to clipping coordinates

    var point3D = [x, y, z, 1];
    mat4.project(viewProjectionMatrix, point3D); // transform clipping to window coordinates

    var winX = Math.round((1 + point3D[0]) * 0.5 * this.canvas.width); // reverse y because (0,0) is top left but opengl's normalized
    // device coordinate (-1,-1) is bottom left

    var winY = Math.round((1 - point3D[1]) * 0.5 * this.canvas.height);
    return [winX, winY];
  };
  /**************************************************************************************************************/

  /**
   * Create a non power of two texture from an image
   * @function createNonPowerOfTwoTextureFromImage
   * @memberof RenderContext.prototype
   * @param image
   * @param invertY
   * @return Texture
   */


  RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function (image, invertY) {
    var gl = this.gl;
    var tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // Restore to default

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    return tex;
  };
  /**
   * Returns the canvas
   * @returns {Object} canvas
   */


  RenderContext.prototype.getCanvas = function () {
    return this.canvas;
  };
  /**
   * Returns the field of view in decimal degree.
   * @returns {Object} field of view
   */


  RenderContext.prototype.getFov = function () {
    return this.fov;
  };
  /**
   * Sets the field of fiew in decimal degree.
   * @param fov field of view
   */


  RenderContext.prototype.setFov = function (fov) {
    this.fov = fov;
  };
  /**
   * Returns the world frustum.
   * @returns {Frustum} frustum
   */


  RenderContext.prototype.getWorldFrustum = function () {
    return this.worldFrustum;
  };
  /**
   * Returns the view matrix.
   * @returns {mat4}
   */


  RenderContext.prototype.getViewMatrix = function () {
    return this.viewMatrix;
  };
  /**
   * Sets the view matrix.
   * @param {mat4} mat4 the matrix
   */


  RenderContext.prototype.setViewMatrix = function (mat4) {
    this.viewMatrix = mat4;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * AbstractGlobe configuration
   * @typedef {Object} AbstractGlobe.configuration
   * @property {boolean} [continuousRendering=false] - Options that renders the globe in continue
   * @property {Crs} coordinateSystem - coordinate system of the globe
   * @property {Object} [renderContext] - RenderContext object.
   * @property {string} [shadersPath=../shaders/] - Option for RenderContext : shader location.
   * @property {int} [tileErrorTreshold=4] - Option for RenderContext : tile error
   * @property {boolean} [lighting=false] - Option for RenderContext : enable/disable lighting
   * @property {Object|string} canvas - Option for RenderContext : Canvas element to insert in the globe
   * @property {Array} [backgroundColor=[0.0, 0.0, 0.0, 1.0]] - Option for RenderContext : color for background
   * @property {int} [minFar=0] - Option for RenderContext : When 0 , no limit on far
   * @property {Array} [defaultColor=[200, 200, 200, 255]] - Option for TileManager : pixel default color
   * @property {Number} [subdivisionLength=10000] - The targetted length of a segment subdivision
   * @property {Number} [maxSubdivisionCount=128] - The max number of subdivisions for a segment
   *
   */

  /**
   * @name AbstractGlobe
   * @class
   * Creates a sky or a planet with it own coordinate reference system and renders the globe.
   * According to its coordinate reference system, the globe can be projected on a map.<br/>
   * Client implementations should not normally instantiate this class directly.
   * @param {GLOBE} type - Type of the globe.
   * @param {AbstractGlobe.configuration} options - Options for globe creation.
   * @throws {ReferenceError} Will throw an error when the options.coordinateSystem is not defined.
   * @throws {Error} Will throw an error when options.coordinateSystem.geoideName  is not part of {@link CRS}
   * @see {@link module:Crs.CoordinateSystemFactory}
   * @implements {Globe}
   */

  var AbstractGlobe = function (type, options) {
    Utils.assert(type === Constants.GLOBE.Sky || type === Constants.GLOBE.Planet || type === Constants.GLOBE.Ground, "Type must be a value of Contants.GLOBE for " + this.constructor.name, "AbstractGlobe.js");
    Utils.assert(options != null, "Options is required " + this.constructor.name, "AbastractGlobe.js");
    Utils.assert(options.coordinateSystem != null && typeof options.coordinateSystem === "object" && options.coordinateSystem.geoideName != null, "coordinate system is required in options parameters for " + this.constructor.name, "AbastractGlobe.js");
    this.type = type;
    this.coordinateSystem = CoordinateSystemFactory.create(options.coordinateSystem);

    if (!options.renderContext) {
      this.renderContext = new RenderContext(options);
    } else {
      this.renderContext = options.renderContext;
    }

    this.publishEvent = options.publishEvent;
    this.isEnable = true;
    this.continuousRendering = options.continuousRendering || false;
    this.tileManager = new TileManager(this, options);
    this.rendererManager = new RendererManager(this);
    this.attributionHandler = null;
    this.baseImagery = null;
    this.preRenderers = [];
    this.nbCreatedLayers = 0;
    this.definedBackgound = false;
    this.subdivisionLength = options.subdivisionLength || 10000;
    this.maxSubdivisionCount = options.maxSubdivisionCount || 128;
    this.cachedPickingValue = null;
    this.tileManager.addPostRenderer(this.rendererManager);
    this.renderContext.renderers.push(this);
    this.refresh();
  };
  /**
   * Computes intersections.
   * @param {Ray} ray
   * @param {Crs} crs - coordinate reference system
   * @returns {number} The nearest intersection, < 0 if no intersection
   * @private
   */


  function _computeIntersection(ray, crs) {
    var intersection;

    if (crs.isFlat()) {
      intersection = ray.planeIntersect([0, 0, 0], [0, 0, 1]);
    } else {
      intersection = ray.sphereIntersect([0, 0, 0], crs.getGeoide().getRadius());
    }

    return intersection;
  }
  /**
   * Computes the position.
   * @param {Ray} ray
   * @param {number} intersection
   * @param {Crs} crs
   * @returns {float[]|null} the position
   * @private
   */


  function _computePosition(ray, intersection, crs) {
    if (intersection >= 0) {
      var pos = crs.getWorldFrom3D(ray.computePoint(intersection));
      var geoBound = crs.getGeoBound();

      if (!pos || pos[0] < geoBound[0] || pos[0] > geoBound[2] || pos[1] < geoBound[1] || pos[1] > geoBound[3] || isNaN(pos[0]) || isNaN(pos[1])) {
        return null;
      } else {
        return pos;
      }
    } else {
      return null;
    }
  }
  /**
   * Updates the geometry related to the old GeoTiling to the new GeoTiling.
   * @function _updateTileIndexInGeometry
   * @param {TileManager} tileManager tile manager
   * @private
   */


  function _updateTileIndexInGeometry(tileManager) {
    var postRenderers = tileManager.postRenderers;
    var postRendererIdx = postRenderers.length; // we use while, this is the fastest loop in Javascript https://jsperf.com/fastest-array-loops-in-javascript/32

    while (postRendererIdx--) {
      // we iterate on renderers
      var postRenderer = postRenderers[postRendererIdx];

      if (postRenderer instanceof RendererManager) {
        // we look for RendererManager because this one contains geometry
        var rendererManager = postRenderers[postRendererIdx];
        var vectors = rendererManager.renderers;
        var vectorIdx = vectors.length;

        while (vectorIdx--) {
          // we iterate on vector
          var vector = vectors[vectorIdx];

          if (vector.levelZeroTiledGeometries && vector.levelZeroTiledGeometries.length > 0) {
            // we retrieve the geometries
            var geometries = vector.levelZeroTiledGeometries;
            var geometryIdx = geometries.length;

            while (geometryIdx--) {
              // we iterate on each geometry to update the indexed tile related to the geometry
              // the (0,0) is 0, the (1,0) is 1, ....
              var geometry = geometries[geometryIdx];
              var tileIndices = vector.maxTilePerGeometry > 0 ? tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null; // update

              geometry._tileIndices = tileIndices;
            }
          }
        }
      }
    }
  }
  /*************************************************************************************************************/

  /**
   * @function getType
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getType = function () {
    return this.type;
  };
  /**
   * @function isSky
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.isSky = function () {
    return this.getType() === Constants.GLOBE.Sky;
  };
  /**
   * @function isPlanet
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.isPlanet = function () {
    return this.getType() === Constants.GLOBE.Planet;
  };
  /**
   * @function hasDefinedBackground
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.hasDefinedBackground = function () {
    return this.definedBackgound;
  };
  /**
   * @function setBaseImagery
   * @memberof AbstractGlobe#
   * @abstract
   */


  AbstractGlobe.prototype.setBaseImagery = function (layer) {
    throw new SyntaxError("AbstractGlobe.js: setBaseImagery Not implemented");
  };
  /**
   * @function getBaseImagery
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getBaseImagery = function () {
    return this.baseImagery;
  };
  /**
   * @function setBaseElevation
   * @memberof AbstractGlobe#
   * @abstract
   */


  AbstractGlobe.prototype.setBaseElevation = function (layer) {
    throw new SyntaxError("AbstractGlobe.js: setBaseElevation Not implemented");
  };
  /**
   * @function getBaseElevation
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getBaseElevation = function () {
    return this.tileManager.elevationProvider;
  };
  /**
   * @function addLayer
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.addLayer = function (layer) {
    Utils.assert(layer != null, "layer must be an AbstractLayer object in addLayer for " + this.constructor.name, "AbstractGlobe.js");
    var globe = this;

    if (layer.isVectorLayer()) {
      if (layer.isForDataProvider() || layer.isDraw()) {
        layer.id = globe.nbCreatedLayers;

        layer._attach(globe);

        globe.refresh();
        globe.nbCreatedLayers++;
      } else {
        // normal case
        Utils.requestUrl(layer.getUrl(), "json", "application/json", null, function (data) {
          layer.addFeatureCollection(data);
          layer.id = globe.nbCreatedLayers;

          layer._attach(globe);

          globe.refresh();
          globe.nbCreatedLayers++;

          if (layer.callback) {
            layer.callback(data);
          }
        }, function (err) {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Failed to request " + layer.getUrl(), err);
        });
      }
    } else {
      if (!layer.id) {
        layer.id = this.nbCreatedLayers;
        this.nbCreatedLayers++;
      }

      layer._attach(globe);

      this.refresh();
    }

    if (layer.isBackground()) {
      this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_ADDED, layer);
    } else {
      this.publishEvent(Constants.EVENT_MSG.LAYER_ADDED, layer);
    }
  };
  /**
   * @function removeLayer
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.removeLayer = function (layer) {
    Utils.assert(layer != null, "layer must be an AbstractLayer object in removeLayer for " + this.constructor.name, "AbstractGlobe.js");
    layer.background = false; //layer.setVisible(false); <!-- cannot do it because of PlanetLayer -->

    layer._detach();

    this.publishEvent(Constants.EVENT_MSG.LAYER_REMOVED, layer);
  };
  /**
   * @function addAnimation
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.addAnimation = function (anim) {
    Utils.assert(anim != null, "anim must be an AbstractAnimation object in addAnimation for " + this.constructor.name, "AbstractGlobe.js");
    anim.renderContext = this.renderContext;
  };
  /**
   * @function removeAnimation
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.removeAnimation = function (anim) {
    Utils.assert(anim != null, "anim must be an AbstractAnimation object in removeAnimation for " + this.constructor.name, "AbstractGlobe.js");
    anim.renderContext = null;
  };
  /**
   * @function getElevation
   * @memberof AbstractGlobe#
   * @abstract
   */


  AbstractGlobe.prototype.getElevation = function (lon, lat) {
    throw new SyntaxError("AbstractGlobe.js: getElevation Not implemented");
  };
  /**
   * @function getViewportGeoBound
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getViewportGeoBound = function (transformCallback) {
    var rc = this.renderContext;
    var tmpMat = mat4.create(); // Compute eye in world space

    mat4.inverse(rc.viewMatrix, tmpMat);
    var eye = [tmpMat[12], tmpMat[13], tmpMat[14]]; // Compute the inverse of view/proj matrix

    mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
    mat4.inverse(tmpMat); // Transform the four corners of the frustum into world space
    // and then for each corner compute the intersection of ray starting from the eye with the earth

    var points = [[-1, -1, 1, 1], [1, -1, 1, 1], [-1, 1, 1, 1], [1, 1, 1, 1]];
    var earthCenter = [0, 0, 0];

    for (var i = 0; i < 4; i++) {
      mat4.multiplyVec4(tmpMat, points[i]);
      vec3.scale(points[i], 1.0 / points[i][3]);
      vec3.subtract(points[i], eye, points[i]);
      vec3.normalize(points[i]);
      var ray = new Ray(eye, points[i]);
      var t = ray.sphereIntersect(earthCenter, this.coordinateSystem.getGeoide().getRadius()); //var t = ray.sphereIntersect(earthCenter, 15);

      if (t < 0.0) {
        return null;
      }

      var pos3d = ray.computePoint(t);
      points[i] = this.coordinateSystem.from3DToGeo(pos3d);

      if (transformCallback) {
        points[i] = transformCallback(points[i]);
      }
    }

    var geoBound = new GeoBound();
    geoBound.computeFromCoordinates(points);
    return geoBound;
  };
  /**
   * @function getLonLatFromPixel
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getLonLatFromPixel = function (x, y) {
    Utils.assert(typeof x === "number" && typeof y === "number", "(x,y) from getLonLatFromPixel must be numbers for " + this.constructor.name, "AbstractGlobe.js");

    if (this.isPlanet() && this.cachedPickingValue && this.cachedPickingValue.x === x && this.cachedPickingValue.y === y) {
      return this.cachedPickingValue.lonLat;
    }

    var ray = Ray.createFromPixel(this.renderContext, x, y);
    const lonLat = this.computeIntersection(ray);
    this.cachedPickingValue = {
      x: x,
      y: y,
      lonLat: lonLat
    };
    return lonLat;
  };
  /**
   * @function getPixelFromLonLat
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getPixelFromLonLat = function (lon, lat) {
    Utils.assert(typeof lon === "number" && typeof lat === "number", "(lon,lat) from getPixelFromLonLat must be numbers for " + this.constructor.name, "AbstractGlobe.js");
    var pos3d = vec3.create();
    this.coordinateSystem.get3DFromWorld([lon, lat], pos3d);
    return this.renderContext.getPixelFrom3D(pos3d[0], pos3d[1], pos3d[2]);
  };
  /**
   * @function setCoordinateSystem
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.setCoordinateSystem = function (coordinateSystem) {
    Utils.assert(coordinateSystem != null, "coordinateSystem must be a Crs object in setCoordinateSystem for " + this.constructor.name, "AbstractGlobe.js");
    var oldCrs = this.coordinateSystem;
    this.coordinateSystem = coordinateSystem;
    this.dispose();
    this.tileManager.tileConfig.coordinateSystem = coordinateSystem;

    if (this.coordinateSystem.isFlat() && this.coordinateSystem.getProjection().getName() === Constants.PROJECTION.Azimuth || oldCrs.isFlat() && oldCrs.getProjection().getName() === Constants.PROJECTION.Azimuth) {
      this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(this.tileManager.tileConfig, this.tileManager.tilePool);
    }

    _updateTileIndexInGeometry.call(this, this.getTileManager());
  };
  /**
   * @function getCoordinateSystem
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getCoordinateSystem = function () {
    return this.coordinateSystem;
  };
  /**
   * @function computeIntersection
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.computeIntersection = function (ray) {
    var intersection;

    if (this.hasMesh()) {
      intersection = Number.MAX_VALUE;

      for (var i = 0; i < this.tileManager.level0Tiles.length; ++i) {
        const tile = this.tileManager.level0Tiles[i];
        const t = tile.intersect(ray, this.tileManager.tileIndexBuffer.indices, this.renderContext);

        if (t < intersection && t >= 0) {
          intersection = t;
        }
      }

      if (intersection === Number.MAX_VALUE) {
        intersection = -1;
      }
    } else {
      //console.log("Ray",ray);
      intersection = _computeIntersection.call(this, ray, this.coordinateSystem);
    } // console.log("intersection",intersection);


    var result = _computePosition.call(this, ray, intersection, this.coordinateSystem); // console.log("result",result);
    // console.log("=================================");


    return result;
  };
  /**
   * @function getRenderStats
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getRenderStats = function () {
    return "# rendered tiles : " + this.tileManager.tilesToRender.length;
  };
  /**
   * @function getRenderContext
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getRenderContext = function () {
    return this.renderContext;
  };
  /**
   * @function setRenderContext
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.setRenderContext = function (context) {
    Utils.assert(context != null, "context must be a Context object in setRenderContext for " + this.constructor.name, "AbstractGlobe.js");
    this.renderContext = context;
  };
  /**
   * @function getTileManager
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getTileManager = function () {
    return this.tileManager;
  };
  /**
   * @function getRendererManager
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.getRendererManager = function () {
    return this.rendererManager;
  };
  /**
   * @function render
   * @memberof AbstractGlobe#
   * @abstract
   */


  AbstractGlobe.prototype.render = function () {
    throw new SyntaxError("AbstractGlobe.js: render Not implemented");
  };
  /**
   * @function dispose
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.dispose = function () {
    this.tileManager.reset();
    this.tileManager.tilePool.disposeAll();
  };
  /**
   * @function destroy
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.destroy = function () {
    if (this.tileManager) {
      this.dispose();
      this.tileManager.removePostRenderer(this.rendererManager);
      this.tileManager = null;
      this.rendererManager = null;
    }

    this.renderContext.renderers.splice(this.renderContext.renderers.indexOf(this), 1);

    if (this.coordinateSystem) {
      this.coordinateSystem.destroy();
      this.coordinateSystem = null;
    }

    this.refresh();
    this.definedBackgound = null;
    this.type = null;
    this.publishEvent = null;
    this.isEnable = null;
    this.globe = null;
    this.continuousRendering = null;
    this.attributionHandler = null;
    this.baseImagery = null;
    this.preRenderers = null;
    this.nbCreatedLayers = null;
  };
  /**
   * @function refresh
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.refresh = function () {
    this.renderContext.requestFrame();
  };
  /**
   * @function isEnabled
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.isEnabled = function () {
    return this.isEnable;
  };
  /**
   * @function enable
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.enable = function () {
    this.isEnable = true;
  };
  /**
   * @function disable
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.disable = function () {
    this.isEnable = false;
  };
  /**
   * @function hasMesh
   * @memberof AbstractGlobe#
   */


  AbstractGlobe.prototype.hasMesh = function () {
    return false;
  };
  /**
   * @function getSubdivisionLength
   * @member AbstractGlobe#
   */


  AbstractGlobe.prototype.getSubdivisionLength = function () {
    return this.subdivisionLength;
  };
  /**
   * @function setSubdivisionLength
   * @member AbstractGlobe#
   */


  AbstractGlobe.prototype.setSubdivisionLength = function (value) {
    this.subdivisionLength = value;
  };
  /**
   * @function getMaxSubdivisionCount
   * @member AbstractGlobe#
   */


  AbstractGlobe.prototype.getMaxSubdivisionCount = function () {
    return this.maxSubdivisionCount;
  };
  /**
   * @function setMaxSubdivisionCount
   * @member AbstractGlobe#
   */


  AbstractGlobe.prototype.setMaxSubdivisionCount = function (value) {
    this.maxSubdivisionCount = value;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name Planet
   * @class
   * Create a virtual planet in a HTML canvas element with its own coordinate reference system.
   * @augments AbstractGlobe
   * @param {AbstractGlobe.configuration} options - Planet configuration
   * @constructor
   * @memberof module:Globe
   */

  var Planet = function (options) {
    AbstractGlobe.prototype.constructor.call(this, Constants.GLOBE.Planet, options);
    this.manualRendererlayers = [];
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractGlobe, Planet);
  /**************************************************************************************************************/

  /**
   * Sets the base imagery layer for the Planet.
   * @function setBaseImagery
   * @memberof Planet#
   * @param {AbstractRasterLayer} layer the layer to use
   * @throws {RangeError} layer must be set.
   */

  Planet.prototype.setBaseImagery = function (layer) {
    if (layer == null) {
      throw new RangeError("Planet.js: layer must be exist.");
    }

    if (layer === this.baseImagery) {
      return;
    }

    if (this.baseImagery) {
      this.tileManager.setImageryProvider(null);
      this.baseImagery = null;
    } // Attach the layer to the globe


    this.definedBackgound = true;
    layer.background = true;
    layer.visible = true; //setImageryProvider needs visible=true and we cannit

    if (layer.isDetached()) {
      this.addLayer(layer);
    }

    this.tileManager.setImageryProvider(layer);
    this.baseImagery = layer;
    this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, layer);
  };
  /**
   * @function setBaseElevation
   * @memberof Planet#
   */


  Planet.prototype.setBaseElevation = function (layer) {
    if (this.tileManager.elevationProvider) {
      this.removeLayer(this.tileManager.elevationProvider);
    }

    this.tileManager.setElevationProvider(layer);

    if (layer) {
      this.addLayer(layer);
    }
  };
  /**
   * @function getElevation
   * @memberof Planet#
   */


  Planet.prototype.getElevation = function (lon, lat) {
    // Use imagery provider tiling if defined, otherwise use globe default one
    var tiling = this.tileManager.tiling;

    if (this.baseImagery) {
      tiling = this.baseImagery.tiling;
    }

    var levelZeroTile = this.tileManager.level0Tiles[tiling.lonlat2LevelZeroIndex(lon, lat)];

    if (Tile.State && levelZeroTile && levelZeroTile.state === Tile.State.LOADED) {
      return levelZeroTile.getElevation(lon, lat);
    } else {
      return 0.0;
    }
  };
  /**
   * @function render
   * @memberof Planet#
   */


  Planet.prototype.render = function () {
    if (this.isEnabled()) {
      // Call pre-renderers (only in 3D mode, no atmosphere for 2D)
      if (!this.coordinateSystem.isFlat()) {
        for (var i = 0; i < this.preRenderers.length; i++) {
          this.preRenderers[i].preRender();
        }
      } // Render tiles


      this.tileManager.render();
    }

    this.cachedPickingValue = null;
  };
  /**
   * @function hashMesh
   * @memberof Planet#
   */


  Planet.prototype.hasMesh = function () {
    return true;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name Sky
   * @class
   * Create a virtual sky in a HTML canvas element with its own coordinate reference system.
   *
   * The sky handles two different grids in the same time in order to display both
   * the galactic and equatorial rasters.
   *
   * @augments AbstractGlobe
   * @param {AbstractGlobe.configuration} options - Sky configuration
   * @constructor
   * @memberof module:Globe
   */

  var Sky = function (options) {
    AbstractGlobe.prototype.constructor.call(this, Constants.GLOBE.Sky, options);
    this.tilePool = new TilePool(this.renderContext);
    this.tileManagers = {
      Equatorial: this.tileManager,
      Galactic: new TileManager(this, options)
    };
    this.renderContext.requestFrame();
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractGlobe, Sky);
  /**************************************************************************************************************/

  /**
   * @function dispose
   * @memberof Sky#
   */

  Sky.prototype.dispose = function () {
    for (var x in this.tileManagers) {
      if (this.tileManagers.hasOwnProperty(x)) {
        this.tileManagers[x].reset();
        this.tileManagers[x].tilePool.disposeAll();
      }
    }
  };
  /**
   * @function setBaseImagery
   * @memberof Sky#
   * @throws {RangeError} Layer must be set
   **/


  Sky.prototype.setBaseImagery = function (layer) {
    if (layer == null) {
      throw new RangeError("Sky.js: layer must be exist.");
    }

    if (this.baseImagery === layer) {
      return;
    }

    if (this.baseImagery) {
      this.tileManagers[this.baseImagery.tiling.coordinateSystem.getGeoideName()].setImageryProvider(null);
      this.baseImagery = null;
    }

    layer.loadOverview(); // Attach the layer to the globe

    this.definedBackgound = true;
    layer.visible = true;

    if (layer.isDetached()) {
      this.addLayer(layer);
    }

    this.tileManagers[layer.tiling.coordinateSystem.getGeoideName()].setImageryProvider(layer);
    this.baseImagery = layer;
    this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, layer);
  };
  /**
   * @function render
   * @memberof Sky#
   */


  Sky.prototype.render = function () {
    // Render tiles manager
    if (this.isEnabled()) {
      this.tileManagers[Constants.CRS.Galactic].render();
      this.tileManagers[Constants.CRS.Equatorial].render();
    }
  };
  /**
   * @function destroy
   * @memberof Sky#
   */


  Sky.prototype.destroy = function () {
    AbstractGlobe.prototype.destroy.call(this);
    this.tileManagers.Galactic.reset();
    this.tileManagers.Galactic.tilePool.disposeAll();
    this.tileManagers = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var GlobeFactory = {
    /**
     * Creates a specific globe based on its type (e.g sky, planet).
     * @param {GLOBE} type - the type of globe
     * @param {AbstractGlobe.configuration} options - options to configure a globe
     * @return {Globe} a globe
     * @alias module:Globe.GlobeFactory.create
     * @throws {RangeError} Will throw an error when the type is not part of {@link GLOBE}
     * @see {@link module:Globe.Planet Planet}
     * @see {@link module:Globe.Sky Sky}
     */
    create: function (type, options) {
      var obj;

      switch (type) {
        case Constants.GLOBE.Planet:
          obj = new Planet(options);
          break;

        case Constants.GLOBE.Sky:
          obj = new Sky(options);
          break;

        default:
          throw RangeError("The type " + type + " is not allowed, A valid type is included in the list GLOBE", "GlobeFactory.js");
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Google mouse navigation handler configuration
   * @typedef {Object} AbstractNavigation.googleMouse_configuration
   */

  /**
   * @name GoogleMouseNavigationHandler
   * @class
   * GoogleMouseNavigationHandler constructor
   * @param {AbstractNavigation.googleMouse_configuration} options
   * @constructor
   * @memberof module:Navigation
   */

  var GoogleMouseNavigationHandler = function (options) {
    /**************************************************************************************************************/

    /**
     * Private variables
     */
    var _navigation = null;

    var _pressedButton = -1;

    var _lastMouseX = -1;

    var _lastMouseY = -1;

    var _needsStartEvent = false;
    var _needsEndEvent = false;
    var _dx = 0;
    var _dy = 0;
    var _pressedGeo = null;
    var _changeInertia = null;
    var _slower = 0;
    /**************************************************************************************************************/

    /**
     * Private methods
     */

    /**
     * Event handler for mouse wheel
     * @function _handleMouseWheel
     * @param event Event
     * @returns {boolean}
     * @private
     * @memberof GoogleMouseNavigationHandler#
     * @fires Context#startNavigation
     * @fires Context#endNavigation
     */

    var _handleMouseWheel = function (event) {
      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

      var factor;
      var geo, pos; // Check differences between firefox and the rest of the world

      if (typeof event.wheelDelta === "undefined") {
        factor = event.detail;
      } else {
        factor = -event.wheelDelta / 120.0;
      }

      if (!_navigation.inertia) {
        // Compute mouse position and corresponding lon lat before zoom
        pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
        geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
      }

      _navigation.zoom(factor); // Stop all animations when an event is received


      _navigation.stopAnimations(); // Launch inertia if needed


      if (_navigation.inertia) {
        _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
      } else {
        // Compute the new position of lon lat and pan the globe toward it
        if (geo) {
          var pos2 = _navigation.ctx.getPixelFromLonLat(geo[0], geo[1]);

          var dx = pos[0] - pos2[0];
          var widthHeightFactor = Math.round(_navigation.ctx.getRenderContext().getCanvas().width / _navigation.ctx.getRenderContext().getCanvas().height);
          widthHeightFactor = widthHeightFactor < 1 ? 1 : widthHeightFactor;
          dx *= widthHeightFactor;
          var dy = pos[1] - pos2[1];

          _navigation.pan(dx, dy);
        }
      } // Stop mouse wheel to be propagated, because default is to scroll the page
      // This is need when using Firefox event listener on DOMMouseScroll


      if (event.preventDefault) {
        event.preventDefault();
      }

      event.returnValue = false;

      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);

      _navigation.ctx.getRenderContext().requestFrame(); // Return false to stop mouse wheel to be propagated when using onmousewheel


      return false;
    };
    /**
     * Event handler for mouse down
     * @function _handleMouseDown
     * @param event
     * @returns {boolean}
     * @private
     * @memberof GoogleMouseNavigationHandler#
     */


    var _handleMouseDown = function (event) {
      _pressedButton = event.button; // Stop all animations when an event is received

      _navigation.stopAnimations();

      _lastMouseX = event.offsetX;
      _lastMouseY = event.offsetY;
      _dx = 0;
      _dy = 0; // Middle click

      if (event.button === 1) {
        // Cursor's style modification: Rotating icon
        _navigation.ctx.getRenderContext().getCanvas().style.cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
      } // Left and right click
      else {
          // Save the lon lat clicked
          var pressedPos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);

          _pressedGeo = _navigation.ctx.getLonLatFromPixel(pressedPos[0], pressedPos[1]); // Left click

          if (event.button === 0) {
            // Cursor's style modification: Grabbing icon
            _navigation.ctx.getRenderContext().getCanvas().style.cursor = "url(data:image/png;base64,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), auto";
          } // Right click
          else {
              // Cursor's style modification: Zooming (same as Rotating) icon
              _navigation.ctx.getRenderContext().getCanvas().style.cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
            }
        }

      _needsStartEvent = true; // Return false to stop mouse down to be propagated when using onmousedown

      return false;
    };
    /**
     * Event handler for mouse up
     * @function _handleMouseUp
     * @param event
     * @returns {boolean}
     * @private
     * @memberof GoogleMouseNavigationHandler#
     * @fires Context#endNavigation
     */


    var _handleMouseUp = function (event) {
      // No button pressed anymore
      _pressedButton = -1;

      if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
        // Left click
        if (event.button === 0) {
          //different behavior if the move has change from pan to rotate
          if (_changeInertia) {
            _navigation.inertia.launch("rotate", _changeInertia, 0);
          } else {
            _navigation.inertia.launch("pan", _dx, _dy);
          }
        } // Middle click
        else if (event.button === 1) {
            _navigation.inertia.launch("rotate", -_dx, -_dy);
          }
      } // Cursor's style modification : Hand icon


      _navigation.ctx.getRenderContext().getCanvas().style.cursor = "url(data:image/png;base64,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), auto";
      _pressedGeo = null;
      _slower = 0;

      if (_needsEndEvent) {
        _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);
      }

      _needsStartEvent = false;
      _needsEndEvent = false; // Stop mouse up event

      return false;
    };
    /**
     * Event handler for mouse move
     * @function _handleMouseMove
     * @param event
     * @returns {boolean}
     * @private
     * @memberof GoogleMouseNavigationHandler#
     * @fires Context#startNavigation
     * @fires Context#endNavigation
     */


    var _handleMouseMove = function (event) {
      // No button pressed
      if (_pressedButton < 0) {
        return;
      }

      _dx = event.offsetX - _lastMouseX;
      _dy = event.offsetY - _lastMouseY;

      if (_dx === 0 && _dy === 0) {
        return;
      }

      var ret = false;
      var inside;
      var pos, pos2; // Pan on Left click

      if (_pressedButton === 0) {
        if (_needsStartEvent) {
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          _needsStartEvent = false;
          _needsEndEvent = true;
        } // Compute the mouse position


        pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);

        if (_pressedGeo) {
          _changeInertia = null;
          inside = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

          if (inside) {
            pos2 = _navigation.ctx.getPixelFromLonLat(_pressedGeo[0], _pressedGeo[1]);
            _dx = pos[0] - pos2[0];
            _dy = pos[1] - pos2[1];

            _navigation.pan(_dx, _dy);
          }
        } // If the mouse not on the globe


        if (!_pressedGeo || !inside) {
          if (Math.abs(_dx) > Math.abs(_dy)) {
            _changeInertia = pos[1] > _navigation.ctx.getRenderContext().getCanvas().height / 2 ? -_dx : _dx;
          } else {
            _changeInertia = pos[0] > _navigation.ctx.getRenderContext().getCanvas().width / 2 ? _dy : -_dy;
          }

          _navigation.rotate(_changeInertia, 0);

          pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
          _pressedGeo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

          if (_pressedGeo) {
            _changeInertia = null;
          }
        }

        _navigation.ctx.getRenderContext().requestFrame();

        ret = true;
      } // Rotate on Middle click
      else if (_pressedButton === 1) {
          _navigation.rotate(-_dx, -_dy);

          _navigation.ctx.getRenderContext().requestFrame();

          ret = true;
        } // Zoom on Right click
        else {
            // Mouse move is too fast for zooming, need to slow it down
            _slower++;

            if (_slower % 3 === 0 && _slower > 1) {
              _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

              _navigation.zoom(-_dy / 10);

              if (_dy > 0 && _dy > _dx) {
                // Compute the new position of lon lat and pan the globe toward it
                if (_pressedGeo) {
                  pos = [_navigation.ctx.getRenderContext().getCanvas().clientLeft + _navigation.ctx.getRenderContext().getCanvas().clientWidth / 2, _navigation.ctx.getRenderContext().getCanvas().clientTop + _navigation.ctx.getRenderContext().getCanvas().clientHeight / 2];
                  pos2 = _navigation.ctx.getPixelFromLonLat(_pressedGeo[0], _pressedGeo[1]);
                  var dx = pos[0] - pos2[0];
                  dx = dx * 10 / 100;
                  var dy = pos[1] - pos2[1];
                  dy = dy * 10 / 100;

                  _navigation.pan(dx, dy);
                }
              } // Stop all animations when an event is received


              _navigation.stopAnimations();

              _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);

              _navigation.ctx.getRenderContext().requestFrame();
            }

            ret = true;
          }

      _lastMouseX = event.offsetX;
      _lastMouseY = event.offsetY;
      return ret;
    };
    /**
     * Event handler for mouse double click
     * @function _handleMouseDblClick
     * @param event
     * @private
     * @memberof GoogleMouseNavigationHandler#
     */


    var _handleMouseDblClick = function (event) {
      if (event.button === 0) {
        var pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);

        var geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

        if (geo) {
          _navigation.zoomTo(geo);
        }
      }
    };
    /**
     * Event handler for mouse context menu
     * @function _handleContextMenu
     * @param event
     * @private
     * @memberof GoogleMouseNavigationHandler#
     */


    var _handleContextMenu = function (event) {
      // Need this so browser's context menu won't show up when using right click zooming
      event.preventDefault();
      return false;
    };
    /**************************************************************************************************************/

    /**
     * Public methods
     */

    /**
     * Setup the default event handlers for the _navigation
     * @function install
     * @param nav
     * @memberof GoogleMouseNavigationHandler#
     * @fires Context#startNavigation
     * @fires Context#endNavigation
     */


    this.install = function (nav) {
      _navigation = nav;
      var canvas = _navigation.getRenderContext.getCanvas; // Cursor's style modification : Hand icon

      canvas.style.cursor = "url(data:image/png;base64,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), auto"; // Setup the mouse event handlers

      canvas.addEventListener("mousedown", _handleMouseDown);
      canvas.addEventListener("mouseup", _handleMouseUp);
      canvas.addEventListener("mousemove", _handleMouseMove);
      canvas.addEventListener("contextmenu", _handleContextMenu);
      canvas.addEventListener("dblclick", _handleMouseDblClick); // For Firefox

      canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
      canvas.addEventListener("mousewheel", _handleMouseWheel);
    };
    /**
     * Remove the default event handlers for the _navigation
     * @function uninstall
     * @memberof GoogleMouseNavigationHandler#
     */


    this.uninstall = function () {
      // Setup the mouse event handlers
      var canvas = _navigation.getRenderContext().getCanvas();

      canvas.style.cursor = "auto";
      canvas.removeEventListener("mousedown", _handleMouseDown);
      canvas.removeEventListener("mouseup", _handleMouseUp);
      canvas.removeEventListener("mousemove", _handleMouseMove);
      canvas.removeEventListener("contextmenu", _handleContextMenu);
      canvas.removeEventListener("dblclick", _handleMouseDblClick); // For Firefox

      canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
      canvas.removeEventListener("mousewheel", _handleMouseWheel);
    };
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Keyboard navigation handler configuration
   * @typedef {Object} AbstractNavigation.keyboard_configuration
   * @property {float} [panFactor = 10.0] - Factor for panning within the scene
   * @property {float} [zoomFactor = 1.0] - Factor for zooming into the scene
   * @property {boolean} [installOnDocument = false] -true to install the event listener on the document and not on the canvas
   */

  /**
   * @name KeyboardNavigationHandler
   * @class
   * KeyboardNavigationHandler constructor.<br/>
   * The keyboard shortcuts are the following :
   * <ul>
   *     <li><i>space bar</i> : Stop all animations when an event is received</li>
   *     <li><i>+</i> : zoom in the camera</li>
   *     <li><i>-</i> : zoom out the camera</li>
   *     <li><i>Left arrow</i> : pan the camera left</li>
   *     <li><i>shift + left arrow</i> : rotate the camera counterclockwise</li>
   *     <li><i>Right arrow</i> : pan the camera right</li>
   *     <li><i>shift + right arrow</i> : rotate the camera clockwise</li>
   *     <li><i>Up arrow</i> : pan the camera up</li>
   *     <li><i>shift + up arrow</i> : rotate the camera up</li>
   *     <li><i>Down arrow</i> : pan the camera down</li>
   *     <li><i>shift + down arrow</i> : rotate the camera down</li>
   * </ul>
   *
   * @param {AbstractNavigation.keyboard_configuration} options - Keyboard navigation configuration
   * @constructor
   * @memberof module:Navigation
   */

  var KeyboardNavigationHandler = function (options) {
    /**************************************************************************************************************/

    /**
     * Private variables
     */
    var _navigation = null;
    var self = this;
    /**
     * Public variables
     */

    this.panFactor = 10.0;
    this.zoomFactor = 1.0; // Setup options

    if (options) {
      if (options.panFactor && typeof options.panFactor === "number") {
        this.panFactor = options.panFactor;
      }

      if (options.zoomFactor && typeof options.zoomFactor === "number") {
        this.zoomFactor = options.zoomFactor;
      }
    }
    /**************************************************************************************************************/

    /**
     * Private methods
     */

    /**
     * Set focus
     */


    var _setFocus = function (event) {
      this.focus();
      return false;
    };
    /**
     * Event handler for key down.
     * @param event
     * @private
     */


    var _handleKeyDown = function (event) {
      switch (event.keyCode) {
        case 32:
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED); // space bar
          // Stop all animations when an event is received


          _navigation.stopAnimations();

          break;

        case 187: // + on Safari
        // falls through

        case 61: // +(=) on Firefox and Opera
        // falls through

        case 107:
          // + on other
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          _navigation.zoom(-self.zoomFactor);

          break;

        case 189: // - on Safari
        // falls through

        case 54: // -(6) on Firefox and Opera
        // falls through

        case 109:
          // - on other
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          _navigation.zoom(self.zoomFactor);

          break;

        case 81: // q
        // falls through

        case 37:
          // Left arrow
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          if (event.shiftKey) {
            _navigation.rotate(self.panFactor, 0);
          } else {
            _navigation.pan(self.panFactor, 0);
          }

          break;

        case 90: // z
        // falls through

        case 38:
          // Up arrow
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          if (event.shiftKey) {
            _navigation.rotate(0, self.panFactor);
          } else {
            _navigation.pan(0, self.panFactor);
          }

          break;

        case 68: // d
        // falls through

        case 39:
          // Right arrow
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          if (event.shiftKey) {
            _navigation.rotate(-self.panFactor, 0);
          } else {
            _navigation.pan(-self.panFactor, 0);
          }

          break;

        case 83: // s
        // falls through

        case 40:
          // Down arrow
          _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

          if (event.shiftKey) {
            _navigation.rotate(0, -self.panFactor);
          } else {
            _navigation.pan(0, -self.panFactor);
          }

          break;
      }
    };

    var _handleKeyUp = function (event) {
      _navigation.donePanning();

      _navigation.doneRotating();
    };
    /**************************************************************************************************************/

    /**
     * Public methods
     */

    /**
       Setup the default event handlers for the navigation
       */


    this.install = function (navigation) {
      // Setup the keyboard event handlers
      _navigation = navigation;

      if (options && options.installOnDocument) {
        document.addEventListener("keydown", _handleKeyDown);
        document.addEventListener("keyup", _handleKeyUp);
      } else {
        var canvas = _navigation.renderContext.canvas;
        canvas.addEventListener("keydown", _handleKeyDown);
        canvas.addEventListener("keyup", _handleKeyUp); // Setup focus handling to receive keyboard event on canvas

        canvas.tabIndex = "0";
        canvas.addEventListener("mousedown", _setFocus);
      }
    };
    /**
       Remove the default event handlers for the navigation
       */


    this.uninstall = function () {
      if (options && options.installOnDocument) {
        document.removeEventListener("keydown", _handleKeyDown);
        document.removeEventListener("keyup", _handleKeyUp);
      } else {
        var canvas = _navigation.renderContext.canvas;
        canvas.removeEventListener("keydown", _handleKeyDown);
        canvas.removeEventListener("keyup", _handleKeyUp);
        canvas.removeEventListener("mousedown", _setFocus);
      }
    };
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Mouse navigation handler configuration
   * @typedef {Object} AbstractNavigation.mouse_configuration
   * @property {float} [panButton = 0]
   * @property {float} [rotateButton = 1]
   * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
   * @property {Object} [zoomOptions] - @see look at options in {@link Navigation#zoomTo}
   */

  /**
   * @name MouseNavigationHandler
   * @class
   * Mouse_navigationHandler constructor.<br/>
   * The mouse movements are the following :
   * <ul>
   *     <li><i>Wheel up</i> : zoom in the camera</li>
   *     <li><i>Wheel down</i> : zoom out the camera</li>
   *     <li><i>Click left+Ri + left mouse</i> : pan the camera right</li>
   *     <li><i>Wheel press + left mouse</i> : rotate the camera counterclockwise</li>
   *     <li><i>Click left + right mouse</i> : pan the camera left</li>
   *     <li><i>Wheel press + right arrow</i> : rotate the camera clockwise</li>
   *     <li><i>Click left + up mouse</i> : pan the camera down</li>
   *     <li><i>Wheel press + up mouse</i> : rotate the camera down</li>
   *     <li><i>Click left + down mouse</i> : pan the camera up</li>
   *     <li><i>Wheel press + down mouse</i> : rotate the camera up</li>
   * </ul>
   * @param {AbstractNavigation.mouse_configuration} options - Mouse navigation configuration
   * @constructor
   * @memberof module:Navigation
   */

  var MouseNavigationHandler = function (options) {
    /**************************************************************************************************************/

    /**
     * Private variables
     */
    var _navigation = null;

    var _pressedButton = -1;

    var _lastMouseX = -1;

    var _lastMouseY = -1;

    var _dx = 0;
    var _dy = 0;

    var _panButton = options && options.panButton || 0;

    var _rotateButton = options && options.rotateButton || 1;

    var _zoomOptions = options && options.zoomOptions ? options.zoomOptions : {};
    /**************************************************************************************************************/

    /**
     * Private methods
     */

    /**
       Event handler for mouse wheel
       */


    var _handleMouseWheel = function (event) {
      var factor; // Check differences between firefox and the rest of the world

      if (event.wheelDelta === undefined) {
        factor = event.detail;
      } else {
        factor = -event.wheelDelta / 120.0;
      }

      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

      _navigation.zoom(factor, null, event.offsetX, event.offsetY); // Stop all animations when an event is received


      _navigation.stopAnimations(); // Launch inertia if needed


      if (_navigation.inertia) {
        _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
      }

      event.returnValue = false; // Return false to stop mouse wheel to be propagated when using onmousewheel

      return false;
    };
    /**
     * Event handler for mouse down
     */


    var _handleMouseDown = function (event) {
      document.addEventListener("mouseup", _handleMouseUp);
      _pressedButton = event.button; // Stop all animations when an event is received

      _navigation.stopAnimations();

      if (event.button === _panButton || event.button === _rotateButton) {
        _lastMouseX = event.offsetX;
        _lastMouseY = event.offsetY;
        _dx = 0;
        _dy = 0;

        _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

        _navigation.startInteraction(_lastMouseX, _lastMouseY); // Return false to stop mouse down to be propagated when using onmousedown


        return false;
      }

      return true;
    };
    /**
     * Event handler for mouse up
     */


    var _handleMouseUp = function (event) {
      // No button pressed anymore
      _pressedButton = -1;
      document.removeEventListener("mouseup", _handleMouseUp);

      if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
        if (event.button === _panButton) {
          _navigation.inertia.launch("pan", _dx, _dy);
        }

        if (event.button === _rotateButton) {
          _navigation.inertia.launch("rotate", _dx, _dy);
        }
      }

      if (event.button === _panButton) {
        _navigation.donePanning();
      }

      if (event.button === _rotateButton) {
        _navigation.doneRotating();
      }

      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);

      if (event.button === _panButton || event.button === _rotateButton) {
        event.preventDefault(); // Stop mouse up event

        return false;
      }

      return true;
    };
    /**
       Event handler for mouse move
       */


    var _handleMouseMove = function (event) {
      // No button pressed
      if (_pressedButton < 0) {
        return;
      }

      _dx = event.offsetX - _lastMouseX;
      _dy = event.offsetY - _lastMouseY;

      if (_dx === 0 && _dy === 0) {
        return;
      }

      var ret = false; // Pan

      if (_pressedButton === _panButton) {
        _navigation.pan(_dx, _dy, event.offsetX, event.offsetY);

        ret = true;
      } // Rotate
      else if (_pressedButton === _rotateButton) {
          _navigation.rotate(_dx, _dy);

          ret = true;
        }

      _lastMouseX = event.offsetX;
      _lastMouseY = event.offsetY;
      return ret;
    };
    /**
       Event handler for mouse double click
       */


    var _handleMouseDblClick = function (event) {
      if (event.button === 0) {
        var pos, geo;
        pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
        geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

        if (geo) {
          _navigation.zoomTo(geo, _zoomOptions);
        }
      }
    };
    /**************************************************************************************************************/

    /**
     * Public methods
     */

    /**
     *    Setup the default event handlers for the _navigation
     */


    this.install = function (nav) {
      _navigation = nav;
      var canvas = _navigation.renderContext.canvas;
      var passiveSupported = Utils.isPassiveSupported(); // Setup the mouse event handlers

      canvas.addEventListener("mousedown", _handleMouseDown);
      canvas.addEventListener("mousemove", _handleMouseMove);

      if (options && options.zoomOnDblClick) {
        canvas.addEventListener("dblclick", _handleMouseDblClick);
      } // For Firefox


      canvas.addEventListener("DOMMouseScroll", _handleMouseWheel, passiveSupported ? {
        passive: true
      } : false);
      canvas.addEventListener("mousewheel", _handleMouseWheel, passiveSupported ? {
        passive: true
      } : false); // Fix for Google Chrome : avoid dragging
      // TODO : a hack, should be more robust (restore on uninstall?)

      canvas.addEventListener("dragstart", function (event) {
        event.preventDefault();
        return false;
      });

      if (_rotateButton === 2) {
        canvas.addEventListener("contextmenu", function (e) {
          e.preventDefault();
          return false;
        }, false);
      }
    };
    /**
     *    Remove the default event handlers for the _navigation
     */


    this.uninstall = function () {
      // Setup the mouse event handlers
      var canvas = _navigation.renderContext.canvas;
      canvas.removeEventListener("mousedown", _handleMouseDown);
      canvas.removeEventListener("mousemove", _handleMouseMove);

      if (options && options.zoomOnDblClick) {
        canvas.removeEventListener("dblclick", _handleMouseDblClick);
      } // For Firefox


      canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
      canvas.removeEventListener("mousewheel", _handleMouseWheel);
    };
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   *    Types of actions for inertia execution
   */

  var Type = {
    PAN: 0,
    ROTATE: 1,
    TILT: 2,
    ZOOM: 3
  };
  /**
   * Touch navigation handler configuration
   * @typedef {Object} AbstractNavigation.touch_configuration
   * @property {boolean} [inversed = false] - if true inverse the sens of touching events
   * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
   */

  /**
   * @name TouchNavigationHandler
   * @class
   * TouchNavigationHandler constructor
   * @param {AbstractNavigation.touch_configuration} options - Touch navigation configuration
   * @constructor
   * @memberof module:Navigation
   */

  var TouchNavigationHandler = function (options) {
    /**************************************************************************************************************/

    /**
     * Private variables
     */
    var _navigation = null;

    var _lastFingerDistance;

    var _startTouches = [];

    var _lastTouches;

    var _lastAngle;

    var _dx, _dy; // Parameters for intertia management


    var _actionHits = [0, 0, 0, 0];

    var _lastTapDate;

    var _rotation; // Double tap


    var _doubletap_interval = 300;

    var _inversed = options && options.hasOwnProperty("inversed") ? options.inversed : false;
    /**************************************************************************************************************/

    /**
     * Private methods
     */

    /**
     * Calculate the angle between two coordinates
     */


    var _getAngle = function (touch1, touch2) {
      var y = touch2.offsetY - touch1.offsetY,
          x = touch2.offsetX - touch1.offsetX;
      return Numeric.toDegree(Math.atan2(y, x));
    };
    /**************************************************************************************************************/

    /**
     * Calculate the rotation degrees between two touchLists (fingers)
     */


    var _getRotation = function (start, end) {
      // Need two fingers
      if (start.length >= 2 && end.length >= 2) {
        return _getAngle(end[1], end[0]) - _getAngle(start[1], start[0]);
      }

      return 0;
    };
    /**************************************************************************************************************/

    /**
       Handle touch start event
       */


    var _handleTouchStart = function (event) {
      //console.log("# events : " + event.touches.length );
      _lastTouches = event.touches;
      _startTouches = event.touches;
      _actionHits = [0, 0, 0, 0];

      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

      _navigation.startInteraction(event.touches[0].offsetX, event.touches[0].offsetY); // Stop all animations when an event is received


      _navigation.stopAnimations();

      _dx = 0;
      _dy = 0;

      if (event.touches.length === 2) {
        var dx = event.touches[0].offsetX - event.touches[1].offsetX;
        var dy = event.touches[0].offsetY - event.touches[1].offsetY;
        _lastFingerDistance = Math.sqrt(dx * dx + dy * dy);
        ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js", "Finger distance : " + _lastFingerDistance);
        _lastAngle = _getRotation(_startTouches, event.touches);
      }

      event.returnValue = false; // Return false to stop event to be propagated

      return false;
    };
    /**************************************************************************************************************/

    /**
       Handle touch move event
       */


    var _handleTouchMove = function (event) {
      _dx = event.touches[0].offsetX - _lastTouches[0].offsetX;
      _dy = event.touches[0].offsetY - _lastTouches[0].offsetY;
      var dx, dy;
      var rotation, fingerDistance, deltaDistance;

      if (event.touches.length === 1) {
        // Pan
        _navigation.pan(_dx, _dy);

        _actionHits[Type.PAN]++;
      } else {
        // Depending on direction of two fingers, decide if tilt OR rotation
        var sameDirection = (event.touches[0].offsetY - _lastTouches[0].offsetY) * (event.touches[1].offsetY - _lastTouches[1].offsetY) > 0;

        if (sameDirection) {
          // Tilt
          _navigation.rotate(0.0, -_dy);

          _actionHits[Type.TILT]++;
        } else {
          // Rotation
          rotation = _getRotation(_startTouches, event.touches);
          dx = rotation - _lastAngle;
          _lastAngle = rotation;

          if (_inversed) {
            dx *= -1;
          }

          _rotation = dx * 10;

          _navigation.rotate(_rotation, 0);

          _actionHits[Type.ROTATE]++;
        } // Zoom


        dx = event.touches[0].offsetX - event.touches[1].offsetX;
        dy = event.touches[0].offsetY - event.touches[1].offsetY;
        fingerDistance = Math.sqrt(dx * dx + dy * dy);
        deltaDistance = fingerDistance - _lastFingerDistance;
        var scale;

        if (_inversed) {
          scale = fingerDistance / _lastFingerDistance;
        } else {
          scale = _lastFingerDistance / fingerDistance;
        }

        if (_lastFingerDistance !== 0) {
          _navigation.zoom(deltaDistance * 0.025, scale);

          _actionHits[Type.ZOOM]++;
        }

        _navigation.getRenderContext().requestFrame();

        _lastFingerDistance = fingerDistance;
      } // Update _lastTouches


      _lastTouches = event.touches;
      event.returnValue = false;
      return false;
    };
    /**************************************************************************************************************/

    /**
       Handle touch end event
       */


    var _handleTouchEnd = function (event) {
      if (options && options.zoomOnDblClick && event.touches.length === 0 && _dx === 0 && _dy === 0) {
        // Handle double tap
        // TODO : take into account the distance
        var now = Date.now();

        if (now - _lastTapDate < _doubletap_interval) {
          var geo = _navigation.ctx.getLonLatFromPixel(_lastTouches[0].offsetX, _lastTouches[0].offsetY);

          if (geo) {
            _navigation.zoomTo(geo);
          }
        }

        _lastTapDate = now;
      } // Update last touches


      _lastTouches = event.touches;

      if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
        // Launch inertia depending on action hits while "moving" phase
        var hitIndex = _actionHits.indexOf(Math.max.apply(this, _actionHits));

        if (hitIndex === Type.PAN) {
          // Pan
          _navigation.inertia.launch("pan", _dx, _dy);
        } else if (hitIndex === Type.ROTATE) {
          ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js", "Rotate not implemented in navigation"); // Rotate
          //_navigation.inertia.launch("rotate", _rotation, 0);
        } else if (hitIndex === Type.TILT) {
          ErrorDialog.open(Constants.LEVEL.DEBUG, "TouchNavigationHandler.js", "Tilt not implemented in navigation"); // No inertia for tilt
        }
      }

      if (event.preventDefault) {
        event.preventDefault();
      }

      event.returnValue = false;

      _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);

      return false;
    };
    /**************************************************************************************************************/

    /**
     * Public methods
     */

    /**
     *    Setup the default event handlers for the _navigation
     */


    this.install = function (nav) {
      _navigation = nav; // Setup the touch event handlers

      var canvas = _navigation.renderContext.canvas;
      var passiveSupported = Utils.isPassiveSupported();
      canvas.addEventListener("touchstart", _handleTouchStart, passiveSupported ? {
        passive: true
      } : false);
      canvas.addEventListener("touchend", _handleTouchEnd, false);
      canvas.addEventListener("touchmove", _handleTouchMove, passiveSupported ? {
        passive: true
      } : false);
    };
    /**
     *    Remove the default event handlers for the _navigation
     */


    this.uninstall = function () {
      // Setup the mouse event handlers
      var canvas = _navigation.renderContext.canvas;
      canvas.removeEventListener("touchstart", _handleTouchStart, false);
      canvas.removeEventListener("touchend", _handleTouchEnd, false);
      canvas.removeEventListener("touchmove", _handleTouchMove, false);
    };
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var NavigationHandlerFactory = {
    /**
     * Creates a specific navigation based on its type (e.g Astro, Flat, Sky).
     * @param {HANDLER} type - the type of navigation
     * @param {AbstractNavigation.touch_configuration|AbstractNavigation.mouse_configuration|AbstractNavigation.googleMouse_configuration|AbstractNavigation.keyboard_configuration} options - see the handlers.
     * @return {Object} one of the handler
     * @alias module:Navigation.NavigationHandlerFactory.create
     * @see {@link GoogleMouseNavigationHandler} - Control the camera with mouse as Google movement
     * @see {@link KeyboardNavigationHandler} - Control the camera with the keyboard
     * @see {@link MouseNavigationHandler} - Control the camera with the mouse
     * @see {@link TouchNavigationHandler} - Control the camera with the smartphone
     * @throws {RangeError} Type not valid - a valid type is included in the list {@link HANDLER}
     */
    create: function (type, options) {
      var obj;

      switch (type) {
        case Constants.HANDLER.GoogleMouse:
          obj = new GoogleMouseNavigationHandler(options);
          break;

        case Constants.HANDLER.Keyboard:
          obj = new KeyboardNavigationHandler(options);
          break;

        case Constants.HANDLER.Mouse:
          obj = new MouseNavigationHandler(options);
          break;

        case Constants.HANDLER.Touch:
          obj = new TouchNavigationHandler(options);
          break;

        default:
          throw RangeError("The type " + type + " is not allowed, A valid type is included in the list Constants.HANDLER", "NavigationHandlerFactory.js");
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   * @name AbstractAnimation
   * @class
   * AbstractAnimation is an abstract class for all animation contexts which allow
   * an application to create an animation of the camera around the globe.
   * @implements {Animation}
   * @todo Describes here and link to the tutos about Animation
   */
  var AbstractAnimation = function () {
    this.startTime = -1;
    this.pauseTime = -1;
    this.renderContext = null;
  };
  /**
   * @function getRenderContext
   * @memberof AbstractAnimation#
   */


  AbstractAnimation.prototype.getRenderContext = function () {
    return this.renderContext;
  };
  /**
   * Unregisters animation.
   * @function _unregisterActive
   * @memberof AbstractAnimation#
   * @private
   */


  AbstractAnimation.prototype._unregisterActive = function () {
    var index = this.renderContext.activeAnimations.indexOf(this);

    if (index >= 0) {
      this.renderContext.activeAnimations.splice(index, 1);
    }
  };
  /**
   * @function getStatus
   * @memberof AbstractAnimation#
   */


  AbstractAnimation.prototype.getStatus = function () {
    if (this.startTime === -1) {
      return "STOPPED";
    } else {
      return this.pauseTime === -1 ? "RUNNING" : "PAUSED";
    }
  };
  /**
   * @function start
   * @memberof AbstractAnimation#
   */


  AbstractAnimation.prototype.start = function () {
    if (!this.renderContext) {
      return;
    }

    if (this.startTime === -1 || this.pauseTime !== -1) {
      var now = Date.now();

      if (this.startTime === -1) {
        this.startTime = now;
      } else {
        // resume after pause
        this.startTime += now - this.pauseTime;
        this.pauseTime = -1;
      } // Register animation as active


      this.renderContext.activeAnimations.push(this);
      this.renderContext.requestFrame();
    }
  };
  /**
   * @function pause
   * @memberof AbstractAnimation#
   */


  AbstractAnimation.prototype.pause = function () {
    if (!this.renderContext) {
      return;
    }

    if (this.startTime !== -1 && this.pauseTime === -1) {
      this.pauseTime = Date.now();

      this._unregisterActive(this);
    }
  };
  /**
   * @function stop
   * @memberof AbstractAnimation#
   */


  AbstractAnimation.prototype.stop = function () {
    this.startTime = -1;
    this.pauseTime = -1;

    if (this.onstop) {
      this.onstop();
    } // Unregister animation


    this._unregisterActive(this);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Segmented animation configuration
   * @typedef  {Object} AbstractAnimation.segmented_configuration
   * @param {float} duration - duration of the animation
   * @param {function} valueSetter - the function used to set the value.
   */

  /**
   * @name SegmentedAnimation
   * @class
   * SegmentedAnimation is an animation defined with segments.
   * Each segment has a [start,end] pair of 't' value and a [start,end] pair of
   * values that will be interpolated with the interpolator set on the segment.
   * When the animation runs, a t parameter is mapped to [0,1] according to
   * current time and animation duration.
   * The current segment is then looked up with that 't' value and used to interpolate
   * the animation's current value.
   * @augments AbstractAnimation
   * @param {AbstractAnimation.segmented_configuration} options - Configuration of the animation
   * @constructor
   * @memberof module:Animation
   */

  var SegmentedAnimation = function (options) {
    Utils.assert(typeof options.duration === "number" && typeof options.valueSetter === "function", "Missing required parameters in constructor", "SegmentedAnimation.js"); // Call ancestor constructor

    AbstractAnimation.prototype.constructor.call(this);
    this.segments = [];
    this.duration = options.duration;
    this.valueSetter = options.valueSetter;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractAnimation, SegmentedAnimation);
  /**
   * Creates a segment.
   * @param start t value at which the segment will be the current segment
   * @param startValue value at t=start
   * @param end value at which the segment will be the current segment
   * @param endValue value at t=end
   * @param interpolator
   * @constructor
   * @todo Create a tutorial with a simple SegmentedAnimation on Mars
   */

  var Segment = function (start, startValue, end, endValue, interpolator) {
    this.start = start;
    this.startValue = startValue;
    this.end = end;
    this.endValue = endValue;
    this.interpolator = interpolator;
  };
  /**************************************************************************************************************/

  /**
   * Adds a new segment to the animation.<br/>
   * start, end are 't' values at which the segment will be the current segment<br/>
   * startValue, endValue are animation values at 't'=start and 't'=end<br/>
   * interpolator is the function that will be called to interpolate bewteen startValue and endValue.
   * @function addSegment
   * @memberof SegmentedAnimation
   * @param {float} start - t value at which the segment will be the current segment
   * @param {float} startValue - value at t=start
   * @param {float} end - value at which the segment will be the current segment
   * @param {float} endValue - value at t=end
   * @param {Function} interpolator - interpolator function
   */


  SegmentedAnimation.prototype.addSegment = function (start, startValue, end, endValue, interpolator) {
    var count = this.segments.length;
    var index = 0;

    while (index < count && this.segments[index].end <= start) {
      index++;
    } // Insert new segment at position 'index'


    this.segments.splice(index, 0, new Segment(start, startValue, end, endValue, interpolator));
  };
  /**
   * Animation update method
   * @function update
   * @memberof SegmentedAnimation#
   * @param {float} now - Now
   */


  SegmentedAnimation.prototype.update = function (now) {
    var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);

    if (t >= 1) {
      // Set last value
      var lastIndex = this.segments.length - 1;
      this.valueSetter(this.segments[lastIndex].endValue);
      this.stop();
    } else {
      // Find current segment
      var count = this.segments.length;
      var index = 0;

      while (index < count && this.segments[index].end < t) {
        index++;
      }

      index = Math.min(index, count - 1); // Remap t between segment bounds

      t = Numeric.map01(t, this.segments[index].start, this.segments[index].end); // Interpolate value

      var value = this.segments[index].interpolator(t, this.segments[index].startValue, this.segments[index].endValue); // Use value

      this.valueSetter(value);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Path animation configuration
   * @typedef {Object} AbstractAnimation.path_configuration
   * @param {Array.<float[]>} coords - The path coordinates
   * @param {float} speed - The speed value
   * @param {Function} setter - the function used to set the value
   * @param {Globe} globe - the globe to clamp path animations on the terrain
   */

  /**
   * @name PathAnimation
   * @class
   * PathAnimation is an animation defined with a path.
   * @augments AbstractAnimation
   * @param {AbstractAnimation.path_configuration} options Configuration of the animation
   * @constructor
   * @memberof module:Animation
   * @todo Create a tutorial with a simple PathAnimation on Mars
   */

  var PathAnimation = function (options) {
    Utils.assert(Array.isArray(options.coords) && typeof options.speed === "number" && typeof options.setter === "function" && options.globe != null, "Missing required arguments in constructor", "PathAnimation.js");
    var i;
    var vec1, vec2;
    var dx, dy, dz;
    var node;
    var temp; // Call ancestor constructor

    AbstractAnimation.prototype.constructor.call(this);
    this.globe = options.globe;
    this.speed = options.speed * this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000;
    this.nodes = [];

    for (i = 0; i < options.coords.length; i++) {
      node = {
        position: this.globe.getCoordinateSystem().get3DFromWorld(options.coords[i]),
        velocity: null,
        distance: 0.0
      };
      this.nodes.push(node);

      if (i > 0) {
        dx = this.nodes[i].position[0] - this.nodes[i - 1].position[0];
        dy = this.nodes[i].position[1] - this.nodes[i - 1].position[1];
        dz = this.nodes[i].position[2] - this.nodes[i - 1].position[2];
        this.nodes[i - 1].distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      }
    }

    for (i = 1; i < options.coords.length - 1; i++) {
      vec1 = vec3.subtract(this.nodes[i + 1].position, this.nodes[i].position, vec3.create());
      vec2 = vec3.subtract(this.nodes[i - 1].position, this.nodes[i].position, vec3.create());
      vec3.normalize(vec1);
      vec3.normalize(vec2);
      this.nodes[i].velocity = vec3.subtract(vec1, vec2, vec3.create());
      vec3.normalize(this.nodes[i].velocity);
    } // Start velocity


    temp = vec3.subtract(this.nodes[1].position, this.nodes[0].position, vec3.create());
    vec3.scale(temp, 3 / this.nodes[0].distance);
    this.nodes[0].velocity = vec3.subtract(temp, this.nodes[1].velocity, vec3.create());
    vec3.scale(this.nodes[0].velocity, 0.5); // End velocity

    i = options.coords.length - 1;
    temp = vec3.subtract(this.nodes[i].position, this.nodes[i - 1].position, vec3.create());
    vec3.scale(temp, 3 / this.nodes[i - 1].distance);
    this.nodes[i].velocity = vec3.subtract(temp, this.nodes[i - 1].velocity, vec3.create());
    vec3.scale(this.nodes[i].velocity, 0.5);
    this.index = 0;
    this.currentDistance = 0;
    this.previousTime = -1;
    this.centerOffset = -0.2;
    this.altitudeOffset = 1000;
    var that = this;

    if (options.setter) {
      this.valueSetter = options.setter;
    } else {
      this.valueSetter = function (value, direction) {
        var up = vec3.normalize(value, vec3.create());
        var eye;

        if (options.globe) {
          var geoEye = options.globe.getCoordinateSystem().getWorldFrom3D(value);
          geoEye[2] = options.globe.getElevation(geoEye[0], geoEye[1]) + that.altitudeOffset;
          eye = options.globe.getCoordinateSystem().get3DFromWorld(geoEye);
        } else {
          eye = value;
          eye[2] += that.altitudeOffset;
        }

        var dirn = vec3.normalize(direction, vec3.create());
        var center = vec3.add(eye, dirn, vec3.create());
        vec3.add(center, vec3.scale(up, that.centerOffset, vec3.create()));
        mat4.lookAt(eye, center, up, that.renderContext.getViewMatrix());
      };
    }
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractAnimation, PathAnimation);
  /**************************************************************************************************************/

  /**
   * Sets the speed.
   * @function setSpeed
   * @memberof PathAnimation#
   * @param {float} val Speed
   */

  PathAnimation.prototype.setSpeed = function (val) {
    this.speed = parseFloat(val) * this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000.0;
  };
  /**
   * Returns the speed.
   * @function getSpeed
   * @memberof PathAnimation#
   * @return {float} Speed
   */


  PathAnimation.prototype.getSpeed = function () {
    return this.speed / (this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000.0);
  };
  /**
   * Sets the altitude offset.
   * @function setAltitudeOffset
   * @memberof PathAnimation#
   * @param {float} val Altitude offset
   */


  PathAnimation.prototype.setAltitudeOffset = function (val) {
    this.altitudeOffset = parseFloat(val);
  };
  /**
   * Returns the altitude offset.
   * @function getAltitudeOffset
   * @memberof PathAnimation#
   * @return {float} Altitude offset
   */


  PathAnimation.prototype.getAltitudeOffset = function () {
    return this.altitudeOffset;
  };
  /**
   * Sets the direction angle.
   * @function setDirectionAngle
   * @memberof PathAnimation#
   * @param {float} vertical Direction angle in degree
   */


  PathAnimation.prototype.setDirectionAngle = function (vertical) {
    this.centerOffset = Math.tan(Numeric.toRadian(parseFloat(vertical)));
  };
  /**
   * Starts the animation.
   * @function start
   * @memberof PathAnimation#
   */


  PathAnimation.prototype.start = function () {
    var previousStartTime = -1;

    if (this.pauseTime !== -1) {
      previousStartTime = this.startTime;
    }

    Animation.prototype.start.call(this);

    if (previousStartTime !== -1) {
      this.previousTime += this.startTime - previousStartTime;
    } else {
      this.previousTime = -1;
    }
  };
  /**
   * Updates the animation.
   * @function update
   * @memberof PathAnimation
   * @param {float} now the date now
   */


  PathAnimation.prototype.update = function (now) {
    if (this.previousTime === -1) {
      this.index = 0;
      this.currentDistance = 0;
    } else {
      this.currentDistance += (now - this.previousTime) * this.speed;
    }

    this.previousTime = now;

    while (this.currentDistance >= this.nodes[this.index].distance && this.index < this.nodes.length - 1) {
      this.currentDistance -= this.nodes[this.index].distance;
      this.index = this.index + 1;
    }

    if (this.index < this.nodes.length - 1) {
      var t = this.currentDistance / this.nodes[this.index].distance;
      var startPos = this.nodes[this.index].position;
      var endPos = this.nodes[this.index + 1].position;
      var startVel = vec3.scale(this.nodes[this.index].velocity, this.nodes[this.index].distance, vec3.create());
      var endVel = vec3.scale(this.nodes[this.index + 1].velocity, this.nodes[this.index].distance, vec3.create());
      var position = Numeric.cubicInterpolation(t, startPos, startVel, endPos, endVel);
      var direction = Numeric.cubicInterpolationDerivative(t, startPos, startVel, endPos, endVel);
      this.valueSetter(position, direction);
    } else if (this.index === this.nodes.length - 1) {
      this.valueSetter(this.nodes[this.index].position, this.nodes[this.index].velocity);
    } else {
      this.stop();
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @constant
   * @type {float}
   * @default
   */

  const EPSILON = 0.1;
  /**
   * Default panFactor value
   * @constant
   * @type {number}
   * @default
   */

  const PAN_FACTOR = 0.95;
  /**
   * Default rotateFactor value
   * @constant
   * @type {number}
   * @default
   */

  const ROTATE_FACTOR = 0.95;
  /**
   * Default zoomFactor value
   * @constant
   * @type {number}
   * @default
   */

  const ZOOM_FACTOR = 0.5;
  /**
   * Inertia animation configuration
   * @typedef {Object} AbstractAnimation.inertia_configuration
   * @property {Navigation} nav - Navigation object that applies the transformations.
   * @property {float} [panFactor=0.95] - Pan Factor which is included in [0..1]. - 1 is sensible to the pan
   * @property {float} [zoomFactor=0.50] - Zoom Factor which is included in [0..1]. - 1 is sensible to the zoom
   * @property {float} [rotateFactor=0.95] - Rotate Factor which is included in [0..1]. - 1 is sensible to the rotation
   */

  /**
   * @name InertiaAnimation
   * @class
   * Animation simulating inertia for camera's navigation.
   * Inertia is its tendency to retain its velocity: in the absence of external influence, the camera's motion
   * persists in an uniform rectilinear motion.
   * @augments AbstractAnimation
   * @param {AbstractAnimation.inertia_configuration} options Configuration of the Inertia animation
   * @constructor
   * @memberof module:Animation
   */

  var InertiaAnimation = function (options) {
    Utils.assert(options.nav != null, "nav is required in constructor", "InertiaAnimation.js");
    AbstractAnimation.prototype.constructor.call(this);
    this.panFactor = options.hasOwnProperty("panFactor") ? options.panFactor : PAN_FACTOR;
    this.rotateFactor = options.hasOwnProperty("rotateFactor") ? options.rotateFactor : ROTATE_FACTOR;
    this.zoomFactor = options.hasOwnProperty("zoomFactor") ? options.zoomFactor : ZOOM_FACTOR;
    this.type = null;
    this.dx = 0;
    this.dy = 0;
    this.navigation = options.nav;
    this.renderContext = options.nav.getRenderContext();
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractAnimation, InertiaAnimation);
  /**************************************************************************************************************/

  /**
   * Updates the inertia.
   * @function update
   * @memberof InertiaAnimation#
   */

  InertiaAnimation.prototype.update = function (now) {
    var hasToStop = false;

    switch (this.type) {
      case "pan":
        this.navigation.pan(this.dx, this.dy);
        this.dx *= this.panFactor;
        this.dy *= this.panFactor;
        hasToStop = Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
        break;

      case "rotate":
        this.navigation.rotate(this.dx, this.dy);
        this.dx *= this.rotateFactor;
        this.dy *= this.rotateFactor;
        hasToStop = Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
        break;

      case "zoom":
        this.navigation.zoom(this.dx);
        this.dx *= this.zoomFactor;
        hasToStop = Math.abs(this.dx) < EPSILON;
        break;
    }

    this.navigation.getRenderContext().requestFrame();

    if (hasToStop) {
      this.stop();
    }
  };
  /**************************************************************************************************************/

  /**
   * Launches the animation.
   * @function launch
   * @param {string} type Type of inertia
   * <ul>
   *   <li>pan</li>
   *   <li>rotate</li>
   *   <li>zoom</li>
   * </ul>
   * @param {int} dx x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
   * @param {int} dy x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
   * @memberof InertiaAnimation#
   */


  InertiaAnimation.prototype.launch = function (type, dx, dy) {
    // Set first value
    this.type = type;
    this.dx = dx;
    this.dy = dy;
    this.start();
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Interpolated animation configuration
   * @typedef {Object} AbstractAnimation.interpolated_configuration
   * @property {float} startValue - Starting point of the interpolation.
   * @property {float} endValue - Ending point of the interpolation.
   * @property {float} duration - Duration of the animation in seconds
   * @property {Function} interpolationFunction-  Interpolation function
   * @property {Function} setFunction - Setter of the Interpolation function
   */

  /**
   * @name InterpolatedAnimation
   * @class
   * Generic animation to interpolate arbitrary values
   * The animation will interpolate between startValue and endValue, using the
   * interpolateFunction(t, startValue, endValue) (t [0,1])
   * The interpolated value is then given to the setFunction(value)
   * @augments AbstractAnimation
   * @param {AbstractAnimation.interpolated_configuration} options Configuration of the InterpolatedAnimation
   * @constructor
   * @memberof module:Animation
   * @todo Create a tutorial with a simple InterpolatedAnimation on Mars
   */

  var InterpolatedAnimation = function (options) {
    Utils.assert(typeof options.startValue === "number" && typeof options.endValue === "number" && typeof options.duration === "number" && typeof options.interpolationFunction === "function" && typeof options.setFunction === "function", "Missing required arguments in constructor", "InterpolatedAnimation.js"); // Call ancestor constructor

    AbstractAnimation.prototype.constructor.call(this);
    this.values = [[0.0, options.startValue], [1.0, options.endValue]];
    this.duration = options.duration;
    this.interpolationFunction = options.interpolationFunction;
    this.setFunction = options.setFunction;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractAnimation, InterpolatedAnimation);
  /**************************************************************************************************************/

  /**
   * Adds a new value to the animation.
   * @function addValue
   * @memberof InterpolatedAnimation#
   * @param {float} t Value at [0,1]
   * @param {float} value Value to reach
   */

  InterpolatedAnimation.prototype.addValue = function (t, value) {
    Utils.assert(t >= 0 && t <= 1, "t must be in [0,1] when using addValue method", "InterpolatedAnimation.js");
    Utils.assert(typeof value === "number", "value must be a number when using addValue method", "InterpolatedAnimation.js");
    var count = this.values.length;
    var upper = 0;

    while (upper < count && this.values[upper][0] < t) {
      upper++;
    } // Insert new value at position 'upper'


    this.values.splice(upper, 0, [t, value]);
  };
  /**
   * Starts the animation.
   * @function start
   * @memberof InterpolatedAnimation#
   */


  InterpolatedAnimation.prototype.start = function () {
    Animation.prototype.start.call(this);
    this.setFunction(this.startValue); //TODO this.startValue is a bug ?
  };
  /**
   * Stops the animation.
   * @function stop
   * @memberof InterpolatedAnimation
   */


  InterpolatedAnimation.prototype.stop = function () {
    Animation.prototype.stop.call(this);
    this.setFunction(this.endValue); //TODO this.endValue is a bug ?
  };
  /**
   * Updates the Animation.
   * @function udate
   * @memberof InterpolatedAnimation
   * @param {float} now Now
   */


  InterpolatedAnimation.prototype.update = function (now) {
    var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);

    if (t >= 1) {
      this.stop();
      return;
    } // Find upper and lower bounds


    var count = this.values.length;
    var upper = 0;

    while (upper < count && this.values[upper][0] < t) {
      upper++;
    }

    upper = Math.min(upper, count - 1);
    var lower = Math.max(0, upper - 1); // Remap t between lower and upper bounds

    t = Numeric.map01(t, this.values[lower][0], this.values[upper][0]); // Interpolate value

    var value = this.interpolationFunction(t, this.values[lower][1], this.values[upper][1]); // Use interpolated value

    this.setFunction(value);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var AnimationFactory = {
    /**
     * Factory to create an animation.
     *
     * Creates an animation based on :
     * <ul>
     *     <li>the animation type {@link ANIMATION},</li>
     *     <li>the options for the specific animation</li>
     * </ul>
     *
     * Severals animations can be created :
     * <ul>
     *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}</li>
     *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation}</li>
     *     <li>{@link module:Animation.PathAnimation PathAnimation}</li>
     *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation}</li>
     * </ul>
     * @param {ANIMATION} type - Type of animation.
     * @param {AbstractAnimation.inertia_configuration|AbstractAnimation.interpolated_configuration|AbstractAnimation.path_configuration|AbstractAnimation.segmented_configuration} options - See the options for each animation for further information
     * @return {AbstractAnimation} - the interface to handle an animation
     * @throws {RangeError} Type not valid - a valid type is included in the list {@link ANIMATION}
     * @alias module:Animation.AnimationFactory.create
     * @see {@link module:Animation.InertiaAnimation InertiaAnimation} Animation simulating inertia for camera's navigation
     * @see {@link module:Animation.InterpolatedAnimation InterpolatedAnimation} Generic animation to interpolate arbitrary values
     * @see {@link module:Animation.PathAnimation PathAnimation} Defines an animation based on a path
     * @see {@link module:Animation.SegmentedAnimation SegmentedAnimation} Defines an animation based on segments
     *
     */
    create: function (type, options) {
      var obj;

      switch (type) {
        case Constants.ANIMATION.Inertia:
          obj = new InertiaAnimation(options);
          break;

        case Constants.ANIMATION.Interpolated:
          obj = new InterpolatedAnimation(options);
          break;

        case Constants.ANIMATION.Path:
          obj = new PathAnimation(options);
          break;

        case Constants.ANIMATION.Segmented:
          obj = new SegmentedAnimation(options);
          break;

        default:
          throw RangeError("The type " + type + " is not allowed, A valid type is included in the list Constants.ANIMATION", "AnimationFactory.js");
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Navigation configuration
   * @typedef {Object} AbstractNavigation.configuration
   * @property {boolean} [inertia = false] - Animation simulating inertia for camera's navigation
   * @property {AbstractAnimation.inertia_configuration} inertiaAnimation - Inertia Animation is used when <i>inertia</i> is true
   * @property {Object[]} [handlers = [{@link module:Navigation.MouseNavigationHandler MouseNavigationHandler},{@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler}[,{@link module:Navigation.TouchNavigationHandler TouchNavigationHandler}]]
   * @property {AbstractNavigation.mouse_configuration} [mouse] - Mouse navigation configuration when <i>handlers</i> is not defined
   * @property {AbstractNavigation.keyboard_configuration} [keyboard] - Keyboard navigation configuration when <i>handlers</i> is not defined
   * @property {boolean} [isMobile = false] - {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} configuration when <i>handlers</i> is not defined, sets to true this parameter to support mobile device
   */

  /**
   * @name AbstractNavigation
   * @class
   * The active navigation object can normally be obtained from the {@link Mizar#getNavigation} method of the Mizar instance.
   * Client implementations should not normally instantiate this class directly.
   * @augments Event
   * @param {NAVIGATION} type - type of navigation
   * @param {AbstractContext} ctx - context
   * @param {AbstractNavigation.configuration} [options = {}] - options for navigation
   * @constructor
   * @see {@link module:Navigation.NavigationHandlerFactory NavigationHandlerFactory} the possible handlers
   * @see {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler} for its options when it is set by default
   * @see {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} for its options when it is set by default
   * @see {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} for its options when isMobile is set to true
   * @implements {Navigation}
   *
   */

  var AbstractNavigation = function (type, ctx, options) {
    Event.prototype.constructor.call(this);
    this.type = type;
    this.ctx = ctx;
    this.renderContext = this.ctx.getRenderContext();
    this.renderContext.cameraUpdateFunction = this.update.bind(this);
    this.options = options || {};
    this.options.isMobile = ctx.getMizarConfiguration().isMobile;

    if (this.options.isMobile === true) {
      this.initTouchNavigation();
    } // Create default handlers if none are created in options


    this.handlers = _createHandlers.call(this, this.options); // Inertia effect

    this.inertia = _addInertiaEffect.call(this, this.options); // ZoomTo animation

    this.zoomToAnimation = null; // Automatically start

    this.start();
  };
  /**
   * Adds inertia effect
   * @param {Object} options
   * @returns {InertiaAnimation|null} inertia
   * @private
   */


  function _addInertiaEffect(options) {
    var inertia;

    if (options.inertia) {
      var inertiaOptions = options.inertiaAnimation || {};
      inertiaOptions.nav = this;
      inertia = AnimationFactory.create(Constants.ANIMATION.Inertia, inertiaOptions);
      const self = this;

      inertia.onstop = function () {
        self.doneMoving();
      };
    } else {
      inertia = null;
    }

    return inertia;
  }
  /**
   * Creates handlers :
   * <ul>
   *     <li>Provided in options</li>
   *     <li>Create default handlers</li>
   * </ul>
   * @param {Object} options
   * @returns {Object[]} handlers
   * @private
   */


  function _createHandlers(options) {
    var handlers; // Create default handlers if none are created in options

    if (options.handlers) {
      handlers = options.handlers;
    } else {
      // Use mouse & keyboard as default handlers
      handlers = _addDefaultHandlers.call(this, options);
    }

    return handlers;
  }
  /**
   * Add default handlers :
   * <ul>
   *     <li>MouseNavigationHandler</li>
   *     <li>KeyboardNavigationHandler</li>
   *     <li>TouchNavigationHandler is isMobile is true</li>
   * </ul>
   * @param {Object} options - options
   * @returns {Object[]} An array of handlers
   * @private
   */


  function _addDefaultHandlers(options) {
    var defaultHandlers = [NavigationHandlerFactory.create(Constants.HANDLER.Mouse, options.mouse || null), NavigationHandlerFactory.create(Constants.HANDLER.Keyboard, options.keyboard || null)];

    if (options.isMobile) {
      defaultHandlers.push(NavigationHandlerFactory.create(Constants.HANDLER.Touch, options.touch || null));
    }

    return defaultHandlers;
  }
  /**************************************************************************************************************/


  Utils.inherits(Event, AbstractNavigation);
  /**************************************************************************************************************/

  /**
   * Initializes the touch navigation handler.
   * @function initTouchNavigation
   * @memberof AbstractContext#
   */

  AbstractNavigation.prototype.initTouchNavigation = function () {
    this.options.touch = {
      inversed: this.ctx.globe.isSky(),
      zoomOnDblClick: true
    };
    var self = this;
    window.addEventListener("orientationchange", function () {
      self.ctx.refresh();
    }, false);
  };
  /**
   * Returns the {@link TYPE type} of navigation.
   * The type can take one of the following value : AstroNavigation, FlatNavigation, PlanetNavigation
   * @function getType
   * @return {string} the name of the navigation class, which is used
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.getType = function () {
    return this.type;
  };
  /**
   * Returns the navigation's options given at the initialisation.
   * @function getOptions
   * @return {Object} Options
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.getOptions = function () {
    return this.options;
  };
  /**
   * Starts the navigation.
   * @function start
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.start = function () {
    // Install handlers
    for (var i = 0; i < this.handlers.length; i++) {
      this.handlers[i].install(this);
    }
  };
  /**
   * Stops the navigation.
   * @function stop
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.stop = function () {
    // Uninstall handlers
    for (var i = 0; i < this.handlers.length; i++) {
      this.handlers[i].uninstall();
    }
  };
  /**
   * Stops the animations.
   * @function stopAnimations
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.stopAnimations = function () {
    if (this.inertia) {
      this.inertia.stop();
    }

    if (this.zoomToAnimation) {
      this.zoomToAnimation.stop();
      this.zoomToAnimation = null;
    }
  };
  /**
   * Returns the field of view in decimal degree.
   * @function getFov
   * @return {float[]} the Field of view [fov along width, fov along height]
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.getFov = function () {
    return [this.renderContext.getFov(), this.renderContext.getFov()];
  };
  /**
   * Moves up vector.
   * @function moveUpTo
   * @memberof AbstractNavigation#
   * @param {float[]} vec Vector
   * @param {int} [duration = 1000] - Duration of animation in milliseconds
   * @abstract
   */


  AbstractNavigation.prototype.moveUpTo = function (vec, duration) {
    throw new SyntaxError("AbstractNavigation.js: moveUpTo not implemented");
  };
  /**
   * Returns the center of the field of view.
   * @function getCenter
   * @return {float[]} the center in decimal degree of the field of view [longitude, latitude]
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.getCenter = function () {
    return this.ctx.getLonLatFromPixel(this.renderContext.getCanvas().width * 0.5, this.renderContext.getCanvas().height * 0.5);
  };
  /**
   * Rotates the camera.
   * @function rotate
   * @param {float} dx Window delta x
   * @param {float} dy Window delta y
   * @abstract
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.rotate = function (dx, dy) {
    throw new SyntaxError("AbstractNavigation.js: rotate is not implemented");
  };
  /**
   * Pans the camera to a direction up/down or left/right with the same distance from the object
   * @function pan
   * @param {float} dx Window direction left/right
   * @param {float} dy Window direction up/down
   * @abstract
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.pan = function (dx, dy) {
    throw new SyntaxError("AbstractNavigation.js: pan is not implemented");
  };
  /**
   * Applies zooming.
   * @function zoom
   * @param {float} delta Delta zoom
   * @param {float} scale Scale
   * @abstract
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.zoom = function (delta, scale) {
    throw new SyntaxError("AbstractNavigation.js: zoom is not implemented");
  };
  /**
   * Zooms to a 2D position (longitude, latitude).
   * @function zoomTo
   * @param {float[]} geoPos - spatial position in decimal degree [longitude, latitude]
   * @param {Object} options - options for zoomTo
   * @abstract
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.zoomTo = function (geoPos, options) {
    throw new SyntaxError("AbstractNavigation.js: zoomTo is not implemented");
  };
  /**
   * Computes the view matrix
   * @function computeViewMatrix
   * @memberof AbstractNavigation#
   * @abstract
   */


  AbstractNavigation.prototype.computeViewMatrix = function () {
    throw new SyntaxError("AbstractNavigation.js: computeViewMatrix not implemented");
  };
  /**
   * Callback at the end of animation (when stop method is called).
   * @callback navigationCallback
   */

  /**
   * Basic animation from current view matrix to the given one
   * @function toViewMatrix
   * @param {Object[]} mat Destination view matrix (array of 16)
   * @param {int} fov Final zooming fov in degrees
   * @param {int} duration Duration of animation in milliseconds
   * @param {navigationCallback} callback Callback at the end of animation
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.toViewMatrix = function (mat, fov, duration, callback) {
    var navigation = this;
    var vm = this.renderContext.getViewMatrix();
    var srcViewMatrix = mat4.toMat3(vm);
    var srcQuat = quat4.fromRotationMatrix(srcViewMatrix);
    var destViewMatrix = mat4.toMat3(mat);
    var destQuat = quat4.fromRotationMatrix(destViewMatrix);
    var destFov = fov || 45;
    duration = duration || 1000; // Animate rotation matrix(with quaternion support), translation and fov

    var startValue = [srcQuat, [vm[12], vm[13], vm[14]], navigation.getRenderContext().getFov()];
    var endValue = [destQuat, [mat[12], mat[13], mat[14]], destFov];
    var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: duration,
      valueSetter: function (value) {
        // Update rotation matrix
        var newRotationMatrix = quat4.toMat4(value[0]); // Need to transpose the new rotation matrix due to bug in glMatrix

        var viewMatrix = mat4.transpose(newRotationMatrix); // Update translation

        viewMatrix[12] = value[1][0];
        viewMatrix[13] = value[1][1];
        viewMatrix[14] = value[1][2]; // sets the new matrix

        navigation.renderContext.setViewMatrix(viewMatrix); // Update fov

        navigation.renderContext.setFov(value[2]);
        navigation.renderContext.requestFrame();
      }
    }); // Add segment

    animation.addSegment(0.0, startValue, 1.0, endValue, function (t, a, b) {
      var pt = Numeric.easeOutQuad(t);
      var resQuat = quat4.create();
      quat4.slerp(a[0], b[0], pt, resQuat);
      var resTranslate = vec3.create();
      vec3.lerp(a[1], b[1], pt, resTranslate);
      var resFov = Numeric.lerp(pt, a[2], b[2]);
      return [resQuat, // quaternions
      resTranslate, // translate
      resFov // fov
      ];
    });

    animation.onstop = function () {
      if (callback) {
        callback();
      }
    };

    this.ctx.addAnimation(animation);
    animation.start();
  };
  /**
   * Returns the rendering context.
   * @function getRenderContext
   * @returns {RenderContext} the rendering context
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.getRenderContext = function () {
    return this.renderContext;
  };
  /**
   * Sets the rendering context
   * @function setRenderContext
   * @param {RenderContext} renderContext - the rendering context to set
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.setRenderContext = function (renderContext) {
    this.renderContext = renderContext;
  };
  /**
   * Destroys the navigation.
   * @function destroy
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.destroy = function () {
    this.renderContext.cameraUpdateFunction = null;
    this.type = null;
    this.options = null;
    this.zoomToAnimation = null;
    this.stop();
    this.ctx = null;
    this.renderContext = null;
  };
  /**
   * Update the navigation values if computations are needed.
   * @function update
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.update = function () {// Does nothing by default
  };
  /**
   * Called when stopping inertia.
   * @function doneMoving
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.doneMoving = function () {
    this.donePanning();
    this.doneRotating();
  };
  /**
   * Called by mouse and keyboard handler when pan interactions are finished.
   * This is useful to, e.g.,  fetch the new focus point of the navigator.
   * @function donePanning
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.donePanning = function () {// Does nothing by default
  };
  /**
   * Called by mouse and keyboard handler when rotate interactions are finished.
   * This is useful to, e.g.,  fetch the new focus point of the navigator.
   * @function doneRotating
   * @memberof AbstractNavigation#
   */


  AbstractNavigation.prototype.doneRotating = function () {// Does nothing by default
  };

  AbstractNavigation.prototype.startInteraction = function (x, y) {// Does nothing by default
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Flat navigation configuration
   * @typedef {AbstractNavigation.configuration} AbstractNavigation.planet_configuration
   * @property {float[]} [initTarget=[0, 0, 3.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
   * at initialisation. distance in meter is optional.
   * @property {int} [minDistance=0] the minimum distance sets to 60 Km by default or options.initTarget[2]
   * when this one is inferior to options.minDistance
   * @property {int} [maxDistance=3*RADIUS_PLANET] the maximum distance sets to 3*RADIUS_PLANET by default or
   * options.initTarget[2] when this one is superior to options.maxDistance
   * @property {boolean} [updateViewMatrix=false] indicating if view matrix must be updated on initialization.
   */

  /**
   * Duration of animation in milliseconds for the zoom_to function.
   * @type {number}
   */

  const DEFAULT_DURATION_ZOOM_TO = 5000.0;
  /**
   * Duration of animation in milliseconds to align the camera with the north.
   * @type {number}
   */

  const DEFAULT_DURATION_NORTH = 1000.0;
  /**
   * Min tilt in decimal degree.
   * @type {number}
   */

  const MIN_TILT = 10.0;
  /**
   * Max tilt in decimal degree.
   * @type {number}
   */

  const MAX_TILT = 90.0;
  /**
   * Default tilt in decimal degree.
   * @type {number}
   */

  const DEFAULT_TILT = 90.0;
  /**
   * Min heading value in decimal degree.
   * @type {number}
   */

  const MIN_HEADING = 0.0;
  /**
   * Max heading value in decimal degee.
   * @type {number}
   */

  const MAX_HEADING = 360.0;
  /**
   * Default heading in decimal degree.
   * @type {number}
   */

  const DEFAULT_HEADING = MIN_HEADING;
  /**
   * Heading difference between two successive rotation (in degree) of the camera
   * @type {number}
   */

  const DELTA_HEADING = 0.05;
  /**
   * Tilt difference between two successive rotation (in degree) of the camera
   * @type {number}
   */

  const DELTA_TILT = 0.05;
  /**
   * @name PlanetNavigation
   * @augments AbstractNavigation
   * @class
   * <table border="0">
   *     <tr>
   *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
   *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
   *     </tr>
   * </table>
   * At initialisation, the distance of the camera is maxDistance
   * @param {PlanetContext} ctx -  Planet context
   * @param {AbstractNavigation.planet_configuration} options - Planet navigation configuration
   * @memberof module:Navigation
   */

  var PlanetNavigation = function (ctx, options) {
    AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.PlanetNavigation, ctx, options);
    Object.defineProperties(this, {
      scale: {
        get: function () {
          return this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
        }
      },
      distance: {
        get: function () {
          const value = this._distance * this.scale;
          return value;
        },
        set: function (v) {
          const value = v / this.scale;
          this._distance = value;
        }
      },
      targetHeight: {
        get: function () {
          return this.ctx.getElevation(this.geoCenter[0], this.geoCenter[1]);
        }
      },
      cameraHeight: {
        get: function () {
          const tilt = Numeric.toRadian(90 - this.tilt);
          const c = Math.cos(tilt);
          const d = c * this._distance;
          return d + this.targetHeight;
        }
      },
      eye: {
        get: function () {
          return [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
        }
      },
      geoEye: {
        get: function () {
          return this.ctx.getCoordinateSystem().from3DToGeo(this.eye);
        }
      }
    });
    const geoide = this.ctx.getCoordinateSystem().getGeoide(); // Default values for min and max distance (in meter)

    const minDistance = this.options.minDistance || 50;
    const maxDistance = this.options.maxDistance || 3.0 * geoide.getRealPlanetRadius(); // Scale min and max distance from meter to internal ratio

    this.minDistance = minDistance * geoide.getHeightScale();
    this.maxDistance = maxDistance * geoide.getHeightScale(); // Initialize the navigation

    this.geoCenter = [0.0, 0.0, 0.0];
    this.heading = DEFAULT_HEADING;
    this.tilt = DEFAULT_TILT;
    this._distance = Number.NaN;
    this.offset = 0.0; // Coordinate of the North in XYZ frame

    this.up = [0.0, 0.0, 1.0];
    this.inverseViewMatrix = mat4.create();
    this.lastMousePosition = null;
    var updateViewMatrix = this.options.hasOwnProperty("updateViewMatrix") ? this.options.updateViewMatrix : true;

    _setInitTarget.call(this, this.options.initTarget); // Update the view matrix if needed(true by default)


    if (updateViewMatrix) {
      this.computeViewMatrix();
    }
  };
  /**
   * Defines the position where the camera looks at and the distance of the camera regarding to the planet's surface
   * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
   * @private
   */


  function _setInitTarget(initTarget) {
    if (initTarget) {
      this.geoCenter[0] = initTarget[0];
      this.geoCenter[1] = initTarget[1];
      this.distance = initTarget.length === 3 ? initTarget[2] * this.ctx.getCoordinateSystem().getGeoide().getHeightScale() : this.distance;

      if (this.distance < this.minDistance) {
        this.minDistance = this.distance;
      }

      if (this.distance > this.maxDistance) {
        this.maxDistance = this.distance;
      }
    }
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractNavigation, PlanetNavigation);
  /**************************************************************************************************************/

  /**
   * Returns the center of the navigation.
   * @function getCenter
   * @memberof PlanetNavigation#
   * @return {float[]}
   */

  PlanetNavigation.prototype.getCenter = function () {
    var center = AbstractNavigation.prototype.getCenter.call(this);

    if (center == null) {
      center = this.geoCenter;
    }

    return center;
  };
  /**
   * Saves the current navigation state.
   * @function save
   * @memberof PlanetNavigation#
   * @return {{geoCenter: *, heading: *, tilt: *, distance: *}} a JS object containing the navigation state
   */


  PlanetNavigation.prototype.save = function () {
    return {
      geoCenter: this.geoCenter,
      heading: this.heading,
      tilt: this.tilt,
      distance: this.distance
    };
  };
  /**
   * Restores the navigation state.
   * @function restore
   * @memberof PlanetNavigation#
   * @param {Object} state - a JS object containing the navigation state
   * @param {float[]} state.geoCenter - Target of the camera (longitude, latitude)
   * @param state.heading
   * @param {float} state.tilt - tilt of the camera in decimal degree
   * @param {float} state.distance - Distance from the surface of the globe in meter.
   */


  PlanetNavigation.prototype.restore = function (state) {
    this.geoCenter = state.geoCenter;
    this.heading = state.heading;
    this.tilt = state.tilt;
    this.distance = state.distance;
    this.computeViewMatrix();
  };
  /**
   * Zoom to a geographic position
   * @function zoomTo
   * @memberof PlanetNavigation#
   * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
   * @param {Object} [options] - Options
   * @param {int} [options.distance] - Final zooming distance in meters - if not set, this is the current distance
   * @param {int} [options.duration = 5000] - Duration of animation in milliseconds
   * @param {int} [options.tilt = 90] - Defines the tilt at the end of animation
   * @param {int} [options.heading] - Defines the heading at the end of animation. By default, the current heading is conserved
   * @param {navigationCallback} [options.callback] - Callback at the end of animation
   */


  PlanetNavigation.prototype.zoomTo = function (geoPos, options) {
    var navigation = this;
    var destDistance = options && options.hasOwnProperty("distance") ? options.distance : this.distance / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
    var duration = options && options.hasOwnProperty("duration") ? options.duration : DEFAULT_DURATION_ZOOM_TO;
    var destTilt = options && options.hasOwnProperty("tilt") ? options.tilt : this.tilt;
    var destHeading = options && options.hasOwnProperty("heading") ? options.heading : this.heading;
    var shortestPath = Numeric.shortestPath180(this.geoCenter[0], geoPos[0]);
    var shortestHeading = Numeric.shortestPath180(this.heading, destHeading); // Create a single animation to animate geoCenter, distance and tilt

    var startValue = [shortestPath[0], // longitude
    this.geoCenter[1], // latitude
    this.distance, // distance from ground
    this.tilt, // tilt
    shortestHeading[0] // heading
    ];
    var endValue = [shortestPath[1], // longitude
    geoPos[1], // latitude
    destDistance * this.ctx.getCoordinateSystem().getGeoide().getHeightScale(), // distance from ground
    destTilt, // tilt
    shortestHeading[1] // heading
    ];
    this.zoomToAnimation = new AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: duration,
      valueSetter: function (value) {
        navigation.geoCenter[0] = value[0] > 180 ? value[0] - 360 : value[0];
        navigation.geoCenter[1] = value[1];
        navigation.distance = value[2];
        navigation.tilt = value[3];
        navigation.heading = value[4] > 180 ? value[4] - 360 : value[4];
        navigation.computeViewMatrix();
      }
    }); // Compute a max altitude for the animation

    var worldStart = this.ctx.getCoordinateSystem().get3DFromWorld(this.geoCenter);
    var worldEnd = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
    var vec = vec3.subtract(worldStart, worldEnd);
    var len = vec3.length(vec);
    var canvas = this.ctx.getRenderContext().canvas;
    var minFov = Math.min(Numeric.toRadian(45.0), Numeric.toRadian(45.0 * canvas.width / canvas.height));
    var maxAltitude = len * 0.5 / Math.tan(minFov * 0.5);

    if (maxAltitude > this.distance) {
      // Compute the middle value
      var midValue = [(startValue[0] + endValue[0]) * 0.5, (startValue[1] + endValue[1]) * 0.5, maxAltitude, (startValue[3] + startValue[3]) * 0.5, (startValue[4] + startValue[4]) * 0.5]; // Add two segments

      this.zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function (t, a, b) {
        var pt = Numeric.easeInQuad(t);
        var dt = Numeric.easeOutQuad(t);
        var ht = Numeric.easeOutQuad(t);
        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
        Numeric.lerp(dt, a[2], b[2]), // distance
        Numeric.lerp(t, a[3], b[3]), // tilt
        Numeric.lerp(ht, a[4], b[4]) // heading
        ];
      });
      this.zoomToAnimation.addSegment(0.5, midValue, 1.0, endValue, function (t, a, b) {
        var pt = Numeric.easeOutQuad(t);
        var dt = Numeric.easeInQuad(t);
        var ht = Numeric.easeInQuad(t);
        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
        Numeric.lerp(dt, a[2], b[2]), // distance
        Numeric.lerp(t, a[3], b[3]), // tilt
        Numeric.lerp(ht, a[4], b[4]) // heading
        ];
      });
    } else {
      // Add only one segments
      this.zoomToAnimation.addSegment(0.0, startValue, 1.0, endValue, function (t, a, b) {
        var pt = Numeric.easeOutQuad(t);
        var dt = Numeric.easeInQuad(t);
        var ht = Numeric.easeInQuad(t);
        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
        Numeric.lerp(dt, a[2], b[2]), // distance
        Numeric.lerp(t, a[3], b[3]), // tilt
        Numeric.lerp(ht, a[4], b[4]) // heading
        ];
      });
    }

    var self = this;

    this.zoomToAnimation.onstop = function () {
      if (options && options.callback) {
        options.callback();
      }

      self.zoomToAnimation = null;
      self.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, destDistance);
      self.updateGeoCenter();
    };

    this.ctx.addAnimation(this.zoomToAnimation);
    this.zoomToAnimation.start();
  };
  /**
   * Applies to rotation matrix
   * @function applyLocalRotation
   * @memberof Navigation#
   */


  PlanetNavigation.prototype.applyLocalRotation = function (matrix) {
    mat4.rotate(matrix, Numeric.toRadian(this.heading), [0.0, 0.0, 1.0]);
    mat4.rotate(matrix, Numeric.toRadian(90 - this.tilt), [1.0, 0.0, 0.0]);
  };
  /**
   * Computes the view matrix
   * @function computeViewMatrix
   * @memberof Navigation#
   */


  PlanetNavigation.prototype.computeViewMatrix = function () {
    this.computeInverseViewMatrix();
    mat4.inverse(this.inverseViewMatrix, this.renderContext.getViewMatrix());
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
    this.renderContext.requestFrame();
  };
  /**
   * Compute the inverse view matrix
   * @function computeInverseViewMatrix
   * @memberof PlanetNavigation#
   */


  PlanetNavigation.prototype.computeInverseViewMatrix = function () {
    this.ctx.getCoordinateSystem().getLHVTransform(this.geoCenter, this.inverseViewMatrix);
    this.applyLocalRotation(this.inverseViewMatrix);
    mat4.translate(this.inverseViewMatrix, [0.0, 0.0, this.distance]);
  };
  /**
   * Zoom to the current observed location
   * @function zoom
   * @memberof PlanetNavigation#
   * @param {float} delta Delta zoom
   * @param {float} scale Scale
   */


  PlanetNavigation.prototype.zoom = function (delta, scale, x, y) {
    const oldDistance = this.distance;

    if (scale) {
      this.distance *= scale;
    } else {
      this._distance *= 1 + delta * 0.1;
    }

    this.distance = Math.max(Math.min(this.distance, this.maxDistance), this.minDistance);

    if (x && y) {
      // Recompute the geo position
      this.computeInverseViewMatrix();
      const eye = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
      const center = vec3.create();
      this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, center);
      const centerDir = vec3.create();
      vec3.subtract(center, eye, centerDir);
      vec3.normalize(centerDir);
      const pos = vec3.create();
      const geoPos = this.ctx.globe.getLonLatFromPixel(x, y);
      this.ctx.getCoordinateSystem().fromGeoTo3D(geoPos, pos);
      const zoomDir = vec3.create();
      vec3.subtract(pos, eye, zoomDir);
      vec3.normalize(zoomDir);
      vec3.scale(zoomDir, oldDistance - this.distance);
      const newEye = vec3.create();
      vec3.add(eye, zoomDir, newEye);
      var r = new Ray(newEye, centerDir);
      const newCenter = this.ctx.globe.computeIntersection(r);

      if (newCenter != null) {
        this.geoCenter = newCenter;
      }
    } // compute the view matrix with new values


    this.computeViewMatrix();
  };
  /**
   * Pans the camera
   * @function pan
   * @memberof PlanetNavigation#
   * @param {int} dx Window delta x
   * @param {int} dy Window delta y
   */


  PlanetNavigation.prototype.pan = function (dx, dy, mx, my) {
    if (this.lastMousePosition && mx && my) {
      const crs = this.ctx.getCoordinateSystem();
      const globe = this.ctx.globe;
      const rc = this.renderContext;
      const fov = rc.getFov();
      const halfFov = Numeric.toRadian(fov * 0.5);
      this.computeInverseViewMatrix();
      const eye = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
      const rotation = mat4.create(this.inverseViewMatrix); // mat4.translate(rotation, [0, 0, -this.distance]);
      // mat4.inverse(rotation);
      // crs.getLHVTransform(this.geoCenter, rotation);

      const center = vec3.create();
      this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, center);
      const centerDir = vec3.create();
      vec3.subtract(center, eye, centerDir);
      vec3.normalize(centerDir);
      const pGeo = globe.getLonLatFromPixel(this.lastMousePosition[0], this.lastMousePosition[1]); // Cannot move if we do not pick a proper point
      // We always want to update the last mouse position
      // to avoid stopping interaction when moving out of the earth and coming back

      this.lastMousePosition = [mx, my];
      if (!pGeo) return;
      const p = vec3.create();
      crs.fromGeoTo3D(pGeo, p);
      const d = vec3.create();
      vec3.subtract(eye, p, d);
      const distance = vec3.length(d);
      const projScale = distance * Math.tan(halfFov);
      dx = dx * 2 / rc.getCanvas().width;
      dy = dy * 2 / rc.getCanvas().height;
      const deltaWorld = vec3.createFrom(-dx * projScale, dy * projScale, 0);
      mat4.rotateVec3(rotation, deltaWorld);
      const newEye = vec3.create();
      vec3.add(eye, deltaWorld, newEye);
      var r = new Ray(newEye, centerDir);
      const newCenter = this.ctx.globe.computeIntersection(r);

      if (newCenter != null) {
        this.geoCenter = newCenter;
        this.geoCenter[1] = Math.min(88, Math.max(this.geoCenter[1], -88));
      }
    } else {
      // Get geographic frame
      var local2World = mat4.create();
      var coordinateSystem = this.ctx.getCoordinateSystem();
      coordinateSystem.getLocalTransform(this.geoCenter, local2World); // Then corresponding vertical axis and north

      var z = vec3.create();
      var previousNorth = vec3.create([0.0, 1.0, 0.0]);
      coordinateSystem.getUpVector(local2World, z); //coordinateSystem.getFrontVector( local2World, previousNorth );

      mat4.multiplyVec3(local2World, previousNorth, previousNorth); // Then apply local transform

      this.applyLocalRotation(local2World); // Retrieve corresponding axes

      var x = vec3.create();
      var y = vec3.create();
      coordinateSystem.getSideVector(local2World, x);
      coordinateSystem.getFrontVector(local2World, y); // According to our local configuration, up is y and side is x
      // Compute direction axes

      vec3.cross(z, x, y);
      vec3.cross(y, z, x);
      vec3.normalize(x, x);
      vec3.normalize(y, y); //Normalize dx and dy

      dx = dx / this.renderContext.getCanvas().width;
      dy = dy / this.renderContext.getCanvas().height; // Move accordingly

      var position = vec3.create();
      coordinateSystem.get3DFromWorld(this.geoCenter, position); // FIXME: Might be interesting to be able to control minimum camera speed

      vec3.scale(x, dx * Math.max(this.distance, 1000 * this.scale), x);
      vec3.scale(y, dy * Math.max(this.distance, 1000 * this.scale), y);
      vec3.subtract(position, x, position);
      vec3.add(position, y, position); // Clamp onto sphere

      vec3.normalize(position);
      vec3.scale(position, coordinateSystem.getGeoide().getRadius()); // Update geographic center

      coordinateSystem.getWorldFrom3D(position, this.geoCenter);
      this.geoCenter[2] = this.targetHeight; // Compute new north axis

      var newNorth = vec3.create([0.0, 1.0, 0.0]);
      coordinateSystem.getLocalTransform(this.geoCenter, local2World);
      mat4.multiplyVec3(local2World, newNorth, newNorth); // Take care if we traverse the pole, ie the north is inverted

      if (vec3.dot(previousNorth, newNorth) < 0) {
        this.heading = (this.heading + 180.0) % MAX_HEADING;
      }

      this.computeViewMatrix();
    }
  };
  /**
   * Rotates the navigation
   * @function rotate
   * @memberof PlanetNavigation#
   * @param {int} dx Window delta x
   * @param {int} dy Window delta y
   */


  PlanetNavigation.prototype.rotate = function (dx, dy) {
    this.heading += dx * DELTA_HEADING;
    this.tilt += dy * DELTA_TILT;
    this.clampTilt();
    this.computeViewMatrix();
  };
  /**
   * Check for collision
   * @function hasCollision
   * @memberof PlanetNavigation#
   * @return {Boolean} collision detected ?
   */


  PlanetNavigation.prototype.hasCollision = function () {
    const eye = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
    const geoEye = vec3.create();
    this.ctx.getCoordinateSystem().from3DToGeo(eye, geoEye);
    const elevation = this.ctx.getElevation(geoEye[0], geoEye[1]);
    const dist = geoEye[2] - elevation - 25;
    const collides = dist < 0;

    if (collides) {
      this.offset = -dist + 25;
    }

    return collides;
  };
  /**
   * Compute the new geocenter, being the intersection point
   * with the center of the screen
   */


  PlanetNavigation.prototype.updateGeoCenter = function () {
    // Recompute the geo position, trace a new ray to check intersection with the terrain
    this.computeInverseViewMatrix();
    const eye = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
    const pos = vec3.create();
    this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, pos);
    const dir = vec3.create();
    vec3.subtract(pos, eye, dir);
    vec3.normalize(dir);
    var r = new Ray(eye, dir);
    const center = this.ctx.globe.computeIntersection(r);

    if (center != null) {
      this.geoCenter = center; // Update distance

      const center3D = vec3.create();
      this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, center3D);
      this.distance = vec3.dist(center3D, eye);
    }
  };
  /**
   * Returns the distance in meters.
   * @return {float} the distance in meters from the surface of the globe
   */


  PlanetNavigation.prototype.getDistance = function () {
    return this._distance;
  };
  /**
   * Returns a Heading where the values are included in [0,360]
   * @return {number}
   */


  PlanetNavigation.prototype.getHeading = function () {
    return (this.heading % MAX_HEADING + MAX_HEADING) % MAX_HEADING;
  };
  /**
   * Destroy
   * @function destroy
   * @memberof PlanetNavigation#
   */


  PlanetNavigation.prototype.destroy = function () {
    AbstractNavigation.prototype.destroy.call(this);
    this.minDistance = null;
    this.maxDistance = null;
    this.geoCenter = null;
    this._distance = null;
    this.heading = null;
    this.tilt = null;
    this.inverseViewMatrix = null;
  };
  /**
   * Update the navigator inner values
   * @function update
   * @memberof PlanetNavigation#
   * @fires Context#navigation:changedDistance
   */


  PlanetNavigation.prototype.update = function () {
    if (!this.ctx.globe.tileManager.level0TilesLoaded) {
      return;
    }

    if (Number.isNaN(this.distance)) {
      this.distance = this.maxDistance;
      this._distance = this.cameraHeight;
    }

    const rc = this.ctx.getRenderContext(); // Update the near plane distance

    rc.near = this.distance * 0.25;
    this.computeViewMatrix();

    if (this.hasCollision()) {
      const hc = this.cameraHeight;
      const ht = this.targetHeight;
      const nh = (hc + this.offset - ht) / this._distance;
      const as = Math.asin(nh); // New tilt value

      if (Number.isNaN(as)) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "PlanetNavigation.js", `NaN ! ${hc}, ${ht}, ${this.offset}, ${this._distance}, ${nh}`);
        this._distance += this.offset;
      } else {
        this.tilt = Numeric.toDegree(as);
        this.clampTilt();
      }

      this.computeViewMatrix();
    }

    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, this.cameraHeight);
  };
  /**
   * Clamp the tilt value between 5 and 90 degrees
   * @function clampTilt
   * @memberof PlanetNavigation#
   */


  PlanetNavigation.prototype.clampTilt = function () {
    this.tilt = Math.min(Math.max(this.tilt, MIN_TILT), MAX_TILT);
  };

  PlanetNavigation.prototype.doneMoving = function () {
    this.updateGeoCenter();
    this.lastMousePosition = null;
  };

  PlanetNavigation.prototype.donePanning = function () {
    this.updateGeoCenter();
    this.lastMousePosition = null;
  };

  PlanetNavigation.prototype.doneRotating = function () {
    this.updateGeoCenter();
  };

  PlanetNavigation.prototype.startInteraction = function (x, y) {
    this.lastMousePosition = [x, y];
  };
  /**
   * Moves up vector.
   * @function moveUpTo
   * @memberof PlanetNavigation#
   * @param {float[]} vec Vector
   * @param {int} [duration = 1000] - Duration of animation in milliseconds
   */


  PlanetNavigation.prototype.moveUpTo = function (vec, duration) {
    // Create a single animation to animate up
    var startValue = [];
    var endValue = [];
    this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, endValue);
    this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);
    this.startHeading = this.getHeading();

    if (this.startHeading > 180) {
      this.endHeading = MAX_HEADING;
    } else {
      this.endHeading = MIN_HEADING;
    }

    var durationTime = duration || DEFAULT_DURATION_NORTH;
    var navigation = this;
    var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: durationTime,
      valueSetter: function (value) {
        navigation.heading = value;
        navigation.computeViewMatrix();
      }
    });
    animation.addSegment(0.0, this.startHeading, 1.0, this.endHeading, function (t, a, b) {
      return Numeric.lerp(t, a, b);
    });
    this.ctx.addAnimation(animation);
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);
    animation.start();
  };

  const DEFAULT_DURATION_NORTH$1 = 1000;
  const DEFAULT_DURATION_ZOOM = 5000;
  const DELTA_HEADING$1 = 0.05;
  const DEFAULT_MIN_FOV = 0.001;
  const DEFAULT_MAX_FOV = 100;
  const DEFAULT_MIDDLE_FOV = 25;
  const DEFAULT_FINAL_FOV = 2;

  var AstroNavigation = function (ctx, options) {
    AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.AstroNavigation, ctx, options);
    this.minFov = this.options.minFov || DEFAULT_MIN_FOV;
    this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV;
    this.center3d = [1, 0, 0];
    this.up = [0, 0, 1];

    _setInitTarget$1.call(this, this.options.initTarget);

    _setInitFov.call(this, this.options.initFov);

    _setUpVector.call(this, this.options.up);

    this.computeViewMatrix();
  };

  function _setUpVector(up) {
    if (up) {
      this.up = up;
    }
  }

  function _setInitFov(initFov) {
    if (initFov) {
      if (this.minFov > initFov) {
        this.minFov = initFov;
      } else if (this.maxFov < initFov) {
        this.maxFov = initFov;
      }

      this.renderContext.setFov(initFov);

      this._clampFov();
    }
  }

  function _setInitTarget$1(initTarget) {
    if (initTarget) {
      this.ctx.getCoordinateSystem().get3DFromWorld(initTarget, this.center3d);
    }
  }

  function _initMoveUpAnimation(navigation, durationTime) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: durationTime,
      valueSetter: function (value) {
        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
        navigation.up[0] = position3d[0];
        navigation.up[1] = position3d[1];
        navigation.up[2] = position3d[2];
        navigation.computeViewMatrix();
      }
    });
  }

  function _initZoomAnimation(navigation, duration) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: duration,
      valueSetter: function (value) {
        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
        navigation.center3d[0] = position3d[0];
        navigation.center3d[1] = position3d[1];
        navigation.center3d[2] = position3d[2];
        navigation.ctx.getRenderContext().setFov(value[2]);
        navigation.computeViewMatrix();
      }
    });
  }

  function _addZoomOutThenZoomIn(zoomToAnimation, startValue, endValue, middleFov) {
    var midValue = [startValue[0] * 0.5 + endValue[0] * 0.5, startValue[1] * 0.5 + endValue[1] * 0.5, middleFov];
    zoomToAnimation.addSegment(0, startValue, 0.5, midValue, function (t, a, b) {
      var pt = Numeric.easeInQuad(t);
      var dt = Numeric.easeOutQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), Numeric.lerp(pt, a[1], b[1]), Numeric.lerp(dt, a[2], b[2])];
    });

    _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
  }

  function _addZoomIn(animation, startValue, endValue, startParameter) {
    var parameter = startParameter ? startParameter : 0;
    animation.addSegment(parameter, startValue, 1, endValue, function (t, a, b) {
      var pt = Numeric.easeOutQuad(t);
      var dt = Numeric.easeInQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), Numeric.lerp(pt, a[1], b[1]), Numeric.lerp(dt, a[2], b[2])];
    });
  }

  function _addStop(animation, ctx, destDistance, options) {
    animation.onstop = function () {
      if (options && options.callback) {
        options.callback();
      }

      animation = null;
      ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, destDistance);
    };
  }

  function _computeParametersAnimation(ctx, center3D, geoPos, startFov, destFov) {
    var geoStart = [];
    ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
    var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
    var startValue = [path[0], geoStart[1], startFov];
    var endValue = [path[1], geoPos[1], destFov];
    return [startValue, endValue];
  }

  Utils.inherits(AbstractNavigation, AstroNavigation);

  AstroNavigation.prototype.getCenter = function () {
    var center = AbstractNavigation.prototype.getCenter.call(this);

    if (center == null) {
      center = [];
      this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, center);
    }

    return center;
  };

  AstroNavigation.prototype.zoomTo = function (geoPos, options) {
    var navigation = this;
    var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV;
    var duration = options && options.duration ? options.duration : DEFAULT_DURATION_ZOOM;

    var parameters = _computeParametersAnimation.call(this, this.ctx, this.center3d, geoPos, this.renderContext.getFov(), destFov);

    var startValue = parameters[0];
    var endValue = parameters[1];

    var zoomToAnimation = _initZoomAnimation.call(this, navigation, duration);

    var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);

    if (DEFAULT_MIDDLE_FOV > this.renderContext.getFov() && this.renderContext.getWorldFrustum().containsSphere(end3DValue, 0.005) < 0) {
      _addZoomOutThenZoomIn.call(this, zoomToAnimation, startValue, endValue, DEFAULT_MIDDLE_FOV);
    } else {
      _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
    }

    _addStop.call(this, zoomToAnimation, this.ctx, destFov, options);

    this.ctx.addAnimation(zoomToAnimation);
    zoomToAnimation.start();
  };

  AstroNavigation.prototype.moveUpTo = function (vec, duration) {
    var startValue = [];
    var endValue = [];
    this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, startValue);
    this.ctx.getCoordinateSystem().getWorldFrom3D(vec, endValue);
    var durationTime = duration || DEFAULT_DURATION_NORTH$1;
    var navigation = this;

    var moveUpToAnimation = _initMoveUpAnimation.call(this, navigation, durationTime);

    _addZoomIn.call(this, moveUpToAnimation, startValue, endValue);

    this.ctx.addAnimation(moveUpToAnimation);
    moveUpToAnimation.start();
  };

  AstroNavigation.prototype.computeViewMatrix = function () {
    vec3.normalize(this.center3d);
    var vm = this.renderContext.getViewMatrix();
    mat4.lookAt([0, 0, 0], this.center3d, this.up, vm);
    this.up = [vm[1], vm[5], vm[9]];
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
    this.renderContext.requestFrame();
  };

  AstroNavigation.prototype.zoom = function (delta, scale) {
    if (scale) {
      this.renderContext.setFov(this.renderContext.getFov() * 1 / scale);
    } else {
      this.renderContext.setFov(this.renderContext.getFov() * (1 + delta * 0.1));
    }

    this._clampFov();

    this.computeViewMatrix();
  };

  AstroNavigation.prototype.pan = function (dx, dy) {
    var x = this.renderContext.getCanvas().width / 2;
    var y = this.renderContext.getCanvas().height / 2;
    var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
    this.center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.ctx.getCoordinateSystem().getGeoide().getRadius()));
    this.computeViewMatrix();
  };

  AstroNavigation.prototype.rotate = function (dx) {
    var angle = Numeric.toRadian(dx * DELTA_HEADING$1);
    var rot = quat4.fromAngleAxis(angle, this.center3d);
    quat4.multiplyVec3(rot, this.up);
    this.computeViewMatrix();
  };

  AstroNavigation.prototype._clampFov = function () {
    if (this.renderContext.getFov() > this.maxFov) {
      this.renderContext.setFov(this.maxFov);
    }

    if (this.renderContext.getFov() < this.minFov) {
      this.renderContext.setFov(this.minFov);
    }
  };

  AstroNavigation.prototype.destroy = function () {
    AbstractNavigation.prototype.destroy.call(this);
    this.minFov = null;
    this.maxFov = null;
    this.center3d = null;
    this.up = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Flat navigation configuration
   * @typedef {AbstractNavigation.configuration} AbstractNavigation.flat_configuration
   * @property {float[]} [initTarget = [0, 0, 5.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
   * at initialisation. distance in meter is optional.
   * @property {float} [minDistance = DEFAULT_MIN_DISTANCE] - The minimum distance in meter from the surface of the globe
   * or options.initTarget[2] when this one is inferior to options.minDistance
   * @property {float} [maxDistance = 5.0 * RADIUS_PLANET] - The maximum distance in meter or
   * options.initTarget[2] when this one is superior to options.maxDistance
   */

  /**
   * Duration of animation in milliseconds to align the camera with the north.
   * @type {number}
   */

  const DEFAULT_DURATION_NORTH$2 = 1000.0;
  /**
   * Min heading value in decimal degree.
   * @type {number}
   */

  const MIN_HEADING$1 = 0.0;
  /**
   * Max heading value in decimal degree.
   * @type {number}
   */

  const MAX_HEADING$1 = 360.0;
  /**
   * Difference between two successive rotation (in degree) of the camera.
   * @type {number}
   */

  const DELTA_HEADING$2 = 0.05;
  /**
   * Rotation axis according to the center of the map (0,0).
   * Long, lat, distance as vector length
   * @type {number[]}
   */

  const ROTATION_AXIS = [0.0, 0.0, 1.0];
  /**
   * 3D cartesian of planet center.
   * Long lat distance as vector ength.
   * @type {number[]}
   */

  const CENTER = [0.0, 0.0, 0.0];
  /**
   * Default min distance in meter.
   * @type {number}
   */

  const DEFAULT_MIN_DISTANCE = 60000;
  /**
   * Default duration in millisecond for zoom feature.
   * @type {number}
   */

  const DEFAULT_DURATION_ZOOM$1 = 5000;
  /**
   * @name FlatNavigation
   * @class
   * <table border="0">
   *     <tr>
   *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
   *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context. A 2D navigation
   *         provides a navigation for which there is no tilt and no roll <img src="https://developers.google.com/kml/documentation/kmlreference"/></td>
   *     </tr>
   * </table>
   * @augments AbstractNavigation
   * @param {PlanetContext} ctx - Planet context
   * @param {AbstractNavigation.flat_configuration} options - Flat navigation configuration
   * @constructor
   * @memberof module:Navigation
   */

  var FlatNavigation = function (ctx, options) {
    AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.FlatNavigation, ctx, options); // Default values for min and max distance (in meter)

    this.minDistance = this.options.minDistance || DEFAULT_MIN_DISTANCE;
    this.maxDistance = this.options.maxDistance || 5.0 * this.ctx.getCoordinateSystem().getGeoide().getRadius() / this.ctx.getCoordinateSystem().getGeoide().getHeightScale(); // Scale min and max distance from meter to internal ratio

    this.minDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
    this.maxDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale(); // Initialize the navigation

    this.center = CENTER;
    this.distance = this.maxDistance;
    this.heading = 0;
    this.up = [0.0, 1.0, 0.0];

    _setInitTarget$2.call(this, this.options.initTarget);

    const rc = this.ctx.getRenderContext();

    if (rc) {
      rc.near = 0.001;
    }

    this.computeViewMatrix();
  };
  /**
   * Defines the position where the camera looks at and the distance of the camera from the planet's surface.
   * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
   * @private
   */


  function _setInitTarget$2(initTarget) {
    if (initTarget) {
      var pos = this.ctx.getCoordinateSystem().get3DFromWorld(initTarget);
      this.center[0] = pos[0];
      this.center[1] = pos[1];
      this.distance = initTarget.length === 3 ? initTarget[2] * this.ctx.getCoordinateSystem().getGeoide().getHeightScale() : this.distance;

      if (this.distance < this.minDistance) {
        this.minDistance = this.distance;
      }

      if (this.distance > this.maxDistance) {
        this.maxDistance = this.distance;
      }
    }
  }
  /**
   * Init move up animation.
   * @param {AbstractNavigation} navigation - navigation object
   * @param {number} durationTime - duration of the animation in millisecond
   * @return {AbstractAnimation} animation
   * @private
   */


  function _initMoveUpAnimation$1(navigation, durationTime) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: durationTime,
      valueSetter: function (value) {
        var angle = value - navigation.heading;
        navigation.heading = value;
        var rot = quat4.fromAngleAxis(Numeric.toRadian(angle), ROTATION_AXIS);
        quat4.multiplyVec3(rot, navigation.up);
        navigation.computeViewMatrix();
      }
    });
  }
  /**
   * Rotates from startHeading to North
   * @param {AbstractAnimation} animation - animation on which the rotation is applied
   * @param {float} startHeading - start heading
   * @private
   */


  function _rotateAnimationToNorth(animation, startHeading) {
    var endHeading;

    if (startHeading > 180) {
      endHeading = MAX_HEADING$1;
    } else {
      endHeading = MIN_HEADING$1;
    }

    animation.addSegment(0.0, startHeading, 1.0, endHeading, function (t, a, b) {
      return Numeric.lerp(t, a, b);
    });
  }
  /**
   * Init zoom animation
   * @param {AbstractNavigation} navigation - navigation object
   * @param {number} duration - duration of the animation in millisecond
   * @return {AbstractAnimation} animation
   * @private
   */


  function _initZoomAnimation$1(navigation, duration) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: duration,
      valueSetter: function (value) {
        navigation.center[0] = value[0];
        navigation.center[1] = value[1];
        navigation.distance = value[2];
        navigation.computeViewMatrix();
      }
    });
  }
  /**
   * Adds two segments to the animation, which starts to startValue and stops to endValue
   * by crossing the maxAltitude at middle value of [startValue, endValue]
   * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
   * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
   * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
   * @param {float} maxAltitude - altitude (as vector length) where the camera FOV contains the center and the target position
   * @private
   */


  function _addZoomOutThenZoomIn$1(zoomToAnimation, startValue, endValue, maxAltitude) {
    // Compute the middle value
    var midValue = [startValue[0] * 0.5 + endValue[0] * 0.5, startValue[1] * 0.5 + endValue[1] * 0.5, maxAltitude]; // zoom out to max altitude

    zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function (t, a, b) {
      var pt = Numeric.easeInQuad(t);
      var dt = Numeric.easeOutQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
      Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
      Numeric.lerp(dt, a[2], b[2])]; // distance
    }); // zoom in

    _addZoomIn$1.call(this, zoomToAnimation, midValue, endValue, 0.5);
  }
  /**
   * Adds a segment to the animation, which starts to startValue and stops to endValue
   * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
   * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
   * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
   * @param {float} [startParameter=0.0] - start parameter
   * @private
   */


  function _addZoomIn$1(zoomToAnimation, startValue, endValue, startParameter) {
    var parameter = startParameter ? startParameter : 0.0;
    zoomToAnimation.addSegment(parameter, startValue, 1.0, endValue, function (t, a, b) {
      var pt = Numeric.easeOutQuad(t);
      var dt = Numeric.easeInQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
      Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
      Numeric.lerp(dt, a[2], b[2])]; // distance
    });
  }
  /**
   * Adds an event when the animation stops.
   * @param {AbstractAnimation} zoomToAnimation - animation where the event is added
   * @param {AbstractContext} ctx - context
   * @param {number} destDistance - Final zooming distance in meter
   * @param {Object} [options] - options
   * @param {Object} [options.callback] - Callback function to call when it is defined.
   * @private
   * @fires Context#navigation:changedDistance
   */


  function _addStop$1(zoomToAnimation, ctx, destDistance, options) {
    zoomToAnimation.onstop = function () {
      if (options && options.callback) {
        options.callback();
      }

      zoomToAnimation = null;
      ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, destDistance);
    };
  }
  /**
   * Computes altitude (as vector length) for which the fov see the distance between worldStart-worldEnd
   * @param {AbstractContext} ctx - context
   * @param {float[]} worldStart - Starting position as [longitude, latitude, distance]
   * @param {float[]} worldEnd - Ending position as [longitude, latitude, distance]
   * @return {number} the altitude for which the fov see the distance worldStart-worldEnd
   * @private
   */


  function _computeMaxAltitudeForZoomAnimation(ctx, worldStart, worldEnd) {
    var vec = vec3.subtract(worldStart, worldEnd);
    var len = vec3.length(vec);
    var canvas = ctx.getRenderContext().getCanvas();
    var fov = ctx.getRenderContext().getFov();
    var minFov = Math.min(Numeric.toRadian(fov), Numeric.toRadian(fov * canvas.width / canvas.height));
    return len / 2.0 / Math.tan(minFov / 2.0);
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractNavigation, FlatNavigation);
  /**************************************************************************************************************/

  /**
   * @function getCenter
   * @memberof FlatNavigation#
   * @return {float[]} Returns the central position of the camera
   */

  FlatNavigation.prototype.getCenter = function () {
    var center = AbstractNavigation.prototype.getCenter.call(this);

    if (center == null) {
      center = this.center;
    }

    return center;
  };
  /**
   * Saves the current navigation state.
   * @function save
   * @memberof FlatNavigation#
   * @return {{center: *, distance: *, up: *}} a JS object containing the navigation state
   */


  FlatNavigation.prototype.save = function () {
    return {
      center: this.center,
      distance: this.distance,
      up: this.up
    };
  };
  /**
   * Restores the navigation state.
   * @function restore
   * @memberof FlatNavigation#
   * @param {Object} state a JS object containing the navigation state
   * @param {float[]} state.center - Center of the camera's field of view in decimal degree as [longitude, latitude]
   * @param {int} state.distance - Distance in meters from the surface of the globe to the camera
   */


  FlatNavigation.prototype.restore = function (state) {
    this.center = state.center;
    this.distance = state.distance;
    this.up = state.up;
    this.computeViewMatrix();
  };
  /**
   * Computes the view matrix.
   * @function computeViewMatrix
   * @memberof FlatNavigation#
   */


  FlatNavigation.prototype.computeViewMatrix = function () {
    var vm = this.renderContext.getViewMatrix();
    var eye = [this.center[0], this.center[1], this.distance];
    mat4.lookAt(eye, this.center, this.up, vm);
    this.up = [vm[1], vm[5], vm[9]];
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
    this.renderContext.requestFrame();
  };
  /**
   * Zooms to a geographic position by creating an animation.
   *
   * @function zoomTo
   * @memberof FlatNavigation#
   * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
   * @param {Object} options - options
   * @param {int} [options.distance] - Final zooming distance in meters. By default, the distance does not change
   * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] -  Duration of animation in milliseconds
   * @param {navigationCallback} options.callback - Callback at the end of animation
   */


  FlatNavigation.prototype.zoomTo = function (geoPos, options) {
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE);
    var navigation = this;
    var duration = options && options.duration ? options.duration : DEFAULT_DURATION_ZOOM$1;

    var zoomToAnimation = _initZoomAnimation$1.call(this, navigation, duration);

    var destDistance = options && options.distance ? options.distance : this.distance / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
    var pos = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
    var startValue = [this.center[0], this.center[1], this.distance];
    var endValue = [pos[0], pos[1], destDistance * this.ctx.getCoordinateSystem().getGeoide().getHeightScale()];

    var maxAltitude = _computeMaxAltitudeForZoomAnimation.call(this, this.ctx, this.center, pos);

    if (maxAltitude > this.distance) {
      _addZoomOutThenZoomIn$1.call(this, zoomToAnimation, startValue, endValue, maxAltitude);
    } else {
      _addZoomIn$1.call(this, zoomToAnimation, startValue, endValue);
    }

    _addStop$1.call(this, zoomToAnimation, this.ctx, destDistance, options);

    this.ctx.addAnimation(zoomToAnimation);
    zoomToAnimation.start();
  };
  /**
   * Zoom to the current observed location
   * @function zoom
   * @memberof FlatNavigation#
   * @param {float} delta Delta zoom
   * @param {float} scale Scale
   */


  FlatNavigation.prototype.zoom = function (delta, scale) {
    var previousDistance = this.distance; // TODO : improve zoom, using scale or delta ? We should use scale always

    if (scale) {
      this.distance *= scale;
    } else {
      this.distance *= 1 + delta * 0.1;
    }

    if (this.distance > this.maxDistance) {
      this.distance = previousDistance;
    }

    if (this.distance < this.minDistance) {
      this.distance = previousDistance;
    } //TODO : add the collision algorithm because of the elevation


    this.computeViewMatrix();
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, this.getDistance());
  };
  /**
   * Pans the camera
   * @function pan
   * @memberof FlatNavigation#
   * @param {int} dx Window delta x
   * @param {int} dy Window delta y
   */


  FlatNavigation.prototype.pan = function (dx, dy) {
    var x = this.renderContext.getCanvas().width / 2.0;
    var y = this.renderContext.getCanvas().height / 2.0; // Get the most-left point

    var ptLeft = this.ctx.getLonLatFromPixel(0, y);

    if (ptLeft === null && dx > 0) {
      dx = 0;
    } // Get the most-right point


    var ptRight = this.ctx.getLonLatFromPixel(this.renderContext.getCanvas().width, y);

    if (ptRight === null && dx < 0) {
      dx = 0;
    } // Get the most-top point


    var ptTop = this.ctx.getLonLatFromPixel(x, 0);

    if (ptTop === null && dy > 0) {
      dy = 0;
    } // Get the most-bottom point


    var ptBottom = this.ctx.getLonLatFromPixel(x, this.renderContext.getCanvas().height);

    if (ptBottom === null && dy < 0) {
      dy = 0;
    }

    if (dx === 0 && dy === 0) {
      return;
    }

    var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
    this.center = ray.computePoint(ray.planeIntersect(CENTER, ROTATION_AXIS));
    this.computeViewMatrix();
  };
  /**
   * Camera heading.
   * @function rotate
   * @memberof FlatNavigation#
   * @param {int} dx Window delta x
   */


  FlatNavigation.prototype.rotate = function (dx) {
    // Constant tiny angle
    var angle = dx * DELTA_HEADING$2;
    this.heading += angle;
    var rot = quat4.fromAngleAxis(Numeric.toRadian(angle), ROTATION_AXIS);
    quat4.multiplyVec3(rot, this.up);
    this.computeViewMatrix();
  };
  /**
   * Returns the distance in meters.
   * @function getDistance
   * @memberof FlatNavigation#
   * @return {float} the distance in meters from the surface of the globe
   */


  FlatNavigation.prototype.getDistance = function () {
    return this.distance * this.ctx.getCoordinateSystem().getGeoide().getRealPlanetRadius();
  };
  /**
   * Returns the heading of the camera.
   * @function getHeading
   * @memberof FlatNavigation#
   * @return {number} the heading angle between [0, 360]
   */


  FlatNavigation.prototype.getHeading = function () {
    return (this.heading % MAX_HEADING$1 + MAX_HEADING$1) % MAX_HEADING$1;
  };
  /**
   * Moves up vector.
   * @function moveUpTo
   * @memberof FlatNavigation#
   * @param {float[]} vec Vector
   * @param {int} [duration = DEFAULT_DURATION_NORTH] - Duration of animation in milliseconds
   */


  FlatNavigation.prototype.moveUpTo = function (vec, duration) {
    // Create a single animation to animate up
    var startValue = [];
    var endValue = this.up;
    endValue[0] = Numeric.toDegree(endValue[0]);
    endValue[1] = Numeric.toDegree(endValue[1]); //endValue[2] = endValue[2];

    this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);
    var durationTime = duration || DEFAULT_DURATION_NORTH$2;
    var navigation = this;

    var moveUpToAnimation = _initMoveUpAnimation$1.call(this, navigation, durationTime);

    _rotateAnimationToNorth.call(this, moveUpToAnimation, this.getHeading());

    this.ctx.addAnimation(moveUpToAnimation);
    moveUpToAnimation.start();
  };
  /**
   * Destroy
   * @function destroy
   * @memberof FlatNavigation#
   */


  FlatNavigation.prototype.destroy = function () {
    AbstractNavigation.prototype.destroy.call(this);
    this.up = null;
    this.minDistance = null;
    this.maxDistance = null;
    this.heading = null;
    this.center = null;
    this.distance = null;
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**************************************************************************************************************/

  /**
   * Duration of animation in milliseconds to align the camera with the north.
   * @type {number}
   */

  const DEFAULT_DURATION_NORTH$3 = 1000;
  /**
   * Default duration in millisecond for zoom feature.
   * @type {number}
   */

  const DEFAULT_DURATION_ZOOM$2 = 5000;
  /**
   * Default min FOV.
   * @type {number}
   */

  const DEFAULT_MIN_FOV$1 = 0.5;
  /**
   * Default max FOV.
   * @type {number}
   */

  const DEFAULT_MAX_FOV$1 = 70;
  /**
   * Arbitrary middle fov value which determines if the animation needs two segments
   * @type {number}
   */

  const DEFAULT_MIDDLE_FOV$1 = 25;
  /**
   * Final FOV.
   * @type {number}
   */

  const DEFAULT_FINAL_FOV$1 = 2.0;
  /**
   * 3D position of the azimuth 0.
   * @type {number[]}
   */

  const DEFAULT_AZIMUTH_ZERO = [1.0, 0.0, 0.0];
  /**
   * Min heading value in decimal degree.
   * @type {number}
   */

  const MIN_HEADING$2 = 0.0;
  /**
   * Difference between two successive rotation (in degree) of the camera.
   * @type {number}
   */

  const DELTA_HEADING$3 = 0.05;
  /**
   * Default heading in decimal degree.
   * @type {number}
   */

  const DEFAULT_HEADING$1 = MIN_HEADING$2;
  /**
   * @name GroundNavigation
   * @class
   * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
   * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
   * @augments AstroNavigation
   * @param {GroundContext} ctx - ground context
   * @param {AbstractNavigation.astro_configuration} options - navigation configuration
   * @constructor
   * @memberof module:Navigation
   */

  var GroundNavigation = function (ctx, options) {
    AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.GroundNavigation, ctx, options); // Default values for fov (in degrees)

    this.minFov = this.options.minFov || DEFAULT_MIN_FOV$1;
    this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV$1; // Initialize the navigation

    this.center3d = DEFAULT_AZIMUTH_ZERO;
    this.up = [0.0, 0.0, 1.0];
    this.heading = this.options.initTarget ? this.options.initTarget[0] : DEFAULT_HEADING$1;

    _setInitTarget$3.call(this, this.options.initTarget);

    _setInitFov$1.call(this, this.options.initFov);

    _setUpVector$1.call(this, this.options.up); // Update the view matrix now


    this.computeViewMatrix();
  };
  /**
   * Defines the position where the camera looks at.
   * @param {float[]|undefined} initTarget
   * @private
   */


  function _setInitTarget$3(initTarget) {
    if (initTarget) {
      this.ctx.getCoordinateSystem().get3DFromWorld(initTarget, this.center3d);
    }
  }
  /**
   * Defines the field of view of the camera at initialisation.<br/>
   * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
   * @param {float|undefined} initFov
   * @private
   */


  function _setInitFov$1(initFov) {
    if (initFov) {
      if (this.minFov > initFov) {
        this.minFov = initFov;
      } else if (this.maxFov < initFov) {
        this.maxFov = initFov;
      }

      this.renderContext.setFov(initFov);

      this._clampFov();
    }
  }
  /**
   * Defines the Up vector.
   * @param up
   * @private
   */


  function _setUpVector$1(up) {
    if (up) {
      this.up = up;
    }
  }
  /**
   * Init move up animation.
   * @param {AbstractNavigation} navigation - navigation object
   * @param {number} durationTime - duration of the animation in millisecond
   * @return {AbstractAnimation} animation
   * @private
   */


  function _initMoveUpAnimation$2(navigation, durationTime) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: durationTime,
      valueSetter: function (value) {
        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
        navigation.center3d[0] = position3d[0];
        navigation.center3d[1] = position3d[1];
        navigation.center3d[2] = position3d[2];
        navigation.computeViewMatrix();
      }
    });
  }
  /**
   * Init zoom animation
   * @param {AbstractNavigation} navigation - navigation object
   * @param {number} duration - duration of the animation in millisecond
   * @return {AbstractAnimation} animation
   * @private
   */


  function _initZoomAnimation$2(navigation, duration) {
    return AnimationFactory.create(Constants.ANIMATION.Segmented, {
      duration: duration,
      valueSetter: function (value) {
        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
        navigation.center3d[0] = position3d[0];
        navigation.center3d[1] = position3d[1];
        navigation.center3d[2] = position3d[2];
        navigation.ctx.getRenderContext().setFov(value[2]);
        navigation.computeViewMatrix();
      }
    });
  }
  /**
   * Adds two segments to the animation, which starts to startValue and stops to endValue
   * by crossing the middleFov at middle value of [startValue, endValue]
   * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
   * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
   * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
   * @param {float} middleFov - FOV
   * @private
   */


  function _addZoomOutThenZoomIn$2(zoomToAnimation, startValue, endValue, middleFov) {
    // Compute the middle value
    var midValue = [startValue[0] * 0.5 + endValue[0] * 0.5, startValue[1] * 0.5 + endValue[1] * 0.5, middleFov]; // zoom out to max altitude

    zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function (t, a, b) {
      var pt = Numeric.easeInQuad(t);
      var dt = Numeric.easeOutQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
      Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
      Numeric.lerp(dt, a[2], b[2])]; // distance
    }); // zoom in

    _addZoomIn$2.call(this, zoomToAnimation, midValue, endValue, 0.5);
  }
  /**
   * Adds a segment to the animation, which starts to startValue and stops to endValue
   * @param {AbstractAnimation} animation - animation where the segment is added
   * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
   * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
   * @param {float} [startParameter=0.0] - start parameter
   * @private
   */


  function _addZoomIn$2(animation, startValue, endValue, startParameter) {
    var parameter = startParameter ? startParameter : 0.0;
    animation.addSegment(parameter, startValue, 1.0, endValue, function (t, a, b) {
      var pt = Numeric.easeOutQuad(t);
      var dt = Numeric.easeInQuad(t);
      return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
      Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
      Numeric.lerp(dt, a[2], b[2])]; // distance
    });
  }
  /**
   * Adds an event when the animation stops.
   * @param {AbstractAnimation} animation - animation where the event is added
   * @param {AbstractContext} ctx - context
   * @param {number} destDistance - Final zooming distance in meter
   * @param {Object} [options] - options
   * @param {Object} [options.callback] - Callback function to call when it is defined.
   * @fires Context#navigation:changedDistance
   * @private
   */


  function _addStop$2(animation, ctx, destDistance, options) {
    animation.onstop = function () {
      if (options && options.callback) {
        options.callback();
      }

      animation = null;
      ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE, destDistance);
    };
  }
  /**
   * Computes parameters for animation
   * @param {AbstractContext} ctx - context
   * @param {Array.<float>} center3D - start position in 3D
   * @param {Array.<float>} geoPos - stop position
   * @param {float} startFov - start FOV
   * @param {float} destFov - stop FOV
   * @return {Array.<float>} Returns [startValue, endValue]
   * @private
   */


  function _computeParametersAnimation$1(ctx, center3D, geoPos, startFov, destFov) {
    var geoStart = [];
    ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
    var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
    var startValue = [path[0], geoStart[1], startFov];
    var endValue = [path[1], geoPos[1], destFov];
    return [startValue, endValue];
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractNavigation, GroundNavigation);
  /**************************************************************************************************************/

  /**
   * Returns the center of the navigation.
   * @function getCenter
   * @memberof GroundNavigation#
   * @return {float[]}
   */

  GroundNavigation.prototype.getCenter = function () {
    var center = AbstractNavigation.prototype.getCenter.call(this);

    if (center == null) {
      center = [];
      this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, center);
    }

    return center;
  };
  /**
   * ZoomTo a 3D position
   * @function zoomTo
   * @param {float[]} geoPos - target of the camera
   * @param {Object} options - options
   * @param {float} [options.fov = DEFAULT_FINAL_FOV] - field of view in degree
   * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] - duration of the animation in milliseconds
   * @param {navigationCallback} [options.callback] - Called at the end of navigation
   * @memberof GroundNavigation#
   */


  GroundNavigation.prototype.zoomTo = function (geoPos, options) {
    var navigation = this; // default values

    var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV$1;
    var duration = options && options.duration ? options.duration : DEFAULT_DURATION_ZOOM$2; // Create a single animation to animate center3d and fov

    var parameters = _computeParametersAnimation$1.call(this, this.ctx, this.center3d, geoPos, this.renderContext.getFov(), destFov);

    var startValue = parameters[0];
    var endValue = parameters[1];

    var zoomToAnimation = _initZoomAnimation$2.call(this, navigation, duration); // End point which is out of frustum invokes two steps animation, one step otherwise


    var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);

    if (DEFAULT_MIDDLE_FOV$1 > this.renderContext.getFov() && this.renderContext.getWorldFrustum().containsSphere(end3DValue, 0.005) < 0) {
      // Two steps animation, 'rising' & 'falling'
      _addZoomOutThenZoomIn$2.call(this, zoomToAnimation, startValue, endValue, DEFAULT_MIDDLE_FOV$1);
    } else {
      // One step animation, 'falling' only
      _addZoomIn$2.call(this, zoomToAnimation, startValue, endValue);
    }

    _addStop$2.call(this, zoomToAnimation, this.ctx, destFov, options);

    this.ctx.addAnimation(zoomToAnimation);
    zoomToAnimation.start();
  };

  GroundNavigation.prototype.moveUpTo = function (vec, duration) {
    // Create a single animation to animate up
    var startValue = this.center3d;
    var endValue = DEFAULT_AZIMUTH_ZERO;
    var durationTime = duration || DEFAULT_DURATION_NORTH$3;
    var navigation = this;

    var moveUpToAnimation = _initMoveUpAnimation$2.call(this, navigation, durationTime);

    _addZoomIn$2.call(this, moveUpToAnimation, startValue, endValue);

    this.ctx.addAnimation(moveUpToAnimation);
    moveUpToAnimation.start();
  };
  /**
   * Compute the view matrix
   * @function computeViewMatrix
   * @memberof GroundNavigation#
   */


  GroundNavigation.prototype.computeViewMatrix = function () {
    vec3.normalize(this.center3d);
    var vm = this.renderContext.viewMatrix;
    mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);
    var geo = [];
    this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geo);
    this.heading = geo[0];
    this.up = [0, 0, vm[9]];
    this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
    this.renderContext.requestFrame();
  };
  /**************************************************************************************************************/

  /**
       Event handler for mouse wheel
       @function zoom
       @param delta Delta zoom
       @memberof GroundNavigation#
       */


  GroundNavigation.prototype.zoom = function (delta, scale) {
    // TODO : improve zoom, using scale or delta ? We should use scale always
    if (scale) {
      this.renderContext.setFov(this.renderContext.getFov() * 1 / scale);
    } else {
      // Arbitrary value for smooth zooming
      this.renderContext.setFov(this.renderContext.getFov() * (1 + delta * 0.1));
    }

    this._clampFov();

    this.computeViewMatrix();
  };
  /**************************************************************************************************************/

  /**
       Pan the navigation by computing the difference between 3D centers
       @function pan
       @param dx Window delta x
       @param dy Window delta y
       @memberof GroundNavigation#
       */


  GroundNavigation.prototype.pan = function (dx, dy) {
    var x = this.renderContext.canvas.width / 2.0;
    var y = this.renderContext.canvas.height / 2.0;
    var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
    this.center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.ctx.getCoordinateSystem().getGeoide().getRadius()));
    this.computeViewMatrix();
  };
  /**************************************************************************************************************/

  /**
       Rotate the navigation
       @function rotate
       @param dx Window delta x
       @param dy Window delta y
       @memberof GroundNavigation#
       */


  GroundNavigation.prototype.rotate = function (dx, dy) {
    var angle = dx * DELTA_HEADING$3;
    var coord = [];
    this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, coord);
    this.heading += angle;
    coord[0] = this.heading;
    this.ctx.getCoordinateSystem().get3DFromWorld(coord, this.center3d);
    this.computeViewMatrix();
  };
  /**
       @function getHeading
       @memberof GroundNavigation#
       */


  GroundNavigation.prototype.getHeading = function () {
    return this.heading;
  };
  /**************************************************************************************************************/

  /**
   *    Clamping of fov
   */


  GroundNavigation.prototype._clampFov = function () {
    if (this.renderContext.getFov() > this.maxFov) {
      this.renderContext.setFov(this.maxFov);
    }

    if (this.renderContext.getFov() < this.minFov) {
      this.renderContext.setFov(this.minFov);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var NavigationFactory = {
    /**
     * Mizar owns different types of navigation to control the camera on the WebGL scene.
     * This class allows to create a navigation based on its type (e.g Astro, Flat, Sky).
     * <table border="1">
     *     <tr>
     *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
     *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
     *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
     *         It is used to view the sky</td>
     *     </tr>
     *     <tr>
     *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
     *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
     *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
     *     </tr>
     *     <tr>
     *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
     *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
     *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
     *     </tr>
     * </table>
     * @param {NAVIGATION} type - the type of navigation
     * @param {AbstractContext} ctx - The context where the camera look at
     * @param {AbstractNavigation.astro_configuration|AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} options - see the navigations.
     * @return {Navigation} navigation
     * @alias module:Navigation.NavigationFactory.create
     * @see {@link module:Navigation.PlanetNavigation PlanetNavigation} - Control the camera and turn around the globe, wich is located
     * at the center of the webGL scene.
     * @see {@link module:Navigation.AstroNavigation AstroNavigation} - Control the camera at the center of the scene. The camera is inside the globe
     * @see {@link module:Navigation.FlatNavigation FlatNavigation} - Control the camera. The camera look at the 2D projection
     * @see {@link module:Navigation.GroundNavigation GroundNavigation} - Control the camera. The camera look at the 3D projection of the ground
     * @throws {RangeError} Type not valid - a valid type is included in the list {@link NAVIGATION}
     */
    create: function (type, ctx, options) {
      var obj;

      switch (type) {
        case Constants.NAVIGATION.AstroNavigation:
          obj = new AstroNavigation(ctx, options);
          break;

        case Constants.NAVIGATION.PlanetNavigation:
          obj = new PlanetNavigation(ctx, options);
          break;

        case Constants.NAVIGATION.FlatNavigation:
          obj = new FlatNavigation(ctx, options);
          break;

        case Constants.NAVIGATION.GroundNavigation:
          obj = new GroundNavigation(ctx, options);
          break;

        default:
          throw new RangeError("The type " + type + " is not allowed, A valid type is included in the list NAVIGATION", "NavigationFactory.js");
      }

      return obj;
    }
  };

  const REGEXP_YEAR = /^\d{4}$/;

  var Time = function (time) {
    this.date = time.date;
    this.display = time.display;
    this.period = time.period;
  };

  function _isTimeTravel(value) {
    return value.hasOwnProperty("date") && value.hasOwnProperty("display") && value.hasOwnProperty("period");
  }

  function _isPeriod(value) {
    return value.hasOwnProperty("from") && value.hasOwnProperty("to");
  }

  function _isOpenedInterval(value) {
    return value.hasOwnProperty("from");
  }

  function _isDateString(value) {
    return typeof value === "string";
  }

  function _isDate(value) {
    return value instanceof Date;
  }

  function _unitWithoutTime(unit) {
    var unitTime;

    switch (unit) {
      case Constants.UNIT_TIME_WMS.YEAR:
        unitTime = Constants.TIME_STEP.YEAR;
        break;

      case Constants.UNIT_TIME_WMS.MONTH:
        unitTime = Constants.TIME_STEP.MONTH;
        break;

      case Constants.UNIT_TIME_WMS.DAY:
        unitTime = Constants.TIME_STEP.DAY;
        break;

      default:
        throw new Error("Unknown date format");
    }

    return unitTime;
  }

  function _unitWithTime(unit) {
    var unitTime;

    switch (unit) {
      case Constants.UNIT_TIME_WMS.HOUR:
        unitTime = Constants.TIME_STEP.HOUR;
        break;

      case Constants.UNIT_TIME_WMS.MINUTE:
        unitTime = Constants.TIME_STEP.MINUTE;
        break;

      case Constants.UNIT_TIME_WMS.SECONDE:
        unitTime = Constants.TIME_STEP.SECONDE;
        break;

      default:
        throw new Error("Onknown time format");
    }

    return unitTime;
  }

  function _timeResolution(resolution) {
    var stepTime, unitTime;
    var unit = resolution.slice(-1);

    if (resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.TIME)) {
      stepTime = resolution.substring(2, resolution.length - 1);
      unitTime = _unitWithTime(unit);
    } else if (resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.NOT_TIME)) {
      stepTime = resolution.substring(1, resolution.length - 1);
      unitTime = _unitWithoutTime(unit);
    } else {
      throw new Error("Unknown resolution");
    }

    var res = {
      step: stepTime,
      unit: unitTime
    };
    return res;
  }

  function _isSampling(timeDefinition) {
    return timeDefinition.indexOf("/") !== -1;
  }

  function _isDistinctValue(timeDefinition) {
    return !_isSampling(timeDefinition) && timeDefinition.indexOf(",") === -1;
  }

  function _isEqual(date1, date2) {
    var interval1 = _createPeriod(date1);

    var interval2 = _createPeriod(date2);

    return interval2.from <= interval1.from && interval1.from <= interval2.to || interval2.from <= interval1.to && interval1.to <= interval2.to || interval1.from <= interval2.from && interval2.from <= interval1.to || interval1.from <= interval2.to && interval2.to <= interval1.to;
  }

  function _createPeriod(date) {
    var format = date.creationData().format;

    var timeResolution = _lowestFormatResolution(format);

    return {
      from: Moment__default['default'](date).startOf(timeResolution),
      to: Moment__default['default'](date).endOf(timeResolution)
    };
  }

  function _isIntersect(period1, date2) {
    var interval2 = _createPeriod(date2);

    return interval2.from <= period1.from && period1.from <= interval2.to || interval2.from <= period1.to && period1.to <= interval2.to || period1.from <= interval2.from && interval2.from <= period1.to || period1.from <= interval2.to && interval2.to <= period1.to;
  }

  function _binarySearch(requestedTime, requestedPeriodTime, startTime, nbValues, timeResolution) {
    var guess,
        currentDate,
        min = 0,
        max = nbValues;

    while (min <= max) {
      guess = Math.floor((min + max) / 2);
      currentDate = Moment__default['default'](startTime);
      currentDate.add(guess * timeResolution.step, timeResolution.unit);
      if (_isEqual(requestedTime, currentDate) || _isIntersect(requestedPeriodTime, currentDate)) return guess;else if (requestedTime > currentDate) min = guess + 1;else max = guess - 1;
    }

    return -1;
  }

  function _lowestFormatResolution(format) {
    var timeResolution;

    if (Utils.aContainsB.call(this, format, "ss")) {
      timeResolution = Constants.TIME_MOMENT_STEP.SECOND;
    } else if (Utils.aContainsB.call(this, format, "mm")) {
      timeResolution = Constants.TIME_MOMENT_STEP.MINUTE;
    } else if (Utils.aContainsB.call(this, format, "HH")) {
      timeResolution = Constants.TIME_MOMENT_STEP.HOUR;
    } else if (Utils.aContainsB.call(this, format, "DD")) {
      timeResolution = Constants.TIME_MOMENT_STEP.DAY;
    } else if (Utils.aContainsB.call(this, format, "MM")) {
      timeResolution = Constants.TIME_MOMENT_STEP.MONTH;
    } else if (Utils.aContainsB.call(this, format, "YYYY")) {
      timeResolution = Constants.TIME_MOMENT_STEP.YEAR;
    } else {
      throw new Error();
    }

    return timeResolution;
  }

  function _templateTimeTravel(date, display, from, to, computed) {
    return {
      date: _convertMoment(date),
      display: display,
      period: {
        from: _convertMoment(from),
        to: _convertMoment(to)
      },
      computed: computed
    };
  }

  function _convertMoment(date) {
    var time;

    if (REGEXP_YEAR.test(date)) {
      time = Moment__default['default'].utc(date, "YYYY");
    } else if (date instanceof Date) {
      time = Moment__default['default'].utc(date.toISOString());
    } else {
      time = Moment__default['default'].utc(date);
    }

    return time;
  }

  function _convertStringDateToTime(time) {
    var timeRequested = _convertMoment(time);

    var format = timeRequested.creationData().format;

    var timeResolution = _lowestFormatResolution(format);

    var from = Moment__default['default'].utc(timeRequested).startOf(timeResolution);
    var to = Moment__default['default'].utc(timeRequested).endOf(timeResolution);
    return _templateTimeTravel(time, time, from, to, false);
  }

  Time.lowestFormatResolution = function (format) {
    return _lowestFormatResolution(format);
  };

  Time.timeResolution = function (resolution) {
    return _timeResolution(resolution);
  };

  Time.isSampling = function (timeDefinition) {
    return _isSampling(timeDefinition);
  };

  Time.isDistinctValue = function (timeDefinition) {
    return _isDistinctValue(timeDefinition);
  };

  Time.parse = function (time) {
    var result;

    if (_isTimeTravel(time)) {
      result = _templateTimeTravel(time.date, time.display, time.period.from, time.period.to, true);
    } else if (_isPeriod(time)) {
      result = _templateTimeTravel(time.from, time.from, time.from, time.to, false);
    } else if (_isOpenedInterval(time)) {
      result = _templateTimeTravel(time.from, time.from, time.from, Moment__default['default'](), false);
    } else if (_isDateString(time)) {
      result = _convertStringDateToTime(time);
    } else if (_isDate(time)) {
      result = _convertStringDateToTime(time.toISOString());
    } else {
      throw new Error("Unsupported time format");
    }

    return new Time(result);
  };

  Time.prototype.isEqual = function (singleTimeDefinition) {
    var singleTimeMoment = _convertMoment(singleTimeDefinition);

    var isEqual = _isEqual(this.date, singleTimeMoment);

    if (isEqual) {
      var format = singleTimeMoment.creationData().format;
      this.display = singleTimeMoment.format(format);
    }

    return isEqual;
  };

  Time.prototype.isInSampling = function (samplingTimeDefinition) {
    samplingTimeDefinition = samplingTimeDefinition.trim();
    var minMaxStepTimeDef = samplingTimeDefinition.split("/");

    var startDateTimeDef = _convertMoment(minMaxStepTimeDef[0]);

    var stopDateTimeDef = _convertMoment(minMaxStepTimeDef[1]);

    var stepDateTimeDef = minMaxStepTimeDef[2];

    var timeResolutionDef = _timeResolution(stepDateTimeDef);

    var nbValues = Math.floor(stopDateTimeDef.diff(startDateTimeDef, timeResolutionDef.unit) / parseInt(timeResolutionDef.step));

    var idx = _binarySearch(this.date, this.period, startDateTimeDef, nbValues, timeResolutionDef);

    var isFound;

    if (idx === -1) {
      isFound = false;
    } else {
      isFound = true;
      var format = startDateTimeDef.creationData().format;
      this.display = Moment__default['default'].utc(startDateTimeDef).add(idx * timeResolutionDef.step, timeResolutionDef.unit).format(format);
    }

    return isFound;
  };

  Time.prototype.isInTimeDefinition = function (timeDefinition) {
    timeDefinition = timeDefinition.trim();
    var dataTime, timeIdx;
    var isInside = false;
    var times = timeDefinition.split(",");

    for (timeIdx = 0; timeIdx < times.length && !isInside; timeIdx++) {
      dataTime = times[timeIdx].trim();

      if (_isDistinctValue(dataTime)) {
        isInside = this.isEqual(dataTime);
      } else if (_isSampling(dataTime)) {
        isInside = this.isInSampling(dataTime);
      } else {
        throw new Error("Unknown timeDefinition format");
      }
    }

    return isInside;
  };

  Time.prototype.getDisplayValue = function () {
    return this.display;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  var simple_colors = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
  var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
  var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;
  /**************************************************************************************************************/

  /**
   @name FeatureStyle
   @class
       The style to display a Feature
   @param {JSON} style an object containing the following style properties
   <ul>
   <li>strokeColor : the color for line, or polygon outline</li>
   <li>strokeWidth : the width of a line</li>
   <li>fillColor : the color for solid polygon or point</li>
   <li>fillTextureUrl : the texture for solid polygon</li>
   <li>iconUrl : the icon to be used for point</li>
   <li>label : label to display on the map</li>
   <li>textColor : text color of the label</li>
   <li>pointMaxSize : Distance maximum (in meter) from the ground to the camera for which a point is displayed</li>
   <li>opacity : opacity</li>
   <li>zIndex : zIndex</li>     
   <li>extrusionScale : extrusion scale (in meter)</li>
   </ul>
   @constructor
   */

  var FeatureStyle = function (style) {
    // Color used for lines or polygon outline
    this.strokeColor = [1.0, 0.0, 0.0, 1.0]; // Color used to fill polygon

    this.fillColor = [1.0, 0.0, 0.0, 1.0];
    this.fillTextureUrl = null;
    this.fillTexture = null;
    this.fillShader = null;
    this.strokeWidth = 1;
    this.iconUrl = null;
    this.icon = null;
    this.label = null;
    this.textColor = [1.0, 1.0, 1.0, 1.0];
    this.fill = false;
    this.pointMaxSize = 40;
    this.opacity = 1.0;
    this.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
    this.extrusionScale = 1.0;
    this.onTerrain = true;

    if (style) {
      for (var s in style) {
        if (style.hasOwnProperty(s)) {
          this[s] = style[s];
        }
      }
    }
  };
  /**
   Convert a color from a string to RGB
   @function fromStringToColor
   @memberof FeatureStyle
   @param {string} color_string Color string
   @return {float[]} array with [r,g,b,alpha]
   */


  FeatureStyle.fromStringToColor = function (color_string) {
    var r = 0,
        g = 0,
        b = 0,
        a = 255;
    var match;
    color_string = color_string.trim();
    color_string = color_string.toLowerCase(); // strip any leading #

    if (color_string.charAt(0) === "#") {
      // remove # if any
      color_string = color_string.substr(1, 6);
    } // Convert a litteral color to rgb string


    if (simple_colors.hasOwnProperty(color_string)) {
      color_string = simple_colors[color_string];
    }

    match = parseHex.exec(color_string);

    if (match) {
      r = parseInt(match[1], 16);
      g = parseInt(match[2], 16);
      b = parseInt(match[3], 16);
    }

    match = parseRgb.exec(color_string);

    if (match) {
      r = parseInt(match[1], 10);
      g = parseInt(match[2], 10);
      b = parseInt(match[3], 10);
    }

    match = parseRgba.exec(color_string);

    if (match) {
      r = parseInt(match[1], 10);
      g = parseInt(match[2], 10);
      b = parseInt(match[3], 10);
      a = parseInt(match[4], 10);
    } // validate/cleanup values


    r = r < 0 ? 0 : r > 255 ? 255 : r;
    g = g < 0 ? 0 : g > 255 ? 255 : g;
    b = b < 0 ? 0 : b > 255 ? 255 : b;
    a = a < 0 ? 0 : a > 255 ? 255 : a;
    return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
  };
  /**************************************************************************************************************/

  /**
   Convert an internal color to a string based color representation
   @function fromColorToString
   @memberof FeatureStyle
   @param {float[]} color array with [r,g,b]
   @return {string}Color string
   */


  FeatureStyle.fromColorToString = function (color) {
    var hashColor = "#";

    for (var i = 0; i < 3; i++) {
      var component = parseInt(color[i] * 255.0, 10).toString(16);
      hashColor += component < 10 ? "0" + component : component;
    }

    return hashColor;
  };

  FeatureStyle.prototype.getStrokeColor = function () {
    return this.strokeColor;
  };

  FeatureStyle.prototype.setStrokeColor = function (strokeColor) {
    this.strokeColor = strokeColor;
    return this.strokeColor;
  };

  FeatureStyle.prototype.getFillColor = function () {
    return this.fillColor;
  };

  FeatureStyle.prototype.setFillColor = function (fillColor) {
    this.fillColor = fillColor;
    return this.fillColor;
  };

  FeatureStyle.prototype.getFillTextureURL = function () {
    return this.fillTextureUrl;
  };

  FeatureStyle.prototype.setFillTextureURL = function (fillTextureURL) {
    this.fillTextureUrl = fillTextureURL;
    return this.fillTextureUrl;
  };

  FeatureStyle.prototype.getFillTexture = function () {
    return this.fillTexture;
  };

  FeatureStyle.prototype.setFillTexture = function (fillTexture) {
    this.fillShader = fillTexture;
    return this.fillShader;
  };

  FeatureStyle.prototype.getFillShader = function () {
    return this.fillShader;
  };

  FeatureStyle.prototype.setFillShader = function (fillShader) {
    this.fillShader = fillShader;
    return this.fillShader;
  };

  FeatureStyle.prototype.getStrokeWidth = function () {
    return this.strokeWidth;
  };

  FeatureStyle.prototype.setStrokeWidth = function (strokeWidth) {
    this.strokeWidth = strokeWidth;
    return this.strokeWidth;
  };

  FeatureStyle.prototype.getIconURL = function () {
    return this.iconUrl;
  };

  FeatureStyle.prototype.setIconURL = function (iconURL) {
    this.iconUrl = iconURL;
    return this.iconUrl;
  };

  FeatureStyle.prototype.getIcon = function () {
    return this.icon;
  };

  FeatureStyle.prototype.setIcon = function (icon) {
    this.icon = icon;
  };

  FeatureStyle.prototype.getLabel = function () {
    return this.label;
  };

  FeatureStyle.prototype.setLabel = function (label) {
    this.label = label;
  };

  FeatureStyle.prototype.getTextColor = function () {
    return this.textColor;
  };

  FeatureStyle.prototype.setTextColor = function (textColor) {
    this.textColor = textColor;
    return this.textColor;
  };

  FeatureStyle.prototype.isFill = function () {
    return this.isFill;
  };

  FeatureStyle.prototype.setFill = function (isFill) {
    this.isFill = isFill;
    return this.isFill;
  };

  FeatureStyle.prototype.getPointMaxSize = function () {
    return this.pointMaxSize;
  };

  FeatureStyle.prototype.setPointMaxSize = function (pointMaxSize) {
    this.pointMaxSize = pointMaxSize;
  };

  FeatureStyle.prototype.getOpacity = function () {
    return this.opacity;
  };

  FeatureStyle.prototype.setOpacity = function (opacity) {
    if (typeof opacity === "number") {
      this.opacity = Math.min(1.0, Math.max(0.0, opacity));
    } else {
      throw new RangeError("AbstractLayer.js: opacity value should be a value in [0..1]");
    }
  };

  FeatureStyle.prototype.getZIndex = function () {
    return this.zIndex;
  };

  FeatureStyle.prototype.setZIndex = function (zIndex) {
    this.zIndex = zIndex;
    return this.zIndex;
  };
  /**
   * Get extrusion scale
   * @function getExtrusionScale
   * @memberof FeatureStyle.prototype
   *
   * @return {float} Extrusion scale
   */


  FeatureStyle.prototype.getExtrusionScale = function () {
    return this.extrusionScale;
  };
  /**
   * Set extrusion scale
   * @function setExtrusionScale
   * @memberof FeatureStyle.prototype
   *
   * @param {float} value Extrusion scale
   */


  FeatureStyle.prototype.setExtrusionScale = function (value) {
    this.extrusionScale = value;
  };

  FeatureStyle.prototype.isOnTerrain = function (value) {
    return this.onTerrain;
  };

  FeatureStyle.prototype.setOnTerrain = function (value) {
    this.onTerrain = value;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  var transferFonctions = {
    linear: [],
    asin: [],
    sqrt: [],
    sqr: [],
    log: []
  };

  var computeTransferFunctions = function () {
    for (var x in transferFonctions) {
      if (transferFonctions.hasOwnProperty(x)) {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        var v;
        var val = [];

        for (var i = 0; i < 256; i++) {
          v = i;

          switch (x) {
            case "linear":
              val[i] = v;
              break;

            case "asin":
              val[i] = Math.log(v + Math.sqrt(Math.pow(v, 2) + 1.0));
              break;

            case "log":
              val[i] = Math.log(v / 10.0 + 1);
              break;

            case "sqrt":
              val[i] = Math.sqrt(v / 10.0);
              break;

            case "sqr":
              val[i] = v * v;
              break;
          }

          if (val[i] < min) {
            min = val[i];
          }

          if (val[i] > max) {
            max = val[i];
          }
        } // Normalize between [0..256]


        for (i = 0; i < 256; i++) {
          v = 256 * ((val[i] - min) / (max - min)); // Clamp

          if (v > 256.0) {
            v = 256.0;
          } else if (v < 0.0) {
            v = 0.0;
          }

          transferFonctions[x][i] = Math.floor(v);
        }
      }
    }
  };

  computeTransferFunctions(); // Contstant colormaps

  var colormaps = {
    // composantes de la table 'Fire' (ImageJ)
    fire: {
      red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 98, 101, 104, 107, 110, 113, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 148, 150, 152, 154, 156, 158, 160, 162, 163, 164, 166, 167, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 184, 185, 186, 188, 189, 190, 192, 193, 195, 196, 198, 199, 201, 202, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 220, 221, 223, 224, 226, 227, 229, 230, 231, 233, 234, 235, 237, 238, 240, 241, 243, 244, 246, 247, 249, 250, 252, 252, 252, 253, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
      green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 5, 7, 8, 10, 12, 14, 16, 19, 21, 24, 27, 29, 32, 35, 37, 40, 43, 46, 48, 51, 54, 57, 59, 62, 65, 68, 70, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101, 103, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 134, 136, 138, 140, 141, 143, 145, 147, 148, 150, 152, 154, 155, 157, 159, 161, 162, 164, 166, 168, 169, 171, 173, 175, 176, 178, 180, 182, 184, 186, 188, 190, 191, 193, 195, 197, 199, 201, 203, 205, 206, 208, 210, 212, 213, 215, 217, 219, 220, 222, 224, 226, 228, 230, 232, 234, 235, 237, 239, 241, 242, 244, 246, 248, 248, 249, 250, 251, 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
      blue: [0, 7, 15, 22, 30, 38, 45, 53, 61, 65, 69, 74, 78, 82, 87, 91, 96, 100, 104, 108, 113, 117, 121, 125, 130, 134, 138, 143, 147, 151, 156, 160, 165, 168, 171, 175, 178, 181, 185, 188, 192, 195, 199, 202, 206, 209, 213, 216, 220, 220, 221, 222, 223, 224, 225, 226, 227, 224, 222, 220, 218, 216, 214, 212, 210, 206, 202, 199, 195, 191, 188, 184, 181, 177, 173, 169, 166, 162, 158, 154, 151, 147, 143, 140, 136, 132, 129, 125, 122, 118, 114, 111, 107, 103, 100, 96, 93, 89, 85, 82, 78, 74, 71, 67, 64, 60, 56, 53, 49, 45, 42, 38, 35, 31, 27, 23, 20, 16, 12, 8, 5, 4, 3, 3, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 13, 17, 21, 26, 30, 35, 42, 50, 58, 66, 74, 82, 90, 98, 105, 113, 121, 129, 136, 144, 152, 160, 167, 175, 183, 191, 199, 207, 215, 223, 227, 231, 235, 239, 243, 247, 251, 255, 255, 255, 255, 255, 255, 255, 255]
    },
    // composantes de la table EOSB (IDL color table 27)
    eosb: {
      red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 18, 27, 36, 45, 49, 57, 72, 81, 91, 100, 109, 118, 127, 136, 131, 139, 163, 173, 182, 191, 200, 209, 218, 227, 213, 221, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 253, 251, 249, 247, 245, 243, 241, 215, 214, 235, 234, 232, 230, 228, 226, 224, 222, 198, 196, 216, 215, 213, 211, 209, 207, 205, 203, 181, 179, 197, 196, 194, 192, 190, 188, 186, 184, 164, 162, 178, 176, 175, 173, 171, 169, 167, 165, 147, 145, 159, 157, 156, 154, 152, 150, 148, 146, 130, 128, 140, 138, 137, 135, 133, 131, 129, 127, 113, 111, 121, 119, 117, 117],
      green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 15, 23, 31, 39, 47, 55, 57, 64, 79, 87, 95, 103, 111, 119, 127, 135, 129, 136, 159, 167, 175, 183, 191, 199, 207, 215, 200, 207, 239, 247, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 250, 246, 242, 238, 233, 229, 225, 198, 195, 212, 208, 204, 199, 195, 191, 187, 182, 160, 156, 169, 165, 161, 157, 153, 148, 144, 140, 122, 118, 127, 125, 123, 121, 119, 116, 114, 112, 99, 97, 106, 104, 102, 99, 97, 95, 93, 91, 80, 78, 84, 82, 80, 78, 76, 74, 72, 70, 61, 59, 63, 61, 59, 57, 55, 53, 50, 48, 42, 40, 42, 40, 38, 36, 33, 31, 29, 27, 22, 21, 21, 19, 16, 14, 12, 13, 8, 6, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      blue: [116, 121, 127, 131, 136, 140, 144, 148, 153, 157, 145, 149, 170, 174, 178, 182, 187, 191, 195, 199, 183, 187, 212, 216, 221, 225, 229, 233, 238, 242, 221, 225, 255, 247, 239, 231, 223, 215, 207, 199, 172, 164, 175, 167, 159, 151, 143, 135, 127, 119, 100, 93, 95, 87, 79, 71, 63, 55, 47, 39, 28, 21, 15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    // tableau des composantes pour Stern
    stern: {
      red: [0, 18, 36, 54, 72, 90, 108, 127, 145, 163, 199, 217, 235, 254, 249, 244, 239, 234, 229, 223, 218, 213, 208, 203, 197, 192, 187, 182, 177, 172, 161, 156, 151, 146, 140, 135, 130, 125, 120, 115, 109, 104, 99, 94, 89, 83, 78, 73, 68, 63, 52, 47, 42, 37, 32, 26, 21, 16, 11, 6, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254],
      green: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254],
      blue: [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 105, 107, 109, 111, 113, 115, 117, 119, 121, 123, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 191, 193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 255, 251, 247, 243, 238, 234, 230, 226, 221, 217, 209, 204, 200, 196, 192, 187, 183, 179, 175, 170, 166, 162, 158, 153, 149, 145, 141, 136, 132, 128, 119, 115, 111, 107, 102, 98, 94, 90, 85, 81, 77, 73, 68, 64, 60, 56, 51, 47, 43, 39, 30, 26, 22, 17, 13, 9, 5, 0, 3, 7, 15, 19, 22, 26, 30, 34, 38, 41, 45, 49, 57, 60, 64, 68, 72, 76, 79, 83, 87, 91, 95, 98, 102, 106, 110, 114, 117, 121, 125, 129, 137, 140, 144, 148, 152, 156, 159, 163, 167, 171, 175, 178, 182, 186, 190, 194, 197, 201, 205, 209, 216, 220, 224, 228, 232, 235, 239, 243, 247, 251]
    },
    // composantes de la table rainbow (IDL color table 13)
    rainbow: {
      red: [0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 45, 50, 54, 58, 61, 64, 68, 69, 72, 74, 77, 79, 80, 82, 83, 85, 84, 86, 87, 88, 86, 87, 87, 87, 85, 84, 84, 84, 83, 79, 78, 77, 76, 71, 70, 68, 66, 60, 58, 55, 53, 46, 43, 40, 36, 33, 25, 21, 16, 12, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 21, 25, 29, 33, 42, 46, 51, 55, 63, 67, 72, 76, 80, 89, 93, 97, 101, 110, 114, 119, 123, 131, 135, 140, 144, 153, 157, 161, 165, 169, 178, 182, 187, 191, 199, 203, 208, 212, 221, 225, 229, 233, 242, 246, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
      green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 16, 21, 25, 29, 38, 42, 46, 51, 55, 63, 67, 72, 76, 84, 89, 93, 97, 106, 110, 114, 119, 127, 131, 135, 140, 144, 152, 157, 161, 165, 174, 178, 182, 187, 195, 199, 203, 208, 216, 220, 225, 229, 233, 242, 246, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 250, 242, 238, 233, 229, 221, 216, 212, 208, 199, 195, 191, 187, 178, 174, 170, 165, 161, 153, 148, 144, 140, 131, 127, 123, 119, 110, 106, 102, 97, 89, 85, 80, 76, 72, 63, 59, 55, 51, 42, 38, 34, 29, 21, 17, 12, 8, 0],
      blue: [0, 3, 7, 10, 14, 19, 23, 28, 32, 38, 43, 48, 53, 59, 63, 68, 72, 77, 81, 86, 91, 95, 100, 104, 109, 113, 118, 122, 127, 132, 136, 141, 145, 150, 154, 159, 163, 168, 173, 177, 182, 186, 191, 195, 200, 204, 209, 214, 218, 223, 227, 232, 236, 241, 245, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 246, 242, 238, 233, 225, 220, 216, 212, 203, 199, 195, 191, 187, 178, 174, 170, 165, 157, 152, 148, 144, 135, 131, 127, 123, 114, 110, 106, 102, 97, 89, 84, 80, 76, 67, 63, 59, 55, 46, 42, 38, 34, 25, 21, 16, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    // Simple grey levels
    grey: {
      red: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
      green: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
      blue: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]
    }
  };
  /**
   *    Create texture from array
   *    TODO : maybe move this function to renderContext ?
   *
   *    @param gl Context
   *    @param dataArray Array creating the texture
   *    @param format Content format(gl.LUMINANCE, gl.RGB...)
   *    @param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
   *    @param width Width of texture
   *    @param height Height of texture
   *
   *    @return GLTexture, or null caused by not supported format
   */

  function _textureFromPixelArray(gl, dataArray, format, dataType, width, height) {
    var dataTypedArray;

    if (dataType === gl.UNSIGNED_BYTE) {
      dataTypedArray = new Uint8Array(dataArray);
    } else {
      if (dataType === gl.FLOAT) {
        dataTypedArray = new Float32Array(dataArray);
      } else {
        return null;
      }
    }

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, dataType, dataTypedArray); // NPOT properties

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
  }

  var ColorMap = {
    /**
     *    Create custom colormap with equidistant intervals
     *
     *    @param name Colormap name
     *    @param colors The array of colors defining the colormap(must have length at least >=2)
     */
    addCustomColormap: function (name, colors) {
      if (colors.length < 2) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "ColorMap.js", "Colors length must be >= 2");
        return null;
      }

      var colormapSize = 256;
      var colormap = {
        red: [],
        green: [],
        blue: []
      };
      var nbIntervals = colors.length - 1;

      for (var i = 0; i < nbIntervals; i++) {
        var c1 = colors[i];
        var c2 = colors[i + 1];
        var intervalLength = colormapSize / (colors.length - 1);
        var start = colormap.red.length;
        var end = Math.floor((i + 1) * intervalLength);

        for (var j = start; j < end; j++) {
          colormap.red.push(Numeric.lerp(j / end, c1[0], c2[0]));
          colormap.green.push(Numeric.lerp(j / end, c1[1], c2[1]));
          colormap.blue.push(Numeric.lerp(j / end, c1[2], c2[2]));
        }
      } // Add to colormaps object


      colormaps[name] = colormap;
    },

    /**
     * Generate colormap
     */
    generateColormap: function (gl, transferFonction, colormap, inverse) {
      // var pas1 = 128./(tr1-tr0);
      // var pas2 = 128./(tr2-tr1);
      // Get transfer function
      var fctGap = transferFonctions[transferFonction];
      var cm = [];
      var Sr, Sg, Sb;
      Sr = colormaps[colormap].red;
      Sg = colormaps[colormap].green;
      Sb = colormaps[colormap].blue;
      var max = Sr.length - 1;

      for (var i = 0; i < 256; i++) {
        // int j= i<tr0 ? 0 :
        //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
        //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
        //               max;
        var j = fctGap[i]; // Clamp

        if (j > max) {
          j = max;
        } else {
          if (j < 0) {
            j = 0;
          }
        }

        if (inverse) {
          j = max - j;
        } // Normalize between [0..1]


        cm[i * 3] = Sr[j] / 256.0;
        cm[i * 3 + 1] = Sg[j] / 256.0;
        cm[i * 3 + 2] = Sb[j] / 256.0;
      } // Create new texture


      return _textureFromPixelArray(gl, cm, gl.RGB, gl.FLOAT, cm.length / 3, 1);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/
  // TODO : Unify shader programs between TileManager, ConvexPolygonRenderer and ImageRenderer
  //		* inverse Y coordinates(if needed)
  //		* vTextureCoord name refactor

  var defaultFragmentCode = "precision highp float; \n";
  defaultFragmentCode += "varying vec2 vTextureCoord;\n";
  defaultFragmentCode += "uniform sampler2D texture; \n";
  defaultFragmentCode += "uniform sampler2D colormap; \n";
  defaultFragmentCode += "uniform float min; \n";
  defaultFragmentCode += "uniform float max; \n";
  defaultFragmentCode += "uniform vec4 color; \n";
  defaultFragmentCode += "void main(void)\n";
  defaultFragmentCode += "{\n";
  defaultFragmentCode += "	float i = texture2D(texture,vTextureCoord).r;\n";
  defaultFragmentCode += "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
  defaultFragmentCode += "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
  defaultFragmentCode += "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b,color.a);\n";
  defaultFragmentCode += "}\n";

  var defaultCallback = function (gl, renderable, program) {
    if (!program) {
      program = renderable.polygonProgram;
    }

    gl.uniform1f(program.uniforms.max, renderable.style.uniformValues.tmax);
    gl.uniform1f(program.uniforms.min, renderable.style.uniformValues.tmin);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, renderable.style.uniformValues.colormapTex);
    gl.uniform1i(program.uniforms.colormap, 1);
  };
  /**************************************************************************************************************/

  /**
  	 @name DynamicImage
  	 @class
  		DynamicImage constructor
  	 @param renderContext
  	 @param pixels
  	 @param format
  	 @param dataType
  	 @param width
  	 @param height
  	 @param options
  	 @constructor
  	 */


  var DynamicImage = function (renderContext, pixels, format, dataType, width, height, options) {
    // Initialize fragment shader and uniformsCallback if needed
    defaultFragmentCode = options && options.fragmentCode ? options.fragmentCode : defaultFragmentCode;
    defaultCallback = options && options.updateUniforms ? options.updateUniforms : defaultCallback;
    this.fragmentCode = defaultFragmentCode;
    this.updateUniforms = defaultCallback;
    this.tmin = 0.0;
    this.tmax = 1.0;
    this.colormapTex = null;
    this.renderContext = renderContext; // Parameters for histogram generation

    this.pixels = pixels;
    this.transferFn = "raw";
    this.inverse = false; // Create texture

    var gl = renderContext.gl;
    var tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex); // TODO : Flip around X axis
    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, dataType, pixels);

    if (dataType === gl.FLOAT) {
      // Choose floating point texture filtering depending on extension support
      var float_linear_ext = gl.getExtension("OES_texture_float_linear");
      var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } // NPOT properties


    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    this.texture = tex;
    this.width = width;
    this.height = height;
    this.computeMinMax(pixels);
    renderContext.requestFrame();
  };
  /**************************************************************************************************************/

  /**
   * Compute min/max of fits data
   * @function computeMinMax
   * @memberof DynamicImage.prototype
   * @param pixels Fits data
   */


  DynamicImage.prototype.computeMinMax = function (pixels) {
    var max = Number.MIN_VALUE;
    var min = Number.MAX_VALUE;

    for (var i = 1; i < pixels.length; i++) {
      var val = pixels[i];

      if (isNaN(val)) {
        continue;
      }

      if (max < val) {
        max = val;
      }

      if (min > val) {
        min = val;
      }
    }

    this.min = min;
    this.max = max;
    this.tmax = max;
    this.tmin = min;
  };
  /**************************************************************************************************************/

  /**
   * Update colormap of current image
   * @function updateColormap
   * @memberof DynamicImage.prototype
   * @param transferFn Transfer function("linear", "log", "sqrt", "pow2", "asin")
   * @param colormap Colormap("grey", "rainbow", "fire", "stern", "eosb")
   * @param inverse Boolean indicating if colormap is inversed
   */


  DynamicImage.prototype.updateColormap = function (transferFn, colormap, inverse) {
    var gl = this.renderContext.gl;

    if (transferFn !== "raw") {
      this.fragmentCode = defaultFragmentCode;
      this.updateUniforms = defaultCallback; // Dispose current texture

      if (this.colormapTex) {
        gl.deleteTexture(this.colormapTex);
      }

      this.colormapTex = ColorMap.generateColormap(gl, transferFn, colormap, inverse);
    } else {
      this.fragmentCode = null;
      this.updateUniforms = null;
    }

    this.transferFn = transferFn;
    this.inverse = inverse;
  };
  /**************************************************************************************************************/

  /**
   * Dispose textures
   * @function dispose
   * @memberof DynamicImage.prototype
   */


  DynamicImage.prototype.dispose = function () {
    var gl = this.renderContext.gl;

    if (this.colormapTex) {
      gl.deleteTexture(this.colormapTex);
    }

    if (this.texture) {
      gl.deleteTexture(this.texture);
    }

    this.colormapTex = null;
    this.texture = null;
  };

  // Generated by CoffeeScript 2.5.1
  // Note: modified to be exported as a module
  function astro() {
    var Base, FITS, Parser; // if (this.astro == null) {

    this.astro = {}; // }

    Base = class Base {
      static include(obj) {
        var key, value;

        for (key in obj) {
          value = obj[key];
          this.prototype[key] = value;
        }

        return this;
      }

      static extend(obj) {
        var key, value;

        for (key in obj) {
          value = obj[key];
          this[key] = value;
        }

        return this;
      }

      proxy(func) {
        return () => {
          return func.apply(this, arguments);
        };
      }

      invoke(callback, opts, data) {
        var context;
        context = (opts != null ? opts.context : void 0) != null ? opts.context : this;

        if (callback != null) {
          return callback.call(context, data, opts);
        }
      }

    };

    Parser = function () {
      class Parser extends Base {
        // FITS objects are constructed using either
        // 1) Path to a remote FITS file
        // 2) Native File object
        // First argument is either a path or File object
        // Second argument is a callback to execute after
        // initialization is complete
        // Third argument is a set of options that may be passed
        // to the callback.  If opts has the context key, the callback
        // is executed with respect to that context.
        constructor(arg, callback1, opts1) {
          var xhr;
          super();
          this.arg = arg;
          this.callback = callback1;
          this.opts = opts1; // Storage for header dataunits

          this.hdus = []; // Set initial state for parsing buffer
          // Blocks of 2880 will be read until an entire header is read.
          // The process will be repeated until all headers have been parsed from file.
          // Number of 2880 blocks read.  This is reset every time an entire header is extracted.

          this.blockCount = 0; // Byte offsets relative to the current header

          this.begin = 0;
          this.end = this.BLOCKLENGTH; // Byte offset relative to the file

          this.offset = 0; // Initial storage for storing header while parsing.

          this.headerStorage = new Uint8Array(); // Check the input type for either
          // 1) Path to remote file
          // 2) Native File object

          if (typeof this.arg === "string") {
            // Define function at runtime for getting next block
            this.readNextBlock = this._readBlockFromBuffer; // Get the remote file as an arraybuffer

            xhr = new XMLHttpRequest();
            xhr.open("GET", this.arg);
            xhr.responseType = "arraybuffer";

            xhr.onload = () => {
              // Error handling on the response status
              if (xhr.status !== 200) {
                // Execute callback returning a null object on failure
                this.invoke(this.callback, this.opts);
                return;
              } // Get buffer from response


              this.arg = xhr.response; // Store the buffer byte length

              this.length = this.arg.byteLength; // Begin reading buffer

              return this.readFromBuffer();
            }; // Send the request


            xhr.send();
          } else {
            // Store the file byte length
            this.length = this.arg.size; // Define function at runtime for getting next block

            this.readNextBlock = this._readBlockFromFile; // Get the local file as an arraybuffer

            this.readFromFile();
          }
        } // Interpret an array buffer that is already copied in memory.  Usually
        // used for remote files, though this can be used for local files if
        // the arraybuffer is already in memory.


        readFromBuffer() {
          var block; // Get first 2880 block

          block = this.arg.slice(this.begin + this.offset, this.end + this.offset); // Begin parsing for headers

          return this.readBlock(block);
        } // Read a file by copying only the headers into memory.  This is needed
        // to handle large files efficiently.


        readFromFile() {
          var block; // Initialize a new FileReader

          this.reader = new FileReader(); // Set reader handler

          this.reader.onloadend = e => {
            return this.readBlock(e.target.result);
          }; // Get first 2880 block


          block = this.arg.slice(this.begin + this.offset, this.end + this.offset); // Begin parsing for headers

          return this.reader.readAsArrayBuffer(block);
        } // Read a 2880 size block. Function is responsible for storing block,
        // searching for END marker, initializing an HDU, and clearing storage.


        readBlock(block) {
          var arr, dataLength, dataunit, header, i, len, ref, rowIndex, rows, s, slice, tmp, value; // Read block as integers

          arr = new Uint8Array(block); // Temporary storage for header

          tmp = new Uint8Array(this.headerStorage); // Reallocate header storage

          this.headerStorage = new Uint8Array(this.end); // Copy contents from temporary storage

          this.headerStorage.set(tmp, 0); // Copy contents from current iteration

          this.headerStorage.set(arr, this.begin); // Check current array one row at a time starting from
          // bottom of the block.

          rows = this.BLOCKLENGTH / this.LINEWIDTH;

          while (rows--) {
            // Get index of first element in row
            rowIndex = rows * this.LINEWIDTH;

            if (arr[rowIndex] === 32) {
              // Go to next row if whitespace found
              continue;
            } // Check for END keyword with trailing space (69, 78, 68, 32)


            if (arr[rowIndex] === 69 && arr[rowIndex + 1] === 78 && arr[rowIndex + 2] === 68 && arr[rowIndex + 3] === 32) {
              // Interpret as string
              s = "";
              ref = this.headerStorage;

              for (i = 0, len = ref.length; i < len; i++) {
                value = ref[i];
                s += String.fromCharCode(value);
              }

              header = new Header(s); // Get data unit start and length

              this.start = this.end + this.offset;
              dataLength = header.getDataLength(); // Create data unit instance

              slice = this.arg.slice(this.start, this.start + dataLength);

              if (header.hasDataUnit()) {
                dataunit = this.createDataUnit(header, slice);
              } // Store HDU on instance


              this.hdus.push(new HDU(header, dataunit)); // Update byte offset

              this.offset += this.end + dataLength + this.excessBytes(dataLength); // Return if at the end of file

              if (this.offset === this.length) {
                this.headerStorage = null;
                this.invoke(this.callback, this.opts, this);
                return;
              } // Reset variables for next header


              this.blockCount = 0;
              this.begin = this.blockCount * this.BLOCKLENGTH;
              this.end = this.begin + this.BLOCKLENGTH;
              this.headerStorage = new Uint8Array(); // Get next block

              block = this.arg.slice(this.begin + this.offset, this.end + this.offset); // Begin parsing for next header

              this.readNextBlock(block);
              return;
            }

            break;
          } // Read next block since END not found


          this.blockCount += 1;
          this.begin = this.blockCount * this.BLOCKLENGTH;
          this.end = this.begin + this.BLOCKLENGTH;
          block = this.arg.slice(this.begin + this.offset, this.end + this.offset);
          this.readNextBlock(block);
        } // Use one of these depending on the initialization parameter (File or ArrayBuffer)


        _readBlockFromBuffer(block) {
          return this.readBlock(block);
        }

        _readBlockFromFile(block) {
          return this.reader.readAsArrayBuffer(block);
        } // Create the appropriate data unit based on info from header


        createDataUnit(header, blob) {
          var type;
          type = header.getDataType();
          return new astro.FITS[type](header, blob);
        } // Determine the number of characters following a header or data unit


        excessBytes(length) {
          return (this.BLOCKLENGTH - length % this.BLOCKLENGTH) % this.BLOCKLENGTH;
        } // Check for the end of file


        isEOF() {
          if (this.offset === this.length) {
            return true;
          } else {
            return false;
          }
        }

      }

      Parser.prototype.LINEWIDTH = 80;
      Parser.prototype.BLOCKLENGTH = 2880; // Prefix function for Safari :(

      File.prototype.slice = File.prototype.slice || File.prototype.webkitSlice;
      Blob.prototype.slice = Blob.prototype.slice || Blob.prototype.webkitSlice;
      return Parser;
    }.call(this);

    FITS = class FITS extends Base {
      constructor(arg, callback, opts) {
        var parser;
        super();
        this.arg = arg;
        parser = new Parser(this.arg, fits => {
          this.hdus = parser.hdus;
          return this.invoke(callback, opts, this);
        });
      } // Public API
      // Returns the first HDU containing a data unit.  An optional argument may be passed to retreive
      // a specific HDU


      getHDU(index) {
        var hdu, i, len, ref;

        if (index != null && this.hdus[index] != null) {
          return this.hdus[index];
        }

        ref = this.hdus;

        for (i = 0, len = ref.length; i < len; i++) {
          hdu = ref[i];

          if (hdu.hasData()) {
            return hdu;
          }
        }
      } // Returns the header associated with the first HDU containing a data unit.  An optional argument
      // may be passed to point to a specific HDU.


      getHeader(index) {
        return this.getHDU(index).header;
      } // Returns the data object associated with the first HDU containing a data unit.  This method does not read from the array buffer
      // An optional argument may be passed to point to a specific HDU.


      getDataUnit(index) {
        return this.getHDU(index).data;
      }

    };
    FITS.version = "0.6.5";
    this.astro.FITS = FITS; // return this.astro;
  }

  var astro$1 = new astro();

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/
  /**
   *    Parse fits file
   *
   *    @param response XHR response containing fits
   *
   *    @return Parsed data
   */

  function parseFits(response) {
    var FITS = astro$1.FITS; // Initialize the FITS.File object using
    // the array buffer returned from the XHR

    var fits = new FITS.File(response); // Grab the first HDU with a data unit

    var hdu = fits.getHDU();
    var data = hdu.data;
    var swapPixels = new Uint8Array(data.view.buffer, data.begin, data.length); // with gl.UNSIGNED_byte

    var bpe;

    if (data.arrayType) {
      bpe = data.arrayType.BYTES_PER_ELEMENT;
    } else {
      bpe = Math.abs(hdu.header.BITPIX) / 8;
    }

    for (var i = 0; i < swapPixels.length; i += bpe) {
      var temp; // Swap to little-endian

      for (var j = 0; j < bpe / 2; j++) {
        temp = swapPixels[i + j];
        swapPixels[i + j] = swapPixels[i + bpe - 1 - j];
        swapPixels[i + bpe - 1 - j] = temp;
      }
    }

    return fits;
  }

  var loadFits = function (url, successCallback, failCallback, onprogressCallback) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if (xhr.response) {
            var fits = parseFits(xhr.response);

            if (successCallback) {
              successCallback(fits);
            }
          }
        } else {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Error while loading " + url);

          if (failCallback) {
            failCallback();
          }
        }
      }
    }; // Define default on progress function, otherwise
    // Firefox won't take Content-length header into account
    // so evt.lengthComputable will be always set to false..


    xhr.onprogress = function (evt) {};

    xhr.open("GET", Proxy.proxify(url));
    xhr.responseType = "arraybuffer";
    xhr.send();
    return xhr;
  };

  var FitsLoader = {
    loadFits: loadFits,
    parseFits: parseFits
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  // import astro from '../external/fitsjs/fits';

  var mizarAPI;
  /**********************************************************************************************/

  /**
   *    Send XHR request for FITS file
   *    @param featureData Feature data(layer,feature)
   *    @param {string} url Url of fits file
   *    @param {Function} preprocessing function if needed
   *    @fires Mizar#image:downloaded
   */

  function computeFits(featureData, url, preprocessing) {
    // Store xhr on feature data object to cancel it if needed
    featureData.xhr = FitsLoader.loadFits(url, function (fits) {
      delete featureData.xhr;
      var fitsData = fits.getHDU().data;

      if (preprocessing) {
        preprocessing(featureData, fits);
      }

      handleFits(fitsData, featureData);
    });
    mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
  }
  /**********************************************************************************************/

  /**
   *    Send XHR request for quicklook file
   *    @param featureData Feature data(layer,feature)
   *    @param {string} url Url of quicklook file
   *    @fires Mizar#image:downloaded
   */


  function computeQuicklook(featureData, url) {
    handleQuicklook(featureData, url);
    mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
  }
  /**********************************************************************************************/

  /**
   * Handle fits data on the given feature
   * @param fitsData
   * @param featureData
   * @returns {Image} image
   */


  function handleFits(fitsData, featureData) {
    // Create new image coming from Fits
    var typedArray = new Float32Array(fitsData.view.buffer, fitsData.begin, fitsData.length / 4); // with gl.FLOAT

    var gl = mizarAPI.getRenderContext().gl;
    var image = new DynamicImage(mizarAPI.getRenderContext(), typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);
    var feature = featureData.feature;
    var layer = featureData.layer; // Attach texture to style

    var targetStyle;

    if (feature.properties.style) {
      targetStyle = new FeatureStyle(feature.properties.style);
    } else {
      targetStyle = new FeatureStyle(layer.style);
    }

    targetStyle.fillTexture = image.texture;
    targetStyle.uniformValues = image;
    targetStyle.fill = true;
    layer.modifyFeatureStyle(feature, targetStyle); // Store image url for zScale processing

    if (feature.services) {
      image.url = feature.services.download.url;
    }

    return image;
  }
  /**
   * Handle quicklook data on the given feature
   * @param featureData
   * @returns {Image} image
   */


  function handleQuicklook(featureData, url) {
    var feature = featureData.feature;
    var layer = featureData.layer;

    if (layer.getType() === Constants.LAYER.OpenSearch) {
      layer.loadQuicklook(feature, url);
    }
  }
  /**********************************************************************************************/


  function parseFits$1(response) {
    return FitsLoader.parseFits(response);
  }
  /**********************************************************************************************/

  /**
   * Remove fits texture from feature
   * @param featureData
   */


  function removeFitsFromRenderer(featureData) {
    // Abort xhr if inprogress
    if (featureData.xhr) {
      featureData.xhr.abort();
      delete featureData.xhr;
    }

    var gl = mizarAPI.getRenderContext().gl;

    if (featureData.feature.properties.style.uniformValues) {
      featureData.feature.properties.style.uniformValues.dispose();
    } // TODO : style could still contain fillTextures, is it normal ?


    var texture = featureData.feature.properties.style.fillTexture;

    if (texture) {
      gl.deleteTexture(texture);
    }

    var targetStyle = new FeatureStyle(featureData.feature.properties.style);
    targetStyle.fillTexture = null;
    targetStyle.fill = false; // Remove rendering

    targetStyle.fillShader = {
      fragmentCode: null,
      updateUniforms: null
    };
    delete targetStyle.uniformValues;
    featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
  }
  /**********************************************************************************************/


  var FitsVisu = {
    /**
     * Initialize ImageManagerCore
     * @param m
     * @param configuration
     */
    init: function (m, configuration) {
      mizarAPI = m;
    },

    /**********************************************************************************************/

    /**
     * Hide image
     * @param {Feature} featureData
     */
    hideImage: function (featureData) {
      var style = new FeatureStyle(featureData.feature.properties.style);
      style.fill = false;
      featureData.layer.modifyFeatureStyle(featureData.feature, style);
    },

    /**********************************************************************************************/

    /**
     * Show image
     * @param {Feature} featureData
     */
    showImage: function (featureData) {
      // Attach texture to style
      var targetStyle = new FeatureStyle(featureData.feature.properties.style);
      targetStyle.fill = true;
      featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
    },

    /**********************************************************************************************/

    /**
     * Remove image from renderer
     * @param {Feature} featureData
     * @fires Mizar#image:removed
     */
    removeImage: function (featureData) {
      // Publish event that the image of the given feature will be removed
      mizarAPI.publish(Constants.EVENT_MSG.IMAGE_REMOVED, featureData);

      if (featureData.isFits) {
        removeFitsFromRenderer(featureData);
        $__default['default']("#quicklookFits").removeClass("selected");
      } else {
        if (featureData.layer.getType() === "OpenSearch") {
          featureData.layer.removeQuicklook();
        } else {
          var style = featureData.feature.properties.style;
          style.fill = false;
          style.fillTextureUrl = null;
          featureData.layer.modifyFeatureStyle(featureData.feature, style);
        }

        $__default['default']("#quicklook").removeClass("selected");
        $__default['default']("#quicklookWms").removeClass("selected");
      }

      mizarAPI.getActivatedContext().refresh();
    },

    /**********************************************************************************************/

    /**
     *    Start download of texture
     *    @param {Feature} featureData
     *    @fires Mizar#image:added
     */
    addImage: function (featureData) {
      var feature = featureData.feature; // Set fill to true while loading

      var style = new FeatureStyle(feature.properties.style);
      var url = null;
      style.fill = true; // Publish event that the image for the given feature will be loaded

      mizarAPI.publish(Constants.EVENT_MSG.IMAGE_ADDED, featureData);

      if (featureData.isFits) {
        url = feature.services.download.url;
        this.computeFits(featureData, url);
        $__default['default']("#quicklookFits").addClass("selected");
      } else {
        style.fill = true;

        if (featureData.isWms) {
          url = feature.properties.services.browse.layer.getUrl();
        } else {
          url = feature.properties.quicklook;
        }

        this.computeQuicklook(featureData, url); // For DEBUG : 'upload/ADP_WFI_30DOR_RGB_V1.0_degraded.jpg';

        if (featureData.isWms) {
          $__default['default']("#quicklookWms").addClass("selected");
        } else {
          $__default['default']("#quicklook").addClass("selected");
        }
      }

      featureData.layer.modifyFeatureStyle(feature, style);
      mizarAPI.getActivatedContext().refresh();
    },
    computeFits: computeFits,
    computeQuicklook: computeQuicklook,
    handleFits: handleFits,
    handleQuicklook: handleQuicklook,
    parseFits: parseFits$1
  };
  /**********************************************************************************************/

  var mizarAPI$1;
  /**
   * Creates a fits layer
   * @param {Layer} layer
   * @fires Context#backgroundLayer:changed
   * @fires Context#backgroundLayer:added
   * @fires Context#layer:added
   * @fires Layer#visibility:changed
   */

  function _createFitsLayer(layer) {
    var isCreated;

    try {
      var selectedLayer = {
        name: layer.getName(),
        type: layer.getType(),
        format: "fits",
        hipsMetadata: layer.getHipsMetadata()
      };
      var fitsLayer = mizarAPI$1.LayerFactory.create(selectedLayer);
      fitsLayer.ID = layer.getID();

      if (layer.isBackground()) {
        mizarAPI$1.getActivatedContext()._getGlobe().setBaseImagery(fitsLayer);
      } else {
        mizarAPI$1.getActivatedContext()._getGlobe().addLayer(fitsLayer);
      }

      fitsLayer.setVisible(true);
      isCreated = true;
      mizarAPI$1.getActivatedContext().publish(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, fitsLayer);
    } catch (e) {
      isCreated = false;
    }

    return isCreated;
  }

  function _removeFitsLayer(ID) {
    var isRemoved;
    var layer = mizarAPI$1.getActivatedContext().getLayerByID(ID);

    if (layer && layer.getFormat() !== "fits") {
      mizarAPI$1.getActivatedContext()._getGlobe().setBaseImagery(layer);

      isRemoved = true;
    } else {
      isRemoved = false;
    }

    return isRemoved;
  }

  var FitsHips = {
    init: function (m, options) {
      mizarAPI$1 = m;
    },
    createFitsLayer: _createFitsLayer,
    removeFitsLayer: _removeFitsLayer
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**
   * Triangle Object use in Histogram classe
   */

  /**************************************************************************************************************/

  /**
   *    Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
   */
  function _sameSide(p1, p2, a, b) {
    var temp1 = [];
    var temp2 = [];
    var temp3 = [];
    var cp1 = [];
    var cp2 = [];
    vec3.cross(vec3.subtract(b, a, temp1), vec3.subtract(p1, a, temp2), cp1);
    vec3.cross(temp1, vec3.subtract(p2, a, temp3), cp2);
    return vec3.dot(cp1, cp2) >= 0;
  }
  /**************************************************************************************************************/

  /**
   *    Private function to check if point is inside the given triangle
   *    If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
   */


  function _pointInTriangle(p, a, b, c) {
    return _sameSide(p, a, b, c) && _sameSide(p, b, a, c) && _sameSide(p, c, a, b);
  }
  /**************************************************************************************************************/

  /**
   *    Isoscele triangle object for thresholds manipulation
   *
   *    @param a Pointer of threshold pointing on histogram
   *    @param b Isoscele point 1
   *    @param c Isoscele point 2
   */


  var Triangle = function (a, b, c) {
    this.initA = a.slice(0);
    this.initB = b.slice(0);
    this.initC = c.slice(0);
    this.a = a; // Pointer to histogram

    this.b = b; // Isoscele point 1

    this.c = c; // Isoscele point 2

    this.dragging = false;
    this.hover = false;
    this.halfWidth = Math.abs((c[0] - b[0]) / 2);
  };
  /**************************************************************************************************************/

  /**
   *    Reset to initial position
   */


  Triangle.prototype.reset = function () {
    this.a = this.initA.slice(0);
    this.b = this.initB.slice(0);
    this.c = this.initC.slice(0);
  };
  /**************************************************************************************************************/

  /**
   *    Test if triangle contains the given point
   *    @param {Array} p point
   */


  Triangle.prototype.contains = function (p) {
    return _pointInTriangle(p, this.a, this.b, this.c);
  };
  /**************************************************************************************************************/

  /**
   * Draw the triangle
   * @param ctx the context
   * @param options
   *      <ul>
   *          <li>draggingColor : color used when moving triangle</li>
   *          <li>noDraggingColor : color used when triangle do not move</li>
   */


  Triangle.prototype.draw = function (ctx, options) {
    if (!options) {
      options = {};
    }

    if (this.dragging) {
      ctx.fillStyle = options.draggingColor || "#FF0";
    } else {
      ctx.fillStyle = options.noDraggingColor || "#F00";
    }

    ctx.beginPath();
    ctx.moveTo(this.a[0], this.a[1]);
    ctx.lineTo(this.b[0], this.b[1]);
    ctx.lineTo(this.c[0], this.c[1]);
    ctx.closePath();
    ctx.fill();

    if (!this.dragging && this.hover) {
      ctx.strokeStyle = options.draggingColor || "#FF0";
      ctx.stroke();
    }
  };
  /**************************************************************************************************************/

  /**
   *    Modify triangle's position by the given "pointer" point
   *    (could be modified only by X-axis)
   *    @param {Array} point point
   */


  Triangle.prototype.modifyPosition = function (point) {
    this.a[0] = point[0];
    this.b[0] = point[0] - this.halfWidth;
    this.c[0] = point[0] + this.halfWidth;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  var nbBins;
  var self$1;
  var canvas;
  var hist = [];
  var hmax; // histogram max to scale in image space
  // Origin histogram point

  var originX;
  var originY;
  var hwidth;
  var paddingBottom;
  var triangleHalfWidth;
  /**************************************************************************************************************/

  /**
   * Get mouse position on canvas
   * @param {HTMLElement} canvas
   * @param {Event} evt
   * @returns {{x: number, y: number}}
   */

  function _getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
      x: evt.offsetX - rect.left,
      y: evt.offsetY - rect.top
    };
  }

  function _handleMouseDown(evt) {
    var mousePos = _getMousePos(canvas, evt);

    if (self$1.minThreshold.contains([mousePos.x, mousePos.y, 0])) {
      self$1.minThreshold.dragging = true;
      self$1.minThreshold.draw(self$1.ctx);
    }

    if (self$1.maxThreshold.contains([mousePos.x, mousePos.y, 0])) {
      self$1.maxThreshold.dragging = true;
      self$1.maxThreshold.draw(self$1.ctx);
    }
  }
  /**************************************************************************************************************/


  function _handleMouseUp(evt) {
    self$1.minThreshold.dragging = false;
    self$1.maxThreshold.dragging = false;

    if (self$1.onUpdate) {
      var min = self$1.getHistValue(self$1.minThreshold.a);
      var max = self$1.getHistValue(self$1.maxThreshold.a);
      self$1.minThreshold.reset();
      self$1.maxThreshold.reset();
      self$1.onUpdate(min, max);
    }
  }
  /**************************************************************************************************************/


  function _handleMouseMove(evt) {
    var mousePos = _getMousePos(canvas, evt);

    self$1.ctx.clearRect(0.0, originY, canvas.width, paddingBottom);
    self$1.minThreshold.hover = self$1.minThreshold.contains([mousePos.x, mousePos.y, 0]);
    self$1.maxThreshold.hover = self$1.maxThreshold.contains([mousePos.x, mousePos.y, 0]); // Draw threshold controls

    if (self$1.minThreshold.dragging && mousePos.x >= self$1.minThreshold.initA[0] && mousePos.x < self$1.maxThreshold.a[0]) {
      self$1.minThreshold.modifyPosition([mousePos.x, self$1.minThreshold.a[1]]);
    }

    if (self$1.maxThreshold.dragging && mousePos.x <= self$1.maxThreshold.initA[0] && mousePos.x > self$1.minThreshold.a[0]) {
      self$1.maxThreshold.modifyPosition([mousePos.x, self$1.maxThreshold.a[1]]);
    }

    self$1.drawThresholdControls(); // Don't draw histogram values if the mouse is out of histogram canvas

    if (mousePos.y > canvas.height || mousePos.y < 0.0 || mousePos.x > originX + nbBins || mousePos.x < originX) {
      return;
    } // Draw the text indicating the histogram value on mouse position


    self$1.ctx.font = "8pt Calibri";
    self$1.ctx.fillStyle = "yellow";
    var thresholdValue = self$1.getHistValue([mousePos.x, mousePos.y]);
    self$1.ctx.fillText(thresholdValue, canvas.width / 2 - 15.0, originY + paddingBottom); // Draw a tiny line indicating the mouse position on X-axis

    self$1.ctx.fillRect(mousePos.x, originY, 1, 2);
  }
  /**************************************************************************************************************/

  /**
   * Get histogram value from the given X-position on canvas
   * @param {Array} position
   * @returns {number} value
   */


  function getHistValue(position) {
    return Math.floor(((position[0] - originX) / 256.0 * (this.image.tmax - this.image.tmin) + this.image.tmin) * Math.pow(10, this.accuracy)) / Math.pow(10, this.accuracy);
  }
  /**************************************************************************************************************/

  /**
   * Init Thresholds by creating to
   */


  function initThresholds() {
    originY = canvas.height - paddingBottom;
    hwidth = nbBins + originX > canvas.width ? canvas.width : nbBins + originX;
    this.minThreshold = new Triangle([originX, originY + 1, 0], [originX - triangleHalfWidth, originY + paddingBottom - 1, 0], [originX + triangleHalfWidth, originY + paddingBottom - 1, 0]);
    this.maxThreshold = new Triangle([hwidth, originY + 1, 0], [hwidth - triangleHalfWidth, originY + paddingBottom - 1, 0], [hwidth + triangleHalfWidth, originY + paddingBottom - 1, 0]);
  }
  /**************************************************************************************************************/


  function drawThresholdControls() {
    this.minThreshold.draw(this.ctx, {});
    this.maxThreshold.draw(this.ctx, {});
  }
  /**************************************************************************************************************/

  /**
   * Draw histogram
   * @param {Object} options
   *        <ul>
   *            <li>color: inside graph color</li>
   *        </ul>
   *
   */


  function drawHistogram(options) {
    if (options == null) {
      options = {};
    }

    this.ctx.fillStyle = options.color || "blue";

    for (var i = 0; i < hist.length; i++) {
      // Scale to y-axis height
      var rectHeight = hist[i] / hmax * originY;
      this.ctx.fillRect(originX + i, originY, 1, -rectHeight);
    }
  }
  /**************************************************************************************************************/

  /**
   *    Draw histogram axis
   */


  function drawAxes() {
    var leftY, rightX;
    leftY = 0;
    rightX = originX + hwidth; // Draw y axis.

    this.ctx.beginPath();
    this.ctx.moveTo(originX, leftY);
    this.ctx.lineTo(originX, originY); // Draw x axis.

    this.ctx.moveTo(originX, originY);
    this.ctx.lineTo(rightX, originY); // Define style and stroke lines.

    this.ctx.closePath();
    this.ctx.strokeStyle = "#fff";
    this.ctx.stroke();
  }
  /**************************************************************************************************************/

  /**
   *    Draw transfer function(linear, log, asin, sqrt, sqr)
   *    @param {Object} options
   *        <ul>
   *            <li>color: transfer stroke color</li>
   *        </ul>
   */


  function drawTransferFunction(options) {
    // Draw transfer functions
    // "Grey" colormap for now(luminance curve only)
    if (options == null) {
      options = {};
    }

    this.ctx.fillStyle = options.color || "red";

    for (var i = 0; i < nbBins; i++) {
      var value = i;
      var posX = originX + value;
      var scaledValue;

      switch (this.image.transferFn) {
        case "linear":
          scaledValue = value / nbBins * originY;
          break;

        case "log":
          scaledValue = Math.log(value / 10.0 + 1) / Math.log(nbBins / 10.0 + 1) * originY;
          break;

        case "sqrt":
          scaledValue = Math.sqrt(value / 10.0) / Math.sqrt(nbBins / 10.0) * originY;
          break;

        case "sqr":
          scaledValue = Math.pow(value, 2) / Math.pow(nbBins, 2) * originY;
          break;

        case "asin":
          scaledValue = Math.log(value + Math.sqrt(Math.pow(value, 2) + 1.0)) / Math.log(nbBins + Math.sqrt(Math.pow(nbBins, 2) + 1.0)) * originY;
          break;
      }

      if (!this.image.inverse) {
        scaledValue = originY - scaledValue;
      }

      this.ctx.fillRect(posX, scaledValue, 1, 1);
    }
  }
  /**************************************************************************************************************/

  /**
   *    Draw the histogram in canvas
   */


  function draw() {
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.drawHistogram();
    this.drawTransferFunction();
    this.drawAxes();
    this.drawThresholdControls();
  }
  /**************************************************************************************************************/

  /**
   *    TODO : create different module
   *    Compute histogram values
   */


  function compute() {
    var image = this.image; // Initialize histogram

    hist = new Array(nbBins);

    for (var i = 0; i < hist.length; i++) {
      hist[i] = 0;
    } // Compute histogram


    hmax = Number.MIN_VALUE;

    for (i = 0; i < image.pixels.length; i++) {
      var val = image.pixels[i]; // Skip NaN

      if (isNaN(val)) {
        continue;
      } // Take only values which belongs to the interval [tmin,tmax]


      if (val < image.tmin) {
        continue;
      }

      if (val >= image.tmax) {
        continue;
      } // Scale to [0,255]


      var bin = Math.floor(nbBins * (val - image.tmin) / (image.tmax - image.tmin));
      hist[bin]++; // Compute histogram max value

      if (hist[bin] > hmax) {
        hmax = hist[bin];
      }
    } // Logarithmic scale for better layout


    for (i = 0; i < hist.length; i++) {
      hist[i] = Math.log(1 + hist[i]);
    }

    hmax = Math.log(1 + hmax);
  }
  /**************************************************************************************************************/

  /**
   *    Set image
   *    @param {Image} image
   */


  function setImage(image) {
    this.image = image;
  }

  function getCanvas() {
    return canvas;
  }
  /**************************************************************************************************************/


  var HistogramCore = {
    /**
     *    Histogram contructor
     *    @param options Histogram options
     *        <ul>
     *            <li>canvas: The canvas context where to draw Histogram</li>
     *            <li>image: The image which is represented by current histogram(required)</li>
     *            <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
     *            <li>onUpdate: On update callback
     *            <li>accuracy: The accuracy of histogram(numbers after floating point)
     *            <li>paddingBottom: space at the bottom
     *            <li>triangleHalfWidth: half width of the triangle to draw
     *            <li>originX
     *        </ul>
     */
    init: function (options) {
      this.image = options.image;
      this.onUpdate = options.onUpdate;
      this.accuracy = options.accuracy || 6;
      self$1 = this;
      nbBins = options.nbBins || 256;
      paddingBottom = options.paddingBottom || 15.0;
      originX = options.originX || 5.0;
      triangleHalfWidth = options.triangleHalfWidth || 5; // Init canvas

      canvas = document.getElementById(options.canvas);
      canvas.addEventListener("mousemove", _handleMouseMove); // Handle threshold controller selection

      canvas.addEventListener("mousedown", _handleMouseDown); // Update histogram on mouseup

      canvas.addEventListener("mouseup", _handleMouseUp);
      this.ctx = canvas.getContext("2d");
      this.initThresholds();
    },
    initThresholds: initThresholds,
    getHistValue: getHistValue,
    drawThresholdControls: drawThresholdControls,
    drawHistogram: drawHistogram,
    drawAxes: drawAxes,
    drawTransferFunction: drawTransferFunction,
    draw: draw,
    compute: compute,
    setImage: setImage,
    getCanvas: getCanvas
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  let feature;
  let layer;
  let disable;
  let unselect;
  let $dialog;
  let histogramElement;
  let cutOutElement;
  /**************************************************************************************************************/

  /**
   *    Toggle visibility of dialog
   */

  function toggle() {
    if ($dialog.dialog("isOpen")) {
      $dialog.dialog("close");
    } else {
      $dialog.dialog("open");
    }
  }
  /**************************************************************************************************************/

  /**
   *    Set data to process
   *
   *    @param selectedData Object containing feature and layer extracted by <PickingManager>
   */


  function setData(selectedData) {
    if (feature && feature.properties.identifier === selectedData.feature.properties.identifier) {
      this.toggle();
    } else {
      if (!$dialog.dialog("isOpen")) {
        this.toggle();
      }
    }

    feature = selectedData.feature;
    layer = selectedData.layer;

    if (selectedData.feature.services) {
      cutOutElement.setUrl(selectedData.feature.services.download.url);
    }
    /** else {
                     // TODO : disable cutOutElement if feature's url isn't defined
                 }*/


    const image = selectedData.feature.properties.style.uniformValues;

    if (!image) {
      $dialog.find(".histogramContent").children("div").fadeOut(function () {
        $__default['default'](this).siblings("p").fadeIn();
      });
    } else {
      this.setImage(image);
    }
  }
  /**************************************************************************************************************/

  /**
   * Set image on the Histogram element
   *
   * @param image
   */


  function setImage$1(image) {
    histogramElement.setImage(image);

    if (image.url) {
      cutOutElement.setUrl(image.url);
    }

    $dialog.find(".histogramContent").children("p").fadeOut(function () {
      $__default['default'](this).siblings("div").fadeIn();
    });
  }
  /**************************************************************************************************************/


  var ImageProcessingCore = {
    /**
     *    Init ImageProcessingCore
     *
     *    @param options
     *        <ul>
     *            <li>feature: The feature to process
     *            <li>layer: The layer to which the feature belongs to
     *            <li>disable: Disable callback</li>
     *            <li>unselect: Unselect callback</li>
     *        </ul>
     *    @param {HTMLElement} $dl dialogElement
     *    @param {HTMLElement} $histoElmt histogramElement
     *    @param {HTMLElement} $cutOutElmt cutOutElement
     *
     */
    init: function (options, $dl, histoElmt, cutOutElmt) {
      if (options) {
        //this.id = options.id;
        feature = options.feature || null;
        layer = options.layer || null; // Callbacks

        disable = options.disable || null;
        unselect = options.unselect || null;
      }

      $dialog = $dl;
      histogramElement = histoElmt;
      cutOutElement = cutOutElmt;
    },
    setData: setData,
    setImage: setImage$1,
    toggle: toggle
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn) {
    var module = { exports: {} };
  	return fn(module, module.exports), module.exports;
  }

  function commonjsRequire (target) {
  	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
  }

  var wcs = createCommonjsModule(function (module, exports) {
    // Generated by CoffeeScript 1.3.3
    // Note: modified to be exported as a module
    function WCS() {
      var WCS,
          __bind = function (fn, me) {
        return function () {
          return fn.apply(me, arguments);
        };
      },
          __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item) return i;
        }

        return -1;
      };

      WCS =  exports !== null && this || (this.WCS = {});
      WCS.Math = {};
      WCS.Math.R2D = 180 / Math.PI;
      WCS.Math.D2R = Math.PI / 180;
      WCS.Math.WCSTRIG_TOL = 1e-10;

      WCS.Math.cosd = function (angle) {
        var i;

        if (angle % 90 === 0) {
          i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;

          switch (i) {
            case 0:
              return 1;

            case 1:
              return 0;

            case 2:
              return -1;

            case 3:
              return 0;
          }
        }

        return Math.cos(angle * WCS.Math.D2R);
      };

      WCS.Math.sind = function (angle) {
        var i;

        if (angle % 90 === 0) {
          i = Math.abs(Math.floor(angle / 90 - 0.5)) % 4;

          switch (i) {
            case 0:
              return 1;

            case 1:
              return 0;

            case 2:
              return -1;

            case 3:
              return 0;
          }
        }

        return Math.sin(angle * WCS.Math.D2R);
      };

      WCS.Math.sincosd = function (angle) {
        var c, i, s, _ref, _ref1;

        if (angle % 90 === 0) {
          i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;

          switch (i) {
            case 0:
              s = 0;
              c = 1;
              break;

            case 1:
              s = (_ref = angle > 0) != null ? _ref : {
                1: -1
              };
              c = 0;
              break;

            case 2:
              s = 0;
              c = -1;
              break;

            case 3:
              s = (_ref1 = angle > 0) != null ? _ref1 : -{
                1: 1
              };
              c = 0;
          }

          return s * c;
        }

        s = Math.sin(angle * WCS.Math.D2R);
        c = Math.cos(angle * WCS.Math.D2R);
        return s * c;
      };

      WCS.Math.tand = function (angle) {
        var resid;
        resid = angle & 360;

        if (resid === 0 || Math.abs(resid) === 180) {
          return 0;
        } else if (resid === 45 || resid === 225) {
          return 1;
        } else if (resid === -135 || resid === -315) {
          return -1;
        }

        return Math.tan(angle * WCS.Math.D2R);
      };

      WCS.Math.acosd = function (v) {
        if (v >= 1) {
          if (v - 1 < WCS.Math.WCSTRIG_TOL) {
            return 0;
          }
        } else if (v === 0) {
          return 90;
        } else if (v <= -1) {
          if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
            return 180;
          }
        }

        return Math.acos(v) * WCS.Math.R2D;
      };

      WCS.Math.asind = function (v) {
        if (v <= -1) {
          if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
            return -90;
          } else if (v === 0) {
            return 0;
          } else if (v >= 1) {
            if (v - 1 < WCS.Math.WCSTRIG_TOL) {
              return 90;
            }
          }
        }

        return Math.asin(v) * WCS.Math.R2D;
      };

      WCS.Math.atand = function (v) {
        if (v === -1) {
          return -45;
        } else if (v === 0) {
          return 0;
        } else if (v === 1) {
          return 45;
        }

        return Math.atan(v) * WCS.Math.R2D;
      };

      WCS.Math.atan2d = function (y, x) {
        if (y === 0) {
          if (x >= 0) {
            return 0;
          } else if (x < 0) {
            return 180;
          }
        } else if (x === 0) {
          if (y > 0) {
            return 90;
          } else if (y < 0) {
            return -90;
          }
        }

        return Math.atan2(y, x) * WCS.Math.R2D;
      };

      WCS.Math.toRightTriangular = function (mat) {
        var els, i, j, k, kp, multiplier, n, np, p;
        n = mat.length;
        k = n;
        kp = mat[0].length;

        while (true) {
          i = k - n;

          if (mat[i][i] === 0) {
            j = i + 1;

            while (j < k) {
              if (mat[j][i] !== 0) {
                els = [];
                np = kp;

                while (true) {
                  p = kp - np;
                  els.push(mat[i][p] + mat[j][p]);

                  if (! --np) {
                    break;
                  }
                }

                mat[i] = els;
                break;
              }

              j += 1;
            }
          }

          if (mat[i][i] !== 0) {
            j = i + 1;

            while (j < k) {
              multiplier = mat[j][i] / mat[i][i];
              els = [];
              np = kp;

              while (true) {
                p = kp - np;
                els.push(p <= i ? 0 : mat[j][p] - mat[i][p] * multiplier);

                if (! --np) {
                  break;
                }
              }

              mat[j] = els;
              j += 1;
            }
          }

          if (! --n) {
            break;
          }
        }

        return mat;
      };

      WCS.Math.determinant = function (mat) {
        var det, i, k, m, n;
        m = WCS.Math.toRightTriangular(mat);
        det = m[0][0];
        n = m.length - 1;
        k = n;

        while (true) {
          i = k - n + 1;
          det = det * m[i][i];

          if (! --n) {
            break;
          }
        }

        return det;
      };

      WCS.Math.matrixInverse = function (m) {
        var I, h, i, inv, j, mat, temp, w;
        w = m[0].length;
        h = m.length;
        I = new Array(h);
        inv = new Array(h);
        temp = [];
        mat = [];
        j = 0;

        while (j < h) {
          mat[j] = [];
          i = 0;

          while (i < w) {
            mat[j][i] = m[j][i];
            i += 1;
          }

          j += 1;
        }

        j = 0;

        while (j < h) {
          I[j] = new Array(w);
          inv[j] = new Array(w);
          i = 0;

          while (i < w) {
            I[j][i] = i === j ? 1 : 0;
            i += 1;
          }

          temp[j] = mat[j].concat(I[j]);
          j += 1;
        }

        WCS.Math.gaussJordan(temp);
        j = 0;

        while (j < h) {
          inv[j] = temp[j].slice(w, 2 * w);
          j += 1;
        }

        return inv;
      };

      WCS.Math.gaussJordan = function (m, eps) {
        if (!eps) eps = 1e-10;
        var h, w, y, y2, x, maxrow, tmp, c;
        h = m.length;
        w = m[0].length;
        y = -1;

        while (++y < h) {
          maxrow = y; // Find max pivot.

          y2 = y;

          while (++y2 < h) {
            if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y])) maxrow = y2;
          } // Swap.


          tmp = m[y];
          m[y] = m[maxrow];
          m[maxrow] = tmp; // Singular?

          if (Math.abs(m[y][y]) <= eps) return false; // Eliminate column y.

          y2 = y;

          while (++y2 < h) {
            c = m[y2][y] / m[y][y];
            x = y - 1;

            while (++x < w) {
              m[y2][x] -= m[y][x] * c;
            }
          }
        } // Backsubstitute.


        y = h;

        while (--y >= 0) {
          c = m[y][y];
          y2 = -1;

          while (++y2 < y) {
            x = w;

            while (--x >= y) {
              m[y2][x] -= m[y][x] * m[y2][y] / c;
            }
          }

          m[y][y] /= c; // Normalize row y.

          x = h - 1;

          while (++x < w) {
            m[y][x] /= c;
          }
        }

        return true;
      };

      WCS.Mapper = function () {
        function Mapper(header) {
          this.coordinateToPixel = __bind(this.coordinateToPixel, this);
          this.pixelToCoordinate = __bind(this.pixelToCoordinate, this);
          this.fromCelestial = __bind(this.fromCelestial, this);
          this.toCelestial = __bind(this.toCelestial, this);
          this.fromIntermediate = __bind(this.fromIntermediate, this);
          this.toIntermediate = __bind(this.toIntermediate, this);
          this.computeCelestialParameters = __bind(this.computeCelestialParameters, this);
          this.getSipCoefficients = __bind(this.getSipCoefficients, this);
          this.setProjection = __bind(this.setProjection, this);
          this.derivePC = __bind(this.derivePC, this);
          this.checkCard = __bind(this.checkCard, this);
          this.verifyHeader = __bind(this.verifyHeader, this);
          this.wcsobj = {};
          this.projection = void 0;
          this.longitudeAxis = void 0;
          this.latitudeAxis = void 0;
          this.sip = void 0;
          this.verifyHeader(header);
          this.setProjection(header);
        }

        Mapper.prototype.verifyHeader = function (header) {
          var arrayName, axis, date, j, key, naxis, requiredCards, _i, _j, _k, _ref;

          this.wcsobj.naxis = naxis = header["NAXIS"] || header["WCSAXES"] || 2;
          this.wcsobj.radesys = header["RADESYS"] || "ICRS";
          requiredCards = ["CRPIX", "CRVAL", "CTYPE"];
          this.wcsobj.crpix = [];
          this.wcsobj.crval = [];
          this.wcsobj.ctype = [];

          for (axis = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; axis = 1 <= naxis ? ++_i : --_i) {
            for (j = _j = 0, _ref = requiredCards.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
              key = requiredCards[j] + axis;

              if (!header.hasOwnProperty(key)) {
                throw "Not enough information to compute WCS, missing required keyword " + key;
              }

              arrayName = requiredCards[j].toLowerCase();
              this.wcsobj[arrayName].push(header[key]);
            }
          }

          this.wcsobj.cunit = [];
          this.wcsobj.cdelt = [];

          for (axis = _k = 1; 1 <= naxis ? _k <= naxis : _k >= naxis; axis = 1 <= naxis ? ++_k : --_k) {
            key = "CUNIT" + axis;
            this.wcsobj.cunit.push(header[key] || "deg");
            key = "CDELT" + axis;
            this.wcsobj.cdelt.push(header[key] || 1);
          }

          this.wcsobj.lonpole = header["LONPOLE"] || 0;
          this.wcsobj.latpole = header["LATPOLE"] || 0;
          this.wcsobj.equinox = header["EQUINOX"] || 2000;
          date = new Date();
          this.wcsobj.dateObs = header["DATE_OBS"] || date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
          this.wcsobj.dateObs = header["DATE_OBS"] || "" + date.getFullYear() + "-" + (date.getMonth() + 1) + "-" + date.getDate();
          this.wcsobj.pc = this.checkCard(header, "PC", naxis) || this.derivePC(header);
          this.wcsobj.pcInv = WCS.Math.matrixInverse(this.wcsobj.pc);
          this.wcsobj.cd = this.checkCard(header, "CD", naxis);

          if (this.wcsobj.cd != null) {
            return this.wcsobj.cdInv = WCS.Math.matrixInverse(this.wcsobj.cd);
          }
        };

        Mapper.prototype.checkCard = function (header, key, dimensions) {
          var fullKey, i, j, obj, _i, _j;

          obj = [];

          for (i = _i = 1; 1 <= dimensions ? _i <= dimensions : _i >= dimensions; i = 1 <= dimensions ? ++_i : --_i) {
            obj[i - 1] = [];

            for (j = _j = 1; 1 <= dimensions ? _j <= dimensions : _j >= dimensions; j = 1 <= dimensions ? ++_j : --_j) {
              fullKey = "" + key + i + "_" + j;

              if (!header.hasOwnProperty(fullKey)) {
                return;
              }

              obj[i - 1].push(header[fullKey]);
            }
          }

          return obj;
        };

        Mapper.prototype.derivePC = function (header) {
          var cd, cd11, cd12, cd21, cd22, cos_rho, crota, lambda, rho_a, rho_b, _ref;

          if (header.hasOwnProperty("CROTA2")) {
            crota = header["CROTA2"];
            lambda = this.wcsobj.cdelt[1] / this.wcsobj.cdelt[0];
          } else {
            cd = this.checkCard(header, "CD", this.wcsobj.naxis);

            if (cd == null) {
              _ref = [0, 1], crota = _ref[0], lambda = _ref[1];
            } else {
              cd11 = cd[0][0];
              cd12 = cd[0][1];
              cd21 = cd[1][0];
              cd22 = cd[1][1];

              if (cd21 > 0) {
                rho_a = Math.atan2(cd21, cd11);
              } else if (cd21 === 0) {
                rho_a = 0;
              } else {
                rho_a = Math.atan2(-cd21, -cd11);
              }

              if (cd12 > 0) {
                rho_b = Math.atan2(cd12, -cd22);
              } else if (cd12 === 0) {
                rho_b = 0;
              } else {
                rho_b = Math.atan2(-cd21, cd22);
              }

              crota = 0.5 * (rho_a + rho_b);
              cos_rho = Math.cos(crota);
              this.wcsobj.cdelt1 = cd11 / cos_rho;
              this.wcsobj.cdelt2 = cd22 / cos_rho;
              lambda = this.wcsobj.cdelt2 / this.wcsobj.cdelt1;
            }
          }

          return cd;
        };

        Mapper.prototype.setProjection = function (header) {
          var conic,
              cylindrical,
              key,
              key1,
              key2,
              key3,
              polyConic,
              quadCube,
              zenithal,
              _ref,
              _ref1,
              _ref2,
              _ref3,
              _ref4,
              _ref5,
              _ref6,
              _ref7,
              _ref8,
              _this = this;

          zenithal = ["AIR", "ARC", "AZP", "NCP", "SIN", "STG", "SZP", "TAN", "TAN-SIP", "ZEA", "ZPN"];
          cylindrical = ["CYP", "CEA", "CAR", "MER", "SFL", "PAR", "MOL", "AIT"];
          conic = ["COP", "COE", "COD", "COO"];
          polyConic = ["BON", "PCO"];
          quadCube = ["TSC", "CSC", "QSC"];
          this.projection = this.wcsobj.ctype[0].slice(5);
          this.longitudeAxis = this.wcsobj.ctype[0].match("RA|GLON|ELON|HLON|SLON") ? 1 : 2;
          this.latitudeAxis = this.wcsobj.ctype[1].match("DEC|GLAT|ELAT|HLAT|SLAT") ? 2 : 1;

          if (_ref = this.projection, __indexOf.call(zenithal, _ref) >= 0) {
            this.wcsobj.phi0 = 0;
            this.wcsobj.theta0 = 90;
            this.wcsobj.alphaP = this.wcsobj.crval[0];
            this.wcsobj.deltaP = this.wcsobj.crval[1];
            this.wcsobj.lonpole = this.wcsobj.crval[1] >= this.wcsobj.theta0 ? 0 : 180;

            switch (this.projection) {
              case "AIR":
                key = "PV" + this.latitudeAxis + "_1";
                this.wcsobj.thetaB = header.hasOwnProperty(key) ? parseFloat(header[key]) : 90;
                this.wcsobj.etaB = (90 - this.wcsobj.thetaB) / 2;
                break;

              case "ARC":
                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = _this.wcsobj.theta0 - r;
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 90 - theta;
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "AZP":
                _ref1 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref1[0], key2 = _ref1[1];
                this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
                this.wcsobj.gamma = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;

                this.toSpherical = function (x, y) {
                  throw "Sorry, not yet implemented!";
                };

                this.fromSpherical = function (phi, theta) {
                  throw "Sorry, not yet implemented!";
                };

                break;

              case "NCP":
                this.toSpherical = function (x, y) {
                  throw "Sorry, not yet implemented!";
                };

                this.fromSpherical = function (phi, theta) {
                  throw "Sorry, not yet implemented!";
                };

                break;

              case "SIN":
                _ref2 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref2[0], key2 = _ref2[1];
                this.wcsobj.eta = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
                this.wcsobj.nu = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;

                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = WCS.Math.acosd(Math.PI * r / 180);
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 180 / Math.PI * WCS.Math.cosd(theta);
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "STG":
                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = _this.wcsobj.theta0 - 2 * WCS.Math.atand(Math.PI * r / 360);
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 360 / Math.PI * WCS.Math.tand((90 - theta) / 2);
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "SZP":
                _ref3 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2", "PV" + this.latitudeAxis + "_3"], key1 = _ref3[0], key2 = _ref3[1], key3 = _ref3[2];
                this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
                this.wcsobj.phiC = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
                this.wcsobj.thetaC = header.hasOwnProperty(key3) ? parseFloat(header[key3]) : 90;
                this.wcsobj.xp = -this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.sind(this.wcsobj.phiC);
                this.wcsobj.yp = this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.cosd(this.wcsobj.phiC);
                this.wcsobj.zp = this.wcsobj.mu * WCS.Math.sind(this.wcsobj.thetaC) + 1;

                this.toSpherical = function (x, y) {
                  throw "Sorry, not yet implemented";
                };

                this.fromSpherical = function (phi, theta) {
                  throw "Sorry, not yet implemented";
                };

                break;

              case "TAN":
                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = WCS.Math.atand(180 / (Math.PI * r));
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 180 / (Math.PI * WCS.Math.tand(theta));
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "TAN-SIP":
                this.getSipCoefficients(header);

                this.f = function (u, v, coeffs) {
                  var order, p, q, value, _i, _j;

                  value = 0;
                  order = coeffs[0].length - 1;

                  for (p = _i = 0; 0 <= order ? _i <= order : _i >= order; p = 0 <= order ? ++_i : --_i) {
                    for (q = _j = 0; 0 <= order ? _j <= order : _j >= order; q = 0 <= order ? ++_j : --_j) {
                      value += coeffs[p][q] * Math.pow(u, p) * Math.pow(v, q);
                    }
                  }

                  return value;
                };

                this.toIntermediate = function (points) {
                  var dx, dy, i, j, proj, u, v, _i, _j, _ref4, _ref5;

                  proj = [];
                  u = points[0] - _this.wcsobj.crpix[0];
                  v = points[1] - _this.wcsobj.crpix[1];
                  dx = dy = 0;
                  dx = _this.f(u, v, _this.sip.aCoeffs);
                  dy = _this.f(u, v, _this.sip.bCoeffs);
                  points[0] = points[0] + dx;
                  points[1] = points[1] + dy;

                  for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                    proj[i] = 0;
                    points[i] -= _this.wcsobj.crpix[i];

                    for (j = _j = 0, _ref5 = _this.wcsobj - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                      proj[i] += _this.wcsobj.cd[i][j] * points[j];
                    }
                  }

                  return proj;
                };

                this.fromIntermediate = function (proj) {
                  var dx, dy, i, j, points, tmp, _i, _j, _ref4, _ref5;

                  tmp = [];

                  for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                    tmp[i] = 0;

                    for (j = _j = 0, _ref5 = _this.wcsobj.naxis - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                      tmp[i] += _this.wcsobj.cdInv[i][j] * proj[j];
                    }

                    tmp[i] += _this.wcsobj.crpix[i];
                  }

                  dx = dy = 0;
                  dx = _this.f(tmp[0], tmp[1], _this.sip.apCoeffs);
                  dy = _this.f(tmp[0], tmp[1], _this.sip.bpCoeffs);
                  points = [];
                  points[0] = tmp[0] + dx;
                  points[1] = tmp[1] + dy;
                  points[0] += _this.wcsobj.crpix[0];
                  points[1] += _this.wcsobj.crpix[1];
                  return points;
                };

                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = WCS.Math.atand(180 / (Math.PI * r));
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 180 / (Math.PI * WCS.Math.tand(theta));
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "ZEA":
                this.toSpherical = function (x, y) {
                  var phi, r, theta;
                  r = Math.sqrt(x * x + y * y);
                  theta = _this.wcsobj.theta0 - 2 * WCS.Math.asind(Math.PI * r / 360);
                  phi = WCS.Math.atan2d(x, -y);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var r, x, y;
                  r = 360 / Math.PI * WCS.Math.sind((90 - theta) / 2);
                  x = r * WCS.Math.sind(phi);
                  y = -r * WCS.Math.cosd(phi);
                  return [x, y];
                };

                break;

              case "ZPN":
                this.toSpherical = function (x, y) {
                  throw "Sorry, not yet implemented!";
                };

                this.fromSpherical = function (phi, theta) {
                  throw "Sorry, not yet implemented!";
                };

            }
          }

          if (_ref4 = this.projection, __indexOf.call(cylindrical, _ref4) >= 0) {
            this.wcsobj.phi0 = 0;
            this.wcsobj.theta0 = 0;
            this.computeCelestialParameters(this.wcsobj.phi0, this.wcsobj.theta0);

            switch (this.projection) {
              case "CYP":
                _ref5 = ["PV" + this.latitudeAxis + "_1,", "PV" + this.latitudeAxis + "_2"], key1 = _ref5[0], key2 = _ref5[1];
                this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 1;
                this.wcsobj.lambda = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 1;

                if (this.wcsobj.mu + this.wcsobj.lambda === 0) {
                  throw new Error("Divide by zero error");
                }

                this.toSpherical = function (x, y) {
                  var nu, phi, theta;
                  nu = Math.PI * y / (180 * (_this.wcsobj.mu + _this.wcsobj.lambda));
                  theta = WCS.Math.atan2d(nu, 1) + WCS.Math.asind(nu * _this.wcsobj.mu / Math.sqrt(nu * nu + 1));
                  phi = x / _this.wcsobj.lambda;
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var x, y;
                  x = _this.wcsobj.lambda * phi;
                  y = 180 / Math.PI * ((_this.wcsobj.mu + _this.wcsobj.lambda) / (_this.wcsobj.mu + WCS.Math.cosd(theta))) * WCS.Math.sind(theta);
                  return [x, y];
                };

                break;

              case "CEA":
                key = "PV" + this.latitudeAxis + "_1";
                this.wcsobj.lambda = header.hasOwnProperty(key) ? parseFloat(header[key]) : 1;

                this.toSpherical = function (x, y) {
                  var theta;
                  theta = WCS.Math.asind(Math.PI * _this.wcsobj.lambda * y / 180);
                  return [x, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var y;
                  y = 180 / Math.PI * WCS.Math.sind(theta) / _this.wcsobj.lambda;
                  return [phi, y];
                };

                break;

              case "CAR":
                this.toSpherical = function (x, y) {
                  return [x, y];
                };

                this.fromSpherical = function (phi, theta) {
                  return [phi, theta];
                };

                break;

              case "MER":
                this.toSpherical = function (x, y) {
                  var theta;
                  theta = 2 * WCS.Math.atand(Math.exp(y * Math.PI / 180)) - 90;
                  return [x, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var y;
                  y = 180 / Math.PI * Math.log(WCS.Math.tand((90 + theta) / 2));
                  return [phi, y];
                };

                break;

              case "SFL":
                this.toSpherical = function (x, y) {
                  var phi;
                  phi = x / WCS.Math.cosd(y);
                  return [phi, y];
                };

                this.fromSpherical = function (phi, theta) {
                  var x;
                  x = phi * WCS.Math.cosd(theta);
                  return [x, theta];
                };

                break;

              case "PAR":
                this.toSpherical = function (x, y) {
                  var phi, theta;
                  theta = 3 * WCS.Math.asind(y / 180);
                  phi = x / (1 - 4 * Math.pow(y / 180, 2));
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var x, y;
                  x = phi * (2 * WCS.Math.cosd(2 * theta / 3) - 1);
                  y = 180 * WCS.Math.sind(theta / 3);
                  return [x, y];
                };

                break;

              case "MOL":
                this.toSpherical = function (x, y) {
                  var phi, theta;
                  theta = WCS.Math.asind(WCS.Math.asind(Math.PI * y / (180 * Math.sqrt(2))) / 90 + y / 180 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
                  phi = Math.PI * x / (2 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  throw "Sorry, not yet implemented!";
                };

                break;

              case "AIT":
                this.toSpherical = function (x, y) {
                  var phi, theta, x_z, y_z, z;
                  x_z = Math.pow(Math.PI * x / (4 * 180), 2);
                  y_z = Math.pow(Math.PI * y / (2 * 180), 2);
                  z = Math.sqrt(1 - x_z - y_z);
                  theta = WCS.Math.asind(Math.PI * y * z / 180);
                  phi = 2 * WCS.Math.atan2d(Math.PI * z * x / (2 * 180), 2 * z * z - 1);
                  return [phi, theta];
                };

                this.fromSpherical = function (phi, theta) {
                  var gamma, x, y;
                  gamma = 180 / Math.PI * Math.sqrt(2 / (1 + WCS.Math.cosd(theta) * WCS.Math.cosd(phi / 2)));
                  x = 2 * gamma * WCS.Math.cosd(theta) * WCS.Math.sind(phi / 2);
                  y = gamma * WCS.Math.sind(theta);
                  return [x, y];
                };

            }
          }

          if (_ref6 = this.projection, __indexOf.call(conic, _ref6) >= 0) {
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.phi0 = 0;
            this.wcsobj.theta0 = header.hasOwnProperty(key) ? header[key] : 0;
            throw "Sorry, not yet implemented!";
          }

          if (_ref7 = this.projection, __indexOf.call(polyConic, _ref7) >= 0) {
            this.wcsobj.phi0 = 0;
            this.wcsobj.theta0 = 0;
            throw "Sorry, not yet implemented!";
          }

          if (_ref8 = this.projection, __indexOf.call(quadCube, _ref8) >= 0) {
            this.wcsobj.phi0 = 0;
            this.wcsobj.theta0 = 0;
            throw "Sorry, not yet implemented!";
          }
        };

        Mapper.prototype.getSipCoefficients = function (header) {
          var i, j, key, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

          if (!(header.hasOwnProperty("A_ORDER") || header.hasOwnProperty("B_ORDER"))) {
            throw "What's the polynomial order, man!";
          }

          this.sip = {};
          this.sip.aOrder = header.A_ORDER;
          this.sip.bOrder = header.B_ORDER;
          this.sip.apOrder = header.AP_ORDER || 0;
          this.sip.bpOrder = header.BP_ORDER || 0;
          this.sip.aCoeffs = [];
          this.sip.bCoeffs = [];
          this.sip.apCoeffs = [];
          this.sip.bpCoeffs = [];

          for (i = _i = 0, _ref = this.sip.aOrder; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            this.sip.aCoeffs[i] = [];

            for (j = _j = 0, _ref1 = this.sip.aOrder; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              key = "A_" + i + "_" + j;
              this.sip.aCoeffs[i][j] = header[key] || 0;
            }
          }

          for (i = _k = 0, _ref2 = this.sip.bOrder; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            this.sip.bCoeffs[i] = [];

            for (j = _l = 0, _ref3 = this.sip.bOrder; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
              key = "B_" + i + "_" + j;
              this.sip.bCoeffs[i][j] = header[key] || 0;
            }
          }

          for (i = _m = 0, _ref4 = this.sip.apOrder; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
            this.sip.apCoeffs[i] = [];

            for (j = _n = 0, _ref5 = this.sip.apOrder; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
              key = "AP_" + i + "_" + j;
              this.sip.apCoeffs[i][j] = header[key] || 0;
            }
          }

          for (i = _o = 0, _ref6 = this.sip.bpOrder; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
            this.sip.bpCoeffs[i] = [];

            for (j = _p = 0, _ref7 = this.sip.bpOrder; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
              key = "BP_" + i + "_" + j;
              this.sip.bpCoeffs[i][j] = header[key] || 0;
            }
          }

          if (!(this.sip.aCoeffs || this.sip.bCoeffs)) {
            throw "Where are the coefficients dude!";
          }
        };

        Mapper.prototype.computeCelestialParameters = function (phi0, theta0) {
          var alpha0, delta0, deltaP1, deltaP2, dist1, dist2, phiP, sol1, sol2, thetaP, _ref, _ref1;

          _ref = this.wcsobj.crval, alpha0 = _ref[0], delta0 = _ref[1];
          _ref1 = [this.wcsobj.lonpole, this.wcsobj.latpole], phiP = _ref1[0], thetaP = _ref1[1];
          deltaP1 = WCS.Math.atan2d(WCS.Math.sind(this.wcsobj.theta0), WCS.Math.cosd(this.wcsobj.theta0 * WCS.Math.cosd(phiP - this.wcsobj.phi0)));
          deltaP2 = WCS.Math.acosd(WCS.Math.sind(delta0) / Math.sqrt(1 - Math.pow(WCS.Math.cosd(this.wcsobj.theta0), 2) * Math.pow(WCS.Math.sind(phiP - this.wcsobj.phi0), 2)));
          sol1 = sol2 = false;

          if (deltaP1 + deltaP2 >= -90 && deltaP1 + deltaP2 <= 90) {
            sol1 = true;
          }

          if (deltaP1 - deltaP2 >= -90 && deltaP1 - deltaP2 <= 90) {
            sol2 = true;
          }

          if (sol1 && sol2) {
            dist1 = Math.abs(deltaP1 + deltaP2 - thetaP);
            dist2 = Math.abs(deltaP1 - deltaP2 - thetaP);
            this.wcsobj.deltaP = dist1 < dist2 ? deltaP1 + deltaP2 : deltaP1 - deltaP2;
          } else if (sol1) {
            this.wcsobj.deltaP = deltaP1 + deltaP2;
          } else if (sol2) {
            this.wcsobj.deltaP = deltaP1 - deltaP2;
          } else {
            this.wcsobj.deltaP = thetaP;
          }

          return this.wcsobj.alphaP = Math.abs(delta0) === 90 ? alpha0 : alpha0 - WCS.Math.asind(WCS.Math.sind(phiP - this.wcsobj.phi0) * WCS.Math.cosd(this.wcsobj.theta0) / WCS.Math.cosd(delta0));
        };

        Mapper.prototype.toIntermediate = function (points) {
          var i, j, proj, _i, _j, _ref, _ref1;

          proj = [];

          for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            proj[i] = 0;
            points[i] -= this.wcsobj.crpix[i];

            for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              proj[i] += this.wcsobj.cdelt[i] * this.wcsobj.pc[i][j] * points[j];
            }
          }

          return proj;
        };

        Mapper.prototype.fromIntermediate = function (proj) {
          var i, j, points, _i, _j, _ref, _ref1;

          points = [];

          for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            points[i] = 0;

            for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              points[i] += this.wcsobj.pcInv[i][j] * proj[j] / this.wcsobj.cdelt[i];
            }

            points[i] += this.wcsobj.crpix[i];
          }

          return points;
        };

        Mapper.prototype.toCelestial = function (phi, theta) {
          var cosDecP, cosDphi, cosTheta, dec, ra, sinDecP, sinDphi, sinTheta, xTemp, yTemp, zTemp;
          sinTheta = WCS.Math.sind(theta);
          cosTheta = WCS.Math.cosd(theta);
          sinDphi = WCS.Math.sind(phi - this.wcsobj.lonpole);
          cosDphi = WCS.Math.cosd(phi - this.wcsobj.lonpole);
          sinDecP = WCS.Math.sind(this.wcsobj.deltaP);
          cosDecP = WCS.Math.cosd(this.wcsobj.deltaP);
          xTemp = sinTheta * cosDecP - cosTheta * sinDecP * cosDphi;
          yTemp = -cosTheta * sinDphi;
          zTemp = sinTheta * sinDecP + cosTheta * cosDecP * cosDphi;
          ra = WCS.Math.atan2d(yTemp, xTemp) + this.wcsobj.alphaP;
          ra = (ra + 360) % 360;
          dec = WCS.Math.asind(zTemp);
          return [ra, dec];
        };

        Mapper.prototype.fromCelestial = function (ra, dec) {
          var cosDalpha, cosDelta, cosDp, phi, sinDalpha, sinDelta, sinDp, theta, xTemp, yTemp;
          sinDelta = WCS.Math.sind(dec);
          cosDelta = WCS.Math.cosd(dec);
          sinDp = WCS.Math.sind(this.wcsobj.deltaP);
          cosDp = WCS.Math.cosd(this.wcsobj.deltaP);
          sinDalpha = WCS.Math.sind(ra - this.wcsobj.alphaP);
          cosDalpha = WCS.Math.cosd(ra - this.wcsobj.alphaP);
          xTemp = sinDelta * cosDp - cosDelta * sinDp * cosDalpha;
          yTemp = -cosDelta * sinDalpha;
          phi = this.wcsobj.lonpole + WCS.Math.atan2d(yTemp, xTemp);
          theta = WCS.Math.asind(sinDelta * sinDp + cosDelta * cosDp * cosDalpha);
          return [phi, theta];
        };

        Mapper.prototype.pixelToCoordinate = function () {
          var coords;
          coords = this.toIntermediate(arguments[0], arguments[1]);
          coords = this.toSpherical(coords[0], coords[1]);
          coords = this.toCelestial(coords[0], coords[1]);
          return {
            ra: coords[this.longitudeAxis - 1],
            dec: coords[this.latitudeAxis - 1]
          };
        };

        Mapper.prototype.coordinateToPixel = function () {
          var coords;
          coords = this.fromCelestial(arguments[0], arguments[1]);
          coords = this.fromSpherical(coords[0], coords[1]);
          coords = this.fromIntermediate(coords);
          return {
            x: coords[0],
            y: coords[1]
          };
        };

        return Mapper;
      }();
    } // ESM export not working somehow ?


    module.exports = new WCS();
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var UtilsFits = {};

  function createCoordinate(x, y) {
    var coordinate = wcs.pixelToCoordinate([x, y]);
    return [coordinate.ra, coordinate.dec];
  }
  /**
   *    Get GeoJson polygon coordinates representing fits using wcs data from header
   */


  UtilsFits.getPolygonCoordinatesFromFits = function (fits) {
    var hdu = fits.getHDU();
    var fitsData = hdu.data; // Create mapper
    //   var wcs = new WCS.Mapper(hdu.header);

    var coords = []; // Find coordinates of coming fits

    coords.push(createCoordinate(0, fitsData.height));
    coords.push(createCoordinate(fitsData.width, fitsData.height));
    coords.push(createCoordinate(fitsData.width, 0));
    coords.push(createCoordinate(0, 0)); // Close the polygon

    coords.push(coords[0]);
    return coords;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var UtilityFactory = {
    create: function (type, options) {
      var obj;

      switch (type) {
        case Constants.UTILITY.Fits:
          obj = UtilsFits;
          break;

        case Constants.UTILITY.Intersection:
          obj = UtilsIntersection;
          break;

        case Constants.UTILITY.Numeric:
          obj = Numeric;
          break;

        case Constants.UTILITY.CreateStyle:
          obj = new FeatureStyle(options);
          break;

        case Constants.UTILITY.FeatureStyle:
          obj = FeatureStyle;
          break;

        case Constants.UTILITY.Utils:
          obj = Utils;
          break;

        default:
          throw new RangeError("UtilityFactory.js: Cannot create the utility " + type);
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const DEFAULT_ICON = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMBQkVBRMIQtMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAvklEQVQY012QMWpCURBFz3yfG7CIwSatpLGwsJJsQEHssr2UttapkkK0zRJEFPKLj5UYPGme8vgDt5l7uNwZKEYNdaZO1FR6VQkBT8AbMAGe1e7dTwXUB8bAFPgF9sBWPUXENbWgBTAELkCTw7bqMdR5kTQCehlogB/gE/iqcs9OVhT9I8v7EZU6UJfqh3pWa3WlvqsvakoRcVOPwCYnvQI1sM67Q0T8JYAWvAEOwDewj4jr4z0teJdf84AA/gF1uG92uhcfoAAAAABJRU5ErkJggg==";
  /**
   * AbstractLayer configuration
   * @typedef {Object} AbstractLayer.configuration
   * @property {string} [name=""] - Layer name
   * @property {string} [attribution=""] - Attribution
   * @property {string} [copyrightUrl=""] - Copyright URL
   * @property {string} [ack=""] - ack
   * @property {string} [icon=a default image] - An icon to represent the layer
   * @property {string} [description=""] - A description
   * @property {boolean} [visible=true] - A boolean flag to display the layer
   * @property {Object} [properties={}] properties
   * @property {boolean} [pickable=false] - Sets to true to make the layer pickable
   * @property {boolean} [service=[]] - List of services related to the layer
   * @property {GEOMETRY} dataType - the data type for vector layers
   * @property {boolean} [background = false] -Set to true to render the layer as a background
   * @property category
   * @param {Crs} coordinateSystem
   * @param {string} [format=""]
   * @param {string} [baseUrl=""]
   * @param {boolean} [deletable=""]
   * @param {Array} [color= a random color]
   * @param {float} [opacity=1.0] - An opacity value
   * @param {FeatureStyle} [style]
   * @param {Array} [services=[]}
   * @param {layerCallback} callback - A callback that transfoms data.
   */

  /**
   * Time configuration
   * @typedef {Object} Time.configuration
   * @property {date} date - Current date
   * @property {string} display - Current date as text for display
   * @property {Time.period.configuration}  - Period
   */

  /**
   * Time period configuration
   * @typedef {Object} Time.period.configuration
   * @property {date} from - start date
   * @property {date} to - stop date
   */

  /**
   * This callback allows to transform FeatureCollection from a GeoJson.
   * @callback layerCallback
   * @param {data} FeatureCollection
   */

  /**
   * @name AbstractLayer
   * @class
   *   Abstract class for creating layer.
   * @augments Event
   * @param {LAYER} type - layer type
   * @param {AbstractLayer.configuration} options - Layer Configuration
   * @constructor
   * @implements {Layer}
   */

  var AbstractLayer = function (type, options) {
    Event.prototype.constructor.call(this, options);
    this.globe = null;
    this.options = options || {};
    this.ID = "URN:Mizar:Layer:" + _$1.uniqueId(this.constructor.name + ":");
    this.name = this.options.name != null ? this.options.name : "";
    this.attribution = this.options.attribution || "";
    this.copyrightUrl = this.options.copyrightUrl || "";
    this.ack = this.options.ack || "";
    this.description = this.options.description || "";
    this.visible = this.options.visible || false;
    this.properties = this.options.properties || {};
    this.services = this.options.services || [];
    this.type = type;
    this.pickable = this.options.pickable || false;
    this.dataType = this.options.dataType || "";
    this.background = this.options.background || false;
    this.category = this.options.background ? "background" : this.options.category;
    this.coordinateSystem = this.options.coordinateSystem;
    this.format = this.options.format || "";
    this.baseUrl = this.options.baseUrl || "";
    this.deletable = this.options.deletable || false;
    this.dimension = this.options.dimension;
    this.callbackContext = null;
    this.linkedTo = this.options.linkedTo || "";
    this.servicesRunningOnCollection = [];
    this.servicesRunningOnRecords = {};
    this.vectorLayer = false;
    this.metadataAPI = this.options.metadataAPI ? this.options.metadataAPI : null;
    this.time = null; // Do we take DEM into account with this layer ?

    this.pickingNoDEM = this.options.pickingNoDEM ? this.options.pickingNoDEM : false; // Set if we need to auto fill the time travel range/step with auto discovered time values

    this.autoFillTimeTravel = this.options.autoFillTimeTravel ? this.options.autoFillTimeTravel : false; // Create style if needed

    this.style = _createStyle.call(this, this.options, this.icon); // Ensure that the attribution link will be opened in new tab

    if (this.attribution && this.attribution.search("<a") >= 0 && this.attribution.search("target=") < 0) {
      this.attribution = this.attribution.replace(" ", " target=_blank ");
    }

    this.multiLayers = []; //cache to know which custom (e;g time, style, ...) Raster parameters are send

    this.imageLoadedAtTime = {};
  };
  /**
   * Create style
   * @param options
   * @returns {*}
   * @private
   */


  function _createStyle(options) {
    var style;

    if (options.hasOwnProperty("style")) {
      // we use style from layerDescription.
      style = UtilityFactory.create(Constants.UTILITY.CreateStyle, options.style);
    } else if (options.style === "FeatureStyle") {
      // use a previous definition
      style = options.style;
    } else {
      // Update layer color
      var color = _createColor.call(this, options); // Layer opacity must be in range [0, 1]


      var opacity = _createOpacity.call(this, options); // Create a default icon if needed.


      var icon = _createIcon.call(this, options); // Create a default zIndex if needed


      var zIndex = _createZIndex.call(this, options); // create default style


      style = UtilityFactory.create(Constants.UTILITY.CreateStyle, {
        rendererHint: "Basic",
        opacity: opacity,
        iconUrl: icon,
        fillColor: color,
        strokeColor: color,
        zIndex: zIndex
      });
    }

    return style;
  }

  function _createZIndex(options) {
    var zIndex;

    if (options.hasOwnProperty("zIndex")) {
      zIndex = options.zIndex;
    } else {
      zIndex = Constants.DISPLAY.DEFAULT_RASTER;
    }

    return zIndex;
  }

  function _createIcon(options) {
    var icon;

    if (options.hasOwnProperty("icon")) {
      icon = options.icon;
    } else {
      icon = DEFAULT_ICON;
    }

    return icon;
  }
  /**
   * Creates opacity
   * @param options
   * @returns {*}
   * @private
   */


  function _createOpacity(options) {
    var opacity;

    if (options.hasOwnProperty("opacity")) {
      opacity = options.opacity / 100.0;
    } else {
      opacity = 1.0;
    }

    return opacity;
  }
  /**
   * Creates color.
   * @param options
   * @returns {*}
   * @private
   */


  function _createColor(options) {
    var color;

    if (options.hasOwnProperty("color")) {
      color = options.color instanceof Array ? options.color : UtilityFactory.create(Constants.UTILITY.FeatureStyle).fromStringToColor(options.color);
    } else {
      // Generate random color
      var rgb = Utils.generateColor();
      color = rgb.concat([1]);
    }

    return color;
  }
  /**************************************************************************************************************/


  Utils.inherits(Event, AbstractLayer);
  /**************************************************************************************************************/

  /**
   * Tests if the layer must be refreshed.
   * @param {string} param parameter
   * @param value value
   * @return {boolean} true when the layer must be refreshed otherwise false
   * @private
   */

  AbstractLayer.prototype._hasToBeRefreshed = function (param, value) {
    var baseUrlMustBeRefreshed;

    if (param === "time" && this.containsDimension(param)) {
      // Time is set and we have a temporal layer => refresh base URL
      var time = Time.parse(value);
      this.time = time;
      baseUrlMustBeRefreshed = this.imageLoadedAtTime[param] !== time.date.toISOString();
      this.imageLoadedAtTime[param] = time.date.toISOString();
    } else if (param === "time") {
      // no temporal layer but time is asked => no refresh base URL
      baseUrlMustBeRefreshed = false;
      this.imageLoadedAtTime[param] = undefined;
    } else {
      baseUrlMustBeRefreshed = this.imageLoadedAtTime[param] !== value;
      this.imageLoadedAtTime[param] = value;
    }

    return baseUrlMustBeRefreshed;
  };

  AbstractLayer.prototype.hasDimension = function () {
    return this.dimension != null;
  };

  AbstractLayer.prototype.getDimensions = function () {
    return this.dimension == null ? {} : this.dimension;
  };

  AbstractLayer.prototype.containsDimension = function (variable) {
    return this.hasDimension() && this.dimension[variable] != null;
  };
  /**
   * return short name
   * @function getShortName
   * @memberof AbstractLayer#
   * @return {string} Short name
   */


  AbstractLayer.prototype.getShortName = function () {
    var shortName = Utils.formatId(this.name);

    if (typeof shortName === "string") {
      shortName = shortName.replace(/[^a-z0-9\s]/gi, "").replace(/[_\s]/g, "-");
    }

    return shortName;
  };
  /**************************************************************************************************************/

  /**
   * @function hasServicesRunningOnCollection
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.hasServicesRunningOnCollection = function () {
    return this.servicesRunningOnCollection.length > 0;
  };
  /**************************************************************************************************************/

  /**
   * @function postProcessDateTime
   * @memberof AbstractLayer#
   */

  /*        AbstractLayer.prototype.postProcessTime = function (time) {
       return time;
       };
       */

  /**************************************************************************************************************/

  /**
   * @function setDateTime
   * @memberof AbstractLayer#
   * @param {Time.configuration} time configuration
   */


  AbstractLayer.prototype.setTime = function (time) {
    this.time = time;
  };
  /**************************************************************************************************************/

  /**
   * @function forceRefresh
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.forceRefresh = function () {
    if (this.getGlobe()) {
      var tileManager = this.getGlobe().getTileManager();
      tileManager.updateVisibleTiles(this);
    }
  };
  /**
   * @function getServicesRunningOnCollection
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getServicesRunningOnCollection = function () {
    var layers = [];

    for (var layerIndex in this.servicesRunningOnCollection) {
      var layerID = this.servicesRunningOnCollection[layerIndex];
      var layer = this.callbackContext.getLayerByID(layerID);

      if (layer != null) {
        layers.push(layer);
      }
    }

    return layers;
  };
  /**
   * @function removeServicesRunningOnCollection
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.removeServicesRunningOnCollection = function () {
    for (var layerIndex in this.servicesRunningOnCollection) {
      var layerID = this.servicesRunningOnCollection[layerIndex];
      this.callbackContext.removeLayer(layerID);
    }

    return this.servicesRunningOnCollection.length === 0;
  };
  /**
   * @function hasServicesRunningOnRecords
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.hasServicesRunningOnRecords = function () {
    return Object.keys(this.servicesRunningOnRecords).length > 0;
  };
  /**
   * @function getServicesRunningOnRecords
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getServicesRunningOnRecords = function () {
    var layers = [];

    for (var featureIndex in this.servicesRunningOnRecords) {
      var featureID = this.servicesRunningOnRecords[featureIndex];
      layers = layers.concat(this.getServicesRunningOnRecord(featureID));
    }

    return layers;
  };
  /**
   * @function removeServicesRunningOnRecords
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.removeServicesRunningOnRecords = function () {
    for (var featureID in this.servicesRunningOnRecords) {
      this.removeServicesRunningOnRecord(featureID);
    }

    return Object.keys(this.servicesRunningOnRecords).length === 0;
  };
  /**
   * @function hasServicesRunningOnRecord
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.hasServicesRunningOnRecord = function (featureID) {
    return this.servicesRunningOnRecords.hasOwnProperty(featureID);
  };
  /**
   * @function getServicesRunningOnRecord
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getServicesRunningOnRecord = function (featureID) {
    var layers = [];

    if (this.hasServicesRunningOnRecord(featureID)) {
      var servicesForFeatureID = this.servicesRunningOnRecords[featureID];

      for (var layerIndex in servicesForFeatureID.layerIds) {
        var layerID = servicesForFeatureID[layerIndex];
        var layer = this.callbackContext.getLayerByID(layerID);

        if (layer != null) {
          layers.push(layer);
        }
      }
    }

    return layers;
  };
  /**
   * @function addServicesRunningOnRecord
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.addServicesRunningOnRecord = function (featureID, layerIDs) {
    var isAdded;

    if (featureID != null && layerIDs != null && !this.hasServicesRunningOnRecord(featureID)) {
      var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
      this.servicesRunningOnRecords[featureID] = {
        layerIds: layersIDArray
      };
      isAdded = true;
    } else {
      isAdded = false;
    }

    return isAdded;
  };
  /**
   * @function removeServicesRunningOnRecord
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.removeServicesRunningOnRecord = function (featureID) {
    var isRemoved;

    if (this.hasServicesRunningOnRecord(featureID)) {
      var servicesForFeatureID = this.servicesRunningOnRecords[featureID];

      for (var layerIndex in servicesForFeatureID.layerIds) {
        var layerID = servicesForFeatureID.layerIds[layerIndex];
        this.callbackContext.removeLayer(layerID);
      }

      delete this.servicesRunningOnRecords[featureID];
      isRemoved = true;
    } else {
      isRemoved = false;
    }

    return isRemoved;
  };
  /**
   * @function addServicesRunningOnCollection
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.addServicesRunningOnCollection = function (layerIDs) {
    var isAdded;

    if (layerIDs != null) {
      var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
      this.servicesRunningOnCollection = this.servicesRunningOnCollection.concat(layersIDArray);
      isAdded = true;
    } else {
      isAdded = false;
    }

    return isAdded;
  };
  /**************************************************************************************************************/

  /**
   * Get getCapabilities url
   * @function getGetCapabilitiesUrl
   * @memberof AbstractLayer#
   * @return {string} url
   */


  AbstractLayer.prototype.getGetCapabilitiesUrl = function () {
    return this.getCapabilitiesUrl;
  };
  /**************************************************************************************************************/

  /**
   * @function getMetadataAPI
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getMetadataAPI = function () {
    return this.metadataAPI;
  };
  /**
   * @function getGlobe
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getGlobe = function () {
    return this.globe;
  };
  /**
   * @function getID
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getID = function () {
    return this.ID;
  };
  /**
   * @function getName
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getName = function () {
    return this.name;
  };
  /**
   * @function getInformationType
   * @memberof AbstractLayer#
   * @abstract
   */


  AbstractLayer.prototype.getInformationType = function () {
    throw new SyntaxError("AbstractLayer.js: getInformationType not implemented");
  };
  /**
   * @function getAttribution
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getAttribution = function () {
    return this.attribution;
  };
  /**
   * @function getCopyrightUrl
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getCopyrightUrl = function () {
    return this.copyrightUrl;
  };
  /**
   * @function getAck
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getAck = function () {
    return this.ack;
  };
  /**
   * @function getDescription
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getDescription = function () {
    return this.description;
  };
  /**
   * @function isVisible
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isVisible = function () {
    return this.visible;
  };
  /**
   * @function setOnTheTop
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.setOnTheTop = function () {
    var manager = this.getGlobe().getRendererManager();
    manager.setSelectedRasterBucket(this);
  };
  /**
   * @function setVisible
   * @memberof AbstractLayer#
   * @throws {TypeError} - The parameter of setVisible should be a boolean
   */


  AbstractLayer.prototype.setVisible = function (arg) {
    if (typeof arg === "boolean") {
      if (this.visible !== arg && this.getGlobe().attributionHandler) {
        this.getGlobe().attributionHandler.toggleAttribution(this);
      }

      this.visible = arg;

      if (!this.isBackground() && this.visible) {
        this.setOnTheTop();
      }

      var ctxTime = this.callbackContext.getTime();

      if (ctxTime !== this.time) {
        this.setTime(ctxTime);
      } // Manage autoFillTimeTravel


      if (this.autoFillTimeTravel === true) {
        if (this.visible === true) {
          //add !
          if (this.callbackContext.timeTravelService) {
            this.callbackContext.timeTravelService.update(this.timeTravelValues);
          }
        } else {
          // Remove
          if (this.callbackContext.timeTravelService) {
            this.callbackContext.timeTravelService.update({
              remove: {
                ID: this.ID
              }
            });
          }
        }
      }

      this.getGlobe().getRenderContext().requestFrame();
      this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
    } else {
      throw new TypeError("AbstractLayer.js: the parameter of visible should be a boolean");
    }
  };
  /**
   * @function getOpacity
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getOpacity = function () {
    return this.getStyle().getOpacity();
  };
  /**
   * @function setOpacity
   * @memberof AbstractLayer#
   * @throws {RangeError} opacity - opacity value should be a value in [0..1]
   */


  AbstractLayer.prototype.setOpacity = function (arg) {
    var style = this.getStyle();
    style.setOpacity(arg);
    this.getGlobe().getRenderContext().requestFrame();
    this.publish(Constants.EVENT_MSG.LAYER_OPACITY_CHANGED, this);
  };
  /**
   * @function getProperties
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getProperties = function () {
    return this.properties;
  };
  /**
   * @function getType
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getType = function () {
    return this.type;
  };
  /**
   * @function isPickable
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isPickable = function () {
    return this.pickable;
  };
  /**
   * @function isType
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isType = function (type) {
    return this.type === type;
  };
  /**
   * @function getServices
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getServices = function () {
    return this.services;
  };
  /**
   * @function getCoordinateSystem
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getCoordinateSystem = function () {
    return this.coordinateSystem;
  };
  /**
   * @function isAttached
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isAttached = function () {
    return !this.isDetached;
  };
  /**
   * @function isDetached
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isDetached = function () {
    return this.globe == null;
  };
  /**
   * @function _attach
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype._attach = function (g) {
    this.globe = g;

    if (this.attribution && this.globe.attributionHandler && this.isVisible()) {
      this.globe.attributionHandler.addAttribution(this);
    }
  };
  /**
   * @function _detach
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype._detach = function () {
    if (this.attribution && this.globe.attributionHandler) {
      this.globe.attributionHandler.removeAttribution(this);
    }

    this.globe = null;
  };
  /**
   * @function getBaseUrl
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getBaseUrl = function () {
    return this.baseUrl;
  };
  /**
   * @function getDataType
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getDataType = function () {
    return this.dataType;
  };
  /**
   * @function getFormat
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getFormat = function () {
    return this.format;
  };
  /**
   * @function isDeletable
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isDeletable = function () {
    return this.deletable;
  };
  /**
   * @function getStyle
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.getStyle = function () {
    return this.style;
  };
  /**
   * Sets the vector layer style.
   * @function setStyle
   * @memberof AbstractLayer#
   * @param {FeatureStyle} arg Feature style
   */


  AbstractLayer.prototype.setStyle = function (arg) {
    this.style = arg;
  };
  /**
   * @function isBackground
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isBackground = function () {
    return this.background;
  };
  /**
   * @function isVectorLayer
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.isVectorLayer = function () {
    return this.vectorLayer;
  };
  /**
   * Decrypt time range to generate time travel informations
   * @function generateTimeTravel
   * @param {string} timeDetails Details of time range
   * @memberof AbstractLayer#
   */


  AbstractLayer.prototype.generateTimeTravel = function (timeDetails) {
    if (timeDetails) {
      // In a general case, timeDetails.value could have this shape:
      //  val1,val2,min1/max1/step1,val3,min2/max2/step2
      var timesDefinition = timeDetails.value.split(",");
      var distinctValues = []; // records the distinct values : val1,val2,val3

      var sampleValues = []; // records the samples values : min1/max1/step1,min2/max2/step2

      var timeDefinition; // We need to iter because it is possible that we have a mix of distinct values and sample values

      for (var i = 0; i < timesDefinition.length; i++) {
        timeDefinition = timesDefinition[i].trim();

        if (Time.isDistinctValue(timeDefinition)) {
          distinctValues.push(timeDefinition);
        } else if (Time.isSampling(timeDefinition)) {
          sampleValues.push(timeDefinition);
        } else {
          ErrorDialog.open(Constants.LEVEL.WARNING, "Case not handle by Mizar for timeDefinition " + timeDefinition);
        }
      } // Add distinct values in time travel


      if (distinctValues.length > 0) {
        this.timeTravelValues = {
          add: {
            enumeratedValues: distinctValues,
            ID: this.ID
          }
        };
      } // Add sample values in time travel


      if (sampleValues.length > 0) {
        var start, end, step, tmpArray, sampleDefinition;

        for (i = 0; i < sampleValues.length; i++) {
          sampleDefinition = sampleValues[i];
          tmpArray = sampleDefinition.split("/");
          start = Moment__default['default'](tmpArray[0]);
          end = Moment__default['default'](tmpArray[1]);
          step = Time.timeResolution(tmpArray[2]);
          this.timeTravelValues = {
            add: {
              start: start,
              end: end,
              stepKind: step.unit,
              stepValue: step.step,
              ID: this.ID
            }
          };
        }
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**
   * AbstractVectorLayer layer configuration
   * @typedef {AbstractVectorLayer.configuration} AbstractLayer.vector_configuration
   * @property {string} url - the url of json data to load when attaching to globe
   * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
   * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
   * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
   */

  /**
   * @name AbstractVectorLayer
   * @class
   *    Create a layer to display vector data in GeoJSON format.
   * @augments AbstractLayer
   * @param {LAYER} type - the type of the layer
   * @param {AbstractVectorLayer.configuration} options - Configuration properties for the AbstractVectorLayer
   * @constructor
   * @implements {VectorLayer}
   */

  var AbstractVectorLayer = function (type, options) {
    this.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_VECTOR;
    AbstractLayer.prototype.constructor.call(this, type, options);
    this.vectorLayer = true;
    this.url = options.url;
    this.draw = false;

    if (options.callback) {
      this.callback = options.callback;
    } else {
      this.callback = null;
    }

    this.minLevel = options.hasOwnProperty("minLevel") ? options.minLevel : 0;
    this.maxLevel = options.hasOwnProperty("maxLevel") ? options.maxLevel : 21;
    this.features = [];
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, AbstractVectorLayer);
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof AbstractVectorLayer#
   */

  AbstractVectorLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.VECTOR;
  };
  /**
   * Returns the min level for which the vector is displayed.
   * @function getMinLevel
   * @memberof AbstractVectorLayer#
   * @returns {int} Returns the min level for which the vector is displayed.
   */


  AbstractVectorLayer.prototype.getMinLevel = function () {
    return this.minLevel;
  };
  /**
   * Returns the max level for which the vector is not displayed.
   * @function getMaxLevel
   * @memberof AbstractVectorLayer#
   * @returns {int} Returns the max level for which the vector is not displayed.
   */


  AbstractVectorLayer.prototype.getMaxLevel = function () {
    return this.maxLevel;
  };
  /**
   * @function getUrl
   * @memberof AbstractVectorLayer#
   */


  AbstractVectorLayer.prototype.getUrl = function () {
    return this.url;
  };
  /**
   * @function isForDataProvider
   * @memberof AbstractVectorLayer#
   */


  AbstractVectorLayer.prototype.isForDataProvider = function () {
    return this.getUrl() === undefined;
  };
  /**
   * @function isDraw
   * @memberof AbstractVectorLayer#
   */


  AbstractVectorLayer.prototype.isDraw = function () {
    return this.draw;
  };
  /**
   * @function isDraw
   * @memberof AbstractVectorLayer#
   */


  AbstractVectorLayer.prototype.setDraw = function (value) {
    Utils.assert(typeof value === "boolean", "value is not a boolean : " + value, "AbstractVectorLayer.js");
    this.draw = value;
  };
  /**
   * Attach the vector layer to the globe
   * @function _attach
   * @memberof AbstractVectorLayer#
   * @param {AbstractGlobe} g globe
   * @private
   */


  AbstractVectorLayer.prototype._attach = function (g) {
    AbstractLayer.prototype._attach.call(this, g); // Add the feature to renderers


    for (var i = 0; i < this.features.length; i++) {
      this._addFeatureToRenderers(this.features[i]);
    }
  };
  /**
   * Detach the vector layer from the globe
   * @function _detach
   * @memberof AbstractVectorLayer#
   * @private
   */


  AbstractVectorLayer.prototype._detach = function () {
    // Remove feature from renderers
    for (var i = 0; i < this.features.length; i++) {
      this._removeFeatureFromRenderers(this.features[i]);
    }

    AbstractLayer.prototype._detach.call(this);
  };
  /**
   * Adds a feature collection, in GeoJSON format
   * @function addFeatureCollection
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} featureCollection Feature Collection
   */


  AbstractVectorLayer.prototype.addFeatureCollection = function (featureCollection) {
    // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
    var features = featureCollection.features;

    if (features) {
      for (var i = 0; i < features.length; i++) {
        this.addFeature(features[i]);
      }
    }
  };
  /**
   * Removes a feature collection, in GeoJSON format
   * @function removeFeatureCollection
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} featureCollection Feature Collection
   */


  AbstractVectorLayer.prototype.removeFeatureCollection = function (featureCollection) {
    // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
    var features = featureCollection.features;

    if (features) {
      for (var i = 0; i < features.length; i++) {
        this.removeFeature(features[i]);
      }
    }
  };
  /**
   * Check whether a feature can be considered on terrain
   */


  AbstractVectorLayer.prototype._isOnTerrain = function (feature) {
    var onTerrain = true;
    const coords = feature.geometry.coordinates;

    if (coords && coords[0] && coords[0][0]) {
      if (coords[0][0].length === 3) {
        const props = feature.properties || {};
        const style = props.style || {};

        if (!style.rendererHint || style.rendererHint !== "Tiled") {
          onTerrain = false;
        }
      }
    }

    return onTerrain;
  };
  /**
   * Add a feature to renderers.
   * @function _addFeatureToRenderers
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} feature Feature
   * @private
   */


  AbstractVectorLayer.prototype._addFeatureToRenderers = function (feature) {
    var geometry = feature.geometry; // Manage style, if undefined try with properties, otherwise use defaultStyle

    var style;
    var props = feature.properties;

    if (props && props.style) {
      style = props.style;
    } else {
      style = Object.assign({}, this.style);
    }

    style.zIndex = this.zIndex;
    style.onTerrain = this._isOnTerrain(feature); // Manage geometry collection

    if (geometry.type === "GeometryCollection") {
      var geoms = geometry.geometries;

      for (var i = 0; i < geoms.length; i++) {
        this.getGlobe().getRendererManager().addGeometry(this, geoms[i], style);
      }
    } else {
      // Add geometry to renderers
      this.getGlobe().getRendererManager().addGeometry(this, geometry, style);
    }
  };
  /**
   * Removes a feature from renderers.
   * @function _removeFeatureFromRenderers
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} feature Feature
   * @returns {boolean} true when the feature is removed from the globe otherwise false
   * @private
   */


  AbstractVectorLayer.prototype._removeFeatureFromRenderers = function (feature) {
    var isRemoved = true;
    var geometry = feature.geometry; // Manage geometry collection

    if (geometry.type === "GeometryCollection") {
      var geoms = geometry.geometries;

      if (this.getGlobe() && this.getGlobe().getRendererManager()) {
        for (var i = 0; i < geoms.length; i++) {
          isRemoved = isRemoved && this.getGlobe().getRendererManager().removeGeometry(geoms[i], this);
        }
      } else {
        isRemoved = false;
      }
    } else if (this.getGlobe() && this.getGlobe().getRendererManager()) {
      isRemoved = this.getGlobe().getRendererManager().removeGeometry(geometry, this);
    } else {
      isRemoved = false;
    }

    return isRemoved;
  };
  /**
   * Add a feature to the layer
   * @function addFeature
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} feature Feature
   */


  AbstractVectorLayer.prototype.addFeature = function (feature) {
    // Check feature geometry : only add valid feature
    var geometry = feature.geometry;

    if (!geometry || !geometry.type) {
      return;
    }

    this.features.push(feature); // Add features to renderer if layer is attached to planet

    if (this.getGlobe()) {
      this._addFeatureToRenderers(feature);

      if (this.isVisible()) {
        this.getGlobe().getRenderContext().requestFrame();
      }
    }
  };
  /**
   * Removes a feature from the layer.
   * @function removeFeature
   * @memberof AbstractVectorLayer#
   * @param {GeoJSON} feature Feature
   */


  AbstractVectorLayer.prototype.removeFeature = function (feature) {
    var index = this.features.indexOf(feature);
    this.features.splice(index, 1);

    if (this.getGlobe()) {
      this._removeFeatureFromRenderers(feature);

      if (this.isVisible()) {
        this.getGlobe().getRenderContext().requestFrame();
      }
    }
  };
  /**
   * Removes all features from the layer.
   * @function removeAllFeatures
   * @memberof AbstractVectorLayer#
   */


  AbstractVectorLayer.prototype.removeAllFeatures = function () {
    // Remove feature from renderers
    if (this.getGlobe()) {
      for (var i = 0; i < this.features.length; i++) {
        this._removeFeatureFromRenderers(this.features[i]);
      }
    }

    this.features.length = 0; // Refresh rendering if needed

    if (this.getGlobe() && this.isVisible()) {
      this.getGlobe().getRenderContext().requestFrame();
    }
  };
  /**
   * Modifies the feature style for a specific feature.
   * @function modifyFeatureStyle
   * @memberof AbstractVectorLayer#
   * @param {GeoJson} feature feature for which the feature style is modified
   * @param {FeatureStyle} style Feature style
   */


  AbstractVectorLayer.prototype.modifyFeatureStyle = function (feature, style) {
    if (this._removeFeatureFromRenderers(feature)) {
      feature.properties.style = style;

      this._addFeatureToRenderers(feature);
    }
  };
  /**
   * Modifies the feature style for all features.
   * @function modifyStyle
   * @memberof AbstractVectorLayer#
   * @param {FeatureStyle} style Feature style
   */


  AbstractVectorLayer.prototype.modifyStyle = function (style) {
    var i;

    for (i = 0; i < this.features.length; i++) {
      this._removeFeatureFromRenderers(this.features[i]);
    }

    this.setStyle(style);

    for (i = 0; i < this.features.length; i++) {
      this._addFeatureToRenderers(this.features[i]);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Vector layer configuration
   * @typedef {AbstractLayer.configuration} AbstractLayer.vector_configuration
   * @property {string} url - the url of json data to load when attaching to globe
   * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
   * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
   * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
   */

  /**
   * @name VectorLayer
   * @class
   *    Create a layer to display vector data in GeoJSON format.
   * @augments AbstractVectorLayer
   * @param {AbstractLayer.vector_configuration} options - Vector configuration
   * @constructor
   * @memberof module:Layer
   */

  var VectorLayer = function (options) {
    AbstractVectorLayer.prototype.constructor.call(this, Constants.LAYER.Vector, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractVectorLayer, VectorLayer);

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var navigation, mizarAPI$2, onselect, measureLayer, self$2, dragging;
  /**********************************************************************************************/

  /**
   * Get first Geo pick point in terms of cursor position
   * @param event
   * @returns {Array} geoPickPoint geo position on the planet
   */

  function _handleMouseDown$1(event) {
    event.preventDefault();

    if (!self$2.activated) {
      return;
    }

    navigation.stop();
    dragging = true;
    self$2.elevations = [];

    if (event.type.search("touch") >= 0) {
      self$2.pickPoint = [event.changedTouches[0].offsetX, event.changedTouches[0].offsetY];
    } else {
      self$2.pickPoint = [event.layerX, event.layerY];
    }

    var geo = mizarAPI$2.getActivatedContext().getLonLatFromPixel(self$2.pickPoint[0], self$2.pickPoint[1]);

    if (geo !== null) {
      self$2.geoPickPoint = geo;
    } else {
      return null;
    }

    return self$2.geoPickPoint;
  }
  /**
   * Close the measure with the last point
   * @param event
   */


  function _handleMouseUp$1(event) {
    event.preventDefault(); // Compute geo radius

    var stopPickPoint;

    if (event.type.search("touch") >= 0) {
      stopPickPoint = mizarAPI$2.getActivatedContext().getLonLatFromPixel(event.changedTouches[0].offsetX, event.changedTouches[0].offsetY);
    } else {
      stopPickPoint = mizarAPI$2.getActivatedContext().getLonLatFromPixel(event.layerX, event.layerY);
    } // No point found, picking was not on planet but sky


    if (!_$1.isEmpty(stopPickPoint)) {
      // Find angle between start and stop vectors which is in fact the radius
      var dotProduct = vec3.dot(vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(stopPickPoint)), vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(self$2.geoPickPoint)));
      var theta = Math.acos(dotProduct);
      self$2.geoDistance = Numeric.toDegree(theta);

      if (onselect) {
        onselect();
      }
    }

    navigation.start();
    dragging = false;
  }
  /**
   * Update drawing and label in terms of current point
   * @param event
   */


  function _handleMouseMove$1(event) {
    event.preventDefault();

    if (!self$2.activated || !dragging) {
      return;
    }

    if (event.type.search("touch") >= 0) {
      self$2.secondPickPoint = [event.changedTouches[0].offsetX, event.changedTouches[0].offsetY];
    } else {
      self$2.secondPickPoint = [event.layerX, event.layerY];
    }

    var geo = mizarAPI$2.getActivatedContext().getLonLatFromPixel(self$2.secondPickPoint[0], self$2.secondPickPoint[1]);

    if (geo !== null) {
      self$2.secondGeoPickPoint = mizarAPI$2.getActivatedContext().getLonLatFromPixel(self$2.secondPickPoint[0], self$2.secondPickPoint[1]);
    } else {
      return;
    } //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);
    // Update radius


    self$2.distance = Math.sqrt(Math.pow(self$2.secondPickPoint[0] - self$2.pickPoint[0], 2) + Math.pow(self$2.secondPickPoint[1] - self$2.pickPoint[1], 2));
    var dotProduct;

    if (self$2.secondGeoPickPoint === undefined) {
      dotProduct = vec3.dot(vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(self$2.secondPickPoint)), vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(self$2.geoPickPoint)));
    } else {
      dotProduct = vec3.dot(vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(self$2.secondGeoPickPoint)), vec3.normalize(mizarAPI$2.getCrs().get3DFromWorld(self$2.geoPickPoint)));
    }

    var theta = Math.acos(dotProduct);
    self$2.geoDistance = Numeric.toDegree(theta);
    updateMeasure();
  }
  /**********************************************************************************************/


  function rotateVector2D(vec, theta) {
    theta = Numeric.toRadian(theta);
    var cs = Math.cos(theta);
    var sn = Math.sin(theta);
    return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
  }
  /**********************************************************************************************/

  /**
   * Computes the measure for the given pick point depending on the second point (used to draw)
   * @returns {Array} points to draw
   */


  function computeMeasure() {
    var geoDiff = [self$2.secondGeoPickPoint[0] - self$2.geoPickPoint[0], self$2.secondGeoPickPoint[1] - self$2.geoPickPoint[1], 0];
    var diff = vec3.create(geoDiff);
    var length = vec3.length(diff);
    vec3.normalize(diff);
    vec3.scale(diff, length * 0.001); // First arrow

    var arrow = rotateVector2D(diff, 30);
    var arrow2 = rotateVector2D(diff, -30);
    arrow = [self$2.geoPickPoint[0] + 10 * arrow[0], self$2.geoPickPoint[1] + 10 * arrow[1]];
    arrow2 = [self$2.geoPickPoint[0] + 10 * arrow2[0], self$2.geoPickPoint[1] + 10 * arrow2[1]]; // Second arrow

    var diff2 = [-diff[0], -diff[1]];
    var arrow3 = rotateVector2D(diff2, 30);
    var arrow4 = rotateVector2D(diff2, -30);
    arrow3 = [self$2.secondGeoPickPoint[0] + 10 * arrow3[0], self$2.secondGeoPickPoint[1] + 10 * arrow3[1]];
    arrow4 = [self$2.secondGeoPickPoint[0] + 10 * arrow4[0], self$2.secondGeoPickPoint[1] + 10 * arrow4[1]];
    var points = [[arrow[0], arrow[1], null], [self$2.geoPickPoint[0], self$2.geoPickPoint[1], null], [arrow2[0], arrow2[1], null], [self$2.geoPickPoint[0], self$2.geoPickPoint[1], null], [self$2.secondGeoPickPoint[0], self$2.secondGeoPickPoint[1], null], [arrow3[0], arrow3[1], null], [self$2.secondGeoPickPoint[0], self$2.secondGeoPickPoint[1], null], [arrow4[0], arrow4[1], null]];
    return points;
  }
  /**********************************************************************************************/


  function remove() {
    self$2.clear();
    mizarAPI$2.getPlanetContext().removeDraw(measureLayer);
  }

  function createGeoJsonMeasurement(coordinates) {
    return {
      geometry: {
        gid: "measureShape",
        coordinates: coordinates,
        type: Constants.GEOMETRY.LineString,
        crs: {
          type: "name",
          properties: {
            name: mizarAPI$2.getCrs().getGeoideName()
          }
        }
      },
      properties: {
        style: new FeatureStyle({
          fillColor: [1, 0, 0, 1],
          zIndex: Constants.DISPLAY.SERVICE_VECTOR
        })
      },
      type: "Feature"
    };
  }

  function createGeoJsonLabel(geoCenter, distance) {
    return {
      geometry: {
        type: Constants.GEOMETRY.Point,
        gid: "measureShape",
        coordinates: geoCenter,
        crs: {
          type: "name",
          properties: {
            name: mizarAPI$2.getCrs().getGeoideName()
          }
        }
      },
      properties: {
        style: new FeatureStyle({
          label: distance + " km",
          fillColor: [1, 1, 1, 1],
          pointMaxSize: 600,
          zIndex: Constants.DISPLAY.SERVICE_VECTOR
        })
      }
    };
  }
  /**
   *    Updates measure coordinates
   */


  function updateMeasure() {
    self$2.clear(); // Create measurement and  apply elevation to all point of displayed arrow

    var coordinates = self$2.computeMeasure();
    self$2.measureFeature = createGeoJsonMeasurement(coordinates); // Create measurement label

    var center = [(self$2.secondPickPoint[0] + self$2.pickPoint[0]) / 2, (self$2.secondPickPoint[1] + self$2.pickPoint[1]) / 2];
    var geoCenter = mizarAPI$2.getActivatedContext().getLonLatFromPixel(center[0], center[1]);
    var distance = self$2.calculateDistanceElevation(self$2.geoPickPoint, self$2.secondGeoPickPoint);
    distance = Numeric.roundNumber(distance.toFixed(3), 2);
    self$2.measureLabel = createGeoJsonLabel(geoCenter, distance); // add measurement and label to the the GeoJson collection

    measureLayer.addFeature(self$2.measureFeature);
    measureLayer.addFeature(self$2.measureLabel);
  }
  /**************************************************************************************************************/

  /**
   *    Clear measureFeature and measureLabel
   */


  function clear() {
    if (self$2.measureFeature) {
      measureLayer.removeFeature(self$2.measureFeature);
    }

    if (self$2.measureLabel) {
      measureLayer.removeFeature(self$2.measureLabel);
    }
  }
  /**************************************************************************************************************/

  /**
   * Calculate intermediaries elevation points to increase drawing precision
   *
   * @param {Object} options
   *              <ul>
   *                  <li>nbPoints : number of intermediary points to compute</li>
   *              </ul>
   * @param {Array} firstPoint
   * @param {Array} secondPoint
   * @return {Array} intermediatePoints
   */


  function calculateIntermediateElevationPoint(options, firstPoint, secondPoint) {
    var nbPoints = options.nbPoints | 50;
    var deltaX = firstPoint[0] - secondPoint[0];
    var intervalX;

    if (deltaX > 180.0) {
      deltaX = 360.0 - deltaX;
      intervalX = -deltaX / nbPoints;
    } else if (deltaX < -180.0) {
      deltaX = 360.0 + deltaX;
      intervalX = deltaX / nbPoints;
    } else {
      intervalX = deltaX / nbPoints;
    }

    var intervalY = (firstPoint[1] - secondPoint[1]) / nbPoints;
    var intermediatePoints = [];
    intermediatePoints[0] = firstPoint;

    for (var i = 1; i < nbPoints; i++) {
      var x = intermediatePoints[i - 1][0] - intervalX;

      if (x > 180.0) {
        x = x - 360;
      } else if (x < -180.0) {
        x = x + 360;
      }

      var y = intermediatePoints[i - 1][1] - intervalY;
      intermediatePoints[i] = [x, y];
    }

    intermediatePoints[nbPoints] = secondPoint;
    return intermediatePoints;
  }
  /**
   * Calculate distance elevation from a point
   *
   * url calcul distance : http://www.movable-type.co.uk/scripts/latlong.html
   *
   * @param {Array} firstPoint
   * @param {Array} secondPoint
   * @returns {number} distance elevation in kilometers
   */


  function calculateDistanceElevation(firstPoint, secondPoint) {
    var R = mizarAPI$2.getCrs().getGeoide().getRealPlanetRadius();
    var phi1 = Numeric.toRadian(firstPoint[1]);
    var phi2 = Numeric.toRadian(secondPoint[1]);
    var delta_phi = Numeric.toRadian(secondPoint[1] - firstPoint[1]);
    var delta_lambda = Numeric.toRadian(secondPoint[0] - firstPoint[0]);
    var a = Math.sin(delta_phi / 2) * Math.sin(delta_phi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(delta_lambda / 2) * Math.sin(delta_lambda / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var distance = R * c;
    return distance / 1000;
  }
  /**
   * Calculate distance and elevation for a given point and store it
   * @param {Array} firstPoint
   * @param {Array} secondPoint
   */


  function storeDistanceAndElevation(firstPoint, secondPoint) {
    var distance = self$2.calculateDistanceElevation(firstPoint, secondPoint);
    distance = Numeric.roundNumber(distance.toFixed(3), 2);
    var elevation = mizarAPI$2.getActivatedContext().getElevation(secondPoint[0], secondPoint[1]);
    var scale = mizarAPI$2.getActivatedContext().getBaseElevation().getScale();
    elevation = Numeric.roundNumber(elevation / scale, 0);
    var pointElevation = [distance, elevation];
    self$2.elevations.push(pointElevation);
  }
  /**
   * Updates Mizar context
   * @param {Mizar} mizar
   * @fires Context#backgroundLayer:added
   * @fires Context#layer:added
   */


  function updateContext(mizar) {
    mizarAPI$2 = mizar;
    navigation = mizarAPI$2.getActivatedContext().getNavigation();
    dragging = false; // Layer containing measure feature

    if (!measureLayer) {
      measureLayer = new VectorLayer();
    }

    mizarAPI$2.getPlanetContext().addDraw(measureLayer);
    this.activated = false;
    this.renderContext = mizarAPI$2.getRenderContext();
    this.elevations = [];
    this.measureFeature = null;
  }

  var MeasureToolPlanetCore = {
    init: function (options) {
      mizarAPI$2 = options.mizar;
      navigation = mizarAPI$2.getActivatedContext().getNavigation();
      onselect = options.onselect;
      self$2 = this;
      dragging = false; // Layer containing measure feature

      measureLayer = mizarAPI$2.LayerFactory.create({
        type: Constants.LAYER.Vector,
        visible: true
      });
      mizarAPI$2.getPlanetContext().addDraw(measureLayer);
      this.activated = false;
      this.renderContext = mizarAPI$2.getRenderContext();
      this.elevations = [];
      this.measureFeature = null;
    },
    _handleMouseDown: _handleMouseDown$1,
    _handleMouseUp: _handleMouseUp$1,
    _handleMouseMove: _handleMouseMove$1,
    clear: clear,
    remove: remove,
    updateContext: updateContext,
    calculateIntermediateElevationPoint: calculateIntermediateElevationPoint,
    calculateDistanceElevation: calculateDistanceElevation,
    computeMeasure: computeMeasure,
    storeDistanceAndElevation: storeDistanceAndElevation
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var mizarAPI$3, navigation$1, onselect$1, measureLayer$1, self$3, dragging$1;
  /**********************************************************************************************/

  /**
   * Get first Geo pick point in terms of cursor position
   * @param event
   * @returns {Array} geoPickPoint geo position on the planet
   */

  function _handleMouseDown$2(event) {
    event.preventDefault();

    if (!self$3.activated) {
      return;
    }

    self$3.distance = 0; // Disable standard navigation events

    navigation$1.stop();
    dragging$1 = true;
    self$3.elevations = [];

    if (event.type.search("touch") >= 0) {
      self$3.pickPoint = [event.changedTouches[0].offsetX, event.changedTouches[0].offsetY];
    } else {
      self$3.pickPoint = [event.layerX, event.layerY];
    }

    self$3.geoPickPoint = mizarAPI$3.getActivatedContext().getLonLatFromPixel(self$3.pickPoint[0], self$3.pickPoint[1]);
  }
  /**
   * Close the measure with the last point
   * @param event
   */


  function _handleMouseUp$2(event) {
    event.preventDefault();

    if (!self$3.activated) {
      return;
    } // Compute geo radius


    var stopPickPoint;

    if (event.type.search("touch") >= 0) {
      stopPickPoint = mizarAPI$3.getActivatedContext().getLonLatFromPixel(event.changedTouches[0].offsetX, event.changedTouches[0].offsetY);
    } else {
      stopPickPoint = mizarAPI$3.getActivatedContext().getLonLatFromPixel(event.layerX, event.layerY);
    } // Find angle between start and stop vectors which is in fact the radius


    var dotProduct = vec3.dot(vec3.normalize(mizarAPI$3.getCrs().get3DFromWorld(stopPickPoint)), vec3.normalize(mizarAPI$3.getCrs().get3DFromWorld(self$3.geoPickPoint)));
    var theta = Math.acos(dotProduct);
    self$3.geoDistance = Numeric.toDegree(theta);

    if (onselect$1) {
      onselect$1();
    } // Enable standard navigation events


    navigation$1.start();
    dragging$1 = false;
  }
  /**
   * Update drawing and label in terms of current point
   * @param event
   */


  function _handleMouseMove$2(event) {
    event.preventDefault();

    if (!self$3.activated || !dragging$1) {
      return;
    }

    if (event.type.search("touch") >= 0) {
      self$3.secondPickPoint = [event.changedTouches[0].offsetX, event.changedTouches[0].offsetY];
    } else {
      self$3.secondPickPoint = [event.layerX, event.layerY];
    }

    self$3.secondGeoPickPoint = mizarAPI$3.getActivatedContext().getLonLatFromPixel(self$3.secondPickPoint[0], self$3.secondPickPoint[1]); //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);
    // Update radius

    self$3.distance = Math.sqrt(Math.pow(self$3.secondPickPoint[0] - self$3.pickPoint[0], 2) + Math.pow(self$3.secondPickPoint[1] - self$3.pickPoint[1], 2));
    var dotProduct = vec3.dot(vec3.normalize(mizarAPI$3.getCrs().get3DFromWorld(self$3.secondGeoPickPoint)), vec3.normalize(mizarAPI$3.getCrs().get3DFromWorld(self$3.geoPickPoint)));
    var theta = Math.acos(dotProduct);
    self$3.geoDistance = Numeric.toDegree(theta);
    self$3.updateMeasure();
  }
  /**************************************************************************************************************/

  /**
   * Transform coordinates to the right world space dimension
   * @param points
   * @returns {Array} points  points transformed
   */


  function computeIntersection(points) {
    var rc = self$3.renderContext;
    var tmpMat = mat4.create(); // Computes eye in world space

    mat4.inverse(rc.viewMatrix, tmpMat);
    var eye = [tmpMat[12], tmpMat[13], tmpMat[14]]; // Computes the inverse of view/proj matrix

    mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
    mat4.inverse(tmpMat); // Transforms the four corners of measured shape into world space
    // and then for each corner computes the intersection of ray starting from the eye to the sphere

    var worldCenter = [0, 0, 0];

    for (var i = 0; i < points.length; i++) {
      mat4.multiplyVec4(tmpMat, points[i]);
      vec3.scale(points[i], 1.0 / points[i][3]);
      vec3.subtract(points[i], eye, points[i]);
      vec3.normalize(points[i]);
      var ray = new Ray(eye, points[i]);
      var pos3d = ray.computePoint(ray.sphereIntersect(worldCenter, mizarAPI$3.getCrs().getGeoide().getRadius()));
      points[i] = mizarAPI$3.getCrs().getWorldFrom3D(pos3d);
    }

    return points;
  }
  /**********************************************************************************************/


  function rotateVector2D$1(vec, theta) {
    theta = Numeric.toRadian(theta);
    var cs = Math.cos(theta);
    var sn = Math.sin(theta);
    return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
  }
  /**********************************************************************************************/

  /**
   * Computes the measure for the given pick point depending on the second point (used to draw)
   * @returns {Array} points to draw
   */


  function computeMeasure$1() {
    var rc = self$3.renderContext; // Scale to [-1,1]

    var widthScale = 2 / rc.canvas.width;
    var heightScale = 2 / rc.canvas.height;
    var diff = [self$3.secondPickPoint[0] - self$3.pickPoint[0], self$3.secondPickPoint[1] - self$3.pickPoint[1]];
    Numeric.normalize2D(diff); // First arrow

    var arrow = rotateVector2D$1(diff, 30);
    var arrow2 = rotateVector2D$1(diff, -30);
    arrow = [self$3.pickPoint[0] + 10 * arrow[0], self$3.pickPoint[1] + 10 * arrow[1]];
    arrow2 = [self$3.pickPoint[0] + 10 * arrow2[0], self$3.pickPoint[1] + 10 * arrow2[1]];
    var diff2 = [-diff[0], -diff[1]];
    var arrow3 = rotateVector2D$1(diff2, 30);
    var arrow4 = rotateVector2D$1(diff2, -30);
    arrow3 = [self$3.secondPickPoint[0] + 10 * arrow3[0], self$3.secondPickPoint[1] + 10 * arrow3[1]];
    arrow4 = [self$3.secondPickPoint[0] + 10 * arrow4[0], self$3.secondPickPoint[1] + 10 * arrow4[1]];
    var points = [[self$3.pickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.pickPoint[1]) * heightScale - 1, 1, 1], [arrow[0] * widthScale - 1, (rc.canvas.height - arrow[1]) * heightScale - 1, 1, 1], [self$3.pickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.pickPoint[1]) * heightScale - 1, 1, 1], [arrow2[0] * widthScale - 1, (rc.canvas.height - arrow2[1]) * heightScale - 1, 1, 1], [self$3.pickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.pickPoint[1]) * heightScale - 1, 1, 1], [self$3.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.secondPickPoint[1]) * heightScale - 1, 1, 1], [arrow3[0] * widthScale - 1, (rc.canvas.height - arrow3[1]) * heightScale - 1, 1, 1], [self$3.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.secondPickPoint[1]) * heightScale - 1, 1, 1], [arrow4[0] * widthScale - 1, (rc.canvas.height - arrow4[1]) * heightScale - 1, 1, 1], [self$3.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self$3.secondPickPoint[1]) * heightScale - 1, 1, 1]];
    this.computeIntersection(points);
    return points;
  }
  /**********************************************************************************************/

  /**
   *    Updates measure coordinates
   */


  function updateMeasure$1() {
    self$3.clear();
    var coordinates = self$3.computeMeasure(); // Close the polygon

    coordinates.push(coordinates[0]);
    self$3.measureFeature = {
      geometry: {
        gid: "measureShape",
        coordinates: [coordinates],
        type: Constants.GEOMETRY.Polygon,
        crs: {
          type: "name",
          properties: {
            name: mizarAPI$3.getCrs().getGeoideName()
          }
        }
      },
      properties: {
        style: new FeatureStyle({
          zIndex: Constants.DISPLAY.SERVICE_VECTOR,
          fillColor: [1, 0, 0, 1]
        })
      },
      type: "Feature"
    };
    var center = [(self$3.secondPickPoint[0] + self$3.pickPoint[0]) / 2, (self$3.secondPickPoint[1] + self$3.pickPoint[1]) / 2];
    var geoCenter = mizarAPI$3.getActivatedContext().getLonLatFromPixel(center[0], center[1]);
    self$3.measureLabel = {
      geometry: {
        type: Constants.GEOMETRY.Point,
        gid: "measureShape",
        coordinates: geoCenter,
        crs: {
          type: "name",
          properties: {
            name: mizarAPI$3.getCrs().getGeoideName()
          }
        }
      },
      properties: {
        style: new FeatureStyle({
          label: mizarAPI$3.getCrs().fromDegreesToDMS(self$3.geoDistance),
          fillColor: [1, 1, 1, 1],
          zIndex: Constants.DISPLAY.SERVICE_VECTOR
        })
      }
    };
    measureLayer$1.addFeature(self$3.measureFeature);
    measureLayer$1.addFeature(self$3.measureLabel);
  }
  /**************************************************************************************************************/

  /**
   *    Clear measureFeature and measureLabel
   */


  function clear$1() {
    if (self$3.measureFeature) {
      measureLayer$1.removeFeature(self$3.measureFeature);
    }

    if (self$3.measureLabel) {
      measureLayer$1.removeFeature(self$3.measureLabel);
    }
  }

  function remove$1() {
    self$3.clear();
    mizarAPI$3.getSkyContext().removeDraw(measureLayer$1);
  }

  var MeasureToolSkyCore = {
    /**
     * @fires Context#backgroundLayer:added
     * @fires Context#layer:added
     */
    init: function (options) {
      mizarAPI$3 = options.mizar;
      navigation$1 = mizarAPI$3.getActivatedContext().getNavigation();
      onselect$1 = options.onselect;
      self$3 = this;
      dragging$1 = false; // Layer containing measure feature

      measureLayer$1 = mizarAPI$3.LayerFactory.create({
        type: Constants.LAYER.Vector,
        visible: true
      });
      mizarAPI$3.getSkyContext().addDraw(measureLayer$1);
      this.activated = false;
      this.renderContext = mizarAPI$3.getRenderContext(); // Measure attributes

      /*this.pickPoint; // Window pick point
              this.secondPickPoint; // Window second pick point
              this.geoPickPoint; // Pick point in geographic reference
              this.secondGeoPickPoint; // Pick point in geographic reference
              this.measureLabel;
              */

      this.elevations = [];
      this.measureFeature = null;
    },
    _handleMouseDown: _handleMouseDown$2,
    _handleMouseUp: _handleMouseUp$2,
    _handleMouseMove: _handleMouseMove$2,
    updateMeasure: updateMeasure$1,
    clear: clear$1,
    remove: remove$1,
    computeMeasure: computeMeasure$1,
    computeIntersection: computeIntersection
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * MocLayer configuration
   * @typedef {AbstractLayer.configuration} AbstractLayer.moc_configuration
   * @property {string} baseUrl - service URL
   * @property {int} [startOrder = 2] - Starting order of HEALPix tiling
   * @property {Object} [style] - See {@link FeatureStyle} description
   */

  /**
   * @name MocLayer
   * @class
   * This layer draws a MOC data
   * @augments AbstractLayer
   * @param {AbstractLayer.moc_configuration} options - Moc layer configuration
   * @memberof module:Layer
   * @see {@link http://www.ivoa.net/documents/MOC/20140602/index.html Moc}
   */

  var MocLayer = function (options) {
    options.dataType = Constants.GEOMETRY.LineString;
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.Moc, options);
    this.baseUrl = this.allowRequest(options.baseUrl);
    this.startOrder = options.startOrder || 2;

    if (options.coordinateSystem && options.coordinateSystem.geoideName) {
      this.crs = {
        properties: {
          name: options.coordinateSystem.geoideName
        }
      };
    } else {
      this.crs = {
        properties: {
          name: "Equatorial"
        }
      };
    } // Set style


    if (options.style) {
      this.style = new FeatureStyle(options.style);
    } else {
      this.style = new FeatureStyle();
    }

    this.featuresSet = null;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, MocLayer);
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof MocLayer#
   */

  MocLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.VECTOR;
  };
  /**
   * Attaches the layer to the planet
   * @function _attach
   * @memberof MocLayer#
   * @param g Planet
   * @protected
   */


  MocLayer.prototype._attach = function (g) {
    AbstractLayer.prototype._attach.call(this, g);

    var self = this;
    var i;

    try {
      FitsLoader.loadFits(self.baseUrl, function (fits) {
        var healpixMoc = {};
        var binaryTable = fits.getHDU(1).data; // setting startOrder with first order in dataTable
        //self.startOrder = uniq2hpix(binaryTable.getRow(0)[binaryTable.columns[0]])[0];

        for (i = 0; i < binaryTable.rows; i++) {
          var uniq = binaryTable.getRow(i);
          var hpix = HEALPixBase.uniq2hpix(uniq[binaryTable.columns[0]]);
          var order = hpix[0];

          if (healpixMoc[order] === undefined) {
            healpixMoc[order] = [];
          }

          healpixMoc[order].push(hpix[1]);
        } // MIZAR CANNOT display MOC with order less than 3, convert the current moc to a moc starting a order 3


        if (healpixMoc.hasOwnProperty("0") || healpixMoc.hasOwnProperty("1") || healpixMoc.hasOwnProperty("2")) {
          for (i = 0; i < 3; i++) {
            if (healpixMoc.hasOwnProperty(i)) {
              var pixels = healpixMoc[i];

              _$1.each(pixels, function (pixel) {
                var pix = HEALPixBase.getChildren(pixel);

                if (!healpixMoc.hasOwnProperty(i + 1)) {
                  healpixMoc[i + 1] = [];
                }

                healpixMoc[i + 1].push(pix[0]);
                healpixMoc[i + 1].push(pix[1]);
                healpixMoc[i + 1].push(pix[2]);
                healpixMoc[i + 1].push(pix[3]);
              });

              delete healpixMoc[i];
            }
          }
        }

        self.moc = healpixMoc;
        self.handleDistribution(healpixMoc);
        fits = null; //delete fits;
      });
    } catch (e) {
      Utils.requestUrl(self.baseUrl, "json", "application/json", null, function (response) {
        self.handleDistribution(response);
      }, function (err) {
        $__default['default']("#addLayer_" + self.id).find("label").css("color", "red");
        ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + self.baseUrl, err);
      });
    } // As post renderer, moc layer will regenerate data on tiles in case of base imagery change


    g.getTileManager().addPostRenderer(this);
  };
  /**************************************************************************************************************/

  /**
   * Generates moc data on tiles.
   * @function generate
   * @memberof MocLayer#
   * @param {Tile} tile Tile
   */


  MocLayer.prototype.generate = function (tile) {
    if (this.featuresSet && tile.order === this.startOrder) {
      var geometries = this.featuresSet[tile.pixelIndex];

      if (geometries) {
        for (var i = 0; i < geometries.length; i++) {
          this.getGlobe().getRendererManager().addGeometryToTile(this, geometries[i], this.style, tile);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Renders
   * @function render
   * @memberof MocLayer#
   */


  MocLayer.prototype.render = function () {// No rendering
  };
  /**************************************************************************************************************/

  /**
   * Detaches the layer from the planet
   * @function _detach
   * @memberof MocLayer#
   * @private
   */


  MocLayer.prototype._detach = function () {
    for (var tileIndex in this.featuresSet) {
      if (this.featuresSet.hasOwnProperty(tileIndex)) {
        var tile = this.getGlobe().getTileManager().level0Tiles[tileIndex];

        for (var i = 0; i < this.featuresSet[tileIndex].length; i++) {
          this.getGlobe().getRendererManager().removeGeometryFromTile(this.featuresSet[tileIndex][i], tile);
        }
      }
    }

    this.featuresSet = null;
    this.getGlobe().getTileManager().removePostRenderer(this);

    AbstractLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/

  /**
   * Returns children indices of starting tiling order.
   * @function findChildIndices
   * @memberof MocLayer#
   * @param index Parent index
   * @param order Parent order
   */


  MocLayer.prototype.findChildIndices = function (index, order) {
    var childOrder = this.startOrder;
    var orderDepth = childOrder - order;
    var numSubTiles = Math.pow(4, orderDepth); // Number of subtiles depending on order

    var firstSubTileIndex = index * numSubTiles;
    var indices = [];

    for (var i = firstSubTileIndex; i < firstSubTileIndex + numSubTiles; i++) {
      indices.push(i);
    }

    return indices;
  };
  /**************************************************************************************************************/

  /**
   * Returns index of parent of starting tiling order.
   * @function findParentIndex
   * @memberof MocLayer#
   * @param index Child index
   * @param order Child order
   */


  MocLayer.prototype.findParentIndex = function (index, order) {
    var parentOrder = this.startOrder;
    var orderDepth = order - parentOrder;
    return Math.floor(index / Math.pow(4, orderDepth));
  };
  /**************************************************************************************************************/

  /**
   * Handles MOC response.
   * @function handleDistribution
   * @memberof MocLayer#
   * @param response MOC response
   */


  MocLayer.prototype.handleDistribution = function (response) {
    this.featuresSet = {};
    var parentIndex;
    var i, u, v; // For each order, compute rectangles geometry depending on the pixel index

    for (var key in response) {
      if (response.hasOwnProperty(key)) {
        var order = parseInt(key, 10);

        for (i = 0; i < response[key].length; i++) {
          var pixelIndex = response[key][i];

          if (order > this.startOrder) {
            parentIndex = this.findParentIndex(pixelIndex, order);
          } else if (order === this.startOrder) {
            parentIndex = pixelIndex;
          } else {
            // Handle low orders(< 3) by creating children polygons of order 3
            var indices = this.findChildIndices(pixelIndex, order);

            if (response[this.startOrder.toString()] === undefined) {
              response[this.startOrder.toString()] = response[0].concat(indices);
            } else {
              response[this.startOrder.toString()] = response[this.startOrder.toString()].concat(indices);
            }

            continue;
          }

          var geometry = {
            type: Constants.GEOMETRY.Polygon,
            gid: "moc" + this.id + "_" + order + "_" + pixelIndex,
            crs: this.crs,
            coordinates: [[]]
          }; // Build the vertices

          var size = 2; // TODO

          var step = 1; // Tesselate only low-order tiles

          if (order < 5) {
            size = 5;
            step = 1.0 / (size - 1);
          }

          var nside = Math.pow(2, order);
          var pix = pixelIndex & nside * nside - 1;
          var ix = HEALPixBase.compress_bits(pix);
          var iy = HEALPixBase.compress_bits(pix >>> 1);
          var face = pixelIndex >>> 2 * order;
          var vertice, geo; // Horizontal boudaries

          for (u = 0; u < 2; u++) {
            for (v = 0; v < size; v++) {
              vertice = HEALPixBase.fxyf((ix + u * (size - 1) * step) / nside, (iy + v * step) / nside, face);
              geo = this.getGlobe().getCoordinateSystem().getWorldFrom3D(vertice);

              if (u === 0) {
                // Invert to clockwise sense
                geometry.coordinates[0][2 * u * size + (size - 1) - v] = [geo[0], geo[1]];
              } else {
                geometry.coordinates[0][2 * u * size + v] = [geo[0], geo[1]];
              }
            }
          } // Vertical boundaries


          for (v = 0; v < 2; v++) {
            for (u = 0; u < size; u++) {
              vertice = HEALPixBase.fxyf((ix + u * step) / nside, (iy + v * (size - 1) * step) / nside, face);
              geo = this.getGlobe().getCoordinateSystem().getWorldFrom3D(vertice);

              if (v === 1) {
                // Invert to clockwise sense
                geometry.coordinates[0][size + 2 * v * size + (size - 1) - u] = [geo[0], geo[1]];
              } else {
                geometry.coordinates[0][size + 2 * v * size + u] = [geo[0], geo[1]];
              }
            }
          }

          var parentTile = this.getGlobe().getTileManager().level0Tiles[parentIndex];

          if (!this.featuresSet[parentIndex]) {
            this.featuresSet[parentIndex] = [];
          }

          this.featuresSet[parentIndex].push(geometry);
          this.getGlobe().getRendererManager().addGeometryToTile(this, geometry, this.style, parentTile);
        }
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var mizarAPI$4;
  var coverageServiceUrl;
  /**************************************************************************************************************/

  /**
   *    Create moc sublayer
   *
   *    @param layer Parent layer
   *    @fires Context#layer:add
   */

  function createMocSublayer(layer, successCallback, errorCallback) {
    var ID;

    if (layer.getBaseUrl()) {
      ID = handleMocLayer(layer, layer.getBaseUrl());
      var mocLayer = mizarAPI$4.getLayerByID(ID);

      if (layer.skyFraction) {
        mocLayer.coverage = Numeric.roundNumber(parseFloat(layer.skyFraction) * 100, 2) + "%";
      } else {
        mocLayer.coverage = "Not available";
      }

      successCallback(mocLayer);
    } else {
      errorCallback(layer);
    }

    return ID;
  }
  /**************************************************************************************************************/

  /**
   *    Handle moc layer as a sublayer
   *
   *    @param layer Parent layer
   *    @param mocServiceUrl Url to moc service
   *    @fires Context#backgroundLayer:added
   *    @fires Context#layer:added
   */


  function handleMocLayer(layer, mocServiceUrl) {
    var style; // checks if style is defined

    if (layer.getStyle()) {
      style = layer.getStyle();
      style.fill = true;

      if (style.hasOwnProperty("fillColor")) {
        // add transparency when fill color is defined
        style.fillColor[3] = 0.3;
      } else {
        // no predefined color, set one
        style.fillColor = [1.0, 0.0, 0.0, 0.3];
      }
    } else {
      // no style, create a new one.
      style = new FeatureStyle({
        rendererHint: "Basic",
        fill: true,
        fillColor: [1.0, 0.0, 0.0, 0.3]
      });
    }

    var ID = mizarAPI$4.addLayer({
      type: Constants.LAYER.Moc,
      baseUrl: mocServiceUrl,
      style: style,
      visible: false
    });
    return ID;
  }
  /**************************************************************************************************************/

  /**
   *    Search moc sublayer
   *    @return    Moc layer if found, null otherwise
   */


  function findMocSublayer(layerID) {
    return mizarAPI$4.getLayerByID(layerID);
  }
  /**************************************************************************************************************/

  /**
   *    Intersect layers
   */


  function intersectLayers(layersToIntersect) {
    // Construct url & layerNames
    var url = coverageServiceUrl;
    var layerNames = "";

    for (var i = 0; i < layersToIntersect.length; i++) {
      var layer = layersToIntersect[i];
      layerNames += layer.getName();
      url += layer.describeUrl;

      if (i !== layersToIntersect.length - 1) {
        url += ";";
        layerNames += " x ";
      }
    } // Create intersection MOC layer


    var intersectionLayer = new MocLayer({
      name: "Intersection( " + layerNames + " )",
      serviceUrl: url + "&media=json",
      style: new FeatureStyle({
        rendererHint: "Basic",
        fill: true,
        fillColor: [1.0, 0.0, 0.0, 0.3]
      }),
      visible: false
    });
    mizarAPI$4.getSkyContext().globe.addLayer(intersectionLayer);
    intersectionLayer.describeUrl = url;
    return intersectionLayer;
  }
  /**************************************************************************************************************/


  var MocBase = {
    init: function (m, options) {
      mizarAPI$4 = m; //coverageServiceUrl = "TODO must use AbstractLayer to get info";//options.coverageService.baseUrl;
      //TODO must use AbstractLayer to get this information
    },
    createMocSublayer: createMocSublayer,
    findMocSublayer: findMocSublayer,
    //getSkyCoverage: getSkyCoverage,
    //requestSkyCoverage: requestSkyCoverage,
    intersectLayers: intersectLayers
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var mizarAPI$5;
  var mizarBaseUrl;
  var navigation$2;
  var halfPaddingX;
  var halfPaddingY;
  var halfHeight;
  var halfWidth;
  var tesselation;
  var center3d;
  var canvas$1;
  var context;
  var self$4;
  var imageObj;
  /**
   *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
   *  @param lat latitude
   *  @see https://en.wikipedia.org/wiki/Mollweide_projection
   *  @return theta
   */

  function _findTheta$1(lat) {
    // Avoid divide by zero
    if (Math.abs(lat) === Math.PI / 2) {
      return lat;
    }

    var epsilon = 0.001;
    var thetaN; // n

    var thetaN1; // n+1

    do {
      thetaN = thetaN1;

      if (!thetaN) {
        thetaN = lat;
      }

      var twoThetaN = 2 * thetaN;
      thetaN1 = twoThetaN / 2 - (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) / (2 + 2 * Math.cos(twoThetaN));
    } while (Math.abs(thetaN1 - thetaN) >= epsilon);

    return thetaN1;
  }
  /**********************************************************************************************/

  /**
   *  Canvas 2D point
   *  @param {Object} options
   *      <ul>
   *          <li>options : x,y, color, size</li>
   */


  var Point = function (options) {
    this.x = options.x | 0;
    this.y = options.y | 0;
    this.color = options.color || "rgb(255,0,0)";
    this.size = options.size | 2;

    for (var x in options) {
      if (options.hasOwnProperty(x)) {
        this[x] = options[x];
      }
    }
  };
  /**********************************************************************************************/

  /**
   *  Compute mollweide position for given 3D position
   *  @param {Array} pos position
   *  @return {Array} x,y coordinates
   */


  function computeMollweidePosition(pos) {
    var coordinateSystem = mizarAPI$5.getCrs();
    var geoPos = coordinateSystem.getWorldFrom3D(pos);
    if (geoPos[0] > 180) geoPos[0] -= 360; //var geoPos = coordinateSystem.from3DToEquatorial(pos, null, false);
    //geoPos = coordinateSystem.convert(geoPos, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());
    //geoPos = coordinateSystem.fromEquatorialToGeo(geoPos, null, false);

    var lambda = Numeric.toRadian(geoPos[0]); // longitude

    var theta0 = Numeric.toRadian(geoPos[1]); // latitude

    var auxTheta = _findTheta$1(theta0); // Transfrom to Mollweide coordinate system


    var mollX = 2 * Math.sqrt(2) / Math.PI * lambda * Math.cos(auxTheta);
    var mollY = Math.sqrt(2) * Math.sin(auxTheta); // Transform to image space
    //    2.8: max x value in Mollweide projection
    //    1.38: max y value in Mollweide projection

    var x = -mollX * halfWidth / 2.8 + halfWidth + halfPaddingX;
    var y = -mollY * halfHeight / 1.38 + halfHeight + halfPaddingY;
    return [x, y];
  }
  /**********************************************************************************************/

  /**
   *  Update navigation eye for the given mouse coordinates
   *  @param {Array} moll
   */


  function updateNavigation(moll) {
    // Transform to Mollweide space
    center3d.x = -(moll[0] - halfWidth - halfPaddingX) * 2.8 / halfWidth;
    center3d.y = -(moll[1] - halfHeight - halfPaddingY) * 1.38 / halfHeight; // Transform to geographic coordinate system
    // http://mathworld.wolfram.com/MollweideProjection.html

    var auxTheta = Math.asin(center3d.y / Math.sqrt(2));
    var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
    var lambda = Math.PI * center3d.x / (2 * Math.sqrt(2) * Math.cos(auxTheta));
    var geo = [Numeric.toDegree(lambda), Numeric.toDegree(phi)]; // Update navigation

    mizarAPI$5.getCrs().get3DFromWorld(geo, navigation$2.center3d);
    navigation$2.computeViewMatrix();
  }
  /**********************************************************************************************/

  /**
   *  Function updating the position of center of camera on mollweide element
   */


  function updateMollweideFov() {
    // Reinit canvas
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.drawImage(imageObj, 0, 0); // Draw fov

    context.fillStyle = "rgb(255,0,0)";
    var stepX = mizarAPI$5.getRenderContext().canvas.clientWidth / (tesselation - 1);
    var stepY = mizarAPI$5.getRenderContext().canvas.clientHeight / (tesselation - 1);
    var ray;
    var pos3d;
    var mPos;

    for (var i = 0; i < tesselation; i++) {
      // Width
      for (var j = 0; j < tesselation; j++) {
        // Height
        ray = Ray.createFromPixel(mizarAPI$5.getRenderContext(), i * stepX, j * stepY);
        pos3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], mizarAPI$5.getCrs().getGeoide().getRadius()));
        mPos = computeMollweidePosition(pos3d); // Draw on canvas 2d

        context.fillRect(mPos[0], mPos[1], 2, 2);
      }
    } // Draw center


    context.fillStyle = center3d.color;
    mPos = computeMollweidePosition(navigation$2.center3d);
    center3d.x = mPos[0] - center3d.size / 2;
    center3d.y = mPos[1] - center3d.size / 2; // Draw on canvas 2d

    context.fillRect(mPos[0] - center3d.size / 2, mPos[1] - center3d.size / 2, center3d.size, center3d.size); // Update fov degrees

    var fov = navigation$2.getFov();
    var fovx = Numeric.roundNumber(fov[0], 2);
    fovx = mizarAPI$5.getCrs().fromDegreesToDMS(fovx);
    var fovy = Numeric.roundNumber(fov[1], 2);
    fovy = mizarAPI$5.getCrs().fromDegreesToDMS(fovy);
    $__default['default']("#fov").html("Fov : " + fovx + " x " + fovy);
  }

  function updateGalaxyProjection(ctx) {
    $__default['default'](self$4.getImageObj()).attr("src", mizarBaseUrl + "css/images/MollweideSky_" + ctx.getCoordinateSystem().getGeoideName() + ".png");
  }
  /**********************************************************************************************/


  var MollweideViewerCore = {
    init: function (options) {
      mizarAPI$5 = options.mizar;
      mizarBaseUrl = options.mizarBaseUrl; // Init options

      navigation$2 = mizarAPI$5.getActivatedContext().getNavigation();
      halfPaddingX = 16;
      halfPaddingY = 8; // Grid background dimensions

      halfHeight = 50;
      halfWidth = 100; // Level of tesselation to represent fov

      tesselation = 9; // Must be >= 2
      // Center of fov

      center3d = new Point({
        size: 5,
        color: "rgb(255,255,0)"
      }); // Init image background

      canvas$1 = document.getElementById("mollweideCanvas");
      context = canvas$1.getContext("2d");
      self$4 = this;
      imageObj = new Image();

      imageObj.onload = function () {
        context.drawImage(imageObj, 0, 0);
        updateMollweideFov();
      };
    },
    getImageObj: function () {
      return imageObj;
    },
    _findTheta: _findTheta$1,
    computeMollweidePosition: computeMollweidePosition,
    updateNavigation: updateNavigation,
    updateMollweideFov: updateMollweideFov,
    updateGalaxyProjection: updateGalaxyProjection
  };

  var GroundOverlayLayer = function (options) {
    options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_RASTER;
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.GroundOverlay, options);
    this.geoBound = null;
    this.image = null;
    this.globe = null;
    this.flipY = null;
    this.quad = options.quad;

    if (typeof options.flipY === "undefined") {
      this.flipY = true;
    } else {
      this.flipY = options.flipY;
    }

    if (this.quad !== null && typeof this.quad !== "undefined") {
      this.geoBound = new GeoBound();
      this.geoBound.computeFromCoordinates(this.quad);
    }

    if (typeof options.image === "string") {
      this.image = new Image();
      this.image.crossOrigin = "";
      this.image.src = Proxy.proxify(options.image);
    } else if (options.image instanceof HTMLImageElement) {
      this.image = options.image;
    }

    this.image.layer = this;

    this.image.onload = function () {
      this.layer.getGlobe().refresh();
    };
  };

  Utils.inherits(AbstractLayer, GroundOverlayLayer);

  GroundOverlayLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.RASTER;
  };

  GroundOverlayLayer.prototype.loadOverview = function () {};

  GroundOverlayLayer.prototype._attach = function (planet) {
    var renderer = planet.groundOverlayRenderer;

    if (!renderer) {
      renderer = new GroundOverlayRenderer(planet.getTileManager());
      planet.getTileManager().addPostRenderer(renderer);
      planet.groundOverlayRenderer = renderer;
    }

    renderer.groundOverlays.push(this);
    this.globe = planet;
    this.computeTransform();
  };

  GroundOverlayLayer.prototype.update = function (quad, url) {
    this.getGlobe().groundOverlayRenderer.enabled = true;
    this.geoBound = null;
    this.geoBound = new GeoBound();
    this.geoBound.computeFromCoordinates(this.quad);
    this.image = null;
    this.image = new Image();
    this.image.crossOrigin = "";
    this.image.src = Proxy.proxify(url);
    this.image.layer = this;
    this.computeTransform();

    this.image.onload = function () {
      this.layer.getGlobe().refresh();
    };
  };

  GroundOverlayLayer.prototype._detach = function (planet) {
    var prevRenderer = this.getGlobe().groundOverlayRenderer;

    if (prevRenderer) {
      var index = prevRenderer.groundOverlays.indexOf(this);

      if (index !== -1) {
        prevRenderer.groundOverlays.splice(index, 1);

        if (prevRenderer.groundOverlays.length === 0) {
          this.getGlobe().getTileManager().removePostRenderer(prevRenderer);
          this.getGlobe().groundOverlayRenderer = null;
        }
      }
    }
  };

  GroundOverlayLayer.prototype.computeInverse = function () {
    var det = this.transform[0] * (this.transform[8] * this.transform[4] - this.transform[5] * this.transform[7]) - this.transform[3] * (this.transform[8] * this.transform[1] - this.transform[7]) * this.transform[3] + this.transform[6] * (this.transform[5] * this.transform[1] - this.transform[4] * this.transform[2]);
    var h11, h12, h13, h21, h22, h23, h31, h32, h33;
    h11 = this.transform[4] * this.transform[8] - this.transform[5] * this.transform[7];
    h21 = this.transform[5] * this.transform[6] - this.transform[3] * this.transform[8];
    h31 = this.transform[3] * this.transform[7] - this.transform[4] * this.transform[6];
    h12 = this.transform[2] * this.transform[7] - this.transform[1] * this.transform[8];
    h22 = this.transform[0] * this.transform[8] - this.transform[2] * this.transform[6];
    h32 = this.transform[1] * this.transform[6] - this.transform[0] * this.transform[7];
    h13 = this.transform[1] * this.transform[5] - this.transform[2] * this.transform[4];
    h23 = this.transform[2] * this.transform[3] - this.transform[0] * this.transform[5];
    h33 = this.transform[0] * this.transform[4] - this.transform[1] * this.transform[3];
    this.inverseTransform = [h11 / det, h12 / det, h13 / det, h21 / det, h22 / det, h23 / det, h31 / det, h32 / det, h33 / det];
  };

  GroundOverlayLayer.prototype.computeTransform = function () {
    if (this.quad === null) {
      return;
    }

    var q1 = this.quad[0];
    var q2 = this.quad[1];
    var q3 = this.quad[2];
    var q4 = this.quad[3];
    var tileConfig = this.getGlobe().getTileManager().tileConfig;

    if (tileConfig.srs !== "CRS:84") {
      q1 = tileConfig.project(q1);
      q2 = tileConfig.project(q2);
      q3 = tileConfig.project(q3);
      q4 = tileConfig.project(q4);
    }

    var dx0 = q1[0];
    var dx1 = q2[0];
    var dx2 = q3[0];
    var dx3 = q4[0];
    var dy0 = q1[1];
    var dy1 = q2[1];
    var dy2 = q3[1];
    var dy3 = q4[1];
    var ax = dx0 - dx1 + dx2 - dx3;
    var ay = dy0 - dy1 + dy2 - dy3;

    if (!ax && !ay) {
      this.transform = [dx1 - dx0, dy1 - dy0, 0, dx2 - dx1, dy2 - dy1, 0, dx0, dy0, 1];
    } else {
      var ax1 = dx1 - dx2;
      var ax2 = dx3 - dx2;
      var ay1 = dy1 - dy2;
      var ay2 = dy3 - dy2;
      var gtop = ax * ay2 - ax2 * ay;
      var htop = ax1 * ay - ax * ay1;
      var bottom = ax1 * ay2 - ax2 * ay1;
      var a, b, c, d, e, f, g, h;

      if (!bottom) {
        return;
      }

      g = gtop / bottom;
      h = htop / bottom;
      a = dx1 - dx0 + g * dx1;
      b = dx3 - dx0 + h * dx3;
      c = dx0;
      d = dy1 - dy0 + g * dy1;
      e = dy3 - dy0 + h * dy3;
      f = dy0;
      this.transform = [a, d, g, b, e, h, c, f, 1];
    }

    this.computeInverse();
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var OpenSearchUtils = {};

  OpenSearchUtils.getArrayBoundKey = function (tiles) {
    var key = "";

    if (tiles == null) {
      return "";
    }

    for (var i = 0; i < tiles.length; i++) {
      key += tiles[i].getKey();
    }

    return key;
  };
  /*************************************************************************************************************/

  /**
   * @function getAttributeValue
   * @memberof OpenSearchUtils#
   * @param {Object} object Object describing the parameter
   * @param {string} name Name of the parameter
   * @return {string} Value
   */


  OpenSearchUtils.getAttributeValue = function (object, name) {
    var reconstructedName = "_attr" + name;

    if (typeof object[reconstructedName] !== "undefined") {
      if (typeof object[reconstructedName]._value != "undefined") {
        return object[reconstructedName]._value;
      }
    }

    return null;
  };
  /*************************************************************************************************************/

  /**
   * Get the value
   * @function getValue
   * @memberof OpenSearchUtils#
   * @param {Object} object Object describing the parameter
   * @param {string} name Name of the parameter
   * @return {string} Value
   */


  OpenSearchUtils.getValue = function (object, name) {
    if (typeof object[name] !== "undefined") {
      if (typeof object[name]._text !== "undefined") {
        return object[name]._text;
      }
    }

    return null;
  };
  /*************************************************************************************************************/

  /**
   * Set the current value of a parameter
   * @function setCurrentValueToParam
   * @memberof OpenSearchUtils#
   * @param {OpenSearchForm} form Form
   * @param {string} name Name of the parameter
   * @param {string} value Value to set
   */


  OpenSearchUtils.setCurrentValueToParam = function (form, name, value) {
    var param; // param managed

    for (var i = 0; i < form.parameters.length; i++) {
      param = form.parameters[i];

      if (param.value === "{" + name + "}") {
        param.currentValue = value;
        $__default['default']("#p_" + name).val(value);
        break;
      }
    }
  };
  /*************************************************************************************************************/

  /**
   * Get the current value of a parameter
   * @function getCurrentValue
   * @memberof OpenSearchUtils#
   * @param {OpenSearchForm} form Form
   * @param {string} name Name of the parameter
   * @return {string} Current value
   */


  OpenSearchUtils.getCurrentValue = function (form, name) {
    var param; // param managed

    for (var i = 0; i < form.parameters.length; i++) {
      param = form.parameters[i];

      if (param.value === "{" + name + "}") {
        return param.currentValue;
      }
    }
  };
  /*************************************************************************************************************/

  /**
   * Init navigation values
   * @function initNavigationValues
   * @memberof OpenSearchUtils#
   * @param {OpenSearchForm} form Form
   */


  OpenSearchUtils.initNavigationValues = function (form) {
    var param; // param managed

    for (var i = 0; i < form.parameters.length; i++) {
      param = form.parameters[i];

      if (param.value === "{count}") {
        param.currentValue = Math.ceil(param.maxInclusive * 0.2); //param.currentValue = Math.ceil(param.maxInclusive * 1);
        //param.currentValue = 20;
      } else if (param.value === "{startPage}") {
        param.currentValue = 1;
      } else ;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name OpenSearchCache
   * @class
   * Manage the OpenSearch cache
   * @memberof module:Layer
   */

  var OpenSearchCache = function () {
    this.maxTiles = 120;
    this.tileArray = [];
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[New] " + this.getCacheStatus());
  };
  /**************************************************************************************************************/

  /**
   * Get cache status
   * @function getCacheStatus
   * @memberof OpenSearchCache#
   * @return {string} Status
   */


  OpenSearchCache.prototype.getCacheStatus = function () {
    var message = "";
    message += "Cache : " + this.tileArray.length + "/" + this.maxTiles + " (size:" + this.getSize() + ")";
    return message;
  };
  /*************************************************************************************************************/

  /**
   * Get tile cache size (in term of number of features)
   * @function getTileSize
   * @memberof OpenSearchCache#
   * @param {Tile} tile Tile
   * @return {Integer} Number of features associated to the tile
   */


  OpenSearchCache.prototype.getTileSize = function (tile) {
    return tile.features.length;
  };
  /*************************************************************************************************************/

  /**
   * Get cache size (in term of number of features)
   * @function getSize
   * @memberof OpenSearchCache#
   * @return {Integer} Number of features associated to the cache
   */


  OpenSearchCache.prototype.getSize = function () {
    var nb = 0;

    for (var i = 0; i < this.tileArray.length; i++) {
      nb += this.getTileSize(this.tileArray[i]);
    }

    return nb;
  };

  OpenSearchCache.prototype.storeInCache = function (url, features, total) {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[addTile]" + this.getCacheStatus());
    var myTile = {
      key: url,
      features: features.slice(),
      total: total
    }; // If cache is full, remove first element

    if (this.tileArray.length === this.maxTiles) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "Cache full, remove oldest");
      this.tileArray.splice(0, 1);
    }

    this.tileArray.push(myTile);
  };

  OpenSearchCache.prototype.getCacheFromKey = function (url) {
    var result = _$1.find(this.tileArray, function (tile) {
      return tile.key === url;
    });

    return result === undefined ? null : Object.assign({}, result);
  };
  /*************************************************************************************************************/

  /**
   * Reset the cache
   * @function reset
   * @memberof OpenSearchCache#
   */


  OpenSearchCache.prototype.reset = function () {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchCache", "[reset]");
    this.tileArray.length = 0;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Update status attribute.<br/>
   * Called with pagination
   * @event OpenSearchLayer#updateStatsAttribute
   * @type {OpenSearchLayer~pagination|OpenSearchLayer~result}
   */

  /**
   * Toggle WMS<br/>
   * Called to display/undisplay the WMS related to the opensearch record
   * @event OpenSearchLayer#toggleWMS
   * @type {object}
   * @property {string} layer_name Name of the layer to make visible
   * @property {boolean} visible display/undisplay the layer related to the opensearch record
   */

  /**
   * Opensearch pagination.
   * @typedef {object} OpenSearchLayer~pagination
   * @property {string} shortName of the opensearch layer
   * @property {int} current page in the query
   */

  /**
   * Opensearch result.
   * @typedef {object} OpenSearchLayer~result
   * @property {string} shortName of the opensearch layer
   * @property {int} nb_loaded number of loaded records
   * @property {int} nb_total total number of records
   */

  /**
   * The time object.
   * @typedef {object} TimeTravelParams~details
   * @property {date|moment} date - the current time.
   * @property {string} display - the current date as string for display.
   * @property {object} [period] - time period.
   * @property {moment} [period.from] - start date.
   * @property {moment} [period.to] - stop date.
   */

  /**
   * @name OpenSearchLayer
   * @class
   * This layer draws an OpenSearch dynamic layer
   * @augments AbstractLayer
   * @param {Object} options Configuration properties for the layer. See {@link AbstractLayer} for base properties
   * @param {string} options.serviceUrl Url of OpenSearch description XML file
   * @param {int} [options.minOrder=5] Starting order for OpenSearch requests
   * @param {Boolean} [options.coordSystemRequired=true]
   * @param {FeatureStyle} [options.style=new FeatureStyle()]
   * @param {int} [options.heatmapMinFeatureCount=100] The minimum feature count to not display the heatmap anymore
   * @param {int} [options.heatmapMaxLevel=5] The maximum level where the heatmap can be displayed
   * @memberof module:Layer
   */

  var OpenSearchLayer = function (options) {
    options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_VECTOR;
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.OpenSearch, options);
    this.minLevel = options.minLevel || 5;
    this.coordSystemRequired = options.hasOwnProperty("coordSystemRequired") ? options.coordSystemRequired : true;
    this.previousKey = null;
    this.previousTileId = null;
    this.previousDistance = null; // Keep trace of all features loaded (TODO: make object more light, just keep geometry and style ?)

    this.features = []; // Keep all tiles associated to a feature id to add / remove them more efficiently

    this.featuresSet = {}; // Keep trace of all tiles loaded (bound, key and features id associated)

    this.tilesLoaded = [];
    this.nbFeaturesTotal = 0; // last datetime for removing outside

    this.lastRemovingDateTime = null;
    this.removingDeltaSeconds = options.hasOwnProperty("removingDeltaSeconds") ? options.removingDeltaSeconds : 1;
    this.nbFeaturesTotal = 0; // Pool for request management (manage outside to be sharable between multiple opensearch layers)

    this.pool = options.openSearchRequestPool; // Cache for data management

    this.cache = new OpenSearchCache(); // Force Refresh

    this.forceRefresh = false; // Layer created on-the-fly to display quickook over openSearch layer
    // TODO: optimisation : created only once and reused ?

    this.currentQuicklookLayer = null; // Id of current feature displayed

    this.currentIdDisplayed = null;
    this.featuresAddedToNotLoadedTiles = {};
    this.heatmapMaxLevel = options.heatmapMaxLevel || 5;
    this.heatmapMinFeatureCount = options.heatmapMinFeatureCount || 100;
    this.colormap = [{
      pct: 0.0,
      color: [0.0, 0.0, 0.3]
    }, {
      pct: 0.01,
      color: [0.0, 0.0, 1.0]
    }, {
      pct: 0.05,
      color: [0.0, 1.0, 1.0]
    }, {
      pct: 0.1,
      color: [0.0, 1.0, 0.0]
    }, {
      pct: 0.25,
      color: [1.0, 1.0, 0.0]
    }, {
      pct: 0.5,
      color: [1.0, 0.0, 0.0]
    }, {
      pct: 1.0,
      color: [0.3, 0.0, 0.0]
    }];
    this.heatmapTiles = {};
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, OpenSearchLayer);
  /**************************************************************************************************************/

  OpenSearchLayer.TileState = {
    LOADING: 0,
    LOADED: 1,
    NOT_LOADED: 2
  };

  function _fixCrossLine(features) {
    var len = features.length;

    while (len--) {
      var currentFeature = features[len];

      if (currentFeature.geometry) {
        switch (currentFeature.geometry.type) {
          case Constants.GEOMETRY.Point:
            // Convert to geographic to simplify picking
            if (currentFeature.geometry.coordinates[0] > 180) {
              currentFeature.geometry.coordinates[0] -= 360;
            }

            break;

          case Constants.GEOMETRY.Polygon:
            var ring = currentFeature.geometry.coordinates[0];

            for (var j = 0; j < ring.length; j++) {
              // Convert to geographic to simplify picking
              if (ring[j][0] > 180) {
                ring[j][0] -= 360;
              }
            }

            break;
        }
      }
    }
  }

  function _getColorForPercentage(pct, colormap) {
    var colors = colormap.slice(0);
    colors.sort(function (c0, c1) {
      return c0.pct - c1.pct;
    });
    const length = colors.length; // Find the pct bounds

    var color; // Pct is outside colormap bounds

    if (colors[0].pct > pct) {
      color = colors[0].color;
    } else if (colors[length - 1].pct < pct) {
      color = colors[length - 1].color;
    } else {
      for (var i = 0; i < length - 1; ++i) {
        const p0 = colors[i].pct;
        const p1 = colors[i + 1].pct;

        if (p0 <= pct && p1 >= pct) {
          const p = (pct - p0) / (p1 - p0);
          const c0 = colors[i].color;
          const c1 = colors[i + 1].color;
          color = [(1.0 - p) * c0[0] + p * c1[0], (1.0 - p) * c0[1] + p * c1[1], (1.0 - p) * c0[2] + p * c1[2]];
        }
      }
    }

    return color;
  }
  /**
   * Internal function to sort tiles
   * @function _sortTilesByDistance
   * @param {Tile} t1 First tile
   * @param {Tile} t2 Second tile
   * @private
   */


  function _sortTilesByDistance$1(t1, t2) {
    return t1.distance - t2.distance;
  }

  function _computeGeometryExtent(geometry) {
    //TODO : To be modified according to the planet CRS.
    var result = {
      east: -180,
      west: +180,
      north: -90,
      south: +90
    };

    for (var i = 0; i < geometry.coordinates[0].length; i++) {
      var coord = geometry.coordinates[0][i];
      result.south = coord[1] < result.south ? coord[1] : result.south;
      result.north = coord[1] > result.north ? coord[1] : result.north;
      result.east = coord[0] > result.east ? coord[0] : result.east;
      result.west = coord[0] < result.west ? coord[0] : result.west;
    }

    return result;
  }

  function _removeFeature(layer, featureId, tile) {
    const featureData = layer.featuresSet[featureId];
    if (!featureData) return;
    const index = featureData.tiles.findIndex(function (element) {
      return element.key === tile.key;
    });

    if (index === -1) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchLayer.js:298", "Tile not found when removing feature");
    } else {
      const feature = layer.features[featureData.index];
      layer.getGlobe().getRendererManager().removeGeometryFromTile(feature.geometry, tile);
      featureData.tiles.splice(index, 1);
    }

    if (featureData.tiles.length === 0) {
      // No more tiles attached to this feature, remove it from the dataset
      delete layer.featuresSet[featureId]; // And from the features list

      const lastFeature = layer.features.pop();

      if (featureData.index < layer.features.length) {
        // The poped feature is not the one we are removing, swap them
        layer.features[featureData.index] = lastFeature; // And update the index

        layer.featuresSet[lastFeature.id].index = featureData.index;
      }
    }
  }

  function _removeFeatures(layer) {
    for (const id in layer.featuresSet) {
      for (var tileIndex = layer.featuresSet[id].tiles.length - 1; tileIndex >= 0; --tileIndex) {
        _removeFeature(layer, id, layer.featuresSet[id].tiles[tileIndex]);
      }
    }

    layer.featuresSet = {};

    for (var i = 0; i < layer.tilesLoaded.length; i++) {
      layer.tilesLoaded[i].tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
    }

    layer.tilesLoaded = [];
    layer.getGlobe().getRenderContext().requestFrame();
  }

  function _removeTile(layer, tile) {
    // If there is no features for this tile, there will be no associatedFeaturesId
    if (tile.associatedFeaturesId) {
      // Remove each feature associated with the tile
      for (const id in tile.associatedFeaturesId) {
        const featureId = tile.associatedFeaturesId[id];

        _removeFeature(layer, featureId, tile);
      }

      tile.associatedFeaturesId = [];
    } // Remove the tile


    const index = layer.tilesLoaded.findIndex(function (element) {
      return element.tile.key === tile.key;
    });

    if (index !== -1) {
      layer.tilesLoaded.splice(index, 1);
    }

    tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
    delete layer.heatmapTiles[tile.level][tile.key];
    layer.buildHeatmap();
  }

  function _removeFeaturesOutside(layer, tiles) {
    var maxLevel = 0;

    for (var t of tiles) {
      if (maxLevel < t.level) {
        maxLevel = t.level;
      }
    }

    for (var i = 0; i < layer.tilesLoaded.length; i++) {
      var tile = layer.tilesLoaded[i].tile;
      var remove = tile.level > maxLevel;

      if (!remove) {
        remove = !UtilsIntersection.tileIntersects(tile, tiles);
      }

      if (remove) {
        _removeTile(layer, tile);
      }
    }
  }

  function _addFeature(layer, feature, tile) {
    var featureData;
    var style = feature.properties.style ? feature.properties.style : layer.style;
    style.opacity = layer.getOpacity(); // fix geometry gid

    feature.geometry.gid = feature.id; // fix feature ID

    if (!feature.hasOwnProperty("id")) {
      feature.id = feature.properties.identifier;
    } // fix style


    if (!feature.properties.hasOwnProperty("style")) {
      feature.properties.style = style;
    }

    if (!layer.featuresSet.hasOwnProperty(feature.id)) {
      layer.features.push(feature);
      featureData = {
        index: layer.features.length - 1,
        tiles: [tile]
      };
      layer.featuresSet[feature.id] = featureData;
    } else {
      featureData = layer.featuresSet[feature.id]; // Store the tile

      featureData.tiles.push(tile); // Always use the base feature to manager geometry indices

      feature = layer.features[featureData.index];
    }

    if (!tile.associatedFeaturesId) tile.associatedFeaturesId = [];
    tile.associatedFeaturesId.push(feature.id);

    if (feature.geometry.type === "GeometryCollection") {
      var geoms = feature.geometry.geometries;

      for (var i = 0; i < geoms.length; i++) {
        layer.getGlobe().getRendererManager().addGeometryToTile(layer, geoms[i], style, tile);
      }
    } else {
      // Add geometry to renderers
      layer.getGlobe().getRendererManager().addGeometryToTile(layer, feature.geometry, style, tile);
    }

    if (tile.state !== Tile.State.LOADED) {
      if (!layer.featuresAddedToNotLoadedTiles[tile.key]) {
        layer.featuresAddedToNotLoadedTiles[tile.key] = [];
      }

      if (feature.geometry.type === "Point") {
        layer.featuresAddedToNotLoadedTiles[tile.key].length = 0;
      }

      layer.featuresAddedToNotLoadedTiles[tile.key].push(feature);
    }
  }

  function _cleanCache(layer) {
    layer.cache.reset();
    layer.previousViewKey = null;
  }

  function _prepareParameters(layer, tile) {
    var param; // param managed

    var code; // param code

    for (var i = 0; i < layer.getServices().queryForm.parameters.length; i++) {
      param = layer.getServices().queryForm.parameters[i];
      code = param.value;
      code = code.replace("?}", "}");

      if (code === "{geo:box}" && (tile.type === Constants.TILE.GEO_TILE || tile.type === Constants.TILE.MERCATOR_TILE)) {
        // set bbox
        param.currentValue = tile.geoBound.west + "," + tile.geoBound.south + "," + tile.geoBound.east + "," + tile.geoBound.north;
      } else if (code === "{geo:geometry}" && tile.type === Constants.TILE.HEALPIX_TILE) {
        var corners = tile.getCorners();
        param.currentValue = "POLYGON((" + corners[0][0] + " " + corners[0][1] + "," + corners[1][0] + " " + corners[1][1] + "," + corners[2][0] + " " + corners[2][1] + "," + corners[3][0] + " " + corners[3][1] + "," + corners[0][0] + " " + corners[0][1] + "))";
      }
    }
  }

  function _addFeatureToRenderersCurrentLevel(layer, feature) {
    var geometry = feature.geometry; // Manage style, if undefined try with properties, otherwise use defaultStyle

    var style = layer.style;
    var props = feature.properties;

    if (props && props.style) {
      style = props.style;
    } // Manage geometry collection


    if (geometry.type === "GeometryCollection") {
      var geoms = geometry.geometries;

      for (var i = 0; i < geoms.length; i++) {
        layer.getGlobe().getRendererManager().addGeometryCurrentLevel(layer, geoms[i], style);
      }
    } else {
      // Add geometry to renderers
      layer.getGlobe().getRendererManager().addGeometryCurrentLevel(layer, geometry, style);
    }
  }

  function _removeFeatureFromRenderersCurrentLevel(layer, feature) {
    return layer.getGlobe().getRendererManager().removeGeometryCurrentLevel(feature.geometry, layer);
  }

  function _buildUrl(layer, tile, count) {
    //var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;
    if (!layer.getServices().hasOwnProperty("queryForm")) {
      return null;
    }

    var url = layer.getServices().queryForm.template; // Prepare parameters for this tile

    _prepareParameters(layer, tile); // Check each parameter


    var param; // param managed

    var currentValue; // value set

    for (var i = 0; i < layer.getServices().queryForm.parameters.length; i++) {
      param = layer.getServices().queryForm.parameters[i];

      if (param.name === "maxRecords" && count) {
        currentValue = count;
      } else {
        currentValue = param.currentValueTransformed();
      }

      if (currentValue === null) {
        // Remove parameter if not mandatory (with a ?)
        url = url.replace("&" + param.name + "=" + param.value.replace("}", "?}"), "");
        url = url.replace(param.name + "=" + param.value.replace("}", "?}"), ""); // Set blank if parameter is mandatory

        url = url.replace(param.value, "");
      } else {
        // replace value
        url = url.replace(param.value, currentValue); // replace optional value

        url = url.replace(param.value.replace("}", "?}"), currentValue);
      }
    }

    return url;
  }

  function _isTileLoaded(tilesLoaded, key) {
    const index = tilesLoaded.findIndex(function (element) {
      return element.key === key;
    });
    return index !== -1;
  }

  function _removeFeaturesExternalFov(layer, tiles) {
    var doRemove = false;

    if (layer.lastRemovingDateTime === null) {
      doRemove = true;
    } else {
      doRemove = Date.now() - layer.lastRemovingDateTime >= layer.removingDeltaSeconds * 1000;
    }

    if (doRemove) {
      layer.lastRemovingDateTime = Date.now();

      _removeFeaturesOutside(layer, tiles);
    }
  }

  function _initOsState(layer, tile) {
    if (typeof tile.key === "undefined") {
      tile.key = tile.getKey();
    } // If no state defined...


    if (tile.osState == null) {
      //...set it to NOT_LOADED
      tile.osState = {};
    }

    if (tile.osState[layer.getID()] == null) {
      tile.osState[layer.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
    }
  }

  function _computeStats(layer) {
    var nb = 0;

    for (var i = 0; i < layer.tilesLoaded.length; i++) {
      var tileLoaded = layer.tilesLoaded[i].tile;

      if (tileLoaded.associatedFeaturesId) {
        nb = nb + tileLoaded.associatedFeaturesId.length;
      }
    }
  }

  function _requestTile(layer, tile, count) {
    var url = _buildUrl(layer, tile, count);

    if (url !== null) {
      var cachedTile = layer.cache.getCacheFromKey(url);

      if (cachedTile == null) {
        // cache
        tile.osState[layer.getID()] = OpenSearchLayer.TileState.LOADING;
        layer.pool.addQuery(url, tile, layer);
      } else {
        // If no state defined...
        if (cachedTile.osState == null) {
          //...set it to NOT_LOADED
          cachedTile.osState = {};
        }

        cachedTile.osState[layer.getID()] = OpenSearchLayer.TileState.LOADING;
        layer.computeFeaturesResponse(cachedTile.features, cachedTile, cachedTile.total);
      }

      _computeStats(layer);
    }
  }

  function _setTileLoaded(tile, id) {
    // Only if tile was LOADING...
    if (tile.osState[id] === OpenSearchLayer.TileState.LOADING) {
      // ...set to LOADED
      tile.osState[id] = OpenSearchLayer.TileState.LOADED;
    }
  }
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof OpenSearchLayer#
   */


  OpenSearchLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.VECTOR;
  };
  /**
   * @function setTime
   * @memberof OpenSearchLayer#
   * @param {Time.configuration} time Time configuration
   */


  OpenSearchLayer.prototype.setTime = function (time) {
    this.setParameter.call(this, "mizar:time", time);
  };
  /**
   * @function setParameter
   * @memberof OpenSearchLayer#
   * @param {string} paramName Name of parameter
   * @param {Time.configuration} value Time configuration
   */


  OpenSearchLayer.prototype.setParameter = function (paramName, value) {
    if (paramName === "mizar:time") {
      this.time = value;
      value.period.from = Moment__default['default'](value.period.from).format("YYYY-MM-DD HH:mm");
      value.period.to = Moment__default['default'](value.period.to).format("YYYY-MM-DD HH:mm");
      OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm, "time:start", value.period.from);
      OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm, "time:end", value.period.to);
    } else {
      OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm, paramName, value);
    }

    this.resetAll();
  };
  /**
   * Go to next page
   * @function nextPage
   * @memberof OpenSearchLayer#
   * @fires OpenSearchLayer#updateStatsAttribute
   */


  OpenSearchLayer.prototype.nextPage = function () {
    var num = OpenSearchUtils.getCurrentValue(this.getServices().queryForm, "startPage"); // If not specified, set default to 1

    if (num === null || typeof num === "undefined") {
      num = 1;
    } else {
      num = parseInt(num);
    }

    OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm, "startPage", num + 1); // update labels

    this.callbackContext.publish(Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES, {
      shortName: this.getShortName(),
      page: num + 1
    });
    this.forceRefresh = true;

    for (var i = 0; i < this.tilesLoaded.length; i++) {
      this.tilesLoaded[i].tile.osState[this.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
    }

    this.getGlobe().getRenderContext().requestFrame();
  };
  /**************************************************************************************************************/

  /**
   * Attaches the layer to the globe
   * @function _attach
   * @memberof OpenSearchLayer#
   * @param g The globe
   * @private
   */


  OpenSearchLayer.prototype._attach = function (g) {
    AbstractLayer.prototype._attach.call(this, g);

    g.getTileManager().addPostRenderer(this);
  };
  /**************************************************************************************************************/

  /**
   * Detach the layer from the globe
   * @function _detach
   * @memberof OpenSearchLayer#
   * @private
   */


  OpenSearchLayer.prototype._detach = function () {
    this.getGlobe().getTileManager().removePostRenderer(this);

    AbstractLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/


  OpenSearchLayer.prototype.modifyFeatureStyle = function (feature, style, useFeatureStyle) {
    if (useFeatureStyle && feature.properties.style) {
      for (var key in feature.properties.style) {
        if (!feature.properties.style.hasOwnProperty(key)) continue;
        style[key] = feature.properties.style[key];
      }
    }

    const rm = this.getGlobe().getRendererManager();

    if (this.featuresSet[feature.id]) {
      for (var tile of this.featuresSet[feature.id].tiles) {
        try {
          rm.removeGeometryFromTile(feature.geometry, tile);
          rm.addGeometryToTile(this, feature.geometry, style, tile);
        } catch (error) {
          /* e */
        }
      }
    }
  };
  /**
   * Load quicklook
   * @function loadQuicklook
   * @memberof OpenSearchLayer#
   * @param {Feature} feature Feature
   * @param {string} url Url of image
   */


  OpenSearchLayer.prototype.loadQuicklook = function (feature, url) {
    // Save coordinates
    this.currentIdDisplayed = feature.id; // Get quad coordinates

    var coordinates = feature.geometry.coordinates[0];
    var quad = [];

    for (var i = 0; i < 4; i++) {
      quad[i] = coordinates[i];
    }

    if (this.currentQuicklookLayer === null) {
      // Creation first time
      this.currentQuicklookLayer = new GroundOverlayLayer({
        quad: quad,
        image: url
      });

      this.currentQuicklookLayer._attach(this.globe);
    } else {
      this.currentQuicklookLayer.update(quad, url);
    } //TODO : Does not work because it is not added to the renderer but postRenderer
    //TODO : Test : load OSM + S1. Click on S1, load quicklook


    this.currentQuicklookLayer.setOnTheTop();
    this.getGlobe().refresh();
  };
  /**************************************************************************************************************/

  /**
   * Indicate if quicklook is currently displayed
   * @function isQuicklookDisplayed
   * @memberof OpenSearchLayer#
   * @return {Boolean} Is quicklook currently displayed ?
   */


  OpenSearchLayer.prototype.isQuicklookDisplayed = function () {
    // Trivial case
    return this.currentQuicklookLayer !== null;
  };
  /**************************************************************************************************************/

  /**removeGeometry
   * Remove quicklook
   * @function removeQuicklook
   * @memberof OpenSearchLayer#
   */


  OpenSearchLayer.prototype.removeQuicklook = function () {
    if (this.currentQuicklookLayer === null) {
      return;
    }

    this.currentQuicklookLayer._detach();

    this.currentQuicklookLayer = null;
  };
  /**************************************************************************************************************/

  /**
   * Highlight feature
   * @function highlight
   * @memberof OpenSearchLayer#
   * @param {Feature} feature Feature
   * @param {FeatureStyle} style Style
   */


  OpenSearchLayer.prototype.highlight = function (feature, style) {
    feature.properties.style = style;

    _addFeatureToRenderersCurrentLevel(this, feature);
  };
  /**
   * Unhighlight feature
   * @function unhighlight
   * @memberof OpenSearchLayer#
   * @param {Feature} feature Feature
   * @param {FeatureStyle} style Style
   */


  OpenSearchLayer.prototype.unhighlight = function (feature, style) {
    _removeFeatureFromRenderersCurrentLevel(this, feature);
  };
  /**
   * Render function
   * @function render
   * @memberof OpenSearchLayer#
   * @param {Tile[]} tiles The array of tiles to render
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#features:added
   */


  OpenSearchLayer.prototype.render = function (tiles) {
    if (!this.isVisible() || tiles.length === 0) {
      return;
    } // Check if we have features that might be missing


    if (Object.keys(this.featuresAddedToNotLoadedTiles).length > 0) {
      for (var tile of tiles) {
        if (tile.state === Tile.State.LOADED && this.featuresAddedToNotLoadedTiles[tile.key]) {
          for (var feature of this.featuresAddedToNotLoadedTiles[tile.key]) {
            _addFeature(this, feature, tile);
          }

          delete this.featuresAddedToNotLoadedTiles[tile.key];
        }
      }
    }

    this.currentKey = OpenSearchUtils.getArrayBoundKey(tiles); // if (_mustBeRefreshed(this.previousKey, this.currentKey, this.forceRefresh)) {

    if (this.forceRefresh === true) {
      // Remove cache, in order to reload new features
      _cleanCache(this);

      this.forceRefresh = false;
    }

    var localTiles = tiles.slice(0); // Sort tiles in order to load the first tiles closed to the camera

    localTiles.sort(_sortTilesByDistance$1);
    this.currentLevel = localTiles[0].level;
    this.ctx = this.callbackContext;
    this.isZoomLevelChanged = this.currentLevel !== this.previousLevel;

    if (this.isZoomLevelChanged) {
      // Go to page 1
      OpenSearchUtils.setCurrentValueToParam(this.getServices().queryForm, "startPage", 1); // update labels

      this.callbackContext.publish(Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES, {
        shortName: this.getShortName(),
        page: 1
      });

      if (this.previousLevel !== undefined && this.previousLevel !== null) {
        if (this.heatmapTiles && this.heatmapTiles[this.previousLevel]) {
          const oldKeys = Object.keys(this.heatmapTiles[this.previousLevel]);

          for (var i = oldKeys.length - 1; i >= 0; --i) {
            const key = oldKeys[i];
            const heatmapData = this.heatmapTiles[this.previousLevel][key];
            if (heatmapData.feature) _removeFeature(this, heatmapData.feature.id, heatmapData.tile);
            heatmapData.tile.osState[this.getID()] = OpenSearchLayer.TileState.NOT_LOADED;
            delete this.heatmapTiles[this.previousLevel][key];
          }
        }
      }
    }

    this.nbFeaturesTotal = 0; // =========================================================================
    // Check each tile
    // =========================================================================

    this.previousLevel = this.currentLevel;
    this.previousKey = this.currentKey;

    for (var j = 0; j < localTiles.length; j++) {
      var currentTile = localTiles[j];

      _initOsState(this, currentTile);

      switch (currentTile.osState[this.getID()]) {
        case OpenSearchLayer.TileState.NOT_LOADED:
          // First load the least possible amount of data
          _requestTile(this, currentTile, 1);

          break;

        case OpenSearchLayer.TileState.LOADED:
          //console.log("tile still loaded !!!");
          break;

        case OpenSearchLayer.TileState.LOADING:
          //console.log("tile loading...");
          break;
      }
    } // Remove all feature outside view of tiles


    _removeFeaturesExternalFov(this, localTiles); // }

  };
  /**************************************************************************************************************/

  /**
   * setRequestProperties OpenSearch form from a submit
   * @function setRequestProperties
   * @memberof OpenSearchLayer#
   * @param {Object} properties query parameters from query form
   */


  OpenSearchLayer.prototype.setRequestProperties = function (properties) {
    this.getServices().queryForm.setParametersValueFrom(properties);
    this.getServices().queryForm.updateFromGUI();
    this.resetAll();
    this.forceRefresh = true;
  };
  /**************************************************************************************************************/

  /**
   * @function setVisible
   * @memberof OpenSearchLayer#
   * @throws {TypeError} - The parameter of setVisible should be a boolean
   */


  OpenSearchLayer.prototype.setVisible = function (arg) {
    if (typeof arg === "boolean") {
      // Change for current layer
      if (this.visible !== arg && this.getGlobe().attributionHandler) {
        this.getGlobe().attributionHandler.toggleAttribution(this);
      }

      this.visible = arg;
      var linkedLayers = this.callbackContext.getLinkedLayers(this.ID); // Change for wms linked layers

      for (var i = 0; i < linkedLayers.length; i++) {
        linkedLayers[i].setVisible(arg);
      }

      if (typeof this.currentQuicklookLayer !== "undefined" && this.currentQuicklookLayer !== null) {
        //this.currentQuicklookLayer.setVisible(this.visible);
        if (this.visible === false) {
          this.removeQuicklook();
        }
      }

      if (this.getGlobe()) {
        this.getGlobe().getRenderContext().requestFrame();
      }

      this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
    } else {
      throw new TypeError("AbstractLayer.js: the parameter of setVisible should be a boolean");
    }
  };
  /**************************************************************************************************************/

  /**
   * @function setOpacity
   * @memberof OpenSearchLayer#
   * @throws {RangeError} opacity - opacity value should be a value in [0..1]
   */


  OpenSearchLayer.prototype.setOpacity = function (arg) {
    if (typeof arg === "number" && arg >= 0.0 && arg <= 1.0) {
      var targetStyle = new FeatureStyle(this.getStyle());
      targetStyle.setOpacity(arg);

      for (var i = 0; i < this.features.length; i++) {
        this.modifyFeatureStyle(this.features[i], targetStyle, true);
      }

      var linkedLayers = this.callbackContext.getLinkedLayers(this.getID()); // Change for wms linked layers

      for (i = 0; i < linkedLayers.length; i++) {
        linkedLayers[i].getStyle().setOpacity(arg);
      }

      AbstractLayer.prototype.setOpacity.call(this, arg);
    } else {
      throw new RangeError("AbstractLayer.js: opacity value should be a value in [0..1]");
    }
  };
  /**************************************************************************************************************/

  /**
   * Reset pool, cache and all OpenSearch data loaded
   * @function resetAll
   * @memberof OpenSearchLayer#
   */


  OpenSearchLayer.prototype.resetAll = function () {
    // Reset pool
    this.pool.resetPool(); // Reset cache

    _cleanCache(this); // Remove all features


    _removeFeatures(this);
  };
  /**
   * Load WMS layer
   * @function loadWMS
   * @memberof OpenSearchLayer#
   * @param {Json} selectedData Selected data
   * @fires OpenSearchLayer#toggleWMS
   * @fires Context#backgroundLayer:added
   * @fires Context#layer:added
   */


  OpenSearchLayer.prototype.loadWMS = function (selectedData) {
    var extent = _computeGeometryExtent(selectedData.feature.geometry);

    var endpoint = selectedData.feature.properties.services.browse.layer.url;
    var name = selectedData.layer.name + " (WMS)";
    var layerDescription = {
      type: "WMS",
      name: name,
      baseUrl: endpoint,
      onlyFirst: true,
      format: "image/png",
      visible: true,
      restrictTo: extent,
      background: false,
      linkedTo: selectedData.layer.ID
    };
    var self = this;
    selectedData.layer.callbackContext.addLayer(layerDescription, function (layerID) {
      // Add feature id of wms into list a current WMS displayed
      self.addServicesRunningOnRecord(selectedData.feature.id, layerID);
      var layer = self.callbackContext.getLayerByID(layerID);
      layer.setOnTheTop();

      if (typeof self.callbackContext !== "undefined") {
        self.callbackContext.publish(Constants.EVENT_MSG.LAYER_TOGGLE_WMS, {
          layer_name: selectedData.layer.getShortName(),
          visible: true
        });
      }
    });
  };
  /**************************************************************************************************************/

  /**
   * Unload all WMS layer
   * @function unloadAllWMS
   * @memberof OpenSearchLayer#
   * @fires OpenSearchLayer#toggleWMS
   */


  OpenSearchLayer.prototype.unloadAllWMS = function (selectedData) {
    this.removeServicesRunningOnRecords();
    this.removeServicesRunningOnCollection();
    this.callbackContext.refresh();

    if (typeof selectedData !== "undefined") {
      this.callbackContext.publish(Constants.EVENT_MSG.LAYER_TOGGLE_WMS, {
        layer_name: selectedData.layer.getShortName(),
        visible: false
      });
    }
  };
  /**************************************************************************************************************/

  /**
   * Unload WMS layer
   * @function unloadWMS
   * @memberof OpenSearchLayer#
   * @param {Json} selectedData Selected data
   * @fires OpenSearchLayer#toggleWMS
   */


  OpenSearchLayer.prototype.unloadWMS = function (selectedData) {
    // Remove feature id
    this.removeServicesRunningOnRecord(selectedData.feature.id);
    selectedData.layer.callbackContext.refresh();

    if (typeof this.callbackContext !== "undefined") {
      this.callbackContext.publish(Constants.EVENT_MSG.LAYER_TOGGLE_WMS, {
        layer_name: selectedData.layer.getShortName(),
        visible: false
      });
    }
  };
  /**************************************************************************************************************/

  /**
   * Compute a response to OpenSearch query
   * @function computeFeaturesResponse
   * @memberof OpenSearchLayer#
   * @param {Array} features Array of features loaded
   * @param {Tile} tile Tile
   * @param {int} nbFeaturesTotalPerTile Total number of features found over all pages for a given tile
   * @fires OpenSearchLayer#updateStatsAttribute
   */


  OpenSearchLayer.prototype.computeFeaturesResponse = function (features, tile, nbFeaturesTotalPerTile) {
    var ableToContinue = true;
    const {
      level,
      key
    } = tile;

    if (!this.heatmapTiles[level]) {
      this.heatmapTiles[level] = {};
    }

    this.heatmapTiles[level][key] = {
      tile: tile,
      nbFeatures: nbFeaturesTotalPerTile
    };

    if (nbFeaturesTotalPerTile > this.heatmapMinFeatureCount && level <= this.heatmapMaxLevel) {
      ableToContinue = false;
      this.heatmapTiles[level][key].shouldBeDrawn = true;
    } else if (features.length === 1) {
      ableToContinue = false; // Set 10 times more than the parsed value because the features total
      // number is approximative
      // TODO Iterate on each page until there is no feature to parse

      _requestTile(this, tile, this.heatmapMinFeatureCount);
    }

    this.buildHeatmap();

    if (!ableToContinue) {
      return;
    }

    _fixCrossLine(features); // compute the total number of available features on the server in the FOV


    this.nbFeaturesTotal += nbFeaturesTotalPerTile; // For each feature...

    for (var feature of features) {
      try {
        _addFeature(this, feature, tile);
      } catch (error) {
        /* error */
      } // Add features to renderer if this is attached to planet

    }

    if (typeof this.callbackContext !== "undefined") {
      this.callbackContext.publish(Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES, {
        shortName: this.getShortName(),
        nb_loaded: this.features.length,
        nb_total: this.nbFeaturesTotal
      });
    }

    _setTileLoaded(tile, this.getID());

    this.getGlobe().refresh();

    if (!_isTileLoaded(this.tilesLoaded, tile.key)) {
      this.tilesLoaded.push({
        key: key,
        tile: tile
      });
    } // Publish event that layer have received new features


    this.getGlobe().publishEvent(Constants.EVENT_MSG.FEATURED_ADDED, {
      layer: this,
      features: this.features
    });
  };
  /**************************************************************************************************************/

  /**
   * Build a heatmap showing the amount of OS data per tile currently displayed on screen
   * @function buildHeatmap
   * @memberof OpenSearchLayer#
   */


  OpenSearchLayer.prototype.buildHeatmap = function () {
    var total = 0;
    const heatmapData = this.heatmapTiles[this.currentLevel];

    for (const key in heatmapData) {
      total += heatmapData[key].nbFeatures;
    }

    for (const key in heatmapData) {
      const entry = heatmapData[key];

      if (entry.shouldBeDrawn) {
        const pct = entry.nbFeatures / total;
        const {
          tile
        } = entry;
        const center = [(tile.geoBound.east + tile.geoBound.west) / 2.0, (tile.geoBound.north + tile.geoBound.south) / 2.0];

        const color = _getColorForPercentage(pct, this.colormap);

        const textFeature = {
          type: "Feature",
          id: `${this.ID}_${key}_text`,
          geometry: {
            type: "Point",
            coordinates: center,
            crs: {
              type: "name",
              properties: {
                name: tile.config.srs
              }
            }
          },
          properties: {
            "Feature count": `${entry.nbFeatures}`,
            Percentage: `${(pct * 100).toFixed(2).toString()}%`,
            style: {
              label: `${(pct * 100).toFixed(2).toString()}%`,
              fillColor: color,
              strokeColor: color,
              textColor: color,
              opacity: 1,
              pointMaxSize: 500,
              extrusionScale: 1,
              fill: false,
              fillShader: null,
              fillTexture: null,
              fillTextureUrl: null,
              icon: null,
              iconUrl: null,
              onTerrain: true,
              strokeWidth: 1,
              zIndex: 0
            }
          }
        };

        if (entry.feature) {
          if (entry.feature.pickData && entry.feature.pickData.picked) {
            entry.feature.pickData.pickSelection[entry.feature.pickData.index].feature = textFeature;
            textFeature.pickData = entry.feature.pickData;
          }

          _removeFeature(this, entry.feature.id, tile);
        }

        entry.feature = textFeature;

        _addFeature(this, textFeature, tile);

        if (this.tilesLoaded.findIndex(function (element) {
          return element.key === tile.key;
        }) === -1) {
          this.tilesLoaded.push({
            key: tile.key,
            tile: tile
          });
        }

        _setTileLoaded(tile, this.getID());
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const DEFAULT_SIZE_MULTIPLICATOR = 1;
  var ctx;
  var globe;
  var pickableLayers = [];
  var selection = [];
  var stackSelectionIndex = -1;
  var selectedStyle = new FeatureStyle({
    strokeColor: [1.0, 0.0, 0.0, 1.0],
    fillColor: [1.0, 1.0, 0.0, 1.0],
    zIndex: Constants.DISPLAY.SELECTED_VECTOR
  });
  var highlightedSelectedStyle = new FeatureStyle({
    strokeColor: [0.0, 0.0, 1.0, 1.0],
    fillColor: [0.0, 0.0, 1.0, 1.0],
    zIndex: Constants.DISPLAY.HIGHLIGHTED_VECTOR
  });
  /**************************************************************************************************************/

  /**
   *    Add pickable layer to the pickableLayers list
   *    @function addPickableLayer
   *    @param {AbstractLayer} layer
   */

  function addPickableLayer(layer) {
    if (pickableLayers.indexOf(layer) === -1) {
      pickableLayers.push(layer);
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", layer.name + " has been already added");
    }
  }
  /**************************************************************************************************************/

  /**
   *    Remove pickable layers
   *    @param {AbstractLayer} layer
   */


  function removePickableLayer(layer) {
    for (var i = 0; i < pickableLayers.length; i++) {
      if (layer.id === pickableLayers[i].id) {
        pickableLayers.splice(i, 1);
      }
    }
  }
  /**************************************************************************************************************/

  /**
   * Get the list of pickable layers
   * @returns {Array} pickableLayers
   */


  function getPickableLayers() {
    return pickableLayers;
  }
  /**************************************************************************************************************/

  /**
   *    Revert style of selected feature
   */


  function blurSelectedFeature() {
    var selectedData = getSelection()[stackSelectionIndex];

    if (selectedData) {
      var style = new FeatureStyle(selectedData.feature.properties.style);

      switch (selectedData.feature.geometry.type) {
        case Constants.GEOMETRY.LineString:
        case Constants.GEOMETRY.MultiLineString:
        case Constants.GEOMETRY.Polygon:
        case Constants.GEOMETRY.MultiPolygon:
          style.strokeColor = selectedStyle.strokeColor;
          break;

        case Constants.GEOMETRY.Point:
          // Use stroke color while reverting
          style.fillColor = selectedStyle.fillColor;
          break;
      }

      style.zIndex = selectedStyle.zIndex;
      selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
    }
  }
  /**************************************************************************************************************/

  /**
   *    Apply selected style to the feature by the given index in selection array
   *
   *    @param index Index of feature in selection array
   *    @param options
   *        <li>isExclusive : Boolean indicating if the focus is exclusive</li>
   *        <li>color : Highlight color</li>
   */


  function focusFeatureByIndex(index, options) {
    if (options.isExclusive) {
      blurSelection();
    } // Update highlight color


    var strokeColor = options.color ? FeatureStyle.fromStringToColor(options.color) : highlightedSelectedStyle.strokeColor;
    var fillColor = options.color ? FeatureStyle.fromStringToColor(options.color) : highlightedSelectedStyle.fillColor;
    var selectedData = getSelection()[index];

    if (selectedData) {
      stackSelectionIndex = index;
      var style = new FeatureStyle(selectedData.feature.properties.style);

      switch (selectedData.feature.geometry.type) {
        case Constants.GEOMETRY.LineString:
        case Constants.GEOMETRY.MultiLineString:
        case Constants.GEOMETRY.Polygon:
        case Constants.GEOMETRY.MultiPolygon:
          style.strokeColor = strokeColor;
          style.strokeWidth = style.strokeWidth + 2;
          break;

        case Constants.GEOMETRY.Point:
          style.fillColor = fillColor;
          break;
      }

      style.zIndex = highlightedSelectedStyle.zIndex;
      selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
    }

    globe.refresh();
  }
  /**************************************************************************************************************/

  /**
   * Get the current selection
   * @returns {Array}
   */


  function getSelection() {
    return selection;
  }
  /**************************************************************************************************************/

  /**
   *    Revert style of selection
   */


  function blurSelection() {
    for (var i = 0; i < getSelection().length; i++) {
      var selectedData = getSelection()[i];
      var style = new FeatureStyle(selectedData.feature.properties.style);

      switch (selectedData.feature.geometry.type) {
        case Constants.GEOMETRY.LineString:
        case Constants.GEOMETRY.MultiLineString:
        case Constants.GEOMETRY.Polygon:
        case Constants.GEOMETRY.MultiPolygon:
          style.strokeColor = selectedData.layer.getStyle().strokeColor;
          style.strokeWidth = selectedData.layer.getStyle().strokeWidth;
          break;

        case Constants.GEOMETRY.Point:
          // Use stroke color while reverting
          style.fillColor = selectedData.feature.properties.style.strokeColor;
          break;
      }

      style.zIndex = selectedData.layer.getStyle().zIndex;

      if (selectedData.layer.getGlobe()) {
        // Layer is still attached to globe
        selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
      }

      if (selectedData.feature.pickData) {
        delete selectedData.feature.pickData;
      }
    }
  }
  /**************************************************************************************************************/

  /**
   *    Apply style to selection
   *    @param {Array} newSelection selection of data
   */


  function focusSelection(newSelection) {
    var style; //var focusLayers = {};

    for (var i = 0; i < newSelection.length; i++) {
      var selectedData = newSelection[i];

      if (selectedData.feature.properties.style) {
        style = new FeatureStyle(selectedData.feature.properties.style);
      } else {
        style = new FeatureStyle(selectedData.layer.getStyle());
      }

      switch (selectedData.feature.geometry.type) {
        case Constants.GEOMETRY.LineString:
        case Constants.GEOMETRY.MultiLineString:
        case Constants.GEOMETRY.Polygon:
        case Constants.GEOMETRY.MultiPolygon:
          style.strokeColor = selectedStyle.strokeColor;
          style.strokeWidth = style.strokeWidth + 1;
          break;

        case Constants.GEOMETRY.Point:
          style.fillColor = selectedStyle.fillColor;
          break;
      }

      style.zIndex = selectedStyle.zIndex;
      selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
    }
    /*            for (var layerID in focusLayers) {
              currentLayer = focusLayers[layerID];
              currentLayer.layer.modifyFeatureStyles(
                  currentLayer.focusFeatures,
                  currentLayer.focusStyles
              );
          }
      */

  }
  /**************************************************************************************************************/

  /**
   *    Clear selection
   */


  function clearSelection() {
    blurSelection();
    setSelection([]);
  }
  /**************************************************************************************************************/

  /**
   * Check if a geometry crosses the date line
   * @param {Array} pickPoint
   * @param {Array}coords
   * @returns {Array} coords
   */


  function fixDateLine(pickPoint, coords) {
    var crossDateLine = false;
    var startLon = coords[0][0];

    for (var i = 1; i < coords.length && !crossDateLine; i++) {
      var deltaLon = Math.abs(coords[i][0] - startLon);

      if (deltaLon > 180) {
        // DateLine!
        crossDateLine = true;
      }
    }

    var n;

    if (crossDateLine) {
      var fixCoords = [];

      if (pickPoint[0] < 0.0) {
        // Ensure coordinates are always negative
        for (n = 0; n < coords.length; n++) {
          if (coords[n][0] > 0) {
            fixCoords[n] = [coords[n][0] - 360, coords[n][1]];
          } else {
            fixCoords[n] = [coords[n][0], coords[n][1]];
          }
        }
      } else {
        // Ensure coordinates are always positive
        for (n = 0; n < coords.length; n++) {
          if (coords[n][0] < 0) {
            fixCoords[n] = [coords[n][0] + 360, coords[n][1]];
          } else {
            fixCoords[n] = [coords[n][0], coords[n][1]];
          }
        }
      }

      return fixCoords;
    } else {
      return coords;
    }
  }
  /**************************************************************************************************************/

  /**
   * Picking test for feature depending on its geometry type
   * @param {Object} feature
   * @param {Array} pickPoint
   * @returns {Boolean} isPicked
   */


  function featureIsPicked(feature, pickPoint, pickingNoDEM, options) {
    var i, j, p;
    var feat, featNext, ring;
    var sizeMultiplicator = options && options.sizeMultiplicator ? options.sizeMultiplicator : DEFAULT_SIZE_MULTIPLICATOR;

    switch (feature.geometry.type) {
      case Constants.GEOMETRY.LineString:
        if (!pickPoint) {
          return false;
        }

        for (i = 0; i < feature.geometry.coordinates.length - 1; i++) {
          feat = feature.geometry.coordinates[i];
          featNext = feature.geometry.coordinates[i + 1];

          if (UtilsIntersection.pointInLine(pickPoint, feat, featNext)) {
            return true;
          }
        } //var ring = fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);


        break;

      case Constants.GEOMETRY.MultiLineString:
        if (!pickPoint) {
          return false;
        }

        for (i = 0; i < feature.geometry.coordinates.length; i++) {
          for (j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
            feat = feature.geometry.coordinates[i][j];
            featNext = feature.geometry.coordinates[i][j + 1];

            if (UtilsIntersection.pointInLine(pickPoint, feat, featNext)) {
              return true;
            }
          }
        }

        break;

      case Constants.GEOMETRY.Polygon:
        if (!pickPoint) {
          return false;
        }

        ring = fixDateLine(pickPoint, feature.geometry.coordinates[0]);
        return UtilsIntersection.pointInRing(pickPoint, ring);

      case Constants.GEOMETRY.MultiPolygon:
        if (!pickPoint) {
          return false;
        }

        for (p = 0; p < feature.geometry.coordinates.length; p++) {
          ring = fixDateLine(pickPoint, feature.geometry.coordinates[p][0]);

          if (UtilsIntersection.pointInRing(pickPoint, ring)) {
            return true;
          }
        }

        return false;

      case Constants.GEOMETRY.Point:
        // Do not pick the labeled features
        var isLabel = !options.allowLabelPicking && feature.properties && feature.properties.style && feature.properties.style.label;
        if (isLabel) return false;

        if (feature.properties && feature.properties.style && feature.properties.style.useMeterSize && feature.properties.style.meterSize) {
          return UtilsIntersection.isInBillboard(pickPoint, feature.geometry, feature.properties.style.meterSize, options.eventPos);
        } else if (feature.properties && feature.properties.style && feature.properties.style.useDegreeSize && feature.properties.style.degreeSize) {
          return UtilsIntersection.isInBillboard(pickPoint, feature.geometry, feature.properties.style.degreeSize, options.eventPos);
        } else {
          if (!pickPoint) {
            return false;
          }

          var coord = feature.geometry.coordinates;
          var point;
          var pt = [pickPoint[0], pickPoint[1], pickPoint[2]];

          if (pickingNoDEM === true) {
            pt[2] = 0;
            point = [coord[0], coord[1], 0];
            sizeMultiplicator = 3;
          } else {
            point = coord;
          }

          return UtilsIntersection.pointInSphere(ctx, pt, point, feature.geometry._bucket.textureHeight * sizeMultiplicator);
        }

      default:
        ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "Picking for " + feature.geometry.type + " is not yet");
        return false;
    }
  }
  /**************************************************************************************************************/

  /**
   * @deprecated Please use computePickSelection
   */


  function computeFilterPickSelection(pickPoint, options) {
    ErrorDialog.open(Constants.LEVEL.WARNING, "PickingManagerCore", "computeFilterPickSelection: This function is deprecated. Please use computePickSelection instead.");
    var selection = computePickSelection(pickPoint, options);
    var returnedSelection = [];

    for (var i = 0; i < selection.length; i++) {
      returnedSelection.push(selection[i]);
    }

    return returnedSelection;
  }
  /**
   * Compute the selection at the picking point
   * @param {Array} pickPoint
   * @return {Array} newSelection
   */


  function computePickSelection(pickPoint, options) {
    var i, j, feature;
    var newSelection = [];
    var selectedTile = pickPoint ? globe.tileManager.getVisibleTile(pickPoint[0], pickPoint[1]) : undefined;
    const tileData = selectedTile ? selectedTile.extension.renderer : null;

    for (i = 0; i < getPickableLayers().length; i++) {
      var pickableLayer = getPickableLayers()[i];

      if (pickableLayer.isVisible() && pickableLayer.globe === globe) {
        if (pickableLayer instanceof OpenSearchLayer) {
          if (!pickPoint) {
            return [];
          } // Extension using layer
          // Search for features in each tile


          if (!selectedTile) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "no tile found");
            continue;
          }

          if (!tileData) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "PickingManagerCore.js", "no tile data");
            continue;
          } //[pickableLayer.extId];

          /*if (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED) {
                          while (tile.parent && (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED)) {
                              tile = tile.parent;
                              tileData = tile.extension[pickableLayer.extId];
                          }
                      }*/
          //for (j = 0; j < tileData.featureIds.length; j++) {


          for (j = 0; j < pickableLayer.features.length; j++) {
            //feature = pickableLayer.features[pickableLayer.featuresSet[tileData.featureIds[j]].index];
            feature = pickableLayer.features[j]; // Allow label picking for opensearch texts

            var localOptions = JSON.parse(JSON.stringify(options));

            if (feature && feature.properties && feature.properties.style && feature.properties.style.label) {
              localOptions.allowLabelPicking = true;

              if (!localOptions.sizeMultiplicator) {
                localOptions.sizeMultiplicator = 3;
              }
            }

            if (featureIsPicked(feature, pickPoint, pickableLayer.pickingNoDEM, localOptions)) {
              feature.pickData = {
                picked: true,
                index: newSelection.length,
                pickSelection: newSelection
              };
              newSelection.push({
                feature: feature,
                layer: pickableLayer
              });
            }
          }
        } else {
          // Vector layer
          // Search for picked features
          for (j = 0; j < pickableLayer.features.length; j++) {
            feature = pickableLayer.features[j];

            if (featureIsPicked(feature, pickPoint, pickableLayer.pickingNoDEM, options)) {
              newSelection.push({
                feature: feature,
                layer: pickableLayer
              });
            }
          }
        }
      }
    } // Add selected tile to selection to be able to make the requests by tile
    // (actually used for asteroids search)


    newSelection.selectedTile = selectedTile;
    return newSelection;
  }
  /**************************************************************************************************************/

  /**
   * Set selection list with passed selection
   * @param {Array} sel selection
   */


  function setSelection(sel) {
    selection = sel;
    return selection;
  }
  /**************************************************************************************************************/

  /**
   *    Highlight the given feature
   *
   *    @param featureData
   *        Feature data is an object composed by feature and its layer
   *    @param options
   *        Focus feature options(isExclusive and color)
   *
   *    // TODO : maybe it's more intelligent to store layer reference on feature ?
   */


  function highlightObservation(featureData, options) {
    selection.push(featureData);
    focusFeatureByIndex(selection - 1, options);
  }

  function updateContext$1(context) {
    ctx = context;
    globe = context.globe;
  }
  /**************************************************************************************************************/


  var PickingManagerCore = {
    selectedStyle: selectedStyle,
    highlightedSelectedStyle: highlightedSelectedStyle,
    stackSelectionIndex: stackSelectionIndex,
    init: function (context) {
      ctx = context;
      globe = context.globe;
    },
    addPickableLayer: addPickableLayer,
    removePickableLayer: removePickableLayer,
    getPickableLayers: getPickableLayers,
    blurSelectedFeature: blurSelectedFeature,
    focusFeatureByIndex: focusFeatureByIndex,
    getSelection: getSelection,
    blurSelection: blurSelection,
    focusSelection: focusSelection,
    clearSelection: clearSelection,
    fixDateLine: fixDateLine,
    featureIsPicked: featureIsPicked,
    computePickSelection: computePickSelection,
    computeFilterPickSelection: computeFilterPickSelection,
    setSelection: setSelection,
    highlightObservation: highlightObservation,
    updateContext: updateContext$1
  };

  // samp
  // ----
  // Provides capabilities for using the SAMP Web Profile from JavaScript.
  // Exported tokens are in the samp.* namespace.
  // Inline documentation is somewhat patchy (partly because I don't know
  // what javascript documentation is supposed to look like) - it is
  // suggested to use it conjunction with the provided examples,
  // currently visible at http://astrojs.github.com/sampjs/
  // (gh-pages branch of github sources).
  var samp$1 = function () {
    // Constants defining well-known location of SAMP Web Profile hub etc.
    var WEBSAMP_PORT = 21012;
    var WEBSAMP_PATH = "/";
    var WEBSAMP_PREFIX = "samp.webhub.";
    var WEBSAMP_CLIENT_PREFIX = ""; // Tokens representing permissible types in a SAMP object (e.g. a message)

    let TYPE_STRING = "string";
    let TYPE_LIST = "list";
    let TYPE_MAP = "map";

    var heir = function (proto) {
      function F() {}

      F.prototype = proto;
      return new F();
    }; // Utility functions for navigating DOM etc.
    // -----------------------------------------


    var getSampType = function (obj) {
      if (typeof obj === "string") {
        return TYPE_STRING;
      } else if (obj instanceof Array) {
        return TYPE_LIST;
      } else if (obj instanceof Object && obj !== null) {
        return TYPE_MAP;
      } else {
        throw new Error("Not legal SAMP object type: " + obj);
      }
    };

    var getChildElements = function (el, childTagName) {
      var children = el.childNodes;
      var child;
      var childEls = [];
      var i;

      for (i = 0; i < children.length; i++) {
        child = children[i];

        if (child.nodeType === 1) {
          // Element
          if (childTagName && child.tagName !== childTagName) {
            throw new Error("Child <" + children[i].tagName + ">" + " of <" + el.tagName + ">" + " is not a <" + childTagName + ">");
          }

          childEls.push(child);
        }
      }

      return childEls;
    };

    var getSoleChild = function (el, childTagName) {
      var children = getChildElements(el, childTagName);

      if (children.length === 1) {
        return children[0];
      } else {
        throw new Error("No sole child of <" + el.tagName + ">");
      }
    };

    var getTextContent = function (el) {
      var txt = "";
      var i;
      var child;

      for (i = 0; i < el.childNodes.length; i++) {
        child = el.childNodes[i];

        if (child.nodeType === 1) {
          // Element
          throw new Error("Element found in text content");
        } else if (child.nodeType === 3 || // Text
        child.nodeType === 4) {
          // CDATASection
          txt += child.nodeValue;
        }
      }

      return txt;
    };

    var stringify = function (obj) {
      return typeof JSON === "undefined" ? "..." : JSON.stringify(obj);
    }; // XmlRpc class:
    // Utilities for packing and unpacking XML-RPC messages.
    // See xml-rpc.com.


    var XmlRpc = {}; // Takes text and turns it into something suitable for use as the content
    // of an XML-RPC string - special characters are escaped.

    XmlRpc.escapeXml = function (s) {
      return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }; // Asserts that the elements of paramList match the types given by typeList.
    // TypeList must be an array containing only TYPE_STRING, TYPE_LIST
    // and TYPE_MAP objects in some combination.  paramList must be the
    // same length.
    // In case of mismatch an error is thrown.


    XmlRpc.checkParams = function (paramList, typeList) {
      var i;

      for (i = 0; i < typeList.length; i++) {
        if (typeList[i] !== TYPE_STRING && typeList[i] !== TYPE_LIST && typeList[i] !== TYPE_MAP) {
          throw new Error("Unknown type " + typeList[i] + " in check list");
        }
      }

      var npar = paramList.length;
      var actualTypeList = [];
      var ok = true;

      for (i = 0; i < npar; i++) {
        actualTypeList.push(getSampType(paramList[i]));
      }

      ok = ok && typeList.length === npar;

      for (i = 0; ok && i < npar; i++) {
        ok = ok && typeList[i] === actualTypeList[i];
      }

      if (!ok) {
        throw new Error("Param type list mismatch: " + "[" + typeList + "] != " + "[" + actualTypeList + "]");
      }
    }; // Turns a SAMP object (structure of strings, lists, maps) into an
    // XML string suitable for use with XML-RPC.


    XmlRpc.valueToXml = function v2x(obj, prefix) {
      prefix = prefix || "";
      var i;
      var result;
      var type = getSampType(obj);

      if (type === TYPE_STRING) {
        return prefix + "<value><string>" + XmlRpc.escapeXml(obj) + "</string></value>";
      } else if (type === TYPE_LIST) {
        result = [];
        result.push(prefix + "<value>", prefix + "  <array>", prefix + "    <data>");

        for (i = 0; i < obj.length; i++) {
          result.push(v2x(obj[i], prefix + "      "));
        }

        result.push(prefix + "    </data>", prefix + "  </array>", prefix + "</value>");
        return result.join("\n");
      } else if (type === TYPE_MAP) {
        result = [];
        result.push(prefix + "<value>");
        result.push(prefix + "  <struct>");

        for (i in obj) {
          result.push(prefix + "    <member>");
          result.push(prefix + "      <name>" + XmlRpc.escapeXml(i) + "</name>");
          result.push(v2x(obj[i], prefix + "      "));
          result.push(prefix + "    </member>");
        }

        result.push(prefix + "  </struct>");
        result.push(prefix + "</value>");
        return result.join("\n");
      } else {
        throw new Error("bad type"); // shouldn't get here
      }
    }; // Turns an XML string from and XML-RPC message into a SAMP object
    // (structure of strings, lists, maps).


    XmlRpc.xmlToValue = function x2v(valueEl, allowInt) {
      var childEls = getChildElements(valueEl);
      var i;
      var j;
      var childEl;
      var elName;

      if (childEls.length === 0) {
        return getTextContent(valueEl);
      } else if (childEls.length === 1) {
        childEl = childEls[0];
        elName = childEl.tagName;

        if (elName === "string") {
          return getTextContent(childEl);
        } else if (elName === "array") {
          var valueEls = getChildElements(getSoleChild(childEl, "data"), "value");
          var list = [];

          for (i = 0; i < valueEls.length; i++) {
            list.push(x2v(valueEls[i], allowInt));
          }

          return list;
        } else if (elName === "struct") {
          var memberEls = getChildElements(childEl, "member");
          var map = {};
          var s_name;
          var s_value;
          var jc;

          for (i = 0; i < memberEls.length; i++) {
            s_name = undefined;
            s_value = undefined;

            for (j = 0; j < memberEls[i].childNodes.length; j++) {
              jc = memberEls[i].childNodes[j];

              if (jc.nodeType == 1) {
                if (jc.tagName === "name") {
                  s_name = getTextContent(jc);
                } else if (jc.tagName === "value") {
                  s_value = x2v(jc, allowInt);
                }
              }
            }

            if (s_name !== undefined && s_value !== undefined) {
              map[s_name] = s_value;
            } else {
              throw new Error("No <name> and/or <value> " + "in <member>?");
            }
          }

          return map;
        } else if (allowInt && (elName === "int" || elName === "i4")) {
          return getTextContent(childEl);
        } else {
          throw new Error("Non SAMP-friendly value content: " + "<" + elName + ">");
        }
      } else {
        throw new Error("Bad XML-RPC <value> content - multiple elements");
      }
    }; // Turns the content of an XML-RPC <params> element into an array of
    // SAMP objects.


    XmlRpc.decodeParams = function (paramsEl) {
      var paramEls = getChildElements(paramsEl, "param");
      var i;
      var results = [];

      for (i = 0; i < paramEls.length; i++) {
        results.push(XmlRpc.xmlToValue(getSoleChild(paramEls[i], "value")));
      }

      return results;
    }; // Turns the content of an XML-RPC <fault> element into an XmlRpc.Fault
    // object.


    XmlRpc.decodeFault = function (faultEl) {
      var faultObj = XmlRpc.xmlToValue(getSoleChild(faultEl, "value"), true);
      return new XmlRpc.Fault(faultObj.faultString, faultObj.faultCode);
    }; // Turns an XML-RPC response element (should be <methodResponse>) into
    // either a SAMP response object or an XmlRpc.Fault object.
    // Note that a fault response does not throw an error, so check for
    // the type of the result if you want to know whether a fault occurred.
    // An error will however be thrown if the supplied XML does not
    // correspond to a legal XML-RPC response.


    XmlRpc.decodeResponse = function (xml) {
      var mrEl = xml.documentElement;

      if (mrEl.tagName !== "methodResponse") {
        throw new Error("Response element is not <methodResponse>");
      }

      var contentEl = getSoleChild(mrEl);

      if (contentEl.tagName === "fault") {
        return XmlRpc.decodeFault(contentEl);
      } else if (contentEl.tagName === "params") {
        return XmlRpc.decodeParams(contentEl)[0];
      } else {
        throw new Error("Bad XML-RPC response - unknown element" + " <" + contentEl.tagName + ">");
      }
    }; // XmlRpc.Fault class:
    // Represents an XML-RPC Fault response.


    XmlRpc.Fault = function (faultString, faultCode) {
      this.faultString = faultString;
      this.faultCode = faultCode;
    };

    XmlRpc.Fault.prototype.toString = function () {
      return "XML-RPC Fault (" + this.faultCode + "): " + this.faultString;
    }; // XmlRpcRequest class:
    // Represents an call which can be sent to an XML-RPC server.


    var XmlRpcRequest = function (methodName, params) {
      this.methodName = methodName;
      this.params = params || [];
    };

    XmlRpcRequest.prototype.toString = function () {
      return this.methodName + "(" + stringify(this.params) + ")";
    };

    XmlRpcRequest.prototype.addParam = function (param) {
      this.params.push(param);
      return this;
    };

    XmlRpcRequest.prototype.addParams = function (params) {
      var i;

      for (i = 0; i < params.length; i++) {
        this.params.push(params[i]);
      }

      return this;
    };

    XmlRpcRequest.prototype.checkParams = function (typeList) {
      XmlRpc.checkParams(this.params, typeList);
    };

    XmlRpcRequest.prototype.toXml = function () {
      var lines = [];
      lines.push("<?xml version='1.0'?>", "<methodCall>", "  <methodName>" + this.methodName + "</methodName>", "  <params>");

      for (var i = 0; i < this.params.length; i++) {
        lines.push("    <param>", XmlRpc.valueToXml(this.params[i], "      "), "    </param>");
      }

      lines.push("  </params>", "</methodCall>");
      return lines.join("\n");
    }; // XmlRpcClient class:
    // Object capable of sending XML-RPC calls to an XML-RPC server.
    // That server will typically reside on the host on which the
    // javascript is running; it is not likely to reside on the host
    // which served the javascript.  That means that sandboxing restrictions
    // will be in effect.  Much of the work done here is therefore to
    // do the client-side work required to potentially escape the sandbox.
    // The endpoint parameter, if supplied, is the URL of the XML-RPC server.
    // If absent, the default SAMP Web Profile server is used.


    var XmlRpcClient = function (endpoint) {
      this.endpoint = endpoint || "http://localhost:" + WEBSAMP_PORT + WEBSAMP_PATH;
    }; // Creates an XHR facade - an object that presents an interface
    // resembling that of an XMLHttpRequest Level 2.
    // This facade may be based on an actual XMLHttpRequest Level 2 object
    // (on browsers that support it), or it may fake one using other
    // available technology.
    //
    // The created facade in any case presents the following interface:
    //
    //    open(method, url)
    //    send(body)
    //    abort()
    //    setContentType()
    //    responseText
    //    responseXML
    //    onload
    //    onerror(err)  - includes timeout; abort is ignored
    //
    // See the documentation at http://www.w3.org/TR/XMLHttpRequest/
    // for semantics.
    //
    // XMLHttpRequest Level 2 supports Cross-Origin Resource Sharing (CORS)
    // which makes sandbox evasion possible.  Faked XHRL2s returned by
    // this method may use CORS or some other technology to evade the
    // sandbox.  The SAMP hub itself may selectively allow some of these
    // technologies and not others, according to configuration.


    XmlRpcClient.createXHR = function () {
      // Creates an XHR facade based on a genuine XMLHttpRequest Level 2.
      var XhrL2 = function (xhr) {
        this.xhr = xhr;

        xhr.onreadystatechange = function (l2) {
          return function () {
            if (xhr.readyState !== 4) {
              return;
            } else if (!l2.completed) {
              if (+xhr.status === 200) {
                l2.completed = true;
                l2.responseText = xhr.responseText;
                l2.responseXML = xhr.responseXML;

                if (l2.onload) {
                  l2.onload();
                }
              }
            }
          };
        }(this);

        xhr.onerror = function (l2) {
          return function (event) {
            if (!l2.completed) {
              l2.completed = true;

              if (l2.onerror) {
                if (event) {
                  event.toString = function () {
                    return "No hub?";
                  };
                } else {
                  event = "No hub?";
                }

                l2.onerror(event);
              }
            }
          };
        }(this);

        xhr.ontimeout = function (l2) {
          return function (event) {
            if (!l2.completed) {
              l2.completed = true;

              if (l2.onerror) {
                l2.onerror("timeout");
              }
            }
          };
        }(this);
      };

      XhrL2.prototype.open = function (method, url) {
        this.xhr.open(method, url);
      };

      XhrL2.prototype.send = function (body) {
        this.xhr.send(body);
      };

      XhrL2.prototype.abort = function () {
        this.xhr.abort();
      };

      XhrL2.prototype.setContentType = function (mimeType) {
        if ("setRequestHeader" in this.xhr) {
          this.xhr.setRequestHeader("Content-Type", mimeType);
        }
      }; // Creates an XHR facade based on an XDomainRequest (IE8+ only).


      var XdrL2 = function (xdr) {
        this.xdr = xdr;

        xdr.onload = function (l2) {
          return function () {
            l2.responseText = xdr.responseText;

            if (xdr.contentType === "text/xml" || xdr.contentType === "application/xml" || /\/x-/.test(xdr.contentType)) {
              try {
                var xdoc = new ActiveXObject("Microsoft.XMLDOM");
                xdoc.loadXML(xdr.responseText);
                l2.responseXML = xdoc;
              } catch (e) {
                l2.responseXML = e;
              }
            }

            if (l2.onload) {
              l2.onload();
            }
          };
        }(this);

        xdr.onerror = function (l2) {
          return function (event) {
            if (l2.onerror) {
              l2.onerror(event);
            }
          };
        }(this);

        xdr.ontimeout = function (l2) {
          return function (event) {
            if (l2.onerror) {
              l2.onerror(event);
            }
          };
        }(this);
      };

      XdrL2.prototype.open = function (method, url) {
        this.xdr.open(method, url);
      };

      XdrL2.prototype.send = function (body) {
        this.xdr.send(body);
      };

      XdrL2.prototype.abort = function () {
        this.xdr.abort();
      };

      XdrL2.prototype.setContentType = function (mimeType) {// can't do it.
      }; // Creates an XHR Facade based on available XMLHttpRequest-type
      // capabilibities.
      // If an actual XMLHttpRequest Level 2 is available, use that.


      if (typeof XMLHttpRequest !== "undefined") {
        var xhr = new XMLHttpRequest();

        if ("withCredentials" in xhr) {
          return new XhrL2(xhr);
        }
      } // Else if an XDomainRequest is available, use that.


      if (typeof XDomainRequest !== "undefined") {
        return new XdrL2(new XDomainRequest());
      } // Else fake an XMLHttpRequest using Flash/flXHR, if available
      // and use that.


      if (typeof flensed.flXHR !== "undefined") {
        return new XhrL2(new flensed.flXHR({
          instancePooling: true
        }));
      } // No luck.


      throw new Error("no cross-origin mechanism available");
    }; // Executes a request by passing it to the XML-RPC server.
    // On success, the result is passed to the resultHandler.
    // On failure, the errHandler is called with one of two possible
    // arguments: an XmlRpc.Fault object, or an Error object.


    XmlRpcClient.prototype.execute = function (req, resultHandler, errHandler) {
      (function (xClient) {
        var xhr;

        try {
          xhr = XmlRpcClient.createXHR();
          xhr.open("POST", xClient.endpoint);
          xhr.setContentType("text/xml");
        } catch (e) {
          errHandler(e);
          throw e;
        }

        xhr.onload = function () {
          var xml = xhr.responseXML;
          var result;

          if (xml) {
            try {
              result = XmlRpc.decodeResponse(xml);
            } catch (e) {
              if (errHandler) {
                errHandler(e);
              }

              return;
            }
          } else {
            if (errHandler) {
              errHandler("no XML response");
            }

            return;
          }

          if (result instanceof XmlRpc.Fault) {
            if (errHandler) {
              errHandler(result);
            }
          } else {
            if (resultHandler) {
              resultHandler(result);
            }
          }
        };

        xhr.onerror = function (event) {
          if (event) {
            event.toString = function () {
              return "No hub?";
            };
          } else {
            event = "No hub";
          }

          if (errHandler) {
            errHandler(event);
          }
        };

        xhr.send(req.toXml());
        return xhr;
      })(this);
    }; // Message class:
    // Aggregates an MType string and a params map.


    var Message = function (mtype, params) {
      this["samp.mtype"] = mtype;
      this["samp.params"] = params;
    }; // Connection class:
    // this is what clients use to communicate with the hub.
    //
    // All the methods from the Hub Abstract API as described in the
    // SAMP standard are available as methods of a Connection object.
    // The initial private-key argument required by the Web Profile is
    // handled internally by this object - you do not need to supply it
    // when calling one of the methods.
    //
    // All these calls have the same form:
    //
    //    connection.method([method-args], resultHandler, errorHandler)
    //
    // the first argument is an array of the arguments (as per the SAMP
    // abstract hub API), the second argument is a function which is
    // called on successful completion with the result of the SAMP call
    // as its argument, and the third argument is a function which is
    // called on unsuccessful completion with an error object as its
    // argument.  The resultHandler and errorHandler arguments are optional.
    //
    // So for instance if you have a Connection object conn,
    // you can send a notify message to all other clients by doing, e.g.:
    //
    //    conn.notifyAll([new samp.Message(mtype, params)])
    //
    // Connection has other methods as well as the hub API ones
    // as documented below.


    var Connection = function (regInfo) {
      this.regInfo = regInfo;
      this.privateKey = regInfo["samp.private-key"];

      if (!typeof this.privateKey === "string") {
        throw new Error("Bad registration object");
      }

      this.xClient = new XmlRpcClient();
    };

    (function () {
      var connMethods = {
        call: [TYPE_STRING, TYPE_STRING, TYPE_MAP],
        callAll: [TYPE_STRING, TYPE_MAP],
        callAndWait: [TYPE_STRING, TYPE_MAP, TYPE_STRING],
        declareMetadata: [TYPE_MAP],
        declareSubscriptions: [TYPE_MAP],
        getMetadata: [TYPE_STRING],
        getRegisteredClients: [],
        getSubscribedClients: [TYPE_STRING],
        getSubscriptions: [TYPE_STRING],
        notify: [TYPE_STRING, TYPE_MAP],
        notifyAll: [TYPE_MAP],
        ping: [],
        reply: [TYPE_STRING, TYPE_MAP]
      };
      var fn;

      for (fn in connMethods) {
        (function (fname, types) {
          // errHandler may be passed an XmlRpc.Fault or a thrown Error.
          Connection.prototype[fname] = function (sampArgs, resultHandler, errHandler) {
            var closer = function (c) {
              return function () {
                c.close();
              };
            }(this);

            errHandler = errHandler || closer;
            XmlRpc.checkParams(sampArgs, types);
            var request = new XmlRpcRequest(WEBSAMP_PREFIX + fname);
            request.addParam(this.privateKey);
            request.addParams(sampArgs);
            return this.xClient.execute(request, resultHandler, errHandler);
          };
        })(fn, connMethods[fn]);
      }
    })();

    Connection.prototype.unregister = function () {

      if (this.callbackRequest) {
        try {
          this.callbackRequest.abort();
        } catch (e) {}
      }

      var request = new XmlRpcRequest(WEBSAMP_PREFIX + "unregister");
      request.addParam(this.privateKey);

      try {
        this.xClient.execute(request);
      } catch (e) {// log unregister failed
      }

      delete this.regInfo;
      delete this.privateKey;
    }; // Closes this connection.  It unregisters from the hub if still
    // registered, but may harmlessly be called multiple times.


    Connection.prototype.close = function () {

      if (this.closed) {
        return;
      }

      this.closed = true;

      try {
        if (this.regInfo) {
          this.unregister();
        }
      } catch (e) {}

      if (this.onclose) {
        oc = this.onclose;
        delete this.onclose;

        try {
          oc();
        } catch (e) {}
      }
    }; // Arranges for this connection to receive callbacks.
    //
    // The callableClient argument must be an object implementing the
    // SAMP callable client API, i.e. it must have the following methods:
    //
    //     receiveNotification(string sender-id, map message)
    //     receiveCall(string sender-id, string msg-id, map message)
    //     receiveResponse(string responder-id, string msg-tag, map response)
    //
    // The successHandler argument will be called with no arguments if the
    // allowCallbacks hub method completes successfully - it is a suitable
    // hook to use for declaring subscriptions.
    //
    // The CallableClient class provides a suitable implementation, see below.


    Connection.prototype.setCallable = function (callableClient, successHandler) {

      if (this.callbackRequest) {
        try {
          this.callbackRequest.abort();
        } catch (e) {} finally {
          delete this.callbackRequest;
        }
      }

      if (!callableClient && !this.regInfo) {
        return;
      }

      var request = new XmlRpcRequest(WEBSAMP_PREFIX + "allowReverseCallbacks");
      request.addParam(this.privateKey);
      request.addParam(callableClient ? "1" : "0");

      var closer = function (c) {
        return function () {
          c.close();
        };
      }(this);

      if (callableClient) {
        (function (connection) {
          var invokeCallback = function (callback) {
            var methodName = callback["samp.methodName"];
            var methodParams = callback["samp.params"];
            var handlerFunc = undefined;

            if (methodName === WEBSAMP_CLIENT_PREFIX + "receiveNotification") {
              handlerFunc = callableClient.receiveNotification;
            } else if (methodName === WEBSAMP_CLIENT_PREFIX + "receiveCall") {
              handlerFunc = callableClient.receiveCall;
            } else if (methodName === WEBSAMP_CLIENT_PREFIX + "receiveResponse") {
              handlerFunc = callableClient.receiveResponse;
            } else ;

            if (handlerFunc) {
              handlerFunc.apply(callableClient, methodParams);
            }
          };

          var startTime;

          var resultHandler = function (result) {
            if (getSampType(result) != TYPE_LIST) {
              errHandler();
              return;
            }

            var i;

            for (i = 0; i < result.length; i++) {
              try {
                invokeCallback(result[i]);
              } catch (e) {// log here?
              }
            }

            callWaiter();
          };

          var errHandler = function (error) {
            var elapsed = new Date().getTime() - startTime;

            if (elapsed < 1000) {
              connection.close();
            } else {
              // probably a timeout
              callWaiter();
            }
          };

          var callWaiter = function () {
            if (!connection.regInfo) {
              return;
            }

            var request = new XmlRpcRequest(WEBSAMP_PREFIX + "pullCallbacks");
            request.addParam(connection.privateKey);
            request.addParam("600");
            startTime = new Date().getTime();
            connection.callbackRequest = connection.xClient.execute(request, resultHandler, errHandler);
          };

          var sHandler = function () {
            callWaiter();
            successHandler();
          };

          connection.xClient.execute(request, sHandler, closer);
        })(this);
      } else {
        this.xClient.execute(request, successHandler, closer);
      }
    }; // Takes a public URL and returns a URL that can be used from within
    // this javascript context.  Some translation may be required, since
    // a URL sent by an external application may be cross-domain, in which
    // case browser sandboxing would typically disallow access to it.


    Connection.prototype.translateUrl = function (url) {
      var translator = this.regInfo["samp.url-translator"] || "";
      return translator + url;
    };

    Connection.Action = function (actName, actArgs, resultKey) {
      this.actName = actName;
      this.actArgs = actArgs;
      this.resultKey = resultKey;
    }; // Suitable implementation for a callable client object which can
    // be supplied to Connection.setCallable().
    // Its callHandler and replyHandler members are string->function maps
    // which can be used to provide handler functions for MTypes and
    // message tags respectively.
    //
    // In more detail:
    // The callHandler member maps a string representing an MType to
    // a function with arguments (senderId, message, isCall).
    // The replyHandler member maps a string representing a message tag to
    // a function with arguments (responderId, msgTag, response).


    var CallableClient = function (connection) {
      this.callHandler = {};
      this.replyHandler = {};
    };

    CallableClient.prototype.init = function (connection) {};

    CallableClient.prototype.receiveNotification = function (senderId, message) {
      var mtype = message["samp.mtype"];
      var handled = false;

      if (mtype in this.callHandler) {
        try {
          this.callHandler[mtype](senderId, message, false);
        } catch (e) {}

        handled = true;
      }

      return handled;
    };

    CallableClient.prototype.receiveCall = function (senderId, msgId, message) {
      var mtype = message["samp.mtype"];
      var handled = false;
      var response;
      var result;

      if (mtype in this.callHandler) {
        try {
          result = this.callHandler[mtype](senderId, message, true) || {};
          response = {
            "samp.status": "samp.ok",
            "samp.result": result
          };
          handled = true;
        } catch (e) {
          response = {
            "samp.status": "samp.error",
            "samp.error": {
              "samp.errortxt": e.toString()
            }
          };
        }
      } else {
        response = {
          "samp.status": "samp.warning",
          "samp.result": {},
          "samp.error": {
            "samp.errortxt": "no action"
          }
        };
      }

      this.connection.reply([msgId, response]);
      return handled;
    };

    CallableClient.prototype.receiveResponse = function (responderId, msgTag, response) {
      var handled = false;

      if (msgTag in this.replyHandler) {
        try {
          this.replyHandler[msgTag](responderId, msgTag, response);
          handled = true;
        } catch (e) {}
      }

      return handled;
    };

    CallableClient.prototype.calculateSubscriptions = function () {
      var subs = {};
      var mt;

      for (mt in this.callHandler) {
        subs[mt] = {};
      }

      return subs;
    }; // ClientTracker is a CallableClient which also provides tracking of
    // registered clients.
    //
    // Its onchange member, if defined, will be called with arguments
    // (client-id, change-type, associated-data) whenever the list or
    // characteristics of registered clients has changed.


    var ClientTracker = function () {
      var tracker = this;
      this.ids = {};
      this.metas = {};
      this.subs = {};
      this.replyHandler = {};
      this.callHandler = {
        "samp.hub.event.shutdown": function (senderId, message) {
          tracker.connection.close();
        },
        "samp.hub.disconnect": function (senderId, message) {
          tracker.connection.close();
        },
        "samp.hub.event.register": function (senderId, message) {
          var id = message["samp.params"]["id"];
          tracker.ids[id] = true;
          tracker.changed(id, "register", null);
        },
        "samp.hub.event.unregister": function (senderId, message) {
          var id = message["samp.params"]["id"];
          delete tracker.ids[id];
          delete tracker.metas[id];
          delete tracker.subs[id];
          tracker.changed(id, "unregister", null);
        },
        "samp.hub.event.metadata": function (senderId, message) {
          var id = message["samp.params"]["id"];
          var meta = message["samp.params"]["metadata"];
          tracker.metas[id] = meta;
          tracker.changed(id, "meta", meta);
        },
        "samp.hub.event.subscriptions": function (senderId, message) {
          var id = message["samp.params"]["id"];
          var subs = message["samp.params"]["subscriptions"];
          tracker.subs[id] = subs;
          tracker.changed(id, "subs", subs);
        }
      };
    };

    ClientTracker.prototype = heir(CallableClient.prototype);

    ClientTracker.prototype.changed = function (id, type, data) {
      if (this.onchange) {
        this.onchange(id, type, data);
      }
    };

    ClientTracker.prototype.init = function (connection) {
      var tracker = this;
      this.connection = connection;

      var retrieveInfo = function (id, type, infoFuncName, infoArray) {
        connection[infoFuncName]([id], function (info) {
          infoArray[id] = info;
          tracker.changed(id, type, info);
        });
      };

      connection.getRegisteredClients([], function (idlist) {
        var i;
        var id;
        tracker.ids = {};

        for (i = 0; i < idlist.length; i++) {
          id = idlist[i];
          tracker.ids[id] = true;
          retrieveInfo(id, "meta", "getMetadata", tracker.metas);
          retrieveInfo(id, "subs", "getSubscriptions", tracker.subs);
        }

        tracker.changed(null, "ids", null);
      });
    };

    ClientTracker.prototype.getName = function (id) {
      var meta = this.metas[id];
      return meta && meta["samp.name"] ? meta["samp.name"] : "[" + id + "]";
    }; // Connector class:
    // A higher level class which can manage transparent hub
    // registration/unregistration and client tracking.
    //
    // On construction, the name argument is mandatory, and corresponds
    // to the samp.name item submitted at registration time.
    // The other arguments are optional.
    // meta is a metadata map (if absent, no metadata is declared)
    // callableClient is a callable client object for receiving callbacks
    // (if absent, the client is not callable).
    // subs is a subscriptions map (if absent, no subscriptions are declared)


    var Connector = function (name, meta, callableClient, subs) {
      this.name = name;
      this.meta = meta;
      this.callableClient = callableClient;
      this.subs = subs;
      this.regTextNodes = [];
      this.whenRegs = [];
      this.whenUnregs = [];
      this.connection = undefined;
      this.onreg = undefined;
      this.onunreg = undefined;
    };

    var setRegText = function (connector, txt) {
      var i;
      var nodes = connector.regTextNodes;
      var node;

      for (i = 0; i < nodes.length; i++) {
        node = nodes[i];
        node.innerHTML = "";
        node.appendChild(document.createTextNode(txt));
      }
    };

    Connector.prototype.setConnection = function (conn) {
      var connector = this;

      if (this.connection) {
        this.connection.close();

        if (this.onunreg) {
          try {
            this.onunreg();
          } catch (e) {}
        }
      }

      this.connection = conn;

      if (conn) {
        conn.onclose = function () {
          connector.connection = null;

          if (connector.onunreg) {
            try {
              connector.onunreg();
            } catch (e) {}
          }

          connector.update();
        };

        if (this.meta) {
          conn.declareMetadata([this.meta]);
        }

        if (this.callableClient) {
          if (this.callableClient.init) {
            this.callableClient.init(conn);
          }

          conn.setCallable(this.callableClient, function () {
            conn.declareSubscriptions([connector.subs]);
          });
        }

        if (this.onreg) {
          try {
            this.onreg(conn);
          } catch (e) {}
        }
      }

      this.update();
    };

    Connector.prototype.register = function () {
      var connector = this;

      var regErrHandler = function (err) {
        setRegText(connector, "no (" + err.toString() + ")");
      };

      var regSuccessHandler = function (conn) {
        connector.setConnection(conn);
        setRegText(connector, conn ? "Yes" : "No");
      };

      register(this.name, regSuccessHandler, regErrHandler);
    };

    Connector.prototype.unregister = function () {
      if (this.connection) {
        this.connection.unregister([]);
        this.setConnection(null);
      }
    }; // Returns a document fragment which contains Register/Unregister
    // buttons for use by the user to attempt to connect/disconnect
    // with the hub.  This is useful for models where explicit
    // user registration is encouraged or required, but when using
    // the register-on-demand model such buttons are not necessary.


    Connector.prototype.createRegButtons = function () {
      var connector = this;
      var regButt = document.createElement("button");
      regButt.setAttribute("type", "button");
      regButt.appendChild(document.createTextNode("Register"));

      regButt.onclick = function () {
        connector.register();
      };

      this.whenUnregs.push(regButt);
      var unregButt = document.createElement("button");
      unregButt.setAttribute("type", "button");
      unregButt.appendChild(document.createTextNode("Unregister"));

      unregButt.onclick = function () {
        connector.unregister();
      };

      this.whenRegs.push(unregButt);
      var regText = document.createElement("span");
      this.regTextNodes.push(regText);
      var node = document.createDocumentFragment();
      node.appendChild(regButt);
      node.appendChild(document.createTextNode(" "));
      node.appendChild(unregButt);
      var label = document.createElement("span");
      label.innerHTML = " <strong>Registered: </strong>";
      node.appendChild(label);
      node.appendChild(regText);
      this.update();
      return node;
    };

    Connector.prototype.update = function () {
      var i;
      var isConnected = !!this.connection;
      var enableds = isConnected ? this.whenRegs : this.whenUnregs;
      var disableds = isConnected ? this.whenUnregs : this.whenRegs;

      for (i = 0; i < enableds.length; i++) {
        enableds[i].removeAttribute("disabled");
      }

      for (i = 0; i < disableds.length; i++) {
        disableds[i].setAttribute("disabled", "disabled");
      }

      setRegText(this, "No");
    }; // Provides execution of a SAMP operation with register-on-demand.
    // You can use this method to provide lightweight registration/use
    // of web SAMP.  Simply provide a connHandler function which
    // does something with a connection (e.g. sends a message) and
    // Connector.runWithConnection on it.  This will connect if not
    // already connected, and call the connHandler on with the connection.
    // No explicit registration action is then required from the user.
    //
    // If the regErrorHandler argument is supplied, it is a function of
    // one (error) argument called in the case that registration-on-demand
    // fails.
    //
    // This is a more-or-less complete sampjs page:
    //   <script>
    //     var connector = new samp.Connector("pinger", {"samp.name": "Pinger"})
    //     var pingFunc = function(connection) {
    //       connection.notifyAll([new samp.Message("samp.app.ping", {})])
    //     }
    //   </script>
    //   <button onclick="connector.runWithConnection(pingFunc)">Ping</button>


    Connector.prototype.runWithConnection = function (connHandler, regErrorHandler) {
      var connector = this;

      var regSuccessHandler = function (conn) {
        connector.setConnection(conn);
        connHandler(conn);
      };

      var regFailureHandler = function (e) {
        connector.setConnection(undefined);
        regErrorHandler(e);
      };

      var pingResultHandler = function (result) {
        connHandler(connector.connection);
      };

      var pingErrorHandler = function (err) {
        register(this.name, regSuccessHandler, regFailureHandler);
      };

      if (this.connection) {
        // Use getRegisteredClients as the most lightweight check
        // I can think of that this connection is still OK.
        // Ping doesn't work because the server replies even if the
        // private-key is incorrect/invalid.  Is that a bug or not?
        this.connection.getRegisteredClients([], pingResultHandler, pingErrorHandler);
      } else {
        register(this.name, regSuccessHandler, regFailureHandler);
      }
    }; // Sets up an interval timer to run at intervals and notify a callback
    // about whether a hub is currently running.
    // Every millis milliseconds, the supplied availHandler function is
    // called with a boolean argument: true if a (web profile) hub is
    // running, false if not.
    // Returns the interval timer (can be passed to clearInterval()).


    Connector.prototype.onHubAvailability = function (availHandler, millis) {
      samp$1.ping(availHandler); // Could use the W3C Page Visibility API to avoid making these
      // checks when the page is not visible.

      return setInterval(function () {
        samp$1.ping(availHandler);
      }, millis);
    }; // Determines whether a given subscriptions map indicates subscription
    // to a given mtype.


    var isSubscribed = function (subs, mtype) {
      var matching = function (pattern, mtype) {
        if (pattern == mtype) {
          return true;
        } else if (pattern === "*") {
          return true;
        } else {
          var prefix;
          var split = /^(.*)\.\*$/.exec(pat);

          if (split) {
            prefix = split[1];

            if (prefix === mtype.substring(0, prefix.length)) {
              return true;
            }
          }
        }

        return false;
      };

      var pat;

      for (pat in subs) {
        if (matching(pat, mtype)) {
          return true;
        }
      }

      return false;
    }; // Attempts registration with a SAMP hub.
    // On success the supplied connectionHandler function is called
    // with the connection as an argument, on failure the supplied
    // errorHandler is called with an argument that may be an Error
    // or an XmlRpc.Fault.


    var register = function (appName, connectionHandler, errorHandler) {
      var xClient = new XmlRpcClient();
      var regRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "register");
      var securityInfo = {
        "samp.name": appName
      };
      regRequest.addParam(securityInfo);
      regRequest.checkParams([TYPE_MAP]);

      var resultHandler = function (result) {
        var conn;

        try {
          conn = new Connection(result);
        } catch (e) {
          errorHandler(e);
          return;
        }

        connectionHandler(conn);
      };

      xClient.execute(regRequest, resultHandler, errorHandler);
    }; // Calls the hub ping method once.  It is not necessary to be
    // registered to do this.
    // The supplied pingHandler function is called with a boolean argument:
    // true if a (web profile) hub is running, false if not.


    var ping = function (pingHandler) {
      var xClient = new XmlRpcClient();
      var pingRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "ping");

      var resultHandler = function (result) {
        pingHandler(true);
      };

      var errorHandler = function (error) {
        pingHandler(false);
      };

      xClient.execute(pingRequest, resultHandler, errorHandler);
    };
    /* Exports. */


    var jss = {};
    jss.XmlRpcRequest = XmlRpcRequest;
    jss.XmlRpcClient = XmlRpcClient;
    jss.Message = Message;
    jss.TYPE_STRING = TYPE_STRING;
    jss.TYPE_LIST = TYPE_LIST;
    jss.TYPE_MAP = TYPE_MAP;
    jss.register = register;
    jss.ping = ping;
    jss.isSubscribed = isSubscribed;
    jss.Connector = Connector;
    jss.CallableClient = CallableClient;
    jss.ClientTracker = ClientTracker;
    return jss;
  }();

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  let mizar;
  let connector; // SAMP connector
  // var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
  //var votable2geojsonBaseUrl;

  /**************************************************************************************************************/

  /**
   *    Create SAMP ClientTracker object which handles incoming messages
   */

  function createClientTracker() {
    // Initialize client tracker
    const clientTracker = new samp.ClientTracker(); // Init available samp income message handlers(as ping, load.votable..)

    const callHandler = clientTracker.callHandler;

    callHandler["samp.app.ping"] = function (senderId, message, isCall) {
      if (isCall) {
        return {
          text: "ping to you, " + clientTracker.getName(senderId)
        };
      }
    };

    callHandler["table.load.votable"] = function (senderId, message, isCall) {
      //if (votable2geojsonBaseUrl) {
      //TODO : convert in GeoJson
      //var params = message["samp.params"];
      //var origUrl = params.url;
      //var proxyUrl = clientTracker.connection.translateUrl(origUrl);
      //Utils.convertVotable2JsonFromURL(proxyUrl, function (response) {
      // Add feature collection
      //    JsonProcessor.handleFeatureCollection(sampLayer, response);
      //    sampLayer.addFeatureCollection(response);
      //});
      //} else {
      ErrorDialog.open(Constants.LEVEL.ERROR, "votable2geojson plugin base url isn't defined"); //}
    }; // callHandler["table.highlight.row"] = function(senderId, message, isCall) {
    // 	var params = message["samp.params"];
    // 	var url = params['url'];
    // 	var row = params['row'];
    // 	if ( highlightedData )
    // 	{
    // 		highlightedData.layer.modifyFeatureStyle( highlightedData.feature, highlightedData.layer.style );
    // 	}
    // 	if ( tables[url] )
    // 	{
    // 		var layer = tables[url].layer;
    // 		var feature = tables[url].features[parseInt(row)];
    // 		layer.modifyFeatureStyle( feature, highlightStyle );
    // 		highlightedData = {
    // 			layer: layer,
    // 			feature: feature
    // 		}
    // 		var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
    // 		navigation.zoomTo( barycenter, (navigation.renderContext.fov < 1. ? navigation.renderContext.fov : 1.), 300. );
    // 	}
    // };


    callHandler["image.load.fits"] = function (senderId, message, isCall) {// var params = message["samp.params"];
      //
      // // Create feature
      // var feature = {
      //     "geometry": {
      //         "gid": params.name,
      //         "coordinates": [],
      //         "type": "Polygon"
      //     },
      //     "properties": {
      //         "identifier": params.name
      //     },
      //     "services": {
      //         "download": {
      //             "mimetype": "image/fits",
      //             "url": params['image-id']
      //         }
      //     },
      //     "type": "Feature"
      // };
      //
      // // Get fits texture from url
      // var featureData = {
      //     layer: sampLayer,
      //     feature: feature,
      //     isFits: true
      // };
      // var url = sitoolsBaseUrl + "/proxy?external_url=" + encodeURIComponent(params['image-id']);
      // mizar.publish("image:add", featureData);
      // imageManager.computeFits(featureData, url, function (featureData, fits) {
      //     // Update feature coordinates according to Fits header
      //     var coords = Utils.getPolygonCoordinatesFromFits(fits);
      //     featureData.feature.geometry.coordinates = [coords];
      //     sampLayer.addFeature(featureData.feature);
      // });
    };

    callHandler["coord.pointAt.sky"] = function (senderId, message, isCall) {
      pointAtReceived = true;
      const params = message["samp.params"];
      const ra = parseFloat(params.ra);
      const dec = parseFloat(params.dec);
      const navigation = mizar.getActivatedContext().getNavigation();
      navigation.zoomTo([ra, dec]);
    };

    callHandler["samp.hub.event.unregister"] = function (senderId, message, isCall) {
      // Update jQuery UI buttons
      $__default['default']("#registerSamp").removeAttr("disabled").button("refresh");
      $__default['default']("#unregisterSamp").attr("disabled", "disabled").button("refresh");
      $__default['default']("#sampInvoker").toggleClass("selected");
    };

    return clientTracker;
  }
  /**************************************************************************************************************/

  /**
   *    Init SAMP connector
   */


  function initSamp(mizarAPI) {
    mizar = mizarAPI;
    const clientTracker = createClientTracker(); // Samp event callbacks

    const logCc = {
      receiveNotification: function (senderId, message) {
        clientTracker.receiveNotification(senderId, message);

        if (message["samp.mtype"] === "samp.hub.event.subscriptions") {
          // Update jQuery UI buttons
          $__default['default']("#unregisterSamp").removeAttr("disabled").button("refresh");
          $__default['default']("#registerSamp").attr("disabled", "disabled").button("refresh");
          $__default['default']("#sampInvoker").addClass("selected");
        }
      },
      receiveCall: function (senderId, msgId, message) {
        clientTracker.receiveCall(senderId, msgId, message);
      },
      receiveResponse: function (responderId, msgTag, response) {
        clientTracker.receiveResponse(responderId, msgTag, response);
      },
      init: function (connection) {
        clientTracker.init(connection);
      }
    }; // Meta-data

    const meta = {
      "samp.name": "Mizar",
      "samp.description.text": "Module for Interactive visualiZation from Astronomical Repositories",
      "mizar.version": "v1.0",
      "author.affiliation": "CNES/TPZ",
      "home.page": "http://github.com/MizarWeb"
    }; // Generate subscriptions map

    const subs = clientTracker.calculateSubscriptions();
    connector = new samp.Connector("Mizar", meta, logCc, subs); // Uncomment for automatic registration(check every 2 sec if Hub is available)
    // Adjusts page content depending on whether the hub exists or not.
    // var configureSampEnabled = function(isHubRunning) {
    //     // TODO
    // };
    // connector.onHubAvailability(configureSampEnabled, 2000);
    // Registration status element is updated by samp.js

    connector.regTextNodes.push($__default['default']("#sampResult")[0]);
    return connector;
  }
  /**************************************************************************************************************/


  var SampCore = {
    initSamp: initSamp,
    sendImage: function (url) {
      if (this.isConnected()) {
        // Send message
        const msg = new samp.Message("image.load.fits", {
          url: url
        });
        connector.connection.notifyAll([msg]);
        return "Image has been sent";
      } else {
        return "Connect to SAMP Hub first";
      }
    },
    sendVOTable: function (layer, url) {
      if (this.isConnected()) {
        // Send message
        const msg = new samp.Message("table.load.votable", {
          url: url + "&media=votable"
        });
        connector.connection.notifyAll([msg]); // Part used to highlighting
        // $.ajax({
        // 	type: "GET",
        // 	url: url,
        // 	success: function(response) {
        // 		if ( response.totalResults > 0 )
        // 		{
        // 			// Store table to be able to highlight features later
        // 			tables[ url+'&media=votable' ] = {
        // 				layer: layer,
        // 				features: []
        // 			};
        // 			for ( var i=0; i<response.features.length; i++ )
        // 			{
        // 				var feature = response.features[i];
        // 				tables[url+'&media=votable'].features.push(feature);
        // 			}
        // 		}
        // 		// Send message
        // 		var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
        // 		connector.connection.notifyAll([msg]);
        // 	},
        // 	error: function(thrownError)
        // 	{
        // 		console.error(thrownError);
        // 	}
        // });

        return "VOTable has been sent";
      } else {
        return "Connect to SAMP Hub first";
      }
    },
    // Commented part is used for highlighting feature which wasn't implemented due to
    // difficulty of SAMP protocol (client doesn't know the feature from row)
    highlightFeature: function (layer, feature) {
      /**if (this.isConnected()) {
                  // for ( var url in tables )
                  // {
                  // 	var table = tables[url];
                  // 	if ( layer == table.layer )
                  // 	{
                  // 		var featureToHighlight = _.filter( table.features, function(x){ return(feature.properties.identifier == x.properties.identifier) } );
                  // 		if ( featureToHighlight.length )
                  // 		{
                  // var featureRow = table.features.indexOf(featureToHighlight[0]);
                  // var msg = new samp.Message("table.highlight.row", {url: url, row: featureRow.toString()});
                  // connector.connection.notifyAll([msg]);
                  // 		}
                  // 	}
                  // }
              }
              */
    },
    isConnected: function () {
      return connector.connection;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var ctx$1, navigation$3, onselect$2;
  /**
   *    @constructor
   *    @param options Configuration options
   *        <ul>
   *            <li>planet: planet</li>
   *            <li>navigation: Navigation</li>
   *            <li>onselect: On selection callback</li>
   *            <li>style: Selection tool style</li>
   *        </ul>
   */

  var SelectionToolCore = function (options) {
    // Required options
    ctx$1 = options.ctx;
    navigation$3 = ctx$1.getNavigation();
    onselect$2 = options.onselect;
    this.activated = options.activated || false;
    this.renderContext = ctx$1.getRenderContext();
    this.coordinateSystem = ctx$1.getCoordinateSystem(); // Set style

    var style;

    if (options.style) {
      style = options.style;
    } else {
      style = new FeatureStyle();
    }

    style.zIndex = Constants.DISPLAY.SELECTED_VECTOR; // Layer containing selection feature

    this.selectionLayer = new VectorLayer({
      style: style,
      visible: true
    });
    ctx$1.addDraw(this.selectionLayer);
    this.selectionFeature = null; // Selection attributes

    this.radius = null; // Window radius

    this.pickPoint = null; // Window pick point

    this.geoRadius = null; // Radius in geographic reference

    this.geoPickPoint = null; // Pick point in geographic reference

    var self = this;
    var dragging = false;
    var state;
    this.renderContext.canvas.addEventListener("mousedown", function (event) {
      var pickPoint = [event.layerX, event.layerY];
      var geoPickPoint = ctx$1.getLonLatFromPixel(event.layerX, event.layerY);

      if (!self.activated && !self.selectionFeature) {
        return;
      } // Dragging : moving/resizing OR drawing selection


      if (self.activated) {
        // Draw
        navigation$3.stop();
        dragging = true;
        self.pickPoint = pickPoint;
        self.geoPickPoint = geoPickPoint;
        self.radius = 0.0;
        state = "resize";
      } else {
        var pickIsInside = UtilsIntersection.pointInRing(geoPickPoint, self.selectionFeature.geometry.coordinates[0]);

        if (!pickIsInside) {
          return;
        }

        navigation$3.stop();
        dragging = true; // Resize/move

        var inside = false; // Check if user clicked on one of control points

        for (var i = 0; i < self.selectionFeature.geometry.coordinates[0].length; i++) {
          var controlPoint = self.selectionFeature.geometry.coordinates[0][i];
          inside |= UtilsIntersection.pointInSphere(ctx$1, geoPickPoint, controlPoint, 20);
        }

        if (inside) {
          state = "resize";
        } else {
          state = "move";
        }
      }
    });
    this.renderContext.canvas.addEventListener("mousemove", function (event) {
      if (!dragging) {
        return;
      }

      var geoPickPoint = ctx$1.getLonLatFromPixel(event.layerX, event.layerY);

      if (state === "resize") {
        // Update radius
        self.radius = Math.sqrt(Math.pow(event.layerX - self.pickPoint[0], 2) + Math.pow(event.layerY - self.pickPoint[1], 2));
        self.computeGeoRadius(geoPickPoint);
      } else if (state === "move") {
        // Update pick point position
        self.pickPoint = [event.layerX, event.layerY];
        self.geoPickPoint = ctx$1.getLonLatFromPixel(event.layerX, event.layerY); // TODO: scale radius of selection shape if fov has been changed(or not?)
      }

      self.updateSelection();
    });
    this.renderContext.canvas.addEventListener("mouseup", function (event) {
      if (!dragging) {
        return;
      }

      var coordinates = self.computeSelection();

      if (self.activated && onselect$2) {
        onselect$2(coordinates);
      } // Reactivate standard navigation events


      navigation$3.start();
      dragging = false;
    });
  };
  /**********************************************************************************************/

  /**
   *    Compute selection tool radius between pickPoint and the given point
   *    @param {Array} pt point
   */


  SelectionToolCore.prototype.computeGeoRadius = function (pt) {
    // Find angle between start and stop vectors which is in fact the radius
    var dotProduct = vec3.dot(vec3.normalize(this.coordinateSystem.get3DFromWorld(pt)), vec3.normalize(this.coordinateSystem.get3DFromWorld(this.geoPickPoint)));
    var theta = Math.acos(dotProduct);
    this.geoRadius = Numeric.toDegree(theta);
  };
  /**********************************************************************************************/

  /**
   *    Compute selection for the given pick point depending on radius
   *    @return {Array} points
   */


  SelectionToolCore.prototype.computeSelection = function () {
    var rc = this.renderContext;
    var tmpMat = mat4.create(); // Compute eye in world space

    mat4.inverse(rc.viewMatrix, tmpMat);
    var eye = [tmpMat[12], tmpMat[13], tmpMat[14]]; // Compute the inverse of view/proj matrix

    mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
    mat4.inverse(tmpMat); // Scale to [-1,1]

    var widthScale = 2 / rc.canvas.width;
    var heightScale = 2 / rc.canvas.height;
    var points = [[(this.pickPoint[0] - this.radius) * widthScale - 1.0, (rc.canvas.height - this.pickPoint[1] - this.radius) * heightScale - 1.0, 1, 1], [(this.pickPoint[0] - this.radius) * widthScale - 1.0, (rc.canvas.height - this.pickPoint[1] + this.radius) * heightScale - 1.0, 1, 1], [(this.pickPoint[0] + this.radius) * widthScale - 1.0, (rc.canvas.height - this.pickPoint[1] + this.radius) * heightScale - 1.0, 1, 1], [(this.pickPoint[0] + this.radius) * widthScale - 1.0, (rc.canvas.height - this.pickPoint[1] - this.radius) * heightScale - 1.0, 1, 1]]; // Transform the four corners of selection shape into world space
    // and then for each corner compute the intersection of ray starting from the eye with the sphere

    var worldCenter = [0, 0, 0];

    for (var i = 0; i < 4; i++) {
      mat4.multiplyVec4(tmpMat, points[i]);
      vec3.scale(points[i], 1.0 / points[i][3]);
      vec3.subtract(points[i], eye, points[i]);
      vec3.normalize(points[i]);
      var ray = new Ray(eye, points[i]);
      var pos3d = ray.computePoint(ray.sphereIntersect(worldCenter, this.coordinateSystem.getGeoide().getRadius()));
      points[i] = this.coordinateSystem.getWorldFrom3D(pos3d);
    }

    return points;
  };
  /**************************************************************************************************************/

  /**
   *    Update selection coordinates
   */


  SelectionToolCore.prototype.updateSelection = function () {
    if (this.selectionFeature) {
      this.selectionLayer.removeFeature(this.selectionFeature);
    }

    var coordinates = this.computeSelection(); // Close the polygon

    coordinates.push(coordinates[0]);
    this.selectionFeature = {
      geometry: {
        gid: "selectionShape",
        coordinates: [coordinates],
        type: "Polygon",
        crs: {
          type: "name",
          properties: {
            name: ctx$1.getCoordinateSystem().getGeoideName()
          }
        }
      },
      type: "Feature"
    };
    this.selectionLayer.addFeature(this.selectionFeature);
  };
  /**************************************************************************************************************/

  /**
   *    Activate/desactivate the tool
   */


  SelectionToolCore.prototype.toggle = function () {
    this.activated = !this.activated;

    if (this.activated) {
      // TODO : Find more sexy image for cursor
      $__default['default'](this.renderContext.canvas).css("cursor", "url(css/images/selectionCursor.png)");
    } else {
      $__default['default'](this.renderContext.canvas).css("cursor", "default");
    }
  };
  /**************************************************************************************************************/

  /**
   *    Clear selection
   */


  SelectionToolCore.prototype.clear = function () {
    if (this.selectionFeature) {
      this.selectionLayer.removeFeature(this.selectionFeature);
    }

    this.pickPoint = null;
    this.radius = null;
    this.geoPickPoint = null;
    this.geoRadius = null;
  };

  var jszip = createCommonjsModule(function (module, exports) {
    (function (f) {
      {
        module.exports = f();
      }
    })(function () {
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof commonjsRequire == "function" && commonjsRequire;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw (f.code = "MODULE_NOT_FOUND", f);
            }
            var l = n[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = typeof commonjsRequire == "function" && commonjsRequire;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      })({
        1: [function (require, module, exports) {
          var utils = require("./utils");
          var support = require("./support");
          var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          exports.encode = function (input) {
            var output = [];
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
            var i = 0, len = input.length, remainingBytes = len;
            var isArray = utils.getTypeOf(input) !== "string";
            while (i < input.length) {
              remainingBytes = len - i;
              if (!isArray) {
                chr1 = input.charCodeAt(i++);
                chr2 = i < len ? input.charCodeAt(i++) : 0;
                chr3 = i < len ? input.charCodeAt(i++) : 0;
              } else {
                chr1 = input[i++];
                chr2 = i < len ? input[i++] : 0;
                chr3 = i < len ? input[i++] : 0;
              }
              enc1 = chr1 >> 2;
              enc2 = (chr1 & 3) << 4 | chr2 >> 4;
              enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
              enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
              output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
            }
            return output.join("");
          };
          exports.decode = function (input) {
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0, resultIndex = 0;
            var dataUrlPrefix = "data:";
            if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
              throw new Error("Invalid base64 input, it looks like a data url.");
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            var totalLength = input.length * 3 / 4;
            if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
              totalLength--;
            }
            if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
              totalLength--;
            }
            if (totalLength % 1 !== 0) {
              throw new Error("Invalid base64 input, bad content length.");
            }
            var output;
            if (support.uint8array) {
              output = new Uint8Array(totalLength | 0);
            } else {
              output = new Array(totalLength | 0);
            }
            while (i < input.length) {
              enc1 = _keyStr.indexOf(input.charAt(i++));
              enc2 = _keyStr.indexOf(input.charAt(i++));
              enc3 = _keyStr.indexOf(input.charAt(i++));
              enc4 = _keyStr.indexOf(input.charAt(i++));
              chr1 = enc1 << 2 | enc2 >> 4;
              chr2 = (enc2 & 15) << 4 | enc3 >> 2;
              chr3 = (enc3 & 3) << 6 | enc4;
              output[resultIndex++] = chr1;
              if (enc3 !== 64) {
                output[resultIndex++] = chr2;
              }
              if (enc4 !== 64) {
                output[resultIndex++] = chr3;
              }
            }
            return output;
          };
        }, {
          "./support": 30,
          "./utils": 32
        }],
        2: [function (require, module, exports) {
          var external = require("./external");
          var DataWorker = require("./stream/DataWorker");
          var DataLengthProbe = require("./stream/DataLengthProbe");
          var Crc32Probe = require("./stream/Crc32Probe");
          var DataLengthProbe = require("./stream/DataLengthProbe");
          function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
            this.compressedSize = compressedSize;
            this.uncompressedSize = uncompressedSize;
            this.crc32 = crc32;
            this.compression = compression;
            this.compressedContent = data;
          }
          CompressedObject.prototype = {
            getContentWorker: function () {
              var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
              var that = this;
              worker.on("end", function () {
                if (this.streamInfo["data_length"] !== that.uncompressedSize) {
                  throw new Error("Bug : uncompressed data size mismatch");
                }
              });
              return worker;
            },
            getCompressedWorker: function () {
              return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            }
          };
          CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
            return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
          };
          module.exports = CompressedObject;
        }, {
          "./external": 6,
          "./stream/Crc32Probe": 25,
          "./stream/DataLengthProbe": 26,
          "./stream/DataWorker": 27
        }],
        3: [function (require, module, exports) {
          var GenericWorker = require("./stream/GenericWorker");
          exports.STORE = {
            magic: "\u0000\u0000",
            compressWorker: function (compressionOptions) {
              return new GenericWorker("STORE compression");
            },
            uncompressWorker: function () {
              return new GenericWorker("STORE decompression");
            }
          };
          exports.DEFLATE = require("./flate");
        }, {
          "./flate": 7,
          "./stream/GenericWorker": 28
        }],
        4: [function (require, module, exports) {
          var utils = require("./utils");
          function makeTable() {
            var c, table = [];
            for (var n = 0; n < 256; n++) {
              c = n;
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
              }
              table[n] = c;
            }
            return table;
          }
          var crcTable = makeTable();
          function crc32(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc = crc ^ -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
            }
            return crc ^ -1;
          }
          function crc32str(crc, str, len, pos) {
            var t = crcTable, end = pos + len;
            crc = crc ^ -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
            }
            return crc ^ -1;
          }
          module.exports = function crc32wrapper(input, crc) {
            if (typeof input === "undefined" || !input.length) {
              return 0;
            }
            var isArray = utils.getTypeOf(input) !== "string";
            if (isArray) {
              return crc32(crc | 0, input, input.length, 0);
            } else {
              return crc32str(crc | 0, input, input.length, 0);
            }
          };
        }, {
          "./utils": 32
        }],
        5: [function (require, module, exports) {
          exports.base64 = false;
          exports.binary = false;
          exports.dir = false;
          exports.createFolders = true;
          exports.date = null;
          exports.compression = null;
          exports.compressionOptions = null;
          exports.comment = null;
          exports.unixPermissions = null;
          exports.dosPermissions = null;
        }, {}],
        6: [function (require, module, exports) {
          var ES6Promise = null;
          if (typeof Promise !== "undefined") {
            ES6Promise = Promise;
          } else {
            ES6Promise = require("lie");
          }
          module.exports = {
            Promise: ES6Promise
          };
        }, {
          "lie": 37
        }],
        7: [function (require, module, exports) {
          var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
          var pako = require("pako");
          var utils = require("./utils");
          var GenericWorker = require("./stream/GenericWorker");
          var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
          exports.magic = "\b\u0000";
          function FlateWorker(action, options) {
            GenericWorker.call(this, "FlateWorker/" + action);
            this._pako = null;
            this._pakoAction = action;
            this._pakoOptions = options;
            this.meta = {};
          }
          utils.inherits(FlateWorker, GenericWorker);
          FlateWorker.prototype.processChunk = function (chunk) {
            this.meta = chunk.meta;
            if (this._pako === null) {
              this._createPako();
            }
            this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
          };
          FlateWorker.prototype.flush = function () {
            GenericWorker.prototype.flush.call(this);
            if (this._pako === null) {
              this._createPako();
            }
            this._pako.push([], true);
          };
          FlateWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this);
            this._pako = null;
          };
          FlateWorker.prototype._createPako = function () {
            this._pako = new pako[this._pakoAction]({
              raw: true,
              level: this._pakoOptions.level || -1
            });
            var self = this;
            this._pako.onData = function (data) {
              self.push({
                data: data,
                meta: self.meta
              });
            };
          };
          exports.compressWorker = function (compressionOptions) {
            return new FlateWorker("Deflate", compressionOptions);
          };
          exports.uncompressWorker = function () {
            return new FlateWorker("Inflate", {});
          };
        }, {
          "./stream/GenericWorker": 28,
          "./utils": 32,
          "pako": 38
        }],
        8: [function (require, module, exports) {
          var utils = require("../utils");
          var GenericWorker = require("../stream/GenericWorker");
          var utf8 = require("../utf8");
          var crc32 = require("../crc32");
          var signature = require("../signature");
          var decToHex = function (dec, bytes) {
            var hex = "", i;
            for (i = 0; i < bytes; i++) {
              hex += String.fromCharCode(dec & 255);
              dec = dec >>> 8;
            }
            return hex;
          };
          var generateUnixExternalFileAttr = function (unixPermissions, isDir) {
            var result = unixPermissions;
            if (!unixPermissions) {
              result = isDir ? 16893 : 33204;
            }
            return (result & 65535) << 16;
          };
          var generateDosExternalFileAttr = function (dosPermissions, isDir) {
            return (dosPermissions || 0) & 63;
          };
          var generateZipParts = function (streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
            var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
            var dataInfo = {
              crc32: 0,
              compressedSize: 0,
              uncompressedSize: 0
            };
            if (!streamedContent || streamingEnded) {
              dataInfo.crc32 = streamInfo["crc32"];
              dataInfo.compressedSize = streamInfo["compressedSize"];
              dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
            }
            var bitflag = 0;
            if (streamedContent) {
              bitflag |= 8;
            }
            if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
              bitflag |= 2048;
            }
            var extFileAttr = 0;
            var versionMadeBy = 0;
            if (dir) {
              extFileAttr |= 16;
            }
            if (platform === "UNIX") {
              versionMadeBy = 798;
              extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
            } else {
              versionMadeBy = 20;
              extFileAttr |= generateDosExternalFileAttr(file.dosPermissions);
            }
            dosTime = date.getUTCHours();
            dosTime = dosTime << 6;
            dosTime = dosTime | date.getUTCMinutes();
            dosTime = dosTime << 5;
            dosTime = dosTime | date.getUTCSeconds() / 2;
            dosDate = date.getUTCFullYear() - 1980;
            dosDate = dosDate << 4;
            dosDate = dosDate | date.getUTCMonth() + 1;
            dosDate = dosDate << 5;
            dosDate = dosDate | date.getUTCDate();
            if (useUTF8ForFileName) {
              unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName;
              extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField;
            }
            if (useUTF8ForComment) {
              unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment;
              extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField;
            }
            var header = "";
            header += "\n\u0000";
            header += decToHex(bitflag, 2);
            header += compression.magic;
            header += decToHex(dosTime, 2);
            header += decToHex(dosDate, 2);
            header += decToHex(dataInfo.crc32, 4);
            header += decToHex(dataInfo.compressedSize, 4);
            header += decToHex(dataInfo.uncompressedSize, 4);
            header += decToHex(encodedFileName.length, 2);
            header += decToHex(extraFields.length, 2);
            var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
            var dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\u0000\u0000" + "\u0000\u0000" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
            return {
              fileRecord: fileRecord,
              dirRecord: dirRecord
            };
          };
          var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
            var dirEnd = "";
            var encodedComment = utils.transformTo("string", encodeFileName(comment));
            dirEnd = signature.CENTRAL_DIRECTORY_END + "\u0000\u0000" + "\u0000\u0000" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment;
            return dirEnd;
          };
          var generateDataDescriptors = function (streamInfo) {
            var descriptor = "";
            descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo["crc32"], 4) + decToHex(streamInfo["compressedSize"], 4) + decToHex(streamInfo["uncompressedSize"], 4);
            return descriptor;
          };
          function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
            GenericWorker.call(this, "ZipFileWorker");
            this.bytesWritten = 0;
            this.zipComment = comment;
            this.zipPlatform = platform;
            this.encodeFileName = encodeFileName;
            this.streamFiles = streamFiles;
            this.accumulate = false;
            this.contentBuffer = [];
            this.dirRecords = [];
            this.currentSourceOffset = 0;
            this.entriesCount = 0;
            this.currentFile = null;
            this._sources = [];
          }
          utils.inherits(ZipFileWorker, GenericWorker);
          ZipFileWorker.prototype.push = function (chunk) {
            var currentFilePercent = chunk.meta.percent || 0;
            var entriesCount = this.entriesCount;
            var remainingFiles = this._sources.length;
            if (this.accumulate) {
              this.contentBuffer.push(chunk);
            } else {
              this.bytesWritten += chunk.data.length;
              GenericWorker.prototype.push.call(this, {
                data: chunk.data,
                meta: {
                  currentFile: this.currentFile,
                  percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
                }
              });
            }
          };
          ZipFileWorker.prototype.openedSource = function (streamInfo) {
            this.currentSourceOffset = this.bytesWritten;
            this.currentFile = streamInfo["file"].name;
            var streamedContent = this.streamFiles && !streamInfo["file"].dir;
            if (streamedContent) {
              var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({
                data: record.fileRecord,
                meta: {
                  percent: 0
                }
              });
            } else {
              this.accumulate = true;
            }
          };
          ZipFileWorker.prototype.closedSource = function (streamInfo) {
            this.accumulate = false;
            var streamedContent = this.streamFiles && !streamInfo["file"].dir;
            var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.dirRecords.push(record.dirRecord);
            if (streamedContent) {
              this.push({
                data: generateDataDescriptors(streamInfo),
                meta: {
                  percent: 100
                }
              });
            } else {
              this.push({
                data: record.fileRecord,
                meta: {
                  percent: 0
                }
              });
              while (this.contentBuffer.length) {
                this.push(this.contentBuffer.shift());
              }
            }
            this.currentFile = null;
          };
          ZipFileWorker.prototype.flush = function () {
            var localDirLength = this.bytesWritten;
            for (var i = 0; i < this.dirRecords.length; i++) {
              this.push({
                data: this.dirRecords[i],
                meta: {
                  percent: 100
                }
              });
            }
            var centralDirLength = this.bytesWritten - localDirLength;
            var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
            this.push({
              data: dirEnd,
              meta: {
                percent: 100
              }
            });
          };
          ZipFileWorker.prototype.prepareNextSource = function () {
            this.previous = this._sources.shift();
            this.openedSource(this.previous.streamInfo);
            if (this.isPaused) {
              this.previous.pause();
            } else {
              this.previous.resume();
            }
          };
          ZipFileWorker.prototype.registerPrevious = function (previous) {
            this._sources.push(previous);
            var self = this;
            previous.on("data", function (chunk) {
              self.processChunk(chunk);
            });
            previous.on("end", function () {
              self.closedSource(self.previous.streamInfo);
              if (self._sources.length) {
                self.prepareNextSource();
              } else {
                self.end();
              }
            });
            previous.on("error", function (e) {
              self.error(e);
            });
            return this;
          };
          ZipFileWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (!this.previous && this._sources.length) {
              this.prepareNextSource();
              return true;
            }
            if (!this.previous && !this._sources.length && !this.generatedError) {
              this.end();
              return true;
            }
          };
          ZipFileWorker.prototype.error = function (e) {
            var sources = this._sources;
            if (!GenericWorker.prototype.error.call(this, e)) {
              return false;
            }
            for (var i = 0; i < sources.length; i++) {
              try {
                sources[i].error(e);
              } catch (e) {}
            }
            return true;
          };
          ZipFileWorker.prototype.lock = function () {
            GenericWorker.prototype.lock.call(this);
            var sources = this._sources;
            for (var i = 0; i < sources.length; i++) {
              sources[i].lock();
            }
          };
          module.exports = ZipFileWorker;
        }, {
          "../crc32": 4,
          "../signature": 23,
          "../stream/GenericWorker": 28,
          "../utf8": 31,
          "../utils": 32
        }],
        9: [function (require, module, exports) {
          var compressions = require("../compressions");
          var ZipFileWorker = require("./ZipFileWorker");
          var getCompression = function (fileCompression, zipCompression) {
            var compressionName = fileCompression || zipCompression;
            var compression = compressions[compressionName];
            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !");
            }
            return compression;
          };
          exports.generateWorker = function (zip, options, comment) {
            var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
            var entriesCount = 0;
            try {
              zip.forEach(function (relativePath, file) {
                entriesCount++;
                var compression = getCompression(file.options.compression, options.compression);
                var compressionOptions = file.options.compressionOptions || options.compressionOptions || ({});
                var dir = file.dir, date = file.date;
                file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                  name: relativePath,
                  dir: dir,
                  date: date,
                  comment: file.comment || "",
                  unixPermissions: file.unixPermissions,
                  dosPermissions: file.dosPermissions
                }).pipe(zipFileWorker);
              });
              zipFileWorker.entriesCount = entriesCount;
            } catch (e) {
              zipFileWorker.error(e);
            }
            return zipFileWorker;
          };
        }, {
          "../compressions": 3,
          "./ZipFileWorker": 8
        }],
        10: [function (require, module, exports) {
          function JSZip() {
            if (!(this instanceof JSZip)) {
              return new JSZip();
            }
            if (arguments.length) {
              throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            }
            this.files = {};
            this.comment = null;
            this.root = "";
            this.clone = function () {
              var newObj = new JSZip();
              for (var i in this) {
                if (typeof this[i] !== "function") {
                  newObj[i] = this[i];
                }
              }
              return newObj;
            };
          }
          JSZip.prototype = require("./object");
          JSZip.prototype.loadAsync = require("./load");
          JSZip.support = require("./support");
          JSZip.defaults = require("./defaults");
          JSZip.version = "3.5.0";
          JSZip.loadAsync = function (content, options) {
            return new JSZip().loadAsync(content, options);
          };
          JSZip.external = require("./external");
          module.exports = JSZip;
        }, {
          "./defaults": 5,
          "./external": 6,
          "./load": 11,
          "./object": 15,
          "./support": 30
        }],
        11: [function (require, module, exports) {
          var utils = require("./utils");
          var external = require("./external");
          var utf8 = require("./utf8");
          var utils = require("./utils");
          var ZipEntries = require("./zipEntries");
          var Crc32Probe = require("./stream/Crc32Probe");
          var nodejsUtils = require("./nodejsUtils");
          function checkEntryCRC32(zipEntry) {
            return new external.Promise(function (resolve, reject) {
              var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
              worker.on("error", function (e) {
                reject(e);
              }).on("end", function () {
                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                  reject(new Error("Corrupted zip : CRC32 mismatch"));
                } else {
                  resolve();
                }
              }).resume();
            });
          }
          module.exports = function (data, options) {
            var zip = this;
            options = utils.extend(options || ({}), {
              base64: false,
              checkCRC32: false,
              optimizedBinaryString: false,
              createFolders: false,
              decodeFileName: utf8.utf8decode
            });
            if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
            }
            return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
              var zipEntries = new ZipEntries(options);
              zipEntries.load(data);
              return zipEntries;
            }).then(function checkCRC32(zipEntries) {
              var promises = [external.Promise.resolve(zipEntries)];
              var files = zipEntries.files;
              if (options.checkCRC32) {
                for (var i = 0; i < files.length; i++) {
                  promises.push(checkEntryCRC32(files[i]));
                }
              }
              return external.Promise.all(promises);
            }).then(function addFiles(results) {
              var zipEntries = results.shift();
              var files = zipEntries.files;
              for (var i = 0; i < files.length; i++) {
                var input = files[i];
                zip.file(input.fileNameStr, input.decompressed, {
                  binary: true,
                  optimizedBinaryString: true,
                  date: input.date,
                  dir: input.dir,
                  comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                  unixPermissions: input.unixPermissions,
                  dosPermissions: input.dosPermissions,
                  createFolders: options.createFolders
                });
              }
              if (zipEntries.zipComment.length) {
                zip.comment = zipEntries.zipComment;
              }
              return zip;
            });
          };
        }, {
          "./external": 6,
          "./nodejsUtils": 14,
          "./stream/Crc32Probe": 25,
          "./utf8": 31,
          "./utils": 32,
          "./zipEntries": 33
        }],
        12: [function (require, module, exports) {
          var utils = require("../utils");
          var GenericWorker = require("../stream/GenericWorker");
          function NodejsStreamInputAdapter(filename, stream) {
            GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
            this._upstreamEnded = false;
            this._bindStream(stream);
          }
          utils.inherits(NodejsStreamInputAdapter, GenericWorker);
          NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
            var self = this;
            this._stream = stream;
            stream.pause();
            stream.on("data", function (chunk) {
              self.push({
                data: chunk,
                meta: {
                  percent: 0
                }
              });
            }).on("error", function (e) {
              if (self.isPaused) {
                this.generatedError = e;
              } else {
                self.error(e);
              }
            }).on("end", function () {
              if (self.isPaused) {
                self._upstreamEnded = true;
              } else {
                self.end();
              }
            });
          };
          NodejsStreamInputAdapter.prototype.pause = function () {
            if (!GenericWorker.prototype.pause.call(this)) {
              return false;
            }
            this._stream.pause();
            return true;
          };
          NodejsStreamInputAdapter.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (this._upstreamEnded) {
              this.end();
            } else {
              this._stream.resume();
            }
            return true;
          };
          module.exports = NodejsStreamInputAdapter;
        }, {
          "../stream/GenericWorker": 28,
          "../utils": 32
        }],
        13: [function (require, module, exports) {
          var Readable = require("readable-stream").Readable;
          var utils = require("../utils");
          utils.inherits(NodejsStreamOutputAdapter, Readable);
          function NodejsStreamOutputAdapter(helper, options, updateCb) {
            Readable.call(this, options);
            this._helper = helper;
            var self = this;
            helper.on("data", function (data, meta) {
              if (!self.push(data)) {
                self._helper.pause();
              }
              if (updateCb) {
                updateCb(meta);
              }
            }).on("error", function (e) {
              self.emit("error", e);
            }).on("end", function () {
              self.push(null);
            });
          }
          NodejsStreamOutputAdapter.prototype._read = function () {
            this._helper.resume();
          };
          module.exports = NodejsStreamOutputAdapter;
        }, {
          "../utils": 32,
          "readable-stream": 16
        }],
        14: [function (require, module, exports) {
          module.exports = {
            isNode: typeof Buffer !== "undefined",
            newBufferFrom: function (data, encoding) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) {
                return Buffer.from(data, encoding);
              } else {
                if (typeof data === "number") {
                  throw new Error("The \"data\" argument must not be a number");
                }
                return new Buffer(data, encoding);
              }
            },
            allocBuffer: function (size) {
              if (Buffer.alloc) {
                return Buffer.alloc(size);
              } else {
                var buf = new Buffer(size);
                buf.fill(0);
                return buf;
              }
            },
            isBuffer: function (b) {
              return Buffer.isBuffer(b);
            },
            isStream: function (obj) {
              return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
            }
          };
        }, {}],
        15: [function (require, module, exports) {
          var utf8 = require("./utf8");
          var utils = require("./utils");
          var GenericWorker = require("./stream/GenericWorker");
          var StreamHelper = require("./stream/StreamHelper");
          var defaults = require("./defaults");
          var CompressedObject = require("./compressedObject");
          var ZipObject = require("./zipObject");
          var generate = require("./generate");
          var nodejsUtils = require("./nodejsUtils");
          var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");
          var fileAdd = function (name, data, originalOptions) {
            var dataType = utils.getTypeOf(data), parent;
            var o = utils.extend(originalOptions || ({}), defaults);
            o.date = o.date || new Date();
            if (o.compression !== null) {
              o.compression = o.compression.toUpperCase();
            }
            if (typeof o.unixPermissions === "string") {
              o.unixPermissions = parseInt(o.unixPermissions, 8);
            }
            if (o.unixPermissions && o.unixPermissions & 16384) {
              o.dir = true;
            }
            if (o.dosPermissions && o.dosPermissions & 16) {
              o.dir = true;
            }
            if (o.dir) {
              name = forceTrailingSlash(name);
            }
            if (o.createFolders && (parent = parentFolder(name))) {
              folderAdd.call(this, parent, true);
            }
            var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
            if (!originalOptions || typeof originalOptions.binary === "undefined") {
              o.binary = !isUnicodeString;
            }
            var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
            if (isCompressedEmpty || o.dir || !data || data.length === 0) {
              o.base64 = false;
              o.binary = true;
              data = "";
              o.compression = "STORE";
              dataType = "string";
            }
            var zipObjectContent = null;
            if (data instanceof CompressedObject || data instanceof GenericWorker) {
              zipObjectContent = data;
            } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              zipObjectContent = new NodejsStreamInputAdapter(name, data);
            } else {
              zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
            }
            var object = new ZipObject(name, zipObjectContent, o);
            this.files[name] = object;
          };
          var parentFolder = function (path) {
            if (path.slice(-1) === "/") {
              path = path.substring(0, path.length - 1);
            }
            var lastSlash = path.lastIndexOf("/");
            return lastSlash > 0 ? path.substring(0, lastSlash) : "";
          };
          var forceTrailingSlash = function (path) {
            if (path.slice(-1) !== "/") {
              path += "/";
            }
            return path;
          };
          var folderAdd = function (name, createFolders) {
            createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
            name = forceTrailingSlash(name);
            if (!this.files[name]) {
              fileAdd.call(this, name, null, {
                dir: true,
                createFolders: createFolders
              });
            }
            return this.files[name];
          };
          function isRegExp(object) {
            return Object.prototype.toString.call(object) === "[object RegExp]";
          }
          var out = {
            load: function () {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },
            forEach: function (cb) {
              var filename, relativePath, file;
              for (filename in this.files) {
                if (!this.files.hasOwnProperty(filename)) {
                  continue;
                }
                file = this.files[filename];
                relativePath = filename.slice(this.root.length, filename.length);
                if (relativePath && filename.slice(0, this.root.length) === this.root) {
                  cb(relativePath, file);
                }
              }
            },
            filter: function (search) {
              var result = [];
              this.forEach(function (relativePath, entry) {
                if (search(relativePath, entry)) {
                  result.push(entry);
                }
              });
              return result;
            },
            file: function (name, data, o) {
              if (arguments.length === 1) {
                if (isRegExp(name)) {
                  var regexp = name;
                  return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                  });
                } else {
                  var obj = this.files[this.root + name];
                  if (obj && !obj.dir) {
                    return obj;
                  } else {
                    return null;
                  }
                }
              } else {
                name = this.root + name;
                fileAdd.call(this, name, data, o);
              }
              return this;
            },
            folder: function (arg) {
              if (!arg) {
                return this;
              }
              if (isRegExp(arg)) {
                return this.filter(function (relativePath, file) {
                  return file.dir && arg.test(relativePath);
                });
              }
              var name = this.root + arg;
              var newFolder = folderAdd.call(this, name);
              var ret = this.clone();
              ret.root = newFolder.name;
              return ret;
            },
            remove: function (name) {
              name = this.root + name;
              var file = this.files[name];
              if (!file) {
                if (name.slice(-1) !== "/") {
                  name += "/";
                }
                file = this.files[name];
              }
              if (file && !file.dir) {
                delete this.files[name];
              } else {
                var kids = this.filter(function (relativePath, file) {
                  return file.name.slice(0, name.length) === name;
                });
                for (var i = 0; i < kids.length; i++) {
                  delete this.files[kids[i].name];
                }
              }
              return this;
            },
            generate: function (options) {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },
            generateInternalStream: function (options) {
              var worker, opts = {};
              try {
                opts = utils.extend(options || ({}), {
                  streamFiles: false,
                  compression: "STORE",
                  compressionOptions: null,
                  type: "",
                  platform: "DOS",
                  comment: null,
                  mimeType: "application/zip",
                  encodeFileName: utf8.utf8encode
                });
                opts.type = opts.type.toLowerCase();
                opts.compression = opts.compression.toUpperCase();
                if (opts.type === "binarystring") {
                  opts.type = "string";
                }
                if (!opts.type) {
                  throw new Error("No output type specified.");
                }
                utils.checkSupport(opts.type);
                if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
                  opts.platform = "UNIX";
                }
                if (opts.platform === "win32") {
                  opts.platform = "DOS";
                }
                var comment = opts.comment || this.comment || "";
                worker = generate.generateWorker(this, opts, comment);
              } catch (e) {
                worker = new GenericWorker("error");
                worker.error(e);
              }
              return new StreamHelper(worker, opts.type || "string", opts.mimeType);
            },
            generateAsync: function (options, onUpdate) {
              return this.generateInternalStream(options).accumulate(onUpdate);
            },
            generateNodeStream: function (options, onUpdate) {
              options = options || ({});
              if (!options.type) {
                options.type = "nodebuffer";
              }
              return this.generateInternalStream(options).toNodejsStream(onUpdate);
            }
          };
          module.exports = out;
        }, {
          "./compressedObject": 2,
          "./defaults": 5,
          "./generate": 9,
          "./nodejs/NodejsStreamInputAdapter": 12,
          "./nodejsUtils": 14,
          "./stream/GenericWorker": 28,
          "./stream/StreamHelper": 29,
          "./utf8": 31,
          "./utils": 32,
          "./zipObject": 35
        }],
        16: [function (require, module, exports) {
          module.exports = require("stream");
        }, {
          "stream": undefined
        }],
        17: [function (require, module, exports) {
          var DataReader = require("./DataReader");
          var utils = require("../utils");
          function ArrayReader(data) {
            DataReader.call(this, data);
            for (var i = 0; i < this.data.length; i++) {
              data[i] = data[i] & 255;
            }
          }
          utils.inherits(ArrayReader, DataReader);
          ArrayReader.prototype.byteAt = function (i) {
            return this.data[this.zero + i];
          };
          ArrayReader.prototype.lastIndexOfSignature = function (sig) {
            var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
            for (var i = this.length - 4; i >= 0; --i) {
              if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
                return i - this.zero;
              }
            }
            return -1;
          };
          ArrayReader.prototype.readAndCheckSignature = function (sig) {
            var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
            return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
          };
          ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size);
            if (size === 0) {
              return [];
            }
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };
          module.exports = ArrayReader;
        }, {
          "../utils": 32,
          "./DataReader": 18
        }],
        18: [function (require, module, exports) {
          var utils = require("../utils");
          function DataReader(data) {
            this.data = data;
            this.length = data.length;
            this.index = 0;
            this.zero = 0;
          }
          DataReader.prototype = {
            checkOffset: function (offset) {
              this.checkIndex(this.index + offset);
            },
            checkIndex: function (newIndex) {
              if (this.length < this.zero + newIndex || newIndex < 0) {
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
              }
            },
            setIndex: function (newIndex) {
              this.checkIndex(newIndex);
              this.index = newIndex;
            },
            skip: function (n) {
              this.setIndex(this.index + n);
            },
            byteAt: function (i) {},
            readInt: function (size) {
              var result = 0, i;
              this.checkOffset(size);
              for (i = this.index + size - 1; i >= this.index; i--) {
                result = (result << 8) + this.byteAt(i);
              }
              this.index += size;
              return result;
            },
            readString: function (size) {
              return utils.transformTo("string", this.readData(size));
            },
            readData: function (size) {},
            lastIndexOfSignature: function (sig) {},
            readAndCheckSignature: function (sig) {},
            readDate: function () {
              var dostime = this.readInt(4);
              return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1));
            }
          };
          module.exports = DataReader;
        }, {
          "../utils": 32
        }],
        19: [function (require, module, exports) {
          var Uint8ArrayReader = require("./Uint8ArrayReader");
          var utils = require("../utils");
          function NodeBufferReader(data) {
            Uint8ArrayReader.call(this, data);
          }
          utils.inherits(NodeBufferReader, Uint8ArrayReader);
          NodeBufferReader.prototype.readData = function (size) {
            this.checkOffset(size);
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };
          module.exports = NodeBufferReader;
        }, {
          "../utils": 32,
          "./Uint8ArrayReader": 21
        }],
        20: [function (require, module, exports) {
          var DataReader = require("./DataReader");
          var utils = require("../utils");
          function StringReader(data) {
            DataReader.call(this, data);
          }
          utils.inherits(StringReader, DataReader);
          StringReader.prototype.byteAt = function (i) {
            return this.data.charCodeAt(this.zero + i);
          };
          StringReader.prototype.lastIndexOfSignature = function (sig) {
            return this.data.lastIndexOf(sig) - this.zero;
          };
          StringReader.prototype.readAndCheckSignature = function (sig) {
            var data = this.readData(4);
            return sig === data;
          };
          StringReader.prototype.readData = function (size) {
            this.checkOffset(size);
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };
          module.exports = StringReader;
        }, {
          "../utils": 32,
          "./DataReader": 18
        }],
        21: [function (require, module, exports) {
          var ArrayReader = require("./ArrayReader");
          var utils = require("../utils");
          function Uint8ArrayReader(data) {
            ArrayReader.call(this, data);
          }
          utils.inherits(Uint8ArrayReader, ArrayReader);
          Uint8ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size);
            if (size === 0) {
              return new Uint8Array(0);
            }
            var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };
          module.exports = Uint8ArrayReader;
        }, {
          "../utils": 32,
          "./ArrayReader": 17
        }],
        22: [function (require, module, exports) {
          var utils = require("../utils");
          var support = require("../support");
          var ArrayReader = require("./ArrayReader");
          var StringReader = require("./StringReader");
          var NodeBufferReader = require("./NodeBufferReader");
          var Uint8ArrayReader = require("./Uint8ArrayReader");
          module.exports = function (data) {
            var type = utils.getTypeOf(data);
            utils.checkSupport(type);
            if (type === "string" && !support.uint8array) {
              return new StringReader(data);
            }
            if (type === "nodebuffer") {
              return new NodeBufferReader(data);
            }
            if (support.uint8array) {
              return new Uint8ArrayReader(utils.transformTo("uint8array", data));
            }
            return new ArrayReader(utils.transformTo("array", data));
          };
        }, {
          "../support": 30,
          "../utils": 32,
          "./ArrayReader": 17,
          "./NodeBufferReader": 19,
          "./StringReader": 20,
          "./Uint8ArrayReader": 21
        }],
        23: [function (require, module, exports) {
          exports.LOCAL_FILE_HEADER = "PK\u0003\u0004";
          exports.CENTRAL_FILE_HEADER = "PK\u0001\u0002";
          exports.CENTRAL_DIRECTORY_END = "PK\u0005\u0006";
          exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\u0006\u0007";
          exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\u0006\u0006";
          exports.DATA_DESCRIPTOR = "PK\u0007\b";
        }, {}],
        24: [function (require, module, exports) {
          var GenericWorker = require("./GenericWorker");
          var utils = require("../utils");
          function ConvertWorker(destType) {
            GenericWorker.call(this, "ConvertWorker to " + destType);
            this.destType = destType;
          }
          utils.inherits(ConvertWorker, GenericWorker);
          ConvertWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: utils.transformTo(this.destType, chunk.data),
              meta: chunk.meta
            });
          };
          module.exports = ConvertWorker;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        25: [function (require, module, exports) {
          var GenericWorker = require("./GenericWorker");
          var crc32 = require("../crc32");
          var utils = require("../utils");
          function Crc32Probe() {
            GenericWorker.call(this, "Crc32Probe");
            this.withStreamInfo("crc32", 0);
          }
          utils.inherits(Crc32Probe, GenericWorker);
          Crc32Probe.prototype.processChunk = function (chunk) {
            this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
            this.push(chunk);
          };
          module.exports = Crc32Probe;
        }, {
          "../crc32": 4,
          "../utils": 32,
          "./GenericWorker": 28
        }],
        26: [function (require, module, exports) {
          var utils = require("../utils");
          var GenericWorker = require("./GenericWorker");
          function DataLengthProbe(propName) {
            GenericWorker.call(this, "DataLengthProbe for " + propName);
            this.propName = propName;
            this.withStreamInfo(propName, 0);
          }
          utils.inherits(DataLengthProbe, GenericWorker);
          DataLengthProbe.prototype.processChunk = function (chunk) {
            if (chunk) {
              var length = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = length + chunk.data.length;
            }
            GenericWorker.prototype.processChunk.call(this, chunk);
          };
          module.exports = DataLengthProbe;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        27: [function (require, module, exports) {
          var utils = require("../utils");
          var GenericWorker = require("./GenericWorker");
          var DEFAULT_BLOCK_SIZE = 16 * 1024;
          function DataWorker(dataP) {
            GenericWorker.call(this, "DataWorker");
            var self = this;
            this.dataIsReady = false;
            this.index = 0;
            this.max = 0;
            this.data = null;
            this.type = "";
            this._tickScheduled = false;
            dataP.then(function (data) {
              self.dataIsReady = true;
              self.data = data;
              self.max = data && data.length || 0;
              self.type = utils.getTypeOf(data);
              if (!self.isPaused) {
                self._tickAndRepeat();
              }
            }, function (e) {
              self.error(e);
            });
          }
          utils.inherits(DataWorker, GenericWorker);
          DataWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this);
            this.data = null;
          };
          DataWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }
            if (!this._tickScheduled && this.dataIsReady) {
              this._tickScheduled = true;
              utils.delay(this._tickAndRepeat, [], this);
            }
            return true;
          };
          DataWorker.prototype._tickAndRepeat = function () {
            this._tickScheduled = false;
            if (this.isPaused || this.isFinished) {
              return;
            }
            this._tick();
            if (!this.isFinished) {
              utils.delay(this._tickAndRepeat, [], this);
              this._tickScheduled = true;
            }
          };
          DataWorker.prototype._tick = function () {
            if (this.isPaused || this.isFinished) {
              return false;
            }
            var size = DEFAULT_BLOCK_SIZE;
            var data = null, nextIndex = Math.min(this.max, this.index + size);
            if (this.index >= this.max) {
              return this.end();
            } else {
              switch (this.type) {
                case "string":
                  data = this.data.substring(this.index, nextIndex);
                  break;
                case "uint8array":
                  data = this.data.subarray(this.index, nextIndex);
                  break;
                case "array":
                case "nodebuffer":
                  data = this.data.slice(this.index, nextIndex);
                  break;
              }
              this.index = nextIndex;
              return this.push({
                data: data,
                meta: {
                  percent: this.max ? this.index / this.max * 100 : 0
                }
              });
            }
          };
          module.exports = DataWorker;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        28: [function (require, module, exports) {
          function GenericWorker(name) {
            this.name = name || "default";
            this.streamInfo = {};
            this.generatedError = null;
            this.extraStreamInfo = {};
            this.isPaused = true;
            this.isFinished = false;
            this.isLocked = false;
            this._listeners = {
              "data": [],
              "end": [],
              "error": []
            };
            this.previous = null;
          }
          GenericWorker.prototype = {
            push: function (chunk) {
              this.emit("data", chunk);
            },
            end: function () {
              if (this.isFinished) {
                return false;
              }
              this.flush();
              try {
                this.emit("end");
                this.cleanUp();
                this.isFinished = true;
              } catch (e) {
                this.emit("error", e);
              }
              return true;
            },
            error: function (e) {
              if (this.isFinished) {
                return false;
              }
              if (this.isPaused) {
                this.generatedError = e;
              } else {
                this.isFinished = true;
                this.emit("error", e);
                if (this.previous) {
                  this.previous.error(e);
                }
                this.cleanUp();
              }
              return true;
            },
            on: function (name, listener) {
              this._listeners[name].push(listener);
              return this;
            },
            cleanUp: function () {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null;
              this._listeners = [];
            },
            emit: function (name, arg) {
              if (this._listeners[name]) {
                for (var i = 0; i < this._listeners[name].length; i++) {
                  this._listeners[name][i].call(this, arg);
                }
              }
            },
            pipe: function (next) {
              return next.registerPrevious(this);
            },
            registerPrevious: function (previous) {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              }
              this.streamInfo = previous.streamInfo;
              this.mergeStreamInfo();
              this.previous = previous;
              var self = this;
              previous.on("data", function (chunk) {
                self.processChunk(chunk);
              });
              previous.on("end", function () {
                self.end();
              });
              previous.on("error", function (e) {
                self.error(e);
              });
              return this;
            },
            pause: function () {
              if (this.isPaused || this.isFinished) {
                return false;
              }
              this.isPaused = true;
              if (this.previous) {
                this.previous.pause();
              }
              return true;
            },
            resume: function () {
              if (!this.isPaused || this.isFinished) {
                return false;
              }
              this.isPaused = false;
              var withError = false;
              if (this.generatedError) {
                this.error(this.generatedError);
                withError = true;
              }
              if (this.previous) {
                this.previous.resume();
              }
              return !withError;
            },
            flush: function () {},
            processChunk: function (chunk) {
              this.push(chunk);
            },
            withStreamInfo: function (key, value) {
              this.extraStreamInfo[key] = value;
              this.mergeStreamInfo();
              return this;
            },
            mergeStreamInfo: function () {
              for (var key in this.extraStreamInfo) {
                if (!this.extraStreamInfo.hasOwnProperty(key)) {
                  continue;
                }
                this.streamInfo[key] = this.extraStreamInfo[key];
              }
            },
            lock: function () {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              }
              this.isLocked = true;
              if (this.previous) {
                this.previous.lock();
              }
            },
            toString: function () {
              var me = "Worker " + this.name;
              if (this.previous) {
                return this.previous + " -> " + me;
              } else {
                return me;
              }
            }
          };
          module.exports = GenericWorker;
        }, {}],
        29: [function (require, module, exports) {
          var utils = require("../utils");
          var ConvertWorker = require("./ConvertWorker");
          var GenericWorker = require("./GenericWorker");
          var base64 = require("../base64");
          var support = require("../support");
          var external = require("../external");
          var NodejsStreamOutputAdapter = null;
          if (support.nodestream) {
            try {
              NodejsStreamOutputAdapter = require("../nodejs/NodejsStreamOutputAdapter");
            } catch (e) {}
          }
          function transformZipOutput(type, content, mimeType) {
            switch (type) {
              case "blob":
                return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
              case "base64":
                return base64.encode(content);
              default:
                return utils.transformTo(type, content);
            }
          }
          function concat(type, dataArray) {
            var i, index = 0, res = null, totalLength = 0;
            for (i = 0; i < dataArray.length; i++) {
              totalLength += dataArray[i].length;
            }
            switch (type) {
              case "string":
                return dataArray.join("");
              case "array":
                return Array.prototype.concat.apply([], dataArray);
              case "uint8array":
                res = new Uint8Array(totalLength);
                for (i = 0; i < dataArray.length; i++) {
                  res.set(dataArray[i], index);
                  index += dataArray[i].length;
                }
                return res;
              case "nodebuffer":
                return Buffer.concat(dataArray);
              default:
                throw new Error("concat : unsupported type '" + type + "'");
            }
          }
          function accumulate(helper, updateCallback) {
            return new external.Promise(function (resolve, reject) {
              var dataArray = [];
              var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
              helper.on("data", function (data, meta) {
                dataArray.push(data);
                if (updateCallback) {
                  updateCallback(meta);
                }
              }).on("error", function (err) {
                dataArray = [];
                reject(err);
              }).on("end", function () {
                try {
                  var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                  resolve(result);
                } catch (e) {
                  reject(e);
                }
                dataArray = [];
              }).resume();
            });
          }
          function StreamHelper(worker, outputType, mimeType) {
            var internalType = outputType;
            switch (outputType) {
              case "blob":
              case "arraybuffer":
                internalType = "uint8array";
                break;
              case "base64":
                internalType = "string";
                break;
            }
            try {
              this._internalType = internalType;
              this._outputType = outputType;
              this._mimeType = mimeType;
              utils.checkSupport(internalType);
              this._worker = worker.pipe(new ConvertWorker(internalType));
              worker.lock();
            } catch (e) {
              this._worker = new GenericWorker("error");
              this._worker.error(e);
            }
          }
          StreamHelper.prototype = {
            accumulate: function (updateCb) {
              return accumulate(this, updateCb);
            },
            on: function (evt, fn) {
              var self = this;
              if (evt === "data") {
                this._worker.on(evt, function (chunk) {
                  fn.call(self, chunk.data, chunk.meta);
                });
              } else {
                this._worker.on(evt, function () {
                  utils.delay(fn, arguments, self);
                });
              }
              return this;
            },
            resume: function () {
              utils.delay(this._worker.resume, [], this._worker);
              return this;
            },
            pause: function () {
              this._worker.pause();
              return this;
            },
            toNodejsStream: function (updateCb) {
              utils.checkSupport("nodestream");
              if (this._outputType !== "nodebuffer") {
                throw new Error(this._outputType + " is not supported by this method");
              }
              return new NodejsStreamOutputAdapter(this, {
                objectMode: this._outputType !== "nodebuffer"
              }, updateCb);
            }
          };
          module.exports = StreamHelper;
        }, {
          "../base64": 1,
          "../external": 6,
          "../nodejs/NodejsStreamOutputAdapter": 13,
          "../support": 30,
          "../utils": 32,
          "./ConvertWorker": 24,
          "./GenericWorker": 28
        }],
        30: [function (require, module, exports) {
          exports.base64 = true;
          exports.array = true;
          exports.string = true;
          exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
          exports.nodebuffer = typeof Buffer !== "undefined";
          exports.uint8array = typeof Uint8Array !== "undefined";
          if (typeof ArrayBuffer === "undefined") {
            exports.blob = false;
          } else {
            var buffer = new ArrayBuffer(0);
            try {
              exports.blob = new Blob([buffer], {
                type: "application/zip"
              }).size === 0;
            } catch (e) {
              try {
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(buffer);
                exports.blob = builder.getBlob("application/zip").size === 0;
              } catch (e) {
                exports.blob = false;
              }
            }
          }
          try {
            exports.nodestream = !!require("readable-stream").Readable;
          } catch (e) {
            exports.nodestream = false;
          }
        }, {
          "readable-stream": 16
        }],
        31: [function (require, module, exports) {
          var utils = require("./utils");
          var support = require("./support");
          var nodejsUtils = require("./nodejsUtils");
          var GenericWorker = require("./stream/GenericWorker");
          var _utf8len = new Array(256);
          for (var i = 0; i < 256; i++) {
            _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
          }
          _utf8len[254] = _utf8len[254] = 1;
          var string2buf = function (str) {
            var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
            }
            if (support.uint8array) {
              buf = new Uint8Array(buf_len);
            } else {
              buf = new Array(buf_len);
            }
            for ((i = 0, m_pos = 0); i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              if (c < 128) {
                buf[i++] = c;
              } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
              } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              }
            }
            return buf;
          };
          var utf8border = function (buf, max) {
            var pos;
            max = max || buf.length;
            if (max > buf.length) {
              max = buf.length;
            }
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 192) === 128) {
              pos--;
            }
            if (pos < 0) {
              return max;
            }
            if (pos === 0) {
              return max;
            }
            return pos + _utf8len[buf[pos]] > max ? pos : max;
          };
          var buf2string = function (buf) {
            var i, out, c, c_len;
            var len = buf.length;
            var utf16buf = new Array(len * 2);
            for ((out = 0, i = 0); i < len; ) {
              c = buf[i++];
              if (c < 128) {
                utf16buf[out++] = c;
                continue;
              }
              c_len = _utf8len[c];
              if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
              }
              c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
              while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 63;
                c_len--;
              }
              if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
              }
              if (c < 65536) {
                utf16buf[out++] = c;
              } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
              }
            }
            if (utf16buf.length !== out) {
              if (utf16buf.subarray) {
                utf16buf = utf16buf.subarray(0, out);
              } else {
                utf16buf.length = out;
              }
            }
            return utils.applyFromCharCode(utf16buf);
          };
          exports.utf8encode = function utf8encode(str) {
            if (support.nodebuffer) {
              return nodejsUtils.newBufferFrom(str, "utf-8");
            }
            return string2buf(str);
          };
          exports.utf8decode = function utf8decode(buf) {
            if (support.nodebuffer) {
              return utils.transformTo("nodebuffer", buf).toString("utf-8");
            }
            buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
            return buf2string(buf);
          };
          function Utf8DecodeWorker() {
            GenericWorker.call(this, "utf-8 decode");
            this.leftOver = null;
          }
          utils.inherits(Utf8DecodeWorker, GenericWorker);
          Utf8DecodeWorker.prototype.processChunk = function (chunk) {
            var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
            if (this.leftOver && this.leftOver.length) {
              if (support.uint8array) {
                var previousData = data;
                data = new Uint8Array(previousData.length + this.leftOver.length);
                data.set(this.leftOver, 0);
                data.set(previousData, this.leftOver.length);
              } else {
                data = this.leftOver.concat(data);
              }
              this.leftOver = null;
            }
            var nextBoundary = utf8border(data);
            var usableData = data;
            if (nextBoundary !== data.length) {
              if (support.uint8array) {
                usableData = data.subarray(0, nextBoundary);
                this.leftOver = data.subarray(nextBoundary, data.length);
              } else {
                usableData = data.slice(0, nextBoundary);
                this.leftOver = data.slice(nextBoundary, data.length);
              }
            }
            this.push({
              data: exports.utf8decode(usableData),
              meta: chunk.meta
            });
          };
          Utf8DecodeWorker.prototype.flush = function () {
            if (this.leftOver && this.leftOver.length) {
              this.push({
                data: exports.utf8decode(this.leftOver),
                meta: {}
              });
              this.leftOver = null;
            }
          };
          exports.Utf8DecodeWorker = Utf8DecodeWorker;
          function Utf8EncodeWorker() {
            GenericWorker.call(this, "utf-8 encode");
          }
          utils.inherits(Utf8EncodeWorker, GenericWorker);
          Utf8EncodeWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: exports.utf8encode(chunk.data),
              meta: chunk.meta
            });
          };
          exports.Utf8EncodeWorker = Utf8EncodeWorker;
        }, {
          "./nodejsUtils": 14,
          "./stream/GenericWorker": 28,
          "./support": 30,
          "./utils": 32
        }],
        32: [function (require, module, exports) {
          var support = require("./support");
          var base64 = require("./base64");
          var nodejsUtils = require("./nodejsUtils");
          var setImmediate = require("set-immediate-shim");
          var external = require("./external");
          function string2binary(str) {
            var result = null;
            if (support.uint8array) {
              result = new Uint8Array(str.length);
            } else {
              result = new Array(str.length);
            }
            return stringToArrayLike(str, result);
          }
          exports.newBlob = function (part, type) {
            exports.checkSupport("blob");
            try {
              return new Blob([part], {
                type: type
              });
            } catch (e) {
              try {
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(part);
                return builder.getBlob(type);
              } catch (e) {
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          function identity(input) {
            return input;
          }
          function stringToArrayLike(str, array) {
            for (var i = 0; i < str.length; ++i) {
              array[i] = str.charCodeAt(i) & 255;
            }
            return array;
          }
          var arrayToStringHelper = {
            stringifyByChunk: function (array, type, chunk) {
              var result = [], k = 0, len = array.length;
              if (len <= chunk) {
                return String.fromCharCode.apply(null, array);
              }
              while (k < len) {
                if (type === "array" || type === "nodebuffer") {
                  result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
                } else {
                  result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
                }
                k += chunk;
              }
              return result.join("");
            },
            stringifyByChar: function (array) {
              var resultStr = "";
              for (var i = 0; i < array.length; i++) {
                resultStr += String.fromCharCode(array[i]);
              }
              return resultStr;
            },
            applyCanBeUsed: {
              uint8array: (function () {
                try {
                  return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                } catch (e) {
                  return false;
                }
              })(),
              nodebuffer: (function () {
                try {
                  return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
                } catch (e) {
                  return false;
                }
              })()
            }
          };
          function arrayLikeToString(array) {
            var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
            if (type === "uint8array") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
            } else if (type === "nodebuffer") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
            }
            if (canUseApply) {
              while (chunk > 1) {
                try {
                  return arrayToStringHelper.stringifyByChunk(array, type, chunk);
                } catch (e) {
                  chunk = Math.floor(chunk / 2);
                }
              }
            }
            return arrayToStringHelper.stringifyByChar(array);
          }
          exports.applyFromCharCode = arrayLikeToString;
          function arrayLikeToArrayLike(arrayFrom, arrayTo) {
            for (var i = 0; i < arrayFrom.length; i++) {
              arrayTo[i] = arrayFrom[i];
            }
            return arrayTo;
          }
          var transform = {};
          transform["string"] = {
            "string": identity,
            "array": function (input) {
              return stringToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function (input) {
              return transform["string"]["uint8array"](input).buffer;
            },
            "uint8array": function (input) {
              return stringToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": function (input) {
              return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
            }
          };
          transform["array"] = {
            "string": arrayLikeToString,
            "array": identity,
            "arraybuffer": function (input) {
              return new Uint8Array(input).buffer;
            },
            "uint8array": function (input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function (input) {
              return nodejsUtils.newBufferFrom(input);
            }
          };
          transform["arraybuffer"] = {
            "string": function (input) {
              return arrayLikeToString(new Uint8Array(input));
            },
            "array": function (input) {
              return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
            },
            "arraybuffer": identity,
            "uint8array": function (input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function (input) {
              return nodejsUtils.newBufferFrom(new Uint8Array(input));
            }
          };
          transform["uint8array"] = {
            "string": arrayLikeToString,
            "array": function (input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function (input) {
              return input.buffer;
            },
            "uint8array": identity,
            "nodebuffer": function (input) {
              return nodejsUtils.newBufferFrom(input);
            }
          };
          transform["nodebuffer"] = {
            "string": arrayLikeToString,
            "array": function (input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function (input) {
              return transform["nodebuffer"]["uint8array"](input).buffer;
            },
            "uint8array": function (input) {
              return arrayLikeToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": identity
          };
          exports.transformTo = function (outputType, input) {
            if (!input) {
              input = "";
            }
            if (!outputType) {
              return input;
            }
            exports.checkSupport(outputType);
            var inputType = exports.getTypeOf(input);
            var result = transform[inputType][outputType](input);
            return result;
          };
          exports.getTypeOf = function (input) {
            if (typeof input === "string") {
              return "string";
            }
            if (Object.prototype.toString.call(input) === "[object Array]") {
              return "array";
            }
            if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
              return "nodebuffer";
            }
            if (support.uint8array && input instanceof Uint8Array) {
              return "uint8array";
            }
            if (support.arraybuffer && input instanceof ArrayBuffer) {
              return "arraybuffer";
            }
          };
          exports.checkSupport = function (type) {
            var supported = support[type.toLowerCase()];
            if (!supported) {
              throw new Error(type + " is not supported by this platform");
            }
          };
          exports.MAX_VALUE_16BITS = 65535;
          exports.MAX_VALUE_32BITS = -1;
          exports.pretty = function (str) {
            var res = "", code, i;
            for (i = 0; i < (str || "").length; i++) {
              code = str.charCodeAt(i);
              res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
            }
            return res;
          };
          exports.delay = function (callback, args, self) {
            setImmediate(function () {
              callback.apply(self || null, args || []);
            });
          };
          exports.inherits = function (ctor, superCtor) {
            var Obj = function () {};
            Obj.prototype = superCtor.prototype;
            ctor.prototype = new Obj();
          };
          exports.extend = function () {
            var result = {}, i, attr;
            for (i = 0; i < arguments.length; i++) {
              for (attr in arguments[i]) {
                if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                  result[attr] = arguments[i][attr];
                }
              }
            }
            return result;
          };
          exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
            var promise = external.Promise.resolve(inputData).then(function (data) {
              var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
              if (isBlob && typeof FileReader !== "undefined") {
                return new external.Promise(function (resolve, reject) {
                  var reader = new FileReader();
                  reader.onload = function (e) {
                    resolve(e.target.result);
                  };
                  reader.onerror = function (e) {
                    reject(e.target.error);
                  };
                  reader.readAsArrayBuffer(data);
                });
              } else {
                return data;
              }
            });
            return promise.then(function (data) {
              var dataType = exports.getTypeOf(data);
              if (!dataType) {
                return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              }
              if (dataType === "arraybuffer") {
                data = exports.transformTo("uint8array", data);
              } else if (dataType === "string") {
                if (isBase64) {
                  data = base64.decode(data);
                } else if (isBinary) {
                  if (isOptimizedBinaryString !== true) {
                    data = string2binary(data);
                  }
                }
              }
              return data;
            });
          };
        }, {
          "./base64": 1,
          "./external": 6,
          "./nodejsUtils": 14,
          "./support": 30,
          "set-immediate-shim": 54
        }],
        33: [function (require, module, exports) {
          var readerFor = require("./reader/readerFor");
          var utils = require("./utils");
          var sig = require("./signature");
          var ZipEntry = require("./zipEntry");
          var utf8 = require("./utf8");
          var support = require("./support");
          function ZipEntries(loadOptions) {
            this.files = [];
            this.loadOptions = loadOptions;
          }
          ZipEntries.prototype = {
            checkSignature: function (expectedSignature) {
              if (!this.reader.readAndCheckSignature(expectedSignature)) {
                this.reader.index -= 4;
                var signature = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
              }
            },
            isSignature: function (askedIndex, expectedSignature) {
              var currentIndex = this.reader.index;
              this.reader.setIndex(askedIndex);
              var signature = this.reader.readString(4);
              var result = signature === expectedSignature;
              this.reader.setIndex(currentIndex);
              return result;
            },
            readBlockEndOfCentral: function () {
              this.diskNumber = this.reader.readInt(2);
              this.diskWithCentralDirStart = this.reader.readInt(2);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
              this.centralDirRecords = this.reader.readInt(2);
              this.centralDirSize = this.reader.readInt(4);
              this.centralDirOffset = this.reader.readInt(4);
              this.zipCommentLength = this.reader.readInt(2);
              var zipComment = this.reader.readData(this.zipCommentLength);
              var decodeParamType = support.uint8array ? "uint8array" : "array";
              var decodeContent = utils.transformTo(decodeParamType, zipComment);
              this.zipComment = this.loadOptions.decodeFileName(decodeContent);
            },
            readBlockZip64EndOfCentral: function () {
              this.zip64EndOfCentralSize = this.reader.readInt(8);
              this.reader.skip(4);
              this.diskNumber = this.reader.readInt(4);
              this.diskWithCentralDirStart = this.reader.readInt(4);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
              this.centralDirRecords = this.reader.readInt(8);
              this.centralDirSize = this.reader.readInt(8);
              this.centralDirOffset = this.reader.readInt(8);
              this.zip64ExtensibleData = {};
              var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
              while (index < extraDataSize) {
                extraFieldId = this.reader.readInt(2);
                extraFieldLength = this.reader.readInt(4);
                extraFieldValue = this.reader.readData(extraFieldLength);
                this.zip64ExtensibleData[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
            },
            readBlockZip64EndOfCentralLocator: function () {
              this.diskWithZip64CentralDirStart = this.reader.readInt(4);
              this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
              this.disksCount = this.reader.readInt(4);
              if (this.disksCount > 1) {
                throw new Error("Multi-volumes zip are not supported");
              }
            },
            readLocalFiles: function () {
              var i, file;
              for (i = 0; i < this.files.length; i++) {
                file = this.files[i];
                this.reader.setIndex(file.localHeaderOffset);
                this.checkSignature(sig.LOCAL_FILE_HEADER);
                file.readLocalPart(this.reader);
                file.handleUTF8();
                file.processAttributes();
              }
            },
            readCentralDir: function () {
              var file;
              this.reader.setIndex(this.centralDirOffset);
              while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
                file = new ZipEntry({
                  zip64: this.zip64
                }, this.loadOptions);
                file.readCentralPart(this.reader);
                this.files.push(file);
              }
              if (this.centralDirRecords !== this.files.length) {
                if (this.centralDirRecords !== 0 && this.files.length === 0) {
                  throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                }
              }
            },
            readEndOfCentral: function () {
              var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
              if (offset < 0) {
                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
                if (isGarbage) {
                  throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                } else {
                  throw new Error("Corrupted zip: can't find end of central directory");
                }
              }
              this.reader.setIndex(offset);
              var endOfCentralDirOffset = offset;
              this.checkSignature(sig.CENTRAL_DIRECTORY_END);
              this.readBlockEndOfCentral();
              if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                this.zip64 = true;
                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                if (offset < 0) {
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                }
                this.reader.setIndex(offset);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                this.readBlockZip64EndOfCentralLocator();
                if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                  this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                  if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                  }
                }
                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                this.readBlockZip64EndOfCentral();
              }
              var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
              if (this.zip64) {
                expectedEndOfCentralDirOffset += 20;
                expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
              }
              var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
              if (extraBytes > 0) {
                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) ; else {
                  this.reader.zero = extraBytes;
                }
              } else if (extraBytes < 0) {
                throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
              }
            },
            prepareReader: function (data) {
              this.reader = readerFor(data);
            },
            load: function (data) {
              this.prepareReader(data);
              this.readEndOfCentral();
              this.readCentralDir();
              this.readLocalFiles();
            }
          };
          module.exports = ZipEntries;
        }, {
          "./reader/readerFor": 22,
          "./signature": 23,
          "./support": 30,
          "./utf8": 31,
          "./utils": 32,
          "./zipEntry": 34
        }],
        34: [function (require, module, exports) {
          var readerFor = require("./reader/readerFor");
          var utils = require("./utils");
          var CompressedObject = require("./compressedObject");
          var crc32fn = require("./crc32");
          var utf8 = require("./utf8");
          var compressions = require("./compressions");
          var support = require("./support");
          var MADE_BY_DOS = 0;
          var MADE_BY_UNIX = 3;
          var findCompression = function (compressionMethod) {
            for (var method in compressions) {
              if (!compressions.hasOwnProperty(method)) {
                continue;
              }
              if (compressions[method].magic === compressionMethod) {
                return compressions[method];
              }
            }
            return null;
          };
          function ZipEntry(options, loadOptions) {
            this.options = options;
            this.loadOptions = loadOptions;
          }
          ZipEntry.prototype = {
            isEncrypted: function () {
              return (this.bitFlag & 1) === 1;
            },
            useUTF8: function () {
              return (this.bitFlag & 2048) === 2048;
            },
            readLocalPart: function (reader) {
              var compression, localExtraFieldsLength;
              reader.skip(22);
              this.fileNameLength = reader.readInt(2);
              localExtraFieldsLength = reader.readInt(2);
              this.fileName = reader.readData(this.fileNameLength);
              reader.skip(localExtraFieldsLength);
              if (this.compressedSize === -1 || this.uncompressedSize === -1) {
                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
              }
              compression = findCompression(this.compressionMethod);
              if (compression === null) {
                throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
              }
              this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
            },
            readCentralPart: function (reader) {
              this.versionMadeBy = reader.readInt(2);
              reader.skip(2);
              this.bitFlag = reader.readInt(2);
              this.compressionMethod = reader.readString(2);
              this.date = reader.readDate();
              this.crc32 = reader.readInt(4);
              this.compressedSize = reader.readInt(4);
              this.uncompressedSize = reader.readInt(4);
              var fileNameLength = reader.readInt(2);
              this.extraFieldsLength = reader.readInt(2);
              this.fileCommentLength = reader.readInt(2);
              this.diskNumberStart = reader.readInt(2);
              this.internalFileAttributes = reader.readInt(2);
              this.externalFileAttributes = reader.readInt(4);
              this.localHeaderOffset = reader.readInt(4);
              if (this.isEncrypted()) {
                throw new Error("Encrypted zip are not supported");
              }
              reader.skip(fileNameLength);
              this.readExtraFields(reader);
              this.parseZIP64ExtraField(reader);
              this.fileComment = reader.readData(this.fileCommentLength);
            },
            processAttributes: function () {
              this.unixPermissions = null;
              this.dosPermissions = null;
              var madeBy = this.versionMadeBy >> 8;
              this.dir = this.externalFileAttributes & 16 ? true : false;
              if (madeBy === MADE_BY_DOS) {
                this.dosPermissions = this.externalFileAttributes & 63;
              }
              if (madeBy === MADE_BY_UNIX) {
                this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
              }
              if (!this.dir && this.fileNameStr.slice(-1) === "/") {
                this.dir = true;
              }
            },
            parseZIP64ExtraField: function (reader) {
              if (!this.extraFields[1]) {
                return;
              }
              var extraReader = readerFor(this.extraFields[1].value);
              if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                this.uncompressedSize = extraReader.readInt(8);
              }
              if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                this.compressedSize = extraReader.readInt(8);
              }
              if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                this.localHeaderOffset = extraReader.readInt(8);
              }
              if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                this.diskNumberStart = extraReader.readInt(4);
              }
            },
            readExtraFields: function (reader) {
              var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
              if (!this.extraFields) {
                this.extraFields = {};
              }
              while (reader.index + 4 < end) {
                extraFieldId = reader.readInt(2);
                extraFieldLength = reader.readInt(2);
                extraFieldValue = reader.readData(extraFieldLength);
                this.extraFields[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
              reader.setIndex(end);
            },
            handleUTF8: function () {
              var decodeParamType = support.uint8array ? "uint8array" : "array";
              if (this.useUTF8()) {
                this.fileNameStr = utf8.utf8decode(this.fileName);
                this.fileCommentStr = utf8.utf8decode(this.fileComment);
              } else {
                var upath = this.findExtraFieldUnicodePath();
                if (upath !== null) {
                  this.fileNameStr = upath;
                } else {
                  var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
                }
                var ucomment = this.findExtraFieldUnicodeComment();
                if (ucomment !== null) {
                  this.fileCommentStr = ucomment;
                } else {
                  var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
                }
              }
            },
            findExtraFieldUnicodePath: function () {
              var upathField = this.extraFields[28789];
              if (upathField) {
                var extraReader = readerFor(upathField.value);
                if (extraReader.readInt(1) !== 1) {
                  return null;
                }
                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                  return null;
                }
                return utf8.utf8decode(extraReader.readData(upathField.length - 5));
              }
              return null;
            },
            findExtraFieldUnicodeComment: function () {
              var ucommentField = this.extraFields[25461];
              if (ucommentField) {
                var extraReader = readerFor(ucommentField.value);
                if (extraReader.readInt(1) !== 1) {
                  return null;
                }
                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                  return null;
                }
                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
              }
              return null;
            }
          };
          module.exports = ZipEntry;
        }, {
          "./compressedObject": 2,
          "./compressions": 3,
          "./crc32": 4,
          "./reader/readerFor": 22,
          "./support": 30,
          "./utf8": 31,
          "./utils": 32
        }],
        35: [function (require, module, exports) {
          var StreamHelper = require("./stream/StreamHelper");
          var DataWorker = require("./stream/DataWorker");
          var utf8 = require("./utf8");
          var CompressedObject = require("./compressedObject");
          var GenericWorker = require("./stream/GenericWorker");
          var ZipObject = function (name, data, options) {
            this.name = name;
            this.dir = options.dir;
            this.date = options.date;
            this.comment = options.comment;
            this.unixPermissions = options.unixPermissions;
            this.dosPermissions = options.dosPermissions;
            this._data = data;
            this._dataBinary = options.binary;
            this.options = {
              compression: options.compression,
              compressionOptions: options.compressionOptions
            };
          };
          ZipObject.prototype = {
            internalStream: function (type) {
              var result = null, outputType = "string";
              try {
                if (!type) {
                  throw new Error("No output type specified.");
                }
                outputType = type.toLowerCase();
                var askUnicodeString = outputType === "string" || outputType === "text";
                if (outputType === "binarystring" || outputType === "text") {
                  outputType = "string";
                }
                result = this._decompressWorker();
                var isUnicodeString = !this._dataBinary;
                if (isUnicodeString && !askUnicodeString) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }
                if (!isUnicodeString && askUnicodeString) {
                  result = result.pipe(new utf8.Utf8DecodeWorker());
                }
              } catch (e) {
                result = new GenericWorker("error");
                result.error(e);
              }
              return new StreamHelper(result, outputType, "");
            },
            async: function (type, onUpdate) {
              return this.internalStream(type).accumulate(onUpdate);
            },
            nodeStream: function (type, onUpdate) {
              return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
            },
            _compressWorker: function (compression, compressionOptions) {
              if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
                return this._data.getCompressedWorker();
              } else {
                var result = this._decompressWorker();
                if (!this._dataBinary) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }
                return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
              }
            },
            _decompressWorker: function () {
              if (this._data instanceof CompressedObject) {
                return this._data.getContentWorker();
              } else if (this._data instanceof GenericWorker) {
                return this._data;
              } else {
                return new DataWorker(this._data);
              }
            }
          };
          var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
          var removedFn = function () {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          };
          for (var i = 0; i < removedMethods.length; i++) {
            ZipObject.prototype[removedMethods[i]] = removedFn;
          }
          module.exports = ZipObject;
        }, {
          "./compressedObject": 2,
          "./stream/DataWorker": 27,
          "./stream/GenericWorker": 28,
          "./stream/StreamHelper": 29,
          "./utf8": 31
        }],
        36: [function (require, module, exports) {
          (function (global) {
            var Mutation = global.MutationObserver || global.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode("");
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function () {
                  element.data = called = ++called % 2;
                };
              } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function () {
                  channel.port2.postMessage(0);
                };
              } else if (((("document" in global) && "onreadystatechange") in global.document.createElement("script"))) {
                scheduleDrain = function () {
                  var scriptEl = global.document.createElement("script");
                  scriptEl.onreadystatechange = function () {
                    nextTick();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function () {
                  setTimeout(nextTick, 0);
                };
              }
            }
            var draining;
            var queue = [];
            function nextTick() {
              draining = true;
              var i, oldQueue;
              var len = queue.length;
              while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue.length;
              }
              draining = false;
            }
            module.exports = immediate;
            function immediate(task) {
              if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        37: [function (require, module, exports) {
          var immediate = require("immediate");
          function INTERNAL() {}
          var handlers = {};
          var REJECTED = ["REJECTED"];
          var FULFILLED = ["FULFILLED"];
          var PENDING = ["PENDING"];
          module.exports = Promise;
          function Promise(resolver) {
            if (typeof resolver !== "function") {
              throw new TypeError("resolver must be a function");
            }
            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;
            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }
          Promise.prototype["finally"] = function (callback) {
            if (typeof callback !== "function") {
              return this;
            }
            var p = this.constructor;
            return this.then(resolve, reject);
            function resolve(value) {
              function yes() {
                return value;
              }
              return p.resolve(callback()).then(yes);
            }
            function reject(reason) {
              function no() {
                throw reason;
              }
              return p.resolve(callback()).then(no);
            }
          };
          Promise.prototype["catch"] = function (onRejected) {
            return this.then(null, onRejected);
          };
          Promise.prototype.then = function (onFulfilled, onRejected) {
            if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
              return this;
            }
            var promise = new this.constructor(INTERNAL);
            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }
            return promise;
          };
          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;
            if (typeof onFulfilled === "function") {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }
            if (typeof onRejected === "function") {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }
          QueueItem.prototype.callFulfilled = function (value) {
            handlers.resolve(this.promise, value);
          };
          QueueItem.prototype.otherCallFulfilled = function (value) {
            unwrap(this.promise, this.onFulfilled, value);
          };
          QueueItem.prototype.callRejected = function (value) {
            handlers.reject(this.promise, value);
          };
          QueueItem.prototype.otherCallRejected = function (value) {
            unwrap(this.promise, this.onRejected, value);
          };
          function unwrap(promise, func, value) {
            immediate(function () {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers.reject(promise, e);
              }
              if (returnValue === promise) {
                handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
              } else {
                handlers.resolve(promise, returnValue);
              }
            });
          }
          handlers.resolve = function (self, value) {
            var result = tryCatch(getThen, value);
            if (result.status === "error") {
              return handlers.reject(self, result.value);
            }
            var thenable = result.value;
            if (thenable) {
              safelyResolveThenable(self, thenable);
            } else {
              self.state = FULFILLED;
              self.outcome = value;
              var i = -1;
              var len = self.queue.length;
              while (++i < len) {
                self.queue[i].callFulfilled(value);
              }
            }
            return self;
          };
          handlers.reject = function (self, error) {
            self.state = REJECTED;
            self.outcome = error;
            var i = -1;
            var len = self.queue.length;
            while (++i < len) {
              self.queue[i].callRejected(error);
            }
            return self;
          };
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }
          function safelyResolveThenable(self, thenable) {
            var called = false;
            function onError(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.reject(self, value);
            }
            function onSuccess(value) {
              if (called) {
                return;
              }
              called = true;
              handlers.resolve(self, value);
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            if (result.status === "error") {
              onError(result.value);
            }
          }
          function tryCatch(func, value) {
            var out = {};
            try {
              out.value = func(value);
              out.status = "success";
            } catch (e) {
              out.status = "error";
              out.value = e;
            }
            return out;
          }
          Promise.resolve = resolve;
          function resolve(value) {
            if (value instanceof this) {
              return value;
            }
            return handlers.resolve(new this(INTERNAL), value);
          }
          Promise.reject = reject;
          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers.reject(promise, reason);
          }
          Promise.all = all;
          function all(iterable) {
            var self = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var values = new Array(len);
            var resolved = 0;
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              allResolver(iterable[i], i);
            }
            return promise;
            function allResolver(value, i) {
              self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
              function resolveFromAll(outValue) {
                values[i] = outValue;
                if (++resolved === len && !called) {
                  called = true;
                  handlers.resolve(promise, values);
                }
              }
            }
          }
          Promise.race = race;
          function race(iterable) {
            var self = this;
            if (Object.prototype.toString.call(iterable) !== "[object Array]") {
              return this.reject(new TypeError("must be an array"));
            }
            var len = iterable.length;
            var called = false;
            if (!len) {
              return this.resolve([]);
            }
            var i = -1;
            var promise = new this(INTERNAL);
            while (++i < len) {
              resolver(iterable[i]);
            }
            return promise;
            function resolver(value) {
              self.resolve(value).then(function (response) {
                if (!called) {
                  called = true;
                  handlers.resolve(promise, response);
                }
              }, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
            }
          }
        }, {
          "immediate": 36
        }],
        38: [function (require, module, exports) {
          var assign = require("./lib/utils/common").assign;
          var deflate = require("./lib/deflate");
          var inflate = require("./lib/inflate");
          var constants = require("./lib/zlib/constants");
          var pako = {};
          assign(pako, deflate, inflate, constants);
          module.exports = pako;
        }, {
          "./lib/deflate": 39,
          "./lib/inflate": 40,
          "./lib/utils/common": 41,
          "./lib/zlib/constants": 44
        }],
        39: [function (require, module, exports) {
          var zlib_deflate = require("./zlib/deflate");
          var utils = require("./utils/common");
          var strings = require("./utils/strings");
          var msg = require("./zlib/messages");
          var ZStream = require("./zlib/zstream");
          var toString = Object.prototype.toString;
          var Z_NO_FLUSH = 0;
          var Z_FINISH = 4;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_SYNC_FLUSH = 2;
          var Z_DEFAULT_COMPRESSION = -1;
          var Z_DEFAULT_STRATEGY = 0;
          var Z_DEFLATED = 8;
          function Deflate(options) {
            if (!(this instanceof Deflate)) return new Deflate(options);
            this.options = utils.assign({
              level: Z_DEFAULT_COMPRESSION,
              method: Z_DEFLATED,
              chunkSize: 16384,
              windowBits: 15,
              memLevel: 8,
              strategy: Z_DEFAULT_STRATEGY,
              to: ""
            }, options || ({}));
            var opt = this.options;
            if (opt.raw && opt.windowBits > 0) {
              opt.windowBits = -opt.windowBits;
            } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
              opt.windowBits += 16;
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            if (opt.header) {
              zlib_deflate.deflateSetHeader(this.strm, opt.header);
            }
            if (opt.dictionary) {
              var dict;
              if (typeof opt.dictionary === "string") {
                dict = strings.string2buf(opt.dictionary);
              } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(opt.dictionary);
              } else {
                dict = opt.dictionary;
              }
              status = zlib_deflate.deflateSetDictionary(this.strm, dict);
              if (status !== Z_OK) {
                throw new Error(msg[status]);
              }
              this._dict_set = true;
            }
          }
          Deflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var status, _mode;
            if (this.ended) {
              return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
            if (typeof data === "string") {
              strm.input = strings.string2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }
              status = zlib_deflate.deflate(strm, _mode);
              if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }
              if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
            if (_mode === Z_FINISH) {
              status = zlib_deflate.deflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === Z_OK;
            }
            if (_mode === Z_SYNC_FLUSH) {
              this.onEnd(Z_OK);
              strm.avail_out = 0;
              return true;
            }
            return true;
          };
          Deflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
          };
          Deflate.prototype.onEnd = function (status) {
            if (status === Z_OK) {
              if (this.options.to === "string") {
                this.result = this.chunks.join("");
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          function deflate(input, options) {
            var deflator = new Deflate(options);
            deflator.push(input, true);
            if (deflator.err) {
              throw deflator.msg || msg[deflator.err];
            }
            return deflator.result;
          }
          function deflateRaw(input, options) {
            options = options || ({});
            options.raw = true;
            return deflate(input, options);
          }
          function gzip(input, options) {
            options = options || ({});
            options.gzip = true;
            return deflate(input, options);
          }
          exports.Deflate = Deflate;
          exports.deflate = deflate;
          exports.deflateRaw = deflateRaw;
          exports.gzip = gzip;
        }, {
          "./utils/common": 41,
          "./utils/strings": 42,
          "./zlib/deflate": 46,
          "./zlib/messages": 51,
          "./zlib/zstream": 53
        }],
        40: [function (require, module, exports) {
          var zlib_inflate = require("./zlib/inflate");
          var utils = require("./utils/common");
          var strings = require("./utils/strings");
          var c = require("./zlib/constants");
          var msg = require("./zlib/messages");
          var ZStream = require("./zlib/zstream");
          var GZheader = require("./zlib/gzheader");
          var toString = Object.prototype.toString;
          function Inflate(options) {
            if (!(this instanceof Inflate)) return new Inflate(options);
            this.options = utils.assign({
              chunkSize: 16384,
              windowBits: 0,
              to: ""
            }, options || ({}));
            var opt = this.options;
            if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
              opt.windowBits = -opt.windowBits;
              if (opt.windowBits === 0) {
                opt.windowBits = -15;
              }
            }
            if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
              opt.windowBits += 32;
            }
            if (opt.windowBits > 15 && opt.windowBits < 48) {
              if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
              }
            }
            this.err = 0;
            this.msg = "";
            this.ended = false;
            this.chunks = [];
            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
            this.header = new GZheader();
            zlib_inflate.inflateGetHeader(this.strm, this.header);
          }
          Inflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var dictionary = this.options.dictionary;
            var status, _mode;
            var next_out_utf8, tail, utf8str;
            var dict;
            var allowBufError = false;
            if (this.ended) {
              return false;
            }
            _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
            if (typeof data === "string") {
              strm.input = strings.binstring2buf(data);
            } else if (toString.call(data) === "[object ArrayBuffer]") {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }
            strm.next_in = 0;
            strm.avail_in = strm.input.length;
            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }
              status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
              if (status === c.Z_NEED_DICT && dictionary) {
                if (typeof dictionary === "string") {
                  dict = strings.string2buf(dictionary);
                } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
                  dict = new Uint8Array(dictionary);
                } else {
                  dict = dictionary;
                }
                status = zlib_inflate.inflateSetDictionary(this.strm, dict);
              }
              if (status === c.Z_BUF_ERROR && allowBufError === true) {
                status = c.Z_OK;
                allowBufError = false;
              }
              if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }
              if (strm.next_out) {
                if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                  if (this.options.to === "string") {
                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    tail = strm.next_out - next_out_utf8;
                    utf8str = strings.buf2string(strm.output, next_out_utf8);
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) {
                      utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                    }
                    this.onData(utf8str);
                  } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                  }
                }
              }
              if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true;
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
            if (status === c.Z_STREAM_END) {
              _mode = c.Z_FINISH;
            }
            if (_mode === c.Z_FINISH) {
              status = zlib_inflate.inflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === c.Z_OK;
            }
            if (_mode === c.Z_SYNC_FLUSH) {
              this.onEnd(c.Z_OK);
              strm.avail_out = 0;
              return true;
            }
            return true;
          };
          Inflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
          };
          Inflate.prototype.onEnd = function (status) {
            if (status === c.Z_OK) {
              if (this.options.to === "string") {
                this.result = this.chunks.join("");
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }
            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          function inflate(input, options) {
            var inflator = new Inflate(options);
            inflator.push(input, true);
            if (inflator.err) {
              throw inflator.msg || msg[inflator.err];
            }
            return inflator.result;
          }
          function inflateRaw(input, options) {
            options = options || ({});
            options.raw = true;
            return inflate(input, options);
          }
          exports.Inflate = Inflate;
          exports.inflate = inflate;
          exports.inflateRaw = inflateRaw;
          exports.ungzip = inflate;
        }, {
          "./utils/common": 41,
          "./utils/strings": 42,
          "./zlib/constants": 44,
          "./zlib/gzheader": 47,
          "./zlib/inflate": 49,
          "./zlib/messages": 51,
          "./zlib/zstream": 53
        }],
        41: [function (require, module, exports) {
          var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
          exports.assign = function (obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            while (sources.length) {
              var source = sources.shift();
              if (!source) {
                continue;
              }
              if (typeof source !== "object") {
                throw new TypeError(source + "must be non-object");
              }
              for (var p in source) {
                if (source.hasOwnProperty(p)) {
                  obj[p] = source[p];
                }
              }
            }
            return obj;
          };
          exports.shrinkBuf = function (buf, size) {
            if (buf.length === size) {
              return buf;
            }
            if (buf.subarray) {
              return buf.subarray(0, size);
            }
            buf.length = size;
            return buf;
          };
          var fnTyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
              if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                return;
              }
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            flattenChunks: function (chunks) {
              var i, l, len, pos, chunk, result;
              len = 0;
              for ((i = 0, l = chunks.length); i < l; i++) {
                len += chunks[i].length;
              }
              result = new Uint8Array(len);
              pos = 0;
              for ((i = 0, l = chunks.length); i < l; i++) {
                chunk = chunks[i];
                result.set(chunk, pos);
                pos += chunk.length;
              }
              return result;
            }
          };
          var fnUntyped = {
            arraySet: function (dest, src, src_offs, len, dest_offs) {
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            flattenChunks: function (chunks) {
              return [].concat.apply([], chunks);
            }
          };
          exports.setTyped = function (on) {
            if (on) {
              exports.Buf8 = Uint8Array;
              exports.Buf16 = Uint16Array;
              exports.Buf32 = Int32Array;
              exports.assign(exports, fnTyped);
            } else {
              exports.Buf8 = Array;
              exports.Buf16 = Array;
              exports.Buf32 = Array;
              exports.assign(exports, fnUntyped);
            }
          };
          exports.setTyped(TYPED_OK);
        }, {}],
        42: [function (require, module, exports) {
          var utils = require("./common");
          var STR_APPLY_OK = true;
          var STR_APPLY_UIA_OK = true;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (__) {
            STR_APPLY_OK = false;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (__) {
            STR_APPLY_UIA_OK = false;
          }
          var _utf8len = new utils.Buf8(256);
          for (var q = 0; q < 256; q++) {
            _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
          }
          _utf8len[254] = _utf8len[254] = 1;
          exports.string2buf = function (str) {
            var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
            }
            buf = new utils.Buf8(buf_len);
            for ((i = 0, m_pos = 0); i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);
              if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);
                if ((c2 & 64512) === 56320) {
                  c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                  m_pos++;
                }
              }
              if (c < 128) {
                buf[i++] = c;
              } else if (c < 2048) {
                buf[i++] = 192 | c >>> 6;
                buf[i++] = 128 | c & 63;
              } else if (c < 65536) {
                buf[i++] = 224 | c >>> 12;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              } else {
                buf[i++] = 240 | c >>> 18;
                buf[i++] = 128 | c >>> 12 & 63;
                buf[i++] = 128 | c >>> 6 & 63;
                buf[i++] = 128 | c & 63;
              }
            }
            return buf;
          };
          function buf2binstring(buf, len) {
            if (len < 65537) {
              if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
              }
            }
            var result = "";
            for (var i = 0; i < len; i++) {
              result += String.fromCharCode(buf[i]);
            }
            return result;
          }
          exports.buf2binstring = function (buf) {
            return buf2binstring(buf, buf.length);
          };
          exports.binstring2buf = function (str) {
            var buf = new utils.Buf8(str.length);
            for (var i = 0, len = buf.length; i < len; i++) {
              buf[i] = str.charCodeAt(i);
            }
            return buf;
          };
          exports.buf2string = function (buf, max) {
            var i, out, c, c_len;
            var len = max || buf.length;
            var utf16buf = new Array(len * 2);
            for ((out = 0, i = 0); i < len; ) {
              c = buf[i++];
              if (c < 128) {
                utf16buf[out++] = c;
                continue;
              }
              c_len = _utf8len[c];
              if (c_len > 4) {
                utf16buf[out++] = 65533;
                i += c_len - 1;
                continue;
              }
              c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
              while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 63;
                c_len--;
              }
              if (c_len > 1) {
                utf16buf[out++] = 65533;
                continue;
              }
              if (c < 65536) {
                utf16buf[out++] = c;
              } else {
                c -= 65536;
                utf16buf[out++] = 55296 | c >> 10 & 1023;
                utf16buf[out++] = 56320 | c & 1023;
              }
            }
            return buf2binstring(utf16buf, out);
          };
          exports.utf8border = function (buf, max) {
            var pos;
            max = max || buf.length;
            if (max > buf.length) {
              max = buf.length;
            }
            pos = max - 1;
            while (pos >= 0 && (buf[pos] & 192) === 128) {
              pos--;
            }
            if (pos < 0) {
              return max;
            }
            if (pos === 0) {
              return max;
            }
            return pos + _utf8len[buf[pos]] > max ? pos : max;
          };
        }, {
          "./common": 41
        }],
        43: [function (require, module, exports) {
          function adler32(adler, buf, len, pos) {
            var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
            while (len !== 0) {
              n = len > 2000 ? 2000 : len;
              len -= n;
              do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
              } while (--n);
              s1 %= 65521;
              s2 %= 65521;
            }
            return s1 | s2 << 16 | 0;
          }
          module.exports = adler32;
        }, {}],
        44: [function (require, module, exports) {
          module.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
          };
        }, {}],
        45: [function (require, module, exports) {
          function makeTable() {
            var c, table = [];
            for (var n = 0; n < 256; n++) {
              c = n;
              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
              }
              table[n] = c;
            }
            return table;
          }
          var crcTable = makeTable();
          function crc32(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc ^= -1;
            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
            }
            return crc ^ -1;
          }
          module.exports = crc32;
        }, {}],
        46: [function (require, module, exports) {
          var utils = require("../utils/common");
          var trees = require("./trees");
          var adler32 = require("./adler32");
          var crc32 = require("./crc32");
          var msg = require("./messages");
          var Z_NO_FLUSH = 0;
          var Z_PARTIAL_FLUSH = 1;
          var Z_FULL_FLUSH = 3;
          var Z_FINISH = 4;
          var Z_BLOCK = 5;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3;
          var Z_BUF_ERROR = -5;
          var Z_DEFAULT_COMPRESSION = -1;
          var Z_FILTERED = 1;
          var Z_HUFFMAN_ONLY = 2;
          var Z_RLE = 3;
          var Z_FIXED = 4;
          var Z_DEFAULT_STRATEGY = 0;
          var Z_UNKNOWN = 2;
          var Z_DEFLATED = 8;
          var MAX_MEM_LEVEL = 9;
          var MAX_WBITS = 15;
          var DEF_MEM_LEVEL = 8;
          var LENGTH_CODES = 29;
          var LITERALS = 256;
          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          var D_CODES = 30;
          var BL_CODES = 19;
          var HEAP_SIZE = 2 * L_CODES + 1;
          var MAX_BITS = 15;
          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
          var PRESET_DICT = 32;
          var INIT_STATE = 42;
          var EXTRA_STATE = 69;
          var NAME_STATE = 73;
          var COMMENT_STATE = 91;
          var HCRC_STATE = 103;
          var BUSY_STATE = 113;
          var FINISH_STATE = 666;
          var BS_NEED_MORE = 1;
          var BS_BLOCK_DONE = 2;
          var BS_FINISH_STARTED = 3;
          var BS_FINISH_DONE = 4;
          var OS_CODE = 3;
          function err(strm, errorCode) {
            strm.msg = msg[errorCode];
            return errorCode;
          }
          function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0);
          }
          function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
              buf[len] = 0;
            }
          }
          function flush_pending(strm) {
            var s = strm.state;
            var len = s.pending;
            if (len > strm.avail_out) {
              len = strm.avail_out;
            }
            if (len === 0) {
              return;
            }
            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
            strm.next_out += len;
            s.pending_out += len;
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;
            if (s.pending === 0) {
              s.pending_out = 0;
            }
          }
          function flush_block_only(s, last) {
            trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
            s.block_start = s.strstart;
            flush_pending(s.strm);
          }
          function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
          }
          function putShortMSB(s, b) {
            s.pending_buf[s.pending++] = b >>> 8 & 255;
            s.pending_buf[s.pending++] = b & 255;
          }
          function read_buf(strm, buf, start, size) {
            var len = strm.avail_in;
            if (len > size) {
              len = size;
            }
            if (len === 0) {
              return 0;
            }
            strm.avail_in -= len;
            utils.arraySet(buf, strm.input, strm.next_in, len, start);
            if (strm.state.wrap === 1) {
              strm.adler = adler32(strm.adler, buf, len, start);
            } else if (strm.state.wrap === 2) {
              strm.adler = crc32(strm.adler, buf, len, start);
            }
            strm.next_in += len;
            strm.total_in += len;
            return len;
          }
          function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length;
            var scan = s.strstart;
            var match;
            var len;
            var best_len = s.prev_length;
            var nice_match = s.nice_match;
            var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
            var _win = s.window;
            var wmask = s.w_mask;
            var prev = s.prev;
            var strend = s.strstart + MAX_MATCH;
            var scan_end1 = _win[scan + best_len - 1];
            var scan_end = _win[scan + best_len];
            if (s.prev_length >= s.good_match) {
              chain_length >>= 2;
            }
            if (nice_match > s.lookahead) {
              nice_match = s.lookahead;
            }
            do {
              match = cur_match;
              if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
              }
              scan += 2;
              match++;
              do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
              len = MAX_MATCH - (strend - scan);
              scan = strend - MAX_MATCH;
              if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;
                if (len >= nice_match) {
                  break;
                }
                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
              }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
            if (best_len <= s.lookahead) {
              return best_len;
            }
            return s.lookahead;
          }
          function fill_window(s) {
            var _w_size = s.w_size;
            var p, n, m, more, str;
            do {
              more = s.window_size - s.lookahead - s.strstart;
              if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                s.block_start -= _w_size;
                n = s.hash_size;
                p = n;
                do {
                  m = s.head[--p];
                  s.head[p] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                n = _w_size;
                p = n;
                do {
                  m = s.prev[--p];
                  s.prev[p] = m >= _w_size ? m - _w_size : 0;
                } while (--n);
                more += _w_size;
              }
              if (s.strm.avail_in === 0) {
                break;
              }
              n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
              s.lookahead += n;
              if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
                while (s.insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                  s.prev[str & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = str;
                  str++;
                  s.insert--;
                  if (s.lookahead + s.insert < MIN_MATCH) {
                    break;
                  }
                }
              }
            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
          }
          function deflate_stored(s, flush) {
            var max_block_size = 65535;
            if (max_block_size > s.pending_buf_size - 5) {
              max_block_size = s.pending_buf_size - 5;
            }
            for (; ; ) {
              if (s.lookahead <= 1) {
                fill_window(s);
                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              s.strstart += s.lookahead;
              s.lookahead = 0;
              var max_start = s.block_start + max_block_size;
              if (s.strstart === 0 || s.strstart >= max_start) {
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
              if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.strstart > s.block_start) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_NEED_MORE;
          }
          function deflate_fast(s, flush) {
            var hash_head;
            var bflush;
            for (; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              hash_head = 0;
              if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
              if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
              }
              if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                  s.match_length--;
                  do {
                    s.strstart++;
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  } while (--s.match_length !== 0);
                  s.strstart++;
                } else {
                  s.strstart += s.match_length;
                  s.match_length = 0;
                  s.ins_h = s.window[s.strstart];
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                }
              } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_slow(s, flush) {
            var hash_head;
            var bflush;
            var max_insert;
            for (; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);
                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              hash_head = 0;
              if (s.lookahead >= MIN_MATCH) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
              s.prev_length = s.match_length;
              s.prev_match = s.match_start;
              s.match_length = MIN_MATCH - 1;
              if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                s.match_length = longest_match(s, hash_head);
                if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                  s.match_length = MIN_MATCH - 1;
                }
              }
              if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;
                do {
                  if (++s.strstart <= max_insert) {
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                  }
                } while (--s.prev_length !== 0);
                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;
                if (bflush) {
                  flush_block_only(s, false);
                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                }
              } else if (s.match_available) {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                if (bflush) {
                  flush_block_only(s, false);
                }
                s.strstart++;
                s.lookahead--;
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              } else {
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
              }
            }
            if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              s.match_available = 0;
            }
            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_rle(s, flush) {
            var bflush;
            var prev;
            var scan, strend;
            var _win = s.window;
            for (; ; ) {
              if (s.lookahead <= MAX_MATCH) {
                fill_window(s);
                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                if (s.lookahead === 0) {
                  break;
                }
              }
              s.match_length = 0;
              if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];
                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                  strend = s.strstart + MAX_MATCH;
                  do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                  s.match_length = MAX_MATCH - (strend - scan);
                  if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead;
                  }
                }
              }
              if (s.match_length >= MIN_MATCH) {
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
              } else {
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function deflate_huff(s, flush) {
            var bflush;
            for (; ; ) {
              if (s.lookahead === 0) {
                fill_window(s);
                if (s.lookahead === 0) {
                  if (flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                  }
                  break;
                }
              }
              s.match_length = 0;
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            }
            s.insert = 0;
            if (flush === Z_FINISH) {
              flush_block_only(s, true);
              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              return BS_FINISH_DONE;
            }
            if (s.last_lit) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            return BS_BLOCK_DONE;
          }
          function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length;
            this.max_lazy = max_lazy;
            this.nice_length = nice_length;
            this.max_chain = max_chain;
            this.func = func;
          }
          var configuration_table;
          configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
          function lm_init(s) {
            s.window_size = 2 * s.w_size;
            zero(s.head);
            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;
            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            s.ins_h = 0;
          }
          function DeflateState() {
            this.strm = null;
            this.status = 0;
            this.pending_buf = null;
            this.pending_buf_size = 0;
            this.pending_out = 0;
            this.pending = 0;
            this.wrap = 0;
            this.gzhead = null;
            this.gzindex = 0;
            this.method = Z_DEFLATED;
            this.last_flush = -1;
            this.w_size = 0;
            this.w_bits = 0;
            this.w_mask = 0;
            this.window = null;
            this.window_size = 0;
            this.prev = null;
            this.head = null;
            this.ins_h = 0;
            this.hash_size = 0;
            this.hash_bits = 0;
            this.hash_mask = 0;
            this.hash_shift = 0;
            this.block_start = 0;
            this.match_length = 0;
            this.prev_match = 0;
            this.match_available = 0;
            this.strstart = 0;
            this.match_start = 0;
            this.lookahead = 0;
            this.prev_length = 0;
            this.max_chain_length = 0;
            this.max_lazy_match = 0;
            this.level = 0;
            this.strategy = 0;
            this.good_match = 0;
            this.nice_match = 0;
            this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
            this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
            this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
            zero(this.dyn_ltree);
            zero(this.dyn_dtree);
            zero(this.bl_tree);
            this.l_desc = null;
            this.d_desc = null;
            this.bl_desc = null;
            this.bl_count = new utils.Buf16(MAX_BITS + 1);
            this.heap = new utils.Buf16(2 * L_CODES + 1);
            zero(this.heap);
            this.heap_len = 0;
            this.heap_max = 0;
            this.depth = new utils.Buf16(2 * L_CODES + 1);
            zero(this.depth);
            this.l_buf = 0;
            this.lit_bufsize = 0;
            this.last_lit = 0;
            this.d_buf = 0;
            this.opt_len = 0;
            this.static_len = 0;
            this.matches = 0;
            this.insert = 0;
            this.bi_buf = 0;
            this.bi_valid = 0;
          }
          function deflateResetKeep(strm) {
            var s;
            if (!strm || !strm.state) {
              return err(strm, Z_STREAM_ERROR);
            }
            strm.total_in = strm.total_out = 0;
            strm.data_type = Z_UNKNOWN;
            s = strm.state;
            s.pending = 0;
            s.pending_out = 0;
            if (s.wrap < 0) {
              s.wrap = -s.wrap;
            }
            s.status = s.wrap ? INIT_STATE : BUSY_STATE;
            strm.adler = s.wrap === 2 ? 0 : 1;
            s.last_flush = Z_NO_FLUSH;
            trees._tr_init(s);
            return Z_OK;
          }
          function deflateReset(strm) {
            var ret = deflateResetKeep(strm);
            if (ret === Z_OK) {
              lm_init(strm.state);
            }
            return ret;
          }
          function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            if (strm.state.wrap !== 2) {
              return Z_STREAM_ERROR;
            }
            strm.state.gzhead = head;
            return Z_OK;
          }
          function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) {
              return Z_STREAM_ERROR;
            }
            var wrap = 1;
            if (level === Z_DEFAULT_COMPRESSION) {
              level = 6;
            }
            if (windowBits < 0) {
              wrap = 0;
              windowBits = -windowBits;
            } else if (windowBits > 15) {
              wrap = 2;
              windowBits -= 16;
            }
            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
              return err(strm, Z_STREAM_ERROR);
            }
            if (windowBits === 8) {
              windowBits = 9;
            }
            var s = new DeflateState();
            strm.state = s;
            s.strm = strm;
            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;
            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = s.hash_size - 1;
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
            s.window = new utils.Buf8(s.w_size * 2);
            s.head = new utils.Buf16(s.hash_size);
            s.prev = new utils.Buf16(s.w_size);
            s.lit_bufsize = 1 << memLevel + 6;
            s.pending_buf_size = s.lit_bufsize * 4;
            s.pending_buf = new utils.Buf8(s.pending_buf_size);
            s.d_buf = 1 * s.lit_bufsize;
            s.l_buf = (1 + 2) * s.lit_bufsize;
            s.level = level;
            s.strategy = strategy;
            s.method = method;
            return deflateReset(strm);
          }
          function deflateInit(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
          }
          function deflate(strm, flush) {
            var old_flush, s;
            var beg, val;
            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
              return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            }
            s = strm.state;
            if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
              return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
            }
            s.strm = strm;
            old_flush = s.last_flush;
            s.last_flush = flush;
            if (s.status === INIT_STATE) {
              if (s.wrap === 2) {
                strm.adler = 0;
                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);
                if (!s.gzhead) {
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, OS_CODE);
                  s.status = BUSY_STATE;
                } else {
                  put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                  put_byte(s, s.gzhead.time & 255);
                  put_byte(s, s.gzhead.time >> 8 & 255);
                  put_byte(s, s.gzhead.time >> 16 & 255);
                  put_byte(s, s.gzhead.time >> 24 & 255);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, s.gzhead.os & 255);
                  if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 255);
                    put_byte(s, s.gzhead.extra.length >> 8 & 255);
                  }
                  if (s.gzhead.hcrc) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                  }
                  s.gzindex = 0;
                  s.status = EXTRA_STATE;
                }
              } else {
                var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                var level_flags = -1;
                if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                  level_flags = 0;
                } else if (s.level < 6) {
                  level_flags = 1;
                } else if (s.level === 6) {
                  level_flags = 2;
                } else {
                  level_flags = 3;
                }
                header |= level_flags << 6;
                if (s.strstart !== 0) {
                  header |= PRESET_DICT;
                }
                header += 31 - header % 31;
                s.status = BUSY_STATE;
                putShortMSB(s, header);
                if (s.strstart !== 0) {
                  putShortMSB(s, strm.adler >>> 16);
                  putShortMSB(s, strm.adler & 65535);
                }
                strm.adler = 1;
              }
            }
            if (s.status === EXTRA_STATE) {
              if (s.gzhead.extra) {
                beg = s.pending;
                while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      break;
                    }
                  }
                  put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                  s.gzindex++;
                }
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (s.gzindex === s.gzhead.extra.length) {
                  s.gzindex = 0;
                  s.status = NAME_STATE;
                }
              } else {
                s.status = NAME_STATE;
              }
            }
            if (s.status === NAME_STATE) {
              if (s.gzhead.name) {
                beg = s.pending;
                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      val = 1;
                      break;
                    }
                  }
                  if (s.gzindex < s.gzhead.name.length) {
                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                  } else {
                    val = 0;
                  }
                  put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                  s.gzindex = 0;
                  s.status = COMMENT_STATE;
                }
              } else {
                s.status = COMMENT_STATE;
              }
            }
            if (s.status === COMMENT_STATE) {
              if (s.gzhead.comment) {
                beg = s.pending;
                do {
                  if (s.pending === s.pending_buf_size) {
                    if (s.gzhead.hcrc && s.pending > beg) {
                      strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s.pending;
                    if (s.pending === s.pending_buf_size) {
                      val = 1;
                      break;
                    }
                  }
                  if (s.gzindex < s.gzhead.comment.length) {
                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                  } else {
                    val = 0;
                  }
                  put_byte(s, val);
                } while (val !== 0);
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                if (val === 0) {
                  s.status = HCRC_STATE;
                }
              } else {
                s.status = HCRC_STATE;
              }
            }
            if (s.status === HCRC_STATE) {
              if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                  flush_pending(strm);
                }
                if (s.pending + 2 <= s.pending_buf_size) {
                  put_byte(s, strm.adler & 255);
                  put_byte(s, strm.adler >> 8 & 255);
                  strm.adler = 0;
                  s.status = BUSY_STATE;
                }
              } else {
                s.status = BUSY_STATE;
              }
            }
            if (s.pending !== 0) {
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
              return err(strm, Z_BUF_ERROR);
            }
            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
              return err(strm, Z_BUF_ERROR);
            }
            if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
              var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
              if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
              }
              if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                }
                return Z_OK;
              }
              if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                  trees._tr_align(s);
                } else if (flush !== Z_BLOCK) {
                  trees._tr_stored_block(s, 0, 0, false);
                  if (flush === Z_FULL_FLUSH) {
                    zero(s.head);
                    if (s.lookahead === 0) {
                      s.strstart = 0;
                      s.block_start = 0;
                      s.insert = 0;
                    }
                  }
                }
                flush_pending(strm);
                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                  return Z_OK;
                }
              }
            }
            if (flush !== Z_FINISH) {
              return Z_OK;
            }
            if (s.wrap <= 0) {
              return Z_STREAM_END;
            }
            if (s.wrap === 2) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              put_byte(s, strm.adler >> 16 & 255);
              put_byte(s, strm.adler >> 24 & 255);
              put_byte(s, strm.total_in & 255);
              put_byte(s, strm.total_in >> 8 & 255);
              put_byte(s, strm.total_in >> 16 & 255);
              put_byte(s, strm.total_in >> 24 & 255);
            } else {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            flush_pending(strm);
            if (s.wrap > 0) {
              s.wrap = -s.wrap;
            }
            return s.pending !== 0 ? Z_OK : Z_STREAM_END;
          }
          function deflateEnd(strm) {
            var status;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            status = strm.state.status;
            if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
              return err(strm, Z_STREAM_ERROR);
            }
            strm.state = null;
            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
          }
          function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var s;
            var str, n;
            var wrap;
            var avail;
            var next;
            var input;
            var tmpDict;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            s = strm.state;
            wrap = s.wrap;
            if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
              return Z_STREAM_ERROR;
            }
            if (wrap === 1) {
              strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
            }
            s.wrap = 0;
            if (dictLength >= s.w_size) {
              if (wrap === 0) {
                zero(s.head);
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
              tmpDict = new utils.Buf8(s.w_size);
              utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
              dictionary = tmpDict;
              dictLength = s.w_size;
            }
            avail = strm.avail_in;
            next = strm.next_in;
            input = strm.input;
            strm.avail_in = dictLength;
            strm.next_in = 0;
            strm.input = dictionary;
            fill_window(s);
            while (s.lookahead >= MIN_MATCH) {
              str = s.strstart;
              n = s.lookahead - (MIN_MATCH - 1);
              do {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
              } while (--n);
              s.strstart = str;
              s.lookahead = MIN_MATCH - 1;
              fill_window(s);
            }
            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.input = input;
            strm.avail_in = avail;
            s.wrap = wrap;
            return Z_OK;
          }
          exports.deflateInit = deflateInit;
          exports.deflateInit2 = deflateInit2;
          exports.deflateReset = deflateReset;
          exports.deflateResetKeep = deflateResetKeep;
          exports.deflateSetHeader = deflateSetHeader;
          exports.deflate = deflate;
          exports.deflateEnd = deflateEnd;
          exports.deflateSetDictionary = deflateSetDictionary;
          exports.deflateInfo = "pako deflate (from Nodeca project)";
        }, {
          "../utils/common": 41,
          "./adler32": 43,
          "./crc32": 45,
          "./messages": 51,
          "./trees": 52
        }],
        47: [function (require, module, exports) {
          function GZheader() {
            this.text = 0;
            this.time = 0;
            this.xflags = 0;
            this.os = 0;
            this.extra = null;
            this.extra_len = 0;
            this.name = "";
            this.comment = "";
            this.hcrc = 0;
            this.done = false;
          }
          module.exports = GZheader;
        }, {}],
        48: [function (require, module, exports) {
          var BAD = 30;
          var TYPE = 12;
          module.exports = function inflate_fast(strm, start) {
            var state;
            var _in;
            var last;
            var _out;
            var beg;
            var end;
            var dmax;
            var wsize;
            var whave;
            var wnext;
            var s_window;
            var hold;
            var bits;
            var lcode;
            var dcode;
            var lmask;
            var dmask;
            var here;
            var op;
            var len;
            var dist;
            var from;
            var from_source;
            var input, output;
            state = strm.state;
            _in = strm.next_in;
            input = strm.input;
            last = _in + (strm.avail_in - 5);
            _out = strm.next_out;
            output = strm.output;
            beg = _out - (start - strm.avail_out);
            end = _out + (strm.avail_out - 257);
            dmax = state.dmax;
            wsize = state.wsize;
            whave = state.whave;
            wnext = state.wnext;
            s_window = state.window;
            hold = state.hold;
            bits = state.bits;
            lcode = state.lencode;
            dcode = state.distcode;
            lmask = (1 << state.lenbits) - 1;
            dmask = (1 << state.distbits) - 1;
            top: do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen: for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist: for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
            } while (_in < last && _out < end);
            len = bits >> 3;
            _in -= len;
            bits -= len << 3;
            hold &= (1 << bits) - 1;
            strm.next_in = _in;
            strm.next_out = _out;
            strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
            strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
            state.hold = hold;
            state.bits = bits;
            return;
          };
        }, {}],
        49: [function (require, module, exports) {
          var utils = require("../utils/common");
          var adler32 = require("./adler32");
          var crc32 = require("./crc32");
          var inflate_fast = require("./inffast");
          var inflate_table = require("./inftrees");
          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          var Z_FINISH = 4;
          var Z_BLOCK = 5;
          var Z_TREES = 6;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_NEED_DICT = 2;
          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3;
          var Z_MEM_ERROR = -4;
          var Z_BUF_ERROR = -5;
          var Z_DEFLATED = 8;
          var HEAD = 1;
          var FLAGS = 2;
          var TIME = 3;
          var OS = 4;
          var EXLEN = 5;
          var EXTRA = 6;
          var NAME = 7;
          var COMMENT = 8;
          var HCRC = 9;
          var DICTID = 10;
          var DICT = 11;
          var TYPE = 12;
          var TYPEDO = 13;
          var STORED = 14;
          var COPY_ = 15;
          var COPY = 16;
          var TABLE = 17;
          var LENLENS = 18;
          var CODELENS = 19;
          var LEN_ = 20;
          var LEN = 21;
          var LENEXT = 22;
          var DIST = 23;
          var DISTEXT = 24;
          var MATCH = 25;
          var LIT = 26;
          var CHECK = 27;
          var LENGTH = 28;
          var DONE = 29;
          var BAD = 30;
          var MEM = 31;
          var SYNC = 32;
          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592;
          var MAX_WBITS = 15;
          var DEF_WBITS = MAX_WBITS;
          function zswap32(q) {
            return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
          }
          function InflateState() {
            this.mode = 0;
            this.last = false;
            this.wrap = 0;
            this.havedict = false;
            this.flags = 0;
            this.dmax = 0;
            this.check = 0;
            this.total = 0;
            this.head = null;
            this.wbits = 0;
            this.wsize = 0;
            this.whave = 0;
            this.wnext = 0;
            this.window = null;
            this.hold = 0;
            this.bits = 0;
            this.length = 0;
            this.offset = 0;
            this.extra = 0;
            this.lencode = null;
            this.distcode = null;
            this.lenbits = 0;
            this.distbits = 0;
            this.ncode = 0;
            this.nlen = 0;
            this.ndist = 0;
            this.have = 0;
            this.next = null;
            this.lens = new utils.Buf16(320);
            this.work = new utils.Buf16(288);
            this.lendyn = null;
            this.distdyn = null;
            this.sane = 0;
            this.back = 0;
            this.was = 0;
          }
          function inflateResetKeep(strm) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            strm.total_in = strm.total_out = state.total = 0;
            strm.msg = "";
            if (state.wrap) {
              strm.adler = state.wrap & 1;
            }
            state.mode = HEAD;
            state.last = 0;
            state.havedict = 0;
            state.dmax = 32768;
            state.head = null;
            state.hold = 0;
            state.bits = 0;
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
            state.sane = 1;
            state.back = -1;
            return Z_OK;
          }
          function inflateReset(strm) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            state.wsize = 0;
            state.whave = 0;
            state.wnext = 0;
            return inflateResetKeep(strm);
          }
          function inflateReset2(strm, windowBits) {
            var wrap;
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (windowBits < 0) {
              wrap = 0;
              windowBits = -windowBits;
            } else {
              wrap = (windowBits >> 4) + 1;
              if (windowBits < 48) {
                windowBits &= 15;
              }
            }
            if (windowBits && (windowBits < 8 || windowBits > 15)) {
              return Z_STREAM_ERROR;
            }
            if (state.window !== null && state.wbits !== windowBits) {
              state.window = null;
            }
            state.wrap = wrap;
            state.wbits = windowBits;
            return inflateReset(strm);
          }
          function inflateInit2(strm, windowBits) {
            var ret;
            var state;
            if (!strm) {
              return Z_STREAM_ERROR;
            }
            state = new InflateState();
            strm.state = state;
            state.window = null;
            ret = inflateReset2(strm, windowBits);
            if (ret !== Z_OK) {
              strm.state = null;
            }
            return ret;
          }
          function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
          }
          var virgin = true;
          var lenfix, distfix;
          function fixedtables(state) {
            if (virgin) {
              var sym;
              lenfix = new utils.Buf32(512);
              distfix = new utils.Buf32(32);
              sym = 0;
              while (sym < 144) {
                state.lens[sym++] = 8;
              }
              while (sym < 256) {
                state.lens[sym++] = 9;
              }
              while (sym < 280) {
                state.lens[sym++] = 7;
              }
              while (sym < 288) {
                state.lens[sym++] = 8;
              }
              inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
              });
              sym = 0;
              while (sym < 32) {
                state.lens[sym++] = 5;
              }
              inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
              });
              virgin = false;
            }
            state.lencode = lenfix;
            state.lenbits = 9;
            state.distcode = distfix;
            state.distbits = 5;
          }
          function updatewindow(strm, src, end, copy) {
            var dist;
            var state = strm.state;
            if (state.window === null) {
              state.wsize = 1 << state.wbits;
              state.wnext = 0;
              state.whave = 0;
              state.window = new utils.Buf8(state.wsize);
            }
            if (copy >= state.wsize) {
              utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
              state.wnext = 0;
              state.whave = state.wsize;
            } else {
              dist = state.wsize - state.wnext;
              if (dist > copy) {
                dist = copy;
              }
              utils.arraySet(state.window, src, end - copy, dist, state.wnext);
              copy -= dist;
              if (copy) {
                utils.arraySet(state.window, src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
              } else {
                state.wnext += dist;
                if (state.wnext === state.wsize) {
                  state.wnext = 0;
                }
                if (state.whave < state.wsize) {
                  state.whave += dist;
                }
              }
            }
            return 0;
          }
          function inflate(strm, flush) {
            var state;
            var input, output;
            var next;
            var put;
            var have, left;
            var hold;
            var bits;
            var _in, _out;
            var copy;
            var from;
            var from_source;
            var here = 0;
            var here_bits, here_op, here_val;
            var last_bits, last_op, last_val;
            var len;
            var ret;
            var hbuf = new utils.Buf8(4);
            var opts;
            var n;
            var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
            if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.mode === TYPE) {
              state.mode = TYPEDO;
            }
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            _in = have;
            _out = left;
            ret = Z_OK;
            inf_leave: for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(state.head.extra, input, next, copy, len);
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = {
                    bits: state.distbits
                  };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
              if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
            }
            _in -= strm.avail_in;
            _out -= strm.avail_out;
            strm.total_in += _in;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap && _out) {
              strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
            }
            strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
            if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
              ret = Z_BUF_ERROR;
            }
            return ret;
          }
          function inflateEnd(strm) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            var state = strm.state;
            if (state.window) {
              state.window = null;
            }
            strm.state = null;
            return Z_OK;
          }
          function inflateGetHeader(strm, head) {
            var state;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if ((state.wrap & 2) === 0) {
              return Z_STREAM_ERROR;
            }
            state.head = head;
            head.done = false;
            return Z_OK;
          }
          function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var state;
            var dictid;
            var ret;
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }
            state = strm.state;
            if (state.wrap !== 0 && state.mode !== DICT) {
              return Z_STREAM_ERROR;
            }
            if (state.mode === DICT) {
              dictid = 1;
              dictid = adler32(dictid, dictionary, dictLength, 0);
              if (dictid !== state.check) {
                return Z_DATA_ERROR;
              }
            }
            ret = updatewindow(strm, dictionary, dictLength, dictLength);
            if (ret) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
            state.havedict = 1;
            return Z_OK;
          }
          exports.inflateReset = inflateReset;
          exports.inflateReset2 = inflateReset2;
          exports.inflateResetKeep = inflateResetKeep;
          exports.inflateInit = inflateInit;
          exports.inflateInit2 = inflateInit2;
          exports.inflate = inflate;
          exports.inflateEnd = inflateEnd;
          exports.inflateGetHeader = inflateGetHeader;
          exports.inflateSetDictionary = inflateSetDictionary;
          exports.inflateInfo = "pako inflate (from Nodeca project)";
        }, {
          "../utils/common": 41,
          "./adler32": 43,
          "./crc32": 45,
          "./inffast": 48,
          "./inftrees": 50
        }],
        50: [function (require, module, exports) {
          var utils = require("../utils/common");
          var MAXBITS = 15;
          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592;
          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
          var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
          var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
          var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
          module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
            var bits = opts.bits;
            var len = 0;
            var sym = 0;
            var min = 0, max = 0;
            var root = 0;
            var curr = 0;
            var drop = 0;
            var left = 0;
            var used = 0;
            var huff = 0;
            var incr;
            var fill;
            var low;
            var mask;
            var next;
            var base = null;
            var base_index = 0;
            var end;
            var count = new utils.Buf16(MAXBITS + 1);
            var offs = new utils.Buf16(MAXBITS + 1);
            var extra = null;
            var extra_index = 0;
            var here_bits, here_op, here_val;
            for (len = 0; len <= MAXBITS; len++) {
              count[len] = 0;
            }
            for (sym = 0; sym < codes; sym++) {
              count[lens[lens_index + sym]]++;
            }
            root = bits;
            for (max = MAXBITS; max >= 1; max--) {
              if (count[max] !== 0) {
                break;
              }
            }
            if (root > max) {
              root = max;
            }
            if (max === 0) {
              table[table_index++] = 1 << 24 | 64 << 16 | 0;
              table[table_index++] = 1 << 24 | 64 << 16 | 0;
              opts.bits = 1;
              return 0;
            }
            for (min = 1; min < max; min++) {
              if (count[min] !== 0) {
                break;
              }
            }
            if (root < min) {
              root = min;
            }
            left = 1;
            for (len = 1; len <= MAXBITS; len++) {
              left <<= 1;
              left -= count[len];
              if (left < 0) {
                return -1;
              }
            }
            if (left > 0 && (type === CODES || max !== 1)) {
              return -1;
            }
            offs[1] = 0;
            for (len = 1; len < MAXBITS; len++) {
              offs[len + 1] = offs[len] + count[len];
            }
            for (sym = 0; sym < codes; sym++) {
              if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
              }
            }
            if (type === CODES) {
              base = extra = work;
              end = 19;
            } else if (type === LENS) {
              base = lbase;
              base_index -= 257;
              extra = lext;
              extra_index -= 257;
              end = 256;
            } else {
              base = dbase;
              extra = dext;
              end = -1;
            }
            huff = 0;
            sym = 0;
            len = min;
            next = table_index;
            curr = root;
            drop = 0;
            low = -1;
            used = 1 << root;
            mask = used - 1;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            for (; ; ) {
              here_bits = len - drop;
              if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
              } else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
              } else {
                here_op = 32 + 64;
                here_val = 0;
              }
              incr = 1 << len - drop;
              fill = 1 << curr;
              min = fill;
              do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
              } while (fill !== 0);
              incr = 1 << len - 1;
              while (huff & incr) {
                incr >>= 1;
              }
              if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
              } else {
                huff = 0;
              }
              sym++;
              if (--count[len] === 0) {
                if (len === max) {
                  break;
                }
                len = lens[lens_index + work[sym]];
              }
              if (len > root && (huff & mask) !== low) {
                if (drop === 0) {
                  drop = root;
                }
                next += min;
                curr = len - drop;
                left = 1 << curr;
                while (curr + drop < max) {
                  left -= count[curr + drop];
                  if (left <= 0) {
                    break;
                  }
                  curr++;
                  left <<= 1;
                }
                used += 1 << curr;
                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                  return 1;
                }
                low = huff & mask;
                table[low] = root << 24 | curr << 16 | next - table_index | 0;
              }
            }
            if (huff !== 0) {
              table[next + huff] = len - drop << 24 | 64 << 16 | 0;
            }
            opts.bits = root;
            return 0;
          };
        }, {
          "../utils/common": 41
        }],
        51: [function (require, module, exports) {
          module.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
          };
        }, {}],
        52: [function (require, module, exports) {
          var utils = require("../utils/common");
          var Z_FIXED = 4;
          var Z_BINARY = 0;
          var Z_TEXT = 1;
          var Z_UNKNOWN = 2;
          function zero(buf) {
            var len = buf.length;
            while (--len >= 0) {
              buf[len] = 0;
            }
          }
          var STORED_BLOCK = 0;
          var STATIC_TREES = 1;
          var DYN_TREES = 2;
          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          var LENGTH_CODES = 29;
          var LITERALS = 256;
          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          var D_CODES = 30;
          var BL_CODES = 19;
          var HEAP_SIZE = 2 * L_CODES + 1;
          var MAX_BITS = 15;
          var Buf_size = 16;
          var MAX_BL_BITS = 7;
          var END_BLOCK = 256;
          var REP_3_6 = 16;
          var REPZ_3_10 = 17;
          var REPZ_11_138 = 18;
          var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
          var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
          var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
          var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          var DIST_CODE_LEN = 512;
          var static_ltree = new Array((L_CODES + 2) * 2);
          zero(static_ltree);
          var static_dtree = new Array(D_CODES * 2);
          zero(static_dtree);
          var _dist_code = new Array(DIST_CODE_LEN);
          zero(_dist_code);
          var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
          zero(_length_code);
          var base_length = new Array(LENGTH_CODES);
          zero(base_length);
          var base_dist = new Array(D_CODES);
          zero(base_dist);
          function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree;
            this.extra_bits = extra_bits;
            this.extra_base = extra_base;
            this.elems = elems;
            this.max_length = max_length;
            this.has_stree = static_tree && static_tree.length;
          }
          var static_l_desc;
          var static_d_desc;
          var static_bl_desc;
          function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree;
            this.max_code = 0;
            this.stat_desc = stat_desc;
          }
          function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
          }
          function put_short(s, w) {
            s.pending_buf[s.pending++] = w & 255;
            s.pending_buf[s.pending++] = w >>> 8 & 255;
          }
          function send_bits(s, value, length) {
            if (s.bi_valid > Buf_size - length) {
              s.bi_buf |= value << s.bi_valid & 65535;
              put_short(s, s.bi_buf);
              s.bi_buf = value >> Buf_size - s.bi_valid;
              s.bi_valid += length - Buf_size;
            } else {
              s.bi_buf |= value << s.bi_valid & 65535;
              s.bi_valid += length;
            }
          }
          function send_code(s, c, tree) {
            send_bits(s, tree[c * 2], tree[c * 2 + 1]);
          }
          function bi_reverse(code, len) {
            var res = 0;
            do {
              res |= code & 1;
              code >>>= 1;
              res <<= 1;
            } while (--len > 0);
            return res >>> 1;
          }
          function bi_flush(s) {
            if (s.bi_valid === 16) {
              put_short(s, s.bi_buf);
              s.bi_buf = 0;
              s.bi_valid = 0;
            } else if (s.bi_valid >= 8) {
              s.pending_buf[s.pending++] = s.bi_buf & 255;
              s.bi_buf >>= 8;
              s.bi_valid -= 8;
            }
          }
          function gen_bitlen(s, desc) {
            var tree = desc.dyn_tree;
            var max_code = desc.max_code;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var extra = desc.stat_desc.extra_bits;
            var base = desc.stat_desc.extra_base;
            var max_length = desc.stat_desc.max_length;
            var h;
            var n, m;
            var bits;
            var xbits;
            var f;
            var overflow = 0;
            for (bits = 0; bits <= MAX_BITS; bits++) {
              s.bl_count[bits] = 0;
            }
            tree[s.heap[s.heap_max] * 2 + 1] = 0;
            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
              n = s.heap[h];
              bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
              if (bits > max_length) {
                bits = max_length;
                overflow++;
              }
              tree[n * 2 + 1] = bits;
              if (n > max_code) {
                continue;
              }
              s.bl_count[bits]++;
              xbits = 0;
              if (n >= base) {
                xbits = extra[n - base];
              }
              f = tree[n * 2];
              s.opt_len += f * (bits + xbits);
              if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1] + xbits);
              }
            }
            if (overflow === 0) {
              return;
            }
            do {
              bits = max_length - 1;
              while (s.bl_count[bits] === 0) {
                bits--;
              }
              s.bl_count[bits]--;
              s.bl_count[bits + 1] += 2;
              s.bl_count[max_length]--;
              overflow -= 2;
            } while (overflow > 0);
            for (bits = max_length; bits !== 0; bits--) {
              n = s.bl_count[bits];
              while (n !== 0) {
                m = s.heap[--h];
                if (m > max_code) {
                  continue;
                }
                if (tree[m * 2 + 1] !== bits) {
                  s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                  tree[m * 2 + 1] = bits;
                }
                n--;
              }
            }
          }
          function gen_codes(tree, max_code, bl_count) {
            var next_code = new Array(MAX_BITS + 1);
            var code = 0;
            var bits;
            var n;
            for (bits = 1; bits <= MAX_BITS; bits++) {
              next_code[bits] = code = code + bl_count[bits - 1] << 1;
            }
            for (n = 0; n <= max_code; n++) {
              var len = tree[n * 2 + 1];
              if (len === 0) {
                continue;
              }
              tree[n * 2] = bi_reverse(next_code[len]++, len);
            }
          }
          function tr_static_init() {
            var n;
            var bits;
            var length;
            var code;
            var dist;
            var bl_count = new Array(MAX_BITS + 1);
            length = 0;
            for (code = 0; code < LENGTH_CODES - 1; code++) {
              base_length[code] = length;
              for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
              }
            }
            _length_code[length - 1] = code;
            dist = 0;
            for (code = 0; code < 16; code++) {
              base_dist[code] = dist;
              for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
              }
            }
            dist >>= 7;
            for (; code < D_CODES; code++) {
              base_dist[code] = dist << 7;
              for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
              }
            }
            for (bits = 0; bits <= MAX_BITS; bits++) {
              bl_count[bits] = 0;
            }
            n = 0;
            while (n <= 143) {
              static_ltree[n * 2 + 1] = 8;
              n++;
              bl_count[8]++;
            }
            while (n <= 255) {
              static_ltree[n * 2 + 1] = 9;
              n++;
              bl_count[9]++;
            }
            while (n <= 279) {
              static_ltree[n * 2 + 1] = 7;
              n++;
              bl_count[7]++;
            }
            while (n <= 287) {
              static_ltree[n * 2 + 1] = 8;
              n++;
              bl_count[8]++;
            }
            gen_codes(static_ltree, L_CODES + 1, bl_count);
            for (n = 0; n < D_CODES; n++) {
              static_dtree[n * 2 + 1] = 5;
              static_dtree[n * 2] = bi_reverse(n, 5);
            }
            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
          }
          function init_block(s) {
            var n;
            for (n = 0; n < L_CODES; n++) {
              s.dyn_ltree[n * 2] = 0;
            }
            for (n = 0; n < D_CODES; n++) {
              s.dyn_dtree[n * 2] = 0;
            }
            for (n = 0; n < BL_CODES; n++) {
              s.bl_tree[n * 2] = 0;
            }
            s.dyn_ltree[END_BLOCK * 2] = 1;
            s.opt_len = s.static_len = 0;
            s.last_lit = s.matches = 0;
          }
          function bi_windup(s) {
            if (s.bi_valid > 8) {
              put_short(s, s.bi_buf);
            } else if (s.bi_valid > 0) {
              s.pending_buf[s.pending++] = s.bi_buf;
            }
            s.bi_buf = 0;
            s.bi_valid = 0;
          }
          function copy_block(s, buf, len, header) {
            bi_windup(s);
            if (header) {
              put_short(s, len);
              put_short(s, ~len);
            }
            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
            s.pending += len;
          }
          function smaller(tree, n, m, depth) {
            var _n2 = n * 2;
            var _m2 = m * 2;
            return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
          }
          function pqdownheap(s, tree, k) {
            var v = s.heap[k];
            var j = k << 1;
            while (j <= s.heap_len) {
              if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
              }
              if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
              }
              s.heap[k] = s.heap[j];
              k = j;
              j <<= 1;
            }
            s.heap[k] = v;
          }
          function compress_block(s, ltree, dtree) {
            var dist;
            var lc;
            var lx = 0;
            var code;
            var extra;
            if (s.last_lit !== 0) {
              do {
                dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                lc = s.pending_buf[s.l_buf + lx];
                lx++;
                if (dist === 0) {
                  send_code(s, lc, ltree);
                } else {
                  code = _length_code[lc];
                  send_code(s, code + LITERALS + 1, ltree);
                  extra = extra_lbits[code];
                  if (extra !== 0) {
                    lc -= base_length[code];
                    send_bits(s, lc, extra);
                  }
                  dist--;
                  code = d_code(dist);
                  send_code(s, code, dtree);
                  extra = extra_dbits[code];
                  if (extra !== 0) {
                    dist -= base_dist[code];
                    send_bits(s, dist, extra);
                  }
                }
              } while (lx < s.last_lit);
            }
            send_code(s, END_BLOCK, ltree);
          }
          function build_tree(s, desc) {
            var tree = desc.dyn_tree;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var elems = desc.stat_desc.elems;
            var n, m;
            var max_code = -1;
            var node;
            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;
            for (n = 0; n < elems; n++) {
              if (tree[n * 2] !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
              } else {
                tree[n * 2 + 1] = 0;
              }
            }
            while (s.heap_len < 2) {
              node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
              tree[node * 2] = 1;
              s.depth[node] = 0;
              s.opt_len--;
              if (has_stree) {
                s.static_len -= stree[node * 2 + 1];
              }
            }
            desc.max_code = max_code;
            for (n = s.heap_len >> 1; n >= 1; n--) {
              pqdownheap(s, tree, n);
            }
            node = elems;
            do {
              n = s.heap[1];
              s.heap[1] = s.heap[s.heap_len--];
              pqdownheap(s, tree, 1);
              m = s.heap[1];
              s.heap[--s.heap_max] = n;
              s.heap[--s.heap_max] = m;
              tree[node * 2] = tree[n * 2] + tree[m * 2];
              s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
              tree[n * 2 + 1] = tree[m * 2 + 1] = node;
              s.heap[1] = node++;
              pqdownheap(s, tree, 1);
            } while (s.heap_len >= 2);
            s.heap[--s.heap_max] = s.heap[1];
            gen_bitlen(s, desc);
            gen_codes(tree, max_code, s.bl_count);
          }
          function scan_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }
            tree[(max_code + 1) * 2 + 1] = 65535;
            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1];
              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                s.bl_tree[curlen * 2] += count;
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  s.bl_tree[curlen * 2]++;
                }
                s.bl_tree[REP_3_6 * 2]++;
              } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2]++;
              } else {
                s.bl_tree[REPZ_11_138 * 2]++;
              }
              count = 0;
              prevlen = curlen;
              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          function send_tree(s, tree, max_code) {
            var n;
            var prevlen = -1;
            var curlen;
            var nextlen = tree[0 * 2 + 1];
            var count = 0;
            var max_count = 7;
            var min_count = 4;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }
            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1];
              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                do {
                  send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  send_code(s, curlen, s.bl_tree);
                  count--;
                }
                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
              } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
              } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
              }
              count = 0;
              prevlen = curlen;
              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          function build_bl_tree(s) {
            var max_blindex;
            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
            build_tree(s, s.bl_desc);
            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
              if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                break;
              }
            }
            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
            return max_blindex;
          }
          function send_all_trees(s, lcodes, dcodes, blcodes) {
            var rank;
            send_bits(s, lcodes - 257, 5);
            send_bits(s, dcodes - 1, 5);
            send_bits(s, blcodes - 4, 4);
            for (rank = 0; rank < blcodes; rank++) {
              send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
            }
            send_tree(s, s.dyn_ltree, lcodes - 1);
            send_tree(s, s.dyn_dtree, dcodes - 1);
          }
          function detect_data_type(s) {
            var black_mask = 4093624447;
            var n;
            for (n = 0; n <= 31; (n++, black_mask >>>= 1)) {
              if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
                return Z_BINARY;
              }
            }
            if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
              return Z_TEXT;
            }
            for (n = 32; n < LITERALS; n++) {
              if (s.dyn_ltree[n * 2] !== 0) {
                return Z_TEXT;
              }
            }
            return Z_BINARY;
          }
          var static_init_done = false;
          function _tr_init(s) {
            if (!static_init_done) {
              tr_static_init();
              static_init_done = true;
            }
            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
            s.bi_buf = 0;
            s.bi_valid = 0;
            init_block(s);
          }
          function _tr_stored_block(s, buf, stored_len, last) {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
            copy_block(s, buf, stored_len, true);
          }
          function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
          }
          function _tr_flush_block(s, buf, stored_len, last) {
            var opt_lenb, static_lenb;
            var max_blindex = 0;
            if (s.level > 0) {
              if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
              }
              build_tree(s, s.l_desc);
              build_tree(s, s.d_desc);
              max_blindex = build_bl_tree(s);
              opt_lenb = s.opt_len + 3 + 7 >>> 3;
              static_lenb = s.static_len + 3 + 7 >>> 3;
              if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
              }
            } else {
              opt_lenb = static_lenb = stored_len + 5;
            }
            if (stored_len + 4 <= opt_lenb && buf !== -1) {
              _tr_stored_block(s, buf, stored_len, last);
            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
              send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
              compress_block(s, static_ltree, static_dtree);
            } else {
              send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
              send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
              compress_block(s, s.dyn_ltree, s.dyn_dtree);
            }
            init_block(s);
            if (last) {
              bi_windup(s);
            }
          }
          function _tr_tally(s, dist, lc) {
            s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
            s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
            s.last_lit++;
            if (dist === 0) {
              s.dyn_ltree[lc * 2]++;
            } else {
              s.matches++;
              dist--;
              s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
              s.dyn_dtree[d_code(dist) * 2]++;
            }
            return s.last_lit === s.lit_bufsize - 1;
          }
          exports._tr_init = _tr_init;
          exports._tr_stored_block = _tr_stored_block;
          exports._tr_flush_block = _tr_flush_block;
          exports._tr_tally = _tr_tally;
          exports._tr_align = _tr_align;
        }, {
          "../utils/common": 41
        }],
        53: [function (require, module, exports) {
          function ZStream() {
            this.input = null;
            this.next_in = 0;
            this.avail_in = 0;
            this.total_in = 0;
            this.output = null;
            this.next_out = 0;
            this.avail_out = 0;
            this.total_out = 0;
            this.msg = "";
            this.state = null;
            this.data_type = 2;
            this.adler = 0;
          }
          module.exports = ZStream;
        }, {}],
        54: [function (require, module, exports) {
          module.exports = typeof setImmediate === "function" ? setImmediate : function setImmediate() {
            var args = [].slice.apply(arguments);
            args.splice(1, 0, 0);
            setTimeout.apply(null, args);
          };
        }, {}]
      }, {}, [10])(10);
    });
  });

  var FileSaver_min = createCommonjsModule(function (module, exports) {
  (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


  });

  /**
   * Copyright (c) 2009 Sergiy Kovalchuk (serg472@gmail.com)
   *
   * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
   * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
   *
   * Following code is based on Element.mask() implementation from ExtJS framework (http://extjs.com/)
   *
   */
  (function ($) {
    /**
     * Displays loading mask over selected element(s). Accepts both single and multiple selectors.
     *
     * @param label Text message that will be displayed on top of the mask besides a spinner (optional).
     * 				If not provided only mask will be displayed without a label or a spinner.
     * @param delay Delay in milliseconds before element is masked (optional). If unmask() is called
     *              before the delay times out, no mask is displayed. This can be used to prevent unnecessary
     *              mask display for quick processes.
     */
    $.fn.mask = function (label, delay) {
      $(this).each(function () {
        if (delay !== undefined && delay > 0) {
          var element = $(this);
          element.data("_mask_timeout", setTimeout(function () {
            $.maskElement(element, label);
          }, delay));
        } else {
          $.maskElement($(this), label);
        }
      });
    };
    /**
     * Removes mask from the element(s). Accepts both single and multiple selectors.
     */


    $.fn.unmask = function () {
      $(this).each(function () {
        $.unmaskElement($(this));
      });
    };
    /**
     * Checks if a single element is masked. Returns false if mask is delayed or not displayed.
     */


    $.fn.isMasked = function () {
      return this.hasClass("masked");
    };

    $.maskElement = function (element, label) {
      //if this element has delayed mask scheduled then remove it and display the new one
      if (element.data("_mask_timeout") !== undefined) {
        clearTimeout(element.data("_mask_timeout"));
        element.removeData("_mask_timeout");
      }

      if (element.isMasked()) {
        $.unmaskElement(element);
      }

      if (element.css("position") == "static") {
        element.addClass("masked-relative");
      }

      element.addClass("masked");
      var maskDiv = $("<div class=\"loadmask\"></div>"); //auto height fix for IE

      if (navigator.userAgent.toLowerCase().indexOf("msie") > -1) {
        maskDiv.height(element.height() + parseInt(element.css("padding-top")) + parseInt(element.css("padding-bottom")));
        maskDiv.width(element.width() + parseInt(element.css("padding-left")) + parseInt(element.css("padding-right")));
      } //fix for z-index bug with selects in IE6


      if (navigator.userAgent.toLowerCase().indexOf("msie 6") > -1) {
        element.find("select").addClass("masked-hidden");
      }

      element.append(maskDiv);

      if (label !== undefined) {
        var maskMsgDiv = $("<div class=\"loadmask-msg\" style=\"display:none;\"></div>");
        maskMsgDiv.append("<div>" + label + "</div>");
        element.append(maskMsgDiv); //calculate center position

        maskMsgDiv.css("top", Math.round(element.height() / 2 - (maskMsgDiv.height() - parseInt(maskMsgDiv.css("padding-top")) - parseInt(maskMsgDiv.css("padding-bottom"))) / 2) + "px");
        maskMsgDiv.css("left", Math.round(element.width() / 2 - (maskMsgDiv.width() - parseInt(maskMsgDiv.css("padding-left")) - parseInt(maskMsgDiv.css("padding-right"))) / 2) + "px");
        maskMsgDiv.show();
      }
    };

    $.unmaskElement = function (element) {
      //if this element has delayed mask scheduled then remove it
      if (element.data("_mask_timeout") !== undefined) {
        clearTimeout(element.data("_mask_timeout"));
        element.removeData("_mask_timeout");
      }

      element.find(".loadmask-msg,.loadmask").remove();
      element.removeClass("masked");
      element.removeClass("masked-relative");
      element.find("select").removeClass("masked-hidden");
    };
  })($__default['default']);

  /*******************************************************************************
   * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  let self$5, mizarAPI$6, layers, availableLayers;
  /**************************************************************************************************************/

  /**
   *    Keep only layers having available searching services
   */

  function filterServicesAvailableOnLayers() {
    availableLayers = [];

    _$1.each(layers, function (layer) {
      if (layer.isVisible() && layer.category !== "Other" && layer.category !== "Solar System" && layer.getName() !== "SAMP" && layer.getName() !== "Planets") {
        layer.layerId = _$1.uniqueId("layer_");
        availableLayers.push(layer);
      }
    });

    return availableLayers;
  }
  /**************************************************************************************************************/

  /**
   * Export data included in the passed coordinates selection
   *
   * @param event.data = coordinates
   */


  function exportSelection(event) {
    self$5.coordinates = event.data;
    $__default['default']("body").mask("Exporting data..."); // creating empty archive

    const zip = new jszip(); // getting all visible and displayed layers

    const backgroundLayers = [];
    const dataLayers = [];

    _$1.each(availableLayers, function (layer) {
      if ($__default['default']("#" + layer.layerId).is(":checked")) {
        if (layer.getType() === Constants.LAYER.OpenSearch || layer.getType() === Constants.LAYER.GeoJSON) {
          //if (layer.type === "DynamicOpenSearch") {
          dataLayers.push(layer);
        } else if (layer.getType() === Constants.LAYER.Hips || layer.getType() === Constants.LAYER.HipsCat) {
          backgroundLayers.push(layer);
        }
      }
    }); // Adding a middle point the bbox to be sure no data/image will be omitted


    const middlePoint = [(self$5.coordinates[0][1] + self$5.coordinates[1][1]) / 2, (self$5.coordinates[0][0] + self$5.coordinates[3][0]) / 2, 0];
    self$5.coordinates.push(middlePoint); // getting data url from layer using tile and bbox coordinates

    const tileLayerFeatures = [];

    _$1.each(dataLayers, function (dataLayer, index) {
      for (let i = 0; i < self$5.coordinates.length; i++) {
        const tile = mizarAPI$6.getActivatedContext().getTileManager().getVisibleTile(self$5.coordinates[i][0], self$5.coordinates[i][1]);

        if (_$1.isEmpty(tile)) {
          return;
        }

        const osData = tile.extension[dataLayer.extId];

        if (!_$1.isEmpty(osData) && !_$1.isEmpty(osData.featureIds)) {
          _$1.each(osData.featureIds, function (fId) {
            const featureSet = dataLayer.featuresSet[fId];

            if (!_$1.isEmpty(featureSet)) {
              const feature = dataLayer.features[featureSet.index];
              let isIncluded = true;

              switch (feature.geometry.type) {
                case Constants.GEOMETRY.Point:
                  isIncluded = self$5.checkIfPointInBbox(feature.geometry.coordinates, self$5.coordinates);
                  break;

                case Constants.GEOMETRY.Polygon:
                  for (let i = 0; i < feature.geometry.coordinates.length; i++) {
                    if (!isIncluded) {
                      return;
                    }

                    isIncluded = self$5.checkIfPointInBbox(feature.geometry.coordinates[0][i], self$5.coordinates);
                  }

                  break;
              }

              if (isIncluded) {
                // Adding layer information in order to rank data in archive
                feature.parentInformation = {
                  copyright: dataLayer.copyright || "",
                  copyrightUrl: dataLayer.copyrightUrl || "",
                  category: dataLayer.category,
                  name: dataLayer.name
                };
                tileLayerFeatures.push(feature);
              }
            }
          });
        }
      }
    }); // Adding features archive


    _$1.each(tileLayerFeatures, function (feature) {
      const folder = zip.folder(feature.parentInformation.category + "/" + feature.parentInformation.name); // Adding a copyright file into each folder

      if (!_$1.isEmpty(feature.parentInformation.copyright) || !_$1.isEmpty(feature.parentInformation.copyrightUrl)) {
        const copyright = "Copyright : " + feature.parentInformation.copyright + " - link : " + feature.parentInformation.copyrightUrl;
        folder.file(feature.parentInformation.name + ".txt", copyright);
      }

      const featureToStringify = {
        geometry: {
          coordinates: feature.geometry.coordinates,
          gid: feature.geometry.gid,
          type: feature.geometry.type,
          crs: {
            type: "name",
            properties: {
              name: mizarAPI$6.getCrs().getGeoideName()
            }
          }
        },
        id: feature.id,
        properties: feature.properties,
        type: feature.type
      };
      folder.file(feature.properties.identifier + ".json", JSON.stringify(featureToStringify, null, "\t"));
    });

    if (backgroundLayers.length === 0) {
      self$5.downloadArchive(zip);
    } else {
      let numberOfImages = 0;
      let imageNotFound = false; // get images url from Background layer

      _$1.each(backgroundLayers, function (backgroundLayer, index) {
        backgroundLayer.urlImages = [];
        backgroundLayer.images = [];

        for (let i = 0; i < self$5.coordinates.length; i++) {
          // Retrieve the tile according to a
          const tile = mizarAPI$6.getActivatedContext().getTileManager().getVisibleTile(self$5.coordinates[i][0], self$5.coordinates[i][1]);

          if (_$1.isEmpty(tile)) {
            return;
          }

          numberOfImages++;
          const url = backgroundLayer.getUrl(tile);
          const image = new Image();
          image.aborted = false;
          image.crossOrigin = "";
          image.backgroundName = backgroundLayer.name;
          image.parentFolder = backgroundLayer.category + "/" + backgroundLayer.name + "/images";
          image.imageName = url.substring(url.lastIndexOf("/") + 1, url.length);

          image.onload = function () {
            self$5.addImageToArchive(this, zip);
            numberOfImages--;

            if (numberOfImages == 0) {
              self$5.downloadArchive(zip);
            }
          };

          image.onerror = function () {
            imageNotFound = true;
            ErrorDialog.open(Constants.LEVEL.WARNING, "Error while retrieving image : " + this.imageName);
            numberOfImages--;

            if (numberOfImages == 0) {
              if (imageNotFound) {
                ErrorDialog.open(Constants.LEVEL.WARNING, "Some images not found", "Change zoom level and retry download");
              }

              self$5.downloadArchive(zip);
            }
          };

          image.src = Proxy.proxify(url);
        }
      });
    }
  }
  /**************************************************************************************************************/

  /**
   * Create a zip file containing data + readme file and download it
   *
   * @param zip
   */


  function downloadArchive(zip) {
    const date = new Date();
    const currentDate = $__default['default'].datepicker.formatDate("yy/mm/dd " + date.getHours() + ":" + date.getMinutes(), date);
    const readme = "Date : " + currentDate + "\n" + "Query :" + JSON.stringify(self$5.coordinates, null, "\t") + "\n" + "Copyright : Generated by MIZAR";
    zip.file("README.txt", readme);
    const content = zip.generate({
      type: "blob"
    });
    FileSaver_min.saveAs(content, "archive_" + currentDate + ".zip");
    $__default['default']("body").unmask();
  }
  /**************************************************************************************************************/

  /**
   * Add an image into the passed archive
   * @param img
   * @param zip
   */


  function addImageToArchive(img, zip) {
    const folder = zip.folder(img.parentFolder);
    folder.file(img.imageName, self$5.getBase64Image(img), {
      base64: true
    });
  }
  /**************************************************************************************************************/

  /**
   * Convert an image into base64
   * @param img
   * @returns {string}
   */


  function getBase64Image(img) {
    // Create an empty canvas element
    const canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height; // Copy the image contents to the canvas

    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0); // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.

    const dataURL = canvas.toDataURL("image/png");
    return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
  }
  /**************************************************************************************************************/


  var ExportToolCore = {
    /**
     *    @constructor
     *    @param options Configuration options
     *        <ul>
     *            <li>planet: planet</li>
     *            <li>layers: Layers</li>
     *        </ul>
     */
    init: function (mizar, options) {
      // Required options
      mizarAPI$6 = mizar;
      layers = mizarAPI$6.getLayers(Constants.CONTEXT.Sky);
      self$5 = this;
    },
    exportSelection: exportSelection,
    addImageToArchive: addImageToArchive,
    downloadArchive: downloadArchive,
    getBase64Image: getBase64Image,
    filterServicesAvailableOnLayers: filterServicesAvailableOnLayers
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**************************************************************************************************************/

  /**
   * @name AbstractNameResolverer
   * @class
   * Abstract Wrapper constructor
   * @param {Context} options - Context
   * @implements {NameResolver}
   */
  var AbstractNameResolver = function (options) {
    this.ctx = options;
  };
  /**************************************************************************************************************/

  /**
   * @function handle
   * @memberof AbstractNameResolver#
   * @abstract
   */


  AbstractNameResolver.prototype.handle = function (options) {
    throw new SyntaxError("AbstractNameResolver.js: handle from NameResolver not implemented");
  };
  /**
   * @function remove
   * @memberof AbstractNameResolver#
   * @abstract
   */


  AbstractNameResolver.prototype.remove = function () {
    throw new SyntaxError("AbstractNameResolver.js: remove from NameResolver not implemented");
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @name DefaultNameResolver
   * @class
   *  Plugin to access to default name resolver
   * @augments AbstractNameResolver
   * @param {Context} options - Context
   * @memberof module:NameResolver
   * @constructor
   */

  var DefaultNameResolver = function (options) {
    AbstractNameResolver.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractNameResolver, DefaultNameResolver);
  /**************************************************************************************************************/

  /**
   * Convert passed url into an url understandable by the service (input transformer)
   * @function handle
   * @memberof DefaultNameResolver#
   */

  DefaultNameResolver.prototype.handle = function (options) {
    var context = this.ctx;
    var objectName = options.objectName;
    var onError = options.onError;
    var onComplete = options.onComplete;
    var onSuccess = options.onSuccess;
    var searchLayer = options.searchLayer;
    var zoomTo = options.zoomTo;
    var url = context.getMizarConfiguration().nameResolver.baseUrl + "/" + objectName + "/EQUATORIAL";
    Utils.requestUrl(url, "text", "text/plain", null, function (response) {
      // Check if response contains features
      if (response.type === "FeatureCollection") {
        var firstFeature = response.features[0];

        var zoomToCallback = function () {
          searchLayer(objectName, onSuccess, onError, response);
        };

        zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], null, zoomToCallback, response);
      } else {
        onError();
      }
    }, function (err) {
      searchLayer(objectName, onSuccess, onError);
    }, function (xhr, textStatus) {
      if (onComplete) {
        onComplete(xhr);
      }
    });
  };
  /**
   * @function remove
   * @memberof DefaultNameResolver#
   */


  DefaultNameResolver.prototype.remove = function () {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @name CDSNameResolver
   * @class
   *  Plugin to access to CDS name resolver
   * @augments AbstractNameResolver
   * @param {Context} options - Context
   * @memberof module:NameResolver
   * @constructor
   */

  var CDSNameResolver = function (options) {
    AbstractNameResolver.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractNameResolver, CDSNameResolver);
  /**************************************************************************************************************/

  /**
   * Queries CDS using this URL : http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?<i>objectName</i>
   * and the layers
   * @function handle
   * @memberof CDSNameResolver#
   */

  CDSNameResolver.prototype.handle = function (options) {
    var objectName = options.objectName;
    var onError = options.onError;
    var onComplete = options.onComplete;
    var onSuccess = options.onSuccess;
    var searchLayer = options.searchLayer;
    var zoomTo = options.zoomTo;
    var url = "http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?" + objectName;
    Utils.requestUrl(url, "xml", "application/xml", null, function (xmlResponse) {
      var target = $__default['default'](xmlResponse).find("Target");
      var name = $__default['default'](target).find("name").text();
      var features = [];
      $__default['default'](target).find("Resolver").each(function (index) {
        var resolver = this;
        var ra = $__default['default'](resolver).find("jradeg");
        var dec = $__default['default'](resolver).find("jdedeg");

        if (!_$1.isEmpty(ra.text()) && !_$1.isEmpty(dec.text())) {
          ra = parseFloat(ra.text());
          dec = parseFloat(dec.text());
          var feature = {};
          feature.ra = ra;
          feature.dec = dec;
          feature.credit = $__default['default'](resolver).attr("name");
          features.push(feature);
        }
      });
      var response = {
        totalResults: features.length,
        type: "FeatureCollection",
        features: []
      };

      _$1.each(features, function (feature) {
        response.features.push({
          type: "Feature",
          geometry: {
            coordinates: [feature.ra, feature.dec],
            type: Constants.GEOMETRY.Point,
            crs: {
              type: "name",
              properties: {
                name: Constants.CRS.Equatorial
              }
            }
          },
          properties: {
            identifier: "CDS0",
            name: name,
            credits: 'Powered by <a href="http://cdsweb.u-strasbg.fr/cgi-bin/Sesame">Sesame API</a> (' + feature.credit + ")"
          }
        });
      }); // Check if response contains features


      if (response.type === "FeatureCollection" && response.features.length > 0) {
        var firstFeature = response.features[0];

        var zoomToCallback = function () {
          searchLayer(objectName, onSuccess, onError, response);
        };

        zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], null, Constants.CRS.Equatorial, zoomToCallback, response);
      } else {
        searchLayer(objectName, onSuccess, onError, response);
      }
    }, function (err) {
      searchLayer(objectName, onSuccess, onError);
    }, function (xhr, textStatus) {
      if (onComplete) {
        onComplete(xhr);
      }
    });
  };
  /**
   * @function remove
   * @memberof CDSNameResolver#
   */


  CDSNameResolver.prototype.remove = function () {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var dictionary;
  /**
   * In case if base url isn't a service but a json containing all known places
   * this method allows to retrieve it
   */

  var retrieveDictionary = function (context) {
    var containsDictionary = context.getContextConfiguration().nameResolver.baseUrl.indexOf("json") >= 0;

    if (containsDictionary) {
      // Dictionary as json
      var marsResolverUrl = context.getContextConfiguration().nameResolver.baseUrl;
      Utils.requestUrl(marsResolverUrl, "json", "application/json", null, function (response) {
        dictionary = response;
      }, function (err) {
        ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + marsResolverUrl, err);
      });
    } else {
      dictionary = null;
    }
  };
  /**************************************************************************************************************/

  /**
   * @name DictionaryNameResolver
   * @class
   *      Plugin to access to the dictionary name resolver
   * @augments AbstractNameResolver
   * @param {Context} options - Configuration properties
   * @memberof module:NameResolver
   * @constructor
   */


  var DictionaryNameResolver = function (options) {
    AbstractNameResolver.prototype.constructor.call(this, options);
    retrieveDictionary(options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractNameResolver, DictionaryNameResolver);

  function _computeDistance(pt1, pt2) {
    var pt = [parseFloat(pt2[0]) - parseFloat(pt1[0]), parseFloat(pt2[1]) - parseFloat(pt1[1])];
    return Math.sqrt(pt[0] * pt[0] + pt[1] * pt[1]);
  }

  function _farestDistance(center, pts) {
    var distance = 0;

    for (var i = 0; i < pts.length; i++) {
      var newDistance = _computeDistance.call(this, center, pts[i]);

      if (newDistance > distance) {
        distance = newDistance;
      }
    }

    return distance;
  }

  function _computeFarestDistanceAlongLineString(center, pts) {
    return _farestDistance.call(this, center, pts);
  }

  function _addPoint(p1, p2) {
    return [parseFloat(p1[0]) + parseFloat(p2[0]), parseFloat(p1[1]) + parseFloat(p2[1])];
  }

  function _computeLineStringBarycenter(pts) {
    var center = pts[0];

    for (var i = 1; i < pts.length; i++) {
      center = _addPoint.call(this, center, pts[i]);
    }

    center = [center[0] / pts.length, center[1] / pts.length];
    return center;
  }

  function _computeBarycenterAndDistance(geometry) {
    var type = geometry.type;
    var coordinates = geometry.coordinates;
    var center;
    var distance;
    var nbPts = null;
    var tmpCenter = null;
    var newDistance = null;

    switch (type) {
      case "Point":
        center = coordinates;
        distance = null;
        break;

      case "LineString":
        center = _computeLineStringBarycenter.call(this, coordinates);
        distance = _computeFarestDistanceAlongLineString.call(this, center, coordinates);
        break;

      case "Polygon":
        var exteriorRing = coordinates[0];
        center = _computeLineStringBarycenter.call(this, exteriorRing);
        distance = _computeFarestDistanceAlongLineString.call(this, center, exteriorRing);
        break;

      case "MultiPoint":
        center = _computeLineStringBarycenter.call(this, coordinates);
        distance = _computeFarestDistanceAlongLineString.call(this, center, coordinates);
        break;

      case "MultiLineString":
        var lineStringArray = coordinates[0];
        center = _computeLineStringBarycenter.call(this, lineStringArray[0]);
        center[0] = center[0] * lineStringArray[0].length;
        center[1] = center[1] * lineStringArray[0].length;
        nbPts = 0;

        for (var i = 1; i < lineStringArray.length; i++) {
          tmpCenter = _computeLineStringBarycenter.call(this, lineStringArray[i]);
          tmpCenter[0] = tmpCenter[0] * lineStringArray[i].length;
          tmpCenter[1] = tmpCenter[1] * lineStringArray[i].length;
          nbPts = nbPts + lineStringArray[i].length;
          center = _addPoint(center, tmpCenter);
        }

        center[0] = center[0] / nbPts;
        center[1] = center[1] / nbPts;
        distance = 0;

        for (i = 0; i < lineStringArray.length; i++) {
          newDistance = _farestDistance.call(this, center, lineStringArray[i]);

          if (newDistance > distance) {
            distance = newDistance;
          }
        }

        break;

      case "MultiPolygon":
        var polygonArray = coordinates[0];
        center = _computeLineStringBarycenter.call(this, polygonArray[0][0]);
        center[0] = center[0] * polygonArray[0][0].length;
        center[1] = center[1] * polygonArray[0][0].length;
        nbPts = 0;

        for (i = 1; i < polygonArray.length; i++) {
          tmpCenter = _computeLineStringBarycenter.call(this, polygonArray[i][0]);
          tmpCenter[0] = tmpCenter[0] * polygonArray[i][0].length;
          tmpCenter[1] = tmpCenter[1] * polygonArray[i][0].length;
          nbPts = nbPts + polygonArray[i][0].length;
          center = _addPoint.call(this, center, tmpCenter);
        }

        center[0] = center[0] / nbPts;
        center[1] = center[1] / nbPts;
        distance = 0;

        for (i = 0; i < polygonArray.length; i++) {
          newDistance = _farestDistance.call(this, center, polygonArray[i][0]);

          if (newDistance > distance) {
            distance = newDistance;
          }
        }

        break;

      default:
        throw "geometry " + type + " is not supported";
    }

    return [center, distance];
  }
  /**
   * Queries the GeoJSON passed in parameter in the Mizar options
   * @function handle
   * @memberof DictionaryNameResolver#
   */


  DictionaryNameResolver.prototype.handle = function (options) {
    var context = this.ctx;
    var crs = this.ctx.getCoordinateSystem();
    var objectName = options.objectName;
    var onError = options.onError; //var onComplete = options.onComplete;

    var onSuccess = options.onSuccess;
    var searchLayer = options.searchLayer;
    var zoomTo = options.zoomTo; // Planet resolver(Mars only currently)

    var feature = _$1.find(dictionary.features, function (f) {
      var name = f.properties.Name == undefined ? f.properties.name : f.properties.Name;
      var isFound;

      if (name == null) {
        isFound = false;
      } else {
        isFound = name.toLowerCase() === objectName.toLowerCase();
      }

      return isFound;
    });

    if (feature) {
      var lon;
      var lat;
      var distance;

      if (feature.properties.center_lon == undefined || feature.properties.center_lat == undefined) {
        var centerAndDistance = _computeBarycenterAndDistance.call(this, feature.geometry);

        lon = parseFloat(centerAndDistance[0][0]);
        lat = parseFloat(centerAndDistance[0][1]);
        distance = centerAndDistance[1];
      } else {
        lon = parseFloat(feature.properties.center_lon);
        lat = parseFloat(feature.properties.center_lat);
        distance = null;
      }

      feature.geometry.crs = {
        type: "name",
        properties: {
          name: context.getCoordinateSystem().getGeoideName()
        }
      };

      var zoomToCallback = function () {
        searchLayer(objectName, onSuccess, onError, {
          features: [feature]
        });
      };

      var fov = context.getRenderContext().getFov();
      var distanceCamera;

      if (distance == null) {
        distanceCamera = null;
      } else {
        distance = distance > 180.0 ? 180.0 : distance; // aproximation of the distance in meters

        distance = 2 * Math.PI * crs.getGeoide().getRealPlanetRadius() * distance / 360;
        distanceCamera = distance / Math.tan(Numeric.toRadian(0.5 * fov));
      }

      zoomTo(lon, lat, distanceCamera, crs.getGeoideName(), zoomToCallback, {
        features: [feature]
      });
    } else {
      searchLayer(objectName, onSuccess, onError);
    }
  };
  /**
   * Code to execute when remove
   * @function remove
   * @memberof DictionaryNameResolver#
   */


  DictionaryNameResolver.prototype.remove = function () {
    dictionary = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @name IMCCENameResolver
   * @class
   *     Plugin to access to IMCCE name resolver
   * @augments AbstractNameResolver
   * @param {Context} options - Context
   * @memberof module:NameResolver
   * @constructor
   */

  var IMCCENameResolver = function (options) {
    AbstractNameResolver.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractNameResolver, IMCCENameResolver);
  /**************************************************************************************************************/

  /**
   * Queries SSODnet using this URL https://api.ssodnet.imcce.fr/quaero/1/sso?q=<i>objectName</i>
   * and the layers
   * @function handle
   * @memberof IMCCENameResolver#
   */

  IMCCENameResolver.prototype.handle = function (options) {
    //TODO refactor AJAX request
    var objectName = options.objectName;
    var onError = options.onError;
    var onComplete = options.onComplete;
    var onSuccess = options.onSuccess;
    var searchLayer = options.searchLayer;
    var zoomTo = options.zoomTo;
    var url = "https://api.ssodnet.imcce.fr/quaero/1/sso?q=" + objectName + "&from=Mizar";
    $__default['default'].ajax({
      type: "GET",
      url: Proxy.proxify(url),
      dataType: "json",
      beforeSend: function (xhr) {
        xhr.setRequestHeader("Accept", "application/json");
      },
      success: function (jsonResponse) {
        var data = jsonResponse.data;
        parseResponse(data, createsGeoJsonResponse);

        function parseResponse(data, callback) {
          var features = [];
          var i = 0;
          var dataLength = data.length;

          if (dataLength === 0) {
            onError();
          } else {
            _$1.each(data, function (data) {
              parseItem(data, function (feature) {
                i++;

                if (!_$1.isEmpty(feature)) {
                  features.push(feature);
                }

                if (i === dataLength) {
                  callback(features);
                }
              });
            });
          }
        }

        function parseItem(data, callback) {
          var type = data.type;
          var id = data.id;
          var name = data.name;

          if ($__default['default'].inArray(type, ["Planet", "Asteroid", "Satellite", "Star", "Comet"]) !== -1) {
            var url = "https://api.ssodnet.imcce.fr/quaero/1/sso/" + id + "/resolver";
            Utils.requestUrl(url, "json", "application/json", null, function (data) {
              var coordinates = data.geometry.coordinates;
              var ra = coordinates[0] * 360 / 24;
              var dec = coordinates[1];

              if (_$1.isNumber(ra) && _$1.isNumber(dec)) {
                ra = parseFloat(ra);
                dec = parseFloat(dec);
                var feature = {};
                feature.ra = ra;
                feature.dec = dec;
                feature.credits = 'Powered by <a href="http://vo.imcce.fr/webservices/ssodnet/?quaero" target="_blank">SsODNet/Quaero API</a>.';
                feature.id = id;
                feature.type = type;
                feature.name = name;
                callback(feature);
              }
            }, function (err) {
              ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + url, err);
            });
          } else {
            callback();
          }
        }

        function createsGeoJsonResponse(features) {
          var response = {
            totalResults: features.length,
            type: "FeatureCollection",
            features: []
          };

          _$1.each(features, function (feature) {
            response.features.push({
              type: "Feature",
              geometry: {
                coordinates: [feature.ra, feature.dec],
                type: "Point",
                crs: {
                  type: "name",
                  properties: {
                    name: Constants.CRS.Equatorial
                  }
                }
              },
              properties: {
                identifier: feature.id,
                type: feature.type,
                name: feature.name,
                credits: feature.credits
              }
            });
          });

          if (response.type === "FeatureCollection" && response.features.length > 0) {
            var firstFeature = response.features[0];

            var zoomToCallback = function () {
              searchLayer(objectName, onSuccess, onError, response);
            };

            zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], null, Constants.CRS.Equatorial, zoomToCallback, response);
          } else {
            onError();
          }
        }
      },
      error: function (xhr) {
        searchLayer(objectName, onSuccess, onError);

        ErrorDialog.open(Constants.LEVEL.ERROR, xhr.responseText);
      },
      complete: function (xhr) {
        if (onComplete) {
          onComplete(xhr);
        }
      }
    });
  };
  /**
   * @function remove
   * @memberof IMCCENameResolver#
   */


  IMCCENameResolver.prototype.remove = function () {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * plugin:not_found.<br/>
   * Called when no plugin is found whereas it is requested
   * @event NameResolver#plugin:not_found
   * @type {string}
   */
  // Name resolver globals

  var mizarAPI$7;
  var context$1; // Name resolver properties

  var duration;
  var zoomFov;
  var targetLayer; // Layer containing target feature(cross) on zoom

  var targetFeature; // Zooming destination feature
  //Wrapper Object

  var nameResolverImplementation = null;
  /**************************************************************************************************************/

  /**
   *    Update targetFeature and add it to the target layer
   *
   *    @param lon Destination longitude/right ascension in degrees
   *    @param lat Destination latitude/declination in degrees
   *    @param crs coordinate reference system of the (longitude,latitude)
   */

  function addTarget(lon, lat, crs) {
    targetFeature = {
      geometry: {
        coordinates: [lon, lat],
        type: Constants.GEOMETRY.Point,
        crs: {
          type: "name",
          properties: {
            name: crs
          }
        }
      },
      type: "Feature"
    };
    targetLayer.addFeature(targetFeature);
  }

  function zoomToHips(matchHealpix, onSuccess) {
    var order = parseInt(matchHealpix[1], 10);
    var pixelIndex = parseInt(matchHealpix[2], 10); // Compute vertices

    var nside = Math.pow(2, order);
    /*jslint bitwise: true */

    var pix = pixelIndex & nside * nside - 1;
    var ix = HEALPixBase.compress_bits(pix);
    /*jslint bitwise: true */

    var iy = HEALPixBase.compress_bits(pix >>> 1);
    /*jslint bitwise: true */

    var face = pixelIndex >>> 2 * order;
    var i = 0.5;
    var j = 0.5;
    var vert = HEALPixBase.fxyf((ix + i) / nside, (iy + j) / nside, face);
    var geoPos = [];
    mizarAPI$7.getCrs().getWorldFrom3D(vert, geoPos);
    zoomTo(geoPos[0], geoPos[1], null, mizarAPI$7.getCrs().getGeoideName(), onSuccess);
  }

  function zoomToSexagesimal(coordinates, onSuccess) {
    // Format to equatorial coordinates
    var word = coordinates.split(" "); // [RA, Dec]

    word[0] = word[0].replace(/h|m|:/g, " ");
    word[0] = word[0].replace("s", "");
    word[1] = word[1].replace(/°|'|:/g, " ");
    word[1] = word[1].replace('"', ""); // Convert to geo and zoom

    var geoPos = [];
    mizarAPI$7.getCrs().getDecimalDegFromSexagesimal([word[0], word[1]], geoPos);
    zoomTo(geoPos[0], geoPos[1], null, mizarAPI$7.getCrs().getGeoideName(), onSuccess);
  }

  function zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound) {
    var currentGeoBound = mizarAPI$7.getCrs().getGeoBound();
    var lon = parseFloat(matchDegree[1]);
    var lat = parseFloat(matchDegree[3]);
    var geo = [lon, lat];

    if (currentGeoBound.isPointInside(geo)) {
      zoomTo(geo[0], geo[1], null, mizarAPI$7.getCrs().getGeoideName(), onSuccess);
    } else {
      onErrorOutOfBound.call(this);
    }
  }
  /**************************************************************************************************************/

  /**
   *    Search for object name
   *    Object name could be:
   *        * Degree in "HMS DMS" or "deg deg"
   *        * Object name as "Mars", "m31", "Mizar"
   *        * For debug : healpix(order,pixelIndex)
   *    @fires NameResolver#plugin:not_found
   */


  function search(objectName, onSuccess, onError, onErrorOutOfBound, onComplete) {
    // regexp used only to distinct equatorial coordinates and objects
    // TODO more accurate ( "x < 24h", "x < 60mn", etc.. )
    objectName = objectName.replace(/\s{2,}/g, " "); // Replace multiple spaces by a single one

    var coordinatesExp = new RegExp("\\d{1,2}[h|:]\\d{1,2}[m|:]\\d{1,2}([\\.]\\d+)?s?\\s[-+]?[\\d]+[°|:]\\d{1,2}['|:]\\d{1,2}([\\.]\\d+)?\"?", "g");
    var healpixRE = /^healpix\((\d)+,(\d+)\)/;
    var degRE = /^(-?\d+(\.\d+)?),?\s(-?\d+(\.\d+)?)/; //var layerRE = /^layer:(.)*?/;

    var matchHealpix = healpixRE.exec(objectName);
    var matchDegree = degRE.exec(objectName);

    if (matchHealpix) {
      zoomToHips(matchHealpix, onSuccess);
    } else if (objectName.match(coordinatesExp)) {
      zoomToSexagesimal(objectName, onSuccess);
    } else if (matchDegree) {
      zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound);
    } else if (searchPlanetProvider(objectName, onSuccess, onErrorOutOfBound)) ; else {
      var options = {
        objectName: objectName,
        onError: onError,
        onComplete: onComplete,
        onSuccess: onSuccess,
        searchLayer: searchLayer,
        zoomTo: zoomTo
      };

      if (nameResolverImplementation) {
        nameResolverImplementation.handle(options);
      } else {
        mizarAPI$7.publish(Constants.EVENT_MSG.PLUGIN_NOT_FOUND, "No name resolver found");
      }
    }
  }

  function searchPlanetProvider(objectName, onSuccess, onErrorOutOfBound) {
    var planetsLayer = mizarAPI$7.getLayerByName("Planets");
    var features = planetsLayer === undefined ? [] : planetsLayer.features;

    var feature = _$1.find(features, function (feature) {
      var name = feature.properties.name;

      if (name.toUpperCase() === objectName.toUpperCase()) {
        return feature;
      }
    });

    var isFound;

    if (feature != null) {
      isFound = true;
      zoomToDecimal(["", feature.geometry.coordinates[0], "", feature.geometry.coordinates[1]], onSuccess, onErrorOutOfBound);
    } else {
      isFound = false;
    }

    return isFound;
  }

  function searchLayer(objectName, onSuccess, onError, response) {
    var layers = mizarAPI$7.searchOnLayerDescription(objectName, mizarAPI$7.getActivatedContext().getMode());

    if (layers.length === 0 && (!response || response.totalResults === 0)) {
      if (onError) {
        onError();
      }

      return;
    }

    layers = _$1.sortBy(layers, function (layer) {
      return layer.category === "background" ? 0 : 1;
    });
    var results; // Check if response contains features

    if (response && response.type === "FeatureCollection") {
      results = response;
    } else {
      results = {};
      results.type = "FeatureCollection";
      results.features = [];
    }

    _$1.each(layers, function (layer) {
      results.features.push({
        type: "Feature",
        properties: {
          type: "layer",
          name: layer.getName(),
          description: layer.getDescription(),
          layerType: layer.getType(),
          visible: layer.isVisible(),
          background: layer.category === "background"
        }
      });
    });

    onSuccess(results);
  }
  /**************************************************************************************************************/

  /**
   *    Zoom to the given longitude/latitude and add target at the end
   *    @param lon Longitude
   *    @param lat Latitude
   *    @param distanceCamera Final Distance in meters from the ground to the camera - only use for PlanetContext / set to null for the others contexts
   *    @param crs coordinate reference system of the (longitude, latitude)
   *    @param callback Callback once animation is over
   *    @param args Callback arguments
   */


  function zoomTo(lon, lat, distanceCamera, crs, callback, args) {
    if (args !== null && typeof args !== "undefined") {
      // updates the coordinates, which is displayed at the screen in the current CRS
      var idx = 0;

      while (idx < args.features.length) {
        args.features[idx].geometry.coordinates = mizarAPI$7.getCrs().convert(args.features[idx].geometry.coordinates, crs, mizarAPI$7.getCrs().getGeoideName());
        args.features[idx].geometry.crs.properties.name = crs;
        idx++;
      }
    } // Add target feature on animation stop


    var addTargetCallback = function () {
      addTarget(lon, lat, crs);

      if (callback) {
        callback.call(this, args);
      }
    };

    var position = mizarAPI$7.getCrs().convert([lon, lat], crs, mizarAPI$7.getCrs().getGeoideName());

    if (mizarAPI$7.getActivatedContext().getMode() === Constants.CONTEXT.Sky) {
      mizarAPI$7.getActivatedContext().getNavigation().zoomTo(position, {
        fov: zoomFov,
        duration: duration,
        callback: addTargetCallback
      });
    } else {
      var distance = distanceCamera == null ? mizarAPI$7.getActivatedContext().getNavigation().getDistance() : distanceCamera;
      mizarAPI$7.getActivatedContext().getNavigation().zoomTo([lon, lat], {
        distance: distance,
        duration: duration,
        callback: addTargetCallback
      });
    }
  }
  /**************************************************************************************************************/

  /**
   *    Delete target image
   */


  function removeTarget() {
    if (targetFeature) {
      targetLayer.removeFeature(targetFeature);
      targetFeature = null;
    }
  }
  /**************************************************************************************************************/

  /**************************************************************************************************************/


  var NameResolver = {
    /**
     * Init name resolver
     * @param {Mizar} m - Mizar API
     * @alias module:NameResolver.NameResolver.init
     */
    init: function (m) {
      if (!context$1) {
        mizarAPI$7 = m;
        this.setContext(mizarAPI$7.getActivatedContext());
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "Name resolver is already initialized");
      }
    },

    /**
     * Unregisters all event handlers
     * @alias module:NameResolver.NameResolver.remove
     */
    remove: function () {
      if (context$1) {
        mizarAPI$7.getActivatedContext().removeDraw(targetLayer);

        if (nameResolverImplementation !== undefined) {
          nameResolverImplementation.remove();
        }

        mizarAPI$7.getActivatedContext().unsubscribe(Constants.EVENT_MSG.NAVIGATION_MODIFIED, removeTarget);
        context$1 = null;
      }
    },

    /**
     *    Search for object name
     *    Object name could be:
     *    <ul>
     *        <li>Degree in "HMS DMS" or "deg deg"</li>
     *        <li>Object name as "Mars", "m31", "Mizar"</li>
     *        <li>For debug : healpix(order,pixelIndex)</li>
     *    </ul>
     *    @alias module:NameResolver.NameResolver.goTo
     *    @fires Mizar#plugin:not_found
     */
    goTo: search,

    /**
     *    Zoom to the given longitude/latitude and add target at the end
     *    @param lon Longitude
     *    @param lat Latitude
     *    @param crs coordinate reference system of the (longitude, latitude)
     *    @param callback Callback once animation is over
     *    @param args Callback arguments
     *    @alias module:NameResolver.NameResolver.zoomTo
     */
    zoomTo: zoomTo,

    /**
     *    Set context
     *    @alias module:NameResolver.NameResolver.setContext
     *    @listens Context#modifiedNavigation
     *    @fires Context#backgroundLayer:added
     *    @fires Context#layer:added
     */
    setContext: function (ctx) {
      // Remove previous context
      this.remove();
      context$1 = ctx; //instantiate name resolver nameResolverImplementation object

      var isDefaultNameResolver;
      var nameResolverClass;

      if (typeof context$1.getContextConfiguration().nameResolver !== "undefined") {
        nameResolverClass = require(context$1.getContextConfiguration().nameResolver.jsObject);
        isDefaultNameResolver = false;
        nameResolverImplementation = new nameResolverClass(context$1);
      } else {
        //Use default name resolver if none defined...
        isDefaultNameResolver = true;
        nameResolverImplementation = new DefaultNameResolver(context$1);
      }

      var style = new FeatureStyle({
        iconUrl: ctx.getMizarConfiguration().mizarBaseUrl + "css/images/target.png",
        fillColor: [1, 1, 1, 1]
      });
      targetLayer = new VectorLayer({
        style: style,
        visible: true
      });
      mizarAPI$7.getActivatedContext().addDraw(targetLayer); // Update name resolver properties

      if (isDefaultNameResolver) {
        duration = 3000;
        zoomFov = 15;
      } else {
        duration = context$1.getContextConfiguration().nameResolver.duration || 3000;
        zoomFov = context$1.getContextConfiguration().nameResolver.zoomFov || 15;
      }

      ctx.subscribe(Constants.EVENT_MSG.NAVIGATION_MODIFIED, removeTarget);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**************************************************************************************************************/

  /**
   * @class
   * Abstract Wrapper constructor
   * @param {Context} options - context
   * @implements {ReverseNameResolver}
   */
  var AbstractReverseNameResolver = function (options) {
    this.ctx = options;
  };
  /**************************************************************************************************************/

  /**
   * @function handle
   * @memberof AbstractReverseNameResolver#
   * @abstract
   */


  AbstractReverseNameResolver.prototype.handle = function () {
    throw new SyntaxError("AbstractReverseNameResolver.js: handle from AbstractReverseNameResolver not implemented");
  };
  /**
   * @function remove
   * @memberof AbstractReverseNameResolver#
   * @abstract
   */


  AbstractReverseNameResolver.prototype.remove = function () {
    throw new SyntaxError("AbstractReverseNameResolver.js: remove from AbstractReverseNameResolver not implemented");
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @name DefaultReverseNameResolver
   * @class
   *   Plugin to access to Default reverse name resolver
   * @augments AbstractReverseNameResolver
   * @param {Context} options - Context
   * @memberof module:ReverseNameResolver
   */

  var DefaultReverseNameResolver = function (options) {
    AbstractReverseNameResolver.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractReverseNameResolver, DefaultReverseNameResolver);
  /**************************************************************************************************************/

  /**
   * @function handle
   * @memberof DefaultReverseNameResolver#
   * @param {Object} options
   */

  DefaultReverseNameResolver.prototype.handle = function (options) {
    var maxOrder = options.maxOrder;
    var equatorialCoordinates = options.equatorialCoordinates;
    var context = options.context;
    var requestUrl = context.getMizarConfiguration().reverseNameResolver.baseUrl + "/EQUATORIAL/" + equatorialCoordinates[0] + " " + equatorialCoordinates[1] + ";" + maxOrder;
    Utils.requestUrl(requestUrl, "text", "text/plain", null, function (response) {
      if (options && options.success) {
        options.success(response);
      }
    }, function (err) {
      if (options && options.error) {
        options.error(err);
      }
    });
  };
  /**
   * @function remove
   * @memberof DefaultReverseNameResolver#
   */


  DefaultReverseNameResolver.prototype.remove = function (options) {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  var HOUR_TO_DEG = 15.0;
  var lastCallTime = null;
  var callTimeInterval = 6000;
  /**
   * @name CDSReverseNameResolver
   * @class
   *   Plugin to access to CDS reverse name resolver
   * @augments AbstractReverseNameResolver
   * @param {Context} options - Context
   * @memberof module:ReverseNameResolver
   */

  var CDSReverseNameResolver = function (options) {
    AbstractReverseNameResolver.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractReverseNameResolver, CDSReverseNameResolver);
  /**************************************************************************************************************/

  /**
   * Queries the CDS reverse name resolver
   * @function handle
   * @memberof CDSReverseNameResolver#
   * @param {Object} options - parameters
   * @param {int} options.maxOrder - Max Hips order
   * @param {float[]} options.pos - position
   * @param {Mizar} options.mizarAPI - mizar API
   * @param {Function} options.error - error function
   * @param {Function} options.success - success function
   */

  CDSReverseNameResolver.prototype.handle = function (options) {
    //Do not call the service to often
    var now = Date.now();
    var diff = now - callTimeInterval;

    if (lastCallTime !== null && diff <= lastCallTime) {
      if (options && options.error) {
        options.error({
          status: 503
        });
      }

      return;
    }

    var self = this;
    var maxOrder = options.maxOrder;
    var pos = options.pos;
    var mizarAPI = options.mizarAPI;
    pos = mizarAPI.getCrs().convert(pos, mizarAPI.getCrs().getGeoideName(), Constants.CRS.Equatorial);
    var equatorialCoordinates = [];
    mizarAPI.getCrs().getSexagesimalFromDeg(pos, equatorialCoordinates); // Format to equatorial coordinates

    equatorialCoordinates[0] = equatorialCoordinates[0].replace("h ", ":");
    equatorialCoordinates[0] = equatorialCoordinates[0].replace("m ", ":");
    equatorialCoordinates[0] = equatorialCoordinates[0].replace("s", "");
    equatorialCoordinates[1] = equatorialCoordinates[1].replace("° ", ":");
    equatorialCoordinates[1] = equatorialCoordinates[1].replace("' ", ":");
    equatorialCoordinates[1] = equatorialCoordinates[1].replace('"', ""); //BEGINING OF SPECIFIC PROCESSING
    //DO IT WITHOUT REQUESTING SITOOLS

    /**
     * Arsec 2 degree conversion.
     */

    var ARCSEC_2_DEG = 1 / 3600.0;
    /**
     * MAX radius of a cone in arcsec.
     */

    var MAX_RADIUS = 1800.0;
    var nside = Math.pow(2, maxOrder);
    var pixRes = HEALPixBase.getPixRes(nside);
    var radius = pixRes > MAX_RADIUS ? MAX_RADIUS : pixRes / 2;
    radius *= ARCSEC_2_DEG;
    var requestUrl = mizarAPI.getActivatedContext().getContextConfiguration().reverseNameResolver.baseUrl;
    requestUrl = requestUrl.replace("{coordinates}", equatorialCoordinates[0] + " " + equatorialCoordinates[1]);
    requestUrl = requestUrl.replace("{radius}", radius);
    Utils.requestUrl(requestUrl, "text", "text/plain", null, function (response) {
      lastCallTime = Date.now(); // we parse the message that is returned by the server

      var posParenthesis = response.indexOf("(");
      var posComma = response.indexOf(",");
      var posSlash = response.indexOf("/");
      var position = response.substring(0, posSlash);
      var name = response.substring(posSlash + 1, posParenthesis);
      var magnitude = parseFloat(response.substring(posParenthesis + 1, posComma));
      var objectType = response.substring(posComma + 1, response.length - 2);
      var positionElts = position.split(" "); //GET HMS

      var hours = parseFloat(positionElts[0]);
      var min = parseFloat(positionElts[1]);
      var sec = parseFloat(positionElts[2]);
      var degrees = parseFloat(positionElts[3]);
      var min2 = parseFloat(positionElts[4]);
      var sec2 = parseFloat(positionElts[5]);

      var ra = self._parseRa(hours, min, sec);

      var dec = self._parseDec(degrees, min2, sec2);

      var features = {
        totalResults: 1,
        type: "FeatureCollection",
        copyright: "CDS",
        features: [{
          type: "Feature",
          geometry: {
            coordinates: [ra, dec],
            type: Constants.GEOMETRY.Point,
            crs: {
              type: "name",
              properties: {
                name: Constants.CRS.Equatorial
              }
            }
          },
          properties: {
            title: name,
            magnitude: magnitude,
            credits: "CDS",
            seeAlso: "http://simbad.u-strasbg.fr/simbad/sim-id?Ident=" + name,
            type: objectType,
            identifier: name
          }
        }]
      };

      if (options && options.success) {
        options.success(features);
      } //END OF SPECIFIC PROCESSING

    }, function (err) {
      if (options && options.error) {
        options.error(err);
      }
    });
  };
  /**
   * Parse RA.
   * @function _parseRa
   * @memberof CDSReverseNameResolver#
   * @param hours
   * @param min
   * @param sec
   * @returns {number}
   * @private
   */


  CDSReverseNameResolver.prototype._parseRa = function (hours, min, sec) {
    var intHours = parseInt(hours, 10);
    var val = (sec / 60.0 + min) / 60.0;
    val = intHours + val;
    return val * HOUR_TO_DEG;
  };
  /**
   * Parse dec
   * @function _parseDecval = intHours + val;
   * @memberof CDSReverseNameResolver#
   * @param degrees
   * @param min
   * @param sec
   * @returns {number}
   * @private
   */


  CDSReverseNameResolver.prototype._parseDec = function (degrees, min, sec) {
    var intDegrees = parseInt(degrees, 10);
    var val = (sec / 60.0 + min) / 60.0;

    if (degrees <= 0.0) {
      val = degrees - val;
    } else {
      val = intDegrees + val;
    }

    return val;
  };
  /**
   * @function remove
   * @memberof CDSReverseNameResolver#
   */


  CDSReverseNameResolver.prototype.remove = function () {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   *    Cache storing <AbstractRasterLayer> tile requests in browser's local storage
   *    Due to performance reasons, it's recommended to use it only for tiles of level 0
   *    @param {Layer} layer
   *    @param options
   *        <ul>
   *            <li>layer: Layer which will contain the given cache(required)</li>
   *            <li>cacheLevel: the maximum level of tiles to be cached</li>
   *        </ul>
   */
  var Cache = function (layer, options) {
    this.layer = layer;
    this.options = options;
    this.cacheLevel = options.hasOwnProperty("cacheLevel") ? options.cacheLevel : 1;

    if (!localStorage.getItem(this.layer.getName())) {
      // Create cache space in local storage named after layer
      localStorage.setItem(this.layer.getName(), JSON.stringify({}));
    }

    this._cacheMap = JSON.parse(localStorage.getItem(this.layer.getName()));
  };
  /**************************************************************************************************************/

  /**
   *    Get tile request from cache for the given tile
   *    @returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
   */


  Cache.prototype.getFromCache = function (tile) {
    var cachedTileRequest = null;

    if (this.cacheLevel >= tile.level) {
      var tileId = this.layer.getUrl(tile);
      var tileInfo = this._cacheMap[tileId];

      if (tileInfo) {
        // Update access info
        tileInfo.lastAccess = Date.now();
        var image = new Image();
        image.src = tileInfo.dataUrl;
        image.dataType = "byte";
        cachedTileRequest = {
          image: image,
          elevations: tileInfo.elevations
        };
      }
    }

    return cachedTileRequest;
  };
  /**************************************************************************************************************/

  /**
   *    Internal method to generate data url from HTML image object
   */


  Cache.prototype._createDataURL = function (image) {
    var imgCanvas = document.createElement("canvas"); // Make sure canvas is as big as layer requests

    imgCanvas.width = this.options.tilePixelSize || 256;
    imgCanvas.height = this.options.tilePixelSize || 256;
    var imgContext = imgCanvas.getContext("2d"); // Draw image into canvas element

    imgContext.drawImage(image, 0, 0, image.width, image.height); // Save image as a data URL

    return imgCanvas.toDataURL("image/png");
  };
  /**************************************************************************************************************/

  /**
   *    Store tile request in cache
   */


  Cache.prototype.storeInCache = function (tileRequest) {
    var tile = tileRequest.tile;

    if (this.cacheLevel >= tile.level) {
      var tileId = this.layer.getUrl(tile);
      this._cacheMap[tileId] = {
        dataUrl: this._createDataURL(tileRequest.image),
        elevations: tileRequest.elevations,
        lastAccess: Date.now()
      }; // Update local storage with new cache

      localStorage.setItem(this.layer.getName(), JSON.stringify(this._cacheMap));
    }
  };
  /**************************************************************************************************************/

  /**
   * Clear cache
   */


  Cache.prototype.clear = function () {
    this._cacheMap = {};
    localStorage.clear();
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * AbstractRasterLayer configuration
   * @typedef {AbstractLayer.configuration} AbstractRasterLayer.configuration
   * @property {int} tilePixelSize - the image size of a tile in pixels
   * @property tiling - Tiling
   * @property {int} numberOfLevels - number of levels in the pyramidal tiles
   * @property [geoBound=null] - geography boundary
   * @property [coordinates=null]
   * @property {int} [zIndex=0]
   * @property {string} [crossOrigin="anonymous"]
   * @property {string} baseUrl
   * @property cache
   */

  /**
   * @name AbstractRasterLayer
   * @class
   *     Base class for raster layer
   * @augments AbstractLayer
   * @param {LAYER} type - the type of the layer
   * @param {AbstractRasterLayer.configuration} options -Configuration properties for the AbstractRasterLayer.
   * @constructor
   * @implements {RasterLayer}
   */

  var AbstractRasterLayer = function (type, options) {
    options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_RASTER;
    AbstractLayer.prototype.constructor.call(this, type, options); // Base properties

    this.tilePixelSize = options.tilePixelSize;
    this.tiling = options.tiling;
    this.numberOfLevels = options.numberOfLevels || 21;
    this.minLevel = options.minLevel;
    this.maxLevel = options.maxLevel;
    this.geoBound = options.geoBound || null;
    this.coordinates = options.coordinates || null;
    this.crossOrigin = options.crossOrigin || "anonymous"; // Init cache if defined

    if (options.cache) {
      this.cache = new Cache(this, options.cache);
    } // Internal


    this._ready = true; // Ready is use by TileManager
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, AbstractRasterLayer);
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof AbstractRasterLayer#
   */

  AbstractRasterLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.RASTER;
  };
  /**
   * Loads a global overview if available.
   * Only use for sky rendering currently
   * @function loadOverview
   * @memberof AbstractRasterLayer#
   */


  AbstractRasterLayer.prototype.loadOverview = function () {};
  /**
   * Returns the URL to query the raster.
   * @param {Tile} tile for which the URL is created
   * @returns {string} the URL
   * @memberof AbstractRasterLayer#
   */


  AbstractRasterLayer.prototype.getUrl = function (tile) {
    throw new SyntaxError("AbstractRasterLayer.js: getUrl() not implemented");
  };
  /**
   * Returns the Url when the tile level is between [minLevel, maxLevel]
   * @param url url
   * @returns {Boolean} the proxified Url when the tile level is between [minLevel, maxLevel]
   * @function allowRequest
   * @memberof AbstractRasterLayer#
   */


  AbstractRasterLayer.prototype.allowRequest = function (url, level) {
    var request;

    if (this.isBetweenMinMaxLevel(level)) {
      request = url;
    } else {
      request = null;
    }

    return request;
  };
  /**
   * Returns true when the tile is defined between [minLevel,maxLevel] otherwise false.
   * @param level level of the tile
   * @returns {Boolean} true when the tile level is defined between [minLevel,maxLevel] otherwise false.
   * @memberof AbstractRasterLayer#
   */


  AbstractRasterLayer.prototype.isBetweenMinMaxLevel = function (level) {
    var isInside;

    if (this.minLevel != null && this.maxLevel != null) {
      isInside = this.minLevel <= level && level <= this.maxLevel;
    } else if (this.minLevel != null) {
      isInside = level >= this.minLevel;
    } else if (this.maxLevel != null) {
      isInside = level <= this.maxLevel;
    } else {
      isInside = true;
    }

    return isInside;
  };
  /**
   * Attach the raster layer to the planet
   * @function _attach
   * @memberof AbstractRasterLayer#
   * @param {Globe} g - globe
   * @private
   */


  AbstractRasterLayer.prototype._attach = function (g) {
    if (this.isBackground()) {
      // Override id of background layer because of unicity of background not overlayed layer
      //TODO : check if it is still needed
      this.id = 0;
    }

    AbstractLayer.prototype._attach.call(this, g);

    if (!this.isBackground()) {
      // Create the renderer if needed
      if (!g.rasterOverlayRenderer) {
        var renderer = new RasterOverlayRenderer(g);
        g.getRendererManager().renderers.push(renderer);
        g.rasterOverlayRenderer = renderer;
      }

      g.rasterOverlayRenderer.addOverlay(this);
    }
  };
  /**************************************************************************************************************/

  /**
   * Detach the raster layer from the planet
   * @function _detach
   * @memberof AbstractRasterLayer#
   * @private
   */


  AbstractRasterLayer.prototype._detach = function () {
    // Remove raster from overlay renderer if needed
    if (!this.isBackground() && this.getGlobe().rasterOverlayRenderer) {
      this.getGlobe().rasterOverlayRenderer.removeOverlay(this);
    }

    AbstractLayer.prototype._detach.call(this);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Configuration parameters to query a Web Map Service (WMS) and Web Map Service-Time (WMS-Time)
   * @typedef {AbstractLayer.configuration} AbstractRasterLayer.wms_configuration
   * @property {string} type - Must be "WMS" - the type of this service
   * @property {string} layers - Layers to display on map. Value is a comma-separated list of layer names.
   * @property {string} [styles=""] - Styles in which layers are to be rendered. Value is a comma-separated list
   * of style names, or empty if default styling is required. Style names may be empty in the list, to use
   * default layer styling.
   * @property {string} [version = "1.3.0"] - Service version
   * @property {string} [format = "image/jpeg"] - Format for the map output
   * @property {string} [transparent = false] - 	Whether the map background should be transparent. Values are
   * true or false. Default is false
   * @property {string} [time] - Time value or range for map data using WMS-Time
   * @property {int} [tilePixelSize = 256] - tile in pixels
   * @property {int} [numberOfLevels = 21] - number of levels
   * @property {{west:float, north:float, east:float, south:float}} [restrictTo] - Bounding box on which the WMS
   * query is allowed. The WMS query must intersect the bounding box sets to restrictTo. When restrictTo is not
   * defined, the bounding box is equivalent to the whole planet.
   * @property {boolean} [autoFillTimeTravel] - Set to true so that Mizar can automatically retrieve the
   * defined time from the time dimension.
   * @property {{units:string,unitSymbol:string,default:string,multipleValues:string,nearestValue:string,value:string}} [dimension.time] - Supported time for WMS-T
   */
  //TODO : check id restrictTo is set to the extent of the layer
  //TODO : For version 1.3.0 crs must be CRS:84 and then tile.config.srs must be CRS:84 with BBOX coord long/lat
  //TODO : For version 1.3.0 and crs=EPSG:xxxx => too bad because we have the bbox coord in this order lat/long
  //TODO : For version != 1.3.0, crs is not used anymore, we srs and it akes an EPSG code with the bbox order long/lat

  /**
   * @name WMSLayer
   * @class
   *    Creates a layer for imagery data using WMS (Web Map Service) or WMS-Time (Web Map Service - Time) protocol
   *    based on a GeoTiling(4, 2) with a pixelSize = 256 by default.<br/>
   *    WMS provides a standard interface for requesting a geo-spatial map image.
   *    The standard guarantees that these images can all be overlaid on one another.
   *    <br/><br/>
   *    Example of a WMS request<br/>
   *    <code>
   *        http://example.com/wms?request=GetMap&service=WMS&version=1.3.0&layers=MyLayer
   *        &styles=population&crs=CRS:84&bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578
   *        &width=780&height=330&format=image/png
   *    </code>
   *
   * @augments AbstractRasterLayer
   * @param {AbstractRasterLayer.wms_configuration} options - WMS Configuration
   * @constructor
   * @memberof module:Layer
   * @see {@link http://www.opengeospatial.org/standards/wms WMS} standard
   */

  var WMSLayer = function (options) {
    options.tilePixelSize = options.tilePixelSize || 256;
    options.tiling = new GeoTiling(4, 2);
    options.numberOfLevels = options.numberOfLevels || 21;
    options.transparent = options.transparent || false;
    this.restrictTo = options.restrictTo;
    this.autoFillTimeTravel = options.autoFillTimeTravel; //this._computeBaseUrlAndCapabilities(options);

    AbstractRasterLayer.prototype.constructor.call(this, options.type, options);
    this.timeTravelValues = null; // If needed, try to fill time travel parameters

    if (this.autoFillTimeTravel === true && this.containsDimension("time")) {
      this.generateTimeTravel(options.dimension.time);
    }

    this.getMapBaseUrl = _queryImage.call(this, this.getBaseUrl(), this.tilePixelSize, this.tilePixelSize, options);
    this.layers = options.layers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRasterLayer, WMSLayer);
  /**************************************************************************************************************/

  /**
   * Static part of the URL to query the WMS/WMS-T server.
   * @function _queryImage
   * @memberof WMSLayer#
   * @param {string} baseUrl - Base URL of the WMS/WMS-Time server
   * @param {int} xTilePixelSize - Number of pixels along X for the output image
   * @param {int} yTilePixelSize - Number of pixels along Y for the output image
   * @param {AbstractRasterLayer.wms_configuration} options - options
   * @return {string} the URL
   * @private
   */

  function _queryImage(baseUrl, xTilePixelSize, yTilePixelSize, options) {
    // Build the base GetMap URL
    var url = baseUrl;
    url = Utils.addParameterTo(url, "service", "wms");
    url = Utils.addParameterTo(url, "version", options.hasOwnProperty("version") ? options.version : "1.3.0");
    url = Utils.addParameterTo(url, "request", "getMap");
    url = Utils.addParameterTo(url, "layers", options.layers);
    url = Utils.addParameterTo(url, "styles", options.hasOwnProperty("styles") ? options.styles : "");
    url = Utils.addParameterTo(url, "format", options.hasOwnProperty("format") ? options.format : "image/jpeg"); // transparent option

    if (options.hasOwnProperty("transparent")) {
      url = Utils.addParameterTo(url, "transparent", options.transparent);
    }

    url = Utils.addParameterTo(url, "width", xTilePixelSize);
    url = Utils.addParameterTo(url, "height", yTilePixelSize);

    if (options.hasOwnProperty("time")) {
      url = Utils.addParameterTo(url, "time", options.time);
    } // custom params


    for (var param in this.imageLoadedAtTime) {
      if (param !== "time" && this.imageLoadedAtTime[param] !== undefined) {
        url = Utils.addParameterTo(url, param, this.imageLoadedAtTime[param]);
      }
    }

    return url;
  }
  /**
   * Checks whether the footprint (that represents the restricted zone area) intersects with the tile
   * @function _tileIsIntersectedFootprint
   * @memberof WMSLayer#
   * @param {{west:float, north:float, east:float, south:float}} tile - Tile
   * @param {{west:float, north:float, east:float, south:float}} footprint - restricted zone area
   * @return {boolean} true when the tile intersects with the footprint otherwise false
   * @private
   */


  function _tileIsIntersectedFootprint(tile, footprint) {
    var isIntersect;

    if (footprint != null) {
      // check if tile is inside restrict zone
      isIntersect = UtilsIntersection.boundsIntersects(tile, footprint);
    } else {
      isIntersect = true;
    }

    return isIntersect;
  }
  /**
   * Sets the time to query
   * @function setTime
   * @memberof WMSLayer#
   * @param {Time.configuration} time - time to query
   */


  WMSLayer.prototype.setTime = function (time) {
    this.setParameter("time", time);
  };
  /**
   * Returns the legend from the WMS/WMS-T server
   * @function getLegend
   * @memberof WMSLayer#
   * @return {{title:string, format:string, url:string, size:string}} the legend information
   */


  WMSLayer.prototype.getLegend = function () {
    var metadata = this.metadataAPI;
    var legend;

    if (metadata.Style) {
      var defaultStyle = metadata.Style[0];
      var title = defaultStyle.Title;
      var format = defaultStyle.LegendURL[0].Format;
      var url = defaultStyle.LegendURL[0].OnlineResource;
      var size = defaultStyle.LegendURL[0].size;

      if (title === undefined || title === "default") {
        legend = {};
      } else {
        legend = {
          title: title,
          format: format,
          url: url,
          size: size
        };
      }
    } else {
      legend = {};
    }

    return legend;
  };
  /**
   * Sets visible/hidden the layer and the legend related to the layer.
   * To make visible the legend, a <div id="legendDiv"/> must be set in the HTML file.
   * @function setVisible
   * @memberof WMSLayer#
   * @param arg true when the layer must be visible otherwise false
   */


  WMSLayer.prototype.setVisible = function (arg) {
    AbstractRasterLayer.prototype.setVisible.call(this, arg);

    if (document.getElementById("legendDiv")) {
      var legend = this.getLegend();

      if (Object.keys(legend).length > 0) {
        document.getElementById("legendDiv").innerHTML = "";

        if (arg === true) {
          document.getElementById("legendDiv").innerHTML = "<div id='legendTxt' class='column'>" + legend.title + "</div><div id='legendUrl' class='column'><img src='" + legend.url + "'/></div>";
        }
      }
    }
  };
  /**
   * Returns the url for the given tile
   * The URL is returned in the following case :
   * - the HTTP request is allowed (case of the time request, the requested time is inside a supported time value
   * or range - when no time dimension, no constraint).
   * - the image is background (when an image is in background, this image is always request, we do not try to
   * make optimization)
   * - the spatial tile intersects with the image extent (useful when we want to display a single footprint as
   * an image - in this case, we do not want to make the request to the server when we know the request does not
   * intersect the image's footprint)
   * @function getUrl
   * @memberof WMSLayer#
   * @param {Tile} tile Tile
   * @return {string} Url
   */


  WMSLayer.prototype.getUrl = function (tile) {
    // Just add the bounding box to the GetMap URL
    var bound = tile.bound;
    var url, bbox; // we cannot reject the request to the server when the layer is defined as background otherwise there is
    // no image to show and Mizar is waiting for an image

    if (this.isBackground() || _tileIsIntersectedFootprint(bound, this.restrictTo)) {
      bbox = bound.west + "," + bound.south + "," + bound.east + "," + bound.north;
      url = this.getMapBaseUrl;
      url = Utils.addParameterTo(url, "transparent", this.options.transparent);
      url = Utils.addParameterTo(url, "crs", tile.config.srs);
      url = Utils.addParameterTo(url, "bbox", bbox);
    }

    return this.allowRequest(url, tile.level);
  };
  /**
   * Set a parameter and add it to the static query parameters.
   * The parameter is added according to some [use cases]{@link AbstractLayer#_hasToBeRefreshed} with the time.
   * @function setParameter
   * @memberof WMSLayer#
   * @param paramName parameter name
   * @param value value name
   */


  WMSLayer.prototype.setParameter = function (paramName, value) {
    if (this._hasToBeRefreshed(paramName, value)) {
      this.options[paramName] = this.imageLoadedAtTime[paramName];
      this.getMapBaseUrl = _queryImage.call(this, this.getBaseUrl(), this.tilePixelSize, this.tilePixelSize, this.options);

      if (this.isBackground()) ; else {
        this.forceRefresh();
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Configuration parameters to query a Web Map Tile Service (WMTS)
   * @typedef {AbstractRasterLayer} AbstractRasterLayer.wmts_configuration
   * @property {string} [version = "1.0.0"] WMTS version
   * @property {string} layer - basic unit of geographic information that may be requested as a map from a server
   * @property {string} matrixSet - The name of pyramidal images
   * @property {int} startLevel - Start level of the index
   * @property {string} [style] - Styled Layers Descriptor
   */

  /**
   * @name WMTSLayer
   * @class
   *    Creates a layer for imagery data using WMTS protocol.
   *    <br/>
   *    WMTS protocol provides tiles with a resolution of <i>tilePixelSize</i><br/>
   *    based on a GeoTiling(4, 2)<br/>
   *    <img src="../doc/images/wmts_tile.png"/><br/>
   *    <br/
   *    Example of a WMTS request:
   *    <code>
   *            http://example.com/wmts?LAYER=MyLayer1,MyLayer2&
   *            EXCEPTIONS=text/xml&FORMAT=image/jpeg&SERVICE=WMTS&
   *            VERSION=1.0.0&REQUEST=GetTile&STYLE=normal&
   *            TILEMATRIXSET=PM&TILEMATRIX=18&TILEROW=90241&TILECOL=132877&
   *    </code>
   *    <br/><br/>
   *    The parameters of a WMTS server are the following:
   *    <ul>
   *        <li><b>TILEMATRIXSET</b>: The name of pyramidal images</li>
   *        <li><b>TILEMATRIX</b>: The name of the matrix that contains the tile</li>
   *        <li><b>TILEROW</b>: The line number from the top left corner from the tile</li>
   *        <li><b>TILECOL</b>: The column number from the top left corner from the tile</li>
   *    </ul>
   *    <img src="../doc/images/wmts_pixel.png"/>
   *
   * @augments AbstractRasterLayer
   * @param {AbstractRasterLayer.configuration} options - WMTS configuration
   * @property {int} [tilePixelSize = 256] - tile in pixels
   * @property {int} [numberOfLevels = 21] - number of levels
   * @property {string} [version = "1.0.0"] - WMS version
   * @property {string} [transparent]
   * @property {string} [time] - Time dimension
   * @property {string} [format = "image/png"] - output image format
   * @constructor
   * @memberof module:Layer
   * @see {@link http://www.opengeospatial.org/standards/wmts WMTS} standard
   * @see {@link http://www.opengeospatial.org/standards/sld SLD} standard
   */

  var WMTSLayer = function (options) {
    AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.WMTS, options);
    this.getTileBaseUrl = _queryImage$1.call(this, this.getBaseUrl(), options);
    this.imageLoadedAtTime = null;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRasterLayer, WMTSLayer);
  /**************************************************************************************************************/

  function _queryImage$1(baseUrl, options) {
    var url = baseUrl;
    url = Utils.addParameterTo(url, "service", "wmts");
    url = Utils.addParameterTo(url, "version", options.version || "1.0.0");
    url = Utils.addParameterTo(url, "request", "GetTile");
    url = Utils.addParameterTo(url, "layer", options.layers);
    url = Utils.addParameterTo(url, "tilematrixset", "WGS84"); //            url = Utils.addParameterTo(url, "tilematrixset", options.tilematrixset);

    if (options.hasOwnProperty("style")) {
      url = Utils.addParameterTo(url, "style", options.style);
    }

    url = Utils.addParameterTo(url, "format", options.hasOwnProperty("format") ? options.format : "image/png");

    if (options.hasOwnProperty("time")) {
      url = Utils.addParameterTo(url, "time", options.time);
    } //custom params


    for (var param in this.imageLoadedAtTime) {
      if (param !== "time" && this.imageLoadedAtTime[param] !== undefined) {
        url = Utils.addParameterTo(url, param, this.imageLoadedAtTime[param]);
      }
    }

    return url;
  }

  WMTSLayer.prototype.setTime = function (time) {
    this.setParameter("time", time);
  };

  WMTSLayer.getCapabilitiesFromBaseURl = function (baseUrl, options) {
    var getCapabilitiesUrl = baseUrl;
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "service", "WMTS");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "request", "getCapabilities");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "version", options.hasOwnProperty("version") ? options.version : "1.0.0");
    return getCapabilitiesUrl;
  };
  /**************************************************************************************************************/

  /**
   * Returns an url for the given tile
   * @function getUrl
   * @memberof WMTSLayer#
   * @param {Tile} tile Tile
   * @return {string} Url
   */


  WMTSLayer.prototype.getUrl = function (tile) {
    var url = this.getTileBaseUrl;
    url = Utils.addParameterTo(url, "tilematrix", tile.level + 1);
    url = Utils.addParameterTo(url, "tilecol", tile.x);
    url = Utils.addParameterTo(url, "tilerow", tile.y);
    return this.allowRequest(url, tile.level);
  };

  WMTSLayer.prototype.setParameter = function (paramName, value) {
    if (this._hasToBeRefreshed(paramName, value)) {
      this.options[paramName] = this.imageLoadedAtTime[paramName];
      this.getCoverageBaseUrl = _queryImage$1.call(this, this.getBaseUrl(), this.options);
      this.forceRefresh();
    }
  }; ///**

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * WCSElevation configuration
   * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.wcsElevation_configuration
   * @property {int} [tilePixelSize = 33]
   * @property {int} [numberOfLevels = 21]
   * @property {string} baseUrl - the base Url to access the WCS server
   * @property {string} coverage - the name of the coverage to use (WCS parameter)
   * @property {string} crs - the coordinate reference system to use (WCS parameter)
   * @property {string} [outputCRS=crs] for 2.0
   * @property {string} version -  2.0.x or 1.0.x is supported
   * @property {float} [scale=1] - elevation scale value
   * @property {float} [scaleData=1] - elevation scale value to apply to have the true altitude
   * @property {string} [format='image/x-aaigrid']
   * @property {float} [minElevation=0]
   */

  /**
   * @name WCSElevationLayer
   * @class
   *    Create a layer for elevation data using WCS protocol  based on a GeoTiling(4, 2)
   *    with a pixelSize = 33 by default. The only supported format is right now image/x-aaigrid. It is an ASCII
   *    format that is easily parsed in Javascript.
   * @augments AbstractRasterLayer
   * @param {AbstractLayer.wcsElevation_configuration} options - WCSElevation Configuration
   * @constructor
   * @memberof module:Layer
   */

  var WCSElevationLayer = function (options) {
    options.tilePixelSize = options.tilePixelSize || 33;
    options.tiling = new GeoTiling(4, 2);
    options.numberOfLevels = options.numberOfLevels || 21;
    options.version = options.version || "2.0.0";
    options.format = options.format || "image/x-aaigrid";
    options.minElevation = options.minElevation || 0;
    options.scale = options.scale || 1;
    options.scaleData = options.scaleData || 1;
    options.crs = options.crs || "EPSG:4326";
    AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.WCSElevation, options); // Build the base GetMap URL

    this.getCoverageBaseUrl = _queryImage$2.call(this, this.getBaseUrl(), options);
    this.level = null;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRasterLayer, WCSElevationLayer);
  /**************************************************************************************************************/

  function _queryImage$2(baseUrl, options) {
    var url = baseUrl;
    url = Utils.addParameterTo(url, "service", "wcs");
    url = Utils.addParameterTo(url, "version", options.version);
    url = Utils.addParameterTo(url, "request", "GetCoverage");

    switch (options.version.substring(0, 3)) {
      case "2.0":
        url = Utils.addParameterTo(url, "outputCRS", options.crs);
        url = Utils.addParameterTo(url, "size", "x(" + options.tilePixelSize + ")");
        url = Utils.addParameterTo(url, "size", "y(" + options.tilePixelSize + ")");
        url = Utils.addParameterTo(url, "coverageid", options.coverage);
        break;

      case "1.0":
        url = Utils.addParameterTo(url, "width", options.tilePixelSize);
        url = Utils.addParameterTo(url, "height", options.tilePixelSize);
        url = Utils.addParameterTo(url, "crs", options.crs);
        url = Utils.addParameterTo(url, "coverage", options.coverage);
        break;
    }

    url = Utils.addParameterTo(url, "format", options.format);

    if (options.hasOwnProperty("time")) {
      url = Utils.addParameterTo(url, "time", options.time);
    } // time constraints and custom params


    for (var param in this.imageLoadedAtTime) {
      if (param !== "time" && this.imageLoadedAtTime[param] !== undefined) {
        url = Utils.addParameterTo(url, param, this.imageLoadedAtTime[param]);
      }
    }

    return url;
  }
  /**
   * Parse a elevation response
   * @function parseElevations
   * @memberof WCSElevationLayer#
   * @param {string} text Response as text
   */


  WCSElevationLayer.prototype.parseElevations = function (text) {
    if (text === null || text.match("ServiceExceptionReport") != null) {
      return this._returnZeroElevations();
    }

    switch (this.options.format) {
      case "image/x-aaigrid":
        return this._parseAAIGrid(text);

      default:
        ErrorDialog.open(Constants.LEVEL.WARNING, "Format '" + this.format + "' could not be parsed.");
        return this._returnZeroElevations();
    }
  };
  /**
   * Fallback elevations when no data was returned
   * @function _returnZeroElevations
   * @memberof WCSElevationLayer#
   * @returns {float[]} Array of float
   * @private
   */


  WCSElevationLayer.prototype._returnZeroElevations = function () {
    var elevations = [];

    for (var i = 0; i < this.options.tilePixelSize * this.options.tilePixelSize; ++i) {
      elevations.push(0);
    }

    return elevations;
  };
  /**
   * Parse a elevation response from AAIGrid
   * @function _parseAAIGrid
   * @memberof WCSElevationLayer#
   * @param {string} text Response as text
   * @private
   */


  WCSElevationLayer.prototype._parseAAIGrid = function (text) {
    var elevations = [];
    var i;
    var lines = text.trim().split("\n");
    var dataLinesStart = 0;
    var noDATA = Number.NEGATIVE_INFINITY;

    for (i = 0; i < lines.length; ++i) {
      if (lines[i].substring(0, 1) === " ") {
        dataLinesStart = i;
        break;
      } else if (lines[i].substring(0, 1) === "NODATA_value") {
        var elt = lines[i].trim().split(/\s+/);
        noDATA = elt[1];
      }
    }

    var oldVal = Number.NEGATIVE_INFINITY;

    for (i = dataLinesStart; i < lines.length; i++) {
      var elts = lines[i].trim().split(/\s+/);

      for (var n = 0; n < elts.length; n++) {
        var elevation;

        if (isNaN(elts[n]) || elts[n] === noDATA) {
          elevation = oldVal;
        } else {
          elevation = parseFloat(elts[n]).toFixed(10);
          oldVal = elevation;
        } //var elevation = parseInt(elts[n], 10);


        if (elevation < this.options.minElevation) {
          elevation = this.options.minElevation;
        }

        elevations.push(elevation * this.options.scale * this.options.scaleData);
      }
    }

    return elevations;
  };
  /**
   * Checks if the Elevation is requested at the current level.
   * @function isRequested
   * @memberof WCSElevationLayer#
   * @return {boolean} True when the elevation is requested at the current level otherwise False.
   */


  WCSElevationLayer.prototype.isRequested = function () {
    return this.level == null ? false : this.isBetweenMinMaxLevel(this.level);
  };
  /**
   * Get an url for the given tile
   * @function getUrl
   * @memberof WCSElevationLayer#
   * @param {Tile} tile Tile
   * @return {string} Url
   */


  WCSElevationLayer.prototype.getUrl = function (tile) {
    var geoBound = tile.geoBound;
    var url = this.getCoverageBaseUrl;

    if (this.options.version.substring(0, 3) === "2.0") {
      url = Utils.addParameterTo(url, "subset", "x" + this.options.crs + "(" + geoBound.west + "," + geoBound.east + ")");
      url = Utils.addParameterTo(url, "subset", "y" + this.options.crs + "(" + geoBound.south + "," + geoBound.north + ")");
    } else if (this.options.version.substring(0, 3) === "1.0") {
      url = Utils.addParameterTo(url, "bbox", geoBound.west + "," + geoBound.south + "," + geoBound.east + "," + geoBound.north);
    }

    this.level = tile.level;
    return this.allowRequest(url, tile.level);
  };

  WCSElevationLayer.prototype.setParameter = function (paramName, value) {
    if (this._hasToBeRefreshed(paramName, value)) {
      this.options[paramName] = this.imageLoadedAtTime[paramName];
      this.getCoverageBaseUrl = _queryImage$2.call(this, this.getBaseUrl(), this.options);
      this.forceRefresh();
    }
  };

  WCSElevationLayer.prototype.getScale = function () {
    return this.options.scale;
  };

  WCSElevationLayer.prototype.getScaleData = function () {
    return this.options.scaleData;
  };

  WCSElevationLayer.prototype.setTime = function (time) {
    this.setParameter("time", time);
  };

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /**
   * @name AbstractProvider
   * @class
   *  Abstract Provider constructor
   * @param {object} options
   * @implements {Provider}
   */
  var AbstractProvider = function (options) {
    this.options = options;
  };
  /**
   * @function loadFiles
   * @memberof Provider#
   * @abstract
   */


  AbstractProvider.prototype.loadFiles = function (layer, configuration) {};
  /**
   * @function handleFeatures
   * @memberof Provider#
   */


  AbstractProvider.prototype.handleFeatures = function (layer) {};

  const PlanetData={};// Can be imported with @rollup/plugin-image
  PlanetData.SUN="data:image/png;base64,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";PlanetData.MERCURY="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEBCAYAAACXLnvDAAA0jXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZxrluWokmb/axR3CAIJAcPhuVbPoIffe+MeWfdRdbt6dUVkRni4n6ODwOx7GIau9b//177+9re/hVByud6Uy1e/7+bXW98aG1+U++dXO3+G+z1//vkVfv/8h+9f5xv+ivz98Pfz84Py/b5t8f3I6+Pv98fv1RrfT393obp+f9D/8Qft90Kx/H7AnxH9ftATfj7g/r3w1X4v9MTfT35//t1/buv+asl/fwvj9/X79+dnGoq3xh/vk+OXvpBf/nzjnfNX+brE+83M23Sge8Tq+1L/vdA//fv689LImOJ6wnPzZ3GED8N/6tMev278n6Lf+fna7z/P71SwWvG6M1/XP/P673/9u5Fff4b+u+T/sKR7/7Xg/3kI/N1KX2dC//zg+acV+v76+z/9fkj/8f3r75f0rNvfffL3/fXJ//D93eL4h3v+s2r+v/cse6+fu2vvxy1/vzf151bCz+3O7mydd338zvyf7uJk+7vyu5ASgziaBFnn9wg1RJZxhzfM0MIO6/w9wmCIb1wx83eMIz5hXHyzsBg1jrPcr7/DjpkFnk9hoQfh8PDd+NdYwvnYej5uhMIHz1AuoidwMePj/+v39d950d7ObQh3+TNPrm800xiFKxcC2c/LWJGwfyc1nQn+8/uff7muDyuYzjQXbrDd3Suw/D2F/wiu5yz0wwsTf/8kcMjz9wJMESNIDCY8rMD9hSeFL9w5xiuHwEQWFqgx9Pi8sbMsIaU4GWR8n+djccgCPpv35HBeGlP8+TZAyEKk57uezNqQgizW+ybiJ7+FGGrpSW9K6Us5lVRT+57PDPu+/ImoLT/5zSl/OeeSa25XecpbUvmA3VJqaTXWB8RNlXyspdbaGh/auHLj3Y0XtNZjf/rbU/967qXX3ka8xjPekcY38iijjjbjfCZ5PL+ZZ5l1thUWobTelda38iqrrrYJtf3sd6f97bzLrtduf61a+E3bf/79/7Bq4XfV4lkpX5j/WjW+m/OfSwThJLlmrFh8AwueXYHwXDG6ZncJ7xtdOdfsrlH4iwwyuTgzuGKs4LtCTDv8tXb/sXLper7/mXW7WIj4P7Fyl0v331i5f123/2zVZjtE95wVMg2d1Psh+3bdq7RYmkz5X/696vNe377zHAl8fHPrX0u5fxOELGMN5mil+XyppdlGC+UlzfbYfBZoBaeNVm+mJPb3u+J883h2S994J8AWy9rtY/2fVr5+P4M7fxtLnr45CMNJePRS7r2+sN78jJvPDrNcI0xRcLe5eudCs0FW/Rn9G8z/C28NWOtmvVLmDTv2j+W/n7reshpTmb7ednkviLY/pfbdU2ZM3CfUWkvPM6455gqMJUfge/TI2LkE48j8k5sIrPxuXK+vdOX9lbRexpDvtmYhWp5SeP+6v/kK343AfAokmu9YDzEMcGjVFNebYqk5JG7pIg5WbrMit1ruc47FbdUnpfmGyuSXsd9UuLtCFD8PkmzwSTv3WFvtsb3pnvUr9WohNYCM6Sd9ag8v4fISj4RJqWHUlXvPgiNB/pbnq3fmv0BEwx8EDPNUx/y+i+G1Ur8VZ+6DWyEnHr5kzJGvby6mdJiBgODe+FZ45b9fwUHAEMzgTLxWyJtUvGcqlTjtTP5eZFke/W7vvRqAzc9ySoWVj/eX5yK1CYO3Vj46LfRO6O+1S+FtyKb9vaqPFVsNPTnale6Rc2p1zrSGGg8FswEBYWPd6/3IlpegHIqIjXAqreXivROG6Ymk3Xpm71z/efhowvlhDL0VMpL15nozp7C4Vu+Rj5ypvpcLAunmSmRn4h4oKmEwm2/bz3jSCtwSeLPjgrxBmGq8bD5uZZg8uX6pjHQRGuNF7Hlbqd35fQiwm0x98/z57mJonfsAOFEEOxPOjYgnHInk/tRsZH9XmaAI6FBqm5PkRJQwhs6Mksfri9wi6Epat4cAYuTEyeoMmdwlk3dhFuu+9/WuGGba7+itP8DfB0ZW5GZAJDZyrImDYZSVXsKq7NR2ysBy6izVFxsfEXnzx2QTR9+9vx7DPfn5AA6ZCSDuuzvSltei9sdHtJRn8i+Sd76FOejoJZCGO/xauJj6zct6S+RpJZfWYtb4ujH7D6P4EtD6oN8JPdAuf/ehi7oKHBP7WHAR9uHiE/YAEVlYbqI7G2WMgU7oA0CYO8D+xGQnc27QfzAwZB2xwyBv1x4k+FK/QgH6QDMWsxMx8EaN4Xyhnfi//536RBS6aqspwQ/MhvxBXcjECV3tzIctAubtfBaDjoxnA4mEJ9KRmK5nUBFuguIuEgcYIruAcFDx+8CZyLqxLhXtQ8gF9CW/WMRCroOLbwnMdlulpLP8hO2dL5lvwOR9s/xMCTMDbjyb287Ob0A/vSNvSDA/YYOwCdZqvaQwvwbPTbOzbaB2lP6yrtDvZLqjwE48w7pVSJ27xEmksGIbFVyB/r8UBSw8oUgS5GWyUfEkJ9TXQMmdayuAI0mZ4zbXx4CRyv6YktZz4AY7r9qwbkHzhSzmovze6+E+Sjh4WVXhWbOTBDvCcaEOH1D7hZ5QDcx/m+/X4rNgksjn75Jeee99r2omETCLuMz1IUNJkkhUQ2mgQZlatMHajLb7evZYEajuTGFbYlwC4xT/16jwHEzOeBAGK/TMz99gMhDNY7p2M1dugDGAJKQrBPAM4q0sRXiuA2h98Gt3nRU/VzEWWYwvplaIGf5AI01kyd3QPREuZ9leFpeAWQQFs/KxbAA9I0bWkMLg1S43yw44rHTeDb2NrijTWW7u4bvBUf4NeXx1LiB8gqqxyxRvMUWi3IDJBcbwVxAPmDbAIjC/lhes6BG3D0bFWHm3F0J7PZOxh3WDCKTfPTHHhPxAfDwrIX4A0tZxV+8397IUkPsmoSMBSEjnkRCte78VbkDybRzt6+fP90LpIxchqrzGZjr5GJKxfntCjsTKQzqjW4lyggszSBSnuVbpkMvgHhtDhSnSNcHSb9QYM1C90+pTI6HngGTOn223Z69RO7fEyt4kLlKoMZU7AO4ACdQ2r8BCzPkaBKkgevon1ICdyKF7ECsNNucSj0T7kNHYLXh39W32Txh5S60PSRvSvHfpcCQ2iJAlQT5CgtROdawbvEmrEWExo022JRyMY+FDFAGE3E2ET26N+9ww9AP2/Tv8mgG9Apbm8CGg0GPjg/i6SiSgUML1IW55cR9AyygmYl4boZ3X3aApkoRI6kF6Bb4/ZGHZCMlCpIFgdxtIQhAwXc40Iqj0ycdvYgOh2DHHuE8S8Nu9g1gdbgYXEMu13ZXBE65fQcKjtF8+nai7kJnE6x1Ybb4gWFLlvc8Lfa5uEkP5XoOE7TiAl5CH3T/NuroQpctHI4QutQ4BZC6Rca2y4uudyCwUMBMJu4GqhDNRW8HGF8kYyjbL+CazRRrCTWNdUbEDcUzAPRE6GVUrgqHkHrT2V2sohGTIDXDiJlFelrPQ/vfEw7rgTNf9XL3gYrgkyYPkypW5Qi8Yhxm8JkkqME4akNjEckUxfzfwMbAkhBU8/IJO3N5FDH54eEAgxwwZkbJEJEIytxvJlR5gH1G+mOMKHCevxEIot1Cq3+AiL+hXL+GcXJmtDT4LGgW4NXQQBJwPx7LKEf8gF9XqJOGdbrAG0OOtxSQHo6pMS+iTPEwjzhvt0DSkD1wDwaAMiCo/Gfzi5dt6jzUwLv65ENxlZo1iuQQybueQxH3uhnt4WKnIt4e4xjhR4IgmorNLD7DlYizfepB/YBRO5C2XOgyexR4ghUHQdCPyXi0Twox7QFMwofFbs4PR+2nWKGI8ax5uI2uGwdJfBPQcBb9xM6lcn/jGPwLxXIgId4RgPTZs35E8/QLRuMJ0lNwtk1uJZqD4CvAd4PWovJqv3aFAZVUaS3gTbrhjz3DiBEEGdnntashEwBK0K41gJtug7A70YTlhKv8keoA8VVetuvTJjSF+wQcynHkhZgNMTzJAUqRx3iAO1nVeiEysDK4ka3Y6KReQMk9GDzdS4oZqIBEQHxmJS5iToAR18qhctjEe7hHP2/C0H9fBSJf4Nu9fu/ac2w+14BmgTeixJhavfMwjOcqc4vemFFc6iE0ctAv9yUwnQuS5/4BlHwypH7AkAJAfXT2NHMa+l9LxlUz2InJX+BgxODxYfrIPK0YSEnkyRkkHGeHcn7/JQLiJ9X8wKNDNfHB3IMA6sgdBt+ON+rqweEntMkhD+PpGoW6m5q7ErgjN5KVCXq4awWplYWrzedHEyKMbwuxcq418MY7JJBQF6z1O4RiNhxvjHVBt4DaV04qxDw9WOtdh4ceeanzEF2xEJN4XmLuhOqw1mmDgVgsJj9ok67+uEAabKsRbsactfEQZeNbmjX0vA+YnehWa7cL+q+uRRggZFu0OWGbsFj6kmdAYTdMRvUvuQbf3AxbjKJ+Emgb8oShcC6u24P2EcyS/XpP//YIugyshmJnxCI0AN62iy8LGkXKbkZhXY5QbbUT04DfuSw2IXhYNBszlIDAuHbLF7OGieWFr+krrQSQREf/Alnkpm98jtyJyKl+fuhklEMHNkplueQEgWUU4A9z07aSfCcHy9hev92XC1Jo/NATCpKc95QLHdkVaBD54H3NE0rPsBMNttDF94CXwrtAASVANSDlRNkUmoSEqE7HyXLz/S+noTswJd3Bqw5VgxToS2DozRr2tLJFGkE0px4IJjEIxJLCA+2veiFjoE3/PP5f1CPKM/FSQw5Hc96tiw0iapwukYhBiJ9QF4PPFC3xtrWgRiDAkaEZx320NpP6tkEGKMfsIvEgGAzj45vnuAA2lQXpWcsO6wPOMq6NWV8amonQScYyiANGfAmyTARhQFCmIBGij2QkJ3OkgXR4SAfzQQWtJFnhEgBIAPQNjcHzWFT1Q+wugVoYlcgbyDVJiXR+4pMIpYOsn8EOlsb66p0vCwx5i9YlncAJpirUl/HCdyH14etdtpjLzXZNwf3jv8J4wXeMhv7A773MxYy+4ktGGIaIxhan5rbrUFRsAggg7KDfkzwfox2pZYeE+HSHDdM0REYnlB1gm4q6BL+3TURIoSFgpSMO9URws/79q1NYcGAvz5XXh3V+3RXDjFa+FqsYsh63C+W70KhqB1P+g2ImfZDFg1Wp5BT7mi8W4kS0JC4HUw76BCyoJbhDcXS+KYiH0UbgLpfdacYwdo40ewrGSWg10Bo9QrB8Ihcy4YpqWEUtfk3WD+bERY9eBCq1qNG6fGOB2IBBCGEOGvse04VtvtHtGbb4O44pFFwuiwwRc+iHnXrxAQflb6bfCyy90BrheSUp8R3SnR08ON+pqUbpENoIPPCAqzlTgKiFFVghoRxURncCQXBQjEwg7zVdUdKKhS0TOssBcUm5XssDCm3Ar+T1izvJo7VZWZjI9gzgyRQTA3H0/sJeAOV7WqljNFuWun/d+VofIypOP9z6cDbxYkjp+7CWpoUnU3kOyuer9XkbBOvnIrVxYMoCjfJ+bVGgk+JWsre8c0AafvaAS/RFrX+AIy4lTk27VH21ypFVmmBeQXQG4D0PxLszKfIi1znySbvHsZhLBe+UU4hysLJc2I6wMxl3hB6AKc1kvUR3cAJHdCmRmQIHXqlZbsuiT3vbUgi+bc/fSiIsyGeFExYMv+cf04psvOIn1OorYoiu3y2pjfRhlskQKgrYJofASfQEDZkQg7XJiKsz74CXv8FwWBdwaQIG4w4dTQActC/UA58K5HEJkigDrjVpRIFngRIokRHhTo2fC+ALuBDXpoVhWENSHl+Ct+xltLGIVrsquOhoaVE6s+aMyStbGGS742a+YVe8WSDAosWEOkBJMNsP8uP/NGoGF4Yf+MvNrdTFqNdDQ6UuBKGEyMccsgU7wa256WCuAg6YSlsztFiKQbmT9O3EXRUhCvZaNU9j1a8uCJVcY++K2rDsuM/JRjd2idUJucSvdW2obctqgJnM8dsTMh5McFpsyn/JBenlcywpHtywHESFmR/weqOk4lblFU3w+Cp6FAeoC8rfAB1kHQb7gClpD8b7t6pboBpYDOI4AfSzWGQBD5hlUEQ4jOUOQAuhxKKSAsohbQykP6ysGQ4vXLVaCurGOB1Rr4PREwKiUP/RSWg82ABZHNmHFMnMDbs7PagWAg2vaawMqYDZzI9iArlWmX6zp1L64vszUBHcmEixu7DXa+f4qGq9awIhyIANmyAsHeQrQfJ6l+GIZDRgeZd+rbVYRsIS+cGoJ3R9xPrgJd1FeMnLuQqhjFtCw+4oqUbIP8nB3DoFE2FsywtcsVE2xbrORXQUNP7+4oC8YxJmZ+RupfUiZSmTjeTHd4QFYISG3G6A4smsqHBphECzsgwckf3ymXMpwmO2OYjcDRmdad71KCcxMQxuO4zZhi8qaLr7TUNQJeZ4jb2MeGMOIvKhwc0UFyngBWL4ka68oNZBEACLab1m2uxmiwc58gtjcemzKiHwS1a3IKvfzYQULBA5zn5vsx+/CooEseuZjbQyuHyfVWIEqJCG5UC5MG/AIr0wWDn35FscgtU+AoV71tVTISIhA9C5LiRRRnZLLuYgwJ/LBqPZYdkTuA+FILASjO+4gJCgW0yW0RCAdrTNJDMBuBZb5Bp4nwnZYWsq7KXJx8GgDtARqrxFhp8DQdPPP+i7oDTlo0v9cCTaKpB8+x+Is0I+GIUqr+h+BCT/EibdF3j3ccQWZmUpy5bJCJM0yt1pFvEaIBGlJ8IlvUziffR4ICNIUL4vbGShdsJlPGOiPsupFCmFUmaleEUH43MK43MstwDNaH/aGDYL3OCwwIdgetQxCm/cghO5yFu/CdO9P+gTnUNLSg01GTwh/hrg+XTpEhI4lvjJ8zcQRvNpVN14sA+XrfnUM2PlU66m554HFevInQO2z0wO7r+My3AwDMSZmFxPoNsewQAxf4rIHls6NL+4cmZBWQgLpH/OBH7AlAWN3x6jyueJMJwvdJcYkYixh34oRhSB7UPHg7YARRnwnwh6iA1hJ4bTsE4H5gN/xxOF+sttHmH9mcyERwdL9WT27oK7ApPJp32P9Vxx9XI5d83q7me8GV8PRA+4ffuIGyU/pY1rFQL4rtO+LJHiwO/BwQp3cLWMdWZkZmDGCHrzFsAJ5pA2I8qDzEdfABtoMckelZjthSNoCAa6+XaK7xYe/YL8+NqE8rYl9ZAKy5EUYghDIM0tmC58992j1PRUg9Gy4mPLunigBChaD63MygS7MqwzlPo/rXNNKCuFEdkDrc2s0YAWL6R/m9b1mgqIUaKDfVt3rtyGhpTLOxINuvCohkFdcxk0EWJflc5vDHGHS7/RcCtN4JkARvYOuA4HZH7QWxoW5Otu2eKaXxGFJwTU/xJ1GbBm+/eVm2r5AvGkj0Scx65o6Cfr2tN0sdps4kiVM4Z1QhQQ/HFUikF/L6YojevvHUjyX1e95tHMkzfispMHv3lYiYmxnQAhZvsSIBxyuyX8v0g+l+T7LD3QZLxAFwnZfCllGUiBsFOfWSLXehCsxs7eIj6qHEswuTLNef4FkmGNmo80LAL1VzgQm+jhYggw6X7E6DfERxq2mBiCChH+hU8u46bZsposJ6Jc9LwT3GN8oSOGVkPlM+Cky4s0sFu03rZKtnoTg/j5mlWtpfW7MGlDKJGxEa72MYytsrwX5gCZSYdRo50fHuCWXZluZ/NqHR0Tpk2yIts5AUOXo7wXQ3hPBHsDT7D4YkghZCniC/8KzVQwE6E8V+s5eBZmudvuQFgHNP0uXex40wPVaPX0RRctiW5w4ghgyEEJciO1g21ceJJNh9w3VeV0FkrDrbzNyJS3MJK+9Pw10quR9DwDk6TeAG+2nK6H+KPHNT+1lKZYtb1HO0svOKFp+lecq6D+Euq0bwZskKnHkRbvt3i+p7h4aPhduyUdloufT2RqBB6z/4aPvtS8iAoyDLQhFEKypRG7L2MTa6vBsdPP3+VRP67VsI5ATnkA14ER4EsGghaV6lQMOmZi+IW6kcT5NdXA/GgrFsTueHB0S3Z4BfAo+Ew+KvXK736I0sXrBX8iPJIE+Sma1EouBtGtzuV2JuuhTq8LVicOxICEsLm96+Qu2ddMLd/RW/QWxZZsGggpRYE0Wb4yWtNcIBT+tBrdTmmCFy40H5qWsOc4WGYQA/d4r2L9KyqM9wI8K0ru9U0k3YJr7SrhcxgN2W3P9QufS2622mogxd7nSqaRpavwcKAUAzPeReSYkBpDkxTqg2Pl/MM/MAPOA2cTMVSuWmVBIb32Z7HE9kL9YSvajr8ERRcA3gRLyZitNMSA4j50ReOYKvuvpRISlAcI2eJ0+90W8ZeKwRuX6obqqjdgDc0aCui84EEmWPF7cx+NKASSWKNeH039QLu6kXWiJfts7gXwik/HkL2i4gIRR6wAwyYwOMmzvinyFh8BvpDzAN4K1MCOWyYbRMBHwUUbYYhSQdYippGVJmOHQRrJuhui3RYREBVGLVf5OMig/0L8QbbvAkrYD8gsw3hn/yKcC8cC7M4JSRmH6FTc909i3O+mR6F2IYhQk8YHiR9Vdxizw2YObWmcLGjTt7vHh8CNRLJiBj/suxwxzXyAdlk1h/H6h/WiffoXeT6MxkJ/XVGNua8fLvfAW4K3z9qxCDDZqqO5ig9BLN6husZ9AXBcohfowzhS6XSBImMWiVfwiqfY+BMOpJ/eixLJwEVu0lGN1a5yP7OXip/LlkbAKute2uK6hYJF8iXN4Y25dTIOv3S8p06ykE5O4imXGFFTtVzBAgOetr2RqEBK4j5TtVEGJqsLw0e/EjyOy9YHBuoZa2mivbt4G8Ggtxvwkb+uzAgFhMGXMd0IQ5erm12hwV7S6O9yAgVrTARq0ujL/q+XDizTE73LPuFo8JLNRRFAAUzKttb/c2Fueo3s+Uc0dcKAzvGvvn0IN5gKbld0xR4vyAe53kQiA+9blG+Y38/uJpxaXv6L8LVxj47GRGvgD+M5yXcBli9dQNf4Y/YXajmYpmBgtgVilQ0VGG+lOHffOMgW6urPGCd97CiIgy/WkQSAqU5i6aVkLLZ+ashcD0rg4lw/W/0u1VIF7BmVtunuaGwlxIKggzStMlv05RYOSpDJIotrLiRgNaEKSEISzwe+VLx5NIniBfHJBbHwbzf3lC0iw3HvsC3K9RhYlf0hZlh/iiwrmvrN7VNa0UJFo0mIbhDWPcD4IfC6XgYn5Jv6sLgGrVUYSMEOE407qPjm51J+VGqjednKQk2SrrMXZcX/+VLQy4gixM0iz8HEBXD+iAf9v0GMacMOk/lg4Gxyms0DgWoj5qS2DydcdaxYqnsL3QFSuqRjBOrsdQcbbwYYgeeyj3e99TB0LiX4ZlpP0NA+AflnCTzpPK9PvTbAjrIHQgq2Y2rjhhmk9+pPYqDhCdIPtHrfj497tsnjQ2RVa5saJ2A524TVYQFiE6CT4cYpngwLuS29T9L9wNYEDJJRq8c6mzYcYv3ayAQk3hx8Hkfjh2cdG2bjvxMzgIp/1uj33lWVpg8RFEFjGgap5I9GxN6tW3cJFowak4zlQAqKIbAOERG/mgdbcn5v39XN/FrA81fFPAuE1SENkGAQpBMKamnVD4GWtV/m6np1VBHereHNWJ7lxPiz0AYKi5pxEmL0VzNEf0GMKbaKq5eySExHvO1j6mCAPCQHdZafcKbRtaM9dNG5tIJLwY/d3TUf0HBn7Ymca2TEPzj+gBqavuknwTKS6ujSED/69n7OrXpEZQDRIEOq+/tzWOvqfibAd9raDdish34R1tJ2Vz05BHLlHkCo7+oXoGzZPIQTD9cDpXEykA02ZhKrCRmOvs08R3HIeWxkE8IxHlHMjBumLXwPAdUAS0oXMZpI/dXGYYDrYgHYE5wkd/AgynJmJp1jtHixqBy8dO7H02juELEULk2UXdFdnzeqvXyBMYlB5B/mBLCY83mYXHbPkhhqMSyg/9rgS4T/iHqF69FGxkZKI9SiQWL+zfouBV/s4Pvc4QKg81FZEgh1U2LBHP4jO/mxxnO8FXHyTJLNtHW3ljoeIRZDob7kiKQU22wqNV4yNNAJI455MgCDLKDspHa5lU30v9WCJvgAyAsYDEYW5RzS/ArGaJb4WGqGp2hlKb8zett/VvmcLmnMv4Rg6wFuQnqhaPig/CN94vHAoGJ3CxAC2KGtuADeZS3brDXZ3axOYvDAMNg9jpmEX0p20QPlgtEQE9zznLSm6g/zWav3QLo4JFfcOHKIhGGO+x2VvULTcwELHxLo+N5luy45tip9ewNYNYr3xecB0Hlh4EIsZjaQCgd5tN77eTn4CXGi0z2q79VP7T4mkaVH6RtslzNrbxjpdIyJK6O4oJQIPMRfsQe6XO4cvYssK9WNDovtD9oDEswOQo6Fh5yay6UUjeh4GLxtgc/v48Dg4+nfkK9jPo4zEvb/TnsqHS/Y61CZWapkM9byHvqb1HFw/0YXWQph/ROuwVSLmyyMAExxDqp0tfhkVbVIicgehCypvBUeWtfTEX+d+iAkYGvnCJzFpGbK97LEuNc/HkvzEpwfmU9XdPDtjEbwPZZKN3cBxtFHZ1vQxlJqkmSVHqOoqmBLQbtqna+M9Rn4Mz6GhdCOJgEhRQYTU3YZYFjfSmNArYjcWFTx4BfxeQRLAitcduDGYAcg7tQIQgnUk+OxoeCxwynsHbdM+3aGEpP1Twfp/uEBEi1NALMJSY4CO84BQe/d0Gb8FHqBrMov8upndXvuzNLvJHjfge58mnXpat6teiHfC5sn6KiwKoiubmdqufZokswoWwZgshVX312GKdjA3FbwIN/8mEeaupzkDRcN7XlaSRW6eZWiISTuC6svQvlNymPjkFYgopEhhRIkRVRAE6m2k79ARLQQor5HFm8UMjzAg74ATQR+LBugcBYJNBdbyc3D6Yj0LSLEJjM8jMtGzG9tjFZ+QkVHlpJU6BQe9kv7X/iE1EQK7orfINDLmQtK7JSjlwJrw8oNiJ0ptZEWrcXXQBQFgIiIJiT2b/YPdqWSy7QC4I9zcNZq7fZDiD9MRT9F6nhA9RU4co8EZbT8noPKnR7JhR/PwQSozEk7luxi37RLD9jXktsrZvmNYYKGkP1tiHcJzE1MYgOdsZbLSbi+Mu2JnFqHZCEj58S6RN6LQSM4nehynO4mQycxag5rOVhdygqSBk635RIfDMkDMrGO/6sdNDovgA4tfE3Ow3ByoN+6HhAcvR/YcVxTbdkhWj7OVyhDILqDDJpX4Xre923JDxoCn+TYoG9VItrACwL+QukgpYta+ns+tWYt9TtL32VB0N3H+GqeBjew6fU2ey7ICBXnP4a7QaQq5bXbB40T09UKkgFQB/GTupwTqDtJ3dZiOUMcTuXk1uR5W9y1WopPqjPDmBzgBQg+AzG6hsJqdWGy2FOOcrJ2Mywa3hOjxEMYN4q19Ojb4aJLrhRndKSP55Yi2QiEQnKkXHbJtfofxsUszXTkp59ezxobPPOSAfVwJWvU8QxEx74FJ6oQDGKxNcWs4/PSrdXtT7sNruyY1B7KSYXmgp36gAXRRCZV4jDrz3kx/buV159Jjm6dIO0CpT/OBNYf7SSISgzhuZpg88KGs3NxaMc6IASN0LJX01WRbSQ/Gs/8HluaLlcH0C4eKgNlW8qB0Fh+Dj0j63IJEwXhSNN02qjPt392B/uBO2tvU/C+SYNv38uD7g2IBJVtN9TnDWjaskKSekRqvvc44hanHJ/MQewxlH3npYZjS9svkru9CdliBg/Pwz/EYPXfR3HG1yH2XVJ7T6mQLa+dyTfefblnLpn97DWxduPzXcXA2NLhlBZkyWssH5PzSRgjDSzHujj7LgIjVXjzTvTm0UY7IcfRR3RaSCDmvlckAD53AFK9e0HOeAQMT7fp8whlMd/er2mV9a4ZxwKkiIm5myDok1uq4ZjQYoeu9CCkoVMw2S+QGJRTTiP6GygYZg7saqZY7zQX3t3v97BP2ksn4OlQCSOo9LWYBBKxItfmq2cIB7bn/xxyc+ub3/CmWfMiacNo73QGMHgu0jcPeE5yKveP7HBIjGtXIBR11WtH89+fRh08QY4n7JU6zNOk+zWrA9vfikNSVmHn8t+zTQUi3xprn2E6VGcYbr5KWqfKoA9zvUYLo9ltSHS8PFZ1mxgj+W8ixBwVxBBgMFHMjjRmv1IZ2+JYnWVDpUM4FVVk87x9sNhirRNJMlGr/zX1Khp4QDNw6xq0RBhNbiHK1WLzstByy2aWZZJIYt11dHp/E3SYjpHkmU0pZ3K3ntD3MsGzfgFRton0ckY15Kg/7IesmCd7+2YzrRI9YVIeBFOJqO1oXQvAykGHJG19JgiN9inhu2zcZBPdbxgrF5hKYzWIznEJguDeCTCXREdxMEMyt+VF6IHLcPQnEFxa8iKBv00KUT4nyrlsFZIs2oYqseXYWf2ykcGsE0rT2+3kgLFuM8YhchGEstefhRl313sOyFaec/se4rUFbdEL9d7iHtHpOBxJTlx579ecgLZgci1QTKzSu7NbDmqf2Y4kGHq0WFPDSiGUPu792D9i4vogs5M3j0pGtrAOqzMosr83XZOFlSM+5N/v4o+UBhrQrpLtsxFx2jjEV/PflRg4TOoE0+1Kwg4+wrR+CHdaAXKKR48/Jc8YnV9xW/YHSSQDdNSNYwYycyKP4vBZacyY/PWFwEzuXndzF3Ma+beAsw6Xx8fAJ8hnwtXqZ8gsE92hlHspKzaJli4MZsoRvEwF+zaMNCzm7bSa9sZM2R1hChVPBzi6bALA2KCMTWrFTw5Yz91Ld7QGf8FRENtGOriR8H9YAXgZvpjKqucvrGQH4GB6ztReuEldW4zuQvuO1FfEr6K+rlmYTKkbTA5FuCtic3j5ZN7p57mZIL4B8VeHdnz191V4oaOgcGWUOsCEX8WsLheceHkliYoRBGeGr33pCAsf9hnOM1QbNvkUiouBUL+yCW3YZXUA5SqSRE4MAPf0a4SjEHk5rBSCNd7/hSTsgT+uUrc3FJwCUfiNX5mOV+PLqHljAazJZ2IV0GvqwHAEC6LY87PhTwP7Q9Cw+gwKEyYyKByNxqrf7obOxjM5PJs3mU7InAPazDvQjhZnbWyuJIrQrE2c4YSyr4kRMXd4Cv258vyrGYgZcX3xL2XfKP8aGfPeIuM3rN9OA9fk0cKOcdqfdx2nJahZgGmLUU5f2M39izB0JluFGBJjq7hqZkdw8XCqklz9BKgxRnGAClDFT9Ax6W5fFatJ/Rzv2iOrq1nIh6eDnYTu/xyLmaUbEwQB36tSf1GvAE3f6BjdhL5Y2Rjyie+9Ex/7w6gUhzQU8vW3JGEQlqTw8g/6u1VawR1dr0xqGsjzIynhNmC8uNBCjwUrY5eYeE0LJ/lgUC+J1hrNh5DF1sAbb3F5gCCnG4rtGO9d5ARumHqAMlkfdkPm4m51mTGy23wmDWpACluoDQgHFh+rL8xzU6yg2tP6Hp3XTkLGoPMIXTqkskeWMP3/k9zq8aVPK4+Fcpq488D4zYeeChTEYbs6LMYaM9TjfewFl9+a5ldOLJPAidnpm8fLhbfiicZ1P5RNbjqfX1dPX3Npt+dqnfnCx7EdhNxS6d3f9PtuZ3fcPpyFqhjfgxZlRVxO+jta7yJYLEl2pnOP6YZzW9fJCqB6cTXL6XnHZHcZc77uHacL36Zm/0TH6WRpT11/p7BGGz4c+WDmVuK2s90MgyOawoucEnq212qqL+REg7piQnaRBjHACqpbB3TazfR615SaiVVw+11NAjDEoJZgcj5vOnwMXqZ2nQ3CnJFscm2BL7dr2p7GCbj9126Js8sPuMZRk4cXOPdyEpm3qUfFY3Pb0aSz93T6rYA7PfF9teFpjwY3nlMMS2Ne01uShWEwmxIsT6Uoea24vxp9xoHdJZBkRgJt4josbf45P81kVLtcLXQ2MA3LkwePaW/k6a6+HHhXWCTmMxscJKUXf9W43q6/lmTw39F7kgmc/uT4YhtMh58Iiwzw0hQy8FYmeu3480A03rZ+6hHhI+ImQHnj7EdrYS2DUQ4CwUWww4U9RatoNu/TiaNf3p0GDC3U73M5Bgi8RkFtvoOkt7iuhsQlsz1VvRZ6bjYhF1iFhaUEzQAoHXBK047E0pn+crbYLlxx6wA4X3tXhR6nNkzDVBwLwv+fdCb6zt+D20vPTSDtNyoT4ruAAI7vsq3yL9RQgNJ7uucBEo2VwsU/wTJ5P4UA/EQY2/djo9x2IwJayiMPNUBDyZ8/SbiWblB8PjVrIwIs1OzZx4veyC9EzSMwW6hGfWXXa5bdt+fQWIP3sdU4+4QdhOaxegTGooUqgMsQucJ4WA8J5DG4fWU1IjNPMDvDhj20uw0JUzxfk/nTP9pwTuHoHN1vAX9y9B966R1osRK9zlmS6rzQxuIA5YImMmudo3isX+3AbSFgjJq0OHc547Systp+DNNaREOzEwDejTv6ERjsHR5HHbrhB3p5a2ht/UBCij9nG2qNGPEfEHHlEEiceiN6PJUL5uQtwuhWfZ/CmfXWkO5ZItj8+DuANwa4rHFVV/W0VDYhpgOGt+rQIAFhs9KnVZUudTO7lFsHZySY7mJyaNMB3Pb11rIb9CghzhMssDN1j8GRMiz63g5kengBC7CKPZ1TfAwqIXeTHqapBrTmec78Ij4qkC9HO9eyeL2AMaQJ4sbdEUk5owroAYnRjhgDD7+wMzG/fNuMmn1QBcLGgaBuiqts4mj0fDtK0vEvywSlQTyfe7auFFH52PLe9UNVzmnr6zUrB+kC/zbawns19tUvRSROLViH7bdFrK2E093VOmXMT0BFywELyzyO2zoOytJLLWi6agVvHmLgrBmCln2fELPtGf768fLJCSwDMZ4k5WJ3dCcV0nlkRIFZmYxL2Lf2cZHHfevmsKIPK0+LW2llRcg2FsGyxJmLTzBtvNreOWe+zbztGU4gjPLDn2VCInkh730/x5TMonuTxkwtWV5Aj+Ve3JQtpBEjPXM42Devm0TfMkvUvdDu4p3VlwlFsNmOcU3ch7mvMnT0rPkFzLAsaCM/zdLvFsdqeAbFdB4LFakgwIiiwDri4xcGswX/E7byEiHGOTZED9sPVNs5Rxm73JUQGTnomzi6IxyNIxNVtCdStZGS35zmfx2b4nwMXn6fTLOJE3B+aRt2WMi5Ck11Oq8EMgQEhDcdplgCpgM6qEPBhAdefYxNdeYG2RRd4Ri8eDvNUMI7MSX2QqD4joZznmtjIE8lVZKpnLQjiq5RTePTwoHXOgynJ7skXE/XzMIBzxAEkzoRCD3ttwTGOU5Pmdj0hiV8bb+BSQJB7pMkqUk/2Y3iO0SbZYI+yhXkUBbyxrKwgmvP20RhqUnsfxkyMqFrlsyeoYAhQhJ7VCp6K9DgMuJcVUlj37/OelwdbNh7QxvHV7o7MBxrwayEKhuccU7Qb9q31uy05owdtlUGen4db4GFthy3zlZFtnguJiPns7RrPZ0Oc3QT1bSgFjxasaeK6mw7ZL1hMmkEBN48yecD5KfY3rdMKfJ8+AZtJL7BQ2gTX3SfNunHAm7tzXzeM34YV+3xZUR/Y0Y++KHalwhu2RjWfjnL5LAUmsKGLXE3Q+63fAAredPxSlhYDOIT0tlWvg2w+5uIrtwVV/SsK7J2XFQCAFMYrh7WJqmlLktsnGDhd2H3KeYDAZ3Hmw1qinauPVoGi1vyZlNN6bveiKhqif47d87RRUPyPALnNDYQQ6l/1OVxgH1IfUoiegvxp1yC2xSMF8brtaMERj5ADyg6Jgnn+HL0cJ54uAqPDeLzLFntLF54wWtG+0n3Zz4yi7NWndCW3JnH6eKOHywxFY/acHnIEHu4W8trJkjk8wtDKfjomF0lxWTw+cwnEQ2e2aO7wfXAU1u+t1g542/yGV1fgSuPugBCOuUS0B1l/Z599yBoDNym750WGezTnF4e/f31AQ+rMpg/KavEFAz8GuHwSxqvLXi9qyqe6yGSAVej95/RC1R1PDPzw5Os5yQz8+SSe4VMSNJ3JHQnPiFzudFipQUzLg5pwkMhj1ba/ecAXTys0owztp7jJXluEbQvQ0CHB+eD+XE8qP61vRNztoxY+D04GmNb9TB9XcCpebjsNU8LeDZU+VOIisTwwBRr38hF48LpPLiq9eFwzuVlJ7trGPLcDdp8eAHvs8AMT3Nxxe9cyjI/CGu45XsSnPf/BfbGaPa9ux/h5gAZqzJSDTR6PrJC8yS0X6wnDb2xmTGkMNIx5nZ2sz41ja6luqXweNsZJlsbnovygNNyPis8DqvqTplZvQPD7FUBnqe0vj23ZNBKJPxHRyfGoArGBNhln0882OVxZbu0cGcgv2re61dGgjvHTinmZcJ4yiRayfILWRrbiY23RvH12WPekipsWxYZ+HzDpGYN8/3gttRbzGt6rNU8inaPs+/6pbNftOmO9Tuufw9yeDtF8qI7y8DwJS5QHQJl8csyzT2sVgosRTpbi8dFd2LB5W2FBGXo028fwNcsJxWN5NpAjo5h/KDXYzYdwQodduosh1fITmydxHOeoHFTbz3G8lkHa307mKQfFoBb/Xlz/T++v/JKuj8A55523BZVzrttmyvPwreAzXZCnQA4B49nejlo6OLk8pvN+H2kM/JBT1zmaQtThbZgJ9HM/T7e1FGBdyGaGAIJA6z5My1J3s0fKZxm532ipfUbPQiQf8iegGc+4Y9QEpC8veywDokBjarpupjDYjP6dxzmcIoLPoPOpCuicAR555mDzIg28D5J6z/me1HzIwYOBBImRRjgfINdUUrM/d87Icx+XEUlT6ODap629iOaEqNuS2PFTPbYL4PXwgE/Yk6r0TyZQa7azFljQBppV3CJ/rnIeXitmk9RM4bb4DBsBoD7HbMHywUcnIrf2fsnjPbgF1hGQuBOW5yF67pCvfB4e1bHj1nF4CXY2+XS7sQTFDMF56hP2Xdvnf4id1TrsPz0B8fovHo1IGIw9uB3ouUE8qIa7oNHmswA6HyBW7Ru2mdndRRDSB154UIDoHM0D86yQ9Vgf2uuBRjcrVtgzx/C+PvwHmYFohQrjp/yw4PgOmBYpuvsiNrDVPqXqsRL2Q57g1Z5FXCY3u08X4ArP2Q1H+8FFnnp1j8zjnuSaz9F5znPPzlO2sqe2ngO/sF/PNiE2lzoTecyuB7gnHkT0L8EKFcIoWNBE4JDJdq+dx0+x+LiQinHonuBglmHpMGs8hwg7tvM0wrEC9rMjlxk/1u5SSjG3pwHsbHKB283je9Hdh3M0eTXxw/o9MtPOnGbV2KfJeowHicQSjCvdqiYYdN7ngWpkwgZv7tfNjulGvP+hHT3C190cTj3iP324ZbNjGztpLeea7insLC0n7e2zPRzPtIQByIFDbhU121t++tc/z1za8rWiz5FldOQcpseWYQg82Wx6HmGpwvb4esZ2soBLvCrMJ9LRXTWbJbjUvTdiC/y2rkGeh3j5/LJeh60uL9rbza3bqg8/W7ASkI8ld6tsn+cFgTyWjJNP7rLA2YAmnxwXr3ekc6ap/pzbzT4/5VvkCXLMh/FE+81AVZZeud5OKyTDXnaPF8sZPvboLldZSOftQzPsA0g+DzSD6riM9XryweeGZbSOrSnMNBN3HmOpDUF2jHMCfHgMtjrxQDN078MlLCHB9eB1PSSYzm4xHs2NXTe98ysTZR9q9/qgNswkYTrr9VOPtJEzTLixVgADnkKindg+VTnFoQ90Za6tC01bP+MRKVzL4MJIXPk8jGd5LKN6xpT8s9e41JV0aR5dmQyHfJ9Etc/08Rk2n9XUfBefjrg9+9cuS4/JxiUbSjDx2BGFmJVKT/pbMfXchc2OHuh186v7BNx2zDNm63bT9cGKYsKWz+skPacPP+sYVYDi4Y3Mvkcn0UxufnWfGosI9JE9wa6YtwMCxMNn+ed6z6y72eRR2lM2tD8hIMhT/CMme/wvHw67NxP9fwBClcdf9sJXIQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+MCGQsdI1qLenYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAgAElEQVR42uy9e7S2aVkf9rvPz+k97NN3mG9mGAaGQU4DRSwEAmiAaCVZmhrMatOYkqglbWOiYWlXo0bTVA1Wo0tDlokQbVZrVkirIW1ijcXEEDHGKOBhEJwCM/PNN99h7/2+73O8j/3jut/nwxjaZWsMMPvhD+ab2d/e+937va/7un6niwV7ExfPxXPxPDMfefEj+Ox/vuub/gJ++p//K/Ebn7ghCy3Vg9dOmtNtXzrnGh9Sed+Vw8v9OPHSaF4X2jx91i6BxISUC8kZnA+7S6s6Ms53SJhSivAh+tvnuxuMs1EK0V49Xo//1/XbuydunrnnPeuK/wOv+fzwjd/53Rc//M/yh110AJ89z3/8B7+Y//Nf+mhzz8nqJEbcixTvL0vz0DDae6Tg9yop7/chNFqKmktZKpZKzjmM0dBGA2BADEgpQUmJlBLcOEBpDc4ZOGOIMSIBSCGAMQ7GAAYMSqnJOrvlXHSc88dDjE8Yra47Fz7WW/dEbfQnb2+6W8tltf37P/mP48Vv66IAXDz/H59vedufYj//4d9Um7a/0k3uYcHwSAJ7BMBzBWfPmqZpVRdGF4WRYAxKaWgt4X3A0HUwxkArCS3pAAshIaSEEBwAwBkD5wzee3TbHbSSYCmBcQYuBLzz0EYjhQDOGRgYGOcQgsNaBykFOONIKYIxBsZ4AsMYYzpNjD0hpHxMpPjLq2X9QSnlR564eX79Ofddct/+zh9OF7/diwJw8fwbzyte+ip249adw2VdviSk9JLg3KuNUS/x3t9TlWWDlJjWGlor9F0PzhlKo4GUIJVEjBFlWYIDsM6iLEtIwSA5gxQCCQyJCwRn58PPADhrwYVEigGCM7CUIISgLiAlJABCCLAYIJUCUkKMEVxwUClJuUtg4CyBcw7OOcZxghQcSsoEzjvr/HVjzId2g/05LuQvXDpY/LouzO1v+8EfuvjlXxSAZ97zxte8nnGg+aVHP/GSKyfrL7Y+vJIzPCI4P5CcS8YZgAQkoCoMkCLAOaQQkFIiOgspBYTgUIoKQUwJWgnEmFBXBWKMkJIgHqUUhFSIIaDd7RCCh5ISWisYUyDGAJYigrUA54gxIcWAGBMYA3QuMt57aK3BAHDOIDhHTAlCCrB9t7AvApOD1BopFxOlJFLwYFx6ofWdwfpfk0L8CyPYP3nqzuYXrl467N/xrh+96BAuCsDn5nPtnufpRWXucyG+CsAbpBRvlAxXOANXSoExBqM1YvBgXNCtyhmkFIjeQ0tBB1cIaK2glIK1lub1RG39arUAZwCQ/16k81SWBawP6LuebnoGNE0NJQTAOR1SZ+GDh3cOKQIJiQ46YxAc+SBHCKnAQJ1CCAGcCyB/zcJo+Pw9KSWBlOC9pyKiNcA4GOfwzlFhEgwhIrqYnjZF+bPK6H8kOfsZxflTf/EHfmi6eNdcFIDP6ue+aw8bwdnDo3VfXBr1h7VWjzCGhqUEJemQSyHAhQDyLSk5BzjPh5gj+AjGGQrF6UAKASUlgndYLBrEGOGch1ISRiswxrHb7aCkpM8nFULwdOCkzEWEI4YAKSW4kECKGPseSmvYcYBWEsEHTNMEpRV4itTeC04jAWP5e5FgSHDeo6oqSCkx9D20MUgxgUuBGALsNEEbjRgTdQ0xQkgJxAipJBhjCIkKk1JqJ4T4KIAfZwzvjRG//pfe+bcuisFFAfjseF7w0CMqpvjQZP0f8TF+mdHqhSHGotASWkowBsQQoJSCyi0643R7IgHWWgjBIYREU1cwWmK36yAFAXRaSYzjBM6AuiohOAcYwBmnGzeEue2344CiLJEAFMYgxohgp1wMBLx3ABMI3oEz6hrcNMEYDe9DHiMEgp1gjAHjVISARKNIjAiRikNZVUBKsNMEzjlSStDGAHusgTGk3DmkBEgp4T2NIlzkoiAEpFLwPoBxjhii5VL+qpTyf5WCvfcDH/rYr/yD9/0Tf/EuuygAn1HPt/6XX413/fg/vceH8OYE9idKo18GpEprDSUIiVdSIIY4t8OCc9RViW3bYtnUiClhu23BUkSzaCCFoEMaAgpjgOghpISWAmfnO9SVgVJqvsmF4OB5dFBSYMoHeX+wuBAQjEHkW1kgQXCG4D1CjLCTRYoRnAGcAYwxuqUT4QGM0dGPMUIphZQSYiQQUimFEAIYAMZAYwESjSa5GKQYEVOEkhLjZFGVBZD/rLRCigmMMXjvwLmAMgYuJri+peIjxJgS+9ec8x+NYP/QpfTkt/3g37x4810UgH9/z5e+/g/oX/y1x17rI76Kc/4mo+Wx0YpLQbexVpIAspSglKJ5WnBIKcEAWOcJ7ANDU5fgnKFte5RGIuXhXikJ7yyauqKioBTdugC150LAThYxBuh8EPfFRhcZ4ONUTOq6oq+x2UIpBSkYhq4D54T8B2chGAAGiDzbBx+gtUJiHME7eOdpdOAMMRLyr5QE5xxSSaSYqcEUUZUl+mHIr5DwhJQSxmlCURTz6zNFgeA9OCOsQUgJJiRiAhRLsNYCALiUCCGmmNhtVRQ/7UL625946tb7/tZ7/r69eDdeFIDfo0P/BvYvf/Wx4xj8H2WMvVVw/ogpjJSSDlmMEVoKFEYjhAAhBEpj4IOnFlcKIAFGK/gYwRJgnUNVlnDOQgqOqjSIPmCyNhcOQEsBrTWUkpisA2fA0A+oFw0KUyB4Rx3FdgeZ+fwYI8q6wjRZGK1RFAacVH7wdqTrOkakjBFwRh1BjIQ70BgQUFU1hOCIIYKoP0YgZf4aUgoQKpBgihLjMEByRq8xBEghASSEEFDXFfp+gJQSKXoAnBgFSYWOA+CCw5QVrKXvOyUgxIgQPIKn8UlqhRCijzF+KKX4I8eHh//T6a6/843f+9cvmISLAvC7/zz/oUf4rTvnz+Wcf1WI4U9KIe4pC0PtNWfQ+fZLwUMqCa01AXycEXA23/WA0RrDOKLQmkQ1+RZvmgqCcyTvICUx7c45lIUBElFv2hgqApOD1gqcCwgOTNZBMobEgJj5/sl6NKsFlFQE4OX/No4TnJ3AucisAbJCMAIsdygpYRhHAv+ymEjuC5w2iFkbEGMEZwxINGokxpByF6K1QkrII4KHdxZKSvhAegKGCKUNnLVQSoOxhHEYoJSitj+PE1zQ9xniXZ0CY0BKpEMI3sMnXIc0fyel9Dev3zx97Af+5797oUa8KAD//58vee0Xio89/vQjN0/btyWGtyjBl4VREEJAy/3hVwAAwRmk4EgASqPRDyMKo8EYHWbvHZaLBThn6Np2xgKEEKiqEikGWGsRnEXT1PA+EGIf4wzCaa1gXUBhFKTg8CHBOYuqLEnplxK8ncAY4ENEUVYoygLOOULzkTAMI3wIWC8atP0AoyU251s0dYmUIlJiBNzl16a1QkzUijMAzWIBZy1Ylg5rY2CnCUeHB+j6fm7ntVJIYFBKQHAOpRTGcULXdSgKg+AdlNJ3AcOUEIIjXhNAWdUQgvCM/WhgCoOxH1BWJVICUgxIjCEE6kwSUlcUxXusdd//4H2Xf/kP/9lvvigEFwXgd/78R6/9IvHox598+dm2/wYf05u1kpXRdNDLQtPhkoyAuBihlYIQHFrn1p9zjNOEqigQgkdZFggx0mydIhiAuq5gpwnLZYO27cA5h9EKKbfVdppQFgXY/pZmpOvnufhY6wDGUJUFvPdw0wStFdw0EpIuJOqmgdKKMAEpMLY7CMlhrYdUCp94/CmslzXqqgRngBQc4zhmHQKHMYaATM4xjROABK01uJSYhpEEPoleP+ccjDPEEGHthGXT0Dyfi5/KP6O+7yEE4QhKKvjgEWOCHUcURfYsIMGHiJNLJ2i3OzDOgUSsA4mXIrTR8M4hhEgdWKDxxRQGPmKcIv5BTPheZ90vfNNfe2e4eFdfFID/1+dr3vIV/Kd+7sOPnO36/8aF+KVKikorBa1EnnUBITgKrZFigJYS1nuUhck8OyHmIUakGFEajeA9Do8OMU0TnA/QSqIqDaTgcM4DKWGxaLA5P0dRGMT8OabJYrlsYCeLIo8bYIwOpZSY8oFPMSGlCDdNSEjgIJrNhYjVeoWqqtB2HQolcOfmLbRdj7quoJVC24+oCk0dg3NYrZbYbjbQiuZ3rRSKwsBZhxgDhCStgsoUn/ceSimwFIie5BxlWVBnwzmmaZqZjKahud45ByGIAuVZGCSlwDhOqOsKxmiEjD8UZQXvLCZrwTkHGENZGJR1g77riEWQEm3XUVGtSviY0LYdqqpECGFUSv0fq9XyL2927b/+6r/0jouO4KIA/Pbnla96A37zox/7PO/D20fn36IErwtjSPeeqTUhxfzPSjAoIeBDRIyZ11d0e+/n1KLQuV2toLWcZbp7eew0DBBSotAE7EnBsVgsMPQDysIgpgiAxoXlaoWyLMDyzYiUUJSEpHPOsD07R1MaKK1grUNTlzg938EUBk1dY+w7CM4x9AO4ovFBaYNucw7GWeblI0IISIk6GKMVuJBoFg3OT8+gNBUKJXgebRjp/qWA0QrW+TwOpVkhKIXAOI7gnKEqNGKgQiGVQlWW8N5T8dtsYYzGkH8mB+s1pmmCEALDMCBkxqGsKvRtOxeCECKEYCiMwa5tIQWxCvumyVoLpRWcdSNX5j3LRflXrp+Nj/75//4dF2/6iwIAvO41b8QnP/n45dtnu28IKf0pztghGVlEprUStFYQnJMmPiUUimb/FInHlpkXT5n6i5HoLZalsFVNKjkpBYLzCJkR8N5BcQbrqB0/Plii6wdCzRlDVRVICej7HiabgQDAh4CyLDENA4CEuqoQ7QSjBCbnIIWE1hKj9RhH6hLsMKKqS4zjBO8DmqbCNE6oCg1rHaxz4EJgHEacnByBM2AcRnIHej+DfJxzyFwA9qahqqJRBmCw1qKqSmitYSf6+3VdIcWI4CbqjgLhBjEExJTAUsJiucAwDNBawzmXRyvCHYxREFwQW1JVBBRq8kAURYEQAqxz0FlUNE4TqrKEVArTOGZxlYCPQFHXG+vCu4/X9XedHCxuvPZPfv0z+v3Pn8kv/hUv/vz6lz786H/x1O3NL7oQ3845PywLTTLd3MIaraCVzKh8QqFJwRbznB+zQ05KQdJWIRGDBz5FJZdSQt8PCN5jHAea0+0EyRjNwoyhrgpwIXDp5Bhnmy0AUu8xxnB4sCZEfAYLI6J3NPd6jxQ8tJYYxomcgEoRh64N6rrG2ekZnHMYxgndMMIUBgDLUmG64WOMsM6jbhoYY9B1PUIM2QvAwRhHVdcQUqKqKwCJcAVtUBgaT4zRJPBBgjEKUikE75ESUBQFpNKEKxQkAvLek6lJCoRIwiIfIgpjYK0jcLMqUZflnGGwlyEjEZg5ToRLVGWJyVoSKglBDMo0QSuJuiphjEFdGsBNq1Wl/1w/ul/64Ecef9v3fdPXNRcdwDPsefCBF/JxHF9zuh2+I6X4KikF4/mGVyIfdGMQYqR2X0qUBc3y+9bX5FbbxwCjNGT+ewDD2Peo6jqPAfR5xmFEWZUolCSpP4CmKvHYx5/AatlASYnVqkGKCX3foygKFIWZVXRSaVRVgX4Y0VQVQvAw+ZZFcJCcgDoA0MZgHEeYqsbY95hGOgguRNx46mlcu3oyA40xePhAhcrHhOWiAUPC+dkZ6rqB4GzGG1TW7RulEBONCwSKEssAJEjO4UPAarXENFmEECClAmMJiAFaazRNDcaIafB7zCSPBgmkkSjLEl3XQwo+jwM+BAJQGcsjQAnr7Ay8xhCgtQHnDOM05bFMwmiDlAK6foQUBMIKKQEuMPj0ASH4X3z2lYP3ve6tfyFedACf488LH3rxlRu3z95567z9x4zh92klmRQChVbQ2WJrckKOzDRYWShKyAHgvIf3Hm3XwWgNJehQTNZCCOoOyrIECV88tbBKoqoqCMaITpssnHU4OzvHtauXgJRQNxW6tgdjDGVZEEYwWbrp+gFCcIzDCK0kurZF3/VUBIyGKUuEmBCyZddOE/H4bQvEgOgJwDtYL/HAs65hu9lg6Ac45+A88fmTdUghoO9ahDxiLFdLmqc5g1QSzjlUdQ0XAhAJh0gpQUqB1bIBz9JizrK4qa6QAMScQiSlQEoRwzDAWgfGKGAkZdrP55+x1hpKSlRlASkFfPAwhQaQ0DQ1qqokniAGMkBl3oAaA8JkvHPQUmAaJ/RDjxgTjFYwRiOLCJCCh0J45aIy/9v1p0//+rv/8jdeuygAn6PPG1/9WnVy9MAf/+jjt97vQ/waznlJtzuHUQJCkP2WNO50mwghYLTMt6VEVd0FlwBGb0xNtlyWXW4HB+vcOiMLaDiElEjBoakLTEMPBuDwYAXGaJ4+OlxDMIbDwzWc96jrCqvVEqvVElVVoVk0s0pQCZ7tuQHtdotxtLA+4ux8g67tkBIwDgNipHQgBkBKgeWihpEcRgqsV0sKEklAjDRHpxCgpUBVFEAW78QQCIBzDt4HmMz3y6zcWywayhEIAc45GKWgjSaHH+hWJ+yA5dGAjirLwqEQQ2ZCHLTWOD46QF1Ruz8MA0xRoKlr6jzy/9q2B2OCnJDZj9B1HY1g+WBrpbBcLNAPI6qygJKSMIqUILOhSggBpTWCc+i3O1OW5msFYx/4sXd8y5/4jq972zMmK/NzfgR4/Wu/GB9/7LFn3zxrv9P68OUMUPswDaMI1TdGI4SIu/9eZkBP5fmaFHtlYXB+voWQgoRAShE1mGWzeyowZslqXVfohwHBB4jswSflHYGEZA5iszy2LAsoJeGcp1k/AT5/rnIvLWaAHUcK7ghhn9mHdrvDYrmgPAFgZiWc9zPdtmgqdG2LYRixPjjANE0IMWHR1Lh96zaqqiCxzjBgtV7PbbVgCVoRA0AtvcjUHYGiUkpMQwdtChIOGYOh72FKwiumcYRSCk1dEgUo5VxE+q7HOFmE4FEUBZqmma3SfT+Q5yAEgBGWUtUVECOJpBR5HqQk5F8qibPTU0ghYIqCxgbnsWhqhJSoGHNSKO7abi5iZ2fnCD6gahpExr3S+sclwtt/4/rm42//HA8+/ZzuAL70dV+kPvihX/1Pr9/Z/pz14S2cMSUEh5Yi3/o8z+7AHvlXgkNywCgxH36bwaVhnLBY0Fzsp2nO2EsxwWid/fiMhDIZPU9Z8lo3NLenLJ3d22+llGhb8tCT3j2iLAs45+GcgxQCdVWi73twBnS7HZyz4CnCWQvECJYStNEYxwnTOCJm9iEEB8kIa2BI6HZtbpNJl396toHMNJtWEjJLlmV2HZaa/l8KAWdHeGdnnQLnHAlpNiDtk0lEDi4RUqBvdxj6DlqR6GcYRgopSQngd6PH9uElZIZq0fXDrHmYJgvGOGLwmKYRwXs0ixp932EaJ0x2gg8+U48MB4eHCIFGgMIUYIxYFmepi+FCYBhHGGMQPWkw1usVFosadhwgEaUW+Io7dzY/u9bpP/l73/0t6qID+Cx8Ll968Oq2Hf+qC+GPIcefU+tHNz8JegSk4NQ+ZvBJsGxhjQFFWUJyDpv1+ISyF+CMwU4WZVVgmixWy8XdisoYnJ1QlCU4oze0tw51aXJrnHBwsEbf9SgKk8cHosqc9zBZVmytJQqtKmHHkSy6ANw0UgiI93OHIjLXrgx97GLZwFkHwVNW31HQp9J6piBH63B4sMbpnTOUpcmWYolx6GeaT+YiJqVAihG7tsPJ8RF8LgDBk0VZKYno3fw9ky2YxilnHYzRUEqhMBoJwDCMJINmgAsEDPKMo9R70ZIxcN5DSTHjIZwByhgIxmfZcwgBPsSsWRBYLhdzwWYA0aWWwEiTfRTDMIIzhmEc4ZzH8dEBnPNo6hL95MAYw/LoGLefuh61Kf6eFOwbv+zPfesnLjqAz4Lny9/wJn7Plee84WzX/zPr/R+ny500+kZLyCzs2ctepaAMu/2Nk/ZON0myVef9zF1XVQkpBCbrsFwtUGaZrM26eI4IRI9CK7AYMI0jirKCKUtMWZprypIovpJoMR9SFrSQgWZyLlOQDNE5pIwnGEWa+NE6WB8huYDkjNSFjjT1UpDdODgLJA/v/Cy84ULA2gnBB+LPtULXtrP3f39L85wJGGJC2TTgikaPEAjcAwMKoxCcRQweKXpMwwApBIoswNlTpJwxmELPIKkpDKQQKMsC3jvKRshdF+cMi6ZGWWgcHx7k0YY6q+PjIywWDU5OjhGcR9d1iDGiXixgigJVVSBmQHIcRxxduxfrS5fhnEcKDstFTWrIts0OxoS6LrFeLbFaLdB2PY1xMVESMgO2t2/i2rOfzZVSXzlN9qff8z3f9obv+Lq3fc6dF/Gt3/z2z5kXc+XSc4qPffLp//a8HX4gJVwm2yrx58aonF5LFF7MsVz72GuZ34iCM3LE5UIhhZgFMADFaokcy2WtQ1WVAGNwziE4cughUZstlcB6tcDp2TmqqkRVlSi0hss3514hx/LB01rPBpvzzS5r5YmC45kq4+wuiIYYgawlEILDZcFLjMRmKSURQiSALltzyeufcwBjpOw+AFIZnN45JR2981gtl1gdHJCcdxgguJhxBe99Ti3KYR8pzjZn7xzKnEOgcoDoarUEA2ULsKwrkFKg7wfSJORdBO2upajyroOzOTdQK7S7DgCwXq1QlAX2uw7qmg71OIyzh6EoC9hpysWaESMCYJH/7tnZOSTn0NogpIT14RoAw2azwdHxEcqyoNaYC6SMs1RGH3Kp3nLlZK3+2T/8iZ//D77wTf6iAHyGPVcvP+dyP04/2o72qxlnmrHszsvhFYITos/y3Kpzfp7M6bhFluruu4JCa4zWwk4WYCBpbozzTR0Cae8B+juCc3jnITiDNoooNkfUm8038bKpEWMghR1j+XtgKIoCwzCiMAZlUeCpG7fgrUVdVwjOzzdlTBExu960ljMQFzyZgohNI7prz1TEREpBMEbx31JmmzLPt3IBHwK6rqeUYSmJ+qzoIDjvMbSUygMAMcT5c/gQUFZV1v2L/CXJIFWWBXn5c6HZW4r3RUMIMdN9pjBZVjxCSImmaWC0RrNoYIyGnSx1MylhuVxic3YGBiqU4zDOEeaSkySZJeD89BR916Gua/RdThVCwmq9gjYai+WC9hxMFsfHh0hg9PPMUuahH2Cdw5XLJ3RQGOR2s/39i9Xi5R/5wM/8zPNf+brdBQbwGfC86EWvxOntW6++s+n+hg/xRftbX3CeU3VpQYb3AU1VAjnmeo+Mi+w1N1rCaI1pmkgswkjr32fraaEVccyBsvKapsHQtVgfrLHd7tDUFXZtR4enpENlM2gItue2BbpsUjk722C1WsB7j+PDAzx18zZKY7BYVKirCn3fg5HfFcE7FEaj60fYyYJxBiNpBt9TX3twzxQFgp0gtaaEnZQoOpzQyjnBJ6VESLqmAwakWbjEGENVltncw8BTyFl+EZyLbPPNAGCMYNTyZCyFcI/VcgltNOxE4p4YAoqiuKuazHiJMYZAT+8x9CRtdj6gLArYXOCWiwbnmx0YEuq6AmPAzZu3SVshBJK36PsBi+UCRVHAjaRx8AlYr9fZMsxxeHSY8wwUQo4gU1lH4JzHlAvQlAVJY9+BCYX64AjJ05jnxgGcsUfHyf7pT97cvv8b3vF9Fx3Av6/nOQ+8QN6+ffqfn237Hwkx3T+3/JwQ/X0RIM24gd8r+UBt9z7ZplASISSYzA+LPJMqKXP4ZQCLJFJReStO8ETVee9JKsuJXaCkm4hpJJtv8AGH6yVSvh0FB0KIsM5hs6FMgL2EdhhGCuoE0LU9CqNRGE0gniWQbZomSM7BkTIazwglT2T3ZWC/hZ2gyHFqv1M2DlFngFm0RGGdktgFxrLVOMeDZfqsKIush1BQmm5y7zxJmrMZSApBh//kMtbrNYa+h5TZSjxNmWalr+O9hxQSVVXCuUCMSSKrsR1HmFwspnGAD8R0FIXJwCl14OPQo2lqaCVRGEWFKYeFVLnrcdM0U4kpUCcWnENZFYgJYIwTdpEzEJVWWCwbHBysoTm9/r3z8b4H7icAMfrj6PwfWS6qOx9+///5wRe9+ovSRQH4PX7+w0desfjE9dvf2Y7221NKFdsHWWYN/z7Jhm4Z0vMzxvL8LuaPJSFQvt0zFVUYQ0h/bt1jDDBlAZZivrHMXXmt88SNc04S3L5HVZNSrSgMrA9wPqAoNK4/+RS22xZVVWK9WmHRNDjfbOcZfbFocOf2KXwgxH6xXMCHgGAn7LY7GKNmqeyerYgp5tEkojAaSvIZAwghoG4aetOHACFI0w8GrA/W2Gx3d7sB5wDGscg6/+D9PEIhhUwPKjhHYwOAWfkI0OFhibwBiXEgRvRdm0NSZLYwU4HieT/A/vfhHBWH4D3A2YzWhxhRFiV88HNhZSClpHcOVVVjuVqi1HIef5SU2ZJczjbjxXIBP42zPZuYGY9xJGWlMRox0f6EFO8mK8dEOYR2nFCVBjdv3ITgwPG1e8E4L1hwb44xnjz5oZ9//3M+/zXTRQH4PXpOjh64/MTN8789WP+fARD7dnIfzSXyqiqRV2MhUToNZ3Tza0Vvapm7hJgDOoIPWC3JGzJmdJ0xBlMYGEULMfZdw2rZ4Ox8k4sAIetlVUJKiTKn82w2WzgfcHy0BmMM55sd7rv3Hgr0lORuOzhYEXKeE3JNYbIBhgwz56enYInm+n3QiHN0W3IpATAER2DkPrBznGg1l5BEcxKVp4AsrimLAtZatN2AqjQoqwqTdVgsahIXpQS+b/kz/Siy5FlKYhOstYTkA8T5DxOOL12CKQrYcYD3Fou6vhsnngG1GAOarKWgRCSGYRhQFASmjsMAO1mS7IIhRHrNFP9FrAcYI7k1I6Cz7zp4Z6lrySCtVjLLjIGmrsBymEoCjWN1UyI4h5AVlt5axLSniiW6fpg7kstXLlGBjAF922F19V4kMIR+y2qjX9H1w+d//Jd/7qee+4rf314UgH/HzwP3Pfy8W+ftTxGd/xcAACAASURBVPgQX0d0M/sUQC23bDILfBifc+lmNJ8x0oCru84yBkYZ+5n33rfoR4drwgKkzJJW+nxjFqfUNWXhHx8f5na6yPr2fUgtmYqGDFTtEWgpBSZrsVo2EJzj/vuuwVqLXduRm48zdG0HZApQS45hmLI5KesEfATb5+Mh0S2rJaYpMwEhoqlrcC5gnZ/n9MVyiaquMQ4DlnUFmbMBrHMIIUHmtWSckxaA53VkVAiLGXxDSthHFaWUYIzB+vCIYrr8lI05lPHPOf1M9r8DaykV2IeQ9RQUFBK8R9PUWCwapGwtllKhqqucU0AOQJa7m67vsTnfYtlUpKOwjpyJUlLwqlFoux4xRqxWS5yfn8NZh7IqMY0ThmEg23VDoStj18E6Rx4MMJQl0bPDSK9n0dQYuw5j11EyExIc0ZEPtm3/ho/94vs/8LwveO3TFzqAf0fPen3fq67f3vxkjOmlM4qZ9fZAAmccWvI8F7O5zdeaOH2fOX26XQhgIxRf5DdyxDCO9HFAzgBQcwtN2X53C46dpswy8LtIOqfuwFmbtQMFOANWixrXrl6CkgJ93+eRhKPrBjz6kd/EODnElHB2egbvPfquhXeOMgETctRVkXnsQFn6gTqPerGgPycyBJFHv4S1FuM0wjqH40snMEWBsizJmZidhpN1AOeo65p+Jrhrxum6HkjIVl+TdwxS4KkpClRliaausFouIAVtJOr6HiFQUpJzbt5bsGuJypNSgjOi7GK2S1traXSTkjQQkqzFzloMfYeYRTxNtir3/QApOJqqmrULXAiUVUkW4WGkBOEYsVwuEFPCkB2Wymi02x3hLTHh4Rd+HlyIMGWBGDyic3DOYRxHuMnCaIWp6/Dor/w6NucbXLnnCmrFcfuJx+ESw9H9z8bJ1cs4OFy/VCv53n/0zu949UUB+F1+vuR1b0DdXHtzN9ifCCE+cPfws4zk8wxWIYtoRBbGCPLk5xQfLQg9H8eJqCylwbjAatVgshZDP86HmXFGctxxRLATpmHIgZkp8/DUHgIJKXrUZUHAY+4iVG4dy6Ig9Vo2vVgXUJZ0aGxe3jENPQqtgJiwaCjwIoSIlAAXEtpugDBkpkkge7BIEU1poCUDYpilroJTqtDJ5cuUGCwETk6Osdu2cD7gxo2noY3GMFqcbltce9b9sJ5udC0YWApZXedRVjW4IJXfNI0YhgHOB5xcvYp+dOBSgXFBlKedIFMAvEVKmHcR+uCxPT/HQY4229uKQwhweY/gwcEapjBzgjKlFltIKUnHb0kvAaVx/+e9AKuTS0jBYVFpLBcN6tUKQmkaKYSg+PMsaOLA7O5MCbjn2lWs1ksgBtRVifPzDVIMkIxBZ6fg4eEBDg8P4LKGYtlUODo5hg0J7WjxwMMPQZgCbuihlcDZboRarCCkuG+9bH78vd/37X/oA3/n+9nFCPC78Lzx1a/jH/n49a882/XvTikdfurhZxnkI3mvokAOyedwzT1fXxQ6C2iQATNC8IktIADJeU8RVlKiKAxMfjN5Ry1qzLftMAzEsydQgi1I476nzqyl9dyMM1RGo+sHLJcNbt2+Azs5rBY1GANsvvHLwmDR1JjshOgJmHI5/y5lgA+MwWYF3x4so5qXciQWdQWcMULrMy04jtMsSmKMKM/T03Mslw3KosDROt+ObYfFooKbSHK8Fz1prVBVZPARSiHmdWHjMMA7R7N58LSuvChoYWgMQC7Mc7ESEmVZYBx6KK3mQyqEJP5+7ydgQN+2GEYy8exDP52zQAKKqsKznvc83Pec5+LOjRtwQw8lODbbHYJzlDmYPRRKKqIVMwVblgViTBj6ce7aWBZfBe8xjQOBk4whMcIrrt53LxnDQoDUCoVWePrJpxCcw9HRGkPb4uz2Ke69dhntdkfR5XaqAHwZQ/rE+/739/7KS1/7hs9ohuAzWgfwoue/jF+/efrWXT/9QIzR/Nabn1p8nRH9vVhm38LqfMvElLCoS9KNexJ6eOeglMxvWgKYyqLAzdt3cLBeZZSaAESdQzP2YaD7YI89k9C2HU6OD7Hdtlgta1jnyQewl8JqaqXHyc2rsEIIMJpAKtKrG3AucH52nsdqki7HQDvyCmOQGEWNT0MPDuQFnHTYGOPw3lEXATar8/ZR20VZIniKzTo8OsQ0DkDwiN5BSFL3DeNIwR6WUoViDIgRKKsiq/sMqeOCx67rUZYFdMZGlKI0orqqkBIlC7FEq8WNMZgmO28l+hTnft4XSLQoy0KlIt/CMUTEPNIYQTqCbW+xvnQJi+USU7tDuzlHVVUotMxRYh5c0qJVN005IIX8CKucbdAPI6a+R9+1YELgyrVrJMEexux0lNjtWhijcfzgQxg3Z0huQlkYbLcthrZFP1pcvXoJSknsti3O2wHP+7yH0O466hTJOGWhy69XUv6NL/zTbw8XI8Dv8Hn5S76APX791tfuuvG3H/4M3u0z+KUUZJfNgZxKSQK1YoQU4q5STEoIzlGVJXHkUpLkNO+wu3xyTEi8UYSE5/VXAG2mWdQVfE71TTHN1tjJeRSlwa7tKU3XOYw5r8/7AO8DqpKMQ8MwoqkrWOsoJit/70qrnGwTURaGHHLZ5WcKk01GFlppLBZNjsMO8M5nfYMhZaOS8yzNMzVJPgBL2gE3kZiFUyio5Flzv5cEC1o0kgLRgAwJQhLd6e1IycC52O6FRnuArh8G+pwiB6hygXE/5kwWzgdM04jtdksuP87z4SdQT2uF6D2xJIKjNLQgpChK2rGgOLa3buLWJz+OW9evz6wCzzqD8/NzDOMEqejnOGWzT0oJ1jlACNRNDR8jFosFpJC4c/PWrJUwRkFJkoOnGAAwrI4vYbfZQjCG4CwWqxWe8/BzwZRGvVpjuWzw3Oc+gGlyOL50DGstFk0NbQpdFuZ7hOD/1T9913fziwLwO3gefOCF/NHHnvjz7Wi/N6Y0H/59G4/M+TMwWnCZY6Xozcso1isR6s0Z4CyhuCkj5uM0ZsSeUMSmqbDbtRjHabasmiwY0oZmS6N1Ds4kHX2IEVpS3lz0Pufq0zhSGAPvA6x1aNsOSkl0XYf1ekk0VR47jBJoygIhUnpP8ETjhUR7AwXnWNYVWApg0eftOIRKk+ONRDoMiXQHWceupEDTNLMj7/zsfB4lCAjl85YfxulwS6XAOYPzng4NGG0KSgkIHsE7xETbefamKOep/d8Xs/1K8pgDVFQWVtFi0fz7yEpCKn4yR5+VqJsaMSbErNDcbDZEy0kOoRTWBwdYHxzgypUT9P2AoiyglUBwDsPkwLjE+vCQFq8wCnI1hckMCUdwHme3bsGPI6rCwDpyKdKyVpJkD/0ASAVVVvDO48bHPoKmVFgcHmGz67A6PiGsaLS4/4H7MUwWIUZsT0/RbbeALnHvcx8GtEG5WmG32WjD8V2FZF//mVoEPuMwgJe/5AvYkzfu/JnB+r8K4Le1/fvWer8Fd39rKUW8tVIk+qGkXZkFMBIc1OY3dY1psjlEwsxAVLvrIJWiXHlPeXt76i8GD60EdtsWi6bK1lLKARzGCTGBnH9FASEFlFaoygIJCaenRD0dHx8RKBkClssFQvDzcszdtgVjdJCRzUrEQSsYJWGnEUVhqKvY4wARODg6xHq9wjQ5SsnNgqC96q4sS5yenuf5n0MIRt2OIOVejLTBd7Iux3kFSMFQ1RUWi4ZoyaKkDMMc31XXTd5FQFHo42TnzASpFJCXf8YQsyqR7MEUAQZC950j67PWYJxjGEibQJ1dxGK1yr/XrMzM8ty7MzslCYVIasjFaoXD40NIQcq/GAnVd9OE4FwuZBFd29GBLwxKYzBOEzk7Fws4H1A3FRYHBzg8PqRtyc6BK4MyB7bUTYO+H8m0FEgzEkKEG0cwJJzePsXx0QpgHMvVCkJKnN85ld6H19qQ2ic//PP/8oGX/b500QF8mudrv/KPsk9ev/XWfrTvSJ9y8+/bfpHVY3eLAanKRF6ftQd39rFTgnOy5oLewJwz2Bw5TSGf1LoerBZzdHUMEYumhg859DIlWOtoCYeh5ZxC0i0XYkI/Wjzr3qvouh4sR2nvvfNHB5Tlf9991yiBVxF1OI4jlssluJRou4Gy/J2D1GYOyDRGQ2k9pw6HTGHub1IhJerFEtt2QDdM2O060jDkVd6cMfRdh6auoBS1vvtRRiuJEFPm1Xu4aYTMQh8mBKbJoh9G1DUBllopCMZw5cpldF0Hmxec9PngxkDZfCIX6LIgI9B+L0BRGDRNPaco78NLnQ/UsWVz1jSOEIKEPYRDRChNEWN7UPTWzVvYbrfohyFLlEsSAtkJdhjRtS2mrPDb7xHgjFPs+vExFosFtFJgnKLY6rJA23VYLmogpvlrgnEorTBszlGXBTk9Jce1++7B0eEKYegxdR20pkWlRkno5PDYox8B5wyPP/4kEhjq5RKc8yKO/XcGa7/qx97xzeyiA/i3PPfe/0L2G4998svvbPofiilVd5F+NqPaPAtPSKPPszJtv7iD9tRzTt79fftZFgYJDAerBsgbewpDKL/PqLYxBm3X4+hgBR8CyWMjgVgyI93eE20UIznilssFzjdbaFMgAVgtF9hsduCc4/Bwje2uRYwJTV3PqT/TZHF4uCb7awK6vqfVXQw4P98i5niuYRiwPjyiwIxxBFJEURZgLOXXRk5G6xy2mw26bsDBekmS1hBoM48U1L0HAtY4J/qT9AFudgx+KjC3Bx0Fy2Ep2bIsM66y2+3gfUBRFrTx2Dmi7SYSKQUfZgpuD67u1Yc8OxB9CLTjIG893s//e8+B/xTtQIwR4JwQdiGw227n0Y4xCird27LLwuTUJHotxhgM/YCiNBB5o5APHn3bkZYiy33JGMayf2MAhMLR0QGmYSB1oLOomhpFVeDWk9fRLBq02y0459hut0j557HXJhD1nFBWBdxkcX77FEeHK6zXK5kYf9PBqnnsX73vJ3/1+a983UUHsH++4kveDLjpDz191r07plT/m/9dZnMO6c/FXAT2Yp19mIcQPGfUiax7Z2g7+sU4HwjVz9w9Y0BMlDJbGDLkDJNFnZNo6e+DwjiVRF1TkIc2KktQFXwgxPvmrVOUVZGTb8ScF8CFBONsjgJbLGporYnqcw4hphn4Wx+sIJXEweEhLb6MPiPZbN4AJDgdIqLdNLrNOapC454rx1itFpmhqHIs+ER6hNwVNVV5N1MfFAaqtYJSGvdcuwdNU+Pg6BDGGNp2lPMA9+7HcbJQeT35Pg2YMYau7+fiLKWEd57aZ2BO61X7zck54pwcfz53NhQcascJ3rnsS6DPEUJAU1eIwaNrd9BK4eTyCa5eufxbOpqy0Gh3LTEVmep1zsMUBn1H4aJaaZRFSayDJzlyyrhJVRUEQMaI7dkZnnj8Osqa5NzTNJIHAEAMDv3mHFpKMAbUiwXOTk9hxxFVXWPyEQdHh9ienaLdbHD5Mv1enLUYJgtpTOmc/+FFob/iZ3/key8KwP75qX/xwdffON29K6W0/NR/nzKVtJ/zU5aAaiWw9/sjswB7Fdw+lhoJkJyhMBrBW1qp5R2aivbWbXcd6rKYi0RTlRAs3xQ+QDCalyMYpC6QuACTigqKovZ20VRA8OAs4YnHrxMuIBW6rs86AzoCZ2fnedbfzTJbxoBl02C33cEzgd0woW4aDH2P2lBaLWeAyG20DwEJ5HLjirbylGUBlleM9R2BjcF7SvrJNOk4TfCeWInKSNixR10WiCmi63qkFLDbbmm/3nZLlNlyQePNMAAJ6IcBLG9Cmled51ZeKYVporXfKQYkpHlfAMtBKXcjutJcfBhjtEAlLxbVedOQdw4h6y2snbA5PyPbsffkPYiRotVy1yc4ywYmZCiUVJrNagmmNDwYhpE6FC441usVDg/XEJyWlPoQELPg5+jkGJUSGDfnsOMEXdX0+YxGUhrSkGQ5pgSJSFTh0SHKpka9qHF4fAgIgSvX7kG/3eH89m3UdYmuH1EaDde1kNGXWrAflgyvuygAAO6/93kvGib3P6aUjn6bSCHPsrPePEt6ea7yQgikbNCRGQeosiIPAJQSKAs9020+3r39kIWvJEWlQA3nfQ6hZNjuaP8cBXxypEQ8/F7OOowUkHnp5BDHBys0Nclip2nCMI5gjNiCvuvAGMdyuQAXEpvNDsvVEv1AHzfHa4NhGkZst7tZkMQZsFqvcnipmFdkV2UJZPca4wxFYSjhJo8zMUZMk6M5Oevi9yo5U5TUvTiXP5ZisNq2hRCSOPFpgspsx75geefng8w5RaXt47qllJScU9M676quZiWfkBLL5QLIK8S0Iqxg786MMWLoezg7kfsykYlrH3Ow2+5ovVpZ4mBNsem7HY1aq8MjLA8O0fYDmoNDHF+5Ai5pI9HY9zg6OcHLvuDliJxA1aEf0LYtNhuSAi+Xy9kBqpSCnWwORaEOrtLUPbXtgGe96BGUl+5BAofUClxTgnG9qLE93+L0zjmqZoFhmFBWFQ6PjzAOE8YhA4SnZ/R7MhqJsUVi/Md+5t3f88gzugC84KEX33/7rP27IcZ7P93h3+MAMUZoSVr/lFLOnCOAat/iI+VgB+vzrnuW31DEN+uc/7dvWffbaPYmopDn/7ajm0FIibquME0ORwdLDMOIo8M1bd3J7sKQ8/K10ej7Aev1KiPXHOfnm7wGnLjn5z77PuLlucDtO2dASjBaYrvZoDC0X2C5bNB3PfHvmULzPgCcg2cdvtYabT/g6OSYYsQ4xzBk3b4i81OMZAaSnGOZV39JQQcWAFSOJuOcIwJQRlM0WS6k1M1IqJxXQFkCVBSspYUlZJ310FphuV6RXdjaOSNhHCn5yPuQ15FRwXXOZYciFQ6p6OtIwXJcWYLKAqXDwzWkpKIyWYu2beGcAxcKZVNjsB5tR7HjXHBakpK/vvceZ6dnWK6psTRFgaqu4b3HMIy0KCTHw3nvMVmL7badAUcmJBJjGHZbPPWJx/HgC1+M0VMoilkfkoRYKjTLxTzWmULjYx/5aGZxJNbrFfk/2m7GDg4P1zg6OrhiBPtf3v+jf+3Zz8gC8MB9D69+84lbPzw5/4JP9zExC3hm+o9zWEf0034RxL7VVVKizrPcnosmqTBt+ok5UILmeJ0XRFD8U1mYvCdPYFETDdgsGrKGcgYuBawnocreHei8h7OWgCdO8dUH6xXGcZoBxiuXT7DdEVJcFganZxswkCvwwWffj7PzDZ548gaip1VaMQYaKYSAcx6r1Qohr+2S+WDsdjucn52jaSqcnZ6B5UPFGMNqTdbiZrmgA5dHmpginLMQkjb2np2fk/c+26SDd+BsXxg5JRM1NQVw5P2E++Se/WYdxhiNBgCKvDWYorpH+HzA9/P/Pmpsu93mMJAwHzJTGCip5pwAZLckGHKKcczORJNDRMRMCSptcPn++3HlyjHcOGJzvgFiQLtrEYPH2O5w9vTT6M/u0MKXnOdgyhLTNGGz2VERzrgHB4GwjGVAVJK2wE09uptPwtkJ1x54FrkLL11FP7m5WNaFRn92ByJGXLlyCU/duImQGE5Pz9EsFlgsF9hs22xUIvapbuoHh8m+6z3/w7esn1EF4MUPP6K3bf/dPsQ3/D99nMztPud08wfvUWiZ99DRL8nkmOe7KTjkYaeFGFkok2W9U95wE7yH8xTksagrTJNFt+tovx6AlLcCiWyD3ef4j8OAbrvLCTtkXZ2TcoQAz8AhY5iNQSeXTrBcNGh3HU7PzqAEx/HBCoIz3HPPVTz/+Q/h6PiQkP2YsOsGrA/WsOOAvu9za11Bao0yb/eNgYRHTdMg5BvZew+f46+Dc+j7IYeNEiviQ8DQD4g56KOuSyB6UvZxDjsOSMHDaAkfA5wj2jGmSCh6piNTjHk/IhWPOoeitruWAjh5Zh9iBMvZBfsxQWk9C4RktjKP44gQwzxbTyP5KoIPWcBFS0DuZJdkVZbZ7uzApIQ2NOJVpcbN69fJDSo4UggotERTFShyHBsHrS4zWuLk5IhwgK5Dt2uJ+chLQ7RSYDFi3O3QVAUODw9w+tR13PnYr0Erep+dP/UE1usFuvwzLcsCXdvR50HCycESduhhtMRms4Gqajz8spdi1w/wjha6MsZwcnL4+kVT/+D3f9PXmWdEAfjyN/5B/okbd/7Mppve+mkNCnnu37v9+Gz5pT/LvKzCGJM3+khoJSnjTsq5cFCIB2AnCyUpG3/XdqT9L8laO07TvLU3pYTNdkdo/kxJ0ejgpgneTtCGbkyWTSbWEppvrc2SY4bNZkersbJisCzNjG6nSBp3pIiqNAAox2+9aMA4h6lIqAQuEAFMOQYMMWDoBly9enkOvdjbm1PMkV7e0yovT/5/LSV0vjmRuykmOKqqgpx9/oSE7z3+3jssmgZ9DuZIIeRFoJSO5HLoiPf+tyzlpBsWd29arWcGwTqXl3XS+CKVgsi/D4DBFLQFqcybhOhnSp/z9PQ0L0ghwDHEhKap0LctTm/cQL/ZUDS6dVgsGrRth6au4XxAt+so5LQgqnaa7haXFCMEp4yDmCLKqoTzDtvtDmPWang7AsGjzuvJkpsQrMPJpSMkO+Ls9hnpB8BgyhLrwwPcvHUHQmscnRzPxrP7H3w2YSNlgQee82zYaYJApDXzzuLSqv5jD9138vX/3X/9NfxzugB87df8WfzsLz76pn50f+XTfe05ujvn1MeYcnYbm73/UkqK2TIUda1z/DVtuWXz2i7r3CwYOj/fUqx2/u+0WXfCmBdvGqNpb0COvhaZN6flFlPW9tP3UxbEJMisqEt5R91212KZE4X2+wVSjLh+4xaJRxyBjVJKDP2QE3PTLDIyVQnEiMl6QNLOgH0IRwKwPlghRTLRxJhmPEEbDWMMtrsWQ0/CokvHh1CaHHwpAVVZzRHodGCRu5e85tsYFGWJmItZ8ITkS0WhHjqPUfsY8cIUWXiUgcKsFTCFQVWW9LGa9AcxBGhToB8G0l4E6sJMpu26dkf7AzhD3dQYxjFHjPuseaC2KgSiI/dRbbvzM7Rnp9nFB9hxwub8nEaycYR1Ftvdbh5BUgKGYQAXHGVdYbFssrAK2G02+fskl6IPCX0/ou8HaK2xXq8RvMfm9DQnFlE0HO13ZP83d28Wa9uWn/V9c445Zt+sbjfnnNtV43JR5bLLLlcV7gDHCCI7cRJQoqDwEkU4KDhICQ+AggQikRwlioB0GEVWpDRKwhPJU4BIWHmwIksIgkIgZVfVbc85u11rrtnP0eXh/5/zXEp2VVku21W+0n25d5+z915rrjH+zff9PozjhItnz7C9OEDGCSalcbi8QNv2OB+P2JQZA13psTeaDGFZEsLp2a/S6C/98Gc+9i/80v/08797D4C/87//7e8+99PPOxb6/Ho3v4OD4SBHbw3woIl/EAQr/24BdExKkZ89oBJOMtTSgwetLdIkQZLEKIucdO6WARERSVi1UkiSdF3/qXnGMAxIIwkPloMlLWQoKUMuJU7dqa6Rpgm6tkUch2RBHUY8uSbwh2Yg6NAPOJ3OZMrh/fZuv0Nb17Ca9+bOQYQRhJQAaxvGmSy3aZ7BA+HD+2FAkiRM29FIs4wlxQLb7QaHww7bqkCeZRj6HuNE03WiCfFshDFowvcwTeNKR1ZKMYiToridc+uMYWm7tDHo+wHWEWdhmRHQoUsl/jRNRGEKgnX4tqDTl5t9OcR8n4I62qbBzJHeQRAwj0EhYt2+4xmOEHRBHPZbxDKAnUc8PtzTgeosiiKnqoTblYEn8esQ0wGnxxO1Qw7I8hxhGGCaFWknlIIfBKh2WzIRzTOa8xlt05CASytMbYtQAJ61lNMIQMgA4zDicH2JzX4LwWrDsirx/P0XeLi5RfNwT4lEw4CbFy/x+HjCoIGo3CAOg7BI5M9Xofvu35VKwC9+9gv5r7539ze1sd/79W5+b+X4EeFnMfgsQ7tFDgxmAfiCHt5ZG2RJxNJf71VePSsC4XlIeFIfRSGcNZhmtXLuNpsSd3cPCPlkJ3ow9fNWE0YqkOQd932P4JfOcSxVCCGIHpxz+bxsGiiMg3bTYSihZoWsyGE09YHGGmRlSRsMTeKfaSIRT9e2kBzTRa64GOM4IsmSVVTT9x2ThWMkSYw0TaHVDGsNrRQdzSOMmmA48DRLUwRM5xUBEY98NgpZR9bcosgZmx3yFsW8arf4IAnDCJYdj8LHGvFFzj5SERIKjOY3oQwRhxLGWFijufKK1tXsNI2whpSafd9RvLgxRPh1IAk2R6IHUsIai4fHGnGy9PnBajAKWOGXZSmvfWmFCl4ba62QZSnCkJ6JiePXojgGfB/ldoM8TZBmKaQMcDrWmOcJ292WK4wJURgAvkCYxDRsZaPU7ctbeNbi5oMPiEshA5zrM+caFkjiEJ4zsPCRbA8o3/g4xtMDyiwuxll99u//vb/ztz7xxd83/q45AL7wfV8Q//jLH/yc0uZfA+B97Qd/Ke89eOsQzWcvdygD+N5yert1A0BuOpowBz5ZRxdijrEWAZeO1lgkcbxScft+QFUW6PsRZp4RyBBJQqk9jrX2YRhxQoyDZPWgsQ5916OsKkr7FQLKOqRJTA++762S1mXesHAHszTF6XRCmiQIIrLLqnFAUW2gpglRkqwE48f7BzjPw+uvPcPHP/Ymbm/vuWSlHTt4liD5AZdSstIt4EguD6f6DGMsdrsNOdwcy4OF4GQfWr1Ns0KSRATP/JBiL4oipEkMw1Hl1lpqw1Zh1auEIq1oDQgW6BCgxMc0TmvpLcVCY6Y+Pk7i1Yfhef6aLKTmGVIGKKsCeZ5ThRGTqtGxGCyOQgShRFUW8ATpPGQosTtQKGjfdsxbYPem71NlEYY8eKRLYbPfQ0bE/JunGZrLc9/zMfYd2lMNpRTqU02W73EEQElDwiemIwBESYowCtGdmzVoNYlj3H/wAbJIQjtgf3UJOOD4SKImeBSXnkcSZNWCgQAAIABJREFUdX1GVlWw80gHtXVvlGWW/aP/8//4ux/7wR+13/EtwA9//vfhned3f2RS+medc7+uEcLDh1Z6Mlin6KFckM/gh4X2+h4Abd2rioAVgSF7/oXvIY0pZddy+dv3I6wDmqYj/HeaQmsNX/iYZtr1G2MIc8Vx30EQoB8oTdbwMM1aSym42vBcwOLysOPsejLnBszPI4Yg8OzpExry8Y3Xdz18Vs1ZRwfJOPQoywJFlsF5HkQgcHl9hSwv4Hk+Xr68RV6WDP4MkKQJxnGk+YRHh199bhDHMba7DbquhwwEsixbbcgyDGndSOoqjOOEJ0+u4dhSbZ2D0gTGTLN0tUhrJg8nSbLahuEsz2UE/ICSlXxO21lWilmaQMoQRVEgK0pa7XFEuNYGI5fQUkqeGQg83D3AGBIexUm8OiGHYUBR5CjyHPOsoOYZSlGgyOPDcVUbhqFcK7MizyjuTGucWVQ0dB2SLIMyFh1vkKKYDv155pYBbo0uH4YJ40j/GmsxzUQAV0qjvr9DfXeH2+fPcff8Bb76/30J5/s7xKFEVpYoyxyBR6tsGSfYvfY64qKkoTEciiTE8Z2vYG5beM4SA9LYP5kn0R/9y3/63/nOnwH8k199+2PHdvirzrlfM2bZrZ9urOq8tTzxfcyKps1LjPSiQQ8C8qOTNdaizDOM07yaTnyfcv+Wm6/tyIyz5tWH4doPO+soY26mnjrmnhAewSZ9IZCmKSQr56y16yAoTSJ0Xb+GiI7zzDn0y+CJ5hnzTIz6eRohhEBe5ABTipeeu21aHA77dZh5f39C2/Vouh4etzEAUJbFyj+QfNM5R4M5Dx5bcmdIKXF1dYkszRCGZNKZRuqHu7bl8p4zB4UPo9kI5bDScYml5+CLgA8/xzFkdHsvf+/SX1vOIvA8eu3h0eptHHoMXcdhphpD369D3YVRsE7bnUXb9sgzovcaQ9N0z/fhCUGzjXHC/rCHMZrbtni1Onu+D6MVHh+POJ8bBCzo6oeBzEpC4IMPXsAZihabxpGBoiR9zosMgSAl5nZb4cnTa+yurpBmKeZpQt8NxFNYvBJaMyR2gBQ+pPAxTBPapkVVlWjODVeoDk5myHcHWOfh5uYeY9ci9inUpe9HolN7CGQo/9pP/d5PfvI7+gD47o9+T6KU/mvG2Ke/7g/Ayb0eGztkICA4nJMeEI/36sGK5VIsCPE9mmiHMsA4zYgjwkKN/OAumntrqcwzWhFEMkuhZ4JXZmlC/a0mjFUYiDU6THGYZSAl+mHE1eUBxpIgyOcEoaXt0Mbi4oJ85H0/vLItCx9aGXT836jfpYOnrU/YbjeIkwhKafKaty3gLB5u79GeawhnoacJ8YfCMI0hKrDn+7i8vsLl9RWKqkTTtghkgGpbEfYsCHA+N5jVhDiKSIobhuyaFGu1ohiRNs8TtRUBHaKkjCThTyDodZjniaGo9H4t6b9hKBGIV3j25UZfhrqLRXueplWrQevbkOXYE+spCMoZx+EyoP8QBwK4vbkFuDWg54ci1B3nMtBaMeLDkr5zXZ/hrMOzZ0/WKkjCoj0dAU0ziqHvEScpnr3+DEmSYbffomk7zCMlMl9cXkAyGXmeZ1RVid1+SyGv04TNZgOfjWrN+czPJ/B4d0fPoJrw7GKH7vZ9hIGHcr9HdXEB+LRSTdIYRZFhGCds91skgXcVCO+/+OX/4a/G35EHwKc++TncHc9/Ypz1T369fb/HAZaL4cfw7ScDAVjLkk66oSxTeZegiCQOOTEXHFLhMM80nDEsIFFKrxVGWZWwjsg4UZIQ5RdAVeakZGPt/JqDxzqEBXIRcsgFDcLIFKON4Sm3wDwrXF9fIssydMOApmngOQfNUVinukGZ56Q+S1L4MoLyfORZvlKIAinx8Y+/hcurC5zOLY51A+csbm9uIPmgbM4N2qZFGEarcMZag3KzQbHZIMlyRGmGrMjR9iO0sdCr8YazECMJH1RyziNVJWWRoypyFEUOKcX6sMuABm5qVmtfzXNY9F2/gkEEVzzUH9PAUSmNIIxgHFA3LZGWtVoPSKU1w1dJPbjMeAKuvDx+NjKegcSMSwtDiYe7e2g1IYojPsAt0ixFe255SEm6gyxLcTrV1M71A4mmtIYM6PUchgFDP6Br25XgpLWmn19rvPuVr2I41yjylDIMlMLx8YTb23uEgSDb9jQiDAScNTCWYK6b7QZSSlg1Iy8KtMMINQ6Iqh1Zw7cbbPdbjNNMYBoHeEGA86lGvt0hzbJ/LomjP/2l/+0XvO+4A6A5159rhukvu68Z+v1acl8+DT4U6UWJMFFEO3bBLHkZ0CTd95eJNcVvTeNE7cLC6eek2eUhbdoe+92WHh6fo8BDiavry9W/vtttVyGRMbwy45/NGGIB1PWZLciCenQh2HNAWvJxnPDweEKaRNhUBeGtNZW79KEKqFdmUU5ZVYCjFKIvfenLuLg8wIfFsW7w5OqAdhixv7zEG2+9gWkYMbDX4OLqElJKtipLkpdqjdPpBBEEMM7h4uoS46zw5hvPeJMi+HehVkprAxHIVQNPMxhan07jxKYf8tDXZ0o4GqcJMuD8PT4IZ2YTesBa3rdn4gYcj0cazA0juq5btQvWEExF8SwgiSNcXOwRx9Gq5/B8MmQtIaSSAR+WU5nHYUSaJri4uEDX9exA9NDUZ9J0RNHqTRCCEqDapkORZwh8SkwqyxJJmmCz2WDLa7/bm1sMw0BpzmWJh/sHdP2ApmnhrMXFxR4f/ehbEIFgzLuG8wVtDjYb7A97lFmKvuswzQR50fx1VVUSrao5wQ8j3Ly8gRUSIs5wrs9omgYwVIme7u/Rnk6+b81/YK354nfUAfD7Pv9Dyf2p+yvWuurr7vsd8drgOM1X+OwEI9GH43KZXb+0212IMmwXWw6IZSXnAei6nspVFoxIjgifxglhGBETgNdoATMEpAwoQ05rODjyFfBDF7K2X0qJQIbQq7vOx/sfvEQUSnR9j77rYI3GrBSLhRYJbLRy585NswaVOpYq39zcoel6aE7zmcYJwzQj5h59njWSOFqHfo8PD6sjrzm3qDYVhmHC6XjG6fGIcRjw+PCIm5s73B9rKG3weKoxzQoWDt0wM5CEvPK0gqWw0DgmhyFJcKl6yrNsbc9WpqCgIZ7vka321XuLdVsDEAtBCIHNdoMiz8jwxJ6FLM9h1Ix51iu8Jc8zxoP57NGQq9fD4zVx3/UrPr3vepzrGuMwoe16+KyQVPOMLM8wK4W+63huQYj4KA45fKWjTQbHnCdJjJjDV8Zxggwl4jiCcxYvXrwkTUDToSjytc2blMLVk2sEMiRDmueh7XrkRbEOXsOIKrUkS5FGIeoXH+DiySWFox4ucf2JT+Hu/oi2aTFwTLueRkRSwIcptTZ/5e/+/M8l3xEHwBe+/4e9f/zl5z+rjP3Rr/d1yyGw9NAL6XdZ95H+nCfMvBKUkm73hWhD3H+zlmyCVX7GWKK6OofdbotJUUqPxzLipayftYF1FLbZNB3x95SGtUTeCRgqEkURZCgh2dSziFnmaaJcP22w3VQcAEKxXG3bY7Op1lWWEIL990Sr8X36un4Y6UOg6eZXDpChxN3dA4ya0RwfoYYeZVWur88C1IziGNdPr3F/94D7+3sEMkDXdujanj70xzM8X6DtCXTq8Z+9vDxgGGj3HQiBLIkRJylFZrFceVaKWIK+QJFnLHkFOyhHBIGA51O8dpZl5O0HoA0htZIkXrMSQ0n6B2strCUwy6Kdt87BGI227WCYoAwPnP1Hz0hWZCjKgla1bIm2RjOk1GKz2XDCckRKPn6G2qZBked47fWnSNOEVIQzVSy73Y4O0WleI9O3ux2ePnuyZgKOA8FjLw57RGHEh80Zt3cPkFy5bLcbxpDRsxBGMWYLHC4viR2oZijrEEQRbl7cwPAhb/oOEALHFy/g9Iztfktr1yRC37TI85w3SRIe7BcPVfZn/tLP/sy3/wHw3vObT5278c9+vZXfclMsjrCAJ9yad/XOsVrN0irHMe/PMu/OGrOGXlpDEJDF2w/nsN9vIUQAwZPagAMoPOdoqqwVRVazbr6uG9omMAdwNaYocrT5gmTB4zQzbGSJ5vaZH0jquDLPEHNybtt1iOJoRXuHUiCNQ469oiCMr371XZwejyjLAr/3898HrQ3u7x5onjCO+Nz3fwY5C3LUrJBm6XpjiYC+5lyfEScxDhcXqKoSV0+ukWYpLi92+MHPfxbjOFIlxdsTD0DbNNjv95zBR9Fi1jkkSYo4fCX9FUKgHwYy6yiNnldmVKqbdXhKCkLHAh+zblqE50Hw4G+eJhhDceTzrEhpaEmjkaQJojCE4VnNwh4ImE84DiNxCvsejpl9C5x0t9sw5Qmrt7/tSByVpimMtdCaqpc4InIQDTgJGruoH+nDSpFgzloorVmfQKi5zaaEYYpRU5+htMY8a1htcD7VCEOJjOnS290W28Mezjnc39yS1iMMsdlu6DVj1WccR2hevIfm+bt48603keUZ+q6Fc+QhgQjgBxLGGG9TFX/mX/+Jz33m2/oAePP1T8pzN/yc/TXgHl+7+nMOq06foJ50M8BaGv54tNdfTgvL0dAegCQM4POacOHgBT7lyY1sylmUbcY55FmKMCC7bxD4JDjhMkvKAGkSEY9+DRchCeysqJyXQkDPEzxn8XiqsSkLPDwcmSbUU+LMNCPLU4Ry+T4C1rh1U2E0A0yswzBO6Loep6bF/uKwvMn4/A98GvMwQI0DtJppWBknSIoCwzTBOoeu61/l7Z0bGDVDhhKHiwO22w2yPEOcJDRN3pR4+uwJLq8u0Q8j7h9Pq0Yhioh9pxTpHgIWqAgpkRc5yiJHnMQIBK1EFzCL1gbGkoU2YCKQtXY9nCiMlQ6CoWvX7UAgSLQkZbAeCEIShs05wPmCZhKKUOqLsWkZylqjSQTEDAEHrPJkNc9UgfDQNgzJIegAqjyM4eAYn0NAiKA0jjRAbJsWTduSAlMR/pwqUsfyb736EbSm73l3e48oiTCOA7IsJaRcP9AcSvj44J13CebCv5PggyTJErSnE+rHIwBgUgabKoeaJxyuLjEb4hQuEmMZSjjrEIVyo5X6z/7B//Jfhd+2B8A4Tn90UuYnv1Hpv84AGEsNjmVeDgTHarql51vaA+ovCfhpeX7gnOO1D9Y3XhuDYRwhA7k+MMKnSGmtDeKY3G9xmhJQlFdXhk99n9/smIERQSDgA0iThOTJgcCzZ9doOfCS+PNAlqZo2w7DOKEscjRtS/FWxvC2IMG57WAMleMOtE6LQonttsLxeKZB0n6HLE3w+PCIMCTUVhJHADzUxxM0m1KMVojiGEKGcItsl1+3NM1wPJ2x25SUVuMRLCOMY2Qcsjkr2q50/UAtAgB4PoQMEScp3Yq8XYnjCNtNhTiO1p48L4oVyDrPikNYBXyf3ksZhhSzFicrTKQ+Hqm3ThK89olP4OnHPo6uH9HUNQ9ePTRtx2tR+rnGaWYxlMcMSGL1RVzuL3kLivMJLi8v2A1JSsF5pik7wV88vmA85IwSW8RMaUZZiEkSQ2mNME6QZRmyPKN2KQhQlSWcNSjLHMf7B3rt2aUacSJVFEWAL1BWJTbbLblFpwlN06JvO+TbLTa7DZLdAZdvvAnlCRgRIt7s8NqbryMvcuR5ijgKoZVGUeTo+gE+7I/HYfCvflseANdXH9vX3fgfAhDfsPRngOcS8EHx1K9Y70SKpdaA7Ke8l7Y0PTfWcRnHfnJj2a9P0/B5mpHwQeDx9xjGEYBDHMeYZ2LkWdb1a2PpxnCWAkNXxaG3tgVREqPvKf237fp1BZhl6YrXIvENcflIa0921yLPIaXE+y9usKlKpEmMT33iLZRZgtubW3YcKnITbio0dY3tjnrCMs/gjMVmU+H+7gF5kSOOE/657GrLrc8d4pSSf32GIhpDK6k4lAgDQUjsKKIQkCBAXuRI04x5iRoWHoWmBnSgLD6K5VZ1Dri7f8QK9Vwjwul7KXYeLo7NLM9gnMc2Y4Nh6OH7gsVIgJ1nwBgoNePy+grN+Ux8Av6AXz+5wnZbkX5gpshuMGOA8kr0GpKiZgXnkfV7GIaV/LTAN8ZhRFEWBH3JU2R5Tl6BPCMc3DSzOImezXma4ayhSoWVgr7voe+J9ziNE+IkWaPhz/UZ8zSi7yhfQkaLiYlETEFAFORpmpHkOY6PxIa4fvMNjJNCttuiO9Xo2pZSkJIUDgsEl1bEVqtAjcN/9KX/9b+5+rY6AP7wj/24N8/zv6uN/fg3+vD/s70A+MPt8e7erCk3rybKVOrHUfhKAqz56zwP06zWoA+lqcekh5ZuC9o7k6BlVhpSCnR8M0dpuvatH0ZUzdPEJa/HuCjzSvbLVcwaIS58TiaiNdh2UwEgGCdlFQhYR3zC7/74R5BnCbQxeO/5Lb7nU9+FLJaYZoV5Jt7A6VQjy3NM48SKuBZxHKGuz9hsK2YieMjKAtYBx2ON+5cvUSQhOq5IhC94gk+bj7LM+dAlZLXzBB+0RPURvqA1ZcDMBf6ZsyzDs6fX8H2Bflhcg+R6I387+RoaRm17q5LTrclDahowTSNnBnBkGBuR7t5/D3NzwrYq8e6772NWGtNE1VOaptSKbLdIsxRN263R32usuFLo+x5d269egTRLADia8AOrCSuKIzTnM6ZposSmpqW041nh8uKAlMM/Zg41UfPEBiDFEBazwkyiMEQch9jtKihFsxkyXClsKpL5FtsNIOhDf3l5sYqsPM+DGXsIEeC9dz+AFyXQ44jp+AjPGewuLjBPCs7zMPYDuq7D6XTGOE7oRwUY/dY0TX/2F3/hW5M09C35S776/s33NIP69xyv5X79qT+V85Z79CAQaw4bvVnhaiihYRcJVzRDKaKQy/lArB+yxXI6jCPfQppgl4YYgtKn+Gzhe1DjAFiLPM9gtYH0PXjOAtZQ7+8IMU1mdFIOenAMuKTdcZbE6Duasi/oryiK0DQd33405HOWWf58CzXtgGPdkPus65HEEbp+RJwX2FQljnd3yOIQVit4PiXkbDYVxmHEqDRuXt6uare8KPDO+y8xaYuPfPwjq0zYaI0kpWTiaSThkrEOMoqIUuzodfasXi3AQRghynIEYQgRBHh5cwdrLKahB3wBDYGLiz2Rf6XER996DZtNxRhtYhSUZcGvn4MzbFFmxFgQSGYHkoV7EVnJQDL19wTHMWvCf5X2BGdxf3uPD955h0jBWkNIiX7oaYVqDWQgOf3ogabtvBYcxxkWHmREGg81E+g1CiO4ZYXLB5RmyMnMWwopJYzR7NlwsJbj0rVFXTekh+hpYxHEKawD0jThMBEPPiygZghQQKkvBDbbLZI0I39KEuF8OmO728COA3T9ABmGON0/IM1S+GGIpCjIK+I5CGcQhwKh7+FwcQCcgfS9P3G1r37g2+IA+D3f9b3i/bvTX7DWlt948EeS0IDxXYJL/iCQnBLjU2AE6+g9AHlKhh5jXmkAlkDKxXK7rJqovCcVmgzESrWVzHxfMulD5v5bVmwtkIZF7RbFMfXI8wzh++g4AWaaZjzcP9AtEJED8HQ8YeQyVPh0KAHgBCKqaqZpImgGT7gJf63x4oPnSJMY9elE0NJQoqnPONekFVj87J7v4+LyAGsMLi72UGrGpiygtcGLl/fIqw2x/4uCzi5WTi5JQr4Q2O42SNOU8N5svVg89lEUkqgqTVFUJaZpRFlVxFvwPPiBxHa/Q1bkLBUO4PuC5gPeq1QmmgFQXqKzFFFm+T3I85ygIswAKKsCRZ6teLYkIZ7jIp4SqwKT3oNqU3HoZrQmMC2JQ5vNFnEcIy8KGkpyFde1HfXoDvCYsCSlxDAMawJTIAT6rqPtTCjXePUojiCCAHlRoqpKCOFjv98y+clC+MDD/SN838fd3QMCSWtZTwicmwaeI32/MQa3t7dw1sAaymCcxhHnm5co0xD3778PM3Touw5KKZzuHwkM2/cIwxCHwx5JklDb6UjTEkYyP9bNn/vFX/hPg9/xA+Dlff37lTL/8jca+q3DP5p7rUOngMv1gB15mg0+y9TPOe5/uOd1/EFeIrDACrQgEK/CQ3nS7TwPmifFPiPEFhGR7/uIkphz7Azduh7WROFABpjGEYZTfFaWvXMsWolx93BCGEUIJXPuggDjOEMrzbBQbkGY1SdDiYijrM91DedRRv22zJCXBdqux9Onl9Bak2NR+NCWPq6bqoTWBv0wYbffIZYCH3nz6epY9IXAyLejYd6c73kQgVyNO1GaAtasiT/nc4NAhuiHEZ7vo65bvP7aE3I+Wkc+dxEgKUskeQGZpgQr4Wn+IhWm0tZfTTdKaUzjuBqPAOrhu64H4DjZmFa8eZ6jyDNSRzo6BH0eaFoAmw2V2Xe3d+i4rDeGrMdNS5DNMAoRJwnSJEJWZIhidhAyxrzYVJAcPTYOAzkc+wFKKYS89Vg3FOPIh5tBWVVomhZpXuBweYmmpdlPFEW4enKN/eUBfpygrErUdQtf0Htbn2rc3dyh7zpESYIyzzH2PeZxxNR3iAIfMApJGMCqGVJ4KIucsigsrUCvnj7FpO3qTt0e9jQUjmJ0dY0qkT+dR8FP/I4eAE+vvyscpvkvWOfCry/2+VAlYN0/Y/0lgKfhwZ63SnGXlZ9hHJhg883Suy7OtaLIUVUlppnsqnmWcRgGkX8WSKWeZ0ShXGGXC+AijKKVEgT+79ZZ9o3LNQJ85phr3/dXx53SGm1LvSSsxfl8hgey9uZpAq3IkUYuvAkxAzOsNSjyDE+uL5FnKe5e3iBJUyjDw8BzQxbhNGVohUReZJxg21MrJSWyssLhsEXge+iahoI+p4lubocPbUoIjLG0I0op4vrNMwLPYewIirns9JchmC8E0oKGZFGaQAQSMqIUYPDGYJxmZFmGJI0RcBXmnEOcpoiiiGYCnschHHrlBfQdHVYeT/WLIsdmu8U8U/m9zFiSOEKWZQxDIV+/54HsxVmGYRghoxDnc4NunGCsQ5alCAJCcodxjCCKsTkcEMYJLq4uVrqx4MCVMIrY4EXmqYGHvcfHRxhrMWqLNz77OWyfPF01BwtjUUoapp7bjp2ZGmmaoG87bPY7EjaBnu28yOGsw/lMngifWzelFDaHPWSWo9ztIMMI1dNnkHmBx9OZmZgC12+8gX6aabhtlIwC/8///f/5v4x/xw4Aa/VPa2N+9Jv+ZnzzOmf5g4S1DM+SkLcBmkv9V0nAC0iz4GELuO9aEFVZGq8zAGtJO36u65UOs+yNhQwxzRR86QA4oxGH4VpxhGGIJAox9j26rsNuu8E0Tag2FXy+3aj8pR30m68/RZrnZEfNUmyqkkAhzMBLkwSXl3umC9HN13Q9tDY4XOzXGLPtfov7mxvstySRrcoCvke3f1ZVhAk3bv168OvnjMH93SOMIgtyKCU8R3jraRgwDgOElJi1gR9IUj0mKUQgqapiwMWmKtG1HaJIkg/AkGR2sbs2jDYPhIAvJXwZwg8CQqopxQeN4PeJuPmLhdtZgzDwOYvQI6uuA+IsxTCMgHOo6zPq4wkPd/dUejOYQ2uNx8cTNJfqVVVCCoGkqBBVW4r/kj4e7h4ofNTz4DnyGIQso1bzjGkYMA0jDqy5KMqC1aOGPRwjnHVc/hMHcUkero9HnI9HnO9eIkuJDlSfGzwez/jV//ef4iv/9Evo2g5FRszFME6RFQVOpxqWU5HapoXRBrc3d4SPS2IY1j6U2y2xGLWGHkeMbQvwtiDMCpI2K80uVYndxQWSLMcw9AiF/yObLP7p35ED4M3XP5me2vHPOQf59fr+D9t+wTrxxdq57P2XANDF708iGoZNeh7d+r6HricDiGZHWpokCAKB4+mMOI5J624NijwlLTqX7ElKO9WbmztEcULU3TUgQ679MGXdzyiLgsxFsyLVGm8IhBDI8wxjP2DoewoCKXM8e3K9wkZoA0GutZc3d4jjGHEkUR9PGMcRbdvheDrhsW5xfbnHu+895wCMHdq2xeHqEmmeoR1GdKNCmsaYNYeUpDGGYYSDB2cMAt/Bc3a99Y1znM9Hf26aJjoU6Q2AthYhtz0AsClzWAeEDEZxxkDNFPgJnw5aNavV1jspBV9KBGmKqKzQT4oSitKUItgFAVCKqkCcZciKkrgAaUY7eyYRV2WJOIoZ5+ZjmmfMivb0VmtoozFOI6aJVm1t25LD0FlESYrda2/ire/9AST7CxyePoMHB6MU6xb0ColR8wzpezATh3ZkKYQMoZThmZJF3w9oG6IITcOwVnsy8OH5AvvdFnkc4uWv/gpu3vkqEYNnjSiO8ezpNeJQYmhb7LZkHMqLHJ4vUG5KPD4esdlUhDQ3GtWmQpbnqKoKWZbB8fxLa4364QFdfcJ0rtE83KO5u0Wx38P3PFoNss8kiiOEUYwsL9B3baCV+vO//D/+59lv+wEwjtO/qI39/m/8lW5dyTnr4JYBnXOrPNVYEveM47Qy4z3fo9LdWLKuLtQfQRTcBRQ5TxT3vaQDL4dJnKaAt0hggbYbEKcp4jhCyasacIWBhf3PN5fW9CHoekrbGYcJ8zSj7XvkeQZjHY6nGlEcrRhpB+phh2GAlEQRUtzrTrNGnNAHcr/bYLepcD43UEqTaEVGSIoSu4tL9JPCG2++husnTxDHMaRP5fg0KxwOO9RHAloGQYC6blFtCqbqOAg4tG1HKj0hUJUF0WicpbRbpRD4HtQ4UtuzYNeXqHXhI4okS4Zpdx7KAHmRoe1GjLPC7rBHUZXI8wz3jydYa9E1Dc5tt85VkiwnA1ScIK82KLY7JBkFjfgeiO7Td+tgd3HsLXZopTRkIBn7rlkPQi5FmkGEGMcZngxxHmaUG6IfhXHMcweLalNS6nNDSUL18Yh5nJBkKZzvk2hK0DBXawKqkHmHsF5tR7/7ZluhabuVZDxPNFeIYmoHQ+Gj71oMXYeIY+e8tdSWAAAgAElEQVSzLMPV1SXimGA0WZpiGickCTEdredBxhE2+y2y7QbxZg8RBIjTlAhFnoc0CuFbem7CUKI+1TDThO7cYHdxQBhFKMoSfdd9Blb/S7+tTMAf/v4vJu+8ePgbv1ak19f+s0z81504p9L6KwjMI9Iri00Wj3j8oTiqpVpYpMGLuEdrmurvd1tYZ5HG1Ap4PvnIfc+HD4csTXA81SiLjKfAJJYJpSQPwcomoJ7OFwHhqOKIh5RAnmeEsJrIJzAME9IkpllBIMidNs2cdCNwe/vAJiegPZ8BeKi2W8ShpDBONgRlaYy2p4PPsF12nNQagOmzMzKWAl3b8WYDqwKRUN5Ewc3zbGUfevw7EROR4s+N0gi4ygmjiCLOTzVgLdIs48MrXFdhcZqQByHP8PL5DXasBDTsQvzql34FQSBwqs/kqR8GOnBZGRfHEQKm5S5aCyECOBCKHLyGE4Jcl2lKwSfLcwCWjC86hv1+i5F39efb5zg9fw95EpOijyXXvk99dSgpR7I5N6wYFKyUpIti6DqqFBjTFrBUHA4cNCMY5qIRMy6M4uQdpAyZQFzA9yjpqShyKDWjqRs0bYsojikP0vcRSkHzBF5vJ1mGaZrI+RqEiIsCAiBPRJZi9iMcXn8Dyvnw1QStZoRBQCY0eEizFHAOSRRhHEc/COR3vf0Pfum/e+37fkj9tlQAbz+/+0ll7Oe+0de9IuCwcs9axLzLX9ZRYRi8Yvjzh3phuC9pP+RK81kK6hH7Pghw2G1WOIXg9GDf83E61tCKpKkzs/i3mwrnusHxWCMKJfWM7DIEcwgXnLTRZOclgCOtB32f7Kn39/fI0gTVtoLwfeR5imGcX4mXADRth2dPrxBJKv37jlJ++mF41fp4/jrxXtaSp5oGPn1PhpSVfuyTGSgMJSPMI3RdxxwCeih9jyqFtu0xDBPgCwjPg1EKjw9HlHmKwAdOp5qQZQEdOGVVciApDeqmiQGcTNidphnN6YxNmUEIH7cvb/HifeLfyTDAwyP9fduqhFYK51ONd776VdSnGjc3dzjXZ/RNg3HokRYlvECi2u2JpsuVSpGnKwK+KHMSDPk+NFuJPc/HxeUFrLW4ezxie3VBwq9ZoefyuCwLwmkJyiE412fUxxpFWaCpz4Ty6ntCvHtAURZUoTGQRCm1+iESXmMarVnOHON8bti3QqtVIQTapsHx8QGCk6CSOEHf93h8eMT5eMTNixtWakrkRUlZkR4lTzXHR0DNaI9HjOMEISWOj0c4rZFcvQ55eA1RuUPTj0giWtV6DjQM7Xt4voDhDVkA8xmt1E/9tlQAf/CHfyz+lffu/mtt7Fvf7AHgM/ln8f0L31v/tYYz99gGay3FRTtn13BMSvrxkCW051+kvRGrAxVTagPhYVYUkRUEAgVLYwWnBRV5Suk+AX04Fq3AQtul0i5mWAYRcZwxK3w0yxK8+95zpGlCN2REXIG72ztcXBzoUBECURzh7bffw263RRRHePLkin4urUnXME/wAsnEHIOQWxzPGkxdi0CGBAmdZ/bF02CSvl4h4UQeGUVw1hAcI4nQn8/wmACsrYNjMQ58Hw4UZ34+nSgwM09wOp6wvTig7zq89/bbSNOE8GBRRINToxFFkig5gcB7b78D32h05zO6psVmUwKej2kcMAwjTe0T4iDU5wZD163GqrZpGNziIQw8HB8eKXuRGQOOTVvWOsKBwfEHlC6GeaLZxzQrou82zXqLhlEIGUWYZtrKRKxHgOdDRhGapqXJv6Th52Lhbptm5RA0zVIpeKv7NJQ0+I04yGWcJvjOcsaBR0IxR5HtjjUG1IoRS1DNEwmWQtqGaOuQlxWgaPjphMTx4R6ma2HVjHkYcP9wxP6wRZjmsABmYzHcv0SaJsiKgkCvzgK+B3g+aQ208Qy8j/4/v/T3/vuP/eCP6d/SCuCffOX5j8za/NA3++H/8AAwCASEWBBgdAAsPHVj7XpQOGe/Rj7sVhioMXYtx/p+IJhj32MYCX1V5CmSOEIUShijVuilUgpaEROQ1pGL6ssSeZjXWoYpweM4out6eD7d1Ess1nZbEsuf33R4HrI8XWlEwzhhmBRm9rZ7jO5eGIYOQF5tUFUlPA+o6xO6tsMwDKiKjKS5HqHNfHhr7BUceel3ux1OpxpJlhELkddpxjpsd5sVc12fzvCtgVEzfGd5PtASxlwGNPjSGseHI7bbDZt+yDINoyFDCXiEI1ezwrtvv4NpGAA4lEWGPEvQnhs8uaRcw6os8OTpNaJQIksSSOFzeImBJwT8QKJrGxyPRzTnBrvdBm1HK9SlPVTa0PByHHlFKBBFMbUMlvICLi8vUBYZrFbI0gTldgsZ0Pyo2lSIo2g98MqqIHESp/MalnSHQUBQVN7sBIISlMkGDobLUCIzAHaYkmJ05HXwOI5sKjOIk4Rj1nxEUUzD4CDA4fKC1Zg043rr05/B7mOfhIWHIKBZy+HyAk1d02EEh/r+Dsf33kH93pdh2yNSN6Guz5imGcpYFGVBdmJuJXwZktzZx2evt8WP/fX/5D/+rWsBvvh9XxDHZvhZ55z4Zj/8+FBpTBQbyxsCYs37nFJDEdQkxFmEOqRr58CFOELbdrQqnBXyLMU0EbI6Y9LM8ucpxIPKV8HlNZxd1zzLB9ew9VixW5DUWpb/nFx7Qa0NPN9H1/fY7fbwQMYjNStopbHbbpEkCY7HE5I0QZkRYfZ0qjH2PeozJfpGUYi2HzHOtG+XPjB35EOHMUS4lRJd22KeFTwzwc50IJyONcZxQhBKGHhwWjF6S2NkZVtdt6iqCmPfIxIkpw2EjziSgDHoGiqX94cDZBSSjVYr+MLH02fPYKzF4eKAse9Xl+Q4zTg+PKDIMhz2WwRBQHZdNfNsgYw3SULZC8MwoOtpEBqGIYqqxDhMhHUTxM8buh73d/cEa+GDNgxDdH2Plzd3mJXCwMivsixgrYMIJAWNjAOO9/fwQcNdWtkurYtDUZU412ecTjXu7x+gZoWLiwPCOELXtcyh8LDd7RAnFG/Wdh2iKMZms6EWgtvPIs9RbTaQYQRjgVlbpAmpRJM4Ybl1TIBTloDHUYirp9eoT2eGjQ4YJ4UoTpAdLhFXe4hAruvwOE7WOLp5mpAmEXw4uP6M5t2vQFqFarfD4/HIzlkLmaSA56NnP8OkNNI4FGPX/Puffy0NfssOgPde3n9m1uaf/4Zzf5b9fngNuAx1FlOKz7BPsjyaDw33sA6wKBaMBkTDNFNgpVKUNrvGe1OLkWUpnKMPL62tPO7xKYeNMOG0QzdMraForZT+/+Le830OmEzYVQfeYdODKwNiFzg4Tra1aLsO8zShKHI83D/AWIfv+55PQk1kIX3xwXPsD/v1NTje36Opz7i/u8f19SV830fbtjifzri42JOwSCvKAdQKY3PG0PcrAMX3fWR5BjWRYSjg/L3ZWMBZXOw36M5nNPUZXduufegSdWWspZ12FBKL7nRCwgPFpuuRltXqsDwfjyRhFT7OTQuwfHiz2RARSPj4+Mc+gvc/eIFz02HWFrPWSOMYVlOP/si3fhzHCOMYZVUi5ICRi8tLJAkNb3MWKzkHGOfQ9+TbJ+k0BYyOw4B5IN7jPJF56vHxEfd393j37XfRd7SNMJq2RIQdN8iyDE3boa7PK2YuSRLM04SE48LnmWjSWRrDGtKnuGVVzOwJMp0pxElMA9+QlJTnc0NOxGkGPB9ZVWGYFaIkgVEKLqBQ2ebmAwg4mgm1HYxWyPKcBpQyhPMlZLGBjOkiGfsBu8Me8zjC0zOOD49INhuIOIaAhfQ9OK2R5TkOlxd/sEjjz/6WHACf/D2fR91P/7Zz7hsqj/wPpfsuE+GF2RcELO5xgPDBSC+xHhjU/1N6rsftg2UFmccACsH2YBnSpJeACeE6RAyEIFOG58EXJFiRgcA0DtAcg0WeAur3FjahsRZFluLi4kBEIUGQUs/3kcQx9oc9zucGSZIQLIJ15/v9HrNSBAPxPRzv7+EBKIscURIzxJMQUk19xmuvP4XWGmVZkApyntDUNYzROB1P3J/S6S7CkNx2HlYakpTB+rrC0aaF9sRmTTy+vr5YV65qJhQWsQgNPEtpyE+ePoExGs25gTMGu+0Gp8cjDVOFgFEzijRBEkc4Nw0O+x2Op5oYjJxITEGnJHseOD2nGya0bbuavIwxGOcZcRwjYRbD1eUF4iRhHPm8XhwUBiMo4s1ZCoGNI2itIAMJOEve/olSk5M4xn63o1DVccS5pr5+s6mQpSmElKi2FU3lq2qt3saJQLJZngF2YUl2GHsKMN1uK8RJwrZgy8wIsktbC/ankKw6TRIURU6AkVDCzDN2+y3KakMzrTRFdnmNF7/yJfjdEcfTCZ4vsNtuILgiEVIiPVzire/5DKpnb9A2RQhOpZ6RFQUe7u8RRyH6boCfV1AseqODvEbgQUgff/If/s2//q0/ANq6fjIr/a98M1/r+a+gH0tGfRKHq+gHHPgpeecrmKdOtFy3qgQDprkOTKkNpUSRUxyzYUfZyp3nD3EoA8JKaQ0HH0EYMoKLqL1gAKiDB+uIQBuEZIYJoxjHtufBlIKaFer6jFPdYGJjkNEGNze3LDWm3rU+HrHf73B//0hcgL5HfTohCASacwsZxXj27AnJU7cbxFEEq8l9lsQR+rbBm2++jrYhKo3vA8YanB4foYxFkqa0ZhoGzEMPq2aMXQurFerTibh5SYx5HDAOI5qGsgVkIAiQojSmaUTKKPSldRrHCU+uL2moOk2oj0fqoZeefFaYpwm73YbszuOAsixwPtVQWqOsSgwDbTjKIodmAc1hv6WEo6pcq54sTVCVOaG1rMXELRv55jXSJKaYs1DC92g1V2032FSUmxjFMeABIggRsiRbyhCWY8XCMECZZ+TnUGpFh/dth7btoRlPnSYRfD7cHbBWpM5Zak9GYkr4zPeXoUTIw15jDC6vr1YJsOCwFBnS1mq32xIViZkTlmXkge9huH0BzxmUV9eQ5Q5KKbx88QKn4wlSELqu7Qbq69WA080N3n/7nXVlnsTxWs3ZeYQzBsVmg5lBrnEoocYBQog/Eknx2rf8ABjG8Y9Z6y5/w3sGargpoZbx0UsIyBJOQUYbXvUt7Dqe7keRJLUUr+hoz+wIzc3u8yU+WykFGQiMw4R+mAhxxS+usxaSWfMyjADeVytNbD9rDbRWyJMYx+MZXU84qrbtIDyg7zocjyec2h5FWSIQZACapnlFlgGUEjtr0nkf64aYeiyplVEIEUavBqOOSsHLywuEUUjKPV6DXl9dQMoQE2u/kzhG23W4u3/kXTf1TEWRIYkJRnK42COQwVoxgV+vcRrXyqDabEnNyFDQqswhfA9FluLh4RHhh3h/Q09DUBkEiMMQXTdwK8LQjnHE5dUF2rbDfr/DRz/2EVxfX2G7qXD92mtI8gJN2+Hp0ye4urrEpDTp+qOIUnykRJoXqKqKw0qY2sSld5qTFLasirXaiWKK7zaGMGS7HYVzbLdbmpSnCbI8Jbv4OFG76QFZVSHb7tB0lCKcsDBrVhoTi8oCQVFmbduhPp8RyAB9R94LsKFqnmbsdltCqCuF5kxefXhAGIUoNxvEaQpnLd7+ylcxdB2ahzuYrkUWh3C+j+uPfhSGpc5t06BtWwjPQ3VxDfnkk1DNGVkSQynFiHIKUi2rCuM0I0ozePPA+LlgFTFxbsVGTeO/8S09AP7AF34k7Ib5j+MbMP6/VgJMqTx2tefKQKzDNwr80HySLm2BW12Dgr/TNNEk3+NSfJ4Vhzh662Hi8WkuPMB3ZLu0nqBbw5EGX7P2QHCy7eI3WEIp4BzyNEHTNAjDAFppaG3gnEWWJuhZwx34HprzmQ4uPsgW6zD54S2un1zDOiDnB7Q51bh7PCHwBbr6hFPdsJKvxvlUwzqL+lRTqwS3OgO3+x1/L5+4cr4P33M0uOMVX5ZleDzWcIZoPEpryJACNYdxxDSTj1/NNFMo8ozDNYKVKhTHMcC37jxNKxjT54gzpQ3qc0N5iMZS7ytDhJL8+Is5KAhIWaeUWi2+vgfkaYQ8pfVg0zRk4qoKJEmEu9s75GWFIEkRJhnSssBrb7wOXwh0TYOmadE07bqavXnxkhKSuWIQQUAiLWORlwVkFCHJKA9QzTN58hkD9sZbryOQIZqmW92oRBAa2WxG4ahaq3WoTJoNkjsvUvFxHHGuazRNBxkRZt5og4eHR3TcDo1dh3jZFhQVgiSh+LrHB/hjhy0Pjq0hmnWSZWQhLirY8ooUgIEPw6vEpq6RZRldniPlFvQMYgkjGirGSQw9T14SyT/+t3/+58Jv2QHwD7/03he1dZ/+jd36TPMJBKZZQzIo0xj7arDmvfIBhOECAgE8Rw6qUAboug7TPKPMEva6s1ecK4fl7/BpvAsP4DhtWo9Ylm/COQQy5JRbf+XszawnaJoWkv34HybbbMqSgI2HHWcJUGDENJPtNw7JX54kCdp+IBuydWSJ5Ql6EPhoTie09Yke6vqEtmnQNS2EDHB8POHx4RG7/Q6Cwy/oRiLWgZ4mWKOx3VQMHiEDzTLk3GxKtF2Pc9utP3te5ATjYGflOAyQEQFXyFhT0SEI8BBspJ13uOQPzEjSFGlKzrmyLNA0DfI8xcgR5iII0DYNTf7bFuMw4HQ8wfc89MMEGUb8kFuK+c7SlSY09gOc1hAetXCBDLG5OCBMc0zK4OXNPU7HIx4fH9F1Pb8uhk1GlnIJowhxFNFUPk1wd3vPno0AIlzgI251fg7DiN1hhyRLKatRUsBqKAlGMs4zhcImCXEZsxSKbcxBEGB3ccmtI0FWNpuSwlEmsns761AfT/RMG4p/D3yB0CeDkYUHz2ioYcDl1QUOFwcURUn8yc0G9Yv3UH/5H0H1DeqHe1hLbalzjl9v8qLocYDqOozDQATpSa1O21D4yJLok29e7f7At+QA+It/6mcwK/1vuV/H8vv11oAL1CEQ/jpVJj3QKyqQtdR7OWtWBBisRShDdgo6WotYIgIBWJHNPmfU+Z4H4Tn4AKwfQDuSgkquDLS18ERAlQMcYDVlAIwjfDgIVvtZQzjovusRclVi4aCNw6QM+r5HEkrkaYw0CuFYH+4ztjvh/AClFeIoRByF2Gy38OGhPR3xcHdL+X5NSx+CacY8EUikqkpCZ7MOQSuNOEmhlMI4DrRtGGds93tYRzFni1JymiZcXR1g5ml9zSZlMCqNaVaIJKklZwZbPtYtnC8gZUB2Wi4lyyKH8OkmT7IUEKS209ogTRKEAQm1sjTFPBNa6+HhiKqq1qpq4g+DD6qwdltyUoooWifdwzBCBJIDWQjcqrVGx8NOHw6TtvCiDGVJv2eWkxPzcEGADNLwGzISscV4Ab7oeYKZJ1RVgf1hC98D3DxiPNfUwliHJM/J3iwDhEFAasKqQiBD5GUJXwR0eQw9Zm0QP3kTH//xn0Swu0IWSSRpym3UtOZFEvgkQ18fCSs/jqQcdA5j20BNI7R1MPAwGiC5uEb57A0YB/THIzyr8fz//r+gb98lLDrLwaMoxtX1FaKsgPM8Wm+qGelmC0+GjJRjizfZ5QPp2X/zL/6pn/nNHwD/7d/6xUtt7B/6DbX9bnHx2Vf9LodGCL6tF52/I6D/2osL3199+Ev5XRQ5PVS+D2s/tGLkA8TxPGFZ5QmOFpeBgHUOFuC+kw4Cy2z5cZqRpDFmpZHnGR4fH8lyygEh4Km0YWkpHFivwH9nEgHcy9V1Da0VzvUZQgSIE5o6dx3RXqI4RpHn6NoWWZaiKnNsNxT2oWa1rj4Bj9sPgoosmCohBM7HI+X6Map6muZ10+Ksw9XlJdpuQJpEGPoe2+0WcULlfRBI9G2Lrh8QRhHub25WFBacQ8CCJ6OJxutA9lhKyRmQpgmqTQVtLKpNtUI/t9sN0ixFURQQQqCoSiL6DgPmccTA2n6tDeaZZjQONKhz1lJoCh9OYM6jccCnP/3dOB+PONVnmtn4AtlmQ+2CECTTFT4MrwcX+/HxdOYkY7pMSKuhMI8jjg+PeLi954NQQAQBPF9AJikM+Jlh27MzGp5Hz6znLBLhIMyEPI1xPrer8/Du4QgPJKOeZ4WubVGfmxVt7nkeXBBCzzPa0wkiDIH9m/CffALZx38A1Xd9Bn51WHMRF2NUUZaII3ofjdaIkhQIIxyuLhGlGZpTja6uCVgbEcmors/Udvk+kiT58Z/6oU9f/6YPgHlWP2Gs/Y1RSHllJVboB63Y3IeSf5wDG1eWQFCf0U1U9o7TvBpHEg7ftPzAJHGEOIrXYEnHbHhSnmmknBy7HBS+70NGIfp+oMOBbx/ChNHNZSytB5MkIcNHyF+zxD9HIT0cHFACa+H5AtM04vhIZd8wjIyzJmELcfv1Wvp2/UDtSRjifCYBUBAE8HyCQoRRxBNl+r5t0+C1156hH0b0w4TXnl1j6DuMnG6z3285yZcgpedzjcNhR8MqVj6GbMNV84RJqTUNqCwLjENPycYMU+3aDmEU0eGtNQJ2ChK8VcIXPqcMJxAigJqJq7/ZVGRQAak9iWlQIslShl6Aw0ImWEsDTZ9DPwzPiKyaMfUDhnFCnJGd+1Of/gSurq+QFQV8KSGiCFGaIt9sEMYxQoZ6zCOZjQ6HPS6vLumW5QSj06lG2/UYuw5aKXgeoc9GZQDPpwsBHp6+/owGgvOMviNl5jjN8ANSiTb3t/jyL/8SHp8/p3WnsxinGW0/YJwIVDoMPbqmRX08QSnKp2jODfRIAaqQIbzqAtXFnnj/WqF+8R4enj/HwC2U4xY1zUiZaLSGzDIYn6oB5wtsX3sdap6gJ6pg4QCfqygpJWScYB6Hy8Mm+8O/qQPgD/3I7xftMP+xb3ZW4K09PQ3/lvVeEPhYTGyGia6vWACOPQGWpMF8MARMa4nCkBDUDA31OFY6jsJlwcB9L3EDhE/R4tpoDNNM0tcgWCfbHkBprNqyO0yi7wfEcYKQTRfzPEGIAGma0O8kKHiUXIBE0U1iWveFnPCitcZms0H9/5P2Jj23pWl61rX6fq3df805JyIysqmWMrasomxTINwAEwYIj5jiAYgf4BFMEGLGzGIEEkMkpvwABh4gCwpKpqoyKyszunPO1+xu9f1aDJ53r8hylasykpRSiohUxvmavdd+3+e57+tKU2zH4cP7D1i2Sdt1Qi1WDbu6kaHO4bCTdVjbqv23KT67IJQVoqHj+ULCuXkAbwDSumkVzELutq4n4tIbBdh2XepGWAA3aertvj+PEg+2LVF+aQqU0g+9woo1+EEgdKG+5+n5SNO2C4dP0zXyNBdNl1qtda18j64ne/7NbiMPrbJmGnrqSoI7pvZtXr7vO4ZRcGs3ao7G7YGtqsGaRhjHmK5LECcYtkOPTpDEHN484gQBmiEx35eXk4pI+8SJSD/l9CNqtziJSVYJYZKwu79jUFJPPwzxo4hZNwnCUIal80wSR2Rpxvl85eX5yNjUXD58w9xVhFHMPEu8/JN3j+q0ITqxoqxAk35AkiTShuxHrDBm98mnREmE0RW0739M//xT+vTEWKacT5JaDMOQpu0ww4hgs6UfxyXclp7PXC8pbrwSRJuh4/o+wzThBgHRKqFtW1V1NrShaf7TP/hf/pn5Kz8A/u+ffPW26Yff/66bPw0Z/o3TpBj/kvU3lfTDteUYrmn6wv9Hcej7Xpp1vu8y9r2CfEgqi/lbz/ygXtyTCmncIr6GIRy+sR9o2l7WPWoCblnmAuVklqN1HIW0XU+Wpktr0bFtPNdWrPdOVXJH6lLy5P0gXfrX4xlNg/VmTdc0NE1NGAbCNqgb6rLEsyUclESBVHPVsdpRD42bpOKWf0DTsB2XXll8r2nG45sHuq6jG0b6fsSx5Hd6vaZ0Xau+x452mNBNmXWs1mvyvOByuaKZ1rIOa9uGbpCCiqnrS4W3blr6vidYJcLZb1sc06BtW3H/qZ9z23bU6pPVMKRX3zTNIgWZpomuk/59VZTLVUqbZ5F36nJtu15TqqpCQ1gFpiLfzGo1OoOcBhwb3XbQXY8oipmnibyo5dSGyE62mzW73QY/CrEcm7ZtwDAxbUeO+CrQZVg2yWYjH0ya9Glsy5TfiyPXH9txmIBZN1ltNqyTiGnsKcuKZJ2QpjlV3eAnG+4/+YRoveXxzSOr/QFvc+Ddj36NT37tN1jfPxAmKzabLXEcoSks/fnnf8bxJ39E9uEb2vMr5tBiWiZ1LbyKzcMjhmWjhxvMzT2aaXF5ecEydFa7HeenJ+YiJVLdhRmN5HBHVdU4txr1NN5Et39vnoa/srT3Vz4dxnH8B/M8r36l1f+s+H8K7qHP2vLFGYZO04qf3VRZfV3JM01V5Binb9nyuiZ7zrbrCQKhAHW97EaHfsBzZadrGjqV2l8zS27AUUmzzXpF0zTstis+Pr1KnXLoF1GJppKFwzCg6/K1uJ5LXdV4riPYajUUK/Icc5Uw3xiCo6TVuraj6Qc2mw3rzZrL8ch2u6YqS+ZRyDrjIEfzuqzQDSmxOJZ8n47jLEy+u/s7nj4+EccxaZqz322ou57NbkNfy9c25APjKEANyzKpyoJVElHVHY/v3jJUJafTCU3TiFcrOU5aJlXdyhWgqgReahjsthvKsiIIArq2XVx5N//CPM/ECnW13W1p25airHEcl4taYUobUicvCuq6IU0zEWAcDELNY7WKhaJ7PDHP0LU5eeYtBGXHM5g6oQDNo4hHdMvC9FxMP8YPfZq65HxsybJCRK29yERty0KfDMZBPIZeEGA7Lm3bMfUdAxq272Ha0oEADc2U1wBjR3ap0U2Th4c72lqsyXrbsl3HxN1EGEVEnkWUiPDVchziwx50k+p6Ac1i//mPqF++QdM0Pvz8C968fcvx6YWXb75k1Xa8+f7nfPXVK54j1Kb3X3wpJzxN47DbstrvcbZ7Ts/PbAYZ6HqOg20aDHXFOMRMgMAAACAASURBVM9Yhkb64Ws8P6AGLpcru7dvsTSYeqlyz/OM7bg4rhO0VfsPgZ9+5xPA3/mb/5bR9eM//pUwQ7qk7FzHWqbDtqIA3YZqUvKRZtbNLW8YhrD+ZuGxiwJMXSdUaegW9b156ARpLalASRnKvEEQVQbDKEezcZpghrxqMCyLWt2F67rBsWUKPirDi6YLm3Clhmi3OUMYyn5Z0w2yvFRJR4Msy4njCM/3FAlYEoSrJMJTeqe2bZVee6JrW56fX2Sl03cLAPM2H+kU1HSz3SjZx7zs6U3TJE5iTqcL8zTTdi1pmnN/2LNSHXc0jabp6JpaOHmajheGRKsE01YGXVOKPq4rQA3hMahNgSWqsrZp8FxvGSx1nawGbUsQ4J1aB37yyVvF0RNT0X63YZpG0XKrIW3bNJSFiDklai1DOEN5G25259umaJpBM210L8CJ1vRtQzeB6YYkSSC5+vRKlRdUZc3pdKVte1zfl7KUyof4cbxo4001KOwVx/Cml9eYKbKUtq45ny/MmsbpeKLKc/KqZf/uHf56w/uvP3A5Hnn9+JHsmnJ+fuXDz7/g9PEjfVXRFSlNlvLhT/6Yvsh4+vhCcjjIa7LvaPIc15asQb3wHJTHYpqoWwG1RKuE5vUZu7osmx1NUYzmaVJ9EI3dw4OUoZ6f6OqSrm6YR2EYNF3Par+Hef7H//x//u+N7/wA+JMvPt63/V9f+/1XfX/fcn5YNEumuu/fyhW34ZysLgypziqFk65ri5paegUsRKHbPxvGSclB5UFQlvViqO2V3NFUrL+qaVmtYlKVtWeaqJuWMBA82C3/LVJHY5kBOIpNEAYBXdfjOTbaLA8i13MZpxnPddDmSR1bZYBjK0XYdrelyGXqfmPyo+lqfXfbT0+LpnqaZNUZRSGapnM5C/rLU9KJ6zVdTLa6ApqOQ6800gL3EHpOTBQF9F1HUbdYrsBTJ0VD9nxPPsVsewFkdl3P68tRlW8q5nEku17J04yiLEVhrk46ZSHBHF0Xdt5t8Hmj+JimxYzGD3/0A+I45O7uoIZvEt1NrxlhJPCOeRboxjDKvOi2XzdMC9O28cIAzXLoW5k9ZJcTmqGjmxarzZpklWC7DqYl/QHb8/ADD9cPsByXpm7xggDL82TVVjdYjrtwCaZh4Hq+LuGyse/R5pl5mhnnmVYNWzVNw7akSNY1DcPQU5clTVGgNQXnpw+cPrynfvlAdz1jTT1dkXH9+IH8emV/d6BuWoo0FWmLIi7fyMWffPoJg9rh93nKZrchv54xdR3DNCjLUgWVDDRdqupN0+JEkWzI+pYyTZmB6/lCnefohokVBLi2+XfHcXz3nR8Awzj9vWmek+98/9e+HQBO6kU+TjNtNyzrQO1GB1ZvbFkPmeL3U6EdseNIZ0COxcZCyZENgaFOG/rSJ9d1TTHnhaV+Y9ulaUYYyMqqUqrpVpFWtVkqpHL3tpfeQZbllEUpRFrVVe+7bkFyjeNIGIaUlex6lw5CPyw0XT8IyLMcZnh4vF9mF5Zt43kedVWKVsqycVwHx3Uoy4owjtjtt5xej4zjSJzEEjdV6SpN1yRfYJjM48Q4jFRNw2SY1G0r93FtXtyEulKuPz+9cL3mFJXUh0/HoxJxjNR1g+04EoVVSccPTy/0w8jr65E8L5ZK7i0paJoml8uFoijkwWTI3Of2uxyGAU815m5izqZpyK6pnM4G0WDHUaTIRgLNGMaZybAJNjvQdKZxYOha6rKgzFJGxCFhq22CY8vuXq6OcqVr2xbd0CnKkt3dQU5ASUK82TBPI2Wakl8uTNNE07SyQlYP/mGQ7UxZNYxDz+mrL/n6T39K37Z4vs84DDBPZJcLpuPRDTOm62I5DudLSjOCHwSEoQ8zuHFCUdZEqxWlaiS6KjE5qNOi53voYw9dzdD1UhkfBZc/jpOsTecZx3Hp+p4iz2ibDjcMYZI8xaByELquYzsWDAPrJPLu1tE//E4PgB98/m9owzj9R/M8a7/s0G9BDOn6cpQ19JsEVFNIa3OZxKMKFaN6U0vnWxzummEsm4RpHFXUdF6gGMM4Ktac7LzHaRKc04ww8tR02lXqcA2k0qr+fCmcyDFznGf8wJe6ri5dgUThrVzXpShKdNNiGCfQdMpaGm83ck7dtGi6SZisGMeJ7XZNW0uduB9HQkX4rRthCVa16KLiOMR1bNF5Bf5yCnh5eqbKc7I0U+AUqMpKPUANqfzqBr7vczjssGxZz/mui+fYWK4nR0nbZrNZKU5dSluVUhaqKk7PzzRFLok6wyJZr9nut2RZxjxPfPz4RN20tP3EMIn1OE5izuczvufieR5VWfLp55+iAWmaqdMJ6gHdUlcVviMPtdVmTVk3ypCkURQFTBOW4+K6Hq4j8tK6KmEcwDSxwwg/2UjfYXtHmAghV58GhiJlaGqassTUNYq84HI8YswTVVWxWidURSlR2VnWj67rMnYdeV4QhBFJEpMVonhLVH7fsB3GGaI4FlPx2FNkGU2Rc/rwXoadjs1muxWSlC7Ite12w1RXNJczvie4OM/3cC257trJhiRwuT4/09Q1tm3hhRJyyvKCrqnR5pmqbqirGj0IcV2XOs+YxgHflyKU5XniW7Alht0rIY487EyqLP12jmQ7lKq+HYbBf/CH/+v/oP/SD4Cu65JxnH7/lx/6fSv0vFV+Z6BTEWANYdbNs7zpJcknDbZhGJeV4G2qLy6AcQkTWbYtx0zHRlMs+3EUoIihy+rKUGzAG8sNWD6Bxmmm6aQTL6uWAN91SPOCOAqXY2yR5ziq4ss8U1eVIgHJiusmLgl8T3x5dY2ma0s46DakdFxXmPxqdjAOI9drSnpNF7LQNEk8FGRGcTlfOB2P3D8+APD88YlYlWSGrmWaJ2XX1dFtD922uaY5RVkJpFKJMG+q7qaqmNSGZZpmptsnsifYq+PxzGff/z6esh6HQcDj4z0vr0d2uy26prNOQq7XC5qm8fT0QtvJHduyLOIkoatbHt48Cne/aUmvF9q25XQShoDrSWYjvabc3R+4pPmiSm+ahu1ui+W6eJFQbm7QU80wWe/uiNZbTMvCD0LuP/0Mf7XF9CO6QdKORZpxPh6p6pp+mGj7gQkDP4nxA5/0mslr0LF5ev+Btqqo0iumbTEbJu8+e8fbtw/oqtjkuuIDHAbhLz4+3Is4pusYJyEqnY8nLperhIhUgvXu/o55llPjMM3CdJzBcj08BWq1PJ8ZGaTeDNGCtneFPKVpxHEk4hPLIdpsKAtJjLqeTzdIDdr1XKE0DYPE55tmkea4vvwZQ9/R1xVDVUpuZeh/D7TVL/0AGMfhN6d5/uS7LP4m9YmvK6mnoYot8zzLp7shL0BTDQFvTT5BKYnpZ55nBnVXvQUibuRWXddp216RWwVsMSj9tWVZrOKQrh9wPME0aQpCqmli5h36fimUGIYuqOmuX+QjjVJK62qNGIQhuqETRiGdyhPMiJDkdDyq1KKGq4QX37z/iG4YPL8cCcOQ9++faJqWtmlxbMGEr9YrosCjrWteXo90ymw89L3aW3tkacpuv5Wcu+sQrxLpjieRmHZUCrEoKkp1spCHgKzoiqIkCkPcMGKaJooi5/7xgTyvuH+QSvL+cJCIcVXTD8IDeH450rY9ge9zuVwpihyYOew2RKHQgLbbDclmQ5rLkT8vSmagbDpeXl5I05SqrGQEp+nolo3puMoJb3C65nQ3y/I8E4QBhuPiRDHr/V6Y97aFaTt4QSgV3L7j5cM35OcLYbxC1zRczyOMQtAN6rqlLGuFkZ+JIp+mHeiGke12xazp7N+8IVmvkMOotsxpJjSGmQUnb1sidc2vgujyfQ/bNCXlqGtsNhvyspLX3tATKUZf13fs9nscz2O939I0DZdrSq0IQpr6mm3HoR9kSGsoU7LrufhBQDPC0/OrlOXUrOea5fhBKLFs4Pz8gm4Y6KYpDdmyZB56yVQMA77v4/sBpmXRNQ2rzYphGKjL4s089r/zSz8Aqrr7+7/s8f8XB4FLn/+G21JllVtxx1SyRF038B2bruuXvsCtNKSp6fBtnagrJsA4DELimWc8x5J+vqErroCcKm4aZ9cXg5BpGLJLdj2Rbc6SKtQ1naysiJOIoigXo9BqtVpOGoZaHzoqw34rk6B8e8wSEV0l8kabBjHu5lmxGHBc15V6cjcw9IPyxBsM00zXjwRRiB+IZ6Bt5AGBigbvVUW4riqiwGOzWTENI6fjiZf376mris12S5xE+GFA3XYkSYztOKDJjCJZJ0RxTFnV3L15kOGpoQowtiVwUk3nh7/+Q8qqJstyXl+Pattg8Pn3PuXd20cJaxmGpPDWG0zbpipLijzHdQRgGsWRlFEUjUnTDRzPw3RdtvsDQRTxo1/7AW8/+5T9/Z1k2z2PIAqYDJv1dsP2sBfvoKnTVCVD3zH3Yjl2g5CuqSguJ0xDo+8HoiTm4d07bFugr13bkl1TurKQVZ2h06PT6S66FzBMyKfr/Rss18O05GSZp5lyGnYipdUERfeqTEW9wqaFoVSZ+3Fa4s7DMHC9pHJKtCVU5rguH5+eaSZohxF9GsmvV0ZVEAOUys5XEemW48uzXDHCCO/+M/RwxWp34HpNyS5XsVjPkwhOVGAtv15p6hrHE/ht3/ffztlMUx6+zMzDoLmG9o9+qQfAf/1f/BOt6cd/8F2m/9+ivL7N+ZuGLljqUQI8jm0t7TXTlLnA7U5umMZitHFsC9s0mTXBfk1qCmsYBqZloWm6FDVGGTa1TYtlWWR5SRi4NG23oMJ+Mcvteh51VRP4LmWRS+Zak4mseN8NxnFYorKT2kq0CgJZVZX82bq+4Kz6XoCQfuDLluIXAChNK1HQWQVRgsDH8zx00yIMfdqmoa4aXN/nmma0bc/1cmW1XqEZIibtu566qvnyq/dCKJ5GBiUaDaIIx3N5fPsG3bSo2w7TtmgbkYZM48jTx2fpxOvSnAvjiDS9Mg4Dm/WK4+srddNyfD3zgx98j9UqJopjHt48cP/mLZrtECYJQRgtTsbr+UwURRRFweH+jr7rWSUxM5oiEWvcP95jOC66upp4gcfQD/Ia0DSVIpwpLheuryfOH97z/OGJrm5o64a6ruVhadk4fsg8Dlw/fEFzeqbJMsa2ZehklpJs1rx588g4TvRtC9PI9XRi7FoM02IT+1QXMe5iWriuDO02h72cRDVNKdI60qyQ7IFhLth0UappbHc7Hj55x/7+jv3dHUEY0jYtgefQDwOHt29lnXg+88XPv2SzXhHaFoHnkD2953w+C0fxhgibhN6kqbo688zQNvR1xdh3WI7Lerv+c8zHaRzxQ+nFdJ2sMpumw1VV5aKolhV4W9fqw1SGjY5l/P3/6j//z4y/Fgv+T/7Lf7q7FvV/99ehv7RfwH7NCveNCtVMs0JRjSOeay+6r1u0d1IrK0edAkzTJPAERBH4Et7wFPK673tQswHHskQh3YkNyLRM8bQruu9+m3A+p1J7VSeApmkxkF+qiDsdTucrh92WsqwUH8/FdRyqqlZHTBfPc8nTFNMQqs7r8UwY+ozjyPV8JYojNbycCHzJBxyPJzzHQdc1qqpGQ2MaenzPJQh81quES5phmRZDL+y4ZL3GVlNzAD8MsC2Ln//sS4FKlpXcTTWNa5pxf3eQiq7r0XaSyvvk3SNlJUM2z3EYu5b1dk1ZNdRlhaZB33ZEgUuR5dRNK1PxKOJ6zQiigDLP8FyXLJOv7xZsGudZ2PiBUnMDrqmpF17AbrcRbfndAds0ieOIMAooC1mvmoZB27S8/+obUW7pMPU9Y9dxTTPy9ELXtpI/MHQ0ZiZDQCGn12eS0Of8/JE6vXA9vjINPa3So90sQ0PXMM0zjuuxPex5fXqRta2hY2g6zFIh79XD/Pj6ShL6NGob4pg6L8+vSyLVUT/vKIoETNP1y+DXdkScYjsWXd1gWRZVIzq50+uJrqkxdQ3PdWjrGn2aYJD/v4hEBFs39D3TMKoPFdA0eb1alk1weGBsG16++BlVkaNpGkWekWcFmm6i+aEAbkyDoWuxTMlgTNNEWzfiRdQ0/CRGR7BhwzitfvDp4/9495t/u/grTwCvl+JvTdMcfpfm3420eju2G0ryeQvs3Jx/0/IAkFXaLRJsq2irpVYvNxZA3bSgSEGWIqeWZSW/KGYc1RrsOjm6GYZJFEeL0qqtG0lRKY7ebbhnmZJONHRBiFW1RFmbupY7rfoz9ncHqex2HbvtWjrjdUMcBfi+j6lry8Dxes2WHW1VNSRxxOGwxbSU7ajr6dqOqigpqwrf95nGgabIaZqGOIlBg/PpvLAPPU+6CJvdlq7t5BThe/ieL1QkVbR6/+GFsZcJ96TU4NdLiuu6bLZb2WcrQGcY+GItfj3huQ6rOCC/XNnvd5xOF8FqzSNj22DME8Y8odsutid5Asc0KIsKLwjAMKR/YZpczxd002SaZ/KsZLtdEUch+fXKT//kJ7i2SRh4S+V5GEds21TfCwok0skspm8ozi9MdcH56T1jXTGUBZErFeu2k5Pi2Pfk14yuFYpwEHgMfUdVFGSXC11V0XYdWS7DxXmaGOsKvSlIT2emcaBT4I55mrDVKVBDW1DfliUVZEddIScFRNGBMAqkY7DeYHlCovbDQFGJQmzT5MOXX6IbBm/evaEfBsIkVp/YwlA0DI28EBuxY1tcXl+pPn7JVGVUKlHZNg1tJ7H2uq7Z/vC3CB/e4m12rPd7DNNgtVkTKhCKaYs/Yuo64WWGEZZt+55j/d5fewUYp+n3/zrs919G/5HpvQA6DdXs03Vd1meK76fpuqr5ypuw7aS6KwrrmaZplTNQ/t2uK5+m859zBHzrCTBNY8kUGKZBUUnN07FFAGmq6uktK2CoCPEwzrRtj2WL8NNWdzdbDaHaVmg6XdthmQZhGErpyDCJVytaRY8dVYnnJilJ1KlgHEfiKKBpWva7DaWCUA4qa16UNV4YsD/s6FX6MMsy7h/usW2bpm64v9urCK/ouBzXYbfbyAui62Aa6foewzSIApe2rkl8l/yaUpcl2jzx4Zv31HXNw8Mdq81GsfVtrmmGacu1IfBc1nFAek05nS8Ylo3j+nTDiBdHTOgMXUt2PjP3HefjkTxLqYqc7HKlbVqGXrr8p5dX2rqhaxvapsNUOrPQc5bUpGFai47LMk1Wq5jNOlE0pRHNkDZkn2eU5yPXlxcsbaZrm+WoHCdSPa7rZmH1W5Yk7NpaUFnn45GmLNGmCde26Uf5cGpqqUPr8wTDQF2WQoEOfZhGXNuWZqiKht/gq0Hgy98bYp46HU+Sw9B0Vts13TgTrFYkSYIXBET7A6vDHs9zuJwv1FWN7QdYrsfu8QHNtLAMg67r8D2PzXbDME7c3R+4vv+G5nwkvV4UwcklDkM0Zkxt5vqzH2PNA9HDG5zPfwdzfSC7XHEDHz8IMSxZpUtlvMWOVwRJoq/j4O/+lQ+A3/2bf0cbxun3ftk3/rfYbzUA/AtCDxY5xqjKPLqhSzhF1+nVw+B2v5zVCuZ2grgReW9Ul1lNbMdRQihd1+M49oIHa9uWpm4IQp95HlW7TK2HVDfBsix0bVaYMqn83tRQ8zQRhiG2bZErhv6kACTtbbYwTyTrNZ7vM6PLBN40cR2HoZNB3E1ccguj3AI5ddOw228ZhoE8r5hnWK9WuK70vvNM1GXn0wk/8JcH5m296no+pmmI9irNaOpGEOemyXqzZr1dKySYgDPPF4m3pteMtmnRDUn+jdMkOYNpVlViyVpoukZR1WRlhel4aKZNlhfMfUeZygrzfLmiIzz+aejp2kbZgKCpSuoyZ1DZgyyVvw6iUL7HpsPyApqup+06TMU81HVDPuX6EScIieKQtq75+PXXpJcLl9OZy/lKUZRUdatmNNJrcD130bxdrxlVWbFeRYSBL77CSgpIo2HjxmupCg8DZZ5T5vkS7BKbtK7yKtaiiWvblvPpQlGUHF+ONFXN+XSmrBpJkA7DkiL0fR/LtomShHGWZuZut2MaJ6XFs2TVqRtYrqdyLlJxT1R/pEgzzq/PdE3N4/3dsmloVX+haxq68wumDpdzih7fYe3eClY+L5mmcUnd9m0rczPXp6pq0svld/9VSMifKwN9fD5F8zz/6LtQfzTt22uArAKl4WeoVJipa5imLly7YVDdf4n7+q5Dqwg2GBB4otwCiV4WhcAsNUUMdmyLvOgUb0Ccg8wCv2xreUPd0oI3HLVhGHSjJA2rplaMN01dN4S1P6sY662JtkoSTscjlm2rY6DEWx3XlQLQNNMPA30nhRivqNhvV2RZxna/o64bXp+e2O+3QsZREedpHAlch88+ecPH9x/pfYfnl1dWScwwjgSBv3T9+2EkWa9oqgrDMGXlOQ5cLxce7va0bUfTCa8fXadpeyZEd1YWJRozv/7Dz2ibhsvpSO1Jpt9yHLEGG6bQbg0D2zdIVjEvLy94tiTi8kuPNvYMTU2pzYrYU9C3LRWTXIEsk+slFRhnEFLkBWPfU3WtrBSjaOm1e77P3NT8+Mc/xXFsHnYxdV0RRRFdfzveNriOJRbgeZKhoWmBbnC4v8NzHcqqoipk0/L0cuTt9z4je30m8APxFJgG+qwRJ7GqfIulOHn7uXwqdn/AWKaklwtNWYiXUjkRLMVCGAaVJp1GqjwXPdolF5z3ZkPfNWR5iWNLMnJoGnkIRJH8XDSN+nqWYZ/voWnyGphnQdU3WQp9u/ATW5UIHMeRy/lMO4yMCgV+OZ0xLYskScTArKkPQ8NELwuqr/4lbrIh2B2wJxlia5rG2HUMrYXu+WhepIhc/Og//nf/Rgxkf+kJwDS1T6d5+u7k39vl/1sPiCL1fPsJ0ypf343lzixRVV3BQecZNENUUOLr1FXYQlvy2FVdY9mWlFc6aQP2aireDzIEsRxn0VGN04TneawiMeg6tsXpdFkquFmW49wKRdPM0Mldsm7kDj+rkorn2riu/LJO5ytVWTL0A/044fvuchXplf21LEoO93cS7LAslU2QQNOtartaxfJAVDME0zSl4DOOHO52+IFPXVZst2vqWgAjNxpunhdSdtF12qZlnmZ83+H1+VVyAxqURYGmG1RlKa1KNTk+ni4UVUPXtbSKWOz5HqfnVw53BzQ0DocdlWrzxUlMer0uRSlPJS27flzgruM0k+U5h7sDQRhiGAbJKlm2J21Tq3i4yeObe6ZxpG1lJtI0rZJtTPhhSFs3sofPcjnVrBIBdY4Tg6azu7tj1iTafIv0zjP0vTAXHNtmRurQ04z87McJtBkv8LFcVwzBplxJbdcT8MYo2jDDMKTLokG2yFpruq4jDAKaWhDoceDSNvLJfL2m9F3PqMjXWV4smHtDN9QsBzESGwZ9N9API2VVLR9SZZGrzdMkK0WlZCvKQl0BXYo8Z5yRD4lppqtr2pf3XH7y/7DbrmiHEcM0l7KToRDvY3Fl6nsMTdt6tvVr/9orQF42f2Oecb/LFWC5BtwEB2pvf3sm2JZFr+AVjm2D0n8L25+FnT6oIz7MOI5FXpZytDTFqafNM1VeoKnjsOc5i7LL9X0hq/ressIzdcFglUUhM4GuxbRtdMtiu93Im9+x6QdhEWq6wCfGUYg+YRRKSEfFR1eJ3MWHvidZJfzpn31Jo/rqbVXR1A2Pj/c0bScap3EA3eB8FvffrUdQV/Wy30+SmPPpQllWNE1LWRQ8Pt5hWfKgME2DshQTcq9oNuvNBtu2sWyb1WbNpO61dVkJv0DlHsJQ1mezpgsmLAgkJt13OKo3kaUp2jzx9M178kwgo7pKL7579+YGllh+Fn3f47gOaVYwTrOIM7oW17GEfNPL9xxGkXqAW2RZjmk7qqUIFiNv7rYYpsn9wx0g8I3dfovruaIrGweJvPoBURITRCEYBv0oZbIbZWq9ShgVpXeaJqqqlp4CEqu1bIsyz5mmgfT5I+9/+mPGpqZvGsIwYLNe07UNrgpd3ZyAN/iK7TrSZ1EPad0wiNdbvDBif3/PZi+zFV3XKfKcrpE15iqJcV2X7Wa90JaatsPQDWzLxA98BQSNlFcxpiqkfi0JPxtf6cZv7os8y9TJSLAYl2++xjZ1LEbqy4kqywhWCWWRM4/ChXDffo5hWRh1jivkYFufx3/zX/sAaLrhd79r+OfWBBBEn7B5dF1TIFC5j4wqN31DMd/utLYa0pmmQd9LSEbTZYjXDfOivbYsiyDwCMJA3cs6PFe46bckoabY9qhj1q1Z2LaSwTdtF8O0WCUxh/1WBkrTjGOZAlJQNdyb7SVT4M6662m6Ht2UHv00zcRRyMP9nv1hD+OIZ5tkRSFrs2FYGARd00iizHOI4litSOV65Cs46KefvQNN4+X5hTAKl7TfPM1ouhznW5WObLoO09Blj47MRoLA5/h6pMiLRVcVhj5lWVLXDdM4EAQ+mgarOGScpJ9gmpbs8zNRZfWKQRj6HvM0CxjVkrKPFHlAN4TXmKxXkkhTw7GhbenHia7vleVHKdUciyAQQIrrB8SrNaMSwQRRpKSr3yYK0zSj7zrqsqLve65pwajpRJsttiNkpzwVrPg8j1RFzjz2SzrQU/yGpm4o84LQd9HniTq9Un38OdXzN1THZ4HAqmucpmmkWUZRVFK1Vdg50zRwlKXKdaWzcPf4wObxDYe3b/n0hz9kdbhjvd0QqrhvVcq2oVMy16IoJc1qmoSBz/F4ZJ4mTqczRZbJ6dB1lyj9rExI2/0eQ5cCmuO6BIF4HN483rO7OxDGEeMwkB5PMgea4HwU3XjbSTJQM0x0L0QzDBgHxr5nnEY05t/9Sx8A/8m//x8awzj9Nv8//iPtvllYemoL0PXjoti6vWFvNV+RMJqMo2jDtJv+ap7wXUn7zZMMULquFx9ePyzZew35c3oF8ZjR6MZpgViMfb88pOZ5ohtG2n6g629arkHd50fKQpp5kzqJXC6pstX6y/G34BqifgAAIABJREFULArWq4hpHDGYMZjYHvbyAjd1qkI01HGSUFY1RZYTrVZizHWk0GQox1wUC7YqSzNs22KzXasXn7sYa20d2qbh9HpEmyepejYtbT+ABm1VYSrCcZQkOJZYb9u2E5quZbHdbhXtRtyBm82G7W6Drt1mJPpSJvGTFZol99o8z2najpeXo3Tkgd1ux+V8JokjrpcLL88vlFXNh49P7LZrojgiTzNMQ6MdBsqyJgx99vutJDnHQcVu5eQ3oy20p+s15Xw807UtuRrQMUhMuq8KujLn/PxEU5XiPCxrgiBgvVkTJTF5ltOrUFfXSDQ4z3KKNOX8/Ex5udKmZ3Rd8hTXy5W6bojiiL4fVDFKXxTpzLMgz6sKx7FxwpDVm3dgmOiuRzNMBJs1ExpBHEu6r2mYho6x7xbJ5c2G/PTxWb1BBqoso6oa+lHe4K4f4Ichui5luPxyYRgkLOQ4NlmWsd7vCRIpOW0++z5mEMlmqeto6xpD13h5epFrUVlJF+D5K7Sho8pycWJOM2EY/tb/9s/+W/MvPAD++Ocf3Gmaf/CrvvkF/TUtw7R5nkX8OY5Lb39mFuKqignLp6F0BoTNLn89jbK60dUsQVRS/YJyusWHYRYemuMIUaiusS1Z3Zj6t7Vh2zJo6wZdg34YeTpe2O022JZFkRekaaqyDPLAqkoRLpi2TaAY8pOCcDJNXC8X2qZZsOBFKZ86jm1yennFd21C36NVUdsojum6TvX7feq6UQLLgWGQF9t+v5M3rZqT1HVNXRa0TUNT17iOsAfOpzNtN3C9ZvRtS3q9Lh2Fpq4Z+p7L6ShbFE2j7zuiOGa1SkQwqcHpeMIwLV5fXrmcLzy+ecSyTNJrStd2vLy8CpVYfaKFcSyOg2uKoRucT2c8V4Z2fdczI4Nf2zTZ7jY8Pb0w1CWuJdfBIsvR5plaTbMlAJTSdT2dyrE/fXyWE5uiG0VRqK59OcfnV+qyUlAWyUB0/YDh+pQDbLZb9g/3mLbYeTVNl6tn19P3vXgWGxGEZHmpNi1nLpcLx+MF27Z5fn6lLCrOp4sU4lqh60QrmSUYjks3zrhhSPL2UwG0KAyaaUimP4wiDN0gS1Ou14z0mmJbFpXSnUdRQJ5KC3MYB9GVKyiIhsZqs8EyTcZx4Cd/9Ceyxmsa5RyYcH2Puix4+dmf4TlyEou3W1abNfM0UhUFSZwQJwnTMDAUGelZXquGZTMI9v57n9xv/b/wANA07ud53nzXN/2NACTWGnnIWYbs9vthWLLVmvYt8FM3dEVk+XZV6Ciu+o0fOIzjwgk0FLJrGEdsSxDTt3Viq6Kut1+a59j0XaNAolJCQZ0WdGX4neeZpm2Jk0jd+WuiJOH15ZXtdi3sPUVk1XQd27ZZrRKulyszGk0tKupZ02n7nqbrMCwb13FlJtA07LZrAs/BMHSFcg4Z1AzAMEwM0yDPc4IwlKRXUdK0jTyUimr5GQeBCDRNHZIo4v6wRZtG2rqmrCraphGv/SSK9WSVKFaCrFeHccawbGzXVf7Ahr5tMbQZ33MZp4kyz3Fsm9PLC+n1ShxHtF1H07ZiXZ4mpU5X/Pt5ZrNds9msCcOQh8d76baPI44jR9Y4CuRTX9PxwwDTEJ79rFwAM/DN1+8V41EnjmNc11Hchg2jag2eXk/qYVQQBPLvvNGfDcfh89/4dQzXJdluCaJIYCWGQV6UdIPAYdp+WFbO+k0w4thYlsw40quUmJqm5XoRQMgwijG6qhueXs/82Z99hb9/wHv4HKyAqsjJj3L3butKZiWhDBlt2ybwXTy1FpzGkTAK8f2A61XcBOn1uszMbowFLwywHIdJPqkV10AekG3bUhby5/TFlevrK5pp4azW+FFEslqx223lSqFYDdM00rUthmWhmyb7xwc05njouse/8AD4eEw/mcH/bvx/Fp3z7aita9Aort0t938LA93kDYYugzpBh80LPGSapENwA2fcqEGC4zYUKkzWiHXTkqyS5X8zVJho6Du0eRabjHIBtuOM7fnKFSj+wa6XApDn+UKz0XU16Bo47LY4jk2oYrld2/LyckTTdKqqoh9k5+sHAYZp03WD+jTrSRQGTEi8UhcdJjg8PrDdH6iqEsPQef74rJz0CZ5j01RyB63qRj7F1KB16AdBf7XdAqooyhLHdVgrPv+ggB5xHHO9pqDpgpwahfRrKu9ePwisRFc11hv/sGlbojgkDAOyTKCXV+VBsBU74dbVEGKREIJXq4QZmUPEUSQbjr7DdWyCIKQaZsLdAd0WbmDTiIJ7GsW+YyszT1kWJElEEASqfyH1bCn4SN01XiWYlkXdinLbMHSaouDjF1/Qty1f//wLpkHWiddrimlZDOPMMEgP5OnjE606ER7u9sSrFUEYcHe/x7BMHNel67qFKHwjRNVVzeVy5fWcguliuAkz8vM9Pz9zPZ85nc4SzbXsxdTk+b46+j/hOO4vFOXkveP7Irm1VY5lvdsy9j2Hw2ExMYWR5BnaruP56ZmmLHEch93DI4cf/jqTG2Gttgxoiwq9KkvJ0pimBIJMkyCSh4ljmZi67rum9v2/8ABwLeO3v2sD8ObXk9LNreKrLes/TbuFTIyltivxR2nwSVGIZTc/zeA61hLbvBGFakWTcR2HoqzU6V/eFKZhKC23eAPbTljuhmWRJDFJFDLPcNiuaLqe/W5D6Luk15QsveK4jhoeVUSxDKZMS+qWjmMvMeS6KtGVwUfXBGueFyWrJML3XTRd1pRlWcrKsqoJwoBhmgXppOusVjGr9WaZ6I835LPrEq8SWYspSq9l23i+v6jRdPX9yQNROQ4skyAIaPtBxCNxqGg1MgX3PB/f9xZvHcoMLKKVSRTe88w4jJR5gWMKCt33XLbr1bLXNX4huScrM/EGDoMQltM0I1nFFEVJWcjw8VpUuLFIQr9+/0zbdrx790jbDeL66zse3z6qY/ogrbcsY5wmzuezCDEUDKapK2EojCPZNeX0cpSiVJ5SXU6U5zP6NHJ8fqUsSi7XFC8IyKsGdJ04CrEUZj6IIoIo4t33PsOPE7EUaaKJ77tOzQOkV3DTyvu+T1tXvLz/IE1BS+Syl/OZPEuZ1Pqw7aTQVZUVZVmx2ayZZ6lk34g+YZIwoXO9XrhcLtR5oZgPvVw9dXEvuL6v5DewXq2FADyNrLcCrnE3B+5+9FuULZRlzevzC2maiS3ZEtBMXZZs1INF13WqqgbdwHGcX/sLD4C0bL//neGf6li/SD2XJ5EhFh2FXL65ACe1lwcEFWUaqA7RUsE0DF2ZWCU4o+nCCrAtOfa5rk3bSasqy4pvU0/jyHazxnE9LEf49N0w0o8jgSv58aZpqZTDvchybMfFskz1ImsEYqKcd5Yt4sk8ywg8R+UQGslamwZxFDF2DdfLFc/3CQIRVNqeavo1LadMGoR9XVPk8sk6quNZnCQid1C/qGmaRRCpieRkGEeeXs8KnKkvHmTLMqVOHYYYuo4fhgSRtPWqpl/oNlEYgOoqGDrC/XsVxn+nJvGe62Aa+oKnahrZGlimyXqVSL1aRagtSzh9bTdQqwRi2zRMfUeVp8uATzdNoiTmchGmYdcPdF0nrIO8lLWUZXG+ZJSldCLa2x05Thinmc1mSxQJ4LTvO/K8lMJQXctqcxpwXIeiqLimGXVVyYNzlLBSEkf89E9/hqtec0VZ8cm7R7EMhSGjblIoPXpVlPhhwHa/4/7xjtP5StPKurNR+YDVZk3X9Xz5h/8XX/zh/8HT//svJLF3SemHiXi9EghMVdLWFafzVcE8JAD3izj71d09m/t7+V0qQWxTVZimQRCGXC8XXM+TD0XTxPV8/MDD931m3aRrW56++Yb645cY3gpn8yBNwLLC8fzFk+j5PvPQYxgmmqXSspqszD3X+eGfewD8/t/59xin6de+K/v/doSfZznem6auqDnGYt4xTMXuV5190zBlGKF8brZa482qLzAMIxMQBL4MWFQt07EtirIiDHzmecK15U3a94KPHkaZ8geey6SIM9Mw0PcSGbUtof7eYsS3jYV0D+S/ZVEyKqLQbULt+R5lVbFaJVK/rFuZEyhKjOik7OW4XpcVjh8ItssTvl7dNLz/5r0Yfg2BPIahyDeqUnTbl8tFTkrKNahp+kJ+WcUCx2jaRslV5euumxaYuT9sBfPVNJRluRhi5kkU6IZhcHfYYZgCDbntzaVUpREEvtCDTJMyL6jrWjIW6n4nbTh5OE7TxHqzZhyHhdXoOI6K1Ip92VTew+PpQpGlOEFIWbdE6823qngVwXUcC9ux1R5eDYdhWWNGYcSMwF7Pl4uYfqqaIi/kWjJOzJqBbgjl2LIt3n3ylrppOL4eOZ9OVFVFmmZst1uYIYxjbMPANeVr+d5v/Aa7d++krWdILNlS9GQ/kNLXm7stNAU//uf/Oz/7g/+TsSlxLJ0oDMQj4bmK2ecIXblteX090Ta1RIynia+++obXDx9hGvnN3/lttvsdjbITX84X6VnkhWjBywodeHl6Jr1mbA8HbMeiyDPOpxMvX3/F6Y//BeU3P8FPVsyGqQS8FlVZ0SuWxXwboCdrtFHIz9M4/eB/+m/+qbY8AL78+oM7TfOb70QAVpHY20lgUvDP2/F8CQeqhGDX9XIMGwRaIEctVPIKlSibFtPvNE6yDlOmn1lNHW1LJCDiDZBthqdEnF0/0HS9zBFmiSFP00TddJR1w3azln82z9zd76X9N0mywnVdxkEEInkmk1rbtgXSqeQhDw/3aBqSvlOT91jxA6+Xq0SV81w65kpmaqivQU4ZNVEU0g8jX3/1nn4Qn8D1cqFXdKAiL1UyciYMfNar1bck5UlISNvNitBz6EfoNOEq+q7NNAyEYai2AylN04AuvYvT6cxqFfPu3Vt8T4i8pqnw3t1AUZa4rkM/jlRVTV7kgi0fBoIwoKqEOnQ9S5JSXIAyr/E90arL9ywhJtdxKK9Sgjnst0RxRHa98vJ65P7xEdd15VTXD9iWLQy8uhF68zBQ1zWO49B2Ha4ttfG+7zEsC9OysW15aOzv7giSGEwTy3FZbSTkdX/YYVkiPJUH/8jQtZyfn+X3zIzjefhhwPVyZZhmCNd88oPvUxSVRM/9gMslJU5idusYU4N1YBO58kmMcjkEgaeO/aVITeaZ/WGPpkEQRqzWKzbbNa+nC9fLFW2amFUGwbYsqqri+eVV8S7kJNx3nawxq1p07KZBXZS8Hk84ts2f/vhPef8v/4Drz39MWZRs9gcBtPgeruvir1YC2AXi3Y5J00VVN47opvG93/vtz73lAXDJKxc4/CobgNv67MZZ13WNQTn3LFUD1jR5w97IIbe1oGnqNK3Qbm1LxB+jIgpXdcM0TnTKM9+qT6Hb9eHmCrAti7Yf8D0JBuka0sNW97ppmsjKWoARfY9tGhyPJ3yVMux6iaNKJNihbVrCOKKu6gVTZugG8zhSFIWQZotSdq39QN93VFWFYRocDluRUF7leGvpMkQb2mY5ahd5wQ9++DlF3UiFWpNPvPuHOza7DbMasBmGvgyg+n5A0zXiJKKsKq6XlChw8VxbYco91msRf2hIoMlTDMO6LDmfr9iWRaPgKTfZ6O3FOipfX55lRGGwdDqcm957kip3EIZYtr3k1q+Xq7zo61qi0UO/6NNWkUfkWrx+9SVdkdGUBV3b8MPvf0rgWgobJsNe23HY7iThOE/y4LVti8D3GIaeYZTXgON6RHGMbdtsNwnJKkG3bJp+wgsCdg93lArxniQRjiPXxWmeSdZrQl+SkE2Rc80rdNdHM0xMJizb5d3f+rd5++u/TbxKMHSduqpkw9E29G2N5zl8+r3PZG1n2sv8axwnyqpetlq28jeEUcTj48NSVrMtA90U90WZ5wI1NXSaWrY54zDy+OZxqVg7js1+vyUI5ENj6Foc5bgYJzEjZdeU4vhKHEgp6nw8gaJh68oWPLk+L1/8HMOyGPsOjXmbhMIZ0wHu12Eyzb8cA+AW/VVy3mUGcHsa2Kax5KAH9eQ1FRj0JgG9ZfvH8YYzntT1wFg+/TRm1YAC33MoChmk9cOI6wgJ+CYSLSs50vqeK7+4tlNYcKlP2rpsE+Z5YlYrxapquLu/o8hLlSeQH7ptW7RNA/NMnl7VKUGoRUEQyIzBttDGgaKsOJ9TqS8rskze9HRq0FbVDY6Sc3Zdz6zp2K5LVdV8+uk7+n6gqSvCOMF2PfquZ7Ne0fXyfT8/PTNNE+c0Z9CFRjuME1nVoOsGlg7Z+UxeVAzoREm8JMssx1U0ZUgv0n2XXEAvVwTbkWOuLScny7aEinub2bjCVgRomobVes3L8zNxEjOOgiYLopi0qDiertKDQPnddZNLXrPdbbEZqC4nzqezrLXqSrTsuk7Z9oyayepwYNQtDg8PxHHE5XIR6hMsxbIiL+ThYJqsViu6QUjQl5dnnj9+JN7tSdYbvvj6I7br0rVi8vUcWclZnsdkOZhzT3Z8xTQt7t48iHhGM4lXCdXlyNjVOL7HrBsYlk1VNTTtwLtPPyFZyyZCNy1sU18gtpfLhXme2GzWRHEsyjtN5+7xga7vSdOULCs47Pccdhvmeebrr7/heDwunQ1N1xln4UqYSnLT9T3zONJrBo9/+9/BjqRuHIUhri0nSkOHuW8o01TwZnlOVZX03UCnW1jxmsn08V2bvu2Y0Okn3AktWR4AL5fybp5n+7tM/2+Dv1szT6i8cqeaZ6Rs8QuykL4fVNhHW6bgMliTmGnbDXR9r+6PrdSA1fBwHOVenhXlki/QFEBkRtYfeVnLNsOx1IpRXos3LDhK6lHkOZYhYZuh76V0U9f0XYttO2imSVmUWIZM3X3PpWulCDKqa4kXyODNMC36YaCualzboq5q9ruNoL49F9fzsR2bw2GP67qiQDcMsmvKKol4eLgnWSWKLyf7fHERGjx9fGZQ++M4EmFkr34+hmlSdQO1wojV6QV9HuVTRHH5yrLANOQFKu76mwdPuu591ykOo8SLu16oOW3fEwYBcSSlnt1uS6WCS34QkCQxd3dyWHx5fiEIApLVimkYZJ+t0N+O5+O5NtvdFjeM+OT7PyBcraiqhizL1MnRIFkn+L6HbujcPRxwXQfXdRl6yTbs91v8IMBRUM1ZnTCaRhh449CzXiW8PL+QF9Lusy1L1l6Ow2q9Iggj4t2e9dvvMekWu8MBU4fyeuV+v4ZppK9yyi/+iK//+I/48mdfYngeX3/9nizPCQNf6rxKuholCY5tEccxnh8wqavZzY8QhIFC4ctpLs8ymrbhsN/i2pZ4/pJEILmWxbt3b+VrVoTpIAzI8pyyahiGkb6p0aaOxzf3bO7uCMKAVRzh+j5vPvtsKdTVtfgBx2Egu14kCu26GPOIFyVE9/e4QYDnu5ahyYlfBximaaNpmvUrJQBVt1/1glUBSN78dSPK7lv44xcfCKZq6w1qUIe6QgzDiK7piwPe0A3Ze6tAxY0dYBiGWgnK35tqDXO7adyUYqay8GizyBWSJKaqa1arRGwtZbW07FzX4ZN3bxYPoazNpMp6CxM1TYvjunz9zUc83+Pz730isNNZ2mNh4BPHIToIVqyoJMRR1+hKV3b38EBVyrVhtV6zWieUWSYbk3kiikOauiaOI4Z+IIojrqeTkIscmzgK6MeJYYbtdk3fdQLhUPqx1Waj7MoT++2GruspipLLNeOaphxP/x9pb9JzS5ad572xd+zom9N87W0yb1ZmkRTEEg1DhA1oahiwf4LhuQD7J2hi+C8YEGzAY88MwzNNbMMTCbAgwBSKRbKqWJk3b/N1p4s+Yu+IHR6sFXHTM2aJQDGzqrIyb3NOxN5rve/znAi/FkeMpBbIsxR2tri/u8E4jWv5p+06KI4HZ1lKgZmBEo5X13tYS9h031dEGjqecboUyLKUeY8K1/d3yK+u8Obbb+GFIYwZkWUZTi/P+P73f8Dx+QXnwxnPj88oixJtQ6DWpmnQNJSCdF1Jm5SmwaUoobXBD9//SKEdo/Hbv/4bfHz/EX/6y29oRazZ28DYr0s3Ib+5RXJ1g84QJ/L8+ITnhwcUxyNODw8YqhKb2MdoNIa6guuA5kaeoqiudNG37QqJ0Vqz0putTllGLzCWnU5ao6prRFGEIAjQ9qRSc+YZcRTi7v6ezMyGXjT0NqXY/OF45gG1RVNccPn9bzBzRDlMM6T7K9y+eb3OEoaeTpvLic1OEzCNEBNZivwwQLTZozkfYdpWztN4tz4ApIPtF7jHP7wItHz5li/aEv5Z7jzgFcgC/1yKQa4raVPAkg49DERgcWlI2Pc9r4aWOzgN9QCgHwbqFjgOD5DohKCNga/ctcxjeLYgeK0o+L5iJ7smrKTjUE3SdQn/rTWl/RgnHicJfE+hbRse/nXrcK5o6W1bNy3sOCLlN2aSJHClJDFI32K329DfP4mRZBnMOKG4LKvDiPIHKU35z8cj4tBHWxO3r20a1pBTxLdpe95J9+iKC/qqwNB3MJMFHMmEWUOFnc0G0gGEUqtrweFsRhKTujoMQ+R5iqZpUJYVrCVS0n6/o+FbEODl5YCuI9DoPM+omwbHlwOUclFXNfLNBo6QMKPF/ppqzNdXO9SXM6SUGC2gLbC5vcXu7jW++uYdYCeyD80WeRLh8PyC4/MTPr7/kVRkvSb1+UgRWEcIYAbKssK5KCBAYTDXlVDKRde2+OrVNYzWxOY3A/c/AG1G/PjhM1RI4lJ6mFsMVYVxJNFrFHhQkmw6ixeyKysIUOFooUO7HFyiJKnGoDWKy5kyHyl1S4a+p47KRC4IWmlTQId042eczheMcBBvt8h2e6RXtKEBgCAM0DY1f78sss0WcRxCVxSf/ptf/zXORYW7X/0lonyDpizpJOES1CaIIuSbLWL+HJYPn3F8/z3s0MM2BQbOPQyD/nIFsHZ+83O++AtwY+b7v50p4TQvRmCH1oJSOIwEpy+vGSfMdkbgEQmGmP20BlyuDKvUY5r4uG8QBgFG3p/7jOheZgBght9y+phnIEkSLhfRP5umvss2goIsXdsS8EMpOLNFEoWQkkSfV9d7umN7FMhoWgKTjGahBgvc3d2gKkv89nffw1UKbd0gz1NUZYEkCtH1PfpugPJout02LYrzBXVVYdAGw9DD53lAcb7gzdvXtP7p6D9/983XJL9oWhzPZyRxiGkcqVqrNWPJZ5zPBXyf9OBxGEDrgVBdXYeyqmANfZGl66723yAM1gejK2k923Ydbm+uYYxeKUR2We1JF5o3HUtOwuN9cxxHZBzmOvO0llMEmqbF8XBA27TQTYXf/fVfcwzXx2QnWP7gjkav4SWfXYYjD20H/udOdqbiTBgjCMmqs9vm2F9dcQ14gJKkEet7vQ6i6aGoMTQNqqrF0+MzRq5aK9dFnGb0+9c06NoOZpyw222xu71B31Nq0WV018vhjMnalWPhugpRFKOuSmSMRacHbIzz8YSJk4l5lmIYhjV0ZWe7FubCLIUjJLa7LfEQHbJb7XdbhGGI/X4HIV3ESYKqqnC6lKiqCl6coTyXaBqqyNPvR4wo32B/c40gTSHiBPM4oi3OKA4HiNnCC5lEZKc36wNgBvL/kBagw4MAx6Hor7VL8AEQDv375SrgeZQD7/VIwA8h1mjnbO1KC55WXfZIf2/pwlUcCea2n8+9+uWJS+rrjjPWlEmgYyh9+GfeL48jtenm2XJ81aDtekhBa5mqLJkMC9RthyRL+WpCUedPnx8RRyFu724hHCDNKA0YR1TxtTMhwrUeAIY9ulKgPJ9Yo53AgYOmquFYSrdpVpFJZtXbacLdq3t4gY/NZoMw8BElEZRwsNluEEQh8u0G+/0Wox6QRCEcTDB9D1eAlWEuzufiC49QKQghVmHJEhEeJwvlh8Ri8DxKKPbDakBWSnLuwa7dj2EYEEVM1uXOvANADz3meSYyjutCKQ/OaNBXFXZpiOJ0or257yPllOY4zRjMhKv7V7i9v4eULtVxfR9eEODm/o66DXCwv7kGhISAheT23PJlxkRbkImzBpJx71e7DQ6fPyDwJc+IRhRVDT8MsL++ojlLlmGaLI6HE/I8Q11WdI2Eg0mTdXc2GjVr0EZDZGrP85Dl5JOYQT0Wyot0MMMAYzQ8zwXg4MPnR5RlgaqsEPo+2qJAdXjBUFX4+OEjJqPRVPW6RajrGkPfIWQSldYamyyB1QPKH36DXR5is91Sn6MbsLu9oa2TNgijCHowgOtie32DKN9idsgwHCQxAk99mQGYacp/7gDQzvOqtLb8tF1knYMZ1wjpjJmfOHSUN4ZoKKQMc9Yrw6DJEe9y6mzFinEngAChNGgMggB120EwU90PfGafUwiFZIsR+n5Y//ddSx3zmnXbS8hIuu7aadBaI05jTBMNEpQr+foxQ0jJsAo6TpdFidBTUMJB6BPpWHCo6en5SF0Dh645mx0ZbdIshSMVZh7a1Lw7DziKPE4EtQhY13U6ntC1HRVJAh/KAcaJJKv7/X6NUruKPiye56EfBrQdOQAjRq3P1hLLTzi4FAWikDYZ4HKMwyKXpiH1mJSS7Er8kG3bDsMwrKst6icQV9AYTXxFpRBFIV09hEBZlZQItdQ96JoW82gQ+B7SNIFwXQilmCvgoO87VOcTXb3iEEJIpkpZaiXOM7EXgwB102DQBnXbom5afPfLbxGGPpSSSLIc+dUVirKCGXpkKZWtMl/g8be/IWkIgIRV7lob9B0RkpaV7vV+A9132G5y7HcbdINh6Qm9HOw8k0J9v8Obt68hHCo6lQW9OCzzLxWfdH0/wP3dDWbOycxwEG82gBA4PD2jLi6YpglVVaOqSpyPR0KdTxP6fkB2e4f09haB7+Ptm9eYJ4PPf/c3MMNAZiPPR1E18OMYgoeAGA3i0IMbp8hevca57ohTOGjURQVXqQgA5P/zf/wr8fn59F+Z0f6TnycDcdYIr+Wp/zwDiucAvu+tlACHLJuFAAAgAElEQVThiLUFOE0T+/do9TRbemrS/Z3eInESo+t65HmKumnh+bQX1sbQnbgfKFE4GrgehUK6poPneTBaw2XAx/QTuQfmGVESY+gHRFHIptoBYUQApKVxqFxi5QWcCZj44SUccMLRwvIQch4JgJHkOYIwQpLE+P79R3jKxe76GpfTGY4DBJ5icrHCaGfcXG3x8f2PlEsI6PRzPl1Yqzbh+vYW59OZsw4OgiCkIeY0smrbgdEDsRECQkVjnnnwGKKqauLZj2QiLssKrqK3UN/1cFzFDbuO2nUs8RSgB8LpeF6RYw4z8uaZMOQbjgiTBJbufXT6olNOU9cwo4GrPMRRRHbdA1VsndlCDwP6vkPb9mi7AVEcUWZ+mhCFAYIgoETmSJ2Hpq4Z8075hYfPD7i+ukJxuWAY9Goj8l0SjpjZweuv31KUualRFiWyPEeepTg8PUI4MwegPJxOdPKSUuLl5QiAXi6hv5CE5tUEvcBq9NARbWm2SNKE51QWj0/PeP36Hh5nD6SkF5nWxDTQjGa3XMKSQkLSeoqG29PEoSW63voenX6lFMiuyJEYRtTtmC1RkuuKtlVt08CVktqHaU4vLNBg8vj5MyY9wEszTDPQ1A1cAdgZf/hX//v/9r9K13XF8VL/15Od/+xnw0D5zr0cy4UjYCYLV7nr4MldXHtRiKbtEEchwA+MpVQzmnGdItPAkKLDShFEI+AiymAoTWjGkfBc04wwDNgabOH5JKLc5jmapoZSHqbRkMwiIKvtOFL5ZAkKCWYOukqtpqE8z2DtxLZc0oe3dYM0jdG1lOe/ub3B6XRZV2VxFOBSVhg6AkgIKaHHCXrQcFjxbe2MwYxIowDzNKE3I3Y3t2jqGqdzgXyTcWuSmo9plhHVZxyRJhH57PgY3rXtWiWNoojWmuMIYGZCjUXf9ySbFAK3d3cIwxCfHp4BS6valhHayvcwzw7i0Fvv3mT7nekhAAfzZLHbb7nRZ+CqL10C13WJmiQkgsCnPbilXIDn0lyFdv8OzNCvWKsk3yDLM0RRCJdBrfM8I4pDSIdeBIKHYYFPUV/wxieLQ+x2WxLDuBKxT8PabnKgRwtnGuE6oGJSVSNNIhg9QBuLJM8xTROenl7w6dMDwiBAGoeY4SDwPXRNhXmaKEoLoKobDp9NqOsGnucSQ9IYTMagHyigozyFpiE12PPjE9Gh+YHtui7ORcXJVR++5/Jpy8V2t4MDksV+fnhClsQoyop/DQEXM2ZDD0Q7W5RFQQPR8wWbLMN2myPwqf2Yf/eP4WKC7Rq4noe+qnA+HEl73jXY5ilGrWGm6fNo8b+IttcOgOznXgGW/L/DR/hpmuEpCgF5Lk2k+16vK0KHZZqYySbsuhKTJVGHp1wYPfKRn778wzCwAcjjppVGHNCXzHUl9KAR+sScW4aCUkqEEWGnjRnXdlerRwi1zBBcCJB00pnJDT+OI7cJNcTiL5QSXddRvpqvOT1n70dLjsFxojesGclv0LUd1XlDchP6ykXi02aiLmuMWiNWDvRAJpsw8Og+GAarncgMGqfzBWESo64qZEkEV9C8wlMKbdeh6zv0WqPlKHPPQ7dpmlA3HQY2+ngMyLx6/RYqoC9M1Rm0veaZAxlwdNehbyo8Pr2QIdlTSOMIo9F8lSD3X+D7hLHyPQyDQccwEN/31y942xJodBx6jJo0a2maYLvNV8qv4n2+bmscHx/w/PkBmleJQ9eS+WcmR6Lve7Czg+PpAk+5qxcvjGiYNVpKyI2QCDKiHV0OB1hj1kRk5NO9eHkQVZcCQ9siTSIEPsW9VRAgTWICrgoFN4jR9GRvqpsOcb4BXIXr+3vUdYs0z/H8/EJXYUdgHA18z1vLbJor8dJVCOIYs+MgiahhSBsFj3yK84zHh0c0xuLm/p5IylkG5fsYzIggoBPq+XBAcTqhOJ4gZqJeRRFRpPPtDl4YIc5SmOJAhu4gAIREnMRwhQMxDnBGA2cmbkQYBF4Wh46YCeHl/wdMAFfajx4n+B7n8wOP0nWMCV8cfw7bg+1MIBBtRjKzYIZgeMdaNnIAYwzloFnMOQwDAt+HNvTG0cOw3unrksg+h5cD9wkIKuJ5HsKQ6pVN2yPN85/gqCYu5tDbzpUu2qZFVZT8NqZGoMOdeMHVWCmJCNO1Lc6nMy5FhTxN4Pn0pujaDtKhgEiSJrhcLphnyzMHCi8FQQDXFdB9j9vbaxoeMYR0NPQ2T5OIWQU0qIyjiGK3HGTSelh7+J7vw1X0phz4Td21LSY7I81SwHUxzQTz9Dy1riEJtELxYD0M0Mag6zpiCfCPd7vdso2ZjrD76ys6uXE4xpVivQpME03SF4iL7ylEDN0c9EA1bqXoSDxNwLwkRImT31Ql2qaGMRSumfi6OPQa1s7Y394i5ZUqAIon8zHajgZ5GsMMdNWjDYjC+XzBdpMT3VkP62dMeR7Hqy/k4et7VBVFvcOQfm6Tpc/vbrtBnmfEnJxo9dt1PWZrV65EHEWMefPQdsMadYcjSMkWRaibFnVVYrYzdUOMgScdtDXJVlWUYLPbYb/fkY6NeRvLas/OQBTHtLUZR2g/wiRdlMcjxr6DYyeIgEjUmnMsURRDMSWJVHpjEoe+I0Pfcwcz/jeTtXc/NwcgeAiwtMasnREGRAFe2IB0KuAvF1dbx3FCyAMq+vKSt48ovSMPn3zMdl5tqG3XYb8h1l7gewQV4ZWVEIIR0z3jpyUThV36Ajl0Bfjw8QGuHyBLY4rqNi3dgYMA1o6IwhBdSzSetm0RhiHiNEF5KYiMA1pFObMlBqG1eHk5Er9PuRjHEUkcoiorDH2P66sdmWQ55iwcsglNfLzUHAAxmr6wYeCjKksYVj2n/PS2bL8BA0/Ad3OlSGyy3VAPgH4dQU09TTCQ2U4YZwqYjMOA8nJGloTwXAnFga0wDNegFiG7CWbSDZr4AFG4IsOEENhsN6QYYx4AQTRpQCelgOdRI27iXMIS3qrrBn3XrT/v5a+X0oVwBNqW8gguJyxpFUvtNt8na5MKI0RpiqHhivBAq7qW9e56INz5uJJ8XezvbhFHAZWr9lvMcKgEdCkwAzhfSshF88YT4eeXA5IopBmU+gI3LS4FZfJ9H1EYws6UDj2fT4BDzUrMMzyuWIORn0YPaJp6nZ1YO8FoOiVcigLF5QIpBF4OZ2xfvUGeJVDCwaePnxAEHpIkJXLwSHHfGQ7evvua5lhZhrqocH5+hJzpWqwHjVlKPPzwA3xedxtDDwOjB3i+f2p7/T8JPta7f8zLf+J1H2asluBl/y6EgM9XArXaeheFOIE84yik4/tiCGLP38DlHGozEWjDWot5ttjmGfQ4rRjocZzQMf0nCOggk21y+lIxSEM4Dj58eoRUHva7LYbRYrPJIaQkN3vbrs2/GYBm8g0lFgWSNKEhoOdBuArKlTidL0izBErSHblrGijhIIt8OCNJT5TycClqnI4X2qNfLujaFlEcoW1bCMfB+XhkqrEgvRdP/IMgQJom8IOAWIugASFJUxTJUqYRlqu/Qsi1iDOOE6RyAcdB4CvU5xN+/MPfY2hrXO9yatv1PfHr2bY02y/CFtfzoBlPLYRAcbmgLEt4vr++aU88tHRdl0UdtCkZBo3D4UBvNY4gL/r1eZ7hBT60NusdVwqJrqM+f9f10MYgjqP1NHN3d4v7+zv6Mc4zMBq8fPqEUQ+YJiqB2Rno2g6+KzHpAY6doIceSkm4ykWSpdjttgjCAA7nRPbXXxBiLQ8ZiVsQoGGxa9fUCJSEHQ2qskTbdjg80d1+ReEz5j5lKYh0XZRlRb7DwKcHPW9QdtstwiDAq/s7+EG4kq80d14u5ws2+x22V3uKo7ukO6vZMzBNEw6HAxzHwdV+jx/+8D2yJEL58BnCkhFKCIGnj58Iuc+mLM/3MQyUZYFD3MWqKPDTINAfe/rn3f28oqCXFqAUzioIXVaCWhu28ghyt/M6aZ7podF1Hf3iCgdaL3coSZVdDocMmhReTdPQXpPv9paHfb7vYzIGQRgiSWJoTYz5pm6glEKWkMrbGPqAjzyxbbuefqOUItxXktCqjHYddNcfBszTiMnQ8a8sStze38LzFR9f6S2c73eIohBSOui1wc39HW5fvcL+mow+59OFcNpaww8CNHVN939mIeSbzVqosnZaTctKeSsbX/k+HCFX2jIch4kwVMLCPKPXI/Q0YzQD4sDD+XiE53t49foeUUwbEc1DquVq8ubtW9zf31Os1NIKMUkp1ksnF6r7OiD+QRhShbjpBniuQBwGUMqD8gJACHIxCAp05XmG+9sbXF2RF0Bz+3OenfWBdnd3h67vcX1zjZDXu3FMgSMhSb55c7PnuY3kFSRpzRx2Q1Q1OR9IGkpm4rbruEZuofWAD+8/wlMS3aDx7us3cKWDwFNwVAA/pBWhH8Z8BXJwPJzw/vv3CIKAId4OOxFraK1RlSVOhyPKS0FKOmsR+h5nEUhamyQJwihchbMAMJgJ2w1tKcIoRHZ1g+pSou86olBvNzRf6jqUZUVraSGxvb1BFIX48OEjMI2QAITrY7Pbwo8iRLf3eHk5YBYCrqfQd5SstdMIM1rMcMJ5nqVMwkC2vf7n8zz/rDqw4B0/QJHMcZygFOXuw8Dj5B8NrhyHIrw0VaVYrmI7D61EBPECR4JKzsxIpxLMQGYUz6NfdO4OLCgvIRx6aDgOaZJHQjyrBZelCRtWVg2EkPCUQuBTHfXx8Rk+/7kjBNqOdE2uWq4x9idEHBd92yH0FewMeK5AXdVkMnKoIiy4qONKiTCkIyKYIxgGNLxqy5LuvI7gbcm0/nwoy+0giiN4iuAcCyfBWiLhNi0ddZ15Yr9AjLpp1tOBKyXzE4GibqGUi1HT3ISO9OQXvNrvUDctddI9Ov43bYc8yxDHdDLzPY+qqss9FoDne1SHdRwIKXgDoWEmiyT0KdPuOPCDENJ1kTER2dppfVubcWJ+PXv1mHVojEGWZ/j88EQ7f6UoEerSCjjNUlzdXCPie/Z2t0HbdkiiEIYx5B7r5x3HQdu0lFAdR/hhiCDw0TQt5wqA4+mMy6XEL779Bsqx2L3+Cvk3v8Trr97Ac6hWHfgePj4+o2paeAzcUK4LozVh2YSDKI5hjEES0eA0CAI4joPz+cwvo4j+fJpgJ0KgWzshzXO8+uYd5GzRti2yfIPN/T3y/RYP3/+BqNAsD6XVeAdHCGy3W4RxhPTdP8JlVKheHnF9s0c3aGzv7hDnOQFymhr7/Q7K8+HyCyzbbTF5IZqqusAR/1L8sbM/wRBQVwo29BAZWAqBrtfoeo0sDlG3LcLAW4NALhN8wRyBpYNAeWYXbdfC9xj6wW+dBdg5jdSaA/MBrZ0RhBEgBJUhAh/Koy9o1w/UfrMz2rbD9fUedVmhqGrMliK0iuEiM1NxdrsNSR14Rdi1HeaZEoldN8DoAYMe2SQkIZWCBbDf7/Anv/wWx+OZEONCkpyirtFzrnscDZ4fH+EqF/urKyq9tB3JI3idOjKPru8HtF3PV5yRfu0YeuoqCcH/fFqJuYxbIz4jOCjlKhehEpgnus4oHlou16kffvgRWZogjqP1nyOlxPF4ZEGHgef5eP3mzRqYkS7l7j1FuHTXJcpS3/dQrouqHXApa1q3WpKZppsMKojQa3p4NW2HQWua8wQ+GaVn8FyAwBpBEECbkRwOPL134FBzUg/4/PEzIeWUwiwk0jyDI12c2VhEBSF6uGitKX7dD4TqLgoIh3iOL4cTbvYbSFjUg4V38xY3X32H7Ve/wBQkaLqeVsxsC5rhoKornIuSSUMNbSKmCfubG+S7HfX0p4n2/Ya8E8WloEzJSEbnIIqQJAny7RZeEMARAjuGdviORfHhR4TKpcH3PLNwZkKWpUxwinF8fsHDx0948/VXuP36azw+veDum3dwkh3m7ArH998j9hVmo/Hy8MhbEZqZBWkGFcWD4zhWJmEgu0H/c/sPPAEsk3w6ttP9evlyB76CGRkGoiR9eTi+2/XDOuRbwhtKCprmO8tq0TLm6YueWUqBLCEzyqIUW8wty9wg9D1yAfCxcokbx1GEDx8fkHG7TnkK4zCgbxv4PgEdjDY0XXXpSyuE/AnzgN4kfdchjiKeQ8xoW9KBdz2JS1zlYrvJcL6UCKMYRVFAgmi0l9MZcRIhCnxkWbLmzle1uaQvgB8EJHngt61yKRUphYOSKbfWWsTcGvN9hU2e43A8rCzGfjBwmNKreDBpjMF2t0WcZvA5JCQEgVunaUKaJATmGEcatrYdDM9OsizlO20JZwZcz6W9O9/Hm7rBaKjIRR4FH1XbYbvJ1nxIWVR0teJY9jwDb75+ix8/PsIVDg9/Keex3W5xOl8ou8BDTs/zqOXokUVnYldj13Womw5XN9cY9YBWWxwvFe5u9vA4PzJNlrMOCmaaEAUBbm+vST8+jiiLAr7no256XP/yz/HVn/wpLocDHj58ws2779D0BqfnJ3jSwdXVDmbQUEohDAPi7o+GpR4k9jB8FZiYorTdbSkO7XlomwYRb3CWZOWGNW+hT+vYeLPB1HWoiwuceYZyJZRLoBoSqQDnokQQBnj//gPmtoA3VLCjgev52H/7p1C7txBBhu7pPSaj0Tc1+QEnikZLxwE8H6bvn0Yz0hBQCGH/mAnA4gEQ/FYfzAjlihXCubj+tDbrXyNYldQtdxI7r/8aR8vVU4qXmnFaNwdB4LNHkI7YEzPqHTioihJplqzCEaVcbLIUZdVgnonWUlY1tpsc337zFYKABjPWjPB8j7YEXKW0lujGLaPAuq6jJKAUXBmmcIe1lrvwOUYz4unluHoPfU8hCEP4nockJcuPUnQ9IV13QW9/lowq1o6PrOhyOPe9cOYW/JKdKYPguvJLfsF1YeeZfYAx6aU0vU2XNJoZLSAEbnmY5ikPWZrATpbeiELA4StZHEVrcKpqCEFlJypezXaGFA7apsH5fEFZVSiKkgenI1I28paXArAjLscj6rJEUxZkeJosirLC+/efkOcZ+p4IyGEc4/r6Cv0woGnJbvv0csI4jiiKghp0pzN1NHyFiHfjfT/Q9auqofwAHsNXdrsNQs49XF/t4UiJkddfFMqRaKoKUlC+pB8t3v35X8ANUnz63d/g+u03uPvuV/in/9l/gXh3jddv3uDNqztIZ+Z1IK04kzSjaHoU0/XWoZlPPwxomhZVVWHkVeXt7S3imLZPge8h8imk8/T5AYenJ3z44T2K4wm661Ccz+yMSEnyYekUPI4jXr1+jabXK0Ho46cH/PZvf4uXwxldZyDjPczkoBmB3tg1yGbtjDBJcTmdYIozkiRibL8Us7W2+TlBoPURICQHeyzfzyd4rksBBn57jyOtzJSie1wchYymcmGmiagqXPVVLuXQFWfq+7aFytI1cDKYEZso5oQhDQelK2FnssHMDg3rmoYmwsZoBIGPaTS42m3Q1DWu9xs+tVBe23BYJAjoxyV+8jAwWiPPc1rRuArKJ9Lw7DiwEJhNDxkoSM/F8+MT5slCyQhxGNLPX7lwXY+vRg5mR0BIgTAK4QcBBZ94fRcltGlYAKCn8wU9dxuihFBgLicEiZNAQ9M4jvkBShPxoe9hRot2GDFOBA7NNnS1GYceWRoDs0UUJcBsUdbEsbt7/Rq///v38KQDKYDudMbIwNUsIT2awyj2OEm4MNTB9XwMg0aSpnj69Amvbq/Q1iWsIyGUD09KuH6Aw/MzgVxdAZfrvI5PW5WrV6/QlyUlNF2Jl2OBq+s99AQ8nWtq+bU9uRmEhO8r1oj3+PjjRygp8HJ4j6s8g9EaF06Mgr2SgaXY7svzM0adc5mph+uSwKaHRLy5xuXzD2gOz4SgqwuUz58h5glxmqBpGuRphMOlhh467PY7enBby4O1EY61KKsa337zNYwxeHp6xoaJwWFIc4GCoauulDgeDozIo7CcGDWabsRuv0dZlmv/pCxrOE6DOI4w6R5DXWG7yaCUi21+jT/71R797ELl1wCA+vAZnhTo6gH18QQzTtCjRRKn0IcD2rJA6roTr0nl7DjO8B8SBLJcKlkGg2Zk6sw4sRiEbS6TXXYH6/+XLoVNPCXhKo+CCyHvlcMQ40glicUX4Hm03qJsNpVYPN+jMApbiEgxZXA8nJjMEyLJUuSbnDVfFlEcQRuWjkiJ55cD9vsdEVjGEfurHcqiAPhIPU0jSzVdjgz3qOsOVVGuQoqcv1ySDbv0cwn4P3OZ8JNSms3zkOc5bm5vkGw2CMIQEC5cn6bMURzD831UdYMgCNbI8gwK8swcf14kqEaPjE1z0DQ1Ok7mSUFBI8+VePj8yOzDYO24L1eeTx8+IU8jMt3yXGJizoOQ9HsRxhFev3kNIShc5TiCy1gBkizDu29/AUcInjk4sGYJKHmIIvIuGrb5LjLT0RhcTsQWDPjX5Wq/hadcdG2DX/3lX+Kf/rP/FJOdYUeNtq7heT7iJEVVNTgejnh+OVKQiUlHYeDhx4+fcDqdCH5iZ0yQsMJFMxhYCLS9AQT9Po3DAKsbhGmGt9/9En68gfQC+MkWUbZBdTrg8dMDHl4ojdh3PTZ5DuE4hDmXEpfTGWFMpJ7j4cgpxZlt2ZLnWz1RfqYJ2mg0bUskZ/4jHAfb/Y6uO37AlXX1JVAVkBG7KEvs9jskSYKmrjEKheztLxBtb6Gff4ckUtB1CQwdrm5v4SuF3SYlhdn+Hg6AtqHAi1BSzg7Q/OzvPROAls6464q1JSjll8k1hTOW9Z+7BjaWSDG10QSEpJ2nGUneOU0WIbfiaNc6rWrokfHeUgiGMc4rUnxxEiwuwTAMONs/wxUCfdcBzrKj9ZCkKRGOp4my50tjkd0DEyvIi3OBoWux2W7oWDfPuL29hudRNHYcJ1KNcXJRGwPrSDK/CIl+IFxW3w9wAApkGOIUjDPBR9IsJZuRq5BmGSm4Nin6jt7+i3uhaxrCmytFlJy6oisTW3Qo8UUlFEqz9airEn3f04xEuTBmXPfVUgjY0aBramAmUhCx/6m73ncttRLjGMpTdO9m7JnnB7Dc1b+5veIHSIuyKEhJjRltWfKKlGZGE19zCNQyozid6Ko40e/fbpvRHduMiJMIN9c7bLY59tfXuL29JkDGMKDre0RRiLKqmRIlcClKzqC4FM1uiS4sPQ+vv3oLOMQpSOKQrk+TBcYBzw+P8NMd4ru3cIMQrh8iSFLSqGFG13fMhYyglEJR0BAZjgCmEabvUVwueP329ZrdiCN6wBVFgREOzkUN16G7fZZlUIo+f9vNBhHPN7QxKIsS5/OJaup1s87Okiwjq1JAhaBZuHj1J3+GKE0hpx5j+YAff/1XGB6+RxJ4yPMU1199jWy3Q5SkmKQHle2ghwFN3XRPp8KKq00yC+HUP9sEvFwF2Oyz0HvsxIOzwaxsACnpyB34ikGKNIAiWhDd5wetMQPIspR4/IFPe+3JctrwS85gsQ5Zu0A/ZoaF0vpOse/dWrtOk3ebDM0i/eQvCQAMXc8xZUAKSXXOidx7NEgaEUcRAIJzGK1Zj03XlXGy8Dyf8gg/qdGWVUuoabYnvTwdUBQ1tbF4oEdJMcCXDuqKkM3FpeAr0Yw8iTCNEz20AERRtAZiZgAjx3/hCNBsx+fhmbfekQetWQEm4HlqvZs2DTkQ2q6lh6hDJ5bRGGzyHGFIlFnP8xYBPKq6xtAPGLoeu/12PSEopWD6Hj/84T1OpxPFpBWxGSejYe3IVCFFzUPfR5ZlEK7CbruB5woMbQcHwH6b4/DyAiEcRFGAT7//PX7/m78jzHjdYuBVqOLBK5FzrzCxFMT3PHRth/1uS2LXkTZJY9di7DuMQ0+bDAEGjViEvovy+QGOHajcU52hmxLlp79HJC0ZhiBozRlFxIoQglqjUYSyLGH0wPf0CaPRZIOSEtKlgXS63WJztYfnKYQBQUJe3d/i/vYGb96+gevRelX3PZIk4c8c6IrL6DzMC6XKW9fjc99ibit8/M2vcfjwHtXTA9xxwKTpRNwXBXEoyxL102c4xTNHg4OmbofZ/c//2V/Y//fv3p//2BvAsp4SQmKy9ASjL4OAnSysoLe7ZJUUUX74Tc21WoC8AS5HWR2O4ip+U01MZVmm/gEXcXyfJqjki6dNRNu0FMfk1RodCw1bigVFYycqKtkZKMuSWmUT9QLCMAQCi46z4EskmPwCA6qKwhnn05mSaFGEqixJ7nGpAG7CLQ84OwNNN8A6AptdCiUlFVzWVl+HKI5wWSyuDEZpmhbtPK9OBDopEUuuHEcANFsBAAtAayokCUdAug4mdutZRmoRcNWlhxjXqn3fR9cP2G1zCCFwns64vrlGlhE30fMIuKK1gWQIyMRiVrq2UQa/KwoEnksTfNfFPEq69wYK2tDaVLDcI+UHfJxETEDqOCRGNqTdbgtrZzpxJDHq0wumNiAEeJrQlohLW199/RUcV+HTxwc8PD7h3buvKR05WfgcGT4WNbQZkW8DTFrj6mpHHANPIe5HpEmMS1Hi8+9+g9CTePPLb6HrCz797b+HN3bwXcFQVAdl3SFODfkM7EThsX5Yo7p+4FPeRLoIl+IZr2WHfkAcBXgZNPbbDcbJYuwHJGnKzVnAC0LkV3s0RYFsQ7OD8nJBUVbY5Blc30OQJLC8CbPThOFyxGkE0nf/CE8Pj7yVIUag7nuE0YjaGJRFgTzL4DoBXHr4Fv/m1//aiv/uf/gfAaD6o64AjO5asF/CcVbEF0kPXH4ze8z1/4IIc5VLxlk7Y5wmBGG02n+Wh8U4Tri+2qHv+7Xtp41ZwzNLWtBxiENQNe1qx+n4F9yZLQLfAzDzDnxGGEXr0TBJk/XPKUU4cvfcZc4BKcKWqLGdRgh+08+gNV7TtPCU5J873YtDHlT98OMnmlDzaqviibjl9KMeBvrC1xX/PGe0dQ3ddTidL+gGelB5iqrKriu5Qm04Tad5JWphRosoSXIBQcUAACAASURBVFAUlKdvu4EHjUT4qZsGdproStC0dKyMYwRhiOurK04vSrRtgzgMUFcl4pjeeIItQtJ10TUtmrqh9qQQ/MGvEfi07mq6HrOQKOqOmImTxSbPqCjFvr/latd1/boLp533gLu7G8zzTNq1wEccRSsdWUkHfd3geDzjdLqgKiucTidsNjmCKESaxIQbY8R223araGaARLy/QrLZoG56vPv6LYtVO8xdjcP3f4d/93/93/jhr/4tXr7/Hc5Pj/j08ROKqsXtzR77bYam7cnYZEZoM8Fz5RohNxbY7HcIQwKaeBzlFcJBdbmgqWmQF4YBHFAkeTEmT9O0YsmOxxPsPK/RcSkE8s2GnJeuhOP5lAysKdB0/fo14t0VuocfkAQeisNxPREWlzMOLy/Y8P/e9TxACNRtV/73//J/ngV/mYs/5su//HG28zqQIly3ZCQTQUJcKdB1w3qUn2dLe2qWhpKuS7BAxHKFWKwyjzRJUJbVl/YVS0Mbds+5rmSaSgOlvJXaE8cRXRe40+7AIWuwS3Vjh8Wfy1GL0mmaVWZqzQ7UVQWjDaXaBo2+61HXDcw44vByRDdowKGBkpQOkiTBMGgUbOo1msAXUkrMk4XWBoFPW4Blpy4llWnm2aKqGwzMLGjqBlEYwPc9BCEN72Zul7VNuxaqPE8h4zhpy9eaxa4MhqBark0vWw6H1VzKlSiKArvdFqfjEcOw4MnpuqZc2scD1DVQnkKSJmt3Y4nH+uxrmKYJVVFi5ijxZFkFx4WwQWu0bb/2AxyHYB63dzcYhh6jIVx2UTU4XipULPvoO/ojDRVDtG2Hv//d3yNJKJbtCAHlB6iblqq/WtPmQUn4nsLLqUCYpAijCOeyhNaaBSQEoHFh8fKHv8Xnv/n3eP/9D/j06TPOF/r7pnmOm1evcHO1g7UWQz+gaxtYOLCzA0gXfhTBDwNs91tiASyo9JZWv678QsFK0gRVTVexnsnLvuehOB7heTTDObwcVnvTw8MD6qKkuYmUmOFAeYStm/WA3/3r/xMYGtzf35EjI4rhKoU4SXB3f49ks0XEbcIgCCDhPK1dAFfSv/m5/7cM+UjyKdaqLx1b53UHOvDxdBlALcTWthv4iEihj34wfI+2qyBE85685/qrz717ozUEH6HPpwvdqbWGlAJRFK4tRcpdGz4xDHCEs5Y+ttsNXJe2E3rQeHk58IQdqOqWjcYuJl6HkXp54sw5+fSklCwGHTFPBD11hEAURxCOg1/9+Z+u8xHP96GYLtv3/frrODL5RQiBIAhXTHrEBFopqQ6tXGL86aHn+QcTZey8NgH1MODmes/a7pBmBePI7L2J1Wr0Y2z4YepwNXrJLoxmRM+VWSnpDd93Hfc8XMyWriJLS3DxPBit4SmFNM2wzROYvqNKrB4xOwKn85mAGkrx3zcgAYid+Q48rWk5KSWSNEW+2+N4KfHx0yPBP7uOGYcEbJFSYOhaXN9cId9u0PY9wjhh85LA9dUedrKoqxJj3+L99z/ifC6QxhE+fPgIIQTu729x/+oO0zhhu91wXJxmH2/fvsZum2McJ9zc3qwsg2+++wXs7KBuGupqGA07jaguJZqqphq670N5Hrb7PW7v7xAnCW7vbshWVZT0EjEURNvu9xB+gN46bH9ucXN/j6tXr2Fncii4yoPjB9hsN7i+vYF0qFLf1yX64yNmS7OrZR5hRnIwbvZ7uHGMrh/QdR2K4xFVWT7/xAuAh589AFzkn+LL9P8nfwGkw0gq98ue33EcDJoGUm1HH+LAU3Qc5m6+p1wMg1m3BFpr9MPA1wsK2NjJruKIeRopox+FFEs24/oL37Q9K54a6JHgCspV6487DMg9t91tUHA7ylUu5tmubcDJ0tVBCgdxFFICsGkRhwTwzLZbXIoSdd2i1xr5Jkc/aDigFeXj50c0VUMhoL7nq0Swii3iOILyPXhM+52WgZ1y+YRA60NrLefoaQMSLwM6hzXd84z9fouiqHiQCujR0gnEjBitZTuRszISFvrSMlAqLgUk5zXSNIW105paDKOI3sBao20bEl9qg6qs0DJvsSwrhFEIpSS22xxpmpAfwM7oBipdnYty1b49vxyQ5Rmub2/w9HzkIhZlKHptcH13Cz9JiHlXd3Sv1aR/Ky5fYKdl3WCagX4wGLTB4eWAOAzoSiOc1eMXKYHTwycEitKX93e3CMIQr17fo6lqDFwvnqzFNkuQJhGdTJk8/fL8wuTokrY/nkIahxAO0BQliuMJPfMV+q7jVCcxHQKmJ6V5DkfQ7+tuu0Ucx/jw4wccDkfs3n2Db/+jv4AeJ+S7Pe6//Q59P+D6+hrvvvsWQilU5wJDXeHl4QEPnz9Bugqf3v+IiHMGjw+PmOcZVVXj8fMDqrLE5XJBdb7g9HJAW1doqwqO85MTgHCci+M40896CPC/xnFiYIJdj3TzvDTZZj7yU3dg0YKRfZfz9FJQK49TfvM8Q7oCjhCIo3B1CsRJDMEmWiqv0HHS5bu1ACAkUYaarkcYBIjiCEXZII5CFOcLUXBZbNkP5AQ0nOpbJt96IFoOZjLqjJwBXyAmXhCg7zoEUQg7jThdKuhphuv50GaCCiIGMZAEIk0i3N7sYPoOk9HY7AirFXHirut6SE7zQdBKKQg8svUMA3zXheLkI7hI5TFjUAiauQxWYP/qNRw/wMupwMwMRld5pED3gzW1uQxe24bakXXTEkDTjGjbdh1Otl2HIAjhKoWyqiGY8Ku1QZSk5AOcLM1DJjqxRTFl3LtuwPFU0NyHy0x923JtnGYJXdfRVSjf4nip8HQsUJoZ6XYH6fn49lf/BN/8x/8JvvnHf4FASQRKou4GCFdBjxbjRIlL13Wx22Q4Hc94fnpBmsT46vUtHGvWTY50JT4/vRBw1ZV4enjCOBp4/FmCFICQvL6boDxaw97e3UI6DpQAAteBaRuYrkUaBTg9UbDJzgSKwWxhdYe+KjCz8n3iVWbftjBtg/PzEx4+fCDSUtehaWpiGmiNu6++hhenUJ5CmGWYzYDLx/eYdY++6/Dw4wdUlwt8CfoCA/juT36JiZmMYA6A5evx7AVkDZ6B8nhEX5wxjRphFCPJcwshj+sDII+DgwOYP2YVuLz5hXDWf2nWgFkegNDe90u2/kuakE4SC5l30UobQxHXJf5IGwAwTEGg73ukabLag7wFD86Glq6qYIxBUVQcjOnICNR2JCPxSef9cjwhTRP0XQ9X0cS2bVrMMzAMZLjt2p6xzlg77kufYQYQcpvQTiOCMETX1IgDwpj1XQ8zEshzu9siiiLESYR8k6Gpa4RRiOJS0JGRdpx0hWItWt2069t/Ie0sDz9+grLMYxkktixcoVOQYWKyp9xVtw5+GJMfsaMAEted+35AWda0yhqnlRwM1phbxkmNhnRivnLXzn8UssMeoBIUv41pczBSJsABwtCHVApJEiFPY1RFCelKYLaAGVBXFQE8Nlu8efcN7t9+xWp2qoAXRYmhHygjEMVMdlb47tt3OD4/U5x2GPgzJPmzKYkC7ACuorXl2zf3JPFgqu1+lyOJQ0J7jxO6rkfTdKjqFp0meGsYUyNPMc5rYSb6gU+sAYdmOg4LW+khGqCsasonSMkYe3IuCN4IRVGIT99/j9OPP6A9HlEfjzi8HPD0+QGe5yFJE9y+ukd9oXTm+XymF5908fL4CJ9pSzGTjpM0xfXbt3j7i28o+qxcellw47Lven0p6+efnABwcITT/lwq8NIKnHgAOE0WMxzokVZugn9xl9nAYgZa2nb8SqDBITP9l3CGwwOwxe4zzxaD1ms7UPHbeWl89YOGww+IBRWltUEUh4ADJEm07rOfHp8R+D7auiaCqhDomoZ8hPyAWsjEk52+yDPadrURLVedtq7wzVevEQQ+0iwlWWnd4OZmDyldtG1H3D1j+EFFYAZqOloelM7I8wwzdxHGiVJ+S0nGYcX3zJbePM/Q9MNKPxKOg/PhiKGpEYU+At/HONHa8ng8sV+BchKBR4WpOIqQ5ht89c07eGEEY8b1Q+spuucT15+0YMNAJGDpujDawBESaUapxizPkCYRiqpmZ6LE5XKh2cugsc1TJFEER0rk2x3Vbf0AdV2jKi4oDke8vdtjNhpt02KcHXz88SMOD5/QXI4AZh6g0RdnmomHsAza7DTBFUCeUC23blrkOTkX+37gzMOXWYrjgBXwM6RDW5fA9+hzMwPDMKzp1n7Q+Ord1xj0SMUy1rWTT4GISHXTIghDSEU5h+1ugySJcXN9hf3VHrvrG9zc3KxuyKIk3NzErgljDCYzoDu9wMMEx07wPHqJfPz4EcfDC54fHnijY/D63TsEQYCnjx9pQ5BlSBKCx8RxiNEY9KcDMNLpdrKEwrt/+3YZeJs49L+cAHoz9QAOf0wleEnzWYZ9Yv5SXYXjYLQTJ+Wo1kpDwEUf5qwZAgoTWURBsN7/Fy20HjSMHtcHkCsER1T5qhDHFPFdk4lAVdXY7XJMFnwvN2tHfDSaMgQhDckIg0VoqTAMuXUIeuAsqnNFU/aiKOjIx4UdX7nUxpICo9bwXFKlj8Zgu0kxWZr4pmkKYygQM40jrq6v0PLbIGRHnzF0LF3yD1qzPclVa9aBrL0zu/tGCvlgRl1VaMoLJGbUdQ0pHNxc72EMiVGCwFsn+WB+YxBHSLcbeL6Pz49PcBwH11d7WhcpF/M0UdlpnBDFEfLtFgCJUHxFVeA0iQE7sUzUxePDE/IsxTSSPTnf5BwMG3B1c4M4zxFnGe5fv8I0ToiDAF3bwPQEOHWVwu9+/ddonx/w23/7b/DDr/8KYiIdOcWqgSDwuSpr4XsKm02Ol6cnYghW1dqX8H36EnUD8f6HYUDddEwSJtbj6XjC+XjkFV2IJKW1qDEGyWaDKE2x2W7w+PyCz08vABwYbjUuItL9bsvcCJrbGE1wGslGIaEUjmWF0+lM9CGPZC8rINR1UdUNitMJn3/8SACQvkeaZWi6gQaADK05Ho7o6xqnw8u6cVsG5uM4IklTKKVwfPiMse+wv7rC/u4eN1+/o02F7yOMoqNw3XZ9ANxfbzsHzuefRwWmL/gXYg9Nk386FxCC+uoL6nrxzi/hFPAeeDmqUa/AMvdec/kFkK5L6Gi2+0qXrhdVSY0u4bqI4pAfSPhiBBIOPFdgHic8PDxRyg8EVFwSdZaVY8pTLOQka0/X9chy+vDTsXBcQabjSB9ICvHEaOsa00hJtCWCTA+/mcCh/KVf2PYOgPPpTM0830dbNwjjiHPgHqI4plOUFGh7mngrVyFJYqQZOehcQdBUO5G63GVGgAVQ1wTUVFLiZp/D9yhDQKZgH3mWANbCFQ5Ozy8rr98YA83Wm3EkgUtZVuv1oalrgnzkObb7HaTy4PsBbm6uMY0jNllChl4/wP76Gkop7K+vYMxIZScmGS3hoCXtKYTAoA3OlzN9gmaLob6gPjzh0x9+j64fKOoraIX88vKCNIkIBjqOuJwvOJ4uaJtm1bGPIw0y4zjGNkuRJDHiOCYDL+cORmNo/sSINCHc9QtkzAgBIhMbQzX0JI7RNTUsnzo836d/Pk/0R2NQ1Q3qqobnKbjKpdPHSJHekK9JUUxQljTPV9BnliZMRZrohaQ1qqqCKx0S484zsjShB+o843Q6Q2sCvCzDYvIpjNDDgLKscLmUiK9uoKKITndlASEF9KA//uHjc7c+AP7qN//Ouq74w88jAtGajVxn8xf55E/+e2r60dXAZUDltCbTSPlFE/OFMERvXc9XtN5i96DvU//7i2Kc9Fae5yGKSIwx9AMN6TwXvq9gR8KNnYsKT88HeCwODcOQ6b6UCRB8PLcTmYC7roOrXJJrEPMMURyTPcfQm/58qfD89MwDNbEGOxae/pIvaNqOtWBML3YIoTYyb6+uaggh0FQVqgs5/vq+Z2UXnW7yPKP24Uydi+PxjDzP4PHbRhsDz3UBh+YW4HCVnSwcELDT4eJQ4HvQekDfayRJhPPLCy4vL6iLAjfXV+xodFeVea81OhazDP0XQMlsSakWxxFmptlMMxAlMZKYzMXb3QZK0YBwf3ONzYaOxdJOqC4FXh6eqMkIrEWxtu1hJroOWUj0hlKfh3OJQY+rF0BJEntoQwPaS1FQtsNMKOsGyvPYw0BXrDihCPUy7D2eziguBaKYCkppmiKJI7RdhzCOcXVzjf1+C99T2G0zfPr4Ca4D3N/uUZQlLucLTqcz+q5H3w/oGC67+BqapoYQtPPfMLA1jWllGvFDXAhBQ8LRIIpCOiGOIz1sOcpdlCUkF5b6vofveUizjCvdNAA9nS8oynLF1i+Oi4Ww5PgB3CDC6fERVVmivFzQ9/37//K//RfT+gAAgMhzf/fzBoB0jKcknrNyBaWUvMKiL3/bDSsFVSm1Bn1mHmwticG+J/TRElhxHMFfJmfl/mut6b9n9xrx3xoU54IkHGbEbr+DMURpITU3TfVHPrZRaWjk0JCC5ubiOI6E8pYuLKuzCXPmoea1j2VF2dV+g5kFmsvDa+miS7WUfyhMs+Twx4nul8YYNHWDJEtX048QAl3XUTpOUtQ18H2kaQovjLDbb5GmKaSiwajRFKkNwxBSujxMtfxjoC+w5sGrHno6thrDKnBn3QRUdc2OvwBt162CkZfDEUmaYr/bQfkeXg4neB7Zmexk4UiJ8/GM4nIhBHycYIKzVqajiEWm0l0tOEEYYrITptHAkwJCED8iSWJkSYQ0S/HmF9+iqFu8HC8kTu169Jo8BoZXk/1An6eAjUjLJqDvB/R9j67rKCfykwi5EHT3dxdQakBv7jAIllw8AODl6Rkvj0/o+x5BEOD56RkffvyI4nRC27WMQhMoqhovhyO01mjqirIi07Q+0OlzPqPresKa8yA44F+/ruuhFA2up3GiGQAnX0/nM5q6hislPEWsiqIoEEcRsv0eXdsRsp0/swvfUmsNpdw1Hp7nKQW9PIWmqmGMwW6/h7HAODvrd939yXTvb///E/p/2CrQsgGG0nZYGX8zc/0lE2++QETJSGv5w7/w5WYu3kwj3fWWzQG99YmeGnAgSDI1SCmFj5+fkKcxNtvNunK8u7vGjz9+ghR0YoiicIVlTtOEuu6x3ebsLeQj9ORyEIXujg4cXC4XRHGMUWs0bQ/fmxAGPjHoNEUql9x6wEISpnJRxLTvMU0Jb0ckwzTp180MmhgG7JCTrqQv8zzjcj7DlQJZvIHRGt1siUcnJdIkwaUoEYU+tNYUDQXw/7H2LjG7bGd+179Wrbrf3tt32dfjY3fbnTiQQLgEJQgGMEcZMYgUGDFBQkLKACnToJ6BhBCMGgmBkBjQTQhSEE0AtUIHOkl3x2237WMf22dfvtt7rftaVasWg+ep2sdyOvZ24pH7nOPTe+/vfavWep7///dzpQelFBl0wwBh72NgKItSCoIfyNNkF8uOJ4mbCAeEWmPwKhwiJdmUHuyrIkeepXi4f0C+KtD3PXzuM1AHw1mArUkcIvQJ+FKsV/B8D+/evcflFCFNY+otKI2urqCGES9evsRkJkg/wM3LF7iczgRC4RcGnfiAKAqRZcnCmxSuiySOUdU10ixDr4/sVRhI233hXX0QLNKUPM9xPp+RJAniKIDqNbRSqCaqgBdFTsTi04UbhmD6ko/d1TXatkEaBUgTgq9stxuKPrctojBc+BaAJdpQGEA4LiLfQ+zTMJUMxxHK82kZsg7jiEt5wnazXhqjQrjszNQoihy3L1/AaI3T4YCetxeuSzyDFy9fQvU9yomShXmeY9ADet3i3eefwyiFq6sthCuwCSJ04/S95SQ//5co8H8AQH+UIWiRHTL9nB8gsxZqNNOC7pojoFHowzB1JwwDRGGIS1UTQJPfsMbMZByBPEt/yhUgBEMvQfQdh1tyIa+xkjjktQc9hEJeg9Hx3V12/Eprwk31CoEfICvypZ/ueT7ps0GZ+/V2DUc49CURAn5M989pmlDWNeq6xflcYuD1Ua8GKAN+8448racP4Uz3AbAcUz2GcsJaBCE1+uIoQldVADcT57zCMOglCSc9j4eLAwZNuCqtehyPR0rZCUGx246rvFKiyDNUTUMrxcBHVdPbLM9SJuzQKa5Yr/D+/pHumFzZdrhX0LXdMusYzbToxJq6RhT4KE9nPD0+QSuN8+lCSO2uw+FED9TT6UJNSUegvJxxOp/Z+3ePJI0xDgOKVQHXDyGFwKqgGiwRd4GmqnA5nyGlRJamOBxPhE5nuIaYgbNcTJuzFuNA5a08S+kuHoeY7EQ/S06w0naG+Ihv756QFQVuXr7EN/+1v4Cbly+x3m7gByFWRQGl9eIvVFojTVNkeU6fxygiDqAZ0XcdDocDyrKE0gNGM8GVHq5vb0khx29vybix6+vd0nEpigK3z59hGkbUVYmmaRbVWMcMgWEcUbNDMQgCRpKltOp++wb15YSn9+8x9D2K7Xr0w/Czn3kAXK2zd46D08f0AUiLBH7qzdgqOhKbydDJgAdn9AMZF3JQHMdouh5CEmBhPgp7ngfFuOwkTTBZS5LEORPAmQEhXbRNBz8IlpjrDCWhFSQWSKmARRKFnHuXMJbunZgmAlXwtUS6AsaC130Drq62/KUzePb8OVzuFfQ93X+lK3A+VxCeT78XdtH1fYeuvGBUPdq+Z/zJTFGiVZqZJiScZQh5OKR5KJUmMUE9Qx/jSJsAx+H1lBmRxrRbVnpYlN/C4RMXH3EF361d10WapvBZo930GqOZUNYtjOVtzTShqmrCVycJTpcag5mwvbpiF8AIj12AWUYnkLJucK4a1J2CdT3sNisIO6G8nNGrHuOgYdkMHEYRXr16jigMUZclwtBHkq9wfb2D1hqnkvLw9eM9JtUBZsDD3T18z0Oa50jiCOuCWnNlWfKVhzomnu/jq59+BS9fPMPrl8+x221wdXWFzdU1gjAkO5JSbI2+kOmpqnE8nADhYtAjzYJcifuH/cIQCAMfWcy/3u0tkmefIt5eY/PqE1hBfkrh+UuPg8Af9OcZRjG8MIQjJbQeUTUtTucLup4Ge1XbYfOVr6LuNSBcQrmBHZWSVscF26vyPEPXtPTw6Ekpp7RegDBFnuN8OkHpAXmeESU7jjGYCVmaIIkiSEmnpuP+gNPd/Xn//u4nP/MA2K6yyhXizceHgbCUgMbRQLIdeE4BztuAaaLAj+G7c680Ao+CJn5IT+JZT0DSTgqqjMPATHe7NAJ7rWlf25N7ru17eJ5EwIMhh9XeQjgLzXWaDPquXxjts0ijV6zUcilr3Xf0dhMAHM7hE9I6wM2zZ8zHI2pOlibsBSALjGDFeF3WqOsGKW8mqK/vLMUj6bqLidjjDj+Zk+jXJKWEhYO27RcfH/AhfzEryiwjulIOpVhrka9WSJIMWZah6wheWlUV6qpG3ysc9gesigKh7y2FGsknA49LUnHo4/7uAVI4CEMfn371K2jaDlmWIYoCsuRwCOt4PGHoe8JOmwm90qirGhFz++q6watXLyC5M2JZV+V6EgmvRos8Q9crpOmHbUPfthCY6FQRRQBAAzUzQXqkkhuZ7PTik5f41T/1daw2G7z85DURiQMfl7JGWVbwPB/FqiBjNX9xRmYvUCW553qzx3Yp4ucXRY4Xn34Fm+0aIiyQvPo1XDTw4itfoTlPU8N1BZ69eI7pS4KPlPMgaUwP8qfHJ0jPZyaDj0lIjI6Lx+OF250C281qOVkPw4AoinB9fUVvdE77jWxaogbthNuXr7B98RIWwHpFwlPaihxhtCI/JePzpUeD00vV3D+eyupnHgD/9r/xF0YH+O7HSkLBcwDL4IsvzxEoJchXAp4HqGFEEn8wq8zarK5TZJbRmo+h9MZXLBOZVeRt18GxVHqZj3mjUjieLrw5sEt/23HoCG6sxWBox+wHPhmJmII7N9o8z4OQH7BdXhii5Pqm4wjKuS9RS0Po774n7jsz31zPAywQsPbMmAlRHNOvY7LwogSuH0KEMfyQnAGeT8zAgdFavqS3i88mWMCB9Dwcjmd+8jtLdLpXCsM4wHFcRDGZj5uqYsUWE4CU/tLAiFx0p/MFIR+FX71+uQSoZo5CnqXYbTcoywqX8wVv37ynecY0QakBmEYEnkTgSXjSxel0wne+9R3KYDgCYRTzw1qQnFJKnM6XhacfJQlFx8cReZbBcUjtprXG8XiE70lEoYfAY8AKgO1uC+kzUMZM6LoO+9MZUZKgaSjhGSc0TT+fLktqMU0TCmmlCXZXV6gqeqDQTCCjjUGeYbIWq80KSZoiTVNM04TrV6/w1W9+E9/+vd/D/v1brK+u8fqf+1egB8J+m4mciVVZAY6DVZGjKHLiTDLzkSA0AlFEnkJHCORFhiDNkRc58u0GrisRxQlcluVs1mQxMhYYXQnhSuJbRiFWqxxRGCBOErq2VRXSNKUwXK8gpUdD28CH69LPR2kNKT0I6SFKkj/6Bz86qp95APy1v/HriEPvd3+ZVuA8A5j1zrP80nGw0HCJdEtDsjkQNI4TYMkMRFNzBWMmwDpLym0YqSDksznH5RSgMWYJpAghiLPfKzzuT9gfL7AWiGN+Axuy63geTWGbpqFjsc8BG7C4xPcgWUbhupLukL6Puqp45UMdg0Ep7K52FMhhxj1JM0Jsr3aoyxpJmsDyWsiTLnpF+C+qgbZQxmK0gMemnUHT9gPCpfgs30OFcFCWFfERhhHGkBtBuu6y5Zgmw28Yl9Rdw4DJUGnI931EYbishpIkRp5nGPSAqm6RpylfI5wF27bbrslyO00w44jT6QwhXByOZ9JS7XaUGeA67eVSctmIkNcDl5M8P1h+L9KVJNxMEgS+pBXW8YSGi0Rh4MMRLgzPaMwwIPBINfbw+Lg03YIwgJCS6+LEizSDxunpQG/htlkwc47jYLvdUFW8blHXNVV5uWA2TROKVYHNZo3Xr19gc32N17/yNSRZju31NVbPXuF0HA0jJgAAIABJREFUaRBbhd//7f8VQ9egOdyhPB5hjcHpXDKt+ALp8ueo57CRMRhYLJNnOWdfHASeh6Gucf7hd7EpUgoPhRQ8mgylY+eftdIDiptbeMWKG6V0oup6RRXht2/RlCWqskTX9yhWOXslI3RtB60VyqpGHIVUpItjCOH8o7/2N34dP/MAAADf8/7QcZyP7gQ4bAief/AfxCHcF8CHo6sFhX201nQk5OPNXPTRegCEs5iF5/77PEAbOENtHcoS+D7FdF0hcHg6UEus6+CHIYT0qIxisYSW6F44Lgk/ulcbnM8X/nBv4ViLpmnon+17+J5EWzc4HU8IohBpkSPgEMjESbzXL27RlCWlBsOQhJiCJvSXSwlPUj1T9T2a0wFDUwGDxshDIckV2bauMVnKV0jXRcuoLMMEZEcIApw4AkHgw3AoidaiMXcraO0VpxlfgcBrzIlFGSWyNEISUkgpjsLleCmlSz8LT2LQtHGxAFxB4ayaYSvPnj/DerNGW1W85pygNbUvldKI4hTGjDifL6jrFsKjht/DwyNh1XUPy8Uw1xUMb7EoiozWdQCatsMwGsRpBj9O0RtgdGgG1LYdoiCAYuBpW5WoTye8efOOfp8cXS6rBje31yjrBvl2h5df/RryosBut4NwXd4G0RdrnCySPMP1i+fItzs8/+qvoKoarK+u4U4Dfvj7fw9DS7OdyYwIPcbTByGZidpuofv0TQ07DsjyAnEcQquOlWEGMANM3wHjCCskRBDCD8MlIh9G1Eko8hT96Yjm6RFJSiGg7XaDq6sdJJOkY1bdTZNFsV6ja1tsdztkWbYU7NZXV+iHEYMxxg3CP/jyd/enpKBR4H3fAc4WuPr4TAA7Ahx6kzj8m5lVUEIITNOAYTAQAtzyG1kOSesRz5NQykEcx+j6HqHvLcx8O1nEUYinuuGMf0yhHVjeKztwfBrGGDPBEfT2AIAsTXAqK4SB+bCPBHhwktNbvm6W+31Vknwh4Dx2ksTo2w7GyoVP0HUtNps1mrbn41mE7fUVhsni1Sev8cMffI4izzGqDkppuJ6HcTxht9tQX99aDAM93DzpIklTHPaHpaAyDBpxGNId3aPY83xf1lov6zfXkQszYNAKEScTfd+H77lotYKeBrIN5wV0T8flaaSyjFIKcZIQH7DtmPAk8LQ/Io4j7u/TUXKO3RLS+rDo0MZhoM3OJBGlEcDH3Mf7B/ozGEfc3z/C9/0lVp0mMR7uK2RpsmxzaK0lAdfC8zycjme4noe6rvHu3R16pZDEtC2a5R+UfjMYIVB3Cm2v4EuJw56EKRmr2fOE/nfpKod0XWx2G7x/845nKSMJOB0HfdOgbVoAFlda42v/0l8CICB/+G3sf/IDdAciXp0uFR3D+TRluAEK/lnMce4sz6H7HjuPOv6ktqMtR1mWdEowBtIB1psNupa4kwDFtuvDHm1VYbUqUF1KRHGMh/t7bPjq0LUtXRu2W/S9hjET9k9PSNMUq/UGTV1j6OglUld1JfrhD76sAf+pE0ASR0fXFT/+peCgyzZgPg0Q+knrAZLhBHM4SClaISk9fDjSWQJ6zFPQkNcZgf9B5qD5nwdXYpUeEKfJYib2fR+eT/hwKV2GbLgL7Xfi6b9SeqHIjuNI03PpwvOpkOS6LuKIShXWTpS5DgJsNmtgovunHg212oocerQ4lxXZhqMQ202BfL1GmCSAS8fueRV5Pp4ppsynkUEPnIAcUJ4vJASJY8RpBrgklhxHg8APoDQNROu6gZ0MDz2pcefyTtnh61jMNqVZkz3x4NWTkuYVLuUOlNI4nU6sc6dr0/F0hudJDpZQqatXNJjquh4NJwKNGejDyxhrYyZ6YPg+HEuyz9CnWcHVbrN4GrSmRluSJlCs8+75JDZbcOehZ9f1KIoC46BhtELf1Kgbak/udjvSZF1q3H7yGkG+Rtvr5XQ5B8YmY+DCoL6UuL97xAR6KQX8gKVkpofL/gmP796hq0o6WtcNwjiBJx08f7bDp5++RPl4jzDwMAkJP6LegJQS5eXCIaojZVXCCG4QIcloIOiHAZIsw7mscCkrtG2Hy/GAp3dv0ZYXWGsR50SoHoYB46DpGD9o1qOVHISjTcBhf0RVljRQFQ55H69usHv+HM9ef0IPgA0JTPaPj/A9CcfiJ//vH/3wp+A/P/UA+NZ3f984cP7BL0UIth/Wgy77AueUIDgyLITL+WtCHjm8LTDjAIfhH5gMc/Tpf6uUQprEy9ViDlqQXMRbKECwFqFPBRafrbKbdYGB/wCTKILne9TwYw7c7LZXSiEKA/IFROFSsVWKaqdCOKyrJl2X4ZXlMAFCSjx/8QyOK5eBZdNSJPPpcU+k4/Uab94/oWYx5aA1K7/pP03dwJgRwzgg5Q9M11Mir+sVrAWSPEfdkOHW8/3lCiME3dWp9knVUdeVkJIJyXyKcphoZKYJ682GfIt9D6X1UqTSWpNFCA7yjJp1NP1P4Tg0zwAokw9rmaIcwk58bx0HaoROZqEjK60RJzGaplki0FEcYRjMsp+HEHT9GwYMmvrx1hgkMQk9izxbOu/XVzv86T/1Dbz+5BWstdisC6zXK+R5BhkGCHwPSRQu5mE4gAMHdTfgeDpBdx2assQPP/scD/cPgLV4fHhC1/XYn0o87Y/Q4wilRzy+fYPy4Q2++Ie/gy/+4Pewf38HaYkFmaYpRq3Qty3Op9NS+Gq7Do70IcMI29trDMZASpplJWmC58+fk7m5pX3+xCUnx5VwXMndE4dOpOyn9KS7rInrusH26opOHhOQFgWF1YyBm63gRzHS9QqjoQee6/m0Kp8mSM/9+3/lP/lPpz/xAQAAnuf+Dr8wPt4Qwm/imdNHKUHy3M3s/XljMDfq5iuEmajyOTA+a2afDcNAWCkWXcx+OWstPI+kFZ7nLx82CwdhFMHht2oUxzhfLpQyNAb3D0+4utqiaboZR0Ddgo4ThsOANCX6TZbTmgqOgGLXusOrPliiB9EeP8SGTbV9ryj27JLS2XEJ9rHZrpc5Rq80NCO7PY+6AoNSKDg3HscRjocTTczjGHCAvm2pVWkofOVJlzyAMeXxp3FA17ZoG6IMG2NgrENV0KaB51JVa35oTJPF23fvMfLd9XwpcTiVdH+PArIQO7NzkE4O0vdhDB2XtdYI45h+ruMIM9FdOIqo4FOVJSPSJlSXy4Icb+oadVlityOxxbw+U32PcRzhBSGCMIIVAiPnNCij4LH8lVBdUZoi36xhYaH7Fu/evMekFbarjLMTgnXYVIu2jgMLB1fXWyQ+AWl311eYJosT8wS3ux1cz0NZNmiaBvc//D7s0CEtVoAZYdoaZVXjcikR+hLCGqqa5zmKzRZBHGN3dYXD8UTiGpcaky6brgLfg8NmKFd6/MUnb+agFOrzeTm5pnlO3f25DMZrxKIocHV7g2KzwZZNyYRhS3F6+wVcz8PpaY/Hh0ecTyeYacJmt4MjhDUT/u7PdHp+BvMtxO+6rlAfEwgCW2TANKB57aeHkWCQ7oerwbxy0oOBmWhVaEEeefsluIgZh4WXNgwDhCOWwZidKOQw6IHMLNKl4gkzCqXrLtcK1VH9s+vpiGnGEdNEWqswCsmswn+tZUOLJyUiNrgOk0VZt8jzDLprIYSDhNcuE3Pxq6oBrMV6lWMYaai32azguoKw2l0H37F4dnuFMCIO3qyKnqYJ0vdYekpEmralh4/WA06XkshH3P5rWkJ0rYoCDixfqwAzAZolJucLvelV3/GbmYo0aUyFl5bbglEU4Xi6IIwT2qnHISZDHfqup7VsllLVmq5r9GaVvk+dhGFg/DmxAuM4Rt0QeblTGllRIE5TOMLFi1cv8fLFcyIx5xnqpmN3QY+EWftBFMOPErjSgyvo4V+VFQ1HOWFZ1w3KukHVDUh312h6jep8RrV/xNObLzAojbJqMVlgtSqgBmIMng4HRJ6L5nTC08Mjrq+vsFoVGKcJeUbWqCxLMY0Dnk4XTNbi9e0Gh8+/BykseiugR4P1dos8S2DNuKDWk/UG+e0zrG9vsVrlENOI+nSC0D2sVjgdz+iYoDQoBen5CEN6CGg1YLJAXV7w+P49PI+6HBPj72co6JwiBIDqeIKdJlz2T1R9NgbSTnj8/DNUTw9oLxcEYUitx8lg1AoQQnd6/H9+7gPg3/k3/4UvhOP84JdZB86JPypHTAzO4EyAmZbtwDSRaWXm1ls+OcRJjCRNaKA10GDIjIbWefwhyNIESlMhSDB3PeBjruCKsXQdeNJD36nFybZaUdAiSYhHH/j+ct9UfMwmXj1hwn3fx/F4wmazgpQuNpsNrLVc9fTRtC3sZNFrzXSdnum2MW8cJF68eIY0TfHjH/2EK7p0rF2tCJrRNg2kR4CNuRIdhCGaqoInXdzcXCNLE4zDiEGTcSj0fbRtx2DTiPRrXLIyfNycJgPhCFxfX8P3/CUOOxiaJTzuD3AcB2lCrLqmrrBZrwiwYSaGkhJToWk7CnO5LiZj8PC4R9O0DLSgIa4f8sBUunj27JYGssAHhr8QcDBhshZ+QINAM47LCSdJU7iC5i5pTtTe+aS43a4pVtz3GPhaFngSSRRA2JFir0nMdmPKacxH8bl6TiQlH3Vdo67JIlSeL9g/7WGZQ3k+nfH48AghPTJGcyz88vSIpzdvsH//HufDHnd3dG0gC7WPw7mE6wDuZHA5HHE8HLFer9B3HU6nE+qmQ1NXsJNlhPmZISAawnFwfXONia9G4zjidDzifL4w/5BSoJL7Aq5Dgbbz+Qy4LqIoQhDHqJsGVVUR6q2qUFcl8vUa6XoNz/NQXkoEYfTF73//zY9+7gPgv/nN3zKRL//Pjx0CzkGgWbo5OwNmK7BdKIJYQjqz8EK6AqpXixjUMG0XjrPspyUPpUYzocgIE+4zSy/ie7t0xZJIBEgNvVoVGM20JBCLPIMxE2flKTYbxTH92s2EUWvkRY7LmTzy40h4rXEy2O12X8Kfs9rbmMXZN2vSVK/w9s1b9GrA69fP8fzFM4orW0D6AaIogs9asjkGbec/L+69D7xq8j2JXqmFlCtdMvyovufYM61Xd7sNAk+iKi9YFRlO5/Ny4srSlAZ6vKptW2oI6nFEHJEUte+6BVnte0QhCrjvYIzhGDdYjU1HUz8I6GHDq+CBLdBRHEM4dFXSA+XUD/sjwpiGiOXlAqU1up6gma4rAAdomgb7xyccDgc0bbtUXj3pIk0jZGmMosgBODjv99g/PKEpywWK2nYU4VVKwfc8VFVFhFyHuvxBECytTc/3cDmdqf8AC0wG50uJMAjxp7/xKcLAx/l0hmpbvP3hDyEwYbUq6IHB26EoiuA4Dt6/fYfvf/uPYVSPQEokcURXq6qGnUYiTzM1eIbLChbkVDVRlOgaRSfoy+WCumnZ+uRwe7WGsROiNKXsyYLjI/q27/tYFTk6Zjne390B3Ma0dkJZlv/3X/3rv65/7gOAPgDu/7F8Wz9yHTjHFD+4Ay20Jsz1MM6x4InKP7BQmkIgI4tF5qpjwPjlkUUWlo/3gMXAeOs5Ejt/APQwEnJbKboOMKpaONTsc5gUFEchYcqVphWYGbFer9lJSNaiiNdTlnfyM5c+SRPuLRCIFJw2pBqmhScFDlynzYscXd0gS4iVpxRRf5Ue0HeKMeCEtXLgYGSKrDEGDujX33c9PEkVaz0M/FAUCEJaKwVhSG085ii6Lp26fE/ifLksxiTPoyDO+VIijkm66vCXncoxEbQmS1DGzH8LIAx87v+TlOTZ7fXCNnQ5u+FxfqOua5zPF8RRBN/3mTc4K+I1Rq2RsN4sTROkaYwsTZHE9EXq+x77pz2GgbBnM9cwiiOs1xvEMVW0z+czAunitN9TDoDXi/ODdBgHrBnlPY6GpCFRiO1uS/MLRUSo9ZraltZaRGGIVZHjcX9ElsRoeGUHO2Gdx3AdB+eyxqvXrwiBByLvZlmKZ7c3qM6nhU5Np1+i7ziOgO+56DnOHkcRzQTgLOTnqiwhecYxDCPCMEDKgFXf89E0LQJWil1OZ+x2Wxbnjjg8Pi0avGEcUWx38OMEwhG4/+ILSOkhTlNrrPN//WO5Hv+4vxj4wd93hTh/vCyEnuazyHI0EyGLDGGp5hSg4FDOwDx8ay2EI9CpgUAhQiDLkoVBT3IKyVAHGmQRjIJIPW2viDjDd8dZLwbHRcm4bqWYCQBgYECJH4aLhMJakpP4QbBkq33ms4cclBEeYbjnvoKZLAQAO+oleSeZdz8MAyGpWMsVBj6SyKfet5l43tDxyciBHjTt1BVluF0hEEchjKFWpOdJ+JLKPTN/gYZqFV0B2G9oRgVMBo6l08zlckHdtuz4swh92sH3fQefIRl5lvJUn0pFnu+h7QdIP0DbKxTrDTYbohW1TctoMZrTjOOItmnQK40ky2EmS1YlJg5ZaxFyL0B6PkFXegVH+ihWa2hjcfewR5alNKl2BVYFdTWKVUFFmelDnWocBlQVte8uxyPCwEcUxdgyTckRLoeaNA9NyTo1jCNOfLevu567KS4/qEL4EclAi1WB9W4HyU4/rQd0vcbheELo088vL3IaDHK6Vfoerq+vqKnHs5EwCJakpMczEzgOrOOwSIZeHOMwYNQaE6g0VdU14jiBsXRNnoE4SZJgsjQMNpOlvkMYsqtiZLlsjqvbG8qDRCH0MCBarRAV68rYnx0A/okPAAjnwXXF7/4yJ4BZczQ/+R0HLKOgI+48BFSszu56xcEdJgxNFkEQomqoyKIUude6nv7vjgtAcz3WjAPapiOgSJJQLRlY+IBkEgIXk6gnMDI40vM8dD19GPquX6QeHWfo4ygkjJd0+QvtwWeXAK0eJ7RNi77rUF7KBYo6t/CUUlzGqWn4lcQkARFkwilLqnCGEa0gZ0TYfNSeC0uGTyKkHsPy5xvFMUWnAfR9x8NWhz94AcVxeTbS9woW4D9DOmVVdc2C0A4NuxjJVzBitSqwWq9Q1h2U6omAHAYYxwFlVTPpeEsYa86577ZrFKsc53O5GJwlcwzmL9LV7S3MBGy2G7x9f484y2EscDx90JBRjdtnyCXh4B8eH4k8xLisu/sHGCvgJyngAKt1Qex9SaWXu/tHCjVNE/qWfH2n4wlPhxPGccL93T2h5T2aFVVVg/pyxs3VBnfv7tCrAav1GnlRIIgiXF9tEfjEEaTWKa1ApUczgyiK6PPMOZK265f5xmqzxcuXLxeFmMOejCAK6UGfxEiSBKvVCjc3N5Cs10vTFM9fvfgpddg4GvgxzcniNKWrL2/c4ixDebrA833AcZDEBHv1k+QfjmZ68ws/AL54813jCvG//RKLwOWmP/sB6EsxXwvEIriYpgkB9wTmuUHTkizE8jHY4/XJvDOf/yCmaULHZaBBD/RD7Hvq0zMIsu8V6rqlJF9M6ymXG3gDx16bukYQ+Oj7nnRlTHZpanqqzlP1ydC9v+vVEobRSuN8PMKMA+qy+hBr5hNKmiQY9YDD4cj4KqK+WMZxF0VOx3whiB7cNDy8o+FZrzTjvulNNQNQtKbwzUy88XxyxkvpobxUDFrFMjxKkhgOHCRpwtSZkRuO9GttmpbsMr1mc4zC6Xzh9GOLbZGgqmoIh65PsBZh4EOwen3QA/87Be7u7qnLv14hLwqyB3seHFfSyo2txmlRwFhgfXWFd2/fUWOPj/E1I9IdR+B8OqOuKjiwNO/hLc5us4b0Q+TbLV589WukK5/o59M0DVV5M+rDl3WNd/ePmCaLfL2CJz1ESYzrm2u8e/cedV1TcCoO8atf/xq5KDyJ15+8WFgNeZ4hColFEUYhC0AFsoxnK67Lpmtax51PZyonxTEO+wMO+z3evH1HQ8jLBVXdoO96nM8XRqKRW9FxBTbbNWcrSFB72B+IjQmgKHJiBqQpjAWEK3H7yScYDKAnwHElTgdKk1qOh/NL9W9/8y//B+YXPwGQ4+7vOI7Tf8wq0PK03y7ONwHDXwgpxdLjtpZaY/Ngi5pj9OWb104ANQUFq8Kk5+HETzfaUYtlqm/mWGvfkUsviVBVNcKQQie+R4OZtuvId88W3rmfP38JJ67XUiW14Q+4Xkoec+Z+JrGWZQ1XcC9dUjuwZautVj3lvkHpurqqOfI6Z/odZHm+zDCSNIUQLuqmhWbaLxmTBW1TlvYl9SSEA1hjoPsOoyZkFg1i6f/fxDwGcsTNxSYqOnlSUlWZuYPWWgjpLislB0DXNHCFgywlaeuJOxaTtXRqMgaXCwE6wjBYmn6XS8WoeIu2V1S3DkOkeQ6terR1BQGLrmnw4tk1NtsN1us1ocjthN1uxwlSTfLTYURZVjCTQZQki4dQKYUojuE6VAtXvVpeQHlRIM9zap9qGqze3d1Bui5unt9id3sNM1n6okwW290W1nEx+RGsH6JXxFnQSuPu7gFv375H2/VIeSMTRQHsZHHh/MA0GRhLrMe6biAkgWeMGbFeraB6Bc+TKIoC0vOXyryUHoQroXlm0NYtHh6eUJUlYfF502SMQRgnSDdbXL9+DRES6n6aJui2he9JXF3vcP/+DlEc4eHuHnEUUoR+HKe2rH77T2R7/kl/Y1ekn/nS/eOP9gVau9xrZxkI3aUMIbBgl7v77DyDJbGG4QjvZGi903AKyhXuEmkNmU3n8ANCDQZJllINNyTM9/lc4vrmepGATnCQFwWiMITvE7+forA0CJzR5jWz4tMkpmoxp88MB5pcNhv3fY+8yFEU2ZLcEoLuk0r1lLqra7iYmFPg8ZeSKMHCWpSXavl3zRHoOIm46UWqMCEcdhcatvNa+J4LM2h6AzDNWHMjMQwpRDMfUaUUOB72LGftEYYRlB4XZ8A40kPD931IrmJP7CQ0hr54gR8gTRMopVGsVsymp4x7VTWI+Y4ehqRKu769oQhtSO5Fz/Og+x7l6QzNp7TQE7icTvjsu9+H6lpMo6aePk/y64b6HtYYdG3LWx72MHSE9/ali8f378nyM4w0SHNdrpYTgWccDSKWtGR5jlefvMLt81uMSuHNm3dQSmN/OOLu3R20sVh/5evYvf4EVUNaL+lJrIocsHSiC+MIQZIiKwo87Q8IwhCKT6CqV3ClCzOM2KxWqOuG260jeyDn0yql/cia7SFfr5GvV+jVgKqqkMYxVN/j+tkzxEmCpmGacBQi2+6w/drX0VU1LscTfvz55zg8PWG9KtA3DZqqhBlHFHmKrm2RJglU2/7x4Xj59kc/AP79v/xvqSiQv/mxbICZeDXz+Q17+MgRYhc5yJwSdCw9/eBSqs8BkKc0tJmHLEHgo65bZFkKPQzcXhuZ7kNwBy8g95rruvD9AFXdAMKFH0YYJ2LFWQd8oqBB1Swc7dqW0m5BQORiS0PHrusQxjGaqqbQUNMCjkPSidHg+uYGExy4vo/H/RGceobSCkWWMOKZLMY31zvy753OOPD02uEU3Xy10cOIIAwxTmT7FZ6H0YyLo9BaS8UTQ0M+C4KNzG/KIIoBR1ArzRjEoY9VnqGqGvSKkodFnvKAlibk8xuG+v0eAoabgMlIh9MZPe/UzTRhnCzOXEM2xiwV5ChNEXF/YoaQlOczotBHW9c4HQ8c3tJoqgrCGgxaLfOY07nkaxsdj10haDbRNHClt/yazTgyO3JAeTqiOR1xOZ0AjnXXdY2yLJGmKexEHgUpJZ5/8prvzhJD39O1MAx44t/hsx/8CE1ZIvJc3NzsyA+hNcZBI/QkxmmCdT1snj3jtGCNKEmxvX2GpukIZTeOiOIIk52w2awpoxGEhHqPI+RFTj9r2n/DUO0T5emClLsbVV0hjCIcn56Yh0Hp1r7voZqaIubv3uEnn/+Ycg8cHDtxRRnTiNtnt0zlmnCp6t/8rd/5Vv/RD4C//p/9FwCcv+U4vzgncG4CzndQWou5XyoIfSAC0w+rWXadlrcDdsaN8VVC8BVhjgELtuQQT5AEEXNxaNZUCZf8AVK62G1WTAI2KPIMWRLBgaUOgRCsArMYx4FgmkHAfYIQfdfzIJPixWGSLLVLhz/4aZbRf+eHmiddCNDsYxwH6u5zpbaqKKEXx7TBUD2TaIKAHHJdh9V6xcSaiYQno+HGIW0xJDfpDG8BJmtJmDqRMJSsyVSequuG7+HUv5//jF1OS2qtYcyIjgEqWZ5BODSg1WwHJtIQdeibht7GL58/Q900cISDy/lMroAsxcuXz+ma1PdUWQYZeEaGZSqezMOha9d2u0UYBHAdB01dIy9yXN9ck9atJIlokqYw44jtbksvDCEQJym2uy2udluYyWC73VAph7cPvh9gNAaH0xmwFqvNGlGaQUgJPwohXbIG395eM3otQBR4+O7/9/dw96MfYV2k6PsexyMR8pI0xdP+hJFnQU2nsF6vqM2KaaH6hmHIK2eqlkuX1n/UpRDL4BpCIM5yOl1qBRjiQRyPZE9WShNXgQlD+XoF4QVwzYCn734bl9MR17s1BtWj61pUdQWtB2RZiqqqMbGz0fX80Tru/0Lf5Y98AICmvn/sCvdbH3P8N9PSCuKVn1i+wMQNEPwHiYX8Yyfq5c9Qx7bteJgnFgkIGKmlekXHQzbERFGItlMLfXiutI4TTcDvH/Yo8gxNUxO0s1dUaHHlklpM0wSenFdp9BDrO/LmOQ41GPteLUowKV3iro+0sozjGNvtluAnwwCjFVTXLvMOBxb745l14+z4WwIplAATrsCohwWEMk/sXeEQ9YfWs+wKpC+yVv3SWLRs8vV8D55Pv7cZNy4cIAwCDONAq0u2Ks3ykihJMAwj8izlmYSB0iNvIpyFjEuGY73Qdh1Bpw2lFN6/u0PTtFBdB88lVsF8zw3DkD4DDpVc5i9HVVVoatqlh2GEUQ/o24bXqOPSedBKoW1qhGGIFc8LKn7Lr9dk5SHfg4c0SbFaF5CeB8/zUdUt0rxAkScLGHQClhlCzMSmIkvw4mqFsW+h+x6Hw2lZ1wkpcbqUOJ0RNM6UAAAgAElEQVTOGDg/sV4XqKoG1aWEx6ivcRzIXQBQ2Mv3ICUlHAUDR33Pw82LF7h59QJ116NparhC4P7ufgn9DFrjUpY4ni+4efYM2XqNl59+AmMmnB4fkMbxwhA0E7h4R5XyMAhQ1TWiLEea598aHfcf/RNf2v+kv/n2/ff7LPb/x18mFrys4lgMYsxEOin+kk08+BuZ+R8ExPMjwu2wdPYnnvrPyrGBtwpS8sBME/1mlnpEYUiJL1dQi5BPDRYOTsczJd/4aCkY0DkOI/SgYae5ETfw9Jw66oHvQ3UdHEz01G07CJB8Y95KhCHpveemF4UzaNvQ9wqB55HxV2sI4UL1PTyfCh5919G6zqW/HkZEHToez4tO3BFUdpoMnXRCZtqHQQDAwWRpZz0n1OYhLO2fxfJTUWwAMqPhkxPtzNuux/F0XuLUz26vsNtu8Pz2BnEULSvTqq5xd/eAJI6he0U5iIlgIA/399Cqx6AHPDGhJ81SVmhR1yOOI2jV43wpaZMxTbRXz9Il9+5LF2EUIwgjDOOEYr1GrwbGx0nUdY3NZstfMIHj6YyeOQeUktTY70+YADpuw+JyPOP89ARrRjgQyLJsOa107BQg2Ce79Jp24TGcT2fKG8TRwodwhECaJnDsBOHQylnrAU0zt/haGJbhak1FqPJSAkJACoFR0dCy6/XyUgnDAL5P/MKbm2v8yje+jmEYoJoG1fGIpu2Rba/gChp8JnmBcRwwjHQSnU98w8Drz9H81p//d//D/pd+ADDl928Kx6k/th48H5dIyGE5oUU9byFoSioEE1CCALAWjh0XSOfAD4MoZErQrOtKE/57VMaYoSFlWVFjTym2FZHTfbtbfyALM6bMlXIh8zZth3GalodOxD76qiFLjAXgB7RX7fVIQSUm68wIbYfDT9IVcCV94YbREIBDaUJgc/XQWWSnQNd2aOoa682GcvFhgIFPARPIa+8FIePGFaq6xThZOF4AyQqxl69eEAfB8wBrGJc+AUKyHo0Q6pYn88ZMiJIEo6GfURgSKLPpejwdzqjbDkkcIc9Swk8phSLPcLNdI5mruQzV9HyfoKZCwAwjA2DoZ34+X1B3PRfCDKqmwdPhhF6PENKj8A1vHgLfQ5ElOJ/P1HPgavFkRjRqgBUu8tUabadwPF/Q65F3/i6UIpTWw/0j+r5H0xJBN44jvHh+SxyBQePx3Ts05zP68kJ1ZXZSzp/NOAwQCou2bvDu3R2udxu8ePkceZ4jW61xs13BswbuqDD2HTS/6eMk5pWcu6x6QwZ5mmGEHieqOQ/j4igYuwaHu/eoyhJZUcA6AkmeY7Va4cUL+nlKz8Obz38EwzHfpiUyFcyIsqoxTNS1SeIYUjioLhRyipIU2+sr9F3bdW3/c2d4P/cB8Jf+3K9+5kn3l2IFzv8JGdIxA0HAgR/iyhs61hraZcMR6JVa7qyz1cdh5Pa8DyfLDGXULROFZylj3/dI0gT7wwnnc4m79w+IAh8ha5QdB2ha0j/PqzUaOI6wfCKRvo9eEcBiztQ3Vc0dBnobj7yu7NqWEFSuiwkuNEsy5qz2xIO8yRhMduK4scCgSevdd3SM1uMIV9B6T3oeIEgxHsf0xqHCj8WoNdIkJgfchYomnu8zXLNHz5Nyl68b40i16GfPbpAktJtWfL+82u3IA8Bx4Fm7NnMIT6czBjOiV4oegr3CdrfFaAyOZ6LiZDkBLufZzVyh9jwKbgGAHgb0A0XC/SCEw3+GYUhc/ePxCMuWm5kvADth1AqX8wVd2xBRh3/vfpIgiGOEgYc4TeAFPqI4xvF4ZtS5gdEKn37yEqf9EYNS0D3RmZRSSwBqmujXk60KUJPDfjBST8SdzNIYw2iWUtL7d+9J/jLQi2maSCu32WwQRiHihECkehxhzbjU2l3JDr+mRdd2uL6+wqAUHh8fcX17i6984+vLFS+JKYqepAmsndA1NZSiLco4jri6voJStCVbFTmi0Ecc+NhtN3Si6/Xv3h/L7/xTPwD+5t/5beMK57/9RRgBX94GzPFewXSgYZzoriIcmHGi/PpoliO04OaWJ13GRklkWUrJJ8+D55MvYGJF2DRZvjYMGPUA33OZEeAtpRk9Undd+j47/GjNpgcqKQ2DXljugMNwUoXA91lfDhKHhCG1AAMffUcQjfkp7/s+dR0EfeADj4g7fhAuqzlKI1pSZ3EOfIKDtte41C3OpzPKsqIHjCAiUtt2cCURiuawlLWsSBsGlGWFrqOjtJkMQt+H55PiemYo0vCR3vp1WcEYg82GGmIeDwa7rsX19RW2V1cwZkLX9yR8hYOBoaJ9r3A4XdD29FBZr1fkXHAFjpdy+TKbcYDDRZs4IgPO1dUOQUDD1ciT9OFOE4QRIeAi/vOhZB2tHOE4JMi4ucHVbktzAD3g5uYa690WflbASVeI1juqKvf0ID3sD4jjEL7v49Wr5/yQpvlQmqXolUbXtmyJJomn0hpX11dwPR9Vq6C1gicl7u6f4Achb7Ac5FlK2YamxXa3ReB7yIocT097dkXQQzxJM9qc9IQHe3h4RFs3iOMIvh+g73o8PjxQeEpK1Lwy7boOh4dH/PjHPyFuY9NQFkZrnE9ntE2Lz3/0htqMwqXV54VkNH5EGDbhUr4E02RlEP13//q/9x+bf+oHAAC8ut38LVeI9x/75p8fCGaimuo40b1UcINtlirM2WYh6UNprIUaDLP3eqbwUD144HqpZMrvjP6eM/ouI68ulxJXnA+fa7xN3VDZhnelgIMoiqhOys3FcRgokz/S26rradC22ayX1OHIttu6ZqIt5659tg/XdQPXJZOQ5drs/O8iKAh4WlzRv4OZiV3XoWlq2Gki3XfdMJ2IEpIzP2A2Dc2DUpplcOGEAZFaazRNA8BBksTwfG9pGsZhgO26QNO0aDsK0eyf9kswiuLYAbI0RRhFuL65oUQfaBUnXbqvusLBZr1arjeu9L7EfSAuXtu0jLJSnH/XuJxIrCmlpAhtHKFXCmFIzcS2bdHUVHEFb2BWmw12t7fYPnuO19/8s/i1f/kvIr56jsEYlGWJy6VErxQ86WGz2yIrCvhBgLrtOVhFgzIpvcWcOwwaL148x+72GlGW4tXXfwXFZgsL4Jv/4p/D4XSBUj0OhyO1Qj36wiqGdKi+R8tvc98jgW3XdYjTFOvdFQtgK4Bdhg+PBESNE0LU1XW9YMmPDw+ozyekeY6HwxnFdkvzsZFCSYEvMQ60KYgiCvvoYQSkj3R3A7iUEKybDsJxHqp++J9/oc3dL/IPfeezb52T0PufPqYYNJuDRsMHK951L2okVzCdhuqzvu9j4PWHJz1acbFJuOvpw0N6MdqDe56H87mkibakPa0MKP/esOxiMiOe3V5BK4Usz1A1LR4e9lRWsWShrRrOAPg+Bq2Jozdoqq1WdMTd74+AQ5ltwaUnctY5UGrAdrOGwyef+W09vwGkcBa3e98rMiLVDU7nEg7Hh+f7oxpomNkrhTimdaV0xRKhnrMAC6XH8xFGpKHK8wyS9+WSqTkODwdd6cHCwX5/wNu372Eng5EfJuMw4nK5oGmaRW4CAE+HI6IoxGpV4P7+kcJGQuB4rtBrEnVebdfYbVaoGFVNNKMYWmlSmHXUaT8cTrAgVBxVm0d2DOglKdm0Heq2Rdf35CewVAwSwkG8WuPVN76BbLNBlBfY3twi316T59D3F6ux9DxA+lhv1lDDiMPxgnNFnY/9fg/P9zAwaCaKQhSrNQlW+fRmrcORYkoh3t5eoyxrSCkRRiF6rqzXVQ1H0CZpu9sgCENsrnY4nkp4vo/tbgc7TdjvD4Sv46Fzzo4Ea8knGXjeUi8GgDArsHv+HK4kmYgaBqSr9ULM9n2ShWpNJ5VpMpiCBOmrr2IwQBBQF8IR4jf/1b/yHx3/mT0AAKBIo98QjtN8LCNgNvqMo2FLDrifb7lDT9HYuc02jgMJIO1EZZW5K8BuQMvT7nEY6bgDECiUj6xZljA+K8Bkgbv7JwYqGGi+0/t8NwYsGWt8Dy+e38APAhZ1+uiZgOP5HtI8Q1PXdDxlbflkLaLAR9M0qNseQUi7/LbtCV/FSm3hUFS4qho40oPiAd3bxxP74RNm9HfLiWgY6KThMhvBcRzi5nOYSg80jJS+D+F58BkMQTxAFy7ruNpeoVMDIFzUFUWbgyBAGEVU0IJdZgsTD2vzgii+vTYom44gIQPNOq6udgh8D8fjCYfjEbAkwdRsQhbSg+MASRoj4j+7eYsRRRGkS9efrusX3PnlcsHj4xPgCJwvFYyl9XHANelBKYRRBC+KkSQRMI04Ptzhi+/8Ad5+749wPl/QKY3BGEAG+PTP/BlIP2AbsIe3jycYx4Xvh6iqhqk6NChdbzdwXBfNpUR12ON8f4fydMKz22t8/9t/DMlN1YQ5BiFvQxZE/aDp5TZZnMsaxXqNtCh4uFsh8H28evUKaUrzlXy9hvSJA7HZbrDebChFqDRkECJ/9gJ6tEiiAMenR1xtt5gskO92uJQ1OvZSrHneEoUhdi9fo60aSEvxcTUMSk3Ob/zC2Z1f9B9MkvhbUrq/89G0YDYCW1i+b2OxybquC2snxHG0TEk1vwWlR/dZn/XPM+2GYrkWNcM1hSBS0Hw0Hwaa8M6NvEGppQTjOA6iOEJZNVQUKWtMoHTduWpxdX2FNMugtcJus0LfdkuvYb5Xe57HOQEKu5wOR1wuFwxKwY56mSsopSEcYJyYeRD6cDmAZBwHEALbqyuo0SCIAtzebBcMFkWKFd+TvWWF5zgOJM9KSGfeshNQMFGXfp2uS2+ZwPehtMbpdIbDCvMszzBZYH84wHMJ9T2vQ3dXV0hiIhg/Hc64VC3awSJif/1ysplhrtOEJEkZ1DKibRs87U8QrkSSJku0OohC+jywCcr3fSqMOYJlMQ6iMICZgKrpMRraDFhr4bgS0gGa/RNO+wP2d/d4/73v4Is//D2c7t7j/d0DzmUNxxFwwxhhviamBbMg8jzHardDyCTkvleL07KpaziwCDz6nHRNg1WRoVjlyNIE0vfx7NkN6qZdTEJaa1r/gXV3rsDpfCHkOHMUjocDpJTI82ypAUtJfY44iuhnJgTKC9mSsjSBdIC7z76P5vCE8nSEUiSvjQIPp8cndG2Dly+e4dXrV7AAijwnFF5fovrJ9yAFYCAwQfzO46n8/X/mD4Bvf+8PJlc4/5XjfBwwdKYCC+dDBJgQ4ljWUnPTj0w4giahdlpsPrP2e/YOaDbu5oxR7roOxhAUZL8/fIBU8E49LwrEcYTtbou2bpDwoIhYgj6kpGBJ39N02Fqq41o74cTNroA3CBZAlhHOWnIRyAwDBk6OedKF71OX3JUS/szbiyJ40sE0DtBdh9fPr+E6QByGSOMYuu+R5+mShDTjiK6dAZ8jpEtzj4z35VpT3XYaiWXY8RVj/jJrpRAnMdI4wvlSw1pLK8lxRFVVRFX2qV2o1YcugeMQqGK9Irfg0+MjijzDZr0iH0McL+blgZmOcwMziSnCXTcdgjDEq09eoet6ugczRmvmL9KDXi3Gos26gOsK5FmCIkvYUkQglL4q8eYHn+EH3/0efvTZZ9i/f4vucsbleETd9jR8DXz4UYx8vYWaHJRVDT1ofPrJC7iO5aCOQVOTBNXh2ZPWGu/fvUddllAtVburC2G+hr7Hmzfv8fT4hCRJlpdQz5VfMCB2VrDBWjze3TPSbsDAxSsz0O/ZGoPT6QQpSQJjpol/vhOqqkLkS0SBRBCEnFZV6NoO9+/v4HsSaRKjrcl3mOUZ8iwDdAcxKkCIOYPwX//Fv/rzh38f/QAAgH/+V17+79J1//CXWQXOX+6JB4G9IpvPnFmm2i+t9ASjnB32wGut+EhNbAAwSiwIAu7I0zAvDHzqUrsu5biZgDuMA6qyhpRkE/IYijHyWkq6Ar4UOB1PaJsWTVUChkSngq1Hge/Th5LZBopLRLvdltZS/qxAo+KNnSaa4rc9/DCkLIEFAt9D4DqYVIfTwz2SgL6snk8ZfOkKcg5y7p3eXBKa1VBlVS/H9U5RPLfvezw9HcgqxKnKIKRTlZSSCEgupdXOZ6IEeVLyXZ3WrL4fEHhS0XAO1mKVJ3j/9i2+ePMOfa+4lGNQ89XMcEyYBmQeJmY+aE7xjTzcdAX/PBiMMjL5OC8KrFYrrHl1tcoSPL/ZQTgWXdehqmo87o847vfQfYe2qnGpWhzONR54aOmHIULfJcFoU6O6nLHZbdCOE8IwQhp6MF2L8nLBONLsgq6QAxOIDjRUFQ5tQITgzAh5/aKQsNpSShRFjqYhA9P93QOamtKeL14+h3BdnM8XgnLcXCOMYjo1WYvL5YymbqE02YEH9jR2XQdHuMS4CImHSaxKGsIOw4DT8QRXuvzPU1hru91yoIwQeBASXhBhGMz3q6b/2x/zvfyoB8Cnv/bNLov8//JjicEfZA9gkq4AMOcCJjRtT+EZY+EIDxASlqOsDvP3mrbjIQd9AYVLb4fJTJS9VwrSsct0mT6EdHwdlF5wS57vw3MFjsczZBAsq0U7WWw2K3RdjwkOBsaPB0GImktAc5e+vFyoBur6sA5l6Ds1IFutyCUwzmvGEa4z9yEcwJVo2p4KI2bEyCQhKanyu7APHFqRNi1NmNM8X1iEZqImH/H8NS5Vjcv5gvP5AtcjtkFdlZBSwIwDR6zpWpCvqJ3nCgdJEtGfp0chonEkJ9/heEHbKezWGeyokSUJul7hUtU0SHMdwE54fDpQDHkiNLkXhKiqClIIFGkMPWjs9wfWobtL+UgpzfMgQAQRbr72q/jKn/3z2Nw+R5KSxUcNIyzzCz3h4FI1MBYcEKKTw2joAZuFPnxJa7FwUvj89/4u3n/2fWS+RCgd6Jauij5n/sOAYszTZNA15DmIkwS9HuH64fIm7boeLrH0sNpsIH0f9+/vCG5qDM0jHIt8VSAKA/iug8CTKLYbGiz6HqqaTmae5+Hu4YFFHoqcFAysKcsSrhDIkxAd49mzPEcUx8RSPBwpmJVn0MOAFy+eQ3oSYUiCU60UzdLgWEc4/3k7/mJzul/qAfDf/w+/gWe71W+54uPsQUtN2NrF8CNdl2ESZnmjOwBpsAQNVvDlawMXduZGIQB0Si+k2YkpK+DA0LrIqIzTtMvG4bA/cpho4iKOh/W6gBB0rWiaFlfX5IyzHGOeWWuUMqQvrOV4qeVfy7x7V2rAbrdduIZwHKrxcpPN57KKUgpxFMFOZCyep/wzhXFec2ZZjq7tcDmfiRbk+/B9Ou46DuiYOQzoOrVEhV3XWxh5SUzFFwsHfpKi1gbFZkN9AIe+mHCA/5+8N43VJbvO8969a56/6Qz3nr7dZKspWqSFxJISOVESR4CExHDsIDaCKIliR5IjIbAoSwwM27CFMEIQZ/oR27JEDY4zjw4pyBlgSBYCxZaNOJGlmBRndvedz/nmmndV7dr5sVZVtxyag8huEvH5QbLRuLz3nvNV1a613vd5hmFAEATI0hRe4PFMxUWrFCSzDsqiQBSFc5GI1pID7nZ7alrCIIwiXF9dIvA9PH12S1kGiwa8cRzD4/SebdvwXA/CjChOJ5xvn2HsOxwPR2Yq1BAQ9HrmkIug73qy3VoSaRxCD2RHDgOfClS83m3rGof9Hh1XrAdNidJTXgKWhShdoKgaJHFM37NhQJRluLy+wkvv+jqMoH36/ftXCJIUYZwiSyKKbjsOrm/uw7KJ3BRGEe7udmi4NGZJQVahqkRbVbCFgdEDdSlcIhwJSSBZowkHRgwG+v53fEM1EEjTDFEU4sUXb0iPLiTiOGaDdg/Hc3nQbdA2CrbjPhTS+tC3ffcfwVt2AwCA3/+d37rPIu+DXww09M2DQHBDzrypMCQEDQhpUKhnWIXqBna/UYdaWja7/OibRtHYltny9AQKo5iPag46pXDOC6w3a+bs05FaWBREUW2LMAqJFTCOcPkdUvN60pIUhEmzlPwBjgOXA0ZlUSJOYiIcSQEhqH9u2TZCZu1F/P+tmfJL/XxaB3o+SUWFFHDYRiwtCWsWX1AnoGo6CCmolWcM8ryYe/+243KhiS6ui81qlqqciwJC2rNy23UdJFmGbLXCZz/7OsKIwCPBhJOyLKTZgoaKTQMBSQBSpWa8E4WdepzPdHwNfB/vfOkFYiZWNXb7w0xRGkYKU92/dw1jQE3MfiCmoesgThK4roO26/D8yVOU+x2Od1sc9wcGeBBg1Q9D+EGIi6sNfN9HnCSQUuLm5j5ubu4hTSIKI9kWkpj670NPtKRh0CxnpVfMJEvhBQEcP0TVKrz8rq/D1dUFbNfDg1degeWSoOP1z7yKIi/wwoMbeGEEO05w/6UXCW/WdwiTBE1FroWOX6+eP31GqUvXh1IKEgbl8QTV0AYoTVPSkNs2pKCVrud5EBBYrZZwedNzPuczXKUqSzx79hxJusD5dMbz53fIiwKe5+HZs1sMPSU786qhOrjjQAvxM//l//Y3b7/U6/lLvgF84Md/Gper9D+zLfnkS9kGCP6PCZw5ueimnoo2Bq7jQCkiqXRc0JmevlQFpchuklAfYEoE6tHAcckEHHCabOh6dK3i5hmryrmaPGm3bYuGgM0UoGEwyFTftW0HVdOyn4/MvoaHWQ47CcoixzhQMEhKwZ0COhUEvj93H7Qe4XkepCBKj5SSiMQ8N9D8NMgWC8AYvPDC/fkWa/N6jQo/HcqCAiRxmiKKY4xmZDNSD63pNaGsa74pRcA4AEOHKPQxCgE/jFDzv9ejRlNXcBwHQRjMToeeFW5xEjF9WWCzXkEKAdX3JAyVoJWjT1iycRznzUxVVfAD0n2R7caab4au56OqGqRpDMeWsIXBfr+nkxdA5ZyOeBC96rFcLlnA6iOMAt7hL2juokc8e/Z8zp14vjdr5dabDaI4nsnKr7/+GKvNGoHvoa5rrC4vka7XuLvbYewU0FNRqhtGdEZgdf8FmnOMmt/HD8hPB5RFQYqxssQySxDFNLydVF6SB7bDaHA6U0gpiiO4voeXXnqAEUC6XiNdreFwzbxtqWQ2GoPA93B1fQVp2/CjiBDtno8jOxvTNEVVlAiTBH4QIEmirdbjX/rAj/803vIbAAD8i//sP34bB+5PiS8BFkoXAiWt9UjT9GHQgKAPxtysMyMDRGlQAiHQDRqQ5A4g0ACx1Sc19pTFlpKe0Iqdc61SsC0Jn1HNnu9Ram8Y0Q8GQRgiTWOciwqDoZz7xOCbMGOLxQJN26IqqzkM0ikCZ5IY04XDkdGu6+D6Hg0KR8PHZwnHkrz6JInFlEswZoKXUhio4aHcxdUlI85aZMsFhACvnugGpbVmlt8APwjQth0810HbdsiyFFJadFMxAsMwkj47P0OOGs+fPKMTTD8wdLXnMlWOsqiglCLwStdRK66s+MLyKVHoeXh2u8P2kCNdLOCHIYaugwDxCaQAgTOFQKc6VHVNBpyuQ+hTMu50zuGFEa7u3YOBwOOnt3jxpRfJmBMQ62C1zFCWJSzbQlmWaNoOx+MZdUlgTCElNpeXuLjcIAy8ea5QFCVGSGTrNS7uXcFlr0CnFF588QUEYYAnjx6jLGscj2c0ZYWryxXapkVdlRAYUTYKq5sHiNcXaNoWu90BI58CJnqSZQmuATswWqM4neB53vzKqrkQNRpgtVnP3EdIC7ZLkBDX92F7PqSUWCwyqtBryr84toW6LJEmCVd9qRPgBz6iMECvNdOLbfS9/on//H/+609/K9fyb+kG8IE//1PwPfcvSuuLiwebuRRj5nQcxXatN1x15g2fgGF24MjOQMmVVmHRMWomAjHWehqQTUfkqW7sex6kTQyBSTCyWS/Q9ho9xIwZbxS9ZsRxzGjtYT6haD3CD0Mo1cFzPbi+P9/tR62hWR7atS2RiIoKluOQ284I5gYQJnocDdF+PJcpuQoOv+MaFpwIISEgcDocWWxJIIksTVmSQSukKPRRcSx1HDWXZHgw1PdznLeuaxgDlGWN1TKD7hW2t7dzDZpEKeTkA8M2yrLEmp+UeVmh4bpy2yrYUs7OwYF/L9JhU3Cp73r4TPOdcGCaNyKe62LUI1brFcIwAIRA3SrcvPgAtuPgyfM7rmETUi3wPRR5AUgLy9WCa9AelqsFgjTD/Qc3EJYFreln6HouyqqBE2e4fvll0pRxiSUKQ3iBD5cTdW1doyvOGPMDmjzHuahQNVQmM12Lrqmxfe2zyA8H6kT4tI1p1DSgJDBtGPgwusc4dLOjAKBU3mKRYuQH2TAM8IIIZVVDsM5NKRKn2ryiHMcRlm0hiiIcjzQPOZ/PM47dtiz6uXGhykBgFPJZqfqf/cCf/ym8bTcAAHjPN7z7me/YP/HFCkT0aGZgiBr0PBOY9qECYubdT6aZqbk33SBosGPNOuwpHjxoDT2OOJ0LWDZ9kyqOpw6joZDOSMfDumrguw6Kcw7A4Ha7x+XFGuOoAR7o0Q+CVoCqbZAmMVzfw/54IuqQICuQNgZGCJyORzQtGW+0HtE2LcVRW/pzGgOMEJQ6q6mB9uDFF2gV1XWI4hhlUaJtW4RhgOfPnkOpFp5LU/2u66H4vW80RBSypMUW4RZJknDdmm5GqutJV9Y0M+KraRqUVQ3fD1DXLXPm6fRxOJdQHfkR4piah8NAceE4SbnGKmDzIPIek3SGSeQqJLENGPCitcZuu2W9uzv/rA9FDcv1kCYxApd6H57vQzUtijzHKkuI4rRe0hylG/Dk+Y54+K3Czf0r9F2H/e6Au+d3OB5OhIRXpIxL0gy25+Od3/gPYxgl6rLE4yfP4QQRdfKVQnE6MZiVTmVPHj/F7fNbqunqEXEcoTgd8OjjH8fjT34C0EQccgM6/di2haIo+X09mINMUUQwlSIvUFc1cxeGefslLQt+GEBIa5bBtHVNurO65u/lyI1Wwf4HgsCAux9+4EMICx0X67q2MW2rPrg9V49/q9fxb9ZYJdMAACAASURBVPkG8Au/9L/g5nL5QUvKz3xJeQBWcBlWfU/6LTANqGf7zWQCkpLyAySYINbfoDXz/GjCOwz0365jw3G9mZ3vODZU287G4aqsMLCeidqCGr02SNMYnkcarKKo4AchYMRMNqLePO3SaUdsw/c8CGkhjkIYrWkwE8XwAsq1D3pElCSkfbYdloEopGkKpYh9t96s+M80wvE8+D6t0owhdZkBgR9Gw1Fqy4IlBQKfth5SYA7x2Fykoh2/xQKQCK7r0unHog/u8XTGvfv34Lgu5fdHDdvxcDwXlDzzPYRBgOJ8ppNHEjGhWWO/26OuK3rv58afYPgrYbAj2vQ4DpOOQ1i2TRYbrfnDbdApBdU22O929KrQdcjPOaKY4CFhEJAws6AG43a7g8Uuw1YpPHnyDHXdID8X2G+3sKQ1wzdfee97EKcJ7p48xG67h3R9ckfaForTEcXhiP12hyKngWZVVXAcG3d3d8gyUqsHQQhXaKi6wtXVBpYUKMsa0rKZPuTD8z0eJHNDtaefg8evgEM/0Guj76MsS/hRhDhJuJjloh8G+FEExbMEw1usfuhp+Ks6IhN3ilKcjkM3FABeEBC4RqmHTTd88J/6Qz+Ct/0GAAAf+/Tf3buO/WeFEF/UKUDwPECwIajXREcVgqqlEwh0GDQd3fh4L/mCFaCa6HTXJV8gvV+6LMgUXMjxfY+kopJ2+kKSltvzPN7Dk36LeP7gD2YHA0M8/tljKCFYA2VZNqI0mTn25k2eQ8/zUFUVssUCtk0/rEFr1I2C7brYH0+omoZ24sNIwFHGgt3d7ShmWzfoFFl54zhmZTYdqft+YBknnZgAoFUda74GLJcLZElM/z+KUOZRFCLPc4yjQRJHdBoYBtRtS6cEVmj7vJk4nc6omxYNzxImJx29ZxITYOIFNnWN4/FNxCK2PRm+GQkhcDwcaWgbRxR2cmzUDW1k9rsDnjx+ikePHmO/3xMSPkloLtF1ePTwMfH/Am+GqDx/voVtUUX6eDxie7dFWdWQXLaiPohBX52h6wpSCrzw4AblcY8wCpElMXa7Hc1QGtKRX11f0XbGdWGGAbvdgZXu9Pnb7w6o6wbFmRwFRV7MMwgKjlXomOeneFZk2TQ0TtOUnQPhXO212RRkc6TcGDOHkizL5lNYDMdxUJYlDZwdhyLco0EYJwTQldIMff/n3vMvfP/dl3MNW//2j/6xL+fX4yf/wgc/2qrhnzPGXH8RyaD5fWH6y09mEz1Qln1amU1xXMUXu+vS3TCJY46kBvyhs8kN8Kaj1qA1oigm6ENZ8XG8g+dR8WJi4tVVNYeRyrJBkkSQhi6Woqx49SfJZMshommSHYYBznmBgDVgNFluYDnOfDxeLhe4vdvCsW0sl0sU5xwuo79037Evjm5aAT8pLIaNhmGI8zmHGUeChnZE4W3aDlXdYhgNLlYZIleiKGtecWo+qvqM4B7no+Q4dIRpG0cUVYNFGmPUA+q6Rt0qRGGAiD0Ih+ORFN22Az3SB3jk70vHViSlOpRljZGpzoZPZbbtQHWUthy1RhSGOJ7PhEULAopCK4osTxuDpm7Qqp4GkVWFsmpIgMnsQJtviHrUTLqtMeoeSZpgtVyiqUsEgY8g8IFeYf/0CTzXQRRG8F3KdNgWfZ9m/bvn4uJiQ/mU0cwWad/3SDzLYaF+GJCfC6iuQ900WC4XSNIE29stlKLTpbQoYRqEITUv9cBkooIpyR53IkKEqzV6IWH6Hn3bQJgRUZrOkpH1eoXddofD4UjGoTAg45WhobKAgR5GNE37kUr1P3jvt/+j6su5fr+sEwAAfPM3/44qi7wfBTB8KaeAOf7LsMgpG2DelCJsVUflIduGY/E7L5ds+n6A5DKJ4ZjkRLql7rdkcw4dxyYz0WKRkTuNj/wwhuUfZu4hWLbFnLsOlmUTVMSSc7zYDwKUZYVFmqCqaiRZSvbWYUBZ0A+97+h4TaRYkmz6vou8KHA8HiGknE8i40iSDd/zeAtiMJoRtu3Adj1OPtLq1HVswlBzc3GUNizH4W4/AU+nwtDhcKIePgA9goM4Npq6RlXVKOsGVaMQ8F56EnIKQbFYY4CXX3kZt9s9HH6qRSHNEKqa1qOWRfqykQd657ykSbwhmu7pnM9D2LqqEIYhf6hDpFmGKAzmQbHjOBiZosO1VnT9gOV6RaxAxnH7gY+bF19Cq3p02kBaNgKf2oa2JbG92zEclt7BgyiC4wd4vj1ASgutUmgUPbWrqkLbNDNtmgaN5FG0bfrZNy31DbJsgdVqRadMTWIYx3bQNIq5FvSZJry9wTj01K3wyEDtBz4hvmzKg0jbghYSRlqoGwKR7PdHgIU6URwhCkPiCw4DaeUsGxDQbhD8mVKN+Zd7/X7ZN4Cf+/n/Ht/4rgd/1bGtn/9i7UFvZgYICLSqh+cSZXdkaChYHiL4jtExQUWwUdhl0McwDCz9pFXaZKydct1JQqUWovk02O8OpGA+nRFMXLle43KzIvKQQywC13Xp17kObP69ojDA+XTC0Pfoug4OF1mauqH1TBShqRsWaDpoqpqIMsagLgpEYQDVtmgahb7r0dQNskVGSu0gIMipUvAZE94pRexALinFSUzv1D6pr6Rt48R8+nHUZPA5HOF6Lnw/wAjAtl0269BWg+zKI/KiwNApBJ6DYdAoWcvmWBZZkthX8PzZLZKIQJ4C1EWgboQDgHr4ddPCYxjroKf1Yofb7Z49DQ6SOEaSJhACUF2Pu8OZX1XEDDgJfI+Hf/3sM6Q4OKUej6cc0raxudjg4mKNxWrJIJaAYtCKasZSSvRKIU5ieL4PrTWKokTb9ZCcjbi4WJOezvWotOW6WK2X8H1/JhlPSVCyMftIkpgoSIfTnM2QlkBeVgh8j0+29Gd1HI94f8ZgZA9gpxT6toGqalRFSevsJKHZV6dQs8+hrkqEPr36aMa9DVpDdYrpwuMv7A7nD/+Tf/CH8FW/AQDAL/7KL3frNPgxKb8wPHQKBmk9zqw/mmCPVELhFZ60JP97othMIpFpddL1/awBnxp8HDhgeejAlFxKtvU8Re/7gcoWvocoSShGy8Gdsqq44w1UdQPXdXDYH+hisyxIyyK3O7++nPNiZvTP1ebAZ0U0wU861VL9VFJW3Pd9xDHJIIkYUyJOEhhj2AlAR70wjnD/wQ3KqubGHWHJbNvBMksw9gpVVUO4AQY9IonjuaGmWoU0jeHyQNSy6bWDAi0DosCfAR1hFCOMAtgW0ZCUUvAcG5KhqXqYzDY0iaf3e8B1HaRJzCJPD1Gc4MGLD3Cx2TBdSbBubcQiyxCEAa4uL7C5vMRiuYTn+WhVN89xpsBI31FLsWnaGf9WVhVOpxyOJeA59DOIQh/SjIh8Dy+9/BLqtsX5XGDoOsAQ6Vj3A549eYbt3Q7QA166f4X1coHFIkNb15BCIM9zIjr3pPUatEa2SKmYZRO1+ubmHm5urmE7Nk6nnJBvrk1UKWNgS3r1pGO8w5mQFp7rIM0yCIt8lEJKjJ3CUJcQIw11y6LA4e4ObUP04b7vEIYUGmraFnrUfPLUSJZrHPbHSrXqT33rd//R9itx7X5FbgAAcO/y4v9JQ+/HvxRUmBnNfDLQ/L/pqa7nRF7XD7TSqhsYRjYKEPHXdV3YtjW/u3UdEYUGHpINwwAxXbhRhG4YkC4XsGwOnPAeO4pCgjZKCWMEtMG8FaBqsuGjHQ0Mp9WcMIYYbYISelEco+86dEph6Ho0ZQnPD5DnBYwBDqdiVn9FcQjX87j11XF6sWP3HdArBYy0lqqaDlpIuL6P4/E4o7uGfsA7X7pBUVaI0gyAQBwFsG0bDx8/wzAMOBfUEIzjGKe8QpLEWC1SWAIYtIFjS4x9D8+ROJ5OqOoKSZpgmaWwpZidgwZAN+h5rTdJXCfIiOd7cF0Hfd/x05D+LJ7romMDUFU3zOOj9dd6vUJZ1sxEIJNulmUIferuq35g1RudFtpugOO4OO33+PTHPzFrsC3Xx82DF3i4ZiOJqZ352quv4nQ4oMgLFEWJ5TJD1ym89trraLsejkva7Uk7d9gfuYZMyrW+6yhk1NNxv+8HSNtGvN5gfe8+3xRppToFtM5FBcfz4YcxeiMQxDGiJEY3jAgyivZ2XYeubVGfzzjc3kII9kRynNtxnTnYprnUJunBaFTf/+ST7envfKWu26/YDeBv//rfMtKy/kPbkh/7fBf9fPTnwE/PYFDBH8hpKNj3w/y/B025biLZCqheQ0g6utOEmUpBZd38prKKnt7jbZtlGwJR6MOxLX4HPNFuXWtCfasOnu/OtqEojuF5PmzLRtOQwy+MQvRaI45CCK7u9ooCPeNoEEYh22loGPhGio2Q22FMH7i6pnBN3/dwOCmnuo5oxK1CkRdomxq2FGx7nUQdEiOn/KSUePLoMWX3B4226+DZFoQZ0fUanjs9XQ1u77Zk/OXXIYJZ2CiKAlIY+B49dftec3CopHdYQwPJgYe0ecmx4cCf2YC73R4PX3+Ix48eEzewH+DYvCIdRzi2DQOBz772iLYOnkvKsLpC2TSo2w5d32O3P2B3OKFRim/ehG6zHfInpGkCKekUEIYBI7Yknj56gvycY7HIZgSd7im6HccxkiigfMXzW5RlhSxNf5O4w7Zp4r7IEmp2Ni3apuWLO6TKubQwCAtBmmJ5eYF7r7yC1cUFl9TeaLoOfY+irLFcr+G6dCPUw4A4jnA+HDEyWFSpDn2nWJWnUeQFOgaY3t5uYUY6EXfDQOElz0N5Pn1GQ/5Hv+t7/y3zNXcDAIDt9tXjIg7+lBCi+2KGgVJMtiCaBUxDlOl4SiEgC4OmgsjA8kozjjTwU4qx4gPiMITNVFTboVcJy7IIMd33jMcesD/mPEtglZkUMxCU9tkUK7bsiflHPxTX8+b3y6Enqo0eNFzPhzaA63uoqwpRHPMRmzoHm4sNPX257KEHPX9gFA8spw6CHg3OpzP0aBAzuadTCqtFikG1OB+PcF0H925ukOdUSoIBr59KbC4vYPhY69gSjkO7+tEAURjMvsROkbKM0ngWyobqtUmSohtG7I5n9MOIxXoFxyHhaZZls20oSVMknH8PgwBpkhBHoaohBLBaLXB9dYEkjnB1dUlHaWbm726fz6z+vCgJwjJo1E2LgiGrhlmGMAat6hElMdI0hhQGeiAFVhT4ZE1SCuftLY67HYqyguTthet7JKM1NCTsB1oz3rt3jSzLyORb1XNTdUJ06WHAdrvDdruDa1twLM6mWBYevPMlWI4LIS1snzxFXlQoK0J1kz2ZkoCuY5OHcZHS6bbv0RQ5hqaGxXF423Xh+5RMDHwPqm2h9Yg7Xm1GSYooilgjBxwPp77T+JPf9F3vu/tKXrNf0RsAACRx+Fdcx/7LX/D4/6aOwDT1puKLPcd6LctmqwqFd/RIg0H6tSOiMJiP4z1DJogQLIh5N46EfqrqOYhi2/RUFMwjmMAj1ESj/Du1+dqZ/JrnVIWlwA09fQZNhJdOKQS+h6pquPJvoWpa1p3TD3TiuydZQnozjgFrHmA2vCJrVceDO5tBGpJjpaSRntZJ+7s7RFGAvu+xuVgDxmC33aGuKFFGLLsRZd3OIBaKEZOp2HUpPUkmGg9dr5GmGVrVIQjp+LxYr1BWLcI4QlXV2N7d0Y0pSQn/zYPasqyQpgnW6yXCMMBms8ZqtaTVrefBD0OsLzbwwwDvfc+7kaQZ6poak44lEQYBbMei1ZzvwXJcBAGd0hwWrrgOOQ+KsqYileNiGA2iNMUIgcUiw/riAqe8wsvvfhccz8X5nM8NQgjg+sEL2FxdoihKHI4nCmY1LZmdLRtpluJ0OuFwOEIIMWfzKdRlsNysmUHh4LWPfwJPPv1pqKaZjT6b9ZJyLKOGGTX22y12dzu0raIT3fk8G5Avrq8QxjFOeUmvwaxp7xRvcRwqejlBiFFIHPMSxnZ+rtX48Ff6ev2K3wA+/epHh1duNn/CtuQXjCdOqnDDQ0HJQAzNnWgSVNKQb2Q1mGROu5QWek21T8cmlv6UHuy7Hk3bQliSyi62ReRhzyNz0Ei/Lk0TBmv0LO6ktGFeVFTRLEpcXF0wp79GEAY0wedQTs/Zgwkw0TOj3nFs6KHHYrkAtEYch1gtFwiDAHlRQgqBqihxOJ2p0ON7qKoaaZrOjATLtil3YFFGQg1Ul+77nk5CeiAevjHwXQdt0yI/54zflsT2sy0cTzkcxlgBBk1doywrhIE/W3sMPwUt20YYeIijCKvlAue8QF23FIX2PGIhjAPCiPIAz+92aBqqx/qei9Vywd4+mnXUdY22aTGMwIvvfAey5QIXVxeclXDhuy7WywzveHCDmNkFSRggS2JYAoijAKtliv3uDs9u77DebHB5/z68IIRwfViehxfe8RLSxQLHc4HdMcezZ3doOR2ZJDHSLMXVvWuMesSzp8/hsxy0VR2urq8QRhEWqwVeffUhDocTtB6RJPGMmveDkLXfPU67PfLDHse7O/gOlXsmxkNelBiNQFFVMzq97zvUdYWqbiBtuon3I2AsG/vDkcChbIPq+w7SorzIYpHRUDFN0SmFKIqeqF7/sX/iX//iUV9vWxDoc321+2f5//l3PrJTvf595vPeZMQcChIcEuo1rbO6XsNlMej0BNOjmaOtxpAhR0yYMX4f9z2PwjO8oiM/Ht8sNM0MtB7RttTskgCVMyDh+QGCwJt/z7puCFxhWRCg1dfpdCbmG5deppimGUcm9dJaSSkeBhp6oidZhrbtKDwUeG9ILqv2TYBNUlLHbDAeBpqNKKWQhCEfozWCMCDewKDJKNT1/CqFmVg8GkJm13UDi4tQHvcYtB5mx6IAiU9HPWCRJjgdj2TjOedYpBE61dLfzxA7IIoiWJaFumloWGbTiUIPpAaT3Ips2xaqbUnykS2QrlZ49PQWiyyF79rwLcEshwCLRYo0jUkA6/lYrzKUeQ7X8zEw+yFNM4QBWXyDOEF27z6VtvoOx/0B+/0B49DDtQRaBpEkaQIjKLEnBWDxgC/PCwRBQIbizXo29fgepUnzvITWA6qG8PICAq5toTqfsb3dIoojqK7Hvfv34Pn0ipUkKVzfg7Ro3rRYLufwWJLEqOsGZVnh6v59mL7H9ulTqqezlKZThIxP0pRoxbaLx6+9isR3tRdG7/+lj9397//YP/3t+Jo/AQDAj3zgx7DMkv/Wdez/7osIB3Lz7g1A6ITFmtx7xhh6L7cs9PPenybhJAixmZNH0d2ybuYbA2DgOHT89edJ9TB32KdTBYyZ7UITq15w3HhKc/Xc3c+yhEk+FFsuq/qN1WRLPMD1ZoO2aRDFEau2clRFgTDwEMYxtQyjCPfvX6Hp+hn1PdmCPc8jLkJHf++uU1y8YVSakDAg4YnWw9xCgyBset/RkMli/6LLrw9aD+hUh0WW4pyX8FyPLD6+TxctnxTCwKdXip7SgtOgdb/f4/ntLcZxRJal8ANvZh2QXq1HzUZil9OATVVBNQ1k3wGjhmNbyBYpsuUKm6srXN7cR3Z5jQfv/ga8+K5X4AUhSzHo7+96HlxbIvAc1HVNA9KS8gjFOUff9yirBpvNGuv1CuligfXVFZq2w/b2FnVRQEJgscyw2x9QVzXp07iDsN/tWWDSo23aefMhAF4BSzx+9Bhd16FpG5xP+WxXMsagrls+PVFWIFtm8HwPquvn2UiSJEjSDK7n4lOfepX048czFItJbc+nuQ8o3TowF9IOwv8pb9R/9SMf+LG34lJ9a24AAPDJz35kuFhEf8KxPn9ZaKL9zi8FZgqsAKOmY//Iw8FpTUgJQs3BGsVknJFSf2zhMRzimAI9cRzBkpQZd3nNMmpaE55PZ7gOHZNV26JrW5QllURO5wLHU45WtQT04Ox/HEe8w7YZeDkgjmMeOJK+a2TvXxAGsKRF67owRBgGsF0XFT+JlssMVVmhKus5l9A0zcwInGCkddPOUVWy6ZA/IE6SOSs+TB/eKbIckFL8dC4IJcUNvIYHmmVVIYkjCl71PbJFRrl1RTePIPDpBJNECAOfL/JuFnuURQWX0eJKKZT5GXEYwvNIDWbbFvqmQXk6w5LA6XBEWZQ08OOTSFk1sF0HQgpKy40juQ6lQJTE9DNsO2gDZIsMbUNbEQnMijMpCCXuey6W6zUevPQAYRxhs1mjGwY2PFGabrlaoh80LCnx9Olz2Kw5m4jFvkecxAnY+fx2h6bt4AcBHrxwg+VqMQfAHj16jN3+gO12Tzcqx0HfDRg1EX8d10EcR2hVh2iRzXOsXo9YLBbIlgs0Db2WVU0Hx7HRdT322zuESfZwFNb7v+lf+iPdW3WdvmU3AAD43t//HY9D332fEOIL55UNPdENxyyppDNpsKz5opiQ23EYoBv0zAecPvQRE3oFF3kmH8D0NDEjGYpGpteqppk5/BbruVXbkuxTSqyX2VzYmE4Z+Zm8fB1baoMwRFXVRA7qKb3YtS3iJIZqFZWL+GQxjnxjcmxki5ShnRLZesOvEA7Kqp6LIFJODTPuIQii+3a9RqN6xElMAMmi4KQadfOnrcYEG+0mcu9Ir5HnomROvU8di4TKQlkS80ZCzyexIAgwDBpBECIMKLrbKUUe+6LA/nBEU9MGxPUDWDZx686nMxOSSdSpVYtB0cUrBODZFpoyx+lui/Z0xOHpUxT7HVRVwneJ4+A6Ns55Cel6cKIEwwj4voso9FGWFQ67AzzPowtzmeJwOOL11x6ialrsD2c8fPQUjuPyzZReqYSU5De0JK1/eauTLTIYA/i+j8vLC/isB98fTths1nQakNRKnMCeWZZhs6FBLGUjiFzVNNQ5cByaT3mBj9EIKNXhxZdewNe/+13IlgvsdgeorkevgSAMcDoV2O/2sBy3h5Q//D/80q89eSuv0bdkBjB9/a7f/Xvwsz/9F19t2y4c9Pht80v/54gJT0/3ScYIboANA3kEHIvMqh2nxyj332O5SFHVDYEZuGkoeXpOZJYRATP9HX5SQFCXn0QPPSfb3LmcIllcSoYfjyQdngeAZhDbuy3BNqoalrTQ1BU17VhbFsURqrJEmi3g+S5gDC6vLqC6jtpmfPTxPBd5XmJ7t8V6laKtaxjO5JdlTTe6OIHn+6jrCr7nI8kopXY6nbnUkyAIAtQVkXt6hmEaYxCHIQTnH7quR5rEaFo6yts2kZhC30fNsWmf9/1t09DJph/guvT3r3nY1/c90iTBarVEx/8chgGCIETT1JwRCOeY9sjr1zAMYAzg2JLU8BbdLKmARDHYIAwgRkPr1CShVV1Zo6gbfP17vgE3L78MhwtFkBK9EfB8H8XphMD3UJYVyrLC/nCCVi2K8xmOYyHk0Ne0XXFclxj7TCuik04AYdm4ublHuQc+SaVpQuUlAaYFNxQ/9jyOjFOrL01TOhlpGuBq9ig6rgvPdQlEmmV8cnTQVBUZhPIzHM/HzYMbHE60baqrCpvN5j851+1P/Gt/8t8d38obwFt6AgCAT332I/rd77j6M45t/fUvRA2mRCCn+DRhuwxogKU64rXp0dCuviPGvFI9BU4M0PUDWt7h07BQ/uYbihBomwZ1Q4qlHR/bpsKM5zo4FyVUr+F6LlTX43g68zGcykCKTwYWDyjrppmjzTVXTKeBZlXXqOsGqqdabeD7uLhYQykKBu12e/LaWQJj32GRJQh9WoOB/8yqo1cJ23YIZ6YUBAw2qwXWWYSyrHB3e4fFcgkBIM2y+cRUVA19Pyyak7SKgicYRwgzwhKAtC30AzXsJgR60xABmSSWZFOaJBoBI6miKMLN/Ws2N3uoWZYhpUSen9E2DXrV8vyiw25/QBBFCMKIMh09E50gUJQVvCBEEkeI0xjHU46m7VBUDQat8eLNPZihR344kOp7GLHfHhAvl2gUyTZhDH8eFJLQhx5oDoKR4tlZliAIAwRRiOfPb9E0BFJp6oqBKS2FrDSJVo7HE4tJ/RnJtVqtAFBJrapoM2RZZLEex4Gx5/S9czwPfhyjKCq0bQtpRkhBsyw6JVjwHBuWbSPlAfH19QWMkHA8/1fyuv2xb/tD7x/e6uvzLb8BAMD//ZFfze9vsu/7QobhaS04M/A1GYEHTVn/ScXU9QO6ji60QRNDgCK2DimmtIYAHX+n1VnTtOjHEZZLw7wp3tu2CpbjYb8/odM8eed97zQwHEczZwS6rkOU0Lu+7djQg2a7jQXPcxFGEQQI1GFJC0EQIIlpcl6WJYo8J468R3zBc54jW9BFO2oNP/BxPJ7hcrS5LEucz2eMnMX3g4CkmIGPJEkoPqoJXa61hmEeXd918D13fio5jjN3+6M4QhTHuP/CDVRL3MSBP/ir1RI9G5tGrZkGnMNzHQQhdRg838dhv5+Nx3VVwnWoQOO6LstfBDwWl0ZxjJ4HpOeyQpSmsG3qJhR5AWHZCPiV7nzOkRcl7m7v0DQNVlmMwHPgCIPXP/lJ5Psd2iJHV1d4/OnPII0oEDSMI46nM2U6pJyHx1pTr0SpDqdzjjwvIKREHEf8QKGHiWXLOZx0OuWo6hqbiw2EoC6JEBL7w4HFogEePLiHy6tLGto5LhzXg7QkY+Al0kWGtizh2LSWdm0LbX5Gddzj8PwWY9/hdDrB8QIi/AgL0vPhheGzKMv+8Dd91w/mb8e1+bbcAADgsw8//qlF7P+QlKL9/PDQNzaEZPUZ5mrmhMHue3LwkbON2oGkhrZwOhf0fty2aNqWMtTDwNAFWpktsgTDoLFZLwlO2vc0rVdUuvA8D9oYHuxFHPbwUVU17d3ZbgMQrHMqrXgeWXnfkHtasBxavVm2jWy5RDeQk+DikgyylmXDCEoaGmEhihPk54LWax5tLVRL9CPJbjs9jgTwZNuOY1vsvef3OsuCw8x4PZJJmCCnFIKiVR5h01x3mmaPTGQmetKgRzb9jMhLApCakS/QvICwLDStQhxFWC4WSJIYSZoiW2S4B3U/PAAAIABJREFUuCBYpeSZSteRYGS326NtaJjqeR68CYvOJ4LDdof8XEAKgWy5wHq1xJFR5MdTztLNCnVBxSDfkRCjRlkU2G733C40sB0bx8MJtiVxcbGBZUnc3W2h+x7CkHVKKYWRgTQTIfp8OqHMc0gpsbq4RFlWeP31RzAAnj+/w9APSJIYxhicjjnubreA7cAJQzg+UYwsx0G6WqIsKxRFiV5184DRtiQkDE6Hw5xMtW0bba+xvlhj7HuFvn/fe//5P/yxt+u6fNtuAABw/2rz4dB1/uPPxxE0DAIFP/FpU81LbhjmCNqYYOMN8/cnXDdZfugIT7VMB67nzjl623EQBT5gRkaFEYjRY4OtZCcAzSPIgnOxWSPPCywWGZUzeD1k8Q2qZ7qO1qQzDxjZNL3/Oo6NtlW4vb3D/ZtraIZ+TvXlu7s9nt3ucC4qPHz0lC9cWt1Z0kIYRfB9F7v9EVVVIwgCNK3CyFNxmBFlUWLQRBoiYQltHQKeQdiMQm+aFkVJx9KyrKBUx0JQB45rI0piAGxiBk38Ly8v+aaqoEdDQ7+Gfv1ykc0rRseSUG2LoihRNw1adu31SiHPz9QLcF06HVkEeh30CNulk0qeF/A8F9fXlxDGIAwDvPLKO2FZFg77A7Z7ci8OA2HgVNPg0euPCJTCngjfDyiD0fdz6zNJYjx48AJsx8V2u4NjSwKqqg5ZkpCwk8GzVd1AMLugUx1u73YIwwhxHCNbZNDjyCq2HTzPxeZiRRYhxs+ZkdqYuutoY2RJNIo6HkaQpCUMA0gY9D0FvC7vEUvndDz/2f/1b/z6h97Oa/JtvQH82kf/r/Fb3vvOf893nf/xc8aD36QVn9pmQgg+4mqMZkKKUSTX4nhrXdVwPWLQJ1GIhrFWruuiUR3qVtEpoW3RNg0aRTeKIs9h8wmhqWu4tkWR4LZB1w1o+wFCWjN33zDYkyLC9CTuuw5+GJBSqqYsu+o6BAFFdd/c7fdZZXZ97wodl10OxzOyRYa8atGoDnEU4vL6EvnxBNW2sCyiIdVVjeVygcMpR9O0zIWjSG4YRbQ6sylhV9XEIRgGjbyo4Hi064+iCI7rYLs/otcjhpFucsYYxIGLQSlsb7fMQaQh5b3795CELl64d4nVcgEpAM/3cTwXBOIIAlrJCYG+H1A3DeclBAFL+Hs0eRoXWUqvTH4I2ycwiC0Fdnd3CKMQh/2RNeEGfhhS2Ie3NoHnMMvR4HQizLnLHoMw9JGEHgwoGZklJBZxXBe250FIiVYppClhtk/nnCAjrosoClFWzZy+mwC1dVngcrNCHIcU790d0NQ1At+H77kIwxD54cRtwYpmIBaj6mwLvuchTjPYlsUNyA5916PteuyOpBy7uL6GHwYodtsPq374wA//B3/O/P/2BgAAf+1v/h/NyzfrH3Jt61f/ftCQ6SQwMQCo2Uc3CFoxdTCGVFjTh00yCLSsie6iWQdlRo26bubyTt22aJqG65YSDgtGbZuCNZ7nIY6nnruPftDIzwXrxHPEcYSGuwVt09IJoB/QNC1Wq+X8w05Tes1QzK87HU9YbdZ4/fVH1PxSVAF2HEqmXV9fwjDPLwo8JHEAS2Duyg96pNx9QpZaw73/iWg0jgb9aFBVFaSQUIokJo7rYrlaoe0H+L6P9WqJJI6w25+4s28hPx0xDOOcbBSSIBd9r9ku5NKQj23NWZrSXMGWpEPngJYREkEYUUDIJ2DojGrjdWJV1+xjpNe6cRzhei4WqyVsm0o0VUXT/OPxhPO5QNM06IceL734AoIwRByTnfl0OlGYJ8/plSIIYFkWsuUSxtDvlxclHj58MuPVqLY74vJygzCKUNU1sSJdB2EYYrlaIowjrFdLrDdrCBjk5xyO68APvDkAtFwteABsKBgmab2ojYDtB4DlQFiULRkGDc9zcXt7h/3uAIwsnrUsBK6F8nD4tRH4wd/53X+0ebuvx7d0Dfj3+yqfvlp94jOv/0pRt7/XGGSfjyIkpZiHSg4LO8C9AGMMBDfpJr7gGys2DzDjzBmYn+JmZD2TCzPSMVMxeqxrFa2iGAjieS7u7na0piRlMWBG2A6ZgMMwoEZcGKIsK9ZkyxmgsVgucDie+MKN4boOtrsDtx5JaTZd5H3fkxykaeDZ1IC0eX4wjoaQ4YGLJI6x2x+ghx5xTBeD41ITseKKscu0njAMYWCwvtjMBZuqqgEx8RQcCENqSdJfD3BdB8dzQd0AKWiHP/So6hYjq9uqukYchfA5ZOWwkdnzKbEXRQTKmJiNIzsE+q7jtCYVsMIoRFmUKMsGXT9Q/LpVEBBYLBd4/OgphKGUYRwFsITAfn/A8XTmjIcmirPvIggC2JL8ea5rw7YtpIsMdd1ie7eDGIf5ldDzKdfQti2KssTucEIYBFitFm/yHNCMBCxFWWQp+wmWOBzP8P0Ay4s1Yedbhaas0HU9NldXsH0P+7s7qLqmFKZL2remqhGEIRmV+wF+HKHtx6dPbnd/4G98/PYz3/Yd3/m2X4tCd3f4an0tsgffUbXdXx6NyT53NoDoPpakp3MUkFCDbgAWBKi8IzhT7NgWDMs7bYZhDnqE7zlIkgTncw4pBXw+wllSoMwLuPyUtW0Li+UCdV1juVqirmrc3e2wXqQQUiBLE7LK1jWBO9jvboxBVdVYLjKWjtJQbbVaYb8/EEFYa3biUYdAtQ02ywWKPEc/AnVVIY5CSEuiLanq26oOdV0jSVOMnUIYkCyzrFoIo5EkMQAaVrqei6omZkGWpbNg4u72DpdXl1gsF9jdPkdXV/CDCN3Qo+sGJBGBQB3HgYHAcrnAaw+fAEJgmcYoixwX6yUarg93HdVxU6bf9F0LpToIIeG4Duqqou2EJI69alviFVY1AIPL62l16MCSwONHTxAlKV57/RFeeeWdFJs+5/Tq1/fIogCObc25hQOTiFfr1Zz3mNaNozGwBKi4FQT0OlRVVNG1JTyXKFCq63B5dYH93ZbpuxXiJEKSxMjPtCVYLlKiAednrJZLYldaFk6nHLv9Ab/tt309pGVR83B/gBSAERaWVxcYup4ufk1ocI+ThVP+ou86FHmBzcWm0AZ/4Hd81/t+4at1DUp8Fb9+6F/9Z/7axTL+4c+1GaCZAK8AMUFC6Q5OslDBRt5uFlwAoIm6T003YdkYAUDQ9mCxSBl2UaGsauRFBSEt6hS4Lhy26hoD1Jw1D0Ji6/WsrPaDEJZLBRBpWehYZhmGAeqmpYxBGEL1GgVbdfTQw+EEo8398lFr9CMNDV1GRe8ZLb3gVdz+eIbWhm4m6yWkZcN1HNy/d4FskVGCbKD8QdsqbDYrdhdQaWi/37O/sMDTh6+jKisIy55XqYQ9I0W4tOx59rJII9jCcKd9gbrtUDUKBhSBlmRnI2VaQ4hxPep5HgEhIGwHRd3iU599BEgb9164gQGRm6RF1VdiGqSwuK8/DgPaqqLhad/xDdGCF4Qo6xZl3RCtKQioNisFVZV3R/IJtgpdP8Dz/PlU1TQKcRwh8D3SvhvgHe/6OqwuLggKczzB9Ry0dUM0KT6uP3z4BIfjCdoIVE2Lw+GEJ0+ewXVdXF1dzpi5uqQbjB8QpswMGtAalhDY3u3gBT6S1ZrKXoHPpSwXlm23p7x8/4d/+dd/8at5DX5VXgGmr2//Pb8P/81/8V//+ulcDYMev/3z3ZBsy+Z2nGBt+BuzkgnwoQcaRlmWNVeICa+kWLLQU/W2biAA5rdRYouyB+Nvgn4YAzR1jSwjo63qOvSjQZamiOMQNfcFRqbeuK6LUev599Naw+dY8nRqAUh4IW1rJtM8f3aLhAGWXddTAIirvvfuX2O1yGCz2DTLUuTsnGuaBja/k8ZRiCgMkBcVwijE5mKNp0+eIwwpVGS0RpbRDbAbSAk2obCFxJx5GPoecZqg7wesVkuUVcO+QYmh7+C6Hio22XgTBwHEUAiCYEazQUrkZYNzUSKOiLpUlCWtPjmgRZkGjYBPUY5tM8fRguM6vKakbc75eEKcpoijCHqgBJ5j22ibBqv1aj7BOa5LLUDeCnmeC9+jAlbddrB94iF+4jc+hiLPMfQ9lbOGgQnADc6nM5IkRhCRJYnyFz7CIOSHiEFVNTgdj/BtAdf3cLc9oGyoOdk0FCdXXTe/dtVFCde1cT6eAAjTjfhRYbt/4Xv+9L9v/oG9AQDAD/yb/wZ+5id/9m8JYZK2G771740LT68CeBNMdHr/n6aFNttgJ5gofVjpnRoA9MAdeylm1bUxI5I4ovgv8+cH5g8CRNCZICLDMCAIA9R1TXx63ulOKbJJCqmnFKChgZ3vk1JLtcQQ8HwP27stRgBBEMCSEq1qMeoRXafguQ4slow4rks3NDYBRWGA07ng47qNgelBaZZgs16xWzBEmef0vtm0kJZNcwHb5iguqcwc10O2WiGOQgxDD9W2cGzuD/AANctS6JlWRLIP+nv0uL68wDnPURQVBMejpxtn09Bx/Hg8wXFdVMxMhKEtRdsSHxBSwvNdqG7A4XCE69h4drtDWdfER+yJWgQzzkWvq6tLXN2/xmKRIooCCANAUgYiTRMEvo90kdEpqCPPX8+5jt1uj8+89gRhHOHm5gquY2OZZXNtfILSRFGE5WoF2yGMWbbIYLRGfj6jaRqAyVV91yMMfUShDy1tKFjI0gS2lDgeT2hqehX0PBfCjHAs6ldIx0XdDT9+dbn+d/6Rf+WHNL7KX1/1GwAA/PD7f3D8xZ//8C+fiupa9cM3/38GgWIaBHLOn//ZsiSAcR4Cgpn6hmWUliXn6b/FfYOuUzzNpg574PsYh4Gsvi6x+RzbgpTUDxBSYhwGeJ4D17HRNAqH/ZGOyouMknSOxcEOjTiJ6GTgupRX0AOUogitZVso8hLZIkOapQA4vjoRcFWPFRN+kjRB3ShUZTWzCVzXRRwRPvxwPJOaLPTndqJh7ZaUcm6n9V1H028hUDUNAzDWiJIIXV0hDAK6KAdaVUZxSCp2biAW5zNcz4dtU/AnTWNIacOSFvI8J099XsCSkvyIeQnAIEkijmf3uL7cYL3MICSlIcEtPrIRt9hcbLDfHdB1CouELv4J2WZJCxcX6zkrGoYh8vMZRV5AtQ0lMi05R53Lop6TpK1SuH/vCkVRcoVcoKlreK6Lvm2R5znlFLjT4PtUi/Y80o6XVYX8nKNTHRxWoSle7Xq+h/3+ADeMEd9/Ce987zeiayo05xPNUrizUdcN4iSGkBY6bRCk6X9qgPd/y7/8PoWvga+viRsAAPzB7/ue4ad/8md+qVHdS4Mev3E6CUzC0DfzA1zHfoPZzl54wxAMwUdBsEtQtS2iOKQmIH/w+kHDdVx2ydMHW0jJnXaKkQ4D6cQHrQlMOgz0vqs6DEOP1YJkIFmWoFM9ojhEfs7hckrQ5iiq73sY9Yi2o/fRwRDObLIhBb6PEUBZlNRQsy0sFhkO292cOmybGmHgoSxqChiNb1Sd+36AMAb9MKA4F+j7HlEc43A4YhiBNE3QtBS8WWTkLoSUiOIIz589h2YM+sA3wTDw4bgOr2SJkFwUdFGnaUIBIUn9eMFHedV1gHnje1uUJcbRIE5pkKaHgaLKAw0rpZSoygKtIshrHNP6TUoJn2/CQghki5R9AT4810VZVnj6+DG7FRoa9to2+wiovdg0DcIwnOvJQlrwmb/new46pZDGVPYJw5Dj5ASKmbYWVVWhLMgOlKQJBl43a02djCgOZ21ddHkP73jvP4S6qvDpj3wUl5cbaK1Rl+WsLDMAjLQMbOdDu0P+A9/5/X+8xtfIl8TX0NenX/uN6nKd/YDn2B+afINvDgcRL4BKP4bTcoaf7HRzoKZXP5o5hjoVPDzXJS2XoI6749iUG6gq4vILesqS9dWdQ0hN3VBhpWqhVI8w8ODYDmUMAFR1S5YXKRElMTTvt/3Ag+faKMsKtu/D8QJUbYebm2uM44gyL5DnBYqyQpxQLr+qySp7PuwBKbE/nGAJgYv1iqbvaYyialA2ClHok2HXkqjrGn0/oCgrhHGM119/AmmR4WbUmvn77jz0bJsGuuuwXC5Q1vQEXG/WFBk2NDSFlLBdB+kiI8y6IPOtHwZouPo8vYNrrlgD5AgIgwBBGOLvfvQTLD2hCxhCwowGSRJjuVjwCtHBbneY6catoqZdmmVUQfZcqKaBUgq2FLh//x7iJCGkd0IMhL7vURYlexDJxwDLgWURmclyyGVQFiVu7l9Bijfi5tQr6VA1LaTjEotf0yAwDgMMSsEwI2D+LEqJqm6xur7G13/L78STR4/xyV/927jaLPDqa48xSpLcBIGPJE0gbdsYIX6u6/rv/b3v+9PV19I19zV1AwCAV1//WJVG/vfZlvwrf29keGSl2DCMc+YdIFf71H9XbzL2gMEhbasYl2VIzcwFn5H77j1nC7TW0AOFXzzPw7Nnt3BsC67rYrFcMGa8x/X1htjuPR3vyVtQU1VUKRgAruOirtu537BeLxBHIQ6HI+IoQppEAB9VJctPbPYO9EbCDyMMEDjmBdRATrw4CuA6FjabFRarFQZNpwDf93E6F8hWK2y3e2RpjM0qgxg1BEbcu7rAs2e3UN2AIs9x3O9R1Q2OpxxdRw3LtiW6LdmU4vl7a1vEUwyYA3DYH2aKk5Q0rLt3dQGfXyUEqKLb9z3WywyL1RKbqyvUraKTFFuVfI7fHg4n5EVBmxPVY9Aa6816jgQveAUXJwn8ICB7rhCI4pgIRhwFT9OE5aIeFgzsuHlwg6urDaQUOByOfLpxqZItyMBLxOKBWAZRDGF7uH7hAWyPykmt6uFHEbpeU85/mcECEC0W6L0Eh9stHn3iN9DmJzx/+BDLJICLERI0VB70CDOav+rZ8nu+4/v/eP61dr19zd0AAOD53WfP6yz6bse2PvS5VoMTOQgQc6tPa03dAUNIrKpp6YkDCSMkSSZ4NtAoYtYJSWupsqqoKOO6EBaxAuqqgh+GaBRFiJM4xPX1JZTqUFcN4igEmHw7TH0A0IrH930UZQlwFtzzPOTnHHHkQxiDIAwwMAewLCvUTYM8z+fAThCRR+63f8O7oEeD4ylHHEU4nXJ6f1UtukFjc31FlKDAR5rEbA7ildo4Elux63E+nbBaZeymo9cTVVWQlkTKiO273f/b3pkH65addfm3hr32vL/pnHPP7du3u5NOAoEwBCihSihErFIEQSLKkBASmURiwCAYSSQJFQShCgRbEqAiVjGoBGikUlZjEWQwGJChMkCg0+l03+Hce853vvNNe95r8I93fV9SqJRYUvRw1j893B7u7d577bXe9/c+z8X+v/H54oK6IACctbj32jHK7RaL1Rbz+QVBRRO6KkynUyQJVceFkDg4mKLIMxwcTHHlyiGkJJvOar3FYB3Kmlj7t27f2QNgsizDdDZFmia4WK5w9+7p/v81lwL5aEQwVGPQ1PTSd22Duqr2chdjDDhjmE4nKIocxSiHHujYvlqtISVNHDZ1vZ8G3cXPD46OUDUtfuM3fgutp0D3fqBLhQpt2yMvMoBxnNy6g8X5AlEc44HnPYgP/v5vQ3Ql8jhEmkTo6hqb1QqcC9RNDybkL9SD+fLPePlr1k/Fd+0puQEAwO07j20Px9krIxX8e/YnMCK7YZldscc6B+3vxdQpoLmBzqOrjDFgXMI47NtNMggghPAwEVJ5hYqU4kM/kAhip7SuaqzWJRUJB03HUeFZA85SsceDNixIA22MgR40mW8bwowN3kJUeyf9wdGhh2ZYaE13WMB3DboWgdO458rBvu3p/OaRpimGwSBJUmhDUVUhOOrt1otUDDrj0HQDtLGYTMZQUmI6GXs8GSPxhyfgOmcxHY8wmYwQhkQealtqZZZlib6jgNG1q0dIUn9fF1RE3W5LnJ8v9jUXYwy0sZjPzykaay1u3r6Dw6MjnJ6eI4pDrFYbRBG1J++9fg1nZ+eoyhoyCJD4hKYxFlpTniHPc5RlBeeA0XiM8XSKqqq9aDRBFMWk0M4z9F2P27fu4OaN2/sXXfvw1S47QkVDQn6VVY3Neo07t08wG2XIkwjVZgPTd1guV7CgmYaz+QLr1YqujuDYbLZ4z2/+JuTQUh6hrslctMugBApplv5ckUav/PxXvX71VH3PJJ7C6+bJB7cveO6Lvu5itd2sqvZrnXN892VwjtBhKpA+CyBgnYHY5wZI623MQO5358D8SYBxutuT/43008ZaDEbDGj94aInsMgwageDQfYezuyXShKSRpMkKoI2FYAx10+LwYIL1ag0GtyfDrlcrSscVOfq2BQsjGE1yUC69LYlT8altW4ALzCZj3D05QXx8BTwY0PcDNnUHAUKJ1f5ufPPGTQgpUIwLWGOoiBcpRKHCar0FrMHR0QFV3cMQq9WKBmCiGPPzC4RxBO4MVJTgyvEhbN/h5PadvY/h7t1TgnUEEjKQmB3M9qeCPEvx6GMfRp4rCM5hmcBoOgNzFquLc3CfzDu5Q/CN9WqNJCI013qzxXgyxnFKUehIBbhYXiBUhPrSxqBrG0ShwmA7352g9mta5AAcVJKSIYoBSlIseBgqxEkCM1ARTnICwESR8uPlDGZwUFECywRkKHF8b467t2+jyDPMDqYoyy2ssaibjgqvmzW6todj1EJWSoGrEM5o2LpCM1Ch0QmJzbbGYB2UYK4d7E9knP/DT/vyV1VP5XeM4ym+Hn38/eXHP+/aN0vBf4Ax9r8QUnbVWGstwATNsVsDa2jMF36yaxgI/bVabTyFmHq5xgMj4cnDfT+g63qAcXBJtGHrRSXwUU5iBPYoaypOMQCz2RTL5QZN2xFyKs+hFDEMopjYcgCZbaIk9rP8RAFerbd7uan0EFQVRmBcYLnaUix3MsZkOoZx2BOJqqpGmiQoihxRkqIsa1RlBblXXSs6BRlLCGoQk+7W7buoqwpD22G9XmOz3aCqGk/FbdC0VNjcEYas3zzbtsVqSVj023fO4Bwd3/NRgXwyxezKIdLxGOODQ9x733VMDmYofGy4aRqogCbklApwPl8QCsw7CvIsQxzHsIyO/EpRtoIUaY2XvHCKPmuDBx64D1IQrnuzrdC0HZq2w/xsjuXFEmGSIIwjBL6zwyhOChlGaNoOT3z4BuaLJSJPRM6SGOfzCywvlhCCgCFhkmAynUJIicODKaHa/Yh6mhEt2IJyH31T456rhwijSG86+9B7P3jzHzzVX/6nVBvwT1uv/Nqv1m956Ed/ZRh0Z537TAByrxv3QZXdwNAuFERjw5yGgBxdA4Sg+CaDhbVAoCQ44/4+SIJPKcgjsHOzUcEp3Y+3Dp79vyPFkE5cY9Bm33YsinzfXlL+x+M48uhzDe5oOEZISffexQWU5PCfV9RNgyxN0XQdufs4x8VyBe4MkiQC5wyttliuNt5YBHApqcoPEnxkeYrNpqRMvBSIkwSnZwtMJmNEUQhYi6PDGZh37wWBRFdTj/7gYEanImMwm4wBkBa8LGsslmuUZUnswzRF27YIwwjTwxnaTqM3DuNRgSAK0TctDo8PcXLrNhjc/qrFOUc/UAHO6AH5aETkpPEY6XiM6XRCejVNf81mW1KLMCENOGfAye07aOsKsIYcEkqhGBVU/wCD4By3bp0giUMsl6v9sBgXEsVkgnuuHVPa0miU6xU22xJCcEzHI1DTg+P6A/ejrltYo7FZr8G5RJzlKOsWjDGc3roJGSjkeUoiVW07BrzxY55z7Q1f+E3f0eNpsP5Ch4H+rOtTP/EvsZsnZy+/2DY/BKDYbQD00jIvBuX73+4yA85n7gHsEdDWGI8cdwik2NcPlL8S9MNA/jkp9zHT3WBS13VIshR5EmG93hANSCkIGUAP3R5gyjmH5BxaD4jiGHme4ezuGZIsgWQEJ6EClfDtxxBFlsIyhs22Aveij9Ozczxw3zUEHBiamlDZ2QhOD1hdLBGGCjKKcfOJG5hMxxAMcHqAkAGM0RCcYzqbwhi939jqqsKVo0PYocNivSVlN3domgZpXqAsKxxfvYLTu2cIVYC2G7DxuYeyrCjDEEc4Oj7aw1WjKEQxLmjwxVokSYwnP3wDt5+8gdl0DD30e8DIer0hWYdHj3e9xvUH7oOKYty5dRvMGTSbNZxzyEdjn+hTGAZDA1NNC6sJZqKtQ5qmnrDMcPXaMWG9NuRjbNsGs4ODPfVpd9rpuwZOa6hAeNxZgrauIAOFq9fuQT8MxEcAw9B3yIocVatxz/V7sF2tsV3MkeQFuDXoB131jn/L4cH4xz777/8T+3R5p54WJ4CPjg3/6m+8+z13bt3+HePcX3WONgG6ChBFSHgvnvbcd/ryi32+mEI+GgCBNkL/sAo/PWisTxIKAXDhQ0DG1wWo4KeiCHES484JCTKKPIOQgu6s/UAoMClR+3HSJMsBBkRhiHK7RejhJdpfP0gv5bxiK8Dds3PK5GcpNmUN5yyUFEi8ijuQEmfzBRgcZocznM3PEQQBFhcr9H2HUZ5SsdE7CebnS5ihx9B1xBr0aUEHOj2BCZo6zDPa3OIYZUnZAmsMKbfzDFVVe6DJkVeZEZPw7O5dWKPRNi1gLTarDVQY4uxsgZMbN6kdOBkj8vru2WwGxgintpOrFKMRzu7OcXZyG2YYfMdGgDFyF5RlRY5Hrfcg1mI8RjEq0HYdTu+eom1a1HWFvqN0YJomROaVAYqiwOJiifn5Asf3P4DrD1xHV9fIkhhJHCLP830OxDlHqrXNBsJTlIpRjrYb8ODHPB9t02K1XCEKAjA4GOtOZZx86e998NbbX/EXnO1/Rm8AAPDSr/gS/PIj/+Vx27e/3HTDZxhrr7p9UBT7YSHsar6+FcgYGYeNJtyzEBzOEip6z4v37URjLRXtvI5cBfQgWmPhPOSiazsYo71sM9jPvzuvxxZCIM0zWOsoBuyTdcxjyUSgYIYBVdUgUqTb7nuaX1iuN0jjGKEUSNIE621FuO9AIg4Vwoj4/RR66q8TAAAex0lEQVQ3FthsSigVYDouADAESmIyKvwsAV1ViiKHCqmIVW5LjD0Xf7naIEkJkJnmBRbLzZ6S3HkbcxzHmJ8vEEiJ42tXkWUJTO8juFIgDEM8cfMunDGwekDf1ujbFudnZ5iOcsKBc6ptyCDA0PdomhbGEjY7Tjypt64JZOonPKezKdI8x+BR5VEUIc9STGdTTA+myLIMd07u+LYb20NJGShbAd+RGU3GUGGI05MTSBng6N77MHQt7p7c8alCP9IsxB5gyuGQF4UPpDo0vt7TNBSHdgDiOELbD3/AZfAlWZa+6xWv+2483dbTbgMAgK965ctQ3X7s7L1/9PjDAO4ftHkhvfsE/hCcCl7WF46EoHaUNqT24j7ySdQhQwrt3RXAW252HHkVhnuCrVSh15YztB6EESq6k+42DyEEmqbdR5Kdg3fEkY0ozRIM/UBJusCzDZ1DEPgWYz8gDkNMp2MEkkMGEqPRiCYRvU48jiJ0A/18zs/PMXgW4mq9wWQy9kNJtAE6f/e2flxX+01BcIEsz3FwMCO+XkfFy6LIcbG42N/Vo5Aq91xwpHlOQlUv+xA+hVjVDcajHOeLJaaTMdmRrEWaZthutwRREQRW3fEC0zTxo7chbty4hW1ZkTIsz2EdwVJUGBI5iHM0rXfn5RnCKKRirWfvJXGINEvReCeglBJRQnxHLkj7trq4gPIikHqzwXpxDt0RGWqwQJIXVNjjdEKcHByg63o/yk2k4yAMce9992JxvoDVg2nb4WHj8KXvv7l87GXf9iY8HdfTqgbwv1v33vMCtSnr19bd8G3OuXQ3PCR8DUAKAc58j1prCMaItONbdaF3/3E/aKRCBWus/3KHVFhkDCogpXYYRWCcUVbAakRxBOdfqtBDORgcVEhjx5NRBuUzBzsRp5SSgB9ViThJsVyuvK47IlVXQnQagKGpSuRFga4fEEYRFmdn5M0zBsdHB1SJNgbni6WvUTBcuXKIxXKNKAwwzjMURYb1au3RYQThnM5mSLIUm+UKSZbi5NaJF6DQySRLY8rWdz2OZhNESbw36mzXa1TbLaI4xsntO8iLDGEU+9i1xmq5QpZnKPIcq4sFlArhnN1nDJxzGI9HqJsW8/MFhOBI4oSm6QSD0YbGcJuGAk1xBDNoTGZTbDdbym4kMZI4RuY31LoqSa9uHTKvTh8GckbkRYF6u6FIeByhazusN0QfNhZI8hzX7rsXQ99TpHh5gSLPEMUJHKPpSGMtDo6PsdlWKFerdnY4+773PXrju17zff+6ezq/P0/LE8BHr9d8yz8yzY0/+PX3/PGT7zXWfra1joqDviuwuw7s6gEqDPfuQGco7WaN2ZuJdpuH1oMnE1sw59D7sd9+GABjkWYpnGcIEFaain6tHyxK4pBsNVUDITjCIEAQBCQd9UZhPfQI4wjrzZZ+LE2glMJqSQRdgPmuQ0DartGImIFJDK01tI8yZ2mM2XSCzvPnwzDE6fkKh1cOMZ4dIE0pAae1xmgyRlFQay9KEjR1Bd33JDQBqCXnWQFaG4/eGgBLGizuVdlmGMA5x2hUEFtBhTTG6wNNTV1TOy1NYS0xDMttiTRNMJtNsViuUJUVNtvSF1klUYak2IeeqrJE27a+rkJDOvOzM0ghcHB4uHf0OcAbf0I0TYNys4VzJC+VUqLvOiyXSyTFGGDCF4UFJgcHqMsSURji5NYtOGtRlyXyjCjJxoGGofx0Z9O0OD2dn1yU7Vf/8Y27b/32H3yrxtN8Pe03AAD4nC/4Ivzar/7ao6enZ++wzr3YOnfdOcd2vXXm8d67qULG4Y+KAQ39cLZHZ3+khUgbQZLE0D3xBIxzaJoOxhoMA913jabkW9fT7zuAeIOOQjuBlPvetWPEL4yjCIvzhS+yEWoqUAGkkEhTQlNVdYP5YoVeU059V1ysqpow2G2PoshRbtbIU8rpT6djfPiJm4izHNttiSxLEQUCduj3x+OiILxZuS1pSm/QWK82xATUlEsIQ39i4RyHRwfoBo1iVGCz2aLalmibFnme0eZT5GiaDkJKXCzOEQUBBCPTcp4mcIwjygqMpxNYTVSl9XpDY7Jpgs22IlGKvxIFKsDZ/Jzu4552rJSiwS9HI9qTcUEwkrLE6ekc6/UG0nsGuq6ndGAcg3GB9WaLsiJWYuY7BYm/fmzWaxSjkR9/BqRSiL0zwTqHriqxLSvkswOEQYCha95V9vZLO5n++uu+/4fwTFhP+yvAn1wv/rgXF4/fnr++aodvAqAYqDMgOA3c7F5K4xl9O/Al1QbggzjUSw8CavuZvocISNTBGfOFQ41IKVgzQGu7F5I6oyF9OpEzIE2I8zf4LICzFpIzsvT46UQVKggp9+6COCJr0PJiiTilMeM8S4n4y2kYKI4jBELg9GyOrqpweDhDXmS4e+cUWTHCkzduAYzj2tVDTIuURma9IHVX+AzD0DMKthSmMgbHx1cA30XZgU3AGKyxSNMEk1GOi+WSnIFN4+/pFhfLFY4PZ8iyBLdv3UIUhojjCOPpDGGagnOO01u3sFmvoRTBU8Mw3BfghI/nRlGI1WpNLcU83+vbq4q6EleODsAYUFc1mrqmbgbnuFiuMRkVSJKY6hacoW2Ic2CMwdSTfHa1jtCfBBnn2G42SLMUo8kYVUm+QC4ELuZzCA7EWa7TOPrB01X55pd/+79YPZPeF45n2Pr9P/z9zad87AOvTSP1dzhjH3bwnkFj92OrvdaU2fehkU5bMCEglYJ1RAAe/L2+6zoY0NDPZkuWmqqq/FHXYFvW2JYVHOOw3krTdz0pu/yoaT9o9G1LR2dNY7vGUgtOhQpVWe2vH4xx3w5UFFve2XmHHtPpFIdHB5RSZNRRKPIM4+kEcUphFK01jB4wmYzQti2WiyVW6w0GYxF5N8BOpKJCha7tEEUxmJehOAAqTnA2X8CCY7Uusd2UEFJgNBkT5VZS+8tai/PFEovFBcbjEcIoQlVVCCR9QR2Aum5wdnKCs5MTnM/Pqe4ShgDY/jQTxyHSJAZAcFXG+V475qzD8mIJYwxGoxxJlqCsamhrkWTZ3iB0MB0jjolnMHg1e5LGCCMqEDohcbHagAkyNHEZIIgiDMZCBAqDcZifnpP1eRgwaI3x8TEgwxt10375ZJR92zPt5X9GngA+ej14/wvvPZmvvmcw9svoIMAhBNuHhYJAkt1n6PdfDinojtsNw144yQEkSYzVpoQKKBAUKAXJGOrGMwTiGJNRjvVqBWst8jQBGKiLwKn9GARyP3a8A4ZITySO4hix9wJmWUKV/r7H3TuniCKFgHPEWYaDgxltHIHEhz70YRRZhiJPEakA64sLDMZgPJ1icbGCUsoXOIlRkGcpobT8Fz3JUjz26IfAORVOx76DkOcZTk/P/KklxnQ6AXxXodpuoaTEYrWhXyMoQn3l6AB1VZFGLVSYL5YYjQrUZYk0icEFBwPIaGQswohYfaEK9rUGIjvRRh17gKazNOW53pTEbGw7HMwIZ1aWFUIPVF0uFsjyDAD8DIgBwDAej5BkKe7eOcXQDxhNxlQLKegKszgncGoYRwgChbP5OYSQSNPEjA5mP2Pa9p++/8mzm9/xgz/8jHxHOJ7B60NPfuDW/fccvHKUhl/NGLtBk4HkyxsMsdmNNZCeVWcNBX0cY4jCcD/LP/jATpbGFDbymmk6ttNob9eSAERKIhaDc3LFefqOiqKPSDMVmYeF70Y0TQPmKbtRHKKua4BRbp8LHyqqKfzSNC3qpqMBJz/dJoSAAzCaTiBkgNVyCThLvMCDKQTnqLYlFoslVqsNNtsK680WN568CW00pp4puC1pvPZ8vsB0NoUKQ7Rth65rwRzdxcEEGCd/wbasPL+QxKNZXqDtelxcEKV35SO4Ugo/fKW9rRmIwojaj/2Arh9Q1TWM1n7Iy6CsGqy2NcrKj+9aS8x+ztC2rQ9nkb2o7zrIIEDfUb6A/hkWoc8FkHo8wXhKLcrttoSKIiyXK8oWjEbATuctA0wno1tCBl/zxJMnX/mS17zxGfvyP+NPAB+9nv/Ax91762z1vYMxL+GchYJzqIDaZqFSsNZ/hRjAnUMQqv19PZB0PeDAnuzr/P0xiSPKqnuBRSAltNYQnjgccHibTIC+axHHMbUUtQHgEMUx1qsVpJCYTEbo/YDQZJSR/kpIGm4JJMIoIv11nmIYNLq2xWRKc/QAsFmv4azDZrXClaMZAk/WefyxxzEd5/Rz0Abb9QYHR4fYbDbQXYeDwxnO7p4Ri8Dbdbp+wNnZHIeHUxoqalocXjlE0zTQXQcOGn1O0xS3bp9iOs5QFDnqqkKSxERL9nhswRnKqoYQpF7re5pwDAIJ5YufjHNkaYzzxXIPgq3qFlePjyAFx/z8AlobQm97bVyaJAjDcC854ZyQ6JxzzGZTMC5wcbHEbDoGGMdmvYbWGsdXj+EADH2HvirRDRrGcTi4wTj29ulk9Nq/963fefPZ8F5wPEvWB5/4w1vXj2cvPxylX8LA/thYi36gQZId740xvm/9DIPZo8WNAzqPimq7Hq3XZe08gG3bkb7M//EuVLRTlBs/3hqGITHvjdmbiuAsDg5mEIJjtdpAa02tL012XuGNwF0/kKteSgjpRRPWwWiNi8UFtpst1v7vl76a3rYdqrqhmgQj+MnR4czzCAe0dYM0iaCCAEWR4fjqFWR5hvFk7DdEisHCUW2DxCrUHWBCQg+GEoIBbRh9R7hurTW0tghUBBnFGIxFMR6jqhuUVYPeE46cNzhZZ7HZbDE/vwDnDGmaQKkQ169fA/MnISEo0LXzKEQ7vfp6Ay44hCTxxs4jsVyusFotoYcBZVVTWItz30kh2GdV1liuNlSPCdTjVW+/clX3X/VsefmfVSeAj15XDp97MGj9zVU7vBoMuRQCgaSvf+AnALkfJKI/Jzw6nO9fbucnzpQXfjBjEEZqP4MgAuLWm45CK4xRr1tK4vjtoKZRSFqrtm1hNDkFrHOYTieecmTRtAP00OHo6ABDP3gCskNZlig8u76qawjGMJmO0dYNioLMPZxzDMZhNT/F8dUrWC43CEOFMFTI8wzLxQUYJxQ5BYFCrFdrRHEM5VOARhPSfHF+Qb9eSwRmIYjoIxhDVTd0r3Y0jq2imIAdUbjXtM3n50iSBEKQnbdtm72bQfhrGOeMhK8e9d0PBmkcIS+oFbrZbBBHEcq63iccpZQYj8fYbKhIK4Ug3BoDQt9CJK28RpIkqOqKxKZRCKNNpcF/WEjxvd/w5h84f7a9C8/KDQAAPv5jXszWm+0nLjb1m51zn8c5F1IwBLuvjBQkcPQvLgf18AlFjv0LIwUJMzljgCWLrXEOSRxBhRECZv0dlu7C03FBlXoPswwCiTShIzznHL0P5RwdHVKv3oeXqpIEpcYQCbkocvRdC+5tPDsISRgqSCFxeucOkjRBmqaQUmCzWkMK7keD6Zg/9P2ef0j/HlKY7YQju1gz4IjB1zSIfOvuYrkCY0Cepd6So1HkGYauhbMajktiBgYSUUiW4CSOCBqapqQzH3pyLMYRuJDYVhWausF0OkbXttCDRu5Hq4Un7Bo9ULrTF1HjKIQxFqPxCEM/YDwZYT4/R+M3JK3N3skYx0QOatsWXAgjZfBIb/G63/ujJ977tp9/2D0b34Nn7QawW8+574XBtqo/v+mGf26BT5ac811tgPsIsDP05TDWejCFQ6QUtcyUgpQE/jBGQwiKFsNLS/XQI8sSRLuXLJCII5oaBChpKKVEkkQY+p1khMCkehiQFzSaC59ncD4EdPXqIbbbEqFSKMYjSj66HWSU0ONt0+LK0QHWqzVUECBNI5RlvRercABplqLzpuKu69D3PcrNdo/47vsB3WCgAo5RUSCJ6OTQNC2WqzUOD2a4e3qGMIooiNO2SCNF4aZAYb1e703A48kIbV0jCoN9Gk/6E4BzjroXZ2fkX/CugsAXXLk/vu/+u0ZxBHj7Dw9CDEOPNKJhp6ZpEYZqd7Sn6b66Qpok6LrOSSk+EITRGwD8p5e/7ruHZ/Pz/6zfAADg53/qp/Dqb31jtimbV2hjvwmMPagkY0opcDhITlQh7k8CcA6hkmB+yJgLjiRJEHqeft/vorKUI+dS0sRfmkBwhkiRPioMJLQhR4AKpA+9CL8pCJydLTCZjIiB7zef8XSKpqqQZJTc44KuJ2EUIk0SohI7Un3fvnELeZbQ5qUHjIoMUURUXBXQBCJAd2O7u274kdgwJAWYlAJ106FtKLk3mU7AGcFTcj+4AzCczeeYjgpYo2GG3nsCM2hj0Htyr3UAZw7jgmhJ1jrESYrtdgNnHaw1VDD1X3jmScnGUNBq7QUkxnj0NwMCIXD/C14AOwxwQw/m25KDHkjT1baw1mEyHuF8uXncgj00GPfW533aX25e8tKXPuuf/csN4KPW973utfjZd7xz9vjt+dfX3fCNkQquOmvZrsLsvOKJw/l0IfcuvAHCDwMp5ek6DZFkgiDAoDUCwZCmKbHyPG+g71qMxyPYYYAQHFEUofX3cMYYurbd67WtNd7CyzCdjvfOAgcHZyzSLIFzwHa7xdHRIaptiTCkHECep+jbFtPpGFVZQXiCkjU0BZhlGaIoxMnJXRR56k8zdu/a670MZTdDsZtlEJJgK1meo6qoJ88cMRK538y0MYBzqNsOcI5qGQdTWGNQVjUd56UktqMv4lljAH9/BwOCQEHrAUmaEXCTkfq8qmpcXCwxuXKM6/ceY377BLPJCGVZoixL6tgwjixL7zRt98PrqntLUEwX3/pd33P5sF9uAP/n9cZXfT1+5pF33XO+Kr+m7oavC6S4RlFfYgPAWSjJ9zx/xj1ZKJDIkgRt3yMQHEPfIw7pqsAAqFABoAc6ScnjVxQ5uqpEnCYw2lDfn7N9b1/3PSbTCebzBaazCRaLJeI4QhKHuHvnDMfHR1gtV8hHBQIpMR4XWCyWsMYgiRSsc9hutijyFFIIpDH1v7mPQKcpqcDCKIJzjoZ4pMLp6RmyNIYQlNGP44i4fnsPICUUd+qyzOPFJWewRnuNWE7dFc7Rtg2co9FkwRm26xXAOPKiQNPUcNb6ugpp1La+oBfGZO/ZiU0XiyWmswnyUYHzs3NEcYTnvuB5mM8XWM3nRELiVLfREKfg4iEL9m+3dXvyxod+5PLhvtwA/u/XG77x6/D2X/rvxxfb6hXdYL6eAQ8IIRAI8uZJTkEfzhwYGFWwA8qRW2Ng+p4m+QKyFytFP6aHwcM86BQhGIOQAkZrRF4a2rcUXqENI0DpI7ZZlmKz2cIaDRkEyLIMpZ+lryqi+tD8Qod8VKBuWjRlSeJRf9dO0wTb9RpDT4BSSuTJfYeh6weEsZ84HDSuHE0hA4W2aZGkCeXpPdhj8EbmuqoQRxERgq1GkqaIoghSKfQ+NJQmMThjaOoSnHnRq/wIPmwYBlhH9mUuOOqqgTEavbbIigKBoNx+2/WYTKcURIpCPPjgcygc1HXYrtdYrTc3jg4P3tpp+xPrpr/1pn/zo5cP8+UG8P++/vErXsb+4yPvHldN93cZZ98QSPEJDBBRSNV/5keCBef7TSCKIui+BxgFiWAdpOQfac0NvQ/Y0EBNmiaAc4iTBFIwbDdbpEnsicfkA1ivVhBcIE4iwotVFRjjOJtfYFykey0X91jzrutIo+4cRkUGZw2cN9sGipJz2oedwijaK7MYGLb+y+4AxIpgHtpYJGkC7s08i/MFjB78yK/ddzU4Y+AehmotXZsGb04ehgGRCgBrwKWkIFYUQ0pJZiW/CY1GhWcncNRNh37QyNPYJxIDWG8GFt5ONGhjslHx/qZu3nbj5Own4zRZ/ssf+3eXD+/lBvD/b33uX/k8lMvz9NEbp39NcPY1XIi/yhlLBGcQjKr0Sop9O8458gwaYxFK4dteBlEcwTogjgI0VYNAUqyYcYE0jSEAME6DQVIKsu8KgXK7xXg02puGkyTBk0/eJJhl02AyGfu0IoMzBlXVYDTK90GnJFJgzkH3HeCdil3bwTGG6/dfR6ctTNdhMs7RNi1O754CnCNPYmrdlVv0XnJ6dHTgyUKMwk+ehsQ5Q5rl2G63cNYhjEIon3uAc/t7f5rQr4H7nAFjFPFNUppcLMuKMgKCE+dAKbRt609dxDG0YMjyvFuu1r+epslDDuydTsXVP/ve7798WC83gD/f9Skv+jRxsd6+qOn0K7XRf1sF8l7BIALPyRNSQAUKjMGTaVL0XQcVCB+DpetAFCoID+fsPFmXAcj8Ub5tO0rMBQJlWXkXIM3PO0+rresGUgjq49td14K+5caaPYUnlBR42qUIh76HcQ5MEB4tH40QBAJ9XcMM/T66bAyx+5I4ggOI0+9NzHGSwHyUaotzjjCK0Hc9nLNgfiRaa4PaB3AYiKenJF2VtNZ+QwwxaI3NtkKeJpgdTH29wqO8mm4nb7Vtr2+LQP1ikac/Urb9+7/zLW9zl0/l5QbwF7Kee9/HTsq6/RtCipfBms8KlcqZ/zqqQFI3QEofMJJgoP51kiY0meiLiUJKDH1Hx3FOG0nbDwT4HCiws1yuSDYShVheLDGZjGCsIzOQUlAqIMqNCmjEOQggd+00rT0uXBBH0FnIgIaKrKYvu/B3+0hJjEc5hBDYlhUVClVA1X0PTXHOUs1CiP2AjnOkEdeGQlFN0yBUimoenNFo9jCg68jPcDibEFyz7bDZliiyDFXToMgSCisZi76ljgoTQWnA3jUe5T/Z9vo/v/Etb7u4fPouN4CnzPqCz/lc8Vvv+9Bz4kj9LYC91AEvCjgLOSPakBR83zqDs1AeMuIcEARinyYMFMWDaYSYZu8Z3N5fWG63FDUO5H6+IE0pqEShH0mzBEZDqQBJ6GsSw4C+68hIFCrAOVhHkWcVhmCwGAZ6iZ21dNQG0NQNsjyDM2RR5sLj1jn9zJKE8Ns7uzI8EzFUwX5zUEp52KpG5YNNTdvj3uvXkGUplqs1zRxwBu3rBH3fwYF12uF9Mgjf3g36Fx69dfahd/zXd5rLp+1yA3jKrje/5tX4uUf+Wzhfl8/X2vxNwdkXRSr4VOtsGPkJuB1+C6AR3yLPIBj2CPJAkeOvqWuoUIE7i9hnDoa+pyN5EnnGoY8rcw5rKb03PztDnMTEHdAaeZF5yq0mWi6Dt+VYkPLAksyEcTIbgXRoDm6v1YIlR8Au89D3GtoHbtq2AxdEMwKAruugjUGeZSTU9IEgrQ1RfbsO8LqxKFSwRiNLIjjGYRzvw1C9B1w8vFhu3nEwHT8aZVn3+mcIhutyA3iWrXuuPl8JwZ/rrPssJflfZ0J8Vij5YRyFDCCduRAcceSRY57sI/3XPwiCj1wV/CxC7XP5gZRQodoPGjk/+KKNwZ2Tuzg6mgHGEILcAWAcghHkNAgUrB48AFT7rzQlGa0mixD3g01SCui+AwfQa4M4jsF9QhKgaUnm3QfXrh17j+CKjEqSxqF39RDG2N7Ou91sIaRwAu7cgL2r7c0j1+45epfk/NHXP/Sj/eXTc7kBPGPWv3rTG/DTDz/CnDHFtuk+A3CfI4T4XGfNCzhjGeecCyEQSkKIqyiCs5SkU1Lus/ChCtD3g+cC+Pu0H1oyxni0GG0iKiCicF1Vfs6e7R0GcRxDCWDoejBOpw6lJPERPfLLWYO207hyfIjKK8X7rgP3xqTpZOxBJ6TgGnqNNE+RRBGq7RbOU32kDABnd20+GyhVaYsPMS5+xTj3S2kS//a6ajaf9MmfZL/5DW+6fFguN4Bnx3rVV3wZ/9l3/o+rh5P80521nwnnXhxI8ULO2VQIGahAeFUZJ7mGCrxRJ4Q1RBVWKvApQyLuwllwScEfmg9o4azd3/f7jii+aRIhDkO0XUc2HksCD+E7GTuk+s6GBEfxYQaq2PeDBuAIryYYzROAQSqFQAgoJaH7AQ4YgjDcSME/UNbt7zqwdxvH3h1F4Y2Hfvo/2Mun4HIDuFx+feUXfqF432M3R1KI5w3D8AmBUp/unPu4OFQPDH0/CUMVCQbOOd/bkAGy5zA/SGS8+DRQCqGiybtdoEgI4gFyX1QUkq4XzlqoQOylI7QZ0D9TciIhr9ZbRHEE03f0Rbd+wMcXOMG5tda1xrlVliZPhGH4ga7rfrfX5refc+3oicduna1+4hd/8bKAd7kBXK4/y3rlS76YP/Kb70vuP54ehUo9OBjzAq31c6NAPgjG7ldKHUnBU+dcAucC5uk3zDlI2i1opt4nFclzqIkEDAchJKHRQSPCYIyoyV1PgSRroY0lFqKUlgFbMFYqKeZam5u9sTeUFB8IguBD1tpHb52tzp9z/aj88Z9/+PLrfrkBXK4/t43hi7+Y/crvfEDdf2UaZrEq5pt6DLDi+uH4nrLppgbs0GgdFVl8rAcdaGMSwVkaKBUIIWLmGYgOgNO64c72FqwRnFWM88E5e9p1Q2OMnedJtBqMOQGXG+bsRdV06+ODcQ/G+h9/+OHLEM7lBnC5norru17zanRNxQBgvtzit/7gw+xP++s//eOf4w4nOQAgjFP3usvW2zN6/U+Fzel72v2z1QAAAABJRU5ErkJggg==";PlanetData.VENUS="data:image/png;base64,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";PlanetData.MARS="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAqS3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZxpklw5joT/8xRzBO7LcbiAZn2DPv58zkilpNrGpq2lKmUqMuI9PgJwuAOgnP37X9f9D79GadXl0nodtXp+5ZFHnHzT/efX52vw+f3541f4+vO31933t5Gvia/p84NqX5+avF5+fqDlr9fX76+7tj/fxP51oR93jp8vSXfW91/v618XSvHzevj6uxtfn5v5l8f5+j/u78f4XPsPf8+NzTiF66XooqWQPH923SWxgjTSTPp+8n+JekXfJ17Tn+Gv98793eb93d75+fV6+n0rnK9fb6h/2KOv10P5w+vp+zbxtxWFn3f+7Qclxux//fXL3t17+r32ebqZKztV3ddD/XiU9x1vXGxleh+r/G78X/i+vd+D351H3FjsYM3F7+3CCJHdviGHE2a4wd7XHTZLzNFi42uMO6b3Wk8tjrifUbJ+hxsb5jkudWyysVri5fi9lvDuO979dujc+QTeGQMXkxX/9Nv91Yv/ye/vC90r1w3B9++9Yl1RPs0yZDn9ybswQbhfe1re/r7f7he/8b8YNmHB8ra584DTr88lVgk/fSs9OyfeV3x2/mPk0M7XBdgi7l1YTEhYwNeQSqjBtxhbCOxjxz6TlceU48ICoZR4grvYJqWKcXrUvflMC++9scTPy0ALhiippoZpCCCMlXPBf1ru+NAsqWRXSqmllV5GmTXVXEuttVVh1Gyp5QZotdZ6G2321HMvvfbWex99jjgSEFZGHc2NPsaYk5tOLj359OQdc6640sqrrLra6musuXGfnXfZdbfd99jzxJMO4X/qae70M860YLiSZStWrVm3YfPiazfdfMutt91+x53fVvuy6u9WC3+w3D9bLXxZTRbL733tp9V4ubUflwiCkyKbYbGYAxZvsgAOHWUz30POUZaTzfyIBEWJWC0UGecEWQwLZgux3PBtu5+W+0e7uZL/X3aLf2c5J9P9NyznZLovy/3Zbn9htTNfRknPQIpC7alPF2Czwv1jn3fsZCPH9xflpz995d6sMK55iKJat+92+rJTeTYBm00ArMV2R1ssMIfJGm2wsWGfsFK+abebfGOhWMAw27U0rK40Tum7ZZvVrcwqbKbbStjGAw72rK1xV9p+bx9H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";PlanetData.JUPITER="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAD8CAYAAACYVXqwAAAtrnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZxpkmy3jYX/cxVaAkeQXA7HiN5BL7+/w8ySNVkhR9vPelWvKod7CeAMIJju/O//XPfLL78En5J3udRm3czzv9xzj4Nvmv/8b7y/g8/v75//he/fv/u5u+v768iPEl/T55/Nvj8//Dzy+Pj9+ffxYfDz8psX6uf7i/n7X4zvC8X2fYOfK/q+UQqfN/DfF3bj+0Ipft85f/49P7flrbf621tY38ff7+/fMvCf01851WjFQs38naOv1Trft+hzZd22LvSu2PW8Mr8v9Id/u5+HRq4pnhSS5++mK0xcfuppJH0/+K9E/UTfEyX+LnqcrpRoRecr3/efdf37//3dlbufS/+G/B+F+q8i7d6C/jwk/SFC9uvXv/x5KP/6ufttSF/cfvPOZt/v4u9/fk60393zT9T037273Xs+dzeyccv2vamfW3zf8bip1XrPMv5U/iu+abH1p/OnURKLPNok2eTPCj1EwnhDDjuMcMN5X1dYXGKOJ1a+xrhiCsvxw0Ywelwv3Fl/wo2VwO/UCPYiHRI/jb9eS3hv29/brdB44x2aI3sCL6b8+H/9cf/kQffFO4S3luutFdcVVWlchSIXgvOBhxGRcL+LWt4C//z54/8U10QEy1vmxg0OP/UKhH+W8K/kSi/QiQcWvn4KONT9fQGWiCsoXExIRMBbSCVY8DVGV0NgIRsBGlx6TDlOwhJKiZuLjDklIzhUAe/Nc2p4D40lfn4MEBKIksylSmwoTYKVcyF/am7k0Cip5FKKlVpa6WVYMlWYWTUh6qip5lqq1Vpb7XW4llpupVmrrbXeRo89gbilU4+99d7H4E0Hrzx49uABY8w408yzTJt1ttnnWNGttPIqy1ZdbfU1dtxpU8fbdt1t9z1OOKTSyaccO/W008+4pNpNN99y7dbbbnd3/Bq1b1j/9Oc/iFr4Ri2+SOmB9deo8dNaf14iCE6KYkbEYg4EvCoCIbkYFTPfQs5RkVPMfI9URYlcZFFwdlDEiGA+IZYbfo3dvyJXXLL/TtwcgYj/jcg5he4fRO7PcfurqO3xiC69CKkMtag+UX03xREb15N309c2RJl/+so7u1hznnMbC9e9rbYzUVq714cs0wji2pWl6ifkHcc+oXGFc61+uNycW7O8orlzCzfl79GSlpV3GnXOxJrFnq8lVi1ufjQAsmrXr54SIaMiR+e3t5w489mJzK711jTLIESzstZG+AhDTLv5c29ZpdYJc8Uhct1jAa9t11483Omtjl1aGK7slYcH60FXljjOZpW1S7eFwqq2Q7pMWKOGdK9vkxcq5Gfa3N32J7c09ZbVXQChrzmCLomgkGM9h5hM35Knt+mCwml5pHP9sVHCENg0omvxgkhWdp6u5NPH4VbmPNI+tZ00HxtYIsrZ0vbXeJPtiwB3lXbJpJt7N6LdeuI6ilW31rXTFxd5x/Zj5s01TtZxwwnQEMIpXFL4kOR9rkREyMR+26Fawzg7HGMBl5sUHJfPo2LuPixPitcTSuY17+zx+H5zgn1m5vfJjicGabSwzxirj5oPz2jw2iVx5tjUQeFmgA1KzApX3k4l1mUsFTfLsPbmSzsWjq95HRbFl1xbOr3M6eIqyovkdadGCLMufSTjHQZRsxhuSbGXeBaXSc31vg9F3vIa9XCdyotRHSoqTNaz6Flr586LNt1GLoHMgrPfN9KEf/vVvW/KvCPeRg2GDQI1u31s7iQv6t+AodLiQSJQvh46nzc1Mef1g/yn1uYMjnKcpBSVPAkAOecJTrvRSJN9gMhG4eYVdg8tbRSLgXxUuo1zLiH2wpphLLaf61iefXMjDWBssB0JRz4YgKAUP5XYBCXSsL5FjH0W1S/VWwbZ0QmnCyxwnYp9zOAPj22AsN/Rrxu2TZJ+g1v5bpVu2JUKC+3MuBf3HWMfd4CSm1ubqBsCVYl+Mep4pdPCrJB37tzBvpsctkFNGElbMgCRAbWl+i8lnV0AxO42S0Lxz9K5+LgMvWOh9+y1ApU1Rx2R971UxOwGKfrIvAOoYp3FniB5S8Qc5V/OopKQyHYiSUEiwTa3kjVcyK1c8FmdFQI4wqoQGbmkGxz9rtF4OihsxamkLoVHScINKv4NppFU3Q5Jezw3DNJ3gte1rKPlGW0fBIcNqjTAI2ut6iY3Df8imiK1M8HZWGbg0kHOuYLxREtxQwoCOlAtgG9pAQtcPxAJVmxy7Dixh6cAC5dA5lVery804YESB5xEqfWZEvgTqWSQAkaChrhIkq5jAEoQ2GRXCPi+OcyRV4+ggAf0CFKj7CIxOrDqULjIbXKCi001XOCB9Q+TevOmxJ2OUo7zBlFK3KBGg2MP3wXSnbQGKTprDX7kqguPk/UJfXfE7mmb2x9h8+juxtqzCadZVwpfSn1VKrhByTelQNnD0twcLJq4TJiz5CZtR9SHOMdMAOAOFejP5J64lphHwNRSu22c1UCbzb11YIRly4tYF4zUCtzv4p02USPBH3U6uDL/FTKQncABcn3dA9BQRMrcXJERB9mBFiXjCGKjdhA8zS1cbz8oEMSSOBEcAgahpTm9sMDDdQVsgyvmmaeQ3ggMUjGN0LnGNQ9LVy94tLjQM8lJwAAfR+ouAIY34VYXSooIBd4IfCmqVRYpg1iZN4O8eScMS0NDsiLQO2s0scFAAktU1p2UGUzHSw6+tYSQxJyRKQcPA3MbD6YID0ieYlEuukx6GlAA75L7BcmAsIGbJo+JpU1kGTKeW40T0VMrTB/QSKfWNR7HIRg2Mg/KxuOPQMQh6sL98zZ7zFSkBgxiQE22O2EC1EdGnZQI6RY0MdSiKt9vJYMjFvGM5iexGIOXmdwZiTzALLyvwfOncsPr9Foi6ILObFAXEIcVW2b4uIQacvD4iSx+scu1nSwVwi+p2YoXQn+gcAnWmN1PMlluL/vJOh9Qw4Sh0qdRlB03YTNLlCMpyPKQKzUuRA96j9SkBBcZfPwVDsURUr02SSBQFn+5N+sAjHBZ5CbitzUP0wMWFJS1kWsCzlh8Kg/q8Kp3CueMc2vxKo3G9V4QDlWLVna6tgP6b1xQmCbM11v01shmVEdPi7CJYG3nQSLCDGgreJ0Kl8wVe82LrAHTz9aTXoWBe5vHbfiSbASaLiWG6dqGrhwIdikLCxlthIjPIiIiBV/ishHmhog7g5wliWZB2pW4pHSl2xqSgFRZmaglVTAqlNQgwwGciqRQeHJz7xp4QNEDyJiEslMqBpJI9q6EnlPd6AJADP3BzcHBXDr8gvqOHj0szetgcMQ3eQIhrVE8ag3ZNrcEH/wLEHZYxIB2yHMZLHNriMaqAETI6bpOamCKG4hFkQ0Sa92Ke8AScM33jolexK3MaWdJ1yhXZ47qDPWbKibnjK4S4ud2HBmH5ibIZ5GpUt3BEAOFmqcAM4Lq+owhCRlfS8I9zQq+tnzSRgYNWYNYi+sdzcWldYM0sVPPGPifr9jexb1zP6AbGa8EgomRLSBOR19LuHvWe7mKBuCGfK0DdgUW0YToog2XxQ1QBnLRMvCO7GzwBfSEdyFO/QoDJorlgHsA2zVMAveCJCdHLyKaTF+8LZWGutdKJgRKJwIXNBkXcJaHVyJmoLuMm2YortTeiRqlX2EgpJePXDU2gJLjbi73Q1KzXAcZAxov7BlXDynt03n7ZlQKItehcClxVnAaRYflw6lewK8A5mQeVFPwqPvWeIkqtvRkBI10uggMR4DgUk46rvriVXguKgI6bt2T/9C6X03qCkRr8EbJVBT3WJFMKtW5sGUkFWi2AcC1HVKqGO8B8QD4API4SYWEB10RbWFS3l0pNlTG8qUkfBHY4EgBe4zouh3jRyaeRvEMLieSqCtDh4glrDZXFsjsJCTnRmZ7bYMV0h6ssNpSR/06Q2ex2BPdw8+kDr5WwvPG+HLPYvCyCzg8mNI8xNUhn5vgH/65b6tZOINFMo/LJmmvRGraVzp64zzAa1IXqQX6XwCeeu6CiJ0CL3c7ouOwFLjDLXNE1JbDsoRiIZI8hagB89g9QApxACKSBQEGCGGeAzbAWXrLWOqGDGZHQs7V2w41OtZx86JwW0Oerw14dIrlINNIicgTh+wINUtuQ6MoBvQ87t7gQbV3c1cKNIdSNYpRC4ZXlNYh9/HACE8Ko5QrDySFg2K6J+eLOLBFTRP6hRZ5nFSBkUWCdH/05/klRHTSVeGUBk4AC6DkHrwIBmTJzEK7Y4EYUAf0ddSZgGIc1UyYKHTKCLeGfkio0wZesF5ZFRs6Hlt3QjyLDAmKY0CcSJIJdYwYagrGC8WFbEgEfkrLbfltAlUH0ZF+EehU0AuU4me2A3+WsDjKwMpuVIANhJzeEKAyj8giq5BClEEm59DqeAKBdd282NhVnSGgpkmDC7G22rKSSIiISjJLjVycL8qgAimQOE53DiLXYV6uu5hvCSgQZ1wSCFsEeF2fEGFIqnD9dRB5ylJYgDnrs8UNeAe4L6iztYClGx+OGUICw8xKEU0Ev2QThBZSUiW4cinFhZNB5ma7DV8DCizEOTT28r3wTVarCG2EI/EJjY3bIdsg2otwQF4AIwS8+Tsp4BUQB0FNEyB3xAqqIqWpEWT50R0jSUhLcGMiZNGUZ1IkB8rHDlzHXxR4RkD7EO6taFEgC/wzUCThj9qjRXVOxGzNVnhPQL8c4gZhQOyUikMJ7xWlLMh9LVS0PkHBTry0zZNQrcqxisj1G50AYPPzV/48f3s5ul6rO6pUUEvrgETgfVT1QKrJLT5t6rF62ESeCyombQ7Jw6kOME0ijQGiOY8+OSWqpaNeDpa/NYQAonkjh3KgfFnfWLkCkngdTGrG+6g5iDe0joKNEj7Oy2ggBsDFw9NgF/Q1XkDeCnfZD0/lSYuUlYcbXCRG1gtCwEftNqmNTa0d9UpZrm7UB/6ZSA1krgTXVRNoS5XkTrZgYzYhLnjbg5FG+NQo4FQOju68LE9NLeBhWZmFP2rpAQ1uCe+iluZE30pzP1VtaNPE1eSn3EoSu1BEDtGzudxgrAww44vFhDth/cHAeFgD/3pL/Ebm7GmZzv+FcmHJzUFaNnGQZEdD/CLL8Oy8MQn8QQoAj9JOUss1GcbB1y08JI4sJma8Uctc6GOq4XIb3L5RhyhpsnuhHKyjuW5WawIBZvBZRpNWCgb3hLk5QTAUYVh5UWSimDYeROUgEwBo2IbqwWWDuuiipF4WVzyQ4M/cSmdleAEzyy1tcVxHuSAp0nSYC6UCOqutigScSMb+NBxCD/nDyoseB3L5rgV0oi6v5edIgcTD7ZJ6IztTqzAmGH8KYDfIBKtsMg4UVBMyXWEGFp0cRCJfbKJcPPTIz870uLqAfXNcQAa8CT6wNEh+9BAVUsSqR84ShXhwC0MM4ElqRM0CdUkghCTcjOnCXG9HpFhSYSArh7Al8/0e2PGEid9EEJ2XJoJpXKQ/mvGsvdfHm+eM1UZ2wmbJIVxZ25h4O/Kpzw3AXlQyCXHUQsSrFQ8THREzUgSoRAX1qzYW9gzXCXNY7Q5Yq7KixlXsRuIA6dR8x/mWqhZS2EOFv3dCUiy0FXmB7sb2okzR2IAM8FUd1WeokqZMVTtYkodEBZQEqmgPSEu93BjltosHyVhPheuoJQufI7+QjQ5lF5B/JAsBUhcz4qEP6U7hX1yJXAuhllJlSbHK6CukAHHa6hxlIk2VdO/6Q3gr4JyXlzTWj7fMB2vrK3AytJvB6vIPSB41kaH946kELgQUBVtQYt3lCIBTRbDIUAGVvneL5DT3mrW/jOOUERVxIkkn9Y9ZwBc2cZZMK3c913ChqbWoSsY6IEKBFnTRCY1qrx+al/FH8hTZb3W0OlUguDToDZ9ZJeyv6xITXAc3hpg2e0Jp4wQ8wgTenmvXXTE1kitahotPI2HIqUBKqkHn8QcHoUVRXYo/I19XDGKFXtSinziMg+gBJhocTYnzy0EqQq6stKi/TLw63BNjdvLgBDF7Sg5VDoBvHBKpAqIJvriJU0lzjMVgzY8SYCdtwfruC6YA7plQu0OIqdsYtZMCq2XpGyGBEIq6iqFIvIzeKX7u+1X7ABwiqe5nZdUwRwTEve4/FguAAVUq1kDNExSHtklG3a11AdpEFLfXEphwA3QGM0vgxUusZ6T6r/41VLGkN0rzIKdYwznUqoevegGjUFb76nYAozmRJlSmWrQboUlqgARoyI3TJMW70hteS7Anjhi/UFVT91APY6XXbVXTsWbBHASvoqRi677qWF+nG9AbqreH8JqV268nbO1YkUUkFliNVcd5Iy0hLuqQ9T7cF6nJGzw8zcndXfEWiFcyi0JakMSSSC/I8o6Kh5PQH0R13PA2kKgNb+RKpRTw1aAJb4NgRz3JzOIN5euW3DEZEBYAVdQANukpvP8a4jTyHGVC/E/cm9rloneVaBgOTG87Qk8DDYxsVt+TaNvevAL4H8EZ8mtPnk+RnLhkqqEbSNur8Q781pOLw24AjOeDJkE9go0GLVvtLghYIELakZPhNe5JsjKvsGkMgelUr08o5JAtweAVaBpCjIC/uis5Iyyrnpa32hio7YI5R1UfuEiWywIQwgNQHdBPLG68vVgQAS1BlLBRplYrmUzRojquAaVkegMmUTHk3OXq5+tZlZ/eNAjvCFgV8/uDGyalURGmTs2WPH2gBRxc8jpjJXmvgWkd6vo27IEmfKCrnpB+2nCoXhtT+RmZVhr317XRh35ClfSqeR/AqWKaJBjwbajn3aFRterFAi2SkOqFde1NZ4FEkeMAShY1w1JHTBH3lGrB0ABjc5EccXsUcqau7kH59tdYdJcspl7UqcQS5+01iYHL0S4SFwRtT+xUATTVC7mkD9L7KLZ1I+KTtjolQZ0EcJXuGKwH5RDiRtRRDHgQhAoRO1MtLEhuo8yB76rtL/0Ot74SgscvfuS4SZK3ZjWT1T49mktZ2GUglnS4qLN2BVomkjKizoVhRqivVg6serSccUBHHcm6KHyERJqzaUNLXSH10KOatF0Jh3IETfoIuRBOq1JqcuysxxOtA8HeMbzcHfBFESyykcJ8WvcG6RHNs1R5uRCUgfhB3F3OUHVTL0EiR3frqE4kZwMfu+ZlkI6QT3ktximNn5HbHq24oFS1janTit9Gz1E5bW8uCiEDHUV++fp8kYVEHGMSyVB0MoaxHgpnWLvBa1u0J7IKl0lqLgwrWAPN1nfVhN9f1hpSpnS4IuKnnjR5zO10jZBxjUH7ipLnhJrsJ63VUaoYvoXehjUoyuDQaTxa0WIJm9iUckIEjITYV6tXvaQde5WeJ7YUB5dgZz+HBXTgmkdu07E+lBg5imjFgKA8YPBoWwIZ32pqUyo+zxVTgLB+WVI+IGbLh/eEBDEcrt4lV8/aIi8o6ms3a8+L0j/ccZWjDpKVku1EGloASaoPicceUgTHiVaabuJKFwxz0JVbs01YYbVkG34TYFNaU2W8hfCHAoGKmml/4MIFsBOsC6P14CCLpL3dpqSUuqWCSCDZGpRj0tYta4n3PuoCRiGD9oU3NA169rW9sXw+ay/7YHBzw8HAG8DubphNpIX22hq6yHu145G0QuzXBngAMWQ8CG0H/nigS4C5No1R0NrDwu8NYJZ71QxPfO0KnLMN9cvw5UA3SE/BLDKS8hCtREK33avspa3AXbQJS3UuFeLWNFIMHQ0Of3rtmcOTyDgfUCpvaoYFzIcCZulWgbIXvkEDZGgE2KVoRiQeQtV4AnZXSveVdASzJ8IQsqaI4ODGHWLRcWtYIce/uKVjJEA6b9sJFsqXN1OpI0BT7RMbx62dUsHTypINGazD6nKDSSrejgMObCCAuLFRwWDIsvEMnDjAlJuJoCYlByYiswEuBKp2b7lptR5yvKa213CbJdwQAYKHsoXHANYKKKNOt/q02m6Fy9X4VQeW0gqoK25RbgQ3MYgNtXkdiI4lkg7qVJ1VdV87bwhlHCBmFFJ8JBAdnQnwoZjkiiFCBM5tUdo2YUm3U2Yin3E/6oa8vX8uXjM8qHDqYXmvJBQdkgjwiGQsbhsy8hRzWdhDeDmA2Ul7HW2yOBEfkl8TEc9QI64HbMtgdYjkr+gYKL68xSAAnUBXoZiaiR7FRoUNKGR2uLQC1RkcAsSuWl+NTABOWPLetNUCBirHV9KW8F5KeK+RCXyLY6mVjBIL0CdgWBK1RbjKAUp5ZUJ4WLQZNKFTJgm/Ix5B7VhyIWhEijiaS10tHpnqCmtN9VdZGrKka8QD7Q0gLo2LzHprVauggUiEFX+1OibnaMjGTOMenoL0ytJ8NReJtoPnVdrorQLiLyI2A5oRt3GiOMDW2w7Xvh3FlBQBV2QQgbEszcIlsTjkxlb/C/ohv48aB15dm61tBP/Eo7ZlAoLqZNZCRJWcJnGwVzPlOjUpcNQ81w629rMG/IROIWnDfvvojYpL582SRegRkK/a3cWAOgQEwM+/9lUbHxRVvYWL7b0VlV1CQl3h2xGWkZs86ex0g34jnYGoog7umE4jiHoqikzjGggy7VxyRU3tAaSYj90AzQQRBAGtBsEmANkIQDSxDinnERFLXMHbUUEa2ODmNfKshg2AD+Hj5eDX83qY7QlY6dyi3WRtZSbTnk3qLqljyJ0VdCK5i7IRHwq6qRGMTQgAWrSq7myamsEpvmmDC8pF//KreUjY65IkAyZ68fqSLUWbkuhA3ES//SE4VaiKN4AGUiRDiVlaGrcaUeMYaAvD06abPP9xvUfzGWpLIlCgE6q6x8/GMk+jPrg2AIdLNfE3iyYF1rQ1jJl3SZul2B91H7hNNX+UGQB8UH+nEpQOdiBgJGOf/MpDcxJgj+SzGlFAAEJLPOTtUgekUNhSrROQQ8GBfhe8DNot0cAcRlWIN6A7L4vL7yA53r1JjdRRWaypPxPIL1v738Bza8VIfnW6THnWDuQQ10JTYl4yWhn/xB0kCPxSnK51aGdpAxOw0v5zBOCgiYwZadiTVXmrgqeteCTTyEtFFKg1glnFQqUJCxNORzg7kEqk8ccLg8TiQMoyImA891MHNknDmyglEo/0zhI0aDjtP18NEqh35V5DMR50OZeS8cKgQNQsl/BENqllFhDvFkALgOior4rz6Y27bgICpBqExBVN4nkIsfahUyY8hFjb2GAXa8wlYLHt7XOpAawpAlipqqlYpfsw3FR9dzFk7eUVDW/2DOAkjRjBeyfxztrvHZo1QJBSpTBO0ewi+AfV2NWsjK3bWjWH9SnyE21SS1m7h9wOl8V1gzd+d+17ICUyEInSqXeHIxOAQK6K5rkEkZdE+uUDj86r9gQlKkWNY2EJGujAvQpRCQ/cULVrq71BbcgNr44+WoenVw0OUEjaSg5AM+XfBIT4VOIxCMauhhAIKlyNMzQpsqEBpYKERMJkTUWpAWYYP/E9rHFJZmQFq9xYgKB09iyuJiQmSP92YU/BMrzJ1XGzqjsH8hiGxjS48LZO8F0a20NhaStXM1fhs7XVQZgJ65/WtJGD2S3wO4gSNeeKLgWtKNkwHbK/6q3TgrUiNxNkMSUDcC/guyiTalxJJl3dVikwyI+YwLcsVgM4gSmHtMIz97epF5paXvvl6pWXlVbyJ8QJVuyntVHoEIqQuLPWUBSvQ/C5NXVN8Ghn4naG5rTAoKVxrVaQD6bxmfMOdpAnRBAMtzdZJwec7obQP0zgotwpl4RilqMBzbPeKmp6BY2aIH6k50R8aP+Za02aPCVp3gyEusj2JAvyGDVCRcvxdW3UqyU2pHyj5ryAXPVecADQdkBroEvrNSzcxPwHchTNe+A3J9GyICEuE+hmoaemSEbTtAYkqQZnCVO6lHTQECGcA4ONNx2YtsfVkgt3Ozn+gQZGoiCsQ9jc9p0jCvq9CJu14t/II/X3EOpdJgBzgaOhYIf2zCWfEezLoFzUSsI3ALW4sQwLTkoaPgPo1aECOzVMrkmXPLkpnOh5tuT0Sepj5TDHidfv6rZ7TDNYeIJpckpZri5z1sGNqJ46RD/Ru1G62aOCoECgEfKAaQPVX4FIy2qYapQQvdnwrJBn1hYnC9TO45Uq/MUy6OEUVNsjgupLVBOKuB85jnZKSGCeosn28Gwd8hRyvAudGMRkKDNki40Vq6aOeHwqGAF4Vg2KHqn+1jaXoTENLD65ALeoqQZGahpPtyMDgJ+tWX0/GBAqfntoSu4I6hCp7i6sep9jg+YyvuaQplPDWtpPtyQ+HJGVYY2GhsKg40by4l4DS6TtWPgHESH3XaSnsAgwFuWcIF5cD3ADAoH9W20A7rlqqk49FXgQGtDIFTH6zDO05kIl+8HSqb4BBnf0z8kys8aFZeFmUGtNTa2K5nqgptFvlkhuTpNIjXd2spiaYutC5Z1gI9C+ZDQ9L0n63CE5ag3x+M564aLioznNE3/mJre2bhxAdlET8nWCuhY0QaIROu0ZgE1rvEnxwaVCbhWLJ0rWV1yddlqa8NmmJqIqKUt6a2wMIK3aJED8YYg0bxgQsZTB0kD29HgcHgG2BM284xwGLh2smpgajfT7JOOMX4qIQIqEfJ5vrBDngOrb2sILUHQbGgZvkEHQvA4O4rLo/DZfF0XyvnABoCb8V8ebOEh+noHjwAYgthbQ0rxQy0eKY1UEiwBeOzHkFfh33SsvST5tdnSAN2n7nfTmznDCSrewhka1WKYoCGmi5WOYW2woyoPQld2dyTUerTaJrAGPnp4qQxSF1D3aOwA+QCSQgrbAo0Q8x/AAP1XbNApU5cZdUV+lmwbkIDdEEeZlCYSL5qp3WVODdRBYaxqGVfHd/t6qqJmLnCh4zQSLBCqKV9R7lcX6H/QvlV/rG2mTgCGfEk4Ai6wGS6+IcIUvJTWYZWipRBZb+1g4f1ktsSEMohFxMBTvttQd05EWbpAiJ7zaiQtv3g8q3ciLYDgXgNLJhVCLoJu2IGa5QFzRRK7OxwS1kJE62CqABjrUxM3us2nI3rx+Yvyl3oPj4vSisD86z7oGk6veHazXWNzhgmHdaRf/JHmOojjqwWvzCIZFMeuUUNkuv6mUQYjh5KHxzZLk16aaFTxIkxfpTZLNiYMVVUqJLG1l6bpv18B0OJQIyAMfKb+WDye2DpZnaENCpGsetOjIo3Ty0W5M2xjppJ0aTSqhYavkAvIY8R2FALy37FbUxjFrFYizYVdRLO9XGnOg4K+aAEPVRKJCns0QSINUdmtaip0q1oQkMSvIx5rMXy8LerOOfN64P+MLBwHUZI5J2ixgkfbJ6NIzHC8z3l4T4KEa4RE6eSixrlkI6Tow52i7DYmu4bYMNqCjABwgI2vYB+E5HJLUVP3eayNQOStjeONJSGEkAIaVwETUydaWYO2aW9fRGc1jnKHjW0GG0PF68PUOKKoUMZAYOq35kZEthBvTkdRIMSIKVoGxcu4ZJb0lrxEopCWw48BQpL0Ozi4hGSpDEk3zmS2BIBqbPBLHwLVar4elIc7xMUftGi1Sq4uijTqZUXSygrUGuApUrMm3kJLaRcjbuXU0k3VKTXvUAJTha85LYtB2pEoouuMHUhXgDXdigEPD0ak1I/tvGleCe6EEtcK9lauF1d7XCS1FfIC2m4WFGL+lPtTW6J9pPAjqCTJshGdSLae/4wsU3NDxIo1Q+6792+v3XcgpnLCcjSMgwe/VynNg5Lrkh29V80raqVM7NejEBxHM6kIndbBAJh1muD1nX7QV1gB/zXZRYO29N9L8btS4Dqmupq1aFHmcu8MvxDRpbJoLKjrlwVIjX8kibjU4TGxUr2io75uW+Q69YDT6O3ZGDg0tr4z0O3Og9vBCCkokygBPDXF1HzUy3BeZgpxlMdWcmr6pjakp/YPq0G4wPLI19iV2g3lZzrF1yHdpZP76VnYFjySs6mPBCngOHc9aIOPV/PVihTs2LOh89dTBpxCHZi/ePAjaH2FV1QSf0dWGL3v7sSt4feGaj+YtWGI1W1cMYvTIo0EQLqMPj1pnOQARkleb75rcdXCrCksFDh95jLfmqZ6/0Rkh7iGna0i4tvKDXojqIHmfcrxiP+3XGtXPSx9oiOvWUAeoJhWjI2maYS4aKJ9BBD49jA+mDp19Qahq5pfXRNktWMY7vKoacGC9eiDKM9NkkiGvqrY2NY43wDUvC01gcDqeHNQQqUkSIRdQQnYctIxJVIdLsww1kTFdnSdISgmKDdCwoddwAHcrDAX4omaDTbtlmkfnNvH9SGj1KHcLGtzCBEk3aYuhPEBU8wBiMx3bhx8pcY0B31v2TToNYqaJdLPgMD8Lm3cfWqgLgebQSYGpJnIFOHSQR/sytbyZA23Mq1sCcgBqZz6jj6JyO+GIqrAW94SRUwvALmZZ6V0lmyhq7T0W2AQQwNBJy1LMoCwCFDkufm0uNx1n3I3VfNMG+62MuufQNNJ2gdpBjXnCawLPmKHynS6FQeBbeBOkO7o5qF/12Hh1NVGwXRJAgvX+jsi8fZjPTMPbrHpbEXh2anBRWAcoQFtGp7FyzX9TcVC49rENMSB8VoOaRWM9mxpqK2EATTu1WScDNLGJpRka//EkulOvs4p1DFjXhFfxz4K1j/Y9qBx9xEJjXZc2tvAzwMyMYRFUr80LUV2JzjT1OuSIIboNr2jjQr3Z4qMOOiztSiGCyeUFG+jkD8htkqlEtWEpSoJXpoMwxlWf/E3Cy8YJqHRsSE2aqGkhSvTi7UupTUcSOjJOU6yaBkc8em2xtKUGAouC7ljbRw0uaXpn6RSxBc1ZHRE0sVC7eYunuzax9LJgaX+nOVRUzal23zAashCFSdR0aOToNMdKlp7+hBTUVIT2lkfLam6qZyyIZpQRwwehyWLfV4foyr3e6GDUJWsgVw/TjKAOI0EXOmrGsxd+8PLjStZq+24BB0tRCxKiJNXVWFXC/gtudXqI1EM1rok91/zxrksnu1bScJXOm7AgDSTBpyxo3dxpOqaRjmA0q9cKMnRNJEDrt1/QkgSjKPl+X1lTNX81rN4xiXdolBAVMbzT0Y+koey3JTKRmrwhposqBbI13aU98wE/ID7Uld8pNNWyHnFG0+gnlIRdlxHl+VPDWNrci9K+FvxFujcdHCOTZseg4S66Ds5ALGdpm11TXVmn1WRw3FAzZWfteyGHiw7ibrWals5QoBNJ0J5vMx/X1bkJzWTM7DVvD2+BdWA0qoiotRkgqKyeb0Q1JI3omE4/j4H41/mHVVm+TFpOfrLWGwaCT7W1LNhOXPatOghHscLy0iakGEtC2XbkH6qJoAkPTGMNWy30VD1xkABHnPEEQLsoAvM4KBVpFzTwdDX+rvMKK+j0tk7BHxPEVDUkNI2h5j92D2ZBMYnAWXI19vHWTkQzQR8dpRkaxNRAAGWftFMFi924PrOKslC6EW45KDNEL4h3lgrnN4PLss0YvazzkuVVGdev3U1+BpIVFKoAPOng4z2Kdjzo2YDuHlvzBjoH35vTkFd7h1oupCG+1xghvhL9qlGr3gC5iFiD4mWAlkbvtfNCdkAru2se/9Ua/nFsTbjZ0n551CkKgv4mtqUEo46ySrhYI6l1zofQqqlKHDT1sNU0IiGFphpHJR/RPmAC6Pgm4A2ihHgK3qnoI0B0zC7LmOt44Du7R3Wsb1ezdKSfDwsvo6lXvAQqWJ9gAN1qdBDE9cSgdw0RoVR1HHtqgqbqmLUOpW8NWVipnvBPKB6zclCOSaNlMFLQHlrVFoPGQHVGfUjlIRgeqhSTchS8yDpdfcBBdZop0skF3gGMVFdVJxN1oPF2NYggdj2BNKo6KI3r3iZZElUmE92niSQQAr9291AED2kdUsVaJsQYYipn5fjUkHjXpob2HhFqQwPc6AodXkHpUYftRCxETGoFU7QbmGWd3ie0gLBeB5LevsoR4qI3IpcYtGME17FQGuk9kpcaOIrbtdyCTBrAo3MHHoWjk3MYOOKz0cpJn2lAkqhz4bdOn5JYS72momasuuQaVQBG1IgP6sVo/Jq7glqBt976PRMbhwIIGrPR9h3UqcPQ6jKP8Q5bvHkHKRiHTMTDTRh66VMdZDRIzRlRX32DTliNrs2Gerppo5ekDtrDgrTBGzXaV8OVVDcl+ZuezvOizjSXzqJ5feIF1gVluExz+43K39pvbkN87nWUliRNT41CGq7qUzriUm9PZ1rfWDVFaoBa1QDb0kl06Gup2aWpi5u5bB3MU9t66VOWturgTY1l0wbGCZVrf5/1ID4/U3uNmrUuS6eLQIyQmyWMtbwVwmPq3OvCKK+oBoKO6UBt2kIQe8j0laIpck02EDpWAiexKdxSNOZNgHeBDIrOpn6cnQaTHQtiOGmjlHQ5MjJHBEW49NkJ2vAteh2ds4zqk1uW+t+E4IT0LEsV1DkUZtMnFhxteJKsEr/6LBNwlZtFNiEtfMxZp4OqPpKEhSeN1MrUGBg6vnQNHLn26jgiT0htuVidudERSp3l16lTxIbmHtLR6fV3flAdwaVPSFCXN2nritJ0XfOvUdIqakhD0mYinMlS8EMaAkNBvXn1K16ZkHU68PEOxOn4YXrCcGsTqhsB0XJyR0fAsfVpVfpkh9hkFGGh8YGPEf7tZyrA/drwhgapPm2vgCJTtIZczwU4HxoLrLmjQGQI33yHTlGSf9N0XrSAEYgTxKjpGODUBtLQ2M7QfCe+gpgs4FFtLQBHbSUuSB8KouPxoAHVN0krsFbD6Ndpv0kbG2Bokpi+pLsO9csQeMB8F8Qkho7reDl9AvSWtGN6s85qIrmSehc6mOs1w+K99v2IqHETUxmEy9QJLJTgkBa9Uy3pq1OmAwWt4xmn6BwGeZ33hWmbzvIg83rBeKpvPmNUy06fB5HV3pYv0WGdo/a1/BFymLs+l/LgO6ia4nS+eKSlvS1IsKMReLIRK2TqWmwdPqhqlRPcrSledXF02BZO3PH1wKpaosttBECuWxyCnlXnBEE+WMGgg6HoIvLalNk69V11+vxWj0nlvkLTdiR1p6FJxCjfoeqVclQ9rvKevIeO1yCJYSodBz6viyXvt6ki/3YQ1KXS2YjakU15OAm7DUyT/mna+9iDJP+pne53eAil0qsOIchS6FCG9rRZwyt5l/VZKcjUE5yfOqLH7WlE8n0Sz89LmD5fQZO/R4ckuSDdNzrlfmpOXY/XTRGZWnGx95TewZr4htM1p9xRKLJY6o95zYvV91kYD466xs+t6RMUDA34KknTak4fniKzl+6TY+PzmXUvJbM2K1A8bX6ZOuf2K1P/8av7d7/wmhVHDbSkH7wtTI2rTSjSAB4d6WI9yJMw8bwlOX3yB390aksb1ZGVqtDz1MfcaJnr0SfzgQ36sAWNLepz0dTVyDoIG9WeSqp5B/s0RJdtHcxt6tVqe1A9g07RbQ1/8MLa7NO0LAW095TOhQQyxkCvrw+M8K5qSl59CfUyi07X6WMpNLh49blwU0fzNFTH0utcSxdFfI4C36nZE3EtIu04GJxvNQSEpClR52E1ILzUZUnqtvV6G4ZoaJMDbs5onooge5/Xhv1catTjj6m1JPwlGxCxQx/KhLoCX4BUHd0MqDwAUI3gqWN0S7tRs+rw+MAusuqwku/viuAt4GDi+7DNS4f8dQbsfaBT6388qP2ng9v37u7+D1mrqWz+zKkcAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4wIZCx46Fc2BdQAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAACAASURBVHja7L1brGzZdZ73jTHnXGtV1d77nNOX04ds9YWUSEmkTIp0HFEiZN0tyRLlmAmkPMR0HoMAARLAQBABSR4SwEECO7Ae7DxED7FhxJJtwEFiJHAMXyJFQSALsmRTlkhKbF5azb6dc/alqtaalzHyMNfe3XIQQElssSntBXSfPrX3rqquvcbt///xT/nOD3+Y2+v2ur3+YF7x9iP42r029XXA1R3dL1XOTgf9iR98n3zpK5fyd3/uCyEIGhTedaZpN0r43Txnc6JBVKhz8eWVc6uXi0szZAyUq2xNRHwzBTvbpbbbDqaq/urh9PYXcpsAbq9/kdcz20sEFzOXq32WJ++l8CMfe1faTVF/5XMP5d1PPogP3zycnZ/Pm2NO48Vi45tvnJ+0edl8w7PjWUM3tTTZBruXopwB4I47iHD9V/CblxSFO+bcA7/YRnnp687Cw322aTZ0iPI6rvsGJQW9GJM9TjofFS+b4aq8emHHY/a2z16HMbSn7k51GtNtcrhNALfX766ivwYQ3veeu/LHP/5CoD6RHp3vN6995XJ6+Fg2hpy0pTw4uN2N4mOt9ezORp8dLJzWpmG4LKePXn34YlJ54oUnhrhICPOxEr0kDRId8OZYczQquv7dZU0C/c/kTjT3GuAYhVKq6iJSHGZrFrOLC7ypwsvgxVw9qrx65w6/ftL86snaXo/Kw5OhPJSWL88PF8vj2cvJNtYUtR3j/dtf9m0C+IN9Pdhe8F1/9A/Lxz78njA//lK4evha3B9Pwpdfvzqd9+XkeHH11BjtwSby7Mkoz4bTcCKQ6uH4zOGgLw5iZ1cXxxjxUcRDM5PoHnSumyGGpCLkUolmbAeFIBSAdRAIQUkiqAomQjMnaP+aNQMRrNm95rAR5SSKmeM512C9WSgifMgMzxWyat7AlRuzl/Kq1/aaqjwy0ZfuSfziqfkrE/bbm2Dn7l9ZXjm35SKT75yNdbdJ9pXD2e1NcZsAfv9X+G/71gfh4x96EMvxXjza5bh//Prd/aOLp/Nxvq9up++6Oz7zsJbn9m8+et62+uxS/D7eTodBggIilrS2TfAWazGq0Ct5NrbZ8GrMbjSBEISzTWQYlKrQknId5SFGQui//iaKA0kcM8PMUA2YGcWFEAMCWpsxlgwh4KLJzVMVJebG1g1xf7JqMGp6kbwUV601pKNu2tHN3rSlfN6bPXLni6en4fOnbp/fxPaVYOXymK/mhbDsTsaWovptQvi9ueSWBfiXW+VLbfKh9z+p3/GhB/Hy4nI4v8pPPH1n86x6uV/NT5zwzPnDqxeV9mIY9IVa7c7Vvmy2kWmMMlbz5CANRemte86NZWmAoyKYO1phl43j0njkcLKNnG0jqoGGU1Ro4S0c0EPCNGKtAYLGQFTBgVobsoIE1xBBaUarjUEAFXI1qgsqoK3RHKoohiDWsGXhaIIhmAPmtdY2l9KqOwczv7BcXvFmn3fjc5dz+1wM+rkh8FDdLl9+3A5HC2VMtyPDbQL4Ggv6P/5DH5cPve9BeP3lz8YvfPGVTYp65/kHZ8+0urx7nvN758vjRzXYe5vL3Zx9W0rbgEwpyRazkKuTxIkKHhQXpTbHrc/p7o6qEKOAKIKyGwMbgaUaFpQUFUdYPOI4hpCb0sxw7yOAi9CaE1TQILg5zRxzBwcNggC5NEo1VCDFgJlzXCrVnSEIZs5cDIMe7O602phLw1fQsTWj1EYIigBm7stccjM/ivtly/U13N908y8Bn7nI/KqYvTSJv/Fwb8dMnE/PpnbbGdyOAO/IoP/Ej3ynfPC9T4fXvvSZeMgX2/lquLeN7f57npm+rpo9J23+RvX2PqU978pTzdgEJU3qokqfz80IUZiGgCBEBUNoLqTYUboekkYKEIcB4pYYBoagBHVOouEuzEuvyoNGwKnex//WGq0ZMQRE9YYRcDNac6L3MaBZTzJCD+AYtAevCLUZu6C4OyJCa4ZoozQjV+9gYopMQcHBzFlyQURu2AdVhImxVBtVuFNUH7i7uXN0uLoz+au2lE9j/hsbwucG4dNbP37lLF/uL6qWzRDsGO/77d13mwC+Oq0T8Mz2gh/7nvfo2eZ+apzvlqt4b5P8vi3nX3f52sXzg9oHIvVbc21PXh3bTvCdNBsHRRuCiiBD6BVbBEeIQdEUaZII4jRXFGHQRooDIgFrC1AJcYPGCY0jqoEQCjE03MHE0fIW3SdATGAtshQnSm/3m6/wvzophl6tPeN+nRQa4yBcUwTNHAGCXj8GIoq5U5oxJUUFqjlL7TSjqqM6UJuRc10TB8QYQIScq2jUFIKScxtxvyvIu2QavgG4Opn86nAsL1vjH8RRf/HJUV66ONRX9xcv75+8O9a7J4O9ejjjNhvcJoB/qZeKc397xSd/7Lvl/c/fDa+89Bux5sPZ6SQv5Hz+/NWbly+qtw9YXT6yLPXelftpVO7k5tHdSSodsBPFvSPtYUhMoqgIGjeoBlQFR3tlXoNsGCBEQURwT+COaEDjiIQIIqgoISpmjtHQsPL8wDj0P1uBEHrollrw5igRDWDeqK2g0qu7rd2BaACHUiutdQ7A1ydu5n0kkZ7QzHx9n//3z6/VdvNz3CAM640YlNrsrTcMQVTuuPsd6VnmvQv6TeMofyK4/9ND4ZefSPrL90b7QjkcHqZ5fwwxtDk86f670zzdXrcJ4Hd3ff/H38uP//BHZdk/1i+/9Jno4bDJe3liN/j9pdavp9p3iNdvXub2HO73Si53S7XQzCkCosI0DUxRKSY0CyQaQYQ49KAXVYapB7+IkESxEDHpM7MG+R0Bg/RxQGPoo4EIqiuP1xppEuIAtQDixNj/21XRFe1XSUABz1iD3ArmhqpSSqO1igq00si1UUrtbfwKCuI9EVy/K3WjlcqhKe6Cm1Gb06zjB+1tAV7Nybl11mHVJpjZ76jibk5dKhkhRU1m/u5g/kwT+YbdLn6XCq8m/Fdz5eeq+S8/usgvm7+yT0FK2j3lIY23N+9tAvj/8eGocX+755ueutKLN357wu2ps408QX30zPL4jW9ueflgmQ8fzCW8J+d2p5lNQRAzJw2BaI6GSBgiu5MtQRVdIFifrXUN+hACmgbSOIAbokrQDtKB9OquEXfDfUXtQ0REcW8dGdCAWaUtjiCkUfCqiFScSqtrAvB1RGiF1gqlFqzV3jWsrbk5LLliZghQW6O1XumFHtilVppDdMNEqCjeGjbPZBOaCNoatTbMelh7NUQFA4oprTnWjJbXWcHfSnEGFAdtnYpEe3fhEMy5IyJ3gOcX+EaPfLvhvyzCL4nzj47ZPreU1x+PSXLaPuFh2NzezLcJ4Hd//duf/Cjf/pH3yrJ/qC999tdiDH5nPv/yC2VZ3hN8+ZYx+Pe0Zu/a53KnNju1akNpJji9ekdlMyZMIpo2jJtIGkfcG1O8luIqYehBr0HROBJCIEi/+XuQtt7mi6KacG/YmgBEZGUE3tbuWgfc3Ay04a0BhrdKK7Bko7Q+g+NGbZWcC7VZf6z2n6/eOhvQKt4abm9FppngDVwK3hrVDafjF2ZGqxUxR11wawQ6lgBCFMfN8eqMokwq5GYsbiTpisRsYAbiTlpxh6E2ioEKWFCoRjVwEXXnrrufbUZ5LkX5jqt9+2xr/ktD4O+b+afPH77xWMXzuLtjm5M7tzf3bQL4f77G0Hh6d+TMX9arh9uNW37qzlYftJbfK56/Verho1brNxysPbtUT8di6AqI7YaRISpBBI2RuN0iaYOE2Nt67TN9CAHR3q4Pw9gDXAVzwV0IGhAccyPqiEhH3nHBBJSIuGD0RODSaC1j1qi5UouDN9wX2mLUajRrlAZzqSw5Y81BekU3c3BHreKtQIVBFRCqGCEJ4ooVwTCKGiYwXssGPXQw0aBaxIZ0U8ndfQUSDQ0Bd6fVipt3BkIDx2Kc1kIMHTcozTkeK60YsuIQJQrH2hOnAXkdD8DW13UNQe8YfrZL/u4p8GEX/965yM8P0f++w68sx8s3pV7lMJ562txSibcJ4G3XJlae3i38ye99r1oraQzt7tUbL73orX3A2/HjeV4+ks/tPrU8ocKmgGSHOCSiKuMQiZsNKQamYcTTSEPQlG7mchFFQ0RVEVVSSh0F72WcXHobrCkQ1uou/hbSbtURibTawToRwekBZdZwM6wZVg23jNXCPBtzLjQ3worqUzNaGlH1pt1OUpEAniIpJgQli5LSyKiBOVcOuUBn9Wi5oOZo6gqDpWrn/1cg8FprYNa5fzNfwUs6+EkfM4o5kwiyMghBhaU0LBW8GQkjuxCaI0slWcWaM+8CpTm2FKwZtTqLKLOYmPvGmm3Mua/Jv7453zVX+YfW/H+es/+aLefnd22f3/XUzi7LlkONtwngD+r17/77/w6f+NE/xm/9H39Lf/0f/S9pGuTOdpyea3n+Jmr+nlrtD1tevi4cl3u+lFAcdBOZNgNTTMTNtlf7NKIxEmJk2G6JKVJqb6tTCjhKiGsy8LWtD4m4VtFmxiB6kyzC9ePNcPwt5Nz6DG/0ZGGt4sUJJGqp1LmS54VWF2ozajGk2tqZ9LZax8A0RlIYaRLw1ogihHEipEBIQnWnOYxTQj0QjpVU6wrMNazk/vrqVHOiS3+Pb9swvKYQr7GFto4Z15BhMyeUhkrHOOpcaTgSlXEbAEcBMceXSkgRpXcswWFeKi3p2mU4Q25skrCMii2NxTxo8ful2ZMi/hzw4aXwi1H4hVzsn37l4fG1TZqXQXeedXebAP4gXSep8PRpYXr5f9Qv/GKLtpzfeeap3QtC/Yao9pG5yr/q5h8YJT/ZrAbB8RRQVdJuZNhOMG6QYYuGQBwGVPufwzgRpBEjuEZCCIASQsDcwCKIojKgKEjFxIkxIvT2WWg0a1h1XJzWSg8gcwzDasGsYaUSCuBCORyYj3tyXTpYiBDDQIwDceiYwQZhGHqiMhJOBIewdiVOBwHVHaci4mCRcYyE2BH71hrEtLb9TljVibW2rh/AcdOe9ELpbEAL+LBQa6HWhtPneaEvLJVmDKF3O017t2Br0gvixGjEMeFrp+TVOlUaww0lqUEZ3Bkd6lwI1SnV8VxDrf5gGuXuPNsfKtW+v9b2c0fz/+E4y6fh8dUTJ/tquvEcTm8TwO/36z/9976fB0+dya/92j+LU7q8e/Gln39XSuH53W74vmrp4+14+SBJe7Ja2QSqSBBsisQUGccBmXa98g8TEgIiShoGUuwVPKj3gE+JEAdiGjqPbk4tBqFjAUIn6Y3W//S1zdcG3qi54BWMRq0LrVVabWubv2BLQ0qjtIrVQi0zQmOUhIQNadwgY8BpaFDiMDKmkSFOuAYqhpmiKCJdHWhllQCb0Vz7yCCKxkYUqEUhgErq4uJma7UH14B6wGg0yoppJFQc1wCqmMkqO+yJJqyUp+JdiuxOazBEIVdWVkIYUr9NS+3jg6owjXEdKZwltxURAXXQjRDMOSyVGgQ1lwibGG1Tl3q/NZ4/Vv/mY/O/F1X+wXGun0tycRX1aHV7/zYB/H68/uP/7Cf59m/7KL/1C39Dl6tXN889vXva6/yNKfkPBG0f81JebHN+UI/HYK321jYmptMtIdFb0GEHmzPSOKJpWGV2HbiLQXuFRwmaiENc6b0Jb4phhOQE7VSeVccotJWCa2Wd4Sk4jbYYwQSvCy0vFBplqXitBCuIeQfJmhFTYDo5pYVIIzHGHdN2hwUntyNKIqWJEAZEEqj1dro6eKEZ6CoybrkHXSDSpK1tvyASSMM1nmEYhjahFaFhpCS4RyDQLFBoNCsgBmI33UVahUqt2Q1jcl3FWeXPXWtgXUko/fFS+h6BqpJzWSnQVVYgwrLUm5GpmBNVmIJwMIEgiMOkgg0aarUHI3zvtNg3Ho72kdbsf0X4+cOcv/xEfK0QJl/C2W0C+P1y/ef/wQ9yP/yWvPn5EOvx4t7lG59/Dy1/MA3huz3G76KUZ/P+KtRcets5bVGNhHHDsJnYTOv8HhIybEmpb9lJCHRB34BoxM2QEIgpolG6Dr71G95bR+ebLZg32orOt9Krem2VVjLNKq0WLFeiBSitg2rqhCCkFEgiiAy0EIiaSDGiA5gqzSMpbglJMSrJBrBE0AFRozbB7frX3jAKSF8UcOsjh4piZjczvWpv6bUrd7EmPVldU4rSn8JsRf8NXCqits78htW2Jo9e2de4JahSsJuvBenbgw5MqUuMczUs6o1CsakiKjcagxgUxsgy92QWQ5cjpyGQHDQopRiFPjpoEAE2IvLeqPJUrfah4+LfEaP8jf1cfvlYysVTp3MljL6EO7cJ4Gv1+rN/5od54s5Wjuev6/7hvLl87Qv38+VXPqR2/BGCfNSd5+tyfMLKrHmZIQwMu1OGIeHDhjBMpBgIQ0RCRDQQY+qyVw2ElBCNiI44ilXrTjsBwGk103LfjGttxtpCbRXxTolVK9Sy8umlYHMGc4JW1Bv4iKZImCaIgRiFFBwNCQ1jpxbp236iimqkw/ldzy8IMUTEE0rAxRDrc3nf6u3CHiN1BWDsQh0MLK9fD3a9BtDn+bpWa3fEteME3mlFEVvVRobQCAJ1xS9FdaX1HP/nRPsi18+5/h2IKxNiDsPaJXQ9UU+Cpbab57keJ1SFmAKhdB2Da2CzKhdDa3iDuo4QtRopiqYY7uYsZyH6c7XaB4+L/Zwgf/tqrr96nJc94WhnTz64TQBfa9d/8Wd+mLtnG8nzYVPz4anjxasvel2+XcW+R0Q+IrU9pUHVTakake0ZadwybDaEGIjjlpgSiqExISESQ+yPiXZ+Pw69FUWxYoDjbe7imtrwlbZquVHaTC1zV9e5rnv3uaPwBlKd0CClRDrZolFBh84epLhKfwOqjujQE8DKh/u6J6yh7wiUesS9grX+c95WNmHBrSIhrIxE3/HvzFwPfgm9gmtXFSHq60YfeHXMaw9iu0b8DazhrSBusAb+dTxHEeqqehQRxPr3dOORvorsJtRS+ibh9bW2CCFERFY3ozXYVRWzesOOuDul9IQQtKsQr7coggqWK2rGKD2JtTUJtPX1Y1QFu6ei3+FuX+/ZX5yX9tcF/4UnNv7G3fG8ZR85z9NtAninX//VT/1Zvvl97+G3fuFn9Xj5cHu8fPiiHd74Iyr1u4z2MS/lOQ26CUGFOCJxRGJkHEbSODEM1+Bd6ui4CCGNverG1Of6EHAPqzTXqblRlwU8Uy1Tl9YpODXMr2/2RquNsI4C1RpqTtTIMCZkKwRVhnFEtxMaU7+F1xVaX/X1IQjIiuD3NIJ4b7WtVaxWWl0wCqIASmsNaRm09p0ClS4marKqEq87gR55joF0FqC3+j1JmDnuBW8VbI1yc1QNK29VZHenedf1qxvitY9JosjqMdBaH0C8NZJnzCpqveuwsi4diSLDCCIkB3e9eY+9A3GCNZooUYWgRr0GD9f34fl69BAUI7CuRavcPB5CVzgCOo36IEb/wf3s963yoLn/3dcez1/Keb+g0cfT+7cJ4J16/Zf/4Y9w9/BpefzlHNt8de/qtd/8Jqg/EKX+oHp9T3N7wkQ1ThvSMFLjREgDKUWmzYZx6lVfdNXna0LiWm0lIEF7UJljtVFzWxH4Qi1HWs2UWrGqOK1XOzfEhOhKlIGY+uptaJDCQJpCX+iRSExKGhISEohi1h12NIBYD0Qk4gS4FgkJuHddv9WCt9KxCDFU+/M0KSANtIuR3GQ1FxFEIlEa5ivLYA136+Bk7cnLvQeqt97e901GWAWDndIzKNl7oivH/h5UezJZF4JuaLv134rhdSa0TMEZIgR1cm1Yaz2Y50oaA0MK1NK1EUGEVCulNrCGoH29OQbEhWhv7Tccq2F0s5Pq6zbm+o+uSUDX8WE1WpFB5Z6If3ut9syc2/tztb8dA79SSnn0THxUCRseL9NtAngnXf/Jp57Hzn9L9v6u3cWrn7+/PH75wyyXP6bqfzSk+AKqQcJATBPDySkxjQwhMAyJNIykNBCHEZUAkgjjSIgDEiJu17JXW+f6hZYrZemzO2RqzdRaVpWe9lndWBNHQhBCcCQpqDAykIaERsFar25x0JVd6K+npJWmq9CW3r7aqh7kGqBzmjfcK0JbtwP7BmFPIv1xoqJhBBSTCutKsKh07X0pDL7QRKmufXwoR2rriUzK0neJATSCJrw4roJGZ6DiLdNKoR5nvDQ8BdqqAGyW8eUtF2KNShRwy9RcYbHe3aSAaoDaaMeGtYoUxaPi5sQoDFER7SCqNyO01rGGFAkieK1o6wYlK8va9RXN8dXwtO9Ey1uYQ+zy7FodM5cUZauiH3C3p6PaR6rJ3xH4nx5fLp8dY5lHPfoS7t0mgK/29Rf+mz/He597wOf+4V/W5fFn7l68+tkPeJ0/bnX5bqx9NGl6ytOkOm4Yh4lhGBimiZAmUoqklAghoXFAYwIJaJiI49BbyGZ4W/BWqDWTlwMtz5TcEX7BiWpoXStTVJL2G1FQdBzROOBuHTBTWRd84tpRRNwVJPZTPK7LKr3FbbWB1Q6iJUUruBVA0RAQwgpECsqEm0Btfc72iiPrPsIaWOsgbWs1N4farAOGMRFEkVwo+Uib91C66KjlgtfWX2eYOiJfKiINx2i5UI9dn0AzRDt9mIIwRKHVyuFQupWYOSkEXIUlN5alMs+NOCjbXUId5utEkYT50Mi1EJKyO42M0lv4aVCkQT02ajVqXmhGdzEyyKULogJdUWjVqc1QWeXFqykKQv9dBOlryeu9FYLoOOozJfMU1V4w86/fH8pfK0n/z3lZrlyOdvbUu28TwFfr+nP/0Y+yO/9VuUiHiNV7Uf0j2ecfq/n4vUOQ53UcN2F7KunkjDhMxBiYxoFh3BCHcZXwdpcdjROa4rq0EzpXXxYsr9LaMlNyocwFaw2Drv5zJSC9tU8jaQiEMOLeTTbiZsJlwKwHXI+/t+0HpBHR1OnENfatVty6XkCkjxFIWHn8diPQERWEhATt6r3W9+eFt5D7EGJ3HnqbHZc0x1ruBiAWUDpVpjjkA+3igvnxJa1kRLtIqZZGXQoqwi5ENELzQjksXOwLy1zx2mfzMCnTEEmDMtDb7tJBBAyICFRjXozDsfsNZm9oELR0bX90SNvepiRVduZkM6Q5y1xZls4o1NYXnqjOcmyU6gyTIK13G6r9o7Di1KUvJtn1GBL7FqM7eOhrzd5WF5R1PAgikDQAL7jbv2buD45z+6sp8Pe2yV4P+1da3b3rNgH8Xl73xiPPvfsOyzLL8fzV3cVXfvN+OX/5I+KHPzGofHfc7p4dh1F1e0La7himzWqZJYzDQBo2hDQiceqVP0REY9+Qs15hW76i5mOvbNW6Gq80xJSoiqQ+xyan22anER23hLjSgq4grT8eEno9R7+NAxORGybBvPbdfb92411Vb2GAkFbAsdNrErRni1WGJ+64t3UxqPSRQbyDmMR1Ymhcr+mJG+LdmUhj6Oq5NmPzFcv5Yy7eOOfqciYoTFPERfDaKHNDAVIGr9Rj5XCx8OajhfnYdf1hFDYaidrQ4lzmxjF3HMCa0bw7G1V3Bpw4CDp2SjU7zAdjWRqDQlu6tfkTJwnx7kuQHR5dFfKhsmTrgq2gfbRoTkrCZuzKQ61GzYYtRi49eVCdpUGKq5+6OaJdAFVt/dRVumHq2otpUFJSAb8H/t1D4Omg8ow7f+sy25eeOX1UQ5p4tGxuE8DvxfXhDz7H2ckmUueTqzfefD+Hix8KUr4vRPnmtNk+yTBpSANp0xVx4ziuaG9Y5+4JlxGkc/ui0qt6y9Sl4jVTy5FaF2qW1dCit7USuv1VDAIaiGkgDhskbdDQqzEeVkTc+vyvAVrDZY3FFUATlbUbMEQr1sqKRkdWO85e6SXgbcFqWRH1ro4zt47utz5/UzqSLqFTk27dULxTgRWx2vfozXCNuCpRA2qZcthzfPSQ48UVec7U2ijNqXOfr8tqRS6ANWcYFMuGHSrzoTEvRozSk+OxUWfDmzPPjcPcxU6lOUFgDIIEYTtGhriOCM3ZHyqPLiqHud4YgDwxBtqu4SKcjn3rMCBMUyAlZRqUMQYu5gpzZ0mGTSLutoSoHC+P7N840Fq3ZAMoOGkbiINC6U5Ec10t0OiS7Go9WYkIHryzF44EZQt8tJmf5uJ3K/o3Lw/5M0Moy6Szz19juMDXVAL4i//tX+DZ+3f5zZ//77UuFyeJ8w83u/iTxPajYdy9qJtNCMMGTV27P0xbNpsdcRgRHQhxJAwdGe/0tXWu3sM65y7UeaGVLtHNpd/sKpWQIKVAwNfFnwkdJ3TYomECCZ1O0w7SXTvmXv+3u90cv6W6WnwJ4LWv77ba389Ky3Vu3/vXvYL14McNs7p+f0NaRa2AF9T6zCumFHdaLghGiAFY1YeE1WlIO1ioiprjdSEvM6UaKSqDCBf7wvmxsVS/Ue+5wLHYjQ35vDTyYn37EcXEaPXGEKCLbwyO2VhKX1ceRBiScn5opCAEhVIMK8ZSnUM2jtV7wEfh6rJQgWNUmvctwTQF7mwDJ5tIHALTSWCaI/u5osDdAXaniWXrPIrO+Ghh3ldydUaB6WxkezJipWGXC36Zqa37DXQh1foJSe8SvHUkMTiYShB4v4j/Ka/25MVV+ZndFP5xs3plZB/PnrlNAP/Cg/+nf4rn3vU0+zd/O3o5PGkXX/ojlfzJIPL9YbN9NuzuatruCCkSY2AcJ9I49eocxrXVHzqHj2O1Iq3inmlVqbnSliMtZwzHvBDUGbW3rDpOXQWIIGkgTjs0jh0RR1fbLlkTwRop6zwPjqw0001geMNXk0y3ynV+6Dx6RWmryGdF3r3RLYdYtfTdracvFAmiEZUCdembedWo+YhY7S46TtcPpE2/yVsBCVgcUQribb0hOrdv2TjOjTk3mvXPIMU+doh5D1iHxWAaO7jYLbz6GBVWz0JXmEZlmgZoRms9qGpzHh8qx2yIPmzirAAAIABJREFUwCiwiYKpcBqVncNmCmy3gUGFx/vKxeOMN6OIMG4iZQpc7ith6NZqUWByZb7MPDpUjmcD201kF5Q6BPLSSINAhU2AcQyUoMhSWUQ41NbVhkEYQ8cuRLsCsVrfXvRVnYigKcoL5v7JUu3e1cH/WozyC9voj+L+FftawQW+JhLAX/rpn+LBk2c8+vJvpjc/+7/fXx699H1qh58IKf4raXv6VNjc1WGzY9xuiEMirG359Z4+0k03RXtL7K0ngNYWLB/JeUW5c+2zdmgolWEcScNIHCIybEAH3DtwF4fxZhsNbN0NWFt3bzd76j34/QakM6uYG4HOYVt5CxfoXDRr91C6OMfln5POdpFLVLnBAazWvjRUDuR5XgU7rW8N1npzOMcwjn10cWjL3L+mCYuCtUoMSpoS1ZzSnFydmJSTQbuibq2OQft4ks3ZbRJnp3CxLxyzkYKS1kNG3EGTstmE/pg7wXu7/3hfCBtlyUZyIa09iZhTVg+EYQwQhVacw9w45kauzkVzYjY4h1qd0wBnp4k0KlKc1x9lXrlq6Kg8uDtwdxRq6aPQLilL8L5JeTlTHCLGMCmbpiTeZkysHQfw6kScDJ3WvGYJFE2BB9b8h6r5k97kXRL177jbl+LXCDj4jk8Af/4nP8Hw6J/Iw8NT6dVP/2/P+fkXP5FS/Ym4Pf1D4263HXanEoYd0zQxbiZCTBA3q1Y+IEFuKiitdP/6pVGXTC1XlGWm5Yp4IXjoaLsKYdwxbk6J424t8glIfc89DX1Bxq8R+b4t19vztj7eD/CAroSjFbxWsAq6uuNaxZeMt4rEiMTY7cDdsRUVF2KfP7U/f/f56yCfqtHKQpsvacc9eT50Z6GQVkVdptZKa05b9w027kiIWM3UZcFcsBhQhc3JhmjGDIRwJARhSsp26hW+aQflVITSDxBgs4qjdgpT9c6GrEEUVIhJ2W56V9bW7iGXRglgAcbZIBvzSh8m7VV2mgJpCJRsPNpXzg+V4rB3eFwcL71fHxVON4rnRivGsRhvzMZrBeZsvLGfuRucjcKTJ5E7u8gwBhZx5mOmGLSVbhw3/Xi01vp2ZluTUhg6q0CDZW3ukndY1UBG9XtB5DsRf1CbPRHQnz2U9oV5/3J74v6ztwng/+v1X//kJ5gGlcPDL+32j37pOT2+8om04VPT7uybhjt3Q9psicNATCNpmIjj2BOATlyb4rtdI/sVK8cu2y2NmjM173FrRIwQVieeYUOctsTNKXHcrLRgoytnuhOvXNt8EW4O28QbXo9Yy4DiHtefa3idsTLjeVkNMqFYB+6sti4WYuygnyZUbF2DVWTVq8jqFmq1QpnBS18nng/k/QV1Xqi1rqYjhst6ClDtLauZMx8ybpDGdCMlstadf9Omy5ytViwFxl3iCXOGpAxj6I7GSTDtZxPG2tjUPi5kd0JUQuwYRzMnhQ6UigohKkNSyrrC7M3oC3xKGDo+cHms5KXvERCESCIYSDVabti1P2BzymocquvZiEcXTlTZTcpu0/l8QuP1pduNP2yCF1isUoF7w8CdKTKpcH7ssu3aIIv0049C32GwQyU7eOriozGumEbtHUpblZgiiIpvG/IttfmfnqttFpOfdfw3Hr72cn0nJ4H4Tg/+Mh92+ze//IGNXn5iOI2fDNPJNw4n98K4O+vKvTigcSDEgTBMfSFGwgqidUloXawH/LKn5D5HOh1cSykxpG7DLcMW3dwhbU4JaVq31Lr8Vgg3Cr3rVtxXTbqb4bZAPfZOQ0L/0/qKr817vB66TNe7DbZbRRRUJyQFuntv7olErtF/3rLLXk076/FAnfdgC9YqJS/kXNYRPxAaNxX4+jyBGCLufQa2dfwJocudr8UB3lZ772Z4UM7u7didbEgJxil2t+JmXB0LmBElQHCOuXPvGmT9HserUTNUFaKshqGxuwUng3ysMDdi69ZjeR05anMel270ebEYm9hFPHM2cnH2xTiUdcknQpTeLT2eG82dRuTupNxNynky9sWpdBPRfYUvZ+HywnheC18nwm4TCFGpDpfravGJChZAXTh35/HBkKRsoqyWZJAbxObE0IVdxL7CHIyQzd9v1f8UIiOif0XEf2PLm3Uatzx8B9KE8R0b/Amp89XJ/s3f/kAo5//6cJI+OexOXwzbO2HcnZKmHSGtPH4c0Zi6dz7Aak/t7UhdFsrSukS1HcEqgT6batwQhs3q1xcI0ylxPEPT0OkfW0/JvebcuXa6bW9p4lnbe8u9vWe1yGkFqzP1MNMOB5CChk43trL0yqjdLci94WUGr9eT8OrE01d9vRlC/38q84GyLODXrb33pR5T2srvy/oWVJRxUkLsv+Zpkv4Fq127ENO65GOdlnTHW2MMwnQyUJsTUgfElrly2BcOFwtWDXNnrk6thkRhTF2Pv58rx8sOHhaDQZyr2OfmiKPV2c9tbaWFY3Eul24frgoWhWODy8W4Wrg5sPRQnLmtZxyu6793R2GnysVinC/GVSmcjMrkzmXui1o3B5aurftFdl56s1AW484uskn9vcnSGGsHNkWdZF0zcMyg1dDUE9xscFkhmrONEBJMoY8trVO76vgLNP/x4oYQ/uqS22fww4LcJoD/N8F/ujx++dsGnz+5Od38sfH09EXdnOmwOWHc7ojTFgmbLmQJCQh461p9q5maC1aOlDzTasExVJ1hGIhh6JZeaQQCEgfi2OXBGoY10FdB6DUPj/Wq7hVvy1vBTq/0WN+Ss2bQZmw54PWALZmW3zqmq9VO8QUCglHLYbXKrv356Vy2ACZdp69eUZxWGrWWDi6uZ/RFWbfq1rdSG1iuBJy4EYa1k5AYO7awrEs+DazQacJ1T78sq5y3+Y0ph6hwnhvn5wtXlxkrhlk/hjwXZ4zKtFGmMXA0eHyeeXxZOJZVfNMHInLt45iZr4apHWTr9KEwRUF9Xc91Z0QordOCS3Py+p6MbvsV3Nmpcm9UQhBC7k5A57Px0Dp7MwUhOCRz1GEaehBfZvjNC+P0mNml3sZr7XZkR5xBnCnARYG9CcmdIYBGQaQ/19GFUpyhOdvUdwna+j0jqLi/gPmPVzN9dJH/yhj4Z7vhlfpOAwbjOzP496fL+W9/LEr+1Hi6+/7tnXtPD7tTlTQyTCekzbYr6DStXXk336hzpuYFK7m765Sl741rI8TAMG6YNjsIU18DloC7rMaem16Nre/xi3hv5W+mZV/3+xewZQ1W69/fKpYXvK58/tJVhLTc7bqr4xVy7aaWisOYKHOhtHbjlCtADD1QqrUuCvJVluyVVpz1aD7Ur006QagEF7wJno02Z1orzHshJWXYjLgm8lJY9jPL0rl9x9mk3jUsS8Vz19Qfc5cST7E78Fzs1/l81RPO2ThkY4yKYpSLxjmFeQXz5mzMtZ8wfH3S0KH2I8BCz119smlv2YfPpXNrvnoGInBcg9/M+/axSD9taf20GpC9J6mzSRiAq2IszQmwYg79TR+tJ4CowiY650tX/r157CcPNYdD66c0x7Ub8d4EoC5YgZ07g8ImdIbjYMK+wQycmpNS3zECmIKo4C8sZv+GOIcx6F92ty+809iBd0wC+Es//VOMj/+JHB++dLJcvPIxCf6pYXfvB7ZnZ09PJ3dkmCY0jWja9qWdVezez5Vr1LxQj0vn8UvB24J47j7345Y0bUjjjjBMIJ277zqdt0A9t06duS190SZsOs1mS5/Pr9v8VZDjrXSALx9p8zrjt0qZl3Ur0LsGfW7U0oNonjNBvK/9akAGiGNA6Ui8GCylsiy5U2YFlmOm1UKpTi597FRtHI6Vko1p6EmqNiFg1Fy4PCwcF5iGwGa70FxY5sK8NI65jw4pOFEqpVTwjoPk3FhqV/UN6rTaq/cQO/XYrCeya4zBmnPMlX12rBrVfQXJVjOO9fCRpHLtB0YM0g9KlX5aUG3O1dy4KL07GIJ0TMBhCF1LkERQheRy09Y3gWO7fq2Od0zXVmyrEEv7giGJvgsRVbg3QlI4FpgrrJAEo8KwirDffkRZdiE3OJqzC5DW1zeHhf41x7mrrKYjUMWRrrJ+obr/RG02q+jPgH3xnZQE3hEJ4M//5CfY7j8npGmkXX7L9mT4CR3GHxhPzp6edmcyrmi/xKlr9ulzuLVGq04rhTLP1JzxmqE1IoUwROLuFN2cEYZN1/xfS2xd+hKNxhXc8zWAj6vUNq7dQE8IXrubjiOoeJ/xyxU272nHA2U+0qrhtSvhRPtNWQ6Zwz6Ta6M1Zck9ckJubLaBzaYbXaoI6lCWxuGqURajLIWLi5nLy8x+bhznLuUdYze3OJbucDOuc2yMvbq15hxyb6/3SyPs5zXBGbkazYQUYM6V45JJ4mzHgUPpwZhCD9Sr3M8EbA776gzaA7f0lVkO1q3Kl9plvm5+47azCbK2/sIgvbVv63kDK8WOrtuT401A27VYklqNeyoEFbL3w0RZjT762YIdziirLiIXWGrHC5baX6esrzXFLuqprbfyUdbE4tc7P72y+/o91cHoXUFySO7M3g1GZ78Waveg78CgcElPUPfEGeDmMJQAms3fVxqfAiMF/ZmltS9evUMowq96AviLP/1TjA//sRzf/NyJ5UcfTLH9m2l39gNp3D6Vxo0M0wlh2PY9eY39128FK4WSS59ny0LNM2YFVSENkTRMhHGLTneI00k3p/Au/RU3WA/n6CCcdxTf53W9tR+YgR174K8zfz+aKnazy3rAlkvafGC5mtlfVqxBit3txt1RL+wvj8xzgTB2w9DYbbdiTGy2iWmzegg2sKVSlj7K7C8XHp/PPN43rg6Fy33vIoJCGbqUNqy25MOobNKa2tzRAFsNzLmLjKL2pFXqW55+S7Eb2e/p2E00q1W2CXaT4iYsBebiHEojqjCqduJbHMP7uq3duHdh9M29aQxsU98uPKzbfSn0yr2Uxrwi/dBNOhxhhi5SAnLzbv2dugAJ8+6taL/jfOSOJ7hg9MS1qnYptQdxW3GMsuIHdQUiB+3uwwBRYfM27ULJ3juCFfSNAkk66HdEWBAO68JW90BeE5bB49KdhU6kg4llHSVUCLX5+93407namF3++hT4TNx/9TGB+NWu/CfzS+LjdlzefPgtIdR/a9yefGIYt8/GYdQ47AjDDh2mGwrOm/cz8OZuJOGtYLagWrtWf9gRhy1xHNE0IXGzAnuOt7wi+9p9/iSsncQM9QD0bTxrFa8Fr8cV4a/riZXSjTDUsXqkLQt5v3B1UZj3bd1BCFQzSnGsGLkqYdz2cwIEfF2xHScYtOFLY262Bn9hf6hcXc5cXi4c5kY1JQRlt3E8df+BzdiRfXMnqHN3F9gM2tv7uZJbb21zWQ/6kK7MmwvM9frob2U7JO7uhDH13fkYA1MUpk3sPzcXGoXT2Pf68V6ZO3/ZRUFy7Q1I5/+9Xc/o0FabMQ3drLOsVuC7KEQRijlLcfIKuKr01j+vW3nNnGhOLt0ZOMoqxV2Dv7sQd7Wl+9vsvVYWJK6S42L9Z/qc37UIg9I7mnCz+dsTWBQW64Dg9T5AUBi0A4+Dw3HFHroh21so0WLCI3dmWQ9LddhFJ3X7xVDx94v6p5KqbqP8d25ffUzgq5oANoPK1au/vvPSK/+4PfnEdHLv2TjsNMREGCbCsEGEFd1vWG2UeabltSX3gioM44Y0TchwhsbtanwZ1q6Bm+rf+bG4imCOWD70QLeyJph+0IaVBa/zKiLqSzkaFQkDDafOM8vlzNXjzGHfE0QKgVI7ct8MXCInZwNpiNScKfNCnrsYKC8LD006xz1n1DoPfczrzQ6kISLWtfTqSqmht6VBKE36so+sN/hiXB0aV/vCoQjVZJUiCzEYbn11tq4fQQz8X9y9baxu23Ue9Iwx51xrve/eZ59j+/rGX7Ed126+09RgUBJoiZPGwXGi0DSlailCwD8Q4ge0/KlACAERAYIgINH+QEICoqpSJZBASKhFalB+NGlCUpI0JthubN97fc895+y933etNeccY/BjjLXefRIgCUkcpz/se+8+++yP911zzDGe8XxgLO55WLt78It5zHczBhkwa0Inw5AJBkWPeDBiB8YSESjaa0KAeYvr+1vIdDMTDttNDsbx6Os7S4zbc8ftWZACkBQFRCX8C7wTmLvjPFMCHhVCBfk6UAyCS7EhXA5ySoSSw37BLgCrwgk+ZzGcFVjVMG1Yxb4r9NFB8aCwxeoxkxeBbLu4Gt0ILf77AKcMm3mB6ABICFca+cnuIPtBmP3p2nUeMv8E/z5jAr8vBeDH//KP4Z2PMn7lb/xlZpL3Xd+MP1SuH/3g8dGT9w5Xj5nLVVhfR0ZeX33GX5zbrr2DrHp7NXihKKPv9LkcQVwuMI5pUHN7OOk4a09bkHP64q62pi4DPp8ga4t1XwsPDwNlA1FyPkFV9PMZ67miVd3tqokM0npYWft8OGTHKc53Zzx/6w7L0tGVsDbFuQJrM7A2HA8J4+hvxzgWjJkgIHT1h89EwDH4dnFGmrvjKp7fd7RuHo7RFWsndOPYlwNdCYkYQzYU9ra/ZAaT4dQEa69uwilA7Sm89QldyH0RE/YC6Y5GwTUwC7UcAmBjDIMhg1AKYczhBGyOuA+F8PiQ8eSY0Mjb6YkZvIZSUQzWCUMwH+duaFCMofEfmHDuboEmyY1CacMD4pCnaNnBTlemaNODu+9/nghN4BsGiwIvW2ahN3v7IQ8Rlxpd8AJyUHMIwkUlt2AjM3ckjt/3rD4u3G1aB/8jFrWPVME/s4jKo5H/qkE/t96+rr8fKsLflwLwwfe/B6enX8iHq+tXTG+/Z7y6/r7D9dveN1w95jxdgXjEJqNVWSHLGbL4bKxSXZ6bCPlwjTRdg3dCULjpqsbMbnHrt329BwpDzNjp+9OssFYh8wu00xltFh8FQq1HDOSRIE2xzh1S3dAyp4Rx8BYVZkjW3chSvTmca8OzKmjNcHe/4sVdQxfAmEPo42k342HEoysPFBHxABCws+BY3OO+bqQbczZfNkOHxoze3eeePfgiZ0Yh4Fj8NhSjsOwGmDOmwZWLtSmWpWPtrk1gY4gyekR4MXs2X2KFgpHy4NoG6dAAzThSirvGfr4kHAfGo4nBibCshmX1eHJiX6vdN6CrYhFXSebihT4n9wqQrg62seHqmHBTGL0wTtUNPm7McEy+9xc1lFBelkS4Htxyfe6GGYIMRjFDi7adadtOAEu3WId6Adva+SE+3gNfEIrrJOjI7FYQPhYQ4To7d6GBUMkdlxM7Y/B+dT7B2ehC0gKSAn+YFH8GpC9y4r9G1N/CyxDHP5gF4Ef/jU/hzV/+X0nb/Pj6+vh9eTj8c1ePb752unrMaTyCeIjkW4FpQ19n9PXkqz1TcFLkPKCMR+TjjRN6OIcZR6wHrcN0DZfcaOXFiTuci797250hHdoX6HrvCjlxS2oV16jX6vZcGzmnNfGQ0CEBqliXimV1tLwubb/J5qXh6Z1bUI0DheAnYRgcCExkME0AJ0wDoyT/fkt1Vl4KtxrpivMqqNUzBjR26wSX5HYlqBKmgXA1eBJxN//6Y/ZAji7qmgA15OxpPBqW5gM7EQpwA9PEDjB6uo4hJ4CRfE9vLsBhypiK7NLkVfwgGnmLzeymJEK+cT1wcpadAtoV9815BLX572pMyFPyVWH336tVQUqGt19l3ExOMqomOBCBBzcGOVXBWjW2CYShOIYharDZDUOnKeGYfMe/rQyjHccxCiuCM9A33KArajc3EVVzqbA6rsIxTwgRWswFY/FirRbBqkxIQ8IVEaZVcDgL3pyB5+JjlsewokDxdaeK7x+S/QqR/eT8xufrl3sz8GUtAP/Jf/Ef4urF36F2+sKjYcC3DU8e/bnxcPjm6fqYOE+uV98ks9I9E29eoHUB0MA5+8E/PEIeroKyCxCFpZcBJgu0naD1PvT9vsIjU/A4hSyYXTAjzT9nOUHbBhACuRCUDa12zOcV57mBVMLIIyPlhLQAJB1VuvPhV0VfG+ZV0LvhbjbMK3A8uHvN8eAhI2pxWNSQS3IvPgLmKjid/X9MnnarrWNphrUq1JyZ0vtWIAglMXIylGy+7w/HnL4FgYDDFzA4D+rousa6SzXMP4Yx8AIfK3KoAEtmlBIeALN79ysIw1CQyRWHMIGMbktG4aU3jAmcCFUUZQQOQ9pDTHpT1GrQ+4ZD9nFCkguNSmJIc3+/Y0+Yq8KGhJ69aztcEcbQRqgZcktoq9uNDcWrpphCtlVrYoyTZxpOakjdQvjjP2sBMGZfXUrIl00NkgjTYG6Uot7WH7rh7DII3zA4uo+yubMlAgRgAYQZLfnrlwfGo0wg7qAz8KJfVqFiOJjiowb7gZLodYb+vS+3eOjLVgB+7D//UXzgXTd40Z6My5u/9k35+Mo/PV0/+tYyHPLmxmti7msnDdoWtHmBtBWJAB6ukKcrDFc3ju6Hey6FxY4bbCyQ5RYyP0M736OenBiUsmC4vt6tu5zEs0KWE9r5hHZ/8hdjSkjjAM6GelpRl4bzacHtLCisOI4ZqXg77YIeB6NYBRBnwM2rv8GZDTdXhOsj4/rAGEpGb90xguDSMxNMnbl2mgUvTsCy+O0/FoWZp+R67FVC78AwOLHl0eS3vqjtLjm624h5wEYKmXKCIZEXGhFFFd/V55SQk48DPRh2Qxz8ITNydpqtdEVOjLEwRP1zhiFhyISpyL5bBzNScQ/Cpbktd4mRRGPvxmpYF8Hx3FDMRURdnaevBFgzUHdG4bNzhxHQiUAD4SqkDBsAWKYEOyiwuvd/h9+whRmPs29FkIEeNzQX5x0sTdECODD2WZ84eBg9UH2N71v8kBzZwOzvd1fvGMzIDVCCrETZb34KP8HWFciMdMg4GvBE/Jk5KW1AI6nh1a74JMHuS6L/prD+ypdzPfhlKQD/8Y//B/jaD381nn32Z8f16S99w+E4/ulxOvzxMhyfcCpuoGkK6Q1SK6QvkDpDewNnRjncoBxukMYrpLJx9XvAv+QU3HoHWW7R7p9ivb9DPXlCTypAHg/u4DMcEA6QsLZA6xlSXROfCiMNIzgz2lxRl47z3DGv4lz1acTNowJOCa1eLK5N/badK0Eo43BFGBKQrELMWW9kilYrejjOEjPa6mg5yAHB0wwsjVDGgsdHwrH4n3UBkjUHrbpnEw4JOI7snACJG6l19ObipUMqvjkxAOxmHLtJBwkGcrbdRshRM2RzmuyQGeOU/dDKxQqslOxjELtRxzAw8kCYBp+9mXzVV4aC2gWYG65hPtMbMJt3NYkIuTQMVxmF2TuS7vLlJgpdwwnp1DCSRW4p+RxuBmm+m+PkmwLiBIXbeRMMB044FN9inOaOWdQdntQDVhL519oCW1PylaaYE6icI+ZfrwUCSw+YhxIjAIWKUkLfkaLtTylsyOGbBdlozJkxTIwrEWg1UCQrNVAWw9dA8cOJrR0L/9eq+tn19g0db179B6MAfPhr3od6/3opdPfV1zdXPzwej//UcLh+LydnYDhA1yDN0X5pZxAJyuGAPF2jBBnIQzr8c2EdFHFYMr9AP7+FPp+wnO4x31WYMHIBxqsR06NHTgGGAVqdD2ArgO700qkgFQYlhnZBPXsB0HD8PRJhGpwwtCw19vTnPZnWsWbC9dWAcUjI7Aq9de0QBebqBz+Rz+9NgPuVfCUHi8Re4NEBeNsN4+2PisdciTPgtPmefoqfZ0+yAcCkyJtuiQg5AUNiN7qIgmDMO+JNKWMohqyy+xZqrMq85U+YJs8ZaAEOEhK6KShlHAbgMDAoJ3S+4BFICcgJPRxzyiFUe+RtNTd1H0QAXBISEozd4w/JCwF3gQZdOHXBQbI7HxkwL4K1OdVY4K/ntn7coP5EhHFIGJJ3NMUSWgXW6sCpBFKPzS6cCZQZwoB0RYu9PiOCUI0h0eUJbWFMfrBjq7mvCdnMnZ+NoeSCrpT8NWwtvB6HhFEBVV99cnCOBVTM8CFR/ODc9LWq/NeI25cFFPw9LwA/8hc+ic/+1F/lceJXHj8ePnV8/OQH8nj1PkojAwSLOGxZF7R1hbYGImA4XKEcniCNV0HaYZg2WF93QY61BbKc0OdbyHqGdoEsAmmEMjKOj0dMj4/IxyOQUjD6xNl9oapzpx32N7sa+trQFoHCD8OQCa0L7k6KZ7ch/mkNIGCYIpqbvQAMgx+c2hQSDLeuzjNPKYHgM/x5DU4/+2ppTMChAI+OhEdXBcdDQm+GtfkGQdVFMh5oQw/Wo/rAlsyQS8YY0ls1DaqzH3ARF/MMQ8I0JCTyNOO4RpE4OPqjO/GYESgbMpnfiCRIg2DKHPx8v2Wlu4KR4vtshicpWv7qkimAbedSafK/S7TFdHmXACJwTnvheniYz0tHbU45VgaSAckI2qMriKS01hRrDT1CWJGbOpegwf+extfgtHn8bfiHo/Qwp1UjTJVBQAr4v2eDRldgRKiBbVB8jpHt485GbuJwGULyjcc0xLAWwKz4OFBE8bWnRt87mP18YfztfHqt9at3/cEtAD/yY/8uXqm/SNZvr1Oq30Y0/DCX6Ws5D2xRCaU1SJ3RlxnauwN9h2sMx0dI43UcfIHp4vTb5u46spzR5hO0zQC622sbw9SdaabjgPHREfl4BUrDvueHVPcDrAIV2smcpi631dCRb9z51tymWtRjuKbC4KmAtKCMCVN28LE296troqhNgN7RxVCF0Jqr9iz5ba/moNU4JpSkYAKuRmAanPU3r4LzLJhXhaiz59SvLxBvZJOLvFZEIOY+921T2u07cEPODB4LCgxjSRgObl8utXtCbs7IKcgqyW9F7X7LEbvDzlgYqXgX1EJYoyJ7MrFEupDXE/p/fB62zoX5Qh8GyFWNXbyQhnhoa9FhPkvXQOa7etaimROH+qLoNXb48TEJsBUxz7uM16nSbpLiZiJID5SJDqKAyXEVJkLKYRcWP6xlYFDXJxA7UUl6OIQMQjlmAAAgAElEQVRSmL52ja4r7aSkCCCASKyUSxiIBGuSyMcsBR1E7KON6HsfDXhNRD53++YX5eaVd//BKwD//n/07+Cbvv7DWJ5Sabf/5/tz6p/Mefp64pykaxw4X/NpXQFTT+s5HjEcr4IBmKC9Ommn3UHmW8gyoy8r6vkMaYo0sAdsUkLt/kAPQ8J4LEije1Rp81kdskClQqrbU1NE8Vhv0L6iLoJ1aa6IWxvuzyvOq3cDw+gHpSQGjCBx09VuWJaGZW5oxvvha3Vrsf1WYlJYceFPzoRc4jZOQCLFNLgg6TQ3zIvg7uw6+RxsPaigJLcz7+qe/e737wVro55KWHwNmX0cyN6Z5Oy3aSkJlJOn6iTfc+ecnd+vWwqwz7DDmOAGSxYy17R3G2YemEHbAY4CkIL8s40XFFHdvn6kB8WB9qjv3gWr+coT8Tu0pmhNnNbcfI2ZmfbgFOm2W3P5etYlyBqeAs569CJ2IN8ybJvfHGMKRXS5+SrJOxXoTuqi5MCihtMxzH+GHKAfDLuVOwCoRaSbKjggKmMHUlW9CyCiSEi2S8JjjErZjLrR+1T1h+5XekrATzDrlx4Pq76o4x+sAvBHvuUbcPfG5/Lpi7/8zpub/N3j4frbifNjp/NWSO9++Pvqh2I6+Kw/uWSXQFCpvtZbX0DOb6Hd3zo6P8dufggXIGWsa8M6eydQDgVckgM6zW3BpPUYH+I2h5tZ9mXB+cUt5nnFafaoKlG/ac+1oRthDNMJswSF7n1i7cB8rjifGgyMMnjXsHEB1DJycr/BnJ174Idi6zAMGof6bla0bliqE4u6AMPoYSYwT7wZkmMGa3O2n8HHh5Ld6KJkp9wmBq6PGWNmNHgC0FASpsGDSDwfU5APKW5GF0q554lfidMhYzokUHLm3XZLE1EYopr/bIMXAA343D0UsXPznZ9vsYq8HH5sgSh4wLk1NydhdVPOGkCcRNZgzhQdoSGpFzkuhM7OxhzCwtsX8nGw4D9DD19Ejk6JQw1o4rcvw7uTeDW8XVcgdy8Q3RSy+o5fwri0baYs7F3Cjkd0BYVxg5YMgb9e9KB4BvHyJRozMZDVUjN8ZGn4U2Omz11P+X9ONp+BP0AF4N/+kX8Tzz7zM4T16eNDPn0P882fJ04fARGbCnqd0dczTKsr5KYrDMcb5OnavfZh0BZqu/kF+ukZ2ukO9TSjzg1qHAagCSLAulTMpxXSFcfryW/9bpCl7zbgEiEfRuzVG8B6rrh7eos333iG5/cdSw9//+RZf47iu9Bmi+sGnMAyL4reBLX6liAPA8rgbTEgMCqAMlLqYL7ciiq6M+i6+KpPxNCq7uSkLbyWyc1KfNPgeELrirWGM04AWUNJSIlRSsaQvSBcHTOIPFLbCEgjAQXonWBs4LiZQJvAx70DUWIdODLS6JwBsgSWLbLMn9QcX8O2234onrcQu3N3Y6ZtHvEUY9HoDKLzUjcN6d3dlbO7fkKr7J4CxJHOow7cMRNI3aVXt1u4+6pxYEYXw9xld0tK4BiTbIM79oIjai78iZVsLJWjKPrKMsVB3RiPS/X3b8rkhyfEVmEPGf+0vbQZ+fjXRZHEOQsm0bkEq5CiAwD5KMKGAYpvEsUPnFb51c+9fvo/Sul9fPTKV34B+Lf+vb+Ej330mzG/8QujaPumMl3/2VTGbzFFNl3R1xPq6R6mHcNxQDk8Qh4fOdg3OAVY6z3k/BT99NQP/t0ZdWloVUFIKIcBqWRoE6xLRV076toAM9SlOlDG7IYbYWa5zZymThQ5zzPuns14+vSE5y8q1u6R0yWYepkZpO5xX2KeW9S97k5nxemkUDUcJiebEDl7ECD34GNGNjffBDbfvcstmHPyAhAfHyd2Km846Ig4ap6yoYnHVjcxkBGmMR744k64Q2YoCHnIGIeEkhgpUnRGNqQMlOKOt8xuXY5wtN2yShCR3SltyUWIgJTQtZcMKwVqDCL2W50cx1FVpDDG7CIBrobHgmo88Ng7g81JyV2LFW1pkNZBTVDnjrtTh8L9CKFO1Xa8xn9YNidqbaSqHqNWIqAHMYc1VqQx1uTioKLbO9r++5OG3PilAuPfp+MiKU7R+vcQGKWNAm0XEpEGq1BDsejkK4GRd1caLiIaGWQlhWApCpNcFhpgtsdd8Y+1pn+XCn0BWp/elNVu2/iVXQD+0Y99FP3+84X09L5hGr6fGd8Is9zXGb2uaPMZ2jvKOGE4PkG5uganKeioBGszdH6Gfv8G1hdvYb5dsC5hBpES0jCASqxnmqCuHdJcstsVyGHI4V5+ARZ138O3tWE+rTjdN9zfzTidV8yN0DUBqYDIkJLhOPrO59wVVQ33BogSzgtwnoFlBQwDhgKU4aF/jO/4ERp8IO2u4YibaJsJU2JQ1x19ngpjYAmaKO1dsZqHWbbqXe2hUGTZ+y1/nApEDGv3zUfJUfjAgFVkUnDyBGCy2J/HD6VBdc3MzoMI3KBk20lDCkJi/7pKCYoIWfFSDZa2ux9RrOcuWQzYQ0k8yTi5RdvmdCwKWxva3LAsDb35uq6FHTllwtI0Og6gVvcyNHHFZBdDM8MqAhNg7UAT2Wl2GgYhTEAhD3U1ctSdgwnYCOiguIlpH0ncCOWiA9jiQDwciUKH4DkBshkobs0FE1KsSC0Sh01tt2eXOPQ5R0SE20Egtq5IIcWA2fvE8F2i9LM5808Wmpff7VHgd70APPvMT1PG6XHm0yco538Sal/lB39FX1cQGcbrI4arJyjHx0hx68PU13rzM/T711Hvn+P8YsbproKIMR0HlMGTfEGAwNV5Gxq9rBXI2VvhqTgVdVkxn1bM54bz3YLz4rTeugqq64JQBgfaWgdaT4FAE3o3LKvPardqqI3QhQHLGCfDYXK2H6cMmPvZKwjd3BGEOIFJvADE1de6i5ByDqNOggt34nZKPCARYUh08aTrglE9RixxQklB8CHGeCignKFQlIju8iwC/55OSfGVnqBB4TFciRlMDEtuUMrMyGP24mCChMsmhIjd+jYReDNINbw0y3tT03cuwgXcihQi7QBzODhdUoqldkjtaN1NQng7mIN3E9vX8niFMAURAylQ1wD9yD9m5vt67d6ZIGzCHBz1Q08tEoojOVn6A/8CDhrwZWoBmx+QusEKkRre1fkZ3ScWZ3XGmtbBUb/dKXIMsFGMQya+FYsUsXMabqeMbROx//nUFX+0dfvB+7m/PtfTLw1F+nD9jq+8AvAX/tK/ho9947sgz3+xgPENnPhPmugf7r1xX1b0dQExYTxeYbh6hHy4AQ8HX3H15m3//Az9/kvo98/RzhXSfX8+jAXDWIL84uh9hPAiJW9/FewGDxmAVNw9r7h7MePF8zNa7agh062SYHBgbxoTEhtaN9yfCasx1mbQk6E1QDRBjFBXfwAOB8ZxIlwdFCnDCwIxxpTB5M61p9n56CnIIO6eE3N9Zog4/kvQfSVWMkAlwzh5l8P+EFuw54rmKPw+R7N5UCnIf76U0t6+Av6zgAhqGQwDsWwLMKcZDwWlpDDrMKTC4JShKmiLE5DopUOeoOS2ZRRdCczApIEK2N6tUMzL2NVzfui0dQcLQ2HZu6LVDgsuAyfCkBgsLqVtVTyUsxtsVTdEDdcfju+v6q14SeyU4azoyQHYbO43aF3RqvMIUnIwjpkgyU1KWVw+3OCMPTw4+FsWoLG/npkikXkzLDEHZXVDR+Jm9wPvo4SqFwy3KHsQDR9rUeKAQs27CyW7FCACZbZXRfE9retnCPSa8vL0ulS7b8NXVgH4+D/xHagvPpfrML6HrX6KOH+9dc1tXiF1BmdgvHqE4eqJW3xFy6+9QpZ76Pwm2u1T9NMdTPzNcsssd+4BzOO8jMEpIcHz/Hp3h5+SHPW/u1/w1rMz7s4dp7kD0n2HPWSfryqBSHF1ZBxyRhfF0iVuZzfW7N1voJzNX6BiSJnw6Cbh6sAYksKYPdMuGGhzc0zAoBBNSGC412j3W1lTgHspZm7fz5d48C2YbZmAHAcawSzbcAMLlSQzu5CIaLMzfIkyxhusrIrEAgJDJIFYMY0erMkhwX1IawUYRh4b7oCGRKfiiLmadxCkPsNT2mk8ENF9NSrmN7J2RW+uoKGY10X8deq1Q5qEaIdQxHfpQj7TN4sD1d1ZyRRBHXYCFCVCUTccSYMXWFHCQoQV4p6PUYxK0JFFvbAOsVptpjuJh81BX5i35dp3go7f7HJxIXJ24PZntPsNbFXTgsFpD3AE2bYEbke5A4e9B5UbGxhIsSUIMJbAnfDVXe27ROlnS04/eUzz8hVVAP6Vf/1fxrPP/hxZu3sbSf/kkPWTou2r+rJClns//NePMV6/HWm48gfOFNYbZL2Hzk/R756i3d15as3WjnaBNG/roP6Q9S4eqSUNrcuOsLYmWDb13OotbMoJ01RQsqPZ4qoPcHLyTxPF3Unw7N5v+xCzIWXbkfiU2TUJiXE8MA5TRuJLjDRD0TT8+GMH7+Ad+yETpzpLnLa0afbJCSVjYeSSoSlhTIRxyChD8fMr/dKGB6AGS+Ac67s4PBazpReM2HGzIWfvVFQcMxjHjPGYkKI/3Q6pBdnIduWgexUYKAxLLTIJXYm4xY9tAJmnEctefaS607CK7K8Jqa/1etedxMTJC5l22YtDDy4Ax23r+AEHxuDFpZETdPa8lg1j2ADAeE0K+1q0lc0chDDE1mS7tVXjdTS3J9vIRyIGCT6BhQNRl/AlNMdttg1Ajhm+bRvi0GFobEMyR5SZeccnYVTkheHBxiD+j+jiqEwgkMUoIPgURD97+2L+v66ujnLq5SujAHzye78b91/8+VLn2/fB5Pul96/VXllrBRfGeH2D8foJ8nTtXvthzqHt5If/9BT17hZt7chTQRpKuLDAbajUkHLBmDKwNsy3Z9y+uMO5+gtbW3c1ICVUicx7wi59XbqhNg4PV3/zz6tCquLZnWGpjKujU2FTJhwPFKSOhJQASYCBdwEKkz8IGrFWEjp9Nw9x+e84Bl8/FaADiRUJBKaMkhOm7CQdIoblAZwZxzGhDIObkagPk0Tbjr7HDn5jl12oxBbQofUwxyRGGQ15yHviMCc3S02ZfQ6O7qlvQGTyw7IdPPH5AJkJZH2XSrtnorfxut3orcfv7ov43jvWpYZtuGLtfrC3mX5bgQ1hXLI591iAaUyeG1h7hIiooVPEhwVib0HOaaroC5CLdwcJjtaDCQOcQdm7RVvPkWyMfYMgIZHeOoTtczXEQSKX2DKNw3lB6h2vKexmI9JCa8AuJtpWymAgSawV/T/R4/mh3WEYuxyZmfZuIBoLKoxXV7HvXKv8TGJ67Z35fG844vw7LAK/4wLwL/5L/wKeffbniPr948T52xntQ7LOubczUikYr5/EzX8EcY61k8Fkha636Odn6Kc79NbBJSMN2UGr5nMfwMhTQR4GWO9+22j3Vv9O0NUP0fEqIWc3YrcopUwAgbE2YF39EHB2au7dnWBZCAbG9RXhyY2LelJxpVsLF1p2CBm9G2o1T9JJjkVYkDrU/PNS9jXTODAOo7eHYoTeE8aQoqZEGJJ3JhtrDil7NPfgCH5bG5ZFQOruNkYpMAONz+E4KHHdcPJYLwApucR2OmTE9jKUjq5FkK6oa8d6bgFeRYvLAVLZtqZKIRdG7O/Ju4btAD6IStMtCl39xq/VTVUcTdfdansgTwnq4inHooyVXKzTuzpWEPvCzEDbbmBVKF9i0nNIfxEU2l5981MK77cyE4FB4QUZjr9Q1O4sQlULirb5+2KGAj+dskl+u7/LG3i3HdJthqfgFlgEt7J617ARCimEUBqW4Qy3R9t0C0RxACOAZNuY6IMisGGphcFN7QOnhu/qpD+Xbtdfesdjqr/vBeBP/cnvw/3nf3rs6/NvgOGHpLcP9b4g5Yzp+gnG63cgjceI1/IBydoMmd9Cu/sS2t0LSG2eLjv6rF/nhr56+5uGwXPfSVBbw3JacH+/Yu0EcHbTheIjg6rfiENxT7rEBjWGwoJQso0LwLI6E/DmmvHomjFOZefoA4Qac+3GX08JWBanqB6PCcPIOyDGIXRxM0rGcSq4GvwdrmHkcRg4EP8Uv9PgrfjGICECZ3YBS3frcg8TNRjlcCGKccHceNQjxBHgll9LeQByiXWVOgDnvTLQW0ebK5Zzwzo7vTcVLxBE7HN899DSlJJrCDgcltAu8tag2wJuo92qx4WZKkQkLNGc6EMIFSTM3XK6oa+C3jtq5v1n3CS3PVpw5eApxJpuA80SXERv26aDsct7e7fw/TOQeDHrtTuteLeItD3XYDMwcQZezPRMWHczUXuQCxWHdPMX3G9yV2vqAy7A1iUEuXHvChDbiB5MwA2vycBOyOCwJtPgGjxcqGTCzaz4Y1L103xqb7UmX7h6fNS55y9/Afhz//yfxZ/4E9+J82s/nUjO70mknzKdv071nHNOGK4eY7h6e7T9tAXjuZ12HP569xx9aS7OGAhEgt4ItfoLmTMArWizW0TdvVjx1tM73N0tME44XOXL6okIuRRcTwlT2fb/Hc3Iba86IltPUKsj9IeJ/CAnZ5DlEI1sq2TeeN9w84dc3K9vmjIOh9E1Ab2ji6BLRxkyxrHg5tEBQ2EP7VDf9w5h5Z1Kcgpz9n26ikJFdppora4FqLVBRZHC9SeXjDxwyFTjoUgJqahTi42RhoJyIC9I1VODRJyE1EzRF08Y8kLJgAgk2Z7fpxFsQpEx4L6JbjzaY8xx85GQESs8wKQ6TRqgnexC0J0lKE1hcZuqmPM6KADTGEFSmG9aqPW6KHpzvEDMkJT2NVkXp+Hq/jrwXhjQvDNr6mKdVgVzt53NV/jBhsOT1/wQ63YLx8d3HkaMAw/YHlsn0ANX4g3wi/VgpgsOsHcLepEOb9z/rc5s4yrTZkx6eS22o2M+PnAhvH8RfGJZ9afGwm/elPMy95svfwH4Z//8nwER8ekLf3+SdvqorPN3tnb3as6M8eptGK7ehjxe+VJUurdisgav/yn6+QX60mCWkAZHwbUHUBcoc1162GkvuD91PL0T3N1XgIBxZF+f7btXn6GvjwUgz7qrQpgrwufdsK7mK71ghg0j76QaR7vNE3zCK/QwJIxDQheBKnDMMb9PI6ZxdBwgd1CroE44HA+4Pow4Xo0hj/UknZLJBUvJi83GZdDeY0+cwOZZB3cvFtyfVogAQxlQSoq239t0CzcfTrSPALZFFkRRkd5QT4I6+8/trsjihiHwWz8Xb7mNzJOFxSm5m01OrYJOhkQeALLMstuGEQySDdqButgOXpkxSLOfhKDOtNrRV8B6BsigaAA5F4JDw4CQxIr4SKIErFXRV7cKyuFunOKWruHbv0t4A7wl1T1qfG6hHgxJcN5YjhZjiLoxqYqHsFIc3tAu+fry4WrF8NKs3h+sPTdPhS2MZOMFBHsaOSTR3kFcHIIbLkWCA1fQ8CzcCo+PMZsBK1AYqRk+0A3f1sX+7lu3y+vjdKWrpC/7CEDt9GbRen639fXbtK/vY6I0HB9jfBQzfyqAWdh1rdB2B5mfQes9TASGHNl8Tlbp1V1toAJti+/xbxecTgvOq2HtCIWc7/JzIpTsLZ3L2ATL6nPjaTWcZ8KyuJ/9xgEnIkwHp8YOA2GcHDzaw4CNgg7rKrphyBg0x4yfwZzAKcPSsM/YBYbDccLV9QFlGEExkuRkSCX7zR9uOtsVo+pSUpVN7quYTw3nc93R+JzcRHQYMzq59JbAbu/FkWAcNwXMYF1QW8dyWrHODSbRRqsGJ8fXiymHICa887UGqAYDZbcA62F5ZqLoqn4Lm0WAccSRy4MAUPHZGmqw5rN8F+dQmKbY/MQmJPm4k8M8tIsEzfkSMOLgpGFi8nEAviMHESzEWDlttuC+w0/mN+faL4DhEuu0HASeRTypSIP0w8Hcw8OD+6DV3zCe7fb2rMNLJ0Ah53244Ddc5neNDYFobAlo8w6IDiDmBcMll2DrFmBBx36QvpTIMCjevQq+a171b45F33r349P6+vnmy1wAzOz8pV8ocnrjH0GdP55YXymHRy8BfpGq4Wu7egtZbqHrvctvlSOZF5uW0pHpdYWK4v7ujDef3uH5nfh6BhSzPu9oeEmETBxVH2hnAWaDdsFcCaez3445R54eew2fDim48YScYwRPIZtNyZHZxI6ac0LJjoarhU0UXbTtSCOIBlxdjzhcFRgVUI6fNScQ53Ch9UfB0Wu/eWTbLEjDeq44nzvUCNNYgrdPKKPv7JkSkhlInMu/qe1AntCrTbDeVZfFLp7+kXLa6cm5eFeTso8ybp6c0FeDWoORaw84MdraIc2LxsZSG0oOerD/9/5AJnb1Y4uWPbYCm/Fpq7p/nplCtbsrhwS/f/UwEYnbtIpiDUwgJY7sPdvba30JgPTDuTTvdMZEu5cAdnAt/j1i2X2U2cDO7Wa1l4JM/dP9FhbdsgJfBgFd6OMfy1sx0NgO0Ms3urgkYFcers6wcDpwgLa7L4Ft6+X4/bYx5EKsBJPlRPiaJvbH16affvZieX0Yr7Rq+r0vAB//3o/jU5/6Xpy++LeT1NO7W737eIZ+cDhcp+H6HcjjdQR4OgKifY62/xn6+R7WZz8ACjCrM/Hmij43rOcFy7xgXTpe3DXcntxZZ5r8MKnRS5W2CXCe3Y/PAnHeKKRqAd4VYBydP2/m+/lhxM7RpyDelFJwmEbkUhxBzgllLGBOyGGjXWsFawM4YRwThsHBuTRmjMdx1+5TSuCSAR5gSh6qQT2W1wZv/uL+UBfDnE/Vab9DxuE4wsjdecvgDjoJQFIH6UQFKWUnFZnP1bX6PE1MwZqMUJDu3NJh8rHHRVL+lCn5DW/ESGQXckoc2E27r+ZrPwQRR3cQIhQB3U1S1XdpO5LdY4VHyddim2lKShrrSUJfDWvt/sBHsCcnICd29lxoA9p2DW/uvUGtdqwn1p/iWQ5bNqCqW3t3Jqzi7MzChBZS7h5gYmbatxuq243v36ddMkOCo0+QLYosDuyGD2yFiuApwxcE4HKwNx/B1WwHMRHFSDeOwVa81MJZyouN0K5hQiK8ZxH7xHnRnypJnr335rS8Pt/83heAv/gX/1UQEb/4zN88aL37GEQ+lsbDTbl6gny4BiVXwvkc32DtHro8Rz/fQesCMx/e2Cpqrbg/rbh9NuN0N3s8FjxjbRUGlQGHUXE1Jhgn1O5VuTVDa4x5TVjXB7JR+B7fDTf8MObsOvIuQGsJRBmqHQxDLoxxSJiGAYfDwW/8YfB1Yna0PiUH6trakM3AlEC54Hg9Ybwa/KCV4malYQ1GxKDkHv0eNoqdYIKIJAcUkI56P2O+95n/eBwwTgM4pcApbE+fZPXORpqFKYYGhdR2skyZGDksuBHkG2JP0eHAOyieWvcsaDGT+9/nRPsemmPVqIGakyqGcCXaxDyqsVKcBbL66o939NvQ2vZeE2rvmJeOpSmG5CxIMjeFQYh2evMCnkanU9cwJfW22EkxkAerOAJ42yCoYY69/Q6+cdCx7bJB2FB2JuBQ2L0U4NsHy7HZEAs/Ru94trObNsxBt8AQ8r8X4SKbKzHB0ANJfMioxoUhvTW9qN1TiC5KSewjHR6MHhs4iR3zsMygjzSxTyxV/95rT8+/Vq6vtSv/no8A1M9Pi/b1PdLOH89pev9w9Q4u0xMwlyiJAlNv+60+h6x30O6H30Q8v/6tW7z++Wf43BdO+LU3K1QMH3wl421vO4APk5twiNszlDFFpVVA/OZoncI4w1HvFFz7YSCUwhjjgQ8/DdiiIVdhELmg59HViONxQhlHFxrljFQK8pCQx4JUMogUbel+U4xeECgER2UsXnjyEHTlC3d+izD3gdHfOQrp14aO97ViOa8e+X08YBwZSEPcBA1iut9IJAr1IPpYz20TJpBKBmcGSEDs8VomkXNPvv/nmJvbKi6q6RbUXQJZ8r29CRweYKh299DvDO0ENoVmAGwQ6S5uaoa6+kzdI0RFogX3QFL1kaL5CldCKtzMQNZ81dl1JxT1iBdHhIyomdO4FVgXxwm8IGmo5mx3821x6jd770uAij/kOdEOYubkIGphp2Fr6Bq2INXOhpUdQ2DygrBRebcsAETw6UqENUBBH9EiZyAUErpHkNNeDJS2TENzxB8XARCCHbhVOI7bv28ziIRNGQOZ7JWq+GPzqn8jJ/rSu6b7+beLBeT/P8P/6Y2fL7I++4cZ+rHh+upmvH4Mztlv95j7pZ0gpzed6bfUWDF1rHcnfOm1Z/j0Z57jlz4741efKk7N8MHHhD/0roLpMEBL2ec9ijdAJQ59BeaVoMpgNowJOy02RvydIjsU973Xfd4jDANwfZVx82jE9fWE8XCApQHEKW7yhJQJXJyoYyqeFzBMoFyQcnw/zrtZBbhcJsGdnN/d640jTosAQvPxp8tO9jF4NFiZJhejqN+sbqwRLW6AfdkouACbCvLCPlR1arOKwjrc4F49sShlgpLLm5dzcxEMp2CqOTdDum/9UgnXGhhEnMQEUw8TCbC1i8bWIOTEydWZaxWscUMTFJktdAOGLgIQYUg9uhZv29f2ICMhXfb0gBN0psywKpjF3ZIUYTiyjQzqW4MUkd+UnLTVzF8/ejCT78aqRDvo5mOAjwy0FZXNpisRBlwUgFvXQfH1KJyeYd7yq3qyMHR7BcPoAw9m+c27IIBHefA/7MAf7R4BLn56sIHYOgQHFBMZfUAM36mG//357fqFVEzF6PemAHz46z+C8xd/Jmk9vwu9fnyYrt4/XT/hNIxh3Fmd6KMNurxAv3+Gfj75em/taLfP8cYX3sTPffoFfvqzgjdOhEMB3v+I8OFXM77qlRH5wLhdnXXXu10cVWPmOy+MpbpufRoVpVzWatvu1Pnx/oqOYwERYSgKYsY4jbi6GvDo8QHlMAFp2L36OZdg8yVQcsadqYKHDPDRNQTmluQX8QcDVEBUYnAHY4QAACAASURBVKPBAJq3/EheBLTGrOoCpvXcUc8CM0aZDh5XttO+AjtRDVquP8gl3HjdX4T2w+dCFdu19ABHwIqPDJuApdVYjS4tuAy2W1z793MhzsrbfBs5AgYHMC1u996xhskpditsCQu0mHHDI7AzAgPPMCUkEpATBp2bECChbC68LdB5XNSQNRmkKmoVJCZM2VeWrQl6JPuOhVGyeStvF2oxhf/fZuK57dURxUwUwee84AFb0d0OnNunkVu9PzgLGqpEpiBdOfMBGw63TXxmL/MHtpUfwy5AID3YMjzQBJjspMKXEIVNVOSZCfZKU3zbXPW/H1f50ntv7tbXfhtdwG+5ALz/Qx/Af/bjP4rz539yIvRvTTz9Q+PVk5s83QSY1dyqWyusVfTTHdbbM6y6KOT07BbPP/cafv5XnuN/+wLheUv44JOEj7zKePVJxitvn3D9+IB7debehtg7XdPftS5O1y0ZKFkxDcAwubilZH+jQRS8cMbhMODx9QTihC5O1R2PA6ZDQT4ewGUIh5sAvfLgACYlB8CIfOZPI8BuxGC9wmTG5ujmxaIAlp3zEL72LmL3+HLta2w4urPgmoJzxhAR5hQ8hO0B9KDR6DRUkEhQStxE23wqzqwrOUCk4Kpy3IKQCOBce3RGHnXmzkQZIn5QYYahOBLeqjP7EhGsMUw0TFIIhBxJyB2u+zEkCOpcUatgaeIBodstJg5OWhhsJmbU5hFnXpR6bFsStCmWRrDm884w+HvSg9gD8bb9MDk78bxq4EE+YowJ++9vqpgKQVJCEzd42ViLEnkA/u++TtwYfUzks38c/rKlAjMuVmhRELfD3CKlaF8JsmNOgK803dkptgV0ObxBcrz8cytOuCgDt68p9hvDAV6GF5HM8P4m9h1i9su1yhv4beQJ/JYLwH/5V/5T1Pu3Uq/2BEgfmx49efdwvGFK2X32dYG2s+/764x6+xzn5/dICWinMz7/uTfwi79yi7/zBcK9JHzLezO+5QMHvOvtA8ZxBA8FVYHefDNgtAWEGvJQ4pYmjJMz9pg4st8KxiHhOBVMQwYX1w34LJ99ruYBYs6NL1NBHjMo5YjN8tmB0wDwBCI/yC51JQDFswPCnny3hyWnz1IeX0ozhjaYrh5KKhXSOtra0Fd1y3Hd8gUjEQeuPtwAuM3imlPauxjX9vtD25q4Go8AzhmUbF+VSQ/ijypaV5yrYWlAhoLUI8k4+QFc1wtfPzh2qFUBaWDzDEClFKamConiS3HjqUZ6ThPUrmh66bq2x3Rb06l5IpFpc7m1EQr7ZsfUULQBUOTs4aSlRBKzeSOdM2HICUPx5GIN9V/KvINjmZPP20IoxcM7z6EypHA/4odmHwSMyc1YCLTP3SKX7YWFoaiF5kHkEsVmMas3e/lmTyFpJnFRkWMs8XrQ5jto+2u5FYFNPWjhThSuYd4J4cJFsAAasdmJO3Ho3U3w3dL0fzrdr09p0r6hDL8rBeBt73w7mIl0fXaQevfhRPztaTq+wu6CCeszZLmFtTOsL+jnE5bbF1hOd8iZ8PzpPT7990/4hdeA2RL+6PsLPvZ1N3jPq84UrJJQO3CuFUuN2XMTahT3yyPO7rJbPL02hRLrMIRhyDSijCPG6wl5mvxWjqIBSqElN3DO4DzshzpOG4gHv+lpO/APaixikavd53keAIoi8qA4eArxDEQysQadta8a87pvACjlaOt6iHy8mBipqyRjXsYGIhLBw43DwTaR59DlEL1EcKlSqCOrq/F6l8A/3FGoiyKpQtV1DJuoR4V3YQ9ZWKyZ+hq0ZB8xtoLxwIxDw0c/5wRhoDf5dUXA5dIp3O4k1lpMDM4c/AjBcCw4joYpe7hpE/FdeWT+aXIzV6gXqa6Gkmi3/07sN3ZVg7CPSmJAIzdPSWBYN6ys++jEsdLMUURKclcmEcN57lhX3aPdtmV+jVUcY7P1JmwUHtVtRLiYp0oItkp8XALQ0wAECUAh7/Zq/Nl24OvDpREehqj4dxTzVfemjyLgq1X0o3PFr17lN2/n/Kr9rhWA//Yn/iusd2+xzK8/nqb0PXk8/KEyTm5S3VcP5Dy/AGyGtQXrizvcv3WL2+cnQDtef+OMpy8Mbz9mfNM7Cd/44Ud451c9BufRmWit4TRX3J07atsWCf5y5sJIOcEog9QDLUtOOIwZ14cMzhlIA3gckK9GDI8OyOPoszh5PjU9FFWwt/rgwXVlsbcHbUWBXj74QKD5nnHjn1te+lw//HU//G5B7sEg0i9rMy9I6YGQfeN5bzdqgESxTrTNY5DDGVjD3DQ5k5Hhe2/tDjiWgbGuiibYb76Rw3tfGRDd2XtbW9yD6eeu//5oNmHXTZhGoIo7Kjlq7WOZ55r5Pj+ZIbMb5lnr6FGoKAhTOWy5LHIBaDNHDfT9MBGOV2FdVgnafDvBYb/to4WzEDdZblgtBPgXhiC4TGBNDCzu38/wdl/DhJNjVOJdYWiuJ0i+QRiiEFkUyI2Qw3zJWFQBhlBQ1m3ZA+wJSx5bF35JwaJMFrTjDUMIM5lkrh/YTGFUDBpW5vbgHto8KFLgT33rBPw5es+p2ico4W8NXe8pmxjod14ApuMBzERS70erp/fkafyOMh3fScze4i4vIKe3YP0EkKKvguW+4u5uwYv7BqkNczW8+6tGvO064T3vLLh5xyO0MqB3AK1ivp/x/HnDKm7Wsc/k5I+lCO/6ysROzy3jiDRN4FIAZgyHAdPViDwMoOSegA6jpj1J2K+kfLntw/gJ7Cm6eGBldeFyarjjxCaY8qVD2GjOrUL7AqDCBJDOUAlWWredZvxwGbxZaLtjcTwwujGa9VKYIoxj3wYASMTI5l6IfW0wUQxTDsuxhpKwq0009ueU2IkyAai6cYh5io4qEj1IW4a4591m1BlbiQ2DaN399Xnbu4dluXZfAciGR6QtXrwA4sZtCQ/33T7qecipoYmE7Ni7GyIOjr0bqPhY5pgABdGJNcwzCMgJQCfXEYiPSTla4d3AJTwdSmxANvFXr4qT2G4DlpiQQlfQQquwZRNEdsjO9Ns1BDECFHZ6sWSLYuw9/rAtiRzv3BOSKnwDkuhCV88SKz/sfLEdVNwBTlyKgJkdV6EP56ofKol+7SZ/6fxb6QJ+0wLw1/+H/y7GjfOYx/zhcrh6lXPOJi3SeN+ErS/c56MZ+rliuV/QNtfNXPCOdw54/GjA1cHppOfmMqqkihcvZnzpWcXdLEixZhuKS2eNyKPCUhh85IzrY8bVcQSPI7gMPu8PBdMxo0wFlIsfnA2co/zg9g9Ab7vt8UBw/ZCutfVeajDtMTQ+vPVD1qxr0HpbbEAMfSfq0Eukj23T4NsKp8uu1WDGGMkh3xaOlCLkrXMOcFAEqm4FRiEza+ruSL0qUth3I/bxbm6ZnDsPJ9f4sHFJ6hHV3fabiT0ohQAyP6gPpb/6APzqsVmgQNJVHHSUB7qELRHJ2Yi0m1+kxG5q2p3h6eNANNI9qLTsftmW4ESiDhRsB9JbGtLATOCCJNlGI3KWY4pDasHh5Y2dFBmCGh/LYQ6CRKg1aN6bWYi4mrArIpLM3MCEyZnMm6qPL2ah265/m99p4/AG2p/CZQpMYDWQGqpsxCTCRiWhKGb2YPj3yDLnkDJdikdS5xIEx/QDXewH1PDLAD7zWwEDf9MCwMwkbS263l0z4VsppbfDxG/++zegyzNAVqgktPsVy90Jy7KgizqVdSo4HjNKYazC6IE+J6yoS8ebtxWnVYPf7ySeqyn298ywnJCYMeWEq8OAw9UBPIyg7GBfHgaMh4xyKKA8eJBociQf7Dz9bZniHy+B9P866pXZnnO3GW446BeA3/Z3tsMvK7RX18rH/l2a/9M/t1wAQ1zeTCMvfrX5AU5BRCFznGD3nTP2WZc9VixxBiVfS/beoogItPuOXs/d98qtulf/RlM1QlN4FJpqpBkHah4AIEW7vVFSm1Lo0f2QyIZGh4ae2Uk+7lgUpp9ddoCNiMOay+nbRI7lFAaOxX0O5w6slXEoBYfCUM4QD+pyHkmN0WmzzlYH3IgIY47gFjEsVVCjY8pBwM8gDOKJxmwAq2INSTMTgqxEoTdwdR54I+8A52o4rbL7+m0FAKbI5u2505N9E6DmNz8TUNW7GRdOGRa9cA4QJiJsL8uBu4aFG7l2xfgCQVkEkSaNv/MAGNitH2mjJduTqvTNovY27fo55Jc2l7/9ArDNzuvtF4rW518zHMbvgMo7+nqL9uKLsOUpyCpEFPVuwemtO9zennB731C7F4AxF5AlnBZHrw8FYOs4nTtenASnRXeFWMmEw8A4DN5iV/Pt6qFkPLo+4OrmGuUwhTd9CjYeI48FvB/+wW9rKgAPF13Cr1+eqO605N/gqLm5UyBouxtYuEU7SYf2vs/lKopeBW1pMGSU0eHvVjdSCO3rxi5e+V2rkBALDqgwctYIwwwKanDSHWwMoE51j5ZC8MfV3JEYEVO9+xOaz/dV/OMl0oPMXD3Xg4GHDcSSDm1txwjKg63m1hVx2F0REwbyIrWt4HbAlS4JO2E1ikSCcRgwjAMMil4rwBmHoWAogmYWkxbtJBoDMBZPEl6rdy1s7rZrq2MRy+qJwTnk0pvBRo62f0SoGbvzBAYmNIpD3b2NNzVwOAN5wrAXiRor1w3YbN3wol8eFsHFFjxv4GDEmkms9Ba9oHQUhqGDKlLYkPW48UV3FfVOfbaNcbS5AsXBV74AgpuXQ3QfDOBVE/0jS8Wnj/mN3xQM/P8sAP/j//LXsd4/Yz2/9jhn+h7O+UPWz1lOb6DfvwHrM1QZy13F6ekd7p/f4m7u3trBjRu4C5gUao4+dyMsq+Ctu46l+QHbMukPQ8JhTD7LEiMTYyyMR8cB1zcHjI+PoPDM45TcXaekBzd/8cOfCojLBaxD3O7WXZGnkYPnjO0g86R9tefadn3QukeaTZw60+pGn83i1hdob3GYDL1VSBPUqu5ZAISFtrsUbUDnznXoBNUUcVve/qniNyDqGxaAAJj2aCn4jaRx7SsAoQtWDahHcnNy5dmGMTyofBIMP4SKz78fhQffJURku834kvzhrLjsFGnHPdwFh8nXWoUIzMWDVYPeRhkgFYAKurldurMfGcQCgiATYYzC15P6Dd0M6xpJzLp5IPrPt1YFB9X4LBc5bWvu+rwdlJRcSq4KLO3iVDxpkIm6A6VL9xFgSE4oEjUsYUYyRMdBriOGiKESoW37f3OK8GoX9yAEd2CF5w5K6AdSJBBv+QMW6h8yX/IjMI4UnUHnDXu4KAfdNJXQDO8+NftEyvhbR+DuNxsD8m/a/q+3o7X796Yp/eOE+k5dn0NOT9GXE7QrlvuK27dOaOfF+fKZoc0ZEJQYZB1QAoln2p3FMK+K8+IruWFMOEyMw5g8spkIxhlj8ZirccoYxgHleMBwGGHsuoCUU3Dg48CnEgAf78j5hZ+vgK0X0X+45/rg+ODwb5uDTZYV7eg2Cqi4O65KczOPVdEiwts3dg6gUQ/DinDvUSQvgkogbbvbUMkhDd4FHB60ua2qtqZDen/AE+8+t1sYoYZTrnsl+k1qsc/2BicUfBoOPf8vyLAooSmDjAG4Ok+2EEu5/DyXLb/fPZkkyEjsyPWWsivO+tsA3c3xpzePyjKBm4cYQ7ofOrWI1KaEbj0A0c2kw22+ehMsS8dcNSy83M9vFsXcFWv9vyl7kx/Jsiy97zt3eIOZTzHlVNldQ7PVhAgQJERAECRBkLTQlvontZUIiBIBQVxpoY0gNcSxSYGtLnZXZXZmRoS7m713h3OOFue8Z+ZRmUUqgQSqIiPC3c3s3XuG7/t9JhLaLs8tF3DT5I85YPB9+xY+ujZF9dUiKXBuglNXn+4bx1uCyYXPbElNAylGPw5ZgdYJxRpN+7oKrH4IZDX9v4DQsLUMu7cHA1nlsh0EsqkScZnyby2YkpubttWgJafZDEIUpDgWpl+Urq8ra/ri7rH+PmXgv3MGQLoOFPAzQN5qXROfzdnHi2A9Vzx9eMLpuWBMATlnnGpFE8WYEqbJ4Bm9dyyFcVpsKqogjJPJbsfJyv7oIuuYB8yHCeMQMQzZyvs8gIYZSmk/wWNOCDmZDDi4Cg+eFqLRS0mvkdGh3qsTgjuqos8J4su9v26Dv76TGZR1R1xbuGlHXS3Ygtk4eKryIv3WFH42e7CJO10BSdIuHCprgEIwJEuPLc1wWFur0sUovDZ4U4RgQzqVC6lW9VIdbBoCg2FuNL2LgKRqsHHgJwqzGBQ5OpRTbUfPck07thJfha7mB+bE05S9/RBkaajCaOIEYRFQVYzJVoAbR0G7E41FAGkgEQgHqHSECLTCWM4ddd0XLgCR5f2pQztUfW0pOBfGUxGUJkhQJK9G6j7MtBdh6NYuCGx9t7Jg6WYPdhMrzl1RQDuleHEGIrNi6dbnbwRij/1DEZ/mmwDchFU+fI1QRHU0/VaXXS3wy3ZQOlyG9k7ApvzkwSJdfYOhNkxU3yZcRRKAbMzwxdr0P1ua/JvWfr8y8CcPgH/0j/8ByvP70M4fMkl5DaaB+wnl8T1O709Yz4y2rKhLBUEwjBnNnV3JS/kcCKV1PJ8azqU7tMEsuMOUoZEgZNPozmrVwHHAzc0ICgl5zMiHAZQHxCFdEEzRVGQhpcuUX8Vvcu/OVPcBne7DOH/oHYezbwKutgDqyHIiE7Woq8K4s6fbXPj1su+Jt4w/Vwd6hLaI+ANqyUWR2EJNnMvP1Y7uoM0rBOyrwV0eLJ6oI7hwFb1kffG2ulfd0oStX2bXypMHfMJVbdj++xaa6hN0E/TQppW1BjdctiS0MarJthSByGoFFzMorhwru3rOWqTWBCG61wKCIM24DTG5ArJ5m8EoRFirYCnsWwKjHUUCGgJK4/2WrI0tMbnbQSDeArUuWFlRZatwFKvDQNSvX3FuQN0OUbZBYxUDgqiHf0QX9HR/SRi07/23n7VbBMz1lOnCFfSb/0IRulRh3dHgtt9XZCKk3QvhycRb1gBg4h/VfR6wVQHqEWqRgK74srD+N6XK/7Ss/TtXYv3/OwBCCNTLaVje//rdkMt/kiW8kfMH1I8fcP5wwlIUxN1y5iIhDgO6NhNBBOP5n6rFKT+dGALCzWxxXMMwYJiSR3X51DQAN3PC3e2EPFqfP8wZafKyf+s3Y7zs+BGgan2lvYgdKgaopOBcOtGLdDdcNgCf3vo23DO5qkrfvx43G/htCK9WZF+FXXr0jSkYEONFeEQke58dSCA+ce+cQNqgzPv6h5lRHaqxJetCuvenfjhxs7TbPd3W3GiqQAwRMUR07mi97WnEycUupIRMiiAdrXc07pdMOwQ/BIxbuHnVQbxTb9QfOAqE6JLW7TXYGPqb4IkADL4LTyGidbKVpe/6WY3kRFCoNtRWgMaIuPLf64b3tuHbuZh5iGHR4dtc1nb+9uB2dRCoWp/+2MwYFILp/BfXZAip994uu/Wv1xiXHl5oR4FHuTL46OWh5p/Q6OPlufyTWv5P/7dlSzrXwmcrbjdD2uPXgOa+hK2N2N6jbREZgCxK75j1s3Ph/+eLt4/8U23ATx4Ap+//ksrjb8ZI9atE+rdl/Xi3/vDXOL9/xLqsaL7GAoB5Gmx45vjqWjvOhbHUy3RzHgjHySO6YoA6FI3Y8+znEXd3Nxjng+fQATFZT7/ZOEOIiNuwz0MvafNKUvhEvaefbDTCRbq7/x7DVm9sPZfk7bMC9YGYsfvM/877qk687A97BPhmS77+miqXOcQW+KEiZiMlQqSO2myf36ux+qPn9G0Tfzucmqfz+DQ8Ze812S3QdEndVTVuYHQcOHewinn6uaFxd6tqeMG2C3jpW78SMO50oD1wReG2YBPcsNgmREWQIzDmiEYBURQpdnAK5hlofKm21KEkbJLltdlkfgO8DK4aOq2MjwujXB02MZrC0ARE4gExnj7EihMDz75jB1sbAGBP6dkpO1c03860L3+2cl30UmbrJ4uiiJeOv610NxTMy4Pi30eXe1U87WlB28D1inJmB5b4gU4v3YbskWgE/Kx1+ftrk3/duvzlT30L6afK/7/+F/9b0PXXX+S4/re6Lr8qT0/x/P0jnp8WLKulypyWjpQTxgNQS8F6bliKkV9Ks/41BsXNBMxTxDhFIEY7rZvPkwPhOI148+oGh9sDNCQoC2IERJMRc2Nwimx0ddynxyftP8o+yHPd/cavs9LfRZgq1jpcTdXhPbP6A7XZd1vpqEV2XLWFZHhJjbAjyS8lL//OHRDINHDqXu/ggE9lRquM7sGZuj8YFwnqJ6eY9evR5xYeenGJtGa0Zg/UdoBZSbz57xnaOxiCISYEBD8M1FJzXCPQuHuWApnij6xvZr7SSPmADipefdn8oVUGcsCY485uTBQgwcROxN1R4HaQ1i5oBSjNSL5rM1ZkjMCUGcyMp7XjXGV/X7rz93JQ9CqoasSkLoqzAAtbZdmvH1yP8EoO1txe2pWNypMB3CTFQOYrAIBVFIvv+rtXGImAKWGnGVsLQXtSlPoBYOU9ubKBfscS/Puqhk9/nT85EGj7NZcFh23wqxePAam+Wpn+o5H11bq03/xUG5B+qvw/vPk6l9/8+jZB/k47PT2Uj09YThVlaTgtHdoZqg0p2jl4Xio+PlU8LfZAjUNAYtNFj4Op9DAGW2J6xloKAfM04u7+gPnmCMQBvRmZBuMAjRZHnZJRZMP+cOsenAkRl4iyD9Z8wBfi7sHcOzP31oNst3wRAvnDL91uXTEDTS8dZWVwt3J6n3+/CGwIezCHyO+aYfzuRyBxS2kHI+yiIXPwufY9JghMQbn37F7u26bjksZDRLaWJHtAxSO5WvMtg7MEWNhFPWGn2OSYMObBkF7st1YgxHAxCGkAaIjIFJBJQWLaf+ZtO2AVRRBrjwILgtqQV6CYOhtwVQS12828rGw+fjYtSG3AYyGPYQ+mdPM8xCgZxVuH2rbsAHNEQm1gKrxtKC6OuVWBRV4ivDf3XcPF69/ESn5V4CEBb0fC2zngVSaMfk8sAJ66Tf5PVWz6H7HTiFM3MdDqf9/CwIndwexzA1LCQIrBPzv9agLQ9TI41H+P6gCXK2yvErYk4x85TKIqjgTMvfNVgum/7wwghkjcBqkfD/XpHMva0briaWF8PK0YU8I8ThhSRC8dz88dz88VpQccDwljDuBgwRZhjJBoCK9EQHK//TQNuL2bcby9AdLkBhbewzNiDjbXI9OF72buve++SFt9XPPSfL21yuHqv2Pb9eu+x1ZPtdnsxypivT9fqDy7acQHfOpMPPMshKu35bqo1n3az74SVLHJuG0UrDKhbaEvQIClGGtM0LB9T3KparbveatqyNN2vSUJbiQyVZ+HpBIhq6Ab09s0EiECYtz5EAgEMxWpsa8dpW25AOqpO4YIs8FmkA5lswKvnoxcGSgdoNbNBZdsU7JWxqlG1NIh4tsZZZwKcOodQQiJLAU6BUUAg6GovbnD0IAoUyQwCZa+HVQXXj9gFmBlQfbrQF0kxT7YY3WxjotqXmXg9Uj44hDw5THiy/sBd3MEN7HDigUfi+CpCk4VOLkisHnaTw4+Tw7AooTviyCJ7embDxcRgAMpjg4UWeRyAKxKeBZFVUK7Ogj0x6VrO0ikX/3erTqgT+YO5rTEHYn8h0vBvzzGbz8u6bN/9wHwj/7xP0A9fQxSfhhDzn/YH0+Hvpw9kaWjNcYQEw5TwjiYqmw5VcNbEXCYCONAezkewmXKrt2y6IecMIwG1pyOEygN6GoJsGk0Nh8lg2Puf35z6W0+/Bivyn29sMDIDDQGb+j7TXpx4/mCxck+KrTv+reYqu6pOtdinK1VCCHuhw5tbkC9tAbbVmAL9SQK+7zgMlfofiiEfQioYguijQ7hYCCEEL3nYyjbLUzuDmTuuzEkkCUPbUnCm8IvgpBIERiQGL0yMMstvPdunbH4lgNXTr7uQzlxOCd3ly+TIKmgdcXjKjgXe91as7mPiqB0S0IuVVCqoopY3LcP2UoHzt22NFMaXRdB9gG3Zcd2ETkRacSQGEgEBePZdf4b+NUgJoI3mXBwBHzxBzakgMqKU1OkQBgDcJsJXxwiXk8BD3PEw03G4caYlh8eK3okMJNtBMS0DICxArpzSgIcTR/Mvp6hGKP15dWJSnO0qiG78u+pim8ECEdV3ARCccNTw0Yh3v43bUM9h5b4e+PrRf2EUPSy8SSQ4KuPRf8+gv7vR+AZ+N02IP1Y+V9O73N5/xdvo/S/28/1vpwKmijqsmIgwXxIiDHYi8Ewxv8GKnQa7xYYwWpa6ykCKWeM04gYI6Z5wOH2YFZXmLc7ZUuLQcrG1Q82yAop7FLY3Q51cUrvcl3aXBly5bNVmBtNryK24dN+b2pt0NfBzYJJysr772dPwjX7aHxR/ge3teoV8/kyG7jo5bbobas0urUt/oayEiJFd4kFt5Hag3j9tfY3Ngb3jJvwPUZ/aBqDKUB9Z7S70tyTH8gMNKULSmto1WYhtZn3fa0Cbux4cBtY1m5BqkHtnqkNkN4wOCzlebXpvCkFbdXXXbOu7i2wg9ToPaxkMwhlVFWMISNFw7KzCBAYBNuQBCKkOEIDG8XZ16LCLwkcQyLMOWBMBB0DjgH4bLZEp1Wtp7+ZI0oVPDXFmAKmYN/jMET0aF4JHgKexXwAPxRFWQxC+qGZIzA4vWMaIjIrlmpBoyc2E1xUC4UdoLvJSLtgCDBScwpWQSnvK8SjB9iK6zCakpOIBU9COIvnB0D3QSPD3u90lSqkeHkgXFUSUxN83YUOLD8OCkw/kveh7ekb1dO3r7j88B+3ZX19OlWc146+VExTRBwTmqfHMJvzrAp2ggpo4/DbIXAzBMxzRkij74IThsOEEKMBFqJaTNeYoCFAQ3Lyrd30tu/3nhfbusmZeJuQB34IEExptuVlIcFGPLSD1tRXcOoKN2Eb9m0rvtaa4WJJewAAIABJREFUQTOv+u1PJbkijrwO8Uc9FNvvuVQQ/vD71I5CRBAxx5j3ijb5Zwh3/ztkL+OBYNTi6K5GGCTUKqv+4uRXuBLO+FSIyojBtQz+gWPP3OusWItgWWz+EZOt+HoHVkdvkQi4VQtoETFbsALn4kEh+4yFEJTRQWhle58MWLKp8dSVdVNMOGTCEBlNu1UOEBBFZIXJgTUaoyDZJsFk0zY4nCPhdoiYEuGQA6Zkct1jJNweIjhF3JD19sfsoBFRNAqYgoIE+KEKfns2AdEEQgTjtDCWxfiKHUYdEn8/s4/ixyHgVSK0wnjfFD0SZtrSpwOmbMPU3tiCbBKBA2HogmO016a6bGXMVkEEH4gnUfS1464pVgHOYhLhxjbfgMuQDUt+CRBpV0zBq8OAAAxd9P5cJX798Ng/XQem3y3/P4SY+Mhx+KPy+Pzlcir5vHR8fFxwGAIOxxFdgedFcCreywbTIedIGFJAGKLplxtjSsD9/Yw0TGZ3BZDHAWkYwfA47SkjTQkUB8vOS56rjmDW3Zi8fPYSeB+SeQvgm1LsxRJ2ph8hetvMuwFIPcZ6Y8j1apN+Y+XLXtZvs4ftpr8+CPZd/O+Z5f7YJN9i0NQx4WQSEjfiGA2o+2wh7bMFguO/iBCo2WHggaDcLDK9dd4ZeaoKbeZXsCmy+PqMdzS3ukNQa7e8AXZqkX+fpSjORa1v52oS3Kt4XGPaE3q3iX1O6mitZENTY9zsFpUhmRpSXFo8ZuAwiF0CrSIkPxjR7PeIVUNjBrKvK6tXlfdTxLtDxMNoF0ieEubJ9HfMilM0dd0mwjr7xdDY5LgcAnpn/ObU8d2p79RNFWCtbPkJOWMUxcCK5yIolX01bW7VuyEAlfFw6oie1ViiWZl3boJ4C+uqvi15uAkjdEUa7LMuHp+eXVBUYrRLUZzE7MLQ1hQcbJW56xKcObjRhn+kRXhg1r8jwD8B8N2nH9b0aflfzx+H8/d/8bmWp/+0nM6vz6cVZVkh1DAcjogp4nTqOC8N62rx1eM04PYQQZ5mQ1tJB2A+DpgOM5Qyau+WmTf47YqAnKJrA7Kn3Tqq2mk+iKPTedlveuv9zfW3KfmSuf/2A8CV1LT59nXv8bmbsGcv18kknvbw89WDT3vJfxH2YI/kslSey+T/0/5/+/u37YEIAD/IyBWH/hdApO8zAgoRcWtnNjBoiL4BseU1c98x1dKs92b/PsgPntIZXMqe7EMO9ahNUbzS6b2jLB1LsfI+kFpmnQJLUaxrRy0F1VmD17toM+/AA1r16udVjKMJk6QbuSMPETmoHRitW45DVCAYa5AlWw5CC4YAE4srO0TCPJrzZW0mJLo7Jnxxl/FutrK6urR6niJ6V5wqY2FG9Om4poAFhLUySrEh6VIJ68p4PAuyAEOOtvOHqVFjcipy9UM1AMch4GaOmA8ZeY7IA0GrYjo1ENtcIEVCH0xUlaogs1qgSxHUldGqoBSGVsaUzB6NJjivjKI2n1qbYcmzq3z61XqRXck5u8Hs3C3FadMmiEeTETmU1FaD7yrrf7VW+R+Z5fvfewCoKsrjt1o+fDPJ6duvyuk8lWIhkYeUEAE8nyoenxraVt4QIQ8R45h2THUKDBLzgB/mCXGY0BmIkTFOGcOQId4KhDHZQI8UIW7ILdo5fQhpn+TTZs0ld/sFy3qmzQD6MpTde24X1LBNxY1tZ9HjCsNwtbKV2i83DPtE3T1DMRF6u86noxcPv4i8ODBiTD/RFmzCI6tGQAFC1vsSyQthd4jJRx7bsBGQetn1b63QTg2qBb3bFHs9q29WPJOhEc4rYV0alKs56upV+Ijv7VWtfK2lGAJcXurZNq9UTjYbIV/RDckGjkPw+Y9ENA8GtZAT3g9SFsJSM0TUtgiadkoRkR0sg4eplmZ23uMY8eWrAV+9nXB3O4CSVYDDFBFjQOuMeGoYXUqdxPQC57WDvCNkVjz6YZBiwDTaZ7gQMKdoPEEAtZi/4ORa4jevRrx5PSAfsoma1MJQ05zQ1mrBqEQYM2ESk+yyMnplfP/c8NunjvfFVooJwDEJxm5r0x8aTC+gus9QAjm8xINkWNxa7BjxiMu6MzgZSX0EFn1bZLQgHUXpKxHcPJ0qfdr0p0971zTdRakt8XoeWutBlBDHEclP8NNasS4NKdhQLzitFVd55oEU4xgwzgdMhyMUEaKMPCQM84Q0DkCMtttPtHOSNgSYanTTjseMuc6fkjn+rNPdbsTgEVw2IlHn2NlkX3a2urL4za/7h3zL1Ot9G/QFrxzCPuG/lO6WSszuctuMLpeHn68OBXLoZNxbBNPzyycaUfJ+3t5Rm6FcQlWtXfCfQ68MSWrpPORWYFFFax2tdfTKWIvgvAhaZQRil8xGrMV89XW1oWG17sMQYtg+XOoDQDMmsW7wlHpZMBMwDha4iqs4g+A+AUZE8AOut34hrKk9kV06uNnMQFTA0hFDMvBJMs1/l4SKjhyAmylgJsLNzYDP34y4fz1hvh3NUBYDoidHnZ9XFFUk9swDFnCxjC9tgkRmq63G88Y4RuQU0DwfcBoCJpcNd5g4aa2M+0PE21cDDq8n9GgbBenq3jPHJAdgDIRBFPXUsD7Ze/H+1PEXT4xvVjXBEgFJLUAkVFsBFt/UbC4/IzzRPuRjsT8LV/nVau1W9Yd+CE6kl+1z7RaOCzdk6KL3H55bnB5ebgJ+ZwjYypJaWe618edKYaBgVBUE8/HXLojZhnSWLEP+Adr6GLs555sR880BMSW01sGdMR0G5GnwBz8g5I2/7/r3jd1HydJ2aHADD10COMIWWCEbnOcSnUByUfK5hFfF1pHbg7qj/th6KpVrxbb+zqT/ZYUkiMmhjb7a227+3b+l+qJ9uG4RthsQnixkVUrf135MA2JQd+tZmSwSLanWASR2RiZEr25671iWgqengvO5e26i/WwxKIZkw7dSrV8HttTbLW76KvEm2yq3rhGVE4Sy2bnxMtcuJWDOF4KtmWRsW2DhowYrVRHUxkgp4jAnDJHQmfDxzFikIbozcUiEeTB5cu02QJuS4G5KeHVMuEmEmwhMxwHHVxPGVzPSwVBwFAhIyYa6mRFStxvRK4fu9uAqhhcnF6Ftn7XuEWpbH87Jbva2dpS1gbrgze2Em7sMSQHFQa+hMbB2DIt5KnogpCo4PTf8v39d8M1TR+vAczNT0m0ARtIdF9YBrOIVk0t6mz/0ogT2TUogePYgYQqmA2hsM44GYLjiCGa41mCzvjkjQIB7Zv3bS8Of/vzwWK/jw9I1/KMtTxRxHubbVz9bHn+4TxTjEDvOpePMQO2MEBvGbPx89dJP1cCK5tMPyCljnI8YhsFCI1Y2//6w3frRrbzhcoMEF/tQ9HnAZH0+FCp+UwZyww7/jkRKr4k9m37fh1Z6dfNuD/4m+d+19pvijn5MGQmEYIQfcwPyBRgC3a3AtvvXFzQl2VWLeLE1sGFfw/W4Nm4gYxBUGaTXmdGCGMRZ8OowC8bTc8F33y/48KGjNSPNbGtHw18FdPb/HwCV5q3GBVKxMehSDGB3lE2D/WKrFSJqD6+LfcKVcnBtluhrL7HtHalbyxVCxDQCN3PA7dEwb6el4fEc0Nlk5A9Txu2oSMFeIxsqEh6OCXfHhGGIGKeAmyHaLGFOoByhIZgkWB2RgwDKHTFWtN4vHuKNI9qtgmKXCCsItdlrvIptCBKZfI67oq6MWhg3mfDqxi68sycBTVDQ0vD8/YpnHwLmHPCxMv7N9xX/7IPgu2Ly6RsC7qMJgboaMOQY7b1ufrOvIGgMCGrDQ3YXIu2MRTMDjcH0Dpu4KbrcD2xVyxY11nSbHzklCvq2Mf7rIdM/JODDdT+3HwAxRlqe3w9Pv/6nn7ePv/0vlPmNa4qx1o5lNfBDTIIhv1QoOVofY8wY54SQzc4rApS12Qs5T0jDaNPssO3J/YaOpvGnlACagDjvGwGV7vt9Z++zx48pXU3ScUFvOwRiMwOFZB+OrceXLYV2k9+GcKUq/HFVpCMFrh5+vVoHyose/1rHZYq/vv/+QFffr1xJkV3XH65OMxVBc1kypCGS7eK12759XQo+PjZ8+FDx/n3DstrwbZ6tv+kOhRbXqVtpWMBtRQwMdm3/9vDn5Cq5sIUg2Qdr0YDSzJsRHOrRBDgV32E7+ScGRYGCSZHYREmHgXAcCHcHm5yzCJ7czvwwDPj8PuCrNwNubxKEFdEP0jQlzLNtbzgAacyYZ8ttpHBtVrKqitSk0imbArUUu+VDMvcpUsNjZTxVQcgRw2hpQlEIZWVkMbjIuQjK2nf6EQXC8SYjDgktWL7iIIqhdjx+LPi33yz45qlbB5ACPlTgr06Cp243c4Tubs2TEKoYG0B8j5/Dpt+/kIg3wWu8uthycJ6Bl2tJgMmlxALjCFqi0AUzFvxw9L9mYsXPFDS5HkB/rAUgqMbz+/d35bvv/haJ3NowqeJUC6ICc87QITkUEmB0RIqYxoRsTAhDLQGohfcMt5gCpuOIPI2Wr0cEbmxmk2TT3JAzKB0AOgAx+8O/PcjiIZNsV7hbby91qex6bxHzdavbak2JB3ATtKpXAA+9WvdhV9BdVwRbCW+HwGUluJl+tvI+BFv3yFVrci1VNmuufXhjMDJQIjZW/bXtDhvXr0LV9AC9C6Q3QDo6C5YVOJ0u0uu6NogSDjNhni1Vp3sL0B3K0buBRHstaI3dR29fch62Sf5FO8/ERq+VAEEy3Lm3DaUTSrXfPw/A6xvC7WQfvA9nMR99IESI/d1uCmoCnBfG89kCXX/2dsCv/uCIzz4/Yjpke68be+JRhDDjuXQI2WdnmIdLlbUTmwAuDO4VcYpIOSHOI2Kzde4wJgyDleqFBU8L47M54e2rAcdDArGgPTcsTdAUWJtgXaI5FpsiZ8Ltw4hwk8EpYlRBXhuef1jxF9+u+LMfGr5bbXXaYDbkBGDyABEBYVGLu99K/8lCnDE6xacqdnAbRackxwvoZbcJe7ipZWUAk+cRbKYn2VDzV7JgfTlxSgRMj0/FKag/MgMQYZRzjcvTOuchxKUKzr2A0XEYRwzTAA7B2H5doSFgPiTc3R8QkqKs3WFv0eKVfLCWh4yU48XMs0+vN3R/tFs/Ha33V0C5v5yWYwtx2AZ0V7iv65vTBzTbgyzC6FVRVt6Tay6GnW16Tvsqi5n3A0H1klBMu+oPL4Z/l3KfLorlq+pARPfDAA4HVU/WCzkCbBZdC+g0lSALg3tHrwXnRVCrfb1SBE/PjKeT4rwArQWbXI8ZQ1bkZAIiUbF1n9ux1TXwZrjZbL263/zkffyWLagcUJo6btYahaWaXbZUMxrNo+L1bcDnDwGHDJRmENJzMYOL8QkMI/7EhHYSLOcGUsUvP8/4o1/e4IuvHzDfHy3iywe17OvJWjtSMM7gMGUfOFvkm4qiluaqyQXtXKGhIAwRFAnDlMEsu4+eVNELY0iEz14N+PzzA8JseoV+aIhrB1gQQ3C6M0MKW/V4zMDNYHkCjw3ffbPgX/3bE/7su4bfLLZv31KpB0/64YsCAm2jMvtTWMX8AAMZ1GN7WLMqZjBCJDSXDVdvGTbr8tbWGZPBEoc2a3PYqUm6uwI/+WfsXb54/1SHX379tHxzvr0cAP/z//o/AADOjz/Eunw8CHOSrlhLRxdGyjDdP9l0PpCCyUQ/x8OA4+0BgKu1KO7OLoIFKUxzQh7Mu0/Rb8UNuBs3QuRoij0hY+xL24zo/m8yXt02lLq29qrst/S2Xt9098yKWnwmIPKTXqvLCnA7EATX7FXaNf92819rBl7OC6LTgOyDbAadcDVI9NWhA0KFeX/4lTt671hXQm1AWxXnMzuHgPF8EjyeGNVXkTmoMxEjRIr1t11wOitOq9GFzcqrANmqLPgBC60+b7CH/1zsdRuyCXxKYXsP1ICaLIQUgZsD4WYi3M0Bd8eAeUpIZGGo0yBYG5vmH0Drxu8TBcYh4uGG8PY24+dfHfD51/eY7g8Ig62BDeDJ+847qEVzi9uyFRVjTMgxoocA5oyEhpAqRBVlWaA97a5BgIzm5DfrPEU8HDPefXbA/DCigdCDiZ+4W0sZ54gxZYOIet4BPJE5lo4fvl/xL399wp9+0/CxGZDjjmx2gO2wgQ3nrCR316abg1bxhxpmHoqku3xtgiJ2xUEVU7R2Q/dUMnrBrmGfAW1E4LDlEdCLDTLC1fVIwFsV/S8phP+LoH+13Zpp6/8BpPPjx9zb6U0aQjbtdUMIiikmQ3g5eygFgKO9qfM8YTgMCBQx3dgVUlfGujCk220aU3JTD/YHyZ4GMgqswkI1uexRXKqGww4hOfHQab28Pfh8QX/5Q3t1FuxyNWELohDh35HrbuX5jx8I+kIfwd7Ld6cDbWCLnIPPdOkFCmw7KOxgkr3CCD7LCFoNH13bxY0oJkg6nRpOJ8WyCmo1KGitgtNiN3uKhGmyQMxAQG8dtRvLwCS8VkJOA+2EYWaT8IKCJQI1OyAAM+Ysxa6x0iyQo5QKUnYOITAmwd1NwquHAfcz4eDnSGVFaYzSFOdGFivGisYd5O7Et/cJP3s34NUtYYgBtw8HDHMGJWNGUkyeMGSycAoRCHZIwmnLvTSEUGxQGUYgzggaEXIFEWE5NfBgAaPw3INeGlpnaAz47N2Mm/sR0/2IHgJaEzTPS1Q205A2sV4/RdAYrGYWRV47vv3mjH/x58/4Z981vG+KQybcB8GR1I0+FwjIyvaQjpFwO5jP5dQEH6viQwdOYk7A1Yd1gYCVCWdRHEUxMzAEMT8HyINNPJ9hC10VvPCZbLmDL+p+X+mSMQPuutDfbYLba1BR2iWr3KU8/vUQqH0x5TBCgSlGDDTZ2illcDe01eA763HImOYBw3FGiANCtr0cywo52f43DwbsZAkIYgxAZfvAU4zGPxcBtJrWX2kP4rAkn08iu5TcxHMJojA02PVE374P4Y5WPApaNze8+dGtn08/6d7bCETM9kEJ5Ek4eoGDmFBDdkdezuGynrwaFJqK0eYRzJYj2HuxVsLbCRbFsgjOp44PHzrODlAVf/jXYuf4YbKhXfDEoN4aWrPfA1hc+ObGjE6/EdlSi5ubTYDSgNo8Nntjp9rHC6CAIQfkYGXzkAi3c8D9bcbD/Yh5sLnC43PD+8eG87kb2q0LKge7VWvHPBK+fDvhV18f8OVnI4YxoFYjOktIyHlAnEYAAZGsHwxITlQWcBCEqIjZgkhIBeW8QiMhjxNCyhAZEEMEN7bPVbaWrXdGXRuUFSkFvHl3wHRI0EBGDqod0hhBFMmHZ3VlBFbMc8Icgal0xNrxww8Ff/bnT/gnf1XwsSjuM3CXFDcBOETDrsVASGRy5aUJhhjwcIiY3Il4bIRjEsxF8KEBj67tL1ub4FXBSQmZFRMRDkExRd0DQJQurr8tr5A/SQ/mq+BRdhDpVqCw6tE7o5czACLC6f1vEj//5dsY+O8F1fsuhJwGBxcEtGY3bQ5GJJ1zxOFmwnh7QD6MXooS2rKiVQZ3E/5Y73+ZMFmajSHDwz7AuyAVDf+VdpOf+p+j4KRb5d3VZw8PuSgnuI+/mSpLxR6M4iw+ip6k0X0HHiBRrnp4vYq0urb5MmrlfbvwKaWB+UpboLLPAbL3tdwViQQxJYDC3tsv57YP305nxvNzxeOTKdQsmIKuZhQegpkUOerO7OTG6LWis1Frh4GQEyBs7IXW1QexFdKLPaDdKwIhL5XtNR6zodkI9uspWAjrYQTGbFVHTnb4LifG+xPj+0fG+0fGWu37ihA02NoxpwE/+yLhT/7oFb76+g63rw+mZ1/s4MvTgDTNCDmbwQgRcbCgVS4CJYVSR0jANCWQKtrSUNYGphVTMlq0EiGFhBRMCQhWUBDDoLEj2+a06+zb2iyynBXS7eRjVdu1q7nyjqWjf1jxzceK09Lx598X/OlfFXxfFA9R8WoADilgcD5ijuZInAdTCFY2G3CMwYaAAaAcMSXGAzoSMcauOLNhw09ie/2qxgRsIDwrcFDCjei+GQikkHiJCe7udwhXn8ct+2DLZNiGj1f1LF1/jtNO/1aJqOWWOv0HLHpkhXP9Fa0wWBvGIUDJ1y3ziMPdEePdEXF2vX7vqOeOcrbacpgGxHxZ+4mXW+JMt/3JIbUSmYKvb33az/0C8NzcGsL7At9Y/G5IUtrDMnv3dBw3udiIu+37+i1WOWq16X9MrvNX79kvYqCN0P5jnQLR5kcnT/SRFw9/79ZjpiEgObWoc0MtFcsiWGAP6oePBY8fFpwWE9KMQ7LsOzXBUE7N5NXktxsTuBu8VNSAqik54FIUtZuRp3W1CqHWnVB8nfKTolUMMRBuDsA0pB33baWjHSqk5sA7F4H2gnXteFwESzWXGrmCMKVoKklRvL0P+ONfPeAP/8Zb3Lx5QD7OgCpyXSHNXndK2bMQdH89BREaMuIIjMHwYRSzq9rs61deELJFxUMVMWbknK2kF3Yl3bbeJlAkVLYMh+AzAWWBFIZ09XbA0OWvSBFODX/xV2f8879a8d0q+GYRPPnD/3oAPj8mHIdg/gEPGh2HgDRYJbrJjosYiLT5uhQpII8RNwACMQYyV+AxKJ6F8J7tECC/Dp8FWF3aO4lBTNQzDZp4wOjvMB23kBAnUb3kBkQCxsfnskuCX3oBugStMlGyjeNGhW6dIdQwh8lAHg83ONwfMd7dIh9nxDxZ/1kXtPOCVhpiSkh5uERaqbnPTI5rvb9q+IRrnWx+qs37e/ZWwL30bGUsxJ17TqmR7gEZjVGr7j3vBe7Jjg5z09G209KtttpUei9XferU3JSsZ7x29lmCT/CUWhNnBLHEmegJtGZIZCgDde3g3vH41PH0JDidjWZblo7n5xW1GGk4J8I42F69dsOJ58EqCWd8eB5cgFJAipfX0FZ/ljy0VkWtHbUWQARDJtyManZif7mHRJhHK++Pswd3sLkM16pYq5OAOuN8bmZaqWwHi1wfgj5scqfhQILP3xzw7vMjbt7cYri7RcgZ0tlgpSm5mpIg3V4XqII6oMiIaULMAGPBaek4V3U7czUiM3fUZUVMYWcRkqOBCK4E7TZ6z6JQzw9kUQwe36WVEQqDqjnzIMAYAiZV/PZjxT/77Yr/89uGRzaZ8M9G4LMx4M0c8e42IUfC0hUcg1mo3elX2eYePZj+IkBBLOCVwR6SEmbCGGwV3JxlmNnWhXUHjFrqclELIyXyXEmxYZ+oHQjkeYT7e3END325DaAAHHqXd999rPnmjUmC00Uh12ltNay9UE4ZqhGt2Q2RAyGkGYfpgNv7I46v7zG/ukGcJ1CeTJ/fGX3paGv3XaUZfDaktHQFqINrRUgZicjMRDH5YAoX0BHhagPgo2ruUK7Q3tzOa2DRunTUwhcuHtOVKvDikYc//AgBQcRCF0O8+tpbJPlLg48JZex85T1cEg4ttenLluO3rdE2GEjvjPVU7LZRxboKnp47zqduGQqqVqV0QfZWKSarFmJQNP9Zrtbe+wqPyAagHdk3CcbYawzU0lBbBztB6HjIeLhPuL+xct6ipe1QGMeMQ7bb9VwYZa0WEBqwm49qZZzODadV9gf/01KI1UJOhRn3M+HtqwnHm9H0HcE1HQyoewtEOmrrQLfth3KDUkIeB6PvcEVfTlieTlAkxCTe5xtqXHrF8mSinVZM/addzBQDRVvNkNajAUsKATHbYd67oC4d+txskZ4DhhRxhOB06vizbwv++Q+MRYGHCLwbFX94G/F6jrgdI+YxYFXb10/m3DFrbhf710/FIIrYBSiWG8kg6GTr3zRFG5A3BouV7KuYB+Hsw8EN+fUpM5DUVoCZrjUCdijI1YN/HV3AVtO+7oy/t6j+HzeGMrwcAD/85Z/n549//XlZ1zHH5KsYNijklDDOE27vDjje32C8PSIdZoR8Cdfgyvbwiw3+UgpXD/QGu3BaTSbEIdiaBSba0S4Amq+d3dZ7zevvDdobuFYv7RW92r+tOhmNgpe4G1ufXlxTqo6l2jIAd5tvuGL74Wq/v631gBh1Nw2xbxe2ZLH9AHCjhhlRGB/eL1hOzZJtu6BWRSkN7DOQTa04zuP+sxKMUksAerMNQd8cTVfDhxAsPHVZxeYQ/sbLpnN3CfJxznj3OuPhPmAe3bsfCccxYJ6yPRCNsZRqqPbgzHlbOFuGQDU6Tu12q6Wol1lHBIZoZXzrNoQ6zBEPDxPG44SY0ybl8IffX9toIFGEzY7dQclbL21o5YTT+0cspwXzzWE3xVAMSETovaCVvqs61a23XE2M1EUR2QI+WxNwIouYGwJqNehHeWoAC25vMo4zIRPw6/cF//dvK84M/HwivBsJ724iPrvNmJK3ssFnNL6qUwUCC4ZugBf1r99ZUZtbgL0/167Q6NVKCqb3Z8VQGPfJY84ZWEBgNwVdY8rDRhkmF/7oJWpEPyFSbgDRTRykilcs+M9F9L9zNgDSP/xf/ntbBf3w62Om5e906J34TZaS6bfHecTtwxHT7QHj3YR8GEEp7qGayg1cCqQzQooWA+W3rTHz3TkHtZWge+lNsdctuSY44x9bzJd7+XuxG78ukNZsHuFKL/EyL8Dy9MhHBSIMku2Gd4psiPb3BbPYBgdzqCpSSr6+06vBm7qjj3YjEHlIxZbKY62Ji4NYUFfrtVlssHd6blDPvK/bnwvBmAchQIKgt/6CYKuw9Vx3avDW++Nq+su9oZaGZRW05hz+0ab1IMVaIp7DCNKM+9uAmyOQgoDZVpXJCU3zPPoqD2CKu4aMfOAYg8dox4ycATk3tGa+j5yAV0fF27uAaQhYW8DH547nk+L2NuPuYUY+zqA0QTFAYAEyRObtCKJIke2/iUCt/rd1aK/gtUIYSDlhPowAK1pdnPZkZqNeGRIIaczwES9q8JwEVcRmSczsu/Mgdtm01fDlRcz5GcnAnU/PHf/6u4pvz4K/eRfw9SHgbgy4mxPjAZJ1AAAgAElEQVSmMaJ5CvPmH4t+cVWHhHJlnIpJuNkDb4pXfzkGB5YIqNqf70qQRHv40rylMUMRPUJvwUXfr7AI8eBPefW9FtnWFB4ubY7OTSq8zbtsmjWI4rUjsrxSz4kAJG7rIZD8yZDCMQcgZ6BHU5kd7g44vpkxHCakw4QwpKtbViFtAS8rlBUx+cPtN3BMYTfnUNgQSxHSFYEthDKIOuSTdjsuKNjDxRXSKnot9uC3TT7l/ntspodNLuz6ea9MrMW4QErhQp2csyO39CrNR8DcXeJ70Qps0M+t/1Yx2m0akq+PjJhzPpt0t1bB+Wxkm5gjxGcKRMA0ph0s0hrADS+0CFuAZm+G8bJ4c94NRZ2BujYsS0HthHEAPnsT8XBnt2tZGe8/MGqNyDlhnmzIWh3SOWSzak/zgGEwtFsMl7mCUYoZIZhBJ2dCShGVzRBhvafi8zvCL3824Yt3M3KOOJ0avvluwbffC+7vBhxuZ8RsUe3AgBA9LVhxPa4CUUSMA0AF3BiMtkNfpuMRI2ZMhwn1XGFLM3/7Pal4HDPGabCMvhhwcGv0UrppCrYU5tLRFsbHU8fzczMXoKs7RYHnp4Z//e2Cf/VtxdcHwt98k3E/ms4iRbKHX+1rKtvNLN1AH6X7Grcynitb9eHekq7q9nF3YW5Icw8cEYk2yCNCmCIOouhqg8woZs4670hz2mi/O/Zy8/uSk4L2qHG14eHmObmI5vEiVC5tA8TTWcPz45oTS4iBME8DGAF5HjAeZ6R5RJwSKEUHf0RozIB0SFnRSrMbzh94OIIacJotC2IeEIcA9kQW+A5dmaCtQ4KvBsno6doFXM1KLFuum4eDAuI5aUCARZBfACAbZNOENwjR12gep5UUadgIQRf+/iY93sAem5CHZWszFAH2depS0auJgraefi12UDT/nkPy9kh03w4kp8tuyUqinwRFSQcpI+cA2hOFzCVXm6CWBjAjRcLtkfDlu4TP342IOWIpjMfHFU9PJvMdXEPVO6H1gGkQvL4LuD9mHGdjLRAEFU4IEgexQBCUDJgxWF//sZuTbh6BP3yX8Ce/PODrr29xez+CKGI9dRxvTni4zbh/M2E6DjuT0KbSF5aYNJvhGA3pwkGULhDqfnlkpMMtQjT8rkizVWFQRHUWQowYUkZCRAeDUkTyIR8To0cvzxNBV6A8V8jaUdUGezUGaGOsC/Db54p/+psC7oJfvR4MN+bE3uh0aGEBsbkfF58ji6sVxdvAHI1POOWAmAKWZjgxEdhqUwnVw0rFg0u72+oRA0JQDIFx8LXfooTF8wgj6R41zldpQXGX1F/yILbDIWLTq/yoPPgyAyhFdTnVdjtCKEXEw4AxZsQhIk5G5zVMFQNqJ7sKoFzRqzn+1KfqhGBXlcs4e+kQdV5guiTWhGBYbFUFlw04MYAsOxrSLW5qe5A3+TDIXHbc7eEIakBLSyqjPSI8pYicbe1DMZvbCh0hCgIJmoRdIGQ/R9+twxrCHuVVVkZZG2IKBscsJtEV6RY6uZrmgL0Cyjk6Et0SjTZwZiCyOC1RtNLQqyUsxRiRcrR1JgVbb5HdMK2x95GGMR+i4O5+wOvXCe9eZ7x+GDDmgHVpCLriDOMUDDlgyD4lborzuSJoxzQccHMckIcMVkJfC+paUEt3XinvvYgxHxS9MnoXJBL8/F3C3/rjW/zhL1/h/rNbxNGYjXMFxrsnvH53Rp4Jw3G0ts670K0jVW2QXsCtgnsB92ZE5m4XBjvTjhAtSDQwai9oAsQ0YAwC9G7vqYNhTKtRbbuzvcZ7NsCWKWgQVArbBN5q6/OZ8VQZ336saJXxB7fG+2tdfDdvJChSQJunMovzBQmYEmEMAT0qjpNj3sncgY2AUAVpjHaDw1rI1gSBbWAY2DIdCPZ+cyBIjhY/7o7QogEnvaz6gm8IZEsFvtLJiX6yst4IQX74/B4qsCJSoCFnynlAGgaM/kFJU9rLc3visll3pYHLinpu4KZGZ7G9mCXA1A6thN4YeRx8wOOggnjBaovfmAryb9bI6Z09/iglKGQHV3JltFLBLscViJteXFoabKg3jvYh0t1vpXtWYWDj4NlKT9Fbx1oMpRiDgjRAlFCr4vS8oldDoLXasSyK87pJd+3Bh68Lb26s2liLizS8vG6eRS9uMOLOuzQ45YgcLQiDiJCCDRyXtWNZGnrvGDPjzesJX3414927GXd3GdOUQUropWGQBVOpxrJv5ipjUfTVBo+tFox3hNvjgDwOxt7jjnVZ8fy8gpsLmsTWkSBgyIQEwWNnlCp4+xDxN//GHX7xx5/h7rMHjPc3CMMEitlmKccDZF1AofuqjwEptrHwFa+BTyt6OVsVxc3VkrSLpVQd1OmGLBUFYkAOIyI6ihQbntk7Cu0dvTaTfBOh+hCOVEHs25oYkA8JWXR/iBKA9qR4KoxEhF8+ZNzNEUMgX4da1rYpSa303/4ZnAI8+TC7y1VsmgKVyA6AIWBQy2cQKEJT5Co2JGyMWBjUbfqPxpAYoDEgk2DohLukOLvsr7jfn8iCfvSaxuQrgy0QBVdRGqqXquEnD4AYOA5TvJ0Oc5ymjHHOmG4Gs/CmuDccu0Q32H6914K+tH1zl/zXl2ra+ZhskLZF+qlYEEZKm90WHg9tk/1YG0R9HRcIQsmUfSCb8JZqaj+5xDEHd+9tDz8F86PHFHehiaitm1qHI8S2YMsACtGkvT5JJzcRcRecT4ZAq1W9N7ZTvDsVCEqYpmC49OB23C1r3qfzIVg70xqbbdhjuVOOSMQIYTvcuvf5jPMqeD7ZvfHmVcTPvpjx5c/u8erdHQ6zPUzc1fiAarbqmAJEA0rzgWapbkhiHCfBF++OuH99QBgGtLWhlwVrqQAZG69KRy2e3hSD9bVrx9OznZS/+vkRv/jjt3j4+i2GuwfE6Wi6CrJDNqQBUmxYK62B2wqV1T+NcQ9k7WVFWc4opw4lRRoTYvYMCFLIavMeygGaA7gLUkyOTehQjqAUEf1m32qBKLjElLO4x8St4WSKwltmRFXU6NmFTxH1qWMaAsZgqr7u1KkoZl4LwT4Xi/ftCcA42nbMEugIJCYEM7is0XslB2j0iT05ycrSTEBKiImgRLYiFwXWZpdaAiQSeiQMrLgPYi5SJfj8EBkmYe5+4Gy3vuAiDd6UtJsm4PfmAgThlEN4GMYhD/OI4TDY0G+erTXlZgMpp/RCO6Q3m9a2ZvLdPTTSI61g5VZI9gYDYuYf5/hT9PJbjGfHK3brbUjJBoh0+ea1M3pbPZU4AZRsHRMDQnSOIC6WYWW2W7CTrUKkGygjbLcRI6TsugFGIpOF9tZxWoDWBMvZbvgNMmMLCjK1n9o84jCZ6aaz+ey3hFvj2G8QEhO86NYaZDNIZbIdful2cwub0GZZG8aB8PVXI/7gywlv3064eTgijhNaaShLAZcOcLWDjBtqsSEkC9BqQ6aC4yQ4HjM+ez3hy6/ucbi9AUCoUlCKQBFxd2evx3dPDU3Vbiu1FJynpePDU8W7VxN+8csHvPrqDcb7e3v40+TbRkth2vwd6LY14cb2uaEA5U0PYf79Vipa7YjZQmYoEEgFWhvq8xm8FuCYoTpCNFicXLTMiJAGjJPJwcmv3CESOFQ7XKugVt4xX11MynxU38mzIE0J0aWR4uOXfiWR3RYvYzIJ9OJS+CEAcw7IxwQdku39N1FZF6AKgqjRPrrpJmSbe/nFohuGjIxajKBIqhCOoJVtFhJseBwScFRBhRr737dO2PMdbM23/QxEF1MSy0VPID8Br79UAFDKgcYhhxCnhDQOiMMEyuNVjn0GwujMtwopK6S2PaZUVfdMvRQvUVwhBuf8X1t1HSpSO8p5xboqVIORZxLtOfFE1jPDo7FYGRoJiaLFQXVvX4LJPk3nzpBu2fCtWQTXdSQ1ycYqsLWKVV8M8Sy6p2fBx0dxgcalehGb0dkLF62+ihZ4jNYdsrEl2Habc3S214R93TlExjiSb0JMmF8boVTBUmSPHz8eIn7+9Yhf/MGEhzvL8muVUcoJ56czylrAzfL5RGBCoHMx34JUHMeKd68S3ryacDwMuL8f8PDmDnEYwf7wlarIw4hpDFjOC8rCWBeFOKexrh3vHy2y/A++vsHnP3uN8fYGFDOECeBqLUNvkHqCdNdxqH0+tC5W8Q02GJbaDVmhxkxMoRsIdDNNlYb1ecHj+wXEDXkQIAGqxjGIlExEkyMCZRPSBAJag6hgrQRu9n0v5w5KZCV1IAyBkIvgL79f8XhmfPHKgmh56YhqMA915FcUe1gjkas8DdWVCZiHgOGQoVMEi4WkUrcIYaqC6K5GroLGFrIap2g4Dk8R4mbzA/bqQDZX32jbKKpivy+bjDl2YCDFTAQORgOu7g7sbvgJdAWkdSbBLgy6yhb8yQMgRYIMATkHpDEgjglhGIzLJ2zhH9EADSCYo20tECbEnI1gC4uS4m4HRnBNPDbar8R93aauoKunguV5RZeIPAyI0csi9TchBKPhNnu6NASklJBCdGmsQH1NFrc+XwXcgN6sHIdDOlU9kVcspHKe4EMkoNWO51PD6SR4PivWCk82tge8NjtMiHw45nqbDY9Wm+4+fe5WaWxR3iEShjyYtTo3jKOl3q69Yi0dpxU4LSazBSnujgF/9IsZv/jDA25vElplfPxw3pkG62qGmrBxB1ncgmzzi3evA969OuCLdwdMo6G358OIYZ5BIZoQZrV2YxzMnvz0XPH4ZJuMGg0V/nxmfDwJvvz8Fr/45Rvcvb1z845Cqh/+WqFcwcszeiu+ak22uekdMU2gkD2LkZHH7BovMYy1NFAfjPG3NDx/LFhLx+EmgfIIAdDKilYEI2ccDjMomqMwBkIUW5mePq54frYD8PlsfMRpSIjJ5kpjDEAhfPtY8dvvKiKMDryugoEuwA2OYR+k5cHe485WYQxztKDbIdpFszZItbK/NpvoKytWNs5g7WLi+2YhsiBnUopCo/eung3GouBIwBARGSYdhmeYxYDAgjEYk3El8rhyf/i3h9tv/+zjur7Hi9MeGPrTB0AIkDgiDgOGKSMOAyhPoDBAo92ato+2JJm+FNSlgyUgzdk0SqKGfGaxKTrD6b8JQDS6TjBLrzCDW0Mv9mCbLNUljC4dI/F+zpHaptO39sHAiBsXQNB7gPTgWCSGwIi6hvIiaHCBjwhaJ/QeMA7Wp6+l4fnEOJ2ApxOhVCsZY7CKolbDh7fOmCbDn4nYmi0Gw0eXKiirrUKFrdef5ox5tu85BsvV2xyQ3DvWteH5LDit9gECFLcz4edfZfzi/2PsXZYszc40rWed/sM++iEyUsqUVFQ3tMENcAUwgQmGGZfIFYAxgAkTBswwY8CANuuiKUmljIxw9733f1hnBt/6t3umVNXILE1mESmXh8dea32H933eP+x5eNpRUuR2m3l9mcg5i4NPKayxWCuuSVmTZmzNfP6kGAbL49Oe3b5nmVaul5Vea5RFRFshtI1CosTE29Xzl68r89pK4iSX0TQndjvH3//rR77//TNuN9xBG3mN5PXWNtSZHGWLoprZoNSK0h2mP6CtIV3eqCHQ7R1VQVwi17eV3oEdhesXYyTmwHg07B8GVGfJITItgXWOnEvCVk3tZG1mNaQl8PrTjT/98cqySqpPliRNGdoZGU7bThNukvN33luo8DYnVIVx0KhcKVlRjGoOTuiMzK8sMHQa12miNcQCfo6kRdKUY4U11RaYUlm8BIBuA98UG4uhmXyKAmzbqhnV0oFo50PW1VnJtqDSvgejGWphVYqu/rKk/2X2dYOEtIF7Rv2L0eP3C6B3BjP0dPsO2/fobkDbQdBVJlEbIUdUeWsbxlW0Bduru1HPJJls51woKJwW5n1JgRIzxnagLKlhr2opWKexzTosKG+R7OaK7IELraIwVGPa4W+k3CYBy7EQsn8fPJr3VxrEYhuibhr9KhdZNqw+M021gSRlUi+iDVnLbPvfLTjDGUXn3vFMPoi+3/t8jwvvesthLyTcTZJccmHxkZAyIWWxAE8JH1p5aSVV+fMny4+/7SWCLWnWW2S6ztRa2R9G6XXLRzSawEazVlgHjw+aw8OOfjdSSmWagmxYcqKEQImJ7BeS9/g1MK+Zn14SL9fSPjiFnCJOFX78zvLDj4/8q//4e3bnfctnFF9HiZ6aFkGx02YstsPYrRoUrYjt+2bwehc6hTXy8tONb1+ufPrNkbPTLc05Y7rK/tTRjV0LOinEGfIKqQaWWCmdYOVDyoSr58sfr/z080pCaMLdzkoZvmY6Jbt5oxVrFhvvbmek+kyFfWforaYzgqgL7eXcjYbBaZkZNcdnrpsFu+CnRNx6/3bw0iY9btVZp2XnP0dZRcpDK2Rfcptf9AaMwEDZwj2swnWa7AshFqoVw5HTmtFvMwt1/37rRppqCsANDpp/lRpcfmUM3i4AC6i+07i9odtJ2IdQWawQB6TbuOvySwySYEuVYZZR5JwhFypJFMLNb77ZgPMaRdo6OKG15LY+a9z/UqUULyWLuKhoYtbonH/BQdu4/5vPeRsoipquJdXIQlQ0AErKbb8mlrWtBEtB68q0GEpNLHMkZcXshRK7+aj5gBrfzDrS5si9G9qQcJ4DISTG0XLYGfrBMQ6azjVbchFb7rQU5lkm/KsX1BeqsusVh52o9p4eNIe9haJYlpXpshBT5nTa8/B8RivVZgDhjvq2CpIyWG3YnTqG4w6lNfEmE3mtKtln/CSajW8vC//0Tzcut0TMsrc+7eRFNWg649gfOp6/P/Ppd99x+u6McVr8Gko3YGkUybWSz4kyCqO16C2MsG9lHyUTUe0MVTlyjIRppubM4dizP/ZooyS+TIHpLG5wEg6yBNa3hXgNoslQhVg8Mckj4F9Wbl8XLm+BkEFZwWPbJI9PqRWdZc6jfCKvidGK9PdtlTb14egYbGtdsyQlGZqQR6tGRN7oUSIIi6to/o0SEtBGzw7xXQrslKIa+f3UbMEbFqMoWduZWO5+ACVJadLQGo3qLa5IcnPK8qgZoxiKyPxUQ4LlIkyB7VLYRHap/nVicPngEfjrIWCHYJDcBrC0d3JQSWLNRfHuyEviNdZGDlSKSRByRYZxRmuMa1Sc9IFwGrPEIMVMTRItnjKoHEgNf6WoaNehN3NPkwuntjuvWssNyBYoIoPGzR65laNaS9CGXzPrkohR8gWVkirgdovkXPFrZPaKeZGSre8dztoPL2zF6ELMWkp9L2iwGDLrGogx0/WGxwfHw7Fxh3LCV92IPiITvly3Vz/fpcH7QfH86NgNtpF2RTIbQmC+zYQQ2e/3nJ/PjMeRHMEsAaUj1lp6J6m2sbTVnzbyMvjAfF1E6us6Kop1jry+zfzDH6+8vqyM+4HffB55ejB0ppCTwljHMHQMhx37pwPDeZTDG1ucerNPUwto29x+HTpvXAYjgpMizs8aM8oqtDMkDDEFKpWn3xyaMtS0YA5ZNYr/RKNS5vbiefm6ME8B23UMtg2IkeHx9LJwefOo3vK870QY1tauvRFYh3FG0nfnSJjkEbqslduS+fTQ8Xh09wCZkDI+1/tr7hsnYNQtwLPJvLWCfa9ZU2WKhTUV5lCYQsFnEad5JLlDq/cY71zBZ+5gnTEXbG7O1PYZr0UGh8UolNUoLxdIzhWsQneaHoEBVCUux4848FzVh3TM//B/7D/7O/XDyLtsGXYyyc1rpjSxiW5JOTlHwGK0lQOsFNq0bDpVsc6IiDAlUlbtUlEyIZcnVfDRMWGNxg0bi6D1Tm29KF9XSnKZ2IqcVuWK2W7bJeOjwnhhD8yz9P0g5hBl5NDHGMhFs6yZmASoMfaK3R6GQQjBuWhBi8XC6t8jwcIaSLngfcJZxafHns+fOpwt3KbKugSBay5RwlECzEs7/EhuYu/g4Wg47u0HvUIVH0GV/MVhHDg+HhkP8gMpWRh5xhr2x55x34k2YU0s14UcM+u0Mi9tEq4dQw+kxLfXmT/+8ZV5Wvndjwd+/LsnHj8dGEYr8eTZoF2P6R2m7zG9RRFauS/ItpoFwa40GGUxzoLu5EOchXNILWS/Mn27UCsMxx636zHWEWLGuIHh3KGsQDxyiGzJ6a43GG1Yr57Lq8cnhe46uhHsoKEXfbPKhd3oGHYdx8eBfrAsc2D1UiGaZpBxTqLrlAIfM69T5m1JDJ3hN48dfae5TYKo33r2zokAycdyD1tdQ5YsxVQZuq06yLwuiSkU4QAoifqOG2Owzfk2rYoEkMhh72vFxopRYtStTstsIFdIhdJi85wT/Utuq8Ha5gamiBhpbNuL0FSU7/nO6m8U/P/SBdAe+c3dBumOqxbOabkrroJPxFBwvSSZURr4UznpR0v7kKAaoknmkDlXGfxtpSSK6BMl52YiErOD2TTNlOZO1bQpCbXdqCIllvFtjEWy66sM5F6vijVo8QdUwWMbszHyIkorLjdZu4ERzPWoOZ0su9FiraLWIE6vqFjWjA+NZGR1KwXTXdb7eHB8ejIMg2JdFfMcuLx5Xm/yYtgt9aw5CjurOe2EVLvfix7Ar3LJvKlCioFh0ByOe86f5OXXWpPCKtP3nCQS+9gz7KVXTkG4/zlE+XpBpNnjYDGq8Dqt/OnPb0y3hd//7oH/6F9/z9MPj7jjXjY9VZi2IvISrBYlkVcRG9UUG3G5oA1oYyhZifpSWZRBHH85kYNnvVz5+Z9eWH3h+x8feBwFHGt1h7YG20vbposoRuMcyDmz73YY60gRNImHk0EPlq6D/WjJRjiN2mpOzmCdpt93kuzjFN0cWUIWc02zNeuYmabI25z56RrxqfDp3GGNwmfwSQ5wyNvwT93Bm2Mv/o01iKakIvkBqVS+3CKvi0SaDUbjjCY1Trf+UGdLwq/gun0j/lAQEAkFZ6Syqm3XrFs+QnUG4wpdRAhAsTZEhszVXJVYsahUE0SJ4lCEg1UGjv+BS8C25l5rranKUEsL+syt76+R2sqzmjMlZErbP6O65jZSuM7eARuapnoqRaKLlNB7YiykEMS/blyDedZfRntVQVgrKrq21V+2qFIwrf8PtRBzIWQpzdaW/1aKZl4t11ndQZ5i4VV388XWUoQoOvehyxz2HYej5bDv0MaQYsAvkTVU5rngg5RgXadxRgY72x079Irz0dDZyjwFLtfK5RKYF1HVAewGxThovIfFF4bBctqrJqjKhBbFvSyB5AtGG85Pj5w/P3N4PAgUM0vLJNVVk+k68T+HaeXycuP19QIp4ZoC0lmFToHXq+ff/XFmniI//v6Jv/83P/L4W1Hz6X7XVCXpjlmXNm+lBE/2Mjjkzki4u04gZ2qxjfAUyOsi8t7Vc31Zefm24mPh+XOmYtGmo9tLwk/NnjzPpHnB3yLee2xnGfZ7TCein3FvGUZD7SydVgyDo2gZzioD9JakZQ+xBjFkpVJl4NYivmqWbcvP3zyvSybVymmU2DEfCpckGxwJS62ScNwizwqy8tW6EZALTG1WEJIM9yS5R9MZfVfgyXZP+v/yK5CLbpN5X5Vka1B5SEXAIZtrtVRUKuJWvDtQ5fxgNM5yz79USNqQbdHhtVYBhVb5dbVl/vxqIPjXa0BnUJ1Fm3r34ctXFPacrH8iJST5BlGoaoTX79pEs3kTlXqXJ4ryica2F292RcklUesd5SS77ObHR8IwY/KyXikRVWj+fKgxsSyJ6yT9eEWmtBXHvErprpUoACULzjKvWS4FYzFaMXZwOmj2Oyuyzq4p94JnmVZuc2VawPuMs5rD3jAMcmHFJLdw12s6J5CGy1tkWhOLF9qu0pZxlL+8/a6y2xmcTTgnF4lpJqF5SaIxCB5dPbuz5fnzE59++Mzx+QHTO1QNv8KaV2pM5NWTlsr8OjG9XJmnhVJyk9RqeqN4C5E//bTwcqv83e9P/Kv/7Eeefvwetz+hup2o9NJCCZNQeXKC4ikpUpM49CSUtImxmi1ZLniJbS8pEKcr69uFsCTZy08BpTXHU0fXdxjXobsdWmcgcnuZeP3TG2ERqXC/sxyeHxjOO6IPVFVQncEMHcoa+g2MWSu5CAdBaUnIFTbEu4nJZOFD+DVznSJxzbzNmVRh3xme9hanFeua8T4TsoA6DDB0oi/IId3FayIug1vI3NZCpwWqcuwMfctHL7Xik4h/ttnR2nb+nRb3ofBy3vv1gkJlOKZKX6oMQ7UcVAneqXdJPI1rEFtQqGlhvIp3NNh2yEN5twubX5At/wUzkO1A9dK315ooKQh9pH3wainE1ROTv1sfhdxb20rqg6W1qg/W2i0mTMwT93tJqTv/P5VEzIlaNFYbYoiSLeAjoenIbakMnRF3Xcj4OfH2Jn35MOj75FkhOXoyoIOUDUkZAXYCu044eLtRcTpaXGfuazq/LqxrZl4kfCNnGSidjpbzWazPl2siJTHwyHRYhEO3qZCqxeiK1RnbQY8mZZniLku6f0BjyHcc+LIEQigMXeT5uefHP3zi+z98z/H5CeNce5Vr49wnkg94HyUvIBc0ihQTfac5jB3TsnJdvaw6I0y3xBLghx/P/P2/+Y6nHz7hjieUHiBHSpzI/kpeJrJvcl7dhpR8yFrMmTivJJ9R1spwrZdwgDAnbl8vhGnBWiMXtoZP3+0ZR8cwymZJW6gpsry88vX//Zmf/nxlHB1P342cvntg93xCqUq4zvh5RVuNceZOc1qnyDQnoSzFxDBY7M7hnKHvDNVqPIE0R/ySWJYs6solyeuuFH2vsVZapJRk6i8ZFIrBanqn0W11WPV7Or1Pm1Kz0HUCBR2sYgmVkAs+NfltkxSnith46zumOzQvwUbqyVWRqoBBu4IkT1stoqgs8yqjZRhIc77GZlDq2vCvNIq10+9QmdLmAoJq+/85A1BGBnpbFLdAD+Ld4pRjFodflF5YG4V2BUVuq7j3NDJBdItLSpvcXvf3lWDKtKANCcxI1RNqRGcHGR7+Fd4AACAASURBVFJJ+JjwPqGNBS3UlVoqziimNTOtYuqxVjLclBIWXgpS0k2TxFShe6pJaBKH0XI6SNne9WLbraXiQ2ZetyFdwVnDfie9Zq1wPIhE+TIl3q4SveicISdIJROi4M+6Tv7RyArSWknzCT4zBRmMSvWQcQ1dHvzK2Fd+/PHAb//wxNP337F/esD0favEVmr0xGlhvc4s08qyeFIp1Nyx3w/sTiP6YWQ3rwxvE+btxtvNs6yJcdfzw+/3/PCHTzz/8IjbH0TcVQo1TZTllThdSUugtPTj0rIVTIu8KSkTlsDlZSaHwOHYMzzscLuOWiLz241lWujHjnE0+GvmdB7YnwaMES9ILZG8RNbLjZd//ML1p1dc53j+4cjj9yf64wEULC8Xvv3jz6xz5Om3e4axJ4XI+ub5+mXip7/MzJP03U8PPb//+zPjoUMrSw6ZdFlJU2S9RnyqLeWnrYWtQhVNRHFZi2xINr1/b+iMYnDy9260KEE7o/G5SEtQZHirjGrYMQhF2g6tYbSGUjMXL0rALbJrzfLih6bcK02/75R8VmLLbtAfDHWb4Uwb0Z7EFvW9SdJjaZM53UJtW/COKVLJlC0duV0C5UNewN+8AHKbgNraKDqVNgeQ6XQK8c6wU4DuROr7EUW6DRBrS+IVpp6w1nOR0jBGyFmjtVhflQVURiNmni0HAF2wVmGQfn4OipA0ViWmpbBGg7MCLQVY1nKn7cYowRepKJTOmLLSd5XDKMYdsJQi0WerL7xdItepkKuU9E+nysMZrlcISaqg6Rr4+i2yBDgMDbFVLNqKqCgV1RgFMB4s55PB2UzXZeZZVowpZZwRyWbKYhCypvL9b/b8/u+/4/mHT/T7nfxcs6ckT1knwuyZX65Mrzeu15l5XZt6SzHuj+yeDujO0a+JYb9jdxw4XVfRJuw6Tk9H9uc9duipVctKLwVqvJGWibRG0fYroRPFIHObjSaTQ2a6RuYl09sGiTmMGNuxXmb81WN7w+FhuINghrGjO/QST1UKZb0RpsjblyvzZWX/sOfwmyfOn4+4vhc/xnxj+vKN6bLg9nvGww43OEiJW0jc3jxljnQKXtfC12vicygcagOBXj0v/zTx7Z/muxo1RrmATa6bIZGcCquXRODHnWGwCmc0tglygpce31kRW/kkqz6RhmtyhetaWEPm4guxpQB1Wt1f4E2VZ3UlVsWa1d3Pv7aqoFcfh4VNOl5lBnDv8ZU8zs16ssGw2p6/pQDrhta/7/nrvdxvkiwy9V/2AuQsqwa3SWdb+AZoARWkfN8KCrZvs9E26yXCj6tJHF+C7m6DmBqpxQsnv7gGJ2i0nir0Vp0N1M063OEcRJ3xi0hxU6rkkoVek8v9B+GDHFIf4HKr9+Rao8GZKgKTkiXFaNBYk/FR45dITPA2SRRXRclE2SqcKaRQmFfwUZGyVCOLr+wGzcPZ0DlpTQYrSPLboljmKOKSk+V4MuJxV4X9YElJLr6UZHV4nSpRJR4fB37/99/x9MN39McdikL2s3gtFsGsr5Nner1yvS1c5gQ5sesNw9DRH0fsfkRZh3YZ4zRu59g/SKKw6Qx2S2UuheIX0XaElThPZL8Ko8+KpNKoIsBOI27NGkXFN556+jYv2T3sMH2Pv0VuXydKKRxPe9xgmV8Ct1vEdJmkRAyWc5SZ4SLwj+PTnsOnA/tPD9ihJ3lPmmbC7UZcAvvTyP75QHfYUVNqEWyG47Hn0GmU1eynzNst8vPPs8jla+X1Hy/82//nwjxnhs6gtEisU5C/o5IFxBmbCnA3GE57iypNstvcm1Jh5nvs1uxFD9BZRdcuhC1ObE0tDlxLRJgvtSkq5XBbJYf1Y0zvduhLSwVK27Cwvm/gU5Fo9NpeeGU1Kv8K+90uANM2A7XlQtx5gNvvNxhI+RuuwPsFsE3tJaCjTT4+goVry4qMDSm4BX1sOX4ttlmSX0SpFINkr5WSm9JKoXTBmNoEI5qaIskXQsoooHMGqwTmsIbKt0sk18putNSS8FHitVOUF+ly24ItLQUrOXau0jeTTsqixlOUJsdV+DXgk2YJmmlJmDZh3tKLX6/S612nTCo0fmBlP2qeHx2Hg5Wdr6kcd2JbHm+VbxQezprvnizaWdYlYnpDdzA4J0PPdY28XYQBoJTltz+c+O7HR8bzCciE2431MpN9IK+CWvOr53L1XKbEbc6cB8PxJHh2d9ijbXcfnipjsH2H7a3kUNfW0pWWj6AilIC/zUwvCxQYD05mP6WirejmjROVZUkKO2pGraS3VzJ889eVt5+urLeF3Wmg6xx5zYQlEnPC3yrL1RNiIZXMftQcRtEuDMeB/rTDONFYpHkiXC74aaVUGI8ju/OI7pyQfgDXW8ZzD9mhncbtpQ1YpsiXdMPExE9/nvnTt0DSmkHLIVRBZOURsTlXLZFcaMXYa4F9lkpcEjmKiy62cJXrnPBBMXmphkojAeWW/bdBQJyWAd0U5eDZFn7btXJ9Ke++/dSGgBqBeuZa2W+4rpZYdOcH5trizgzGaWzIjXzwQapTJMVZ21b2/3U0+P9PHUB9R/G/J/DUD6k9VWS+LW2ErMm+klvijjGGmgt+FTGIqO2SSISBlAw5a5wTym1u8skSI9OaWWPGGYtWiZAr85L5y0vh50vi4Wx4OBqCF5HMZRKn2jJH1iC8gKHvMW2gZ7SswFRLv4mpEnzi24uiookxkZrU2Bo4Hkb2owwCb0vh6wQxBHJKOGcxDvYHx8PZsd9Z+fGoinIK1/d0HZTsUU+a5+eR0/OBgkNbccv1Q0ffywXprgshZkIM7HcDT5/ODIcjuhvI65X1unD96YW4eEIQYcvsC/MSWZZALbB72nF+PrN7PGP6XZNoe2oUNj61lbuqserz5tkvYq+OgeVtZXpb6YaeXZv/lNjKSN38+cZgrMPqTg7qEkmLZ70tXL9JmMnu1DMeOtLqST6gVOF0Hkmx4G8rS4ysoZDWgi49tnOkkqjzjEmCPffXG/E642dp73CZXAr4QAwRlWSCrzvJc1RK43Kl7zQxZMKacF78GElrslJcg7ShY/tgmyrimxSFGrRzmtHoBtbbEqsrSUnKkjVK1olZnHq6EaF9knlWbLgu1+pqn2Uab1pQx1oVoYkm5/b68oHjR4N67AzsLXffQNno0cgGK/hC37wAnVV0DfhZW+edi3AolG6XRnmPAPrlCrJdMP/cBbCpoNhw3R9jNXQLy3TiWjItuKDkTG6rIZXl1S+5yK2txf+sP9xGWot7L4VCKhFtNDXLDjYFUejNCb4tmS+vmdeb/P/mveZ6i9xuiS/fEi+3yuLf5cWd03SdUIpCfpdebjOIWmEJUNYkkMwMlSJKvIPlfMo4W2VPvyZqEqOSdZb9qHg8wens6Hrh9olkNeOsRRvX1qSZ8+PIw+cnhvMoqrbBQhW8mrGGkgS3Za8erTS73UB/PKC7neDVi9CIdBU09jR7bmsR33qMdDpzOA88f39m/3TCDgNoQ4kLxXvBpFdhKMg+P1NioWTdUplE2BVDZp4SKcOuN5huIxULv1FFBdUJ0FcDyeOnifVtIk4r820RI83TkfPzjlIy1y8rxhTGo8NoJ4nGA/Q7zcur5/J15k0kHnTVvxu2Ko0JmIglCZw0eObbJJ4MHzBRxDubVDhHUemlWqlGtCBzLCRgbH6AqX0OiqjG78J2Bew0PPaawWnCtgX4oO0QoKqixMZzKO8vvuz25ZyMRmNVlQePyq4FeU6IYSu0Xl1TGXTDiLWzMBgYtQS9Dp2o1MROXN5j0qrMsmwoGNus+m2IvoE+YrsoSpsPxCz0IdO2F1tatrqTk/6ZFiAleQHKtuttZoNa0n34Z40mqtwIT6VFFckOdcMdyxBQ5gU1CycPo9BaeqOSZZsgAw3RBqgswMVlLbzFymWq3JbaVHPC2P/2GrncMrMXDsDWRxkDQ+/oe9ey0z/2UvL6S4ZdC71sFt5cpE0Y+0JnI5VOwCFNCGO05jDAeV/Y70a6zpCiSKJPRyHsWieVUqkZYyyH84nxfMIOVvIOjMAZtLNNPBMx1khclAI3Otw4oF2HUg5te/r9jvooB0QNPYdSIUVSLLjecTiOHD890h33aKehrBQ/k5YAVXBrmCyWXS8HOsVK8onggyQKp8IyB4wxuE7JBWA0+EKYZtbF040dXe9kr+wj63Wm5ITRmv4gCVGHxz1WFa5fXgmL53CWF56NyWgs1VYOMaNLL7bcwWCtQRvaZararwt+rj8UrBa7uPdyGevWQlqjIIqpJ6RMP1oUsFwzc5IU4CdXmZDLYUHWZlToP3zgj1ZxGGQiOK9yKW979EzFanltfZR+P3/IFhBHX3O5SnIufQOFbv19r2X3H9q0vtPQa6kQnBG5sGvZmKnFisVYREbdqp2N5R8zTGth7GU70NlmQCqQWhUQRLSJ3uYChvtGYeMcxI2q9c9SgRMlxzKfas2UYkpWTfzRiDy1NkWUkHJMVb+0hzYoWUkyelBamHoha5HCKilP11X2r9bK5bKuhXkpvF0j01KJRVx3wyBqQh8rt0vkOskc033o7+X1t+wPht0oN+E2hU25ElNmWQUBth9gNyp2o9z66yr4pNWX1tdm1jUyzUEMIEPmuFMMQ5tQB5Es73eV487gmsFGYsE79rue4/ORbnCAmIVKrmBtA3eIjr7kjCqRvjcMxz12PKBMDziU7XCHvawJx55DkX67tMw92/do11J1Ow01kNeZOC+UWIWrZ+WOT6GwXiPzJLx9iiQ2r6t4CbRS2EFQarof0K4nrxDCC1//8iKcwMEKO6FUeqc4nDsO55H+eMadTlinCG+v5CXhnIh5tNbCaWgfPErhsHccTz2m73C7XnwhLWFpC301KIGNKE1Jkbh4rA/yAKWMDQlbM7UqrO14Omt0rfjLwls3y4EcDWlOvF0jNRRqEDiHabRdqQTkdK2N+bisSey+7QJQCmxzAqYiJb9CvbM7arPzIinAlUpvRQK8pCI8fiUv/Ibsci1EVoFoDax87azka8VYGltDyvhUfmkgilE+q0OnZPiM8Aeylglj3SqO9v13jQdo2gXwLw0E3isAZUMp5c+1Vl+pO9XgGaU2J1K7BFIL97SIZKnEQoxRIrTk3sE6J/JVAmEVtV/JiXWOzF689jKZrNzmxNe3zNs1kqulHwy7od71+l/fMuuaGXsh7mqtRFVYpLzveysVQCfrupwV01KZJpF2uk7z+UkGeN1g6DrNvEhIxrwUphk6lzmMNKpOaT9szTh2KO1EgkniuNd8enIcj7JOy1Vjh55x5+iPA93YU2tivU2EaUVpjRtHajFQm5BnldnCbjcwHk+YbmSLNLqbbDrXtiwtyRbNpkpR2gh0o0TyshCnRfpra9BO5MU5QpgCyy0QY8UYQ9cZIRWljDaKcecYdo5u36PdIH4ANcuKKclQVuzaiv3ecTqNDMeOYd+LOk8JIj0uK7Vk3Cgq0pIlu5EWra6tabkSI3Z3xPT9e1YgFUVqQ2TXYCKa7ANuNzHkdnHFdmmVQsGgnBHlZwyEtwvDaNkNhjhH/DWQjSJdI1oXbmsmJzkIWSl0rVxj4Ya0ujpX+gb23IZzm6/fl8qaKlZXnNbtAtgOab23JVqJECe3XV3f1napbQS2bIkKqFzwWSoDo0HFwi1K62u2JI1NPNRal4L4CGIbXlonl8rWCuhchUL8oce/SwPUO078n5MCV6BobSJKfyPXQK07qlB4YoMYEkUNlqP8pSqFJLuWRGmqv+2D7KzFuhYwmaPsLKP0skYrSixc18y8Zi63cH/dx51m7AuqZKa58vU1s/jKw8Hw+cmyGyW19uUi91HfKXZDEUcVSpxrqRC8wodI1zt+97nj+2cjL0ujGY9oSoZlrYw9/O63PQ+PHZdLICbP5SrfZ23G7UpiHCrffdrz/N0RNwzEKKWb7QdsL0yE5ANxXZjeLqQlYftOZhzGCo4sFuK8YpRidz7QjaLDr3FtASoLNaW7iksZ2jBOsA2SchxFR+8jcVoEDKpaH68VySfW68r8OlFTZhzEfKPvEeKCduv3jm5nheakMjUu1OxRCHjk1BnGUbiLxhi0Ff7+fFvRa8Z2F2pJhHkBK0acnHPrYYvItl1HdxjoDw/Y8YDuDiJ3u4ehFJSK1KplPdzk4ZQVozS2CmxEZ7CbZ6S2KqcWSvIY5ejR0HXExWOGGd/iswaT6Iq0BILREpFMqlCa738rJnMRQY6k7VamKAEgpVZ8FvZfpTYZb71XmqXJ2bVSHJySNbZSpFIaHKTeFXr5rg6Usl2qisqcFbEq9lpWdlukjm0trrKKpN4HfGjRz9hNG6Cb83Frgc0vMwL/xS1AjLE651IppEJ9FSi7aiEGheAl/aYGifKi1BafDSFGYoyC+CqQi4AbbEtKTSETQr6n3o6HDnLhFj3zFHmdJKQxpcq4s+x6hSqRy5R4nQvBw2nX8/zYczpZrAYfJJ7KGtiPmqEv5OzJ0eBD4uWSuc6S4PPb7xy/edL0g2Vudl9BxEvufefg6Wz43W9Gxr2j0wKVfN1n1rVQSmB0sB8qT88jz5/P7B+OAsCILXZRKWl1Zi+XnPcShJIluyCF3CLGoOZCXj1uHBlOe1HI5UTJCVUD1EBJnqZBbgelsQ9qJs0zeV2lEvOC9jLWSm6DqqzXwHKZWa4zlMz+OGB7Q0pNFOIcrrdo15iPTmYeeRVAR/IzWlUenvfsHne43pDXKKu9lIgtr69zity3KHUDw6lHK4l7ryhJ7+kcqhtx4xG7O6HsCLq7z1ia/LQ1qbphrxsrsLZNk7ZUnJyCbeicE5rGd1Sa5ICTphv32HUWKbKC4AzDxaPVSr9kpiztpPpgqXANzBGSoMLkcyUv6eRbarORXMclvwe0ai19fNUyO1MKBqPuBqBtYFjqO5gzb5uBKi/82nL7bFvsm1+t73RD0lXbBHdJLqhaq0TD2/a/Ve8ZADq3GLJmDJK8ivZ7cgkVowgfKWH2v/4v/1v+5//1f6C6vS+Ff19KWrbvJKcotteQmllCSZCmlfQVvxbCnNoHXOCdygjxNodE9LlRY2AcBozTzA3eeL1FYmo3PhXVtgPXKfHtKhSWp7PheDAMvUho11KZVjkfd+SWqswxclsjr9fMdRL/wfEA3z9Zxt7gY0Ipkf6WllNoVMEasXtqKtOUCDFzPFj2h555Fkff+Vh5ftpxfD6zfzpjh1GGnFWGazkK6iyFSGzpwVKiV7G5piBBDlr+rJ3WjKc9/di30M9mvomrUIlXj1YF7SxVVdADFEOJHn+Z8NdJLp2M2F/bQfa3lctPF/ziMRrGQ09/HuXvZZYcGTt0cvCNrHUpshIsKVFiJq4BM1j648j4eBSakpkbvBNM1FCaAcpa8QR0Gu2cMB+zalsjhel6dL9DuxHtOtF9IC93LbklMasGh5VoMKni5ENblZUgNrUFu4gQrBRZyG+ClmocdKOQiFDoU+Cswe8G3G7G9IbjkrguibdLxPsi4RpZKoCQKzdfWIs46oaWdLxlCRil6Iwc2vwhxu39VX9X4MnQWb43317/XN4vgVTBF3V3Dab2yjvFXTxklYh/TCck7aqFLERbD95D1hqlyFDI6gPpp/y1EED8DJWKWozhH5RS61/NAMaHz2F92f2x5LSWnKTcTJLpl4PAE4uxYKz8QRv+W6r/1vOVgsoQSyCmTEoZpRPGFpy2pABfvs388aeFKShc5zBWIqjnJXKZFJdJbsbvT5ZPjx2us6QC05xYvSi1jAHnJERiXTM/vybeboV5EVf0OHb85tny6WyIuXCbE84Vhl7jeoknVynRdwXnhJA7J1kf9dbysB/Y9YZl9JzPI4/fPzI8nLGjcPFKLPc9jNZVRDRGLqaqFBpNVlmCIrKUwzKwVOyOe8bzHtP19+SGmoNwFpeVdQrN4w7VWBSuqTEzYfEs11lsxEpj7EDNFX9duXy9Ml0m+qHj+DAwHHbY/dBe2JXkVynNjUZb6dVLkniyOEvGQyXTHQeGx2fs4SDKL2XQXS/mrkaKUtsswjp5nbaU6G3lpA1KOzBiEa/bKLoho5TS9wqnNvGL/Pp2gRgyH9KaN4z7VuumLK3nxyBsJTRihh1WG6qJKG2wgyXMATcnutFzmxPrUkhrElNZWykGrfC5sPhmt96IQko0AalIlbAhvu7Gm7vev7SlgLzUS6p3bF1uPoBtQFjaf3dUdrref81poRdbq6lbJkZjE9T6PkfQTZ+w6f+r/rCyb6Sp8u4u3n48tRZ+Vkr9b9ao619dAE8//CG+fHn8EuNfgk1ZkF1Sr4hCzxoh/VJauKPsTq0xbXiWN3gQa0rtApA/WAbWm+fnl8i//YeJyzWyP46Mg5UIrAUuc2GNkq32dNI8nh1jL/Tf4Au3KROSpus0gy3k4Pn6onm9Vd4uUeg9SX4gVhdOe7F1vk4iTe17w/FoeTrtsWg6rTDGc37oGPYDFsFvC+dAkoWOu8rp6cT4/IjdHVHaUvNKrUnkrbYdwpSEYxhrs0BnYpBIL6V0EyQpdnvH7uGA3e1l8KaMILXXhbSu1BQhB0o1lNGiq2neiET2njiv5IZIKg3Ltc4LfvH4yWOcZncaGB/GtinYgRLwhp8ussbrZVAoyT2BuEbCHFGm0B06+tMZt3+S/21dQW16gNruK90uAXuPiK+1DTGrVINS2tf3KLntOdpibD+spIR6W8U81rAWFdM+vILwqjm15CErOo6S7xJhcbC1R0/1YGoL3FDYQ0FZEWypwTLuLIc5EW6BaTL4KWKUoreKWyhcGt5rg9BsE3dVa5PeVnzTyIjrTzV4DSz3ZCnwRZDdpslwQ1WsRQaDTjXOAIpeiXZg2+e7TmOdROtl1SicH5liqpUI95S++tdxX+r94KvNp1PvwsFXY9T/dRjM8tfJQMZKOzrHaqzYQoOXfYRuuXdZQ8oR5TO6VkxtgENF45zT3Hjh7hvPXsQ5rzHwD3+88eVb5OHkGEaNUuIUTFVy7JyGww4ez46hl1VRCEVw0yVhlMMoS0mRyxyZgyUmOI2ZYXC8zoJ30kqGl1+vma+vntstMYyW7z/vOR16lBYL6fG8Yzj0jIcRsKJwe72xrBFDYbfrGM4n7P4RZXvIvtF1o2C4nW0Ov0xYI8FHwYWFzLwGcikYrXFGOHu70x63P2C6HcoNMuFeZ+LtRqFincMNtUWvb59q4evHZSHHJBAQBcEnpuvcsgkLzhkOp4HdqcOOg1wwtm/DROFjlVJEE54i2bcw1Fywg5Yd/PmIOzyh+wPKOiga3XdUW94PcGkfLG3kAqsNHltjC6pU91QmsZLLTkq1f2S+JOwHIdmC0qUN1XQDWzVQTBWgh6otwm1LvMltUGrcfcxVUWRjMFlm6VUVqi5kq6idoOqstdgukkdDN0biaDjtEtOUuK2Zh1iYfOa2ZnwsLLlilDTyOQsE1Gl55fO9rFfvVQzc3X7m7s+Xg2+V0Iac6ONQyPZBAlTF66A6QzYC9izqPf57O/tbZkblfauRqL/Y8m0ko9Ichr9aASat1fV8cHn+W0zAUpRUaWsiI6+4Qj5AyoCqhRgCNYu3um7DDjZkuEyKU1xRpmDQpAQvt8yXbyt//jIzDj3HvQNdmNbKssja6bRTDB30nWEYLKUqprUQm0d9GCxVGUKQPe/brVCJPJ81v/vsGMeOww1ebhZnYJojtzlxuVXWWBljJqSItgpjHMZZdlrWeNp15JgJPjBNC7lWDmPX9t3P6P5ETSthvpKnG6lBLNCG4D3+cmOZgkyNc2LxMhxVtWCspds7dqcd3fkRuz+hbNeyDmfidCOHIElMzjY8tNhAJUMhCWlnlrXicBiwzhB8wC++wTqknRqPHXbs0XZEWemLa0looxkOI7UajLWN6IzIfLsRMzrsMGD6HarbNzdoe4mNkJPqRl02709MRVE/rDDf05fqL7GUVUgN0gpJEKig1nWLc5NA0FqVVBhqC3x5P0RiT8mkGFFpRVdJGBKYucjVDWI6o0bInhQCKWaKnJ6WwCOCocEo+sFQdolxn3hI0o7MS+L1LfDtFlkaFHRptbxVqgW9ykPcafDN+79J/Bqtq/2Z5SJQG7O//d79ZXeG3GAhzupmDqqkJjhQRVqA7RybdnnUxmiIpb4nbdV36e82myi/2v+3fyUcdl2d119eADWHpeSSS855jcEXVNW5FmrVWGMkvKAJSpSke0r0dy6CgKbemXFKSfyRD/DzS+TLi+f1EkBt9FuF97Ausos3Br57Ghk7IQfVInitGBJKa7rO0feGlApv18zrTRJbPz8o/vDZ8fQ4YIxm6Cufzm2PnRVzUDhbCUl2u6W9JgKnMLJrdx2lwPR25ae/vHC9rpxPjv3xzP75GTsepc9+e+X25SfS7UYKETf05D4SZsFgFYSBUFtijtWa3SAzjPF8pH/6jDs+oa146LOfiLcLYZpJoYASn4Wo0iQSSulMTp7l7YqfFklsPuxwY09PZR9WmR+UitZbwKYD0wlyTQmwRFtFdzjQcrZAFdRoUaaTId0gQiBBupk7BERe3RbmsknlWu+u1Mamb4Tgmv9GLbodeJkT1TbzUCWikXxH+bmptk7jnqMgdLt8/+iqkkV0FgOkBV0zmkTFtfVopvqFuK6UuJKisCtlua8oJBJFDl5VZGfQStynrjNyECr0PrMfDKfRsIbC7DPXNcuhrUiORJLS2wDHdhC3leA9Qu7D41uaGGgL7BytpnZGHH7qfWaXc5Wg0Q+uvdrkxEU3vp9t4vpcf+EevNO3fnEJfAgPeb+Pq/4ALLQiA851ff1TTFVPMcc/rzGtnep2KldCTCjdvnhEMtlsC7zIcjer4uTGSRmtpQS/3gpfXxN/+eqZl4xzhmG0ZDRvk0xLvU/kVDgfOp7PFqsKP3/zXCdJ/zVa0e0MptOQI9dr5PUifv/jrvKHzx2//TSQlKEoxX6vcabtWZNh8YXLNRBTkT24aVmF1mD67C6m+QAAIABJREFU5v7TsFwn/vKPP/PtZeF06nl6PnL89EB/OotM8/aN5ee/4F/eZCsSxfVW1Er0nq6z6G5oZW9l1zv2RxnE6W5gePrE8PAZ7UZqXEnzhfX1K/7yxnxbyLHQt6lvzhXXdwyH4T6ZDzeP1pp+P+B2IqjBGKqfqWkCVd5zoDGN1S8eDlSVqG69pTdljOlaxLtcAMp0W+qpQEhKES6j0u1r5zvyTTLm84ct89+SmtX7MFAunFbGS3LsHTGmapIJVhMOCejV3ClI9++lJCgBVRKkSA4eVeVnXVURanFO5JBIQcI1Y8wixGne2liFA6CL2N5rEjVk0hpPO9AKTGcwO8eIokuFfS6cUhW7fCxcbgkdCgFFT8VWebVFsVdYQiaW+sGzR6sepGTvWvxeMnIFltIep6bcuUd6K0VpYjm5D5VUMk7OXfkV6qfU98P/twDfVSIfYxsb1F9cAP/Vf/Hf8D/+T/99ufz5338Nr//u/wje/+fGmp2AFTPRSx5ZzaCdw3TCba+5YJSS1NaYKDK7JcbK17fIn34KTL7SO8PTSS6Nb5fEzUvZoxUMg+Owd4ydSGV9yLxdEvvRMO46+p3C6cTtNfDylohR+H+Pe8Xzg8P1justY3uDGztQFVM1h17jTCR40f+f9objzrbD36LDtSaFwu3lxvX1wsPDnh//7hPHpwP96Qnd9ZS4Eq8vFO/p94KzLikzv13EtpsLzllyjJTg6XrL/vHM4fGI2+/AjrjDA8o68joRbz+zvnxh/vqN6bYQYmXoDarvyKkSvMhdXW9RVUMpdGOH6Xv60x67O6KHI0qZtpYSpDWoZvap91JUHm1NVZ1M7g2oYqnKobSTaG/Tc7cObiAJldHatjdum3M319wvPj+bxkz98vDfP4kfCPVtJkSbC0jf3ExLLbRVbOmyOtY1QloEQJskEEQXCSOtyYsOoBRK9uQUm29FkqZzEn/K5p3PuZCah79G0afYKoKo3IAhtfnqCwqvFKEz6M4IMahUqs+kORLHysnJ4dXtj+pacRR8EWR3vquE7tHg2+ut2wynZFlHZ8T3v/EHJRyWez9RyocBKmIWSqne/QJ3ju6Hq/jXF4FsK9TUG/V/61Ju7z+ZDzOAbnfi+ON/el3+8n/+72Ve/rtU4/epaEqqxCoTfWc04ygimlSqbAMqLf45kIMnlsT1kvn6krgtheOh47ATV11Ksu8tWWM7w9hZht6w6zWRik8CXdRG8eMPPY8PA0ZpwpJYdeU4wmGvCEmxHzWpwNuUmNfKQy866aQK2dcmYRYxx3GEH75znA47lO7uirOaiqzWLheG3vLDHz7x+MNn0dwPPZRAnq+kecaNju6ww/QDJWVsJyaWdRaAZkweazXHpyPHz0+4o1h1K2ID9pdv+Jef8W/f8NebBKlgOBwM+9NIN3aUXOhjEaGJM21lZ+isxYwjduhRVmS7tVZ5YU0vL0ZpKTybBVILeEVe+qa10NsnqZO+W23+sHdWjLz6TaSD+Rs68l8KSrdIq/snkWY71ubD9F8372p6p0CX1i5uisCa5NdAMGhlJa0zNWUqRnr6lFqmZBamRPSENaOUxMvVJGEkklAt2ZLbfr6kTInyd55zM66lRPRC/FRNAh1LxVfZv1stZqLQXIFFSevQWe5y4FLlMQOoRqy7tIuGmMlK3X0IadPlfgB6ZCNybwXiqWnrvnLXFrwrDmurFuKvZnu5yKXRrBf3VuTjfVxRP4+d/l92Tr39ZT7+7WCQ/dP3yXXnt3j5S0w5E6KUu9VojIXedDhb6TpDXSu1BBkKGsmeu1wj3ider7Jb3w2a5weHMZWYC/OaCVE4+TunOe0a0FNX1qnwes1Ms+f3vx35T/71idNpJK2F6+tCiIX9UVRm1ynho+LLFYyVcij6QIqQtZYosiQs+Jzht9/1/OEPZw4PR0mqzeVOkp2+vTK9XdmdTpy+e8Qd9m2fmikpkJcJRcXuBtx+kJ14LuzqCWst7vXK27cbtWZ2px375we68xntdqAscbmxfHtlfrkQb1dUjdi+Y7c7sFeKbnR0u6GxDGg9tXwoZGWG7Nu7HrQsc2uKUJPYkNWHpB5AGYe2LdVZmTZl3vr01CbyXeMDSCS73vbJpX540T+W9h9gUpIw2lSQFaXK+6vzVx+8NhtQMtUvGyq6zYhqSQJGqZI50SARqDgRlyt+9aAVruukU6iZ6L0Qq22zkgcRWlE0YYkELzyK3KzXYpEVw1oNBSRISph6XlqBDRwzT4nFi1O16wzRalJRrLE0Q1W57/5ji4CvtPQ82gG3TQqMuPXuPw4NpQ3Oye2na0Wip5S6VwQbLbh+yBTY9v+5tAHir/S9qn0Gan1vBX4xAKygqFOBf7vbuXX+55KBtDYopeR7LJklelJMmKxx5oCzwuuvWUQ/JSfWsFCUVANfXlZuN1hXYfKfT45+1PicWRah2eSiGEbLuDN0g1BaVYXrLfDTt0iqmh9+s+e7784M+x15iYDiHBQ+yuzgtsI6RUJOHA+SsFNLJazyF5wb8TWVwvNjx+//7onPv3vGDgMlQ1qjJMVMMy8/fSNEeH440x0OaGNlIp09NWbBTdPWNUrdndXaWrr9IJuQBENKHB5PuN2+vdCFNL1y/fKF6z99YZ1Wut5xfNozno4YJzJgbQ1mcKKsa3W7lPRNWtsEJuK6FMCI0qsc/o+o8CawUW5E2V0r7V0TAiEK7xobwdlKJOM2uFN/o4ev6W+U923Hv8H1qvx7ihZJdr8ERLpMbkh5pWV9GsUJKZdYlqRiLYmYOYmXQBMocWa5XQk+0A09yllKKaSwEpdZXvemrNySd1OohCXe4+PEwZmbtkNe5JLfRyUbude0rMg1CsiztAC/EDI1VdaiJDA2lzupJ/H++lfqHdW1HdSKxHtZq+8inYaCfE8NKvUeCZZbu1BUuyS2oeCHw79VBnyoIu7Dvo/8jvpOJ96+jlIkDa/5/+PtXWJtW7P7rv/4HvOx1l57n+d9VRVlYscPgTANhAhEsmULVEhEFaE0UZQGQoIGpEcviB5INEIHaJAIhEBCioWDGyklOA5p2KA4wriSOClRdrmoKt/3OXuvteac32sMGmPMuda+L1cZK1e6uueexz5777Xm943H///7Mx72+65N6bMPAGk1MYiqONy3ksuSSyypYuwC+kAI3gOlIZeEZa7IdUFJGVMR5CT46LXg1QMjeIebncPQOzBXtAzUrKzzLhD2g0PXE+C1ZyMmHCfGx/cz3nmjw4uXNxgPt4q6qjN8DAhB01l0MktgeBxGxW8d9gFD5zEOHpUFZxKEwDjc9Hj6/A7P3nxmDz/pxL4xHAnmhxPyPGO8GXF4qk41veGqvWELuDZbM9ktKZpryIr3RbcfcWspR3E3woVoCconpNf3SK9egUtB13scnt3g8OZzxN2NOi1zUivyOr+D1+l98CDSSgWyGBm4gGs12o+WvXCdPuQgE+b0cHG0tiDoMBBOSU728dcHeLvf5cJ7uGo2raKQq/kAtl5eP2Gvo7OVHHU1aiaoeIfrAinZYtm1DJeaIBYsyltLQGisRF3PM7gsyEtSw5UHfKkoOWM+TkhzAvmg55opCJl0wNdYQDHCOYCzRncv5wpOKlzLtsXQQA1B1zvF1he1JgfvdB0n0AF1aSrl5Qs2j3nVvhB8VM//yrRo7sqsg+3bpFqaZggxS5jitbByBG9MwlUT8Enln+V+al7gFzj71peP+fHLBaKTd/SPW5Oj804+BwraZP74ewXD7pWE/jckpZ+U3N7IuWLogkVbCepsmXiLUm6XzLi/F8yL4HhWUurhRnt7R4SWBK6xxXepQm+MiqtLGVi4QgT4+NTgAHz1rRHPn+8Q+mBpQlUFNsYjQK3wUvDiaYcvv7XDm28fsD/sEL1GepVcMU0zhAX90GN3ewff9ShzQVkS8lK2VN15LnA+4uZ2QL+LGqS0DqOE0HJDWYpx+ZsR0gQtJ+TzDB8jwjigv1MbKwWtCNrpiPn1PdJpQgwO8W4EOcLuyc5AHjvN1oyD0nmhq1UKAyhEg7Law9kypJzt9rcb2YJadbDXqRDHhe3HBNXsC8G4gG19J1wT5a46Ub4q9U1II6tbz+FKeqY3O/Sh11akXMr9LV1IxUtSZtRl2tSLwqwPfysXXNw6vTYoHnNGThm1MpzrAGlI0wnLecZynNHg0MUO4tRiTZLVcVoZ5B26vgdzRa4ZnBlUGKkq46/YsJGrUny9Vy/+GlojVb0sxWS7kPUZVVyYCw6BCNFcgeu+rhgjkGwyv67yGhlIpGoLolWHDgadZfxtiglLE96IwJ/9bKvASD47/JOMO8BX4iBbIz5Eh38AwvTedPvZPIB/8xf/LH7lV/57bo3eT+9/9+/W/Prf4tLeKEWDOEtuIFqwpEWxTQBSqZhSxXEi5CTGTiN0nkHwOjxhdcGlVEDQGOwQvAY8JNYY69Lw6uGMl7cO77zoMEaAS0FeGOfzjDkVMNT2OwbG2y8i3njnFm++/QSHp7cIw87e3IyuMvrdaCrRCIoDaipIpxNarRAorUbRWYRhHLA77BF6D3DSUhm6b65LQkmKL181EAJCnWfM90d04w6+7+CNUCLSwLlgef2A88cPcN5j/+QGAINrVdOMYdPhtE8nHyCtgEJnZbs9KGUB5xOknAzGuR4QweYDHuR6wNtE35FWLxSvbmzW25jWnb7DJjHceFHyGSs9vmwELK9Rb/uqMXFsSs+m5GGd5F/kudIUacblqArG9cEwxkQrGa1emG7SdKKvKMqq9Gjx6AYBWsGSEpZTQq1NA0u9gUeIECSoL6A2hC6AUFWVOVuqkU3ZEQmBgbToFD0SkLOGfbD1+LUJ2IAmBBX+eIhBNbQ1E0doUE7GuhdxpEThaqU4GxqsNW0VxA6fRgCi2x66tZVYv/2f6t03+bSKCPiKKfh5jI/rg2EVUVXQKRB9K3osX5gO3B+eyeHNr5b34pNXU/luqaRuqZwqzlPCkgWnKSGXBufURvlwrlhKgPfAftRJvHUKaCCUUpCmhNO8oOsHPL0JiJ4wzwzvHQ47j9cPBdIYz5/sEbzDdJwV0QWNzwqO0XUVTYD+EHF4coOXX3mJ/YtbnYy7sK2YyDeQ623o5JGXiuU0o6aCfozo9oPKd+esKKoY0A0rFVdLa2GgJTWMqOhFqTxcE7hlzPdnzMcZ0kRXj+i2HrGlinQ6g8AY727R3e7QpkV/vTa0eQb5AteNINPqwzIV18NBc/nOQJt1gO5uAD9qiR96e9idPfDrrS2XHv3qAFjhUlt02xYVJZ+4+dfistnenwFR3YAo+UX7+bpsazjNd29K7WlZS3xT+bUyo6QJrTatVAhoVX8v56SKvvXGamobbxUgGBAUFa0oeHM6LihL0RmUI6RWAFZqj3cCWGZlZkFZCpapoM1VM/zMOReJwJmRrjaYxSzCbPRqdc/qcNTjovkvooYdKL4E1Wy4zsA2cITqSDcJorMFZ8TetT8X2wQ82qOsDz7ZUb0i9XC55c2SqK9Ou9L+f4bZX7a8wMtBYCbmJQb64PltLPkPjQeXxlVQU5XJqhi/zAUxzKBCmJaCedG4q9IEc2oYoyK5pDk9MEwS60SQEuP1JCjw2EWvaK7eY1r0BL/dB6RE2PceuyHi42NFkTPeCTvsntzihhx6LxhKj5oZ0QM3z55g//SAuBvsMtMcN6FNaA1uQJ4r0lIwn2fE6LB/doP+dkSzqDI4bS1UfWahmOQBdjb8U3QZeQVYcqlYHmZMD+dtt1ymRVN0LWMeIvAxoh8DhlslFXOy24Mr2nKyUFC1ZRMFiDQQKliyqtpaBrjobR9uQG6nB4BT3p72/x6Q8Anm05U53N5BKtz55Dtlvf0/OeSzA2Mr5S1vipsORWuClFmFN2wHBVhnJUWNSmIuvlYW1Frg42BJws3K72x7e0XbcmOkXJGz2oE96a67VEYp2odPxwQww++UCVgWrcpC16OhYkkau17OGSkxcmkaltmAKTMQlB/RbPMRgvIpuOo6cFuVmTZBLChHRC/AxoIuOHjH1jDpw+5ZI3iY2eK51CYPsYFeM0UgfUHJvir9rq7+tf/fZISkQ2i3Dh5tKiiOHi9e5JJGdPWOYAc5AzjfHnr+MH3BAcDMMn38vSK+f2gUfiv68pOjc8+WJBhGNgglISeP86Lrnb4nPNlHdKNDzYJlIXAqWKq+iKlon3cYenQE1FIhfUA/REhs6HvC2Afc7TxaYXz4UQGJnr8KzYxovcPI2od7R+hv94j7zig8RcUiQR1q60NQc8EyaZw5uKHbj2p22Y1wYUFcKpwjVS/iqhRmVXyJiWqcN3iG98hTwfTqDJKG/e144fGzTrJXcrL67klddGggz3CBTTpLZpYjUKva1ouhrmjz08J1Ayh2IL8DqAdR3C5rsrJwe7jFrhyQDv6I7HP6tDoPIo/tI+sBQmtvz4b0YnUAioazSkvgdESdXkNqNvuvVgZcMmpJ9pA7e0BUTBRit7EiVu59rUaGqg1laViqTu+D12YjzfpAw3wRZdHb3HGGyw2laetIoSC3hlOquD8XzJMyGpzTnD9h/bvYUqsqCyg6DMFZrSPovII5mxnSVvhnNf/9+hymqsNtb+W4l0tmYGmaLVhJy/yNF0q6Itz0+3It1tEPXKoBRemqAbvq8cXAgIyL+AdWUawqwvXwqnzJKrg6AE7R4Vut8DF8YgD4qQPga7/wdfz1v/5X+Y2pvlvuv/+N+vH3fm7Xy7NzUiFQR4ySGNMsyKXhyW3E/hCw2+tnXy0/TarHkgRL0r3/fiAN0+CGtFQQFdQKiBcUbtj1wH4X8bAAOwC7fY9h3yMMUcGbgdCFi+nED9oLc2toeUErjLgqUizSoFW19jpU9KFhGAP80IPiAA9Bv1+wP3TI01o6kWHOGvIpI58WOGLEmwFh1Ny56fUJy7Rgfztg93Q0UydZma7Heegvkk4xzz0JKyGHCC4GUNfbzd5tZBz1yJNq3qXXTESvQ0G9ienTQrvrq4Sv5GDGudcDgm2odDWtv3qLqAKPTZbbLqo909evFZaUGXV6jfzwSteg3aAPfNUo8VqbxnFZfpXq7IGaNSiGa1XEXCHoPLOipIrlXFDBKt9tGoKak24H+jEgiJbo06Sk437V3reK1ATN0ipqZtSiYqdghdFqU2iLaRCcIuR9IOSifXwXCM55VHLg0uDXwA+SC17bQm5Vu2BDc2gLvNicAaTtBjfZyFPN3LJsYJD1IV9hocyi3hcxncCqXOTLaHZd5239/1qxrHj7q+rlkzMA++H3vKNfDh6v3v3EAPAzW4Dx7qU8/8pP5I+/9eL90+sfTCGQeDTycMiJ8XAqmGbCOHo8e+IRBmcGC8DDm+Y767DHQip88OiDviL3M+Fk2nzvBXVoGG8C/Enw8euCl88HvHznKcYnB6wQfx88wtiZPFw951INeZ14eyNLSahJkJeKdFY3GKHCxwjfdyDvtPz2Ab6PGO9GxGgJtKIlY50r5tdHLKcJ+yc7s9b2WB7usTwc4T2j3wdl/jsPad4esDUolWz/XiFgSNVVmo+DDq/6Xvf0YbT+3dlBoDFpgqbh6S5aRQPF8azOL5HPMYDTNmjbZCQkl9v80ejoOiTK9PlSHyVBgy9sQnBFSwuW0xElzYj9Hj50IKpoXFQ7wcptaKwPjQ8MlIT5PKNkhg8M54NyJGtB5YY0FaRFQI7Bc8WcVC1KqBh6j9E7SGqYZiVS9T6i8w6l6X6/VkE3euw7h06USN1swl5XmjUrIblWwRAdQkegJluvbNlZSvINQe26lTH5hqVq8i9XfViZBc4y/iqAXBgJWnGI6ZhgvoE1vFMc9D1gs4DrUE9pshmAVl8Ar4NEaxvs/N4ixa93/Vvb8lniH4sQBOG92Llvv/1sSNMXJgNd/eNDYIrjVMh9r+X2M2iyC6JpPPfHjOg99oND32lSamkCp+IwNGGURmAm3PT6di5VEd3RAw8zo82M57cenZFyvHPwDhh6wsu3bvHkrSfoDoOaO5ZqzDsySafm0QsL0tRQU0O3U9NJmTOWhxlpyVhmlY6G4HE4jOh2PZzTeDEuCVwryDvEwwgflb1aEyOfJsz396i5wj2/sWRbXX+iNQw3NwjDoIdJCED0lsbTLrexEEQCyDUd4MQRrjuo4y4OIK/OO2Fnxh3/SMOPzTu/uiuDHjBy9UCvlbu7eOzX3l7sc1FSU/1UC7COoWS99VmVnPr/qseXmswUFEDIaPkELhkhRHTDaKEutsYzcRQzIEWNQ9QYtWWcp4xWBLF3iF20q0+HboUZVSqoaJlfLYDTe6e/3xNOhXFqQNhF7G47wDtw1v18HD1uDx16Ae5nZR2AZCvhc2Utne367CLBBwJX7dmpM8quIzjt5hAIyJVRE6GlBs566zebBaybLhGFg6h335ywVrvnovMx8XqpcLk0XaWtbhxzEK5DwM9w860BJNchPdsRzhdC8ToqaHJhCKhwiM7B07c77063+06m6Yc4AJhZ4nibxxc/9m74/j/528sHp3+xVv5qXSrms8ZnP3ujR4wBOQt6ElAVzAthShnnVHFaVEJ52CvG+9V9QjpnYOwxFe0p90PE7dhhYWXx7XvC8+c7vPOVW+ye7OGCRz7NyKcZgh6+9yrmmPN2iaVzRasNcdTbNKeM88NZZZtOo6Pi0GM83GgyLjdwWlBOR6TjAm6iGfcUwG1BmTLyeUIr2VSRNgVndUQO+wHdbtDynILKisWDXLZy20p1pys3Cj2c7+G6HSgedO1H3baKo+uQNyKz416LccS0+esQsW1IbaKmQ89tHLzq8NvVeu8aEm1MG77MO6Rpb7869FQvoLRnzpN93R4iFXU6gbgg9LpizcuEdD6Dc1KfemuWkKTS7JQaptxwnipQLV4+6jXWuKKB0UpFsno3dhG3O8YQnU7UnfbiuTHiLmL3tAeGgLxU1KbJ0ft9RPQOaVYJr4bCkpEEdJBW7Qnpeo84erDXW9gFgg9eE4qctUvWZrVS4UkQoH+em4FU8goCke1AWClYTTTIY+3LG2PTOJRmDP+rQd328Du6zASuH3b5lLL60cO/Zghc24av/21MqKB7D/rtXPn4eZvDTx0AX/uFr+Nv/p1f4Td/4mfPD9/+5m+d8d5rFvnqcVJySnDAfueRhfH6CDyFau/vj4L7qeK8APPM6KOD80GFMCGjloqoSx4AwO0oeDoCHzxodfDW23u8+c88w8svPUHcDVrizxllmkHBoQ2dynuTllxO582QIIaJFt37MqO76bG72SMEhzAM6J89AfmIfJyRjw+YX58wHxXqMdzu0WWzo1YbbO6GLdSiLQXkgdh7BL9DPOzgxx1c6JWK0yoQ2FR3uglZDwfqRrXbuqiQDeouuvorBxyBzLxDV7f0evtfkSZAj6Y7hDXCu13d6PXTZMh10CfFdvfaAkhN4DJbC0DbjEVaQUuT2m5JUGvGcjzBoSKEgDwxzqcZ6TwBVdFwjbUXdwT4Jsi54ZwLSlJ3plgcm4gyFBvqluLkHLAbHXZrRBlUoFNLBXUOt0NAGHSlO58y0ARd5+BEwS/zWYNCd70HQ7AUcxhqYpsmRfcOEtUPywHox4A4RvigwilpAcyKoPNuQWiMaAPL1gio6szLa79ucwAVidkD6WgbsK5zg61//0R9LlY5rfMBZ+ixtql9LzFe677lujJYm7hVGFRxLXOmdf5w7xz9dvQ0fVb//7ktAADEvm/dOEzdvjtiWur9xOG4MPreARW6P+WC3GtEeK2CnD1SUq/3ftAvpDCh79SR1kdGnBpYnL7fURBQsX++w5f/xAu8+MqbGG5vbWqcbAetPVRLbQMdOq96TO8dQvDqBGsNUgRx7HH79nPsnj4DUTDlKyGfTnh49xWm1/fKOXRBNfhO0LLmFMahhwsO/b4DV8D3o5bpDgijRnDH/Y3ivMgQ11QAijqsQzBZrQfcoLANH+1Cb1e3vUEuVucdVp8BLj342re7x1ZbWVd428VvnvltNHVl1117RbYWpSXj/xfzOkz6Y3Hg5swxWBVBtiRwLmhVpd8tzQiekGlBSozzQ9arlBnTuWBJTb+HnYcTQc5VlXekmfet6kwiRiB2QGbdiHRNNwJhCCi0bR2VM1l4UzCXpSI9FKRzUcOMpUxpQKfDuA/gwpiSlv/1amSu2QpAaboR2I8BN3d7UNehwGvAC6thqbYGVEWIkW/w0cM3gSTLBCis32GnBh6wxs9VA8Suwdrbw+/p0QaAVueeqUpp5SMSlP7bruzca6VwzfG+GgN9isbweCCYCfgD5+kPXj4d6vkPTQf+5Drwo++V/jA89M8Ov4kPp596NZWXrybGG53D0hhTbRp/XB1S0fSUw+gA8ehcxdMbvZlTZVDvMQ49+i5grl7FGrnigRyG/Q5f+rG38PIrL9Df3SlCmg3OCQLFXr+BefWok/aApQHOoxv0Vi1LRuOG/nCL8emb6O6e6i1XTsjHE07vvcLxg48hcLh5eofxMCB01j03BxfJGAEESK8DuziYzt7ZTr7XCT5ZhiCa8vZ8B3Kj9cvQA4FUsaYheGwlnslx6UqRt93u8gnNfbNV3/oUX1x/Wuavs4a1rDfxjh0KYDb3nZXmXHWdV87gfAbn2YQ5zspYdT+SFOXricJEay06zCUP5orpvGCeGsoMeFH+4fGYUUpD3wUNIWWxBCL92FkY3gE3NxGHg4egoJ4ZkgscgL73cF4n8847dL0eIsukcfBNBFwEaSo4n6vCOxwg0aEb1QMiApznhjlZjSla5otRpNfzdYxOV9JhhxJ6YwgwqjPXoDCaExTvUYMKzKixOvcCgKKDOrYcAcg63NPY8M6pMnDrKOy/q6RYFy2q+78SWW+fszd2ALttE2uipMshQJZncLUY+tS2lwjv9oG+QSIfHHaRz9OPcAB87Re+jv/ll/4bzsvywUf/73d+rZf3/vVW28vKKqJgEiQLvFAogkNkPfuVAAAgAElEQVTXCWLUL2zsAm72OuHuckNthN1NxDgQKgMPD3rKhxjx8u2nePb2M/Q3ey3/qpapUpUEy2JQBDvaWlGUdRPSOKqo2ngRRux7DHd3iPtbUOghBpTIpwl1mTEcBoy3txjvDgi9B0HDMjfKDTdbtDN8jHBdgMga0QWAisng7c+IA3WDPfxmvyXzBayOOV7TXv2V644e/5cUrUXuak23Wsy2U98ZKMd6fHY2+CsKV92qBjadfgaXtBmbdEpVwWVCOd+j5QL4Hi4EG/wV1JJQczLDULCDuMK5S6+bFsZ0ryo9AEhzwTQXDL3HYA/iUvVg8H6VuQrG2w43B48wAMcjY5k0cCZ0mk9YC4MbY9z1iMGrqGdpqMKaX2gQESFbu5KW9fsxwAnh/iHj1X3R7IXBGUBTB3Tr8MwRYegjYjei+R5M3rIZ1vNVKUXiCBIixNWNrOK8gnG9ByqzHQBW8NvuX3fw9vepHQNOgCBaCWB9sL0KichCSZ2jjfLrTELMVv251awpgmJZlGsACX1iVXilHJYG+qCP9Ou3oz9/Xvn/hS3A/vmXpKYp7YZn7x6Ce+gksyd2IZJmpy0EG+Kj6wEftYRMAsALZtGH2VVtG57edoidwzQX1FRx2HV4650XePblNzDc3ujksiTTkVeUrHlwCov0etq2Cs66AfAhIHh9wFig/387oDuMcEEg9QROZ+TjEW1aMOwi4mGH7nADHxWWIS2YjJhN+ObVpll1U6Cqu6gnbbV+mzqj7HYg10FoBJGShkHOQBhXjrpVh0/eyned3G+c/esl7jrEQ1EU16O6z0Sd0gDL09tYfHJBba3/1cjw8yYGXdl9nBdLF4L6H4yfsF5VwqpmEykgU7VJMEYfqd8iZ8Z81mFszhWNgf0+4nCImJPm6imnUDRoMwC7AxAHYF4K5rmgVQ/nPbzT2UsqDB88uqihKtM5Y1oqusEjiHrl2RHioK+Rjw7D6FEq4/5UMZ2r8Q20HQ0d4DoCMQHFHHsCIEa00EMowLG72vPr5cUuwkdBkAa3FJ1VOFKbMNHVxvWx4cZtAFDa5rgk2v5c7/gdNlTiWhBuB4jIhQBElgOo2wJ5NN3/JPDjkwUACwoRPgDRRy+fDPWjgh/9AGBmSffvZh6G4zz2/6g1/ukO8pQFOJ3VDks77WGHGOGiwAcg1YLz0lCPhFYFDhVfuRvw/NkOzMCHrmDsHJ698RTPv/wcu6cDnFMhiDQ109S83jCM0Dl4F1GaoqbJEbpdB+8dOBekI8NFDbkM4x6hC5AygUtCmc7I5wnCQNzt0O33CEN/VXgFCDlTAhatFZuuflYIpkDtyvoCeJAf4Dr1/MN3IBqAbVLvdXdPZDt1ugzkPoXOo8thwLyFhGAT5Kg4aevftwHfCu8wv73lMoqovx5ND6+WTpA62frU68eCgFNGqw3Oewhn1JJRUgM1hmNC9B7SKnJqGkDhLSORACcO1FQwU5qW6yE4jKPHzU2AD4I2q2IzRsKTpzvsbiMYBd4zltJUpuuAfmA0qLkml4r5XBC7gHRe0JaK032GsJbUralijq2fF+MHLnPToI+pYRcJwy7gNDeUYoNh/9jmLORQpUOJES4IArEtYFQavMFQodoETxGNqlZ+9Ljvvn5BVzdjIFgS9uVmXt2Bq+WaVpGY4cKu60FNtb4cKGKSYuUC6CyE+QvYf6v9i+jj6PH3WpP7GL3gj3IAfO0Xvo5f+p//y3b7lZ961/3et/6Gw/t/aoh4mlmwJIc+ePTRobAgUFNoZedx2AOQiFMRzJzgidFHj2E3YF6AWk/oxwF3b9xhfLLfQipWUQxXgBcGBUK/7+EgaNmGOt4pynrXgQSYzwtKLog70gebCFJ141CXhDrPkMrwfYQfOxMD9VuWIbyHi+akk6SnumsgsdvcR7Pcrnv9YCu9vTrxQJ8CZqyTe9X7O7vR6dGkRpFZ7tG6D1LBXNV0A7GKQW90bgXgxZJ6bO/PRTP2+AIElZY1YqzMKMsEQkOI3XbDCVeUUjastSwJ0yljOmVERxh6vZqWc0WaK7pOITGStdqr4lGKIttubzUQ1XFEP3j4Dljs3XuzC+ie7/D0rScYDh1O9/c4P5yRUwFKQyCgOg3cZHE6tMsMrgUfi2A+FZyOataap6pAT6tzhXU1WLIO9crC6Byh9872/yr6IQ9QMxsvzM8RA1oMepvDHHrNshudQzE2AllymgsCFwBfdVW44r2DI1Rnu38DJa9l/PqWCKSCo5Xx/8jdJ1dmH2iLIA5XDOT1ujcBkv2Cs7L/ei0onwa2CYAfBE+/1ns6flH5/4UHAADsX/6Y8P/9t6bYhfe7Mb52VWoRhCaC3aDMuNcPOoB60qvj63Yfse8jPnIZ+VVCa4K5NMznBeezYJornr8YMRx28DGi5QIRj7AbFCe+ZIAIvosIQwAX5bx5J/BjjxVgy0yQENDmBFd1p8wlgaD58nWu4Aw4HxCGqFJcb72teEVjG0SDnNf1HVf9+U7L+9Vfryx81Qu4EKz8j5uV9dEuXuRqKo9L/NfV/v3iwBUjCRcIl6vbXyAWgCmtQjirC2/dy5tQB5yNDmvVAy+aXFSyfi1eOQGoyjBoVbmNNRWUpKk754eC5VzgHWGOepAsi2Ycuhjha0NN6glgEGphHG579J0eyqkI0DEKdL335KnDED26wx79kx24Ab4RnKgytGaNlMs2Q/BeY9PBOlg7l4R51gFoqozlpOGyTta8SsbZlH3NpujkgGS+/5KUBswQuE6FP/CE5gTRk7aqZENP20P6GD79UJp33weP4PwGRXNeI8bJWQguLgYcNo2ACw4UCFR5Y6rKFQxwzR5cRZ4gufz6Z3h7142AZg5oBVRwEf5cHwKBcO48vjV27jsvn/Rl+sPSgb/oF7/2C1/Hf/WffL3tX375/Zs3PviN5cOPf/zY5E2PipsuYuaKV2fCzV57N2EgRIfbfY/WGh5OHktjzKni49cT0rkhOsbd0x26oTOcEcMPA/x4AykLXCCEUT3vec7I54KWGaEHYhT4LqwDcnRjh7LY8IsLpFmYpCghx0UH8mKILTG9v/Xw283MhslS/bdKcAfAD7rCc9b7unBp3sCPp/Yrgpc/R8Fx5dC+HAR8ifuWYuu8CrQCoGpfznJR661JOVzAOYNrtgFfsfJSNF246IMN8vBW5pdzwnLMBhVRxd3S9IFUZ6Rq0lslxKjrVa0aHDgxllNRTEjUtet+pwk+pTCauYJDZAxdwK5XEhE3xun1A+aHBJlOaKWiLOrcKxVoheBJ9f25MHpvDzIrSosC4DIjtTUdyog/SvneRD+AxnkvC2/Cn2I5lSN7BLPTwmmYqndmemaBNNqsc1vwqN2jq7GHoBFfkYHkNBrcilFER2hEKCw2rdeCzAeFezShrb93pEM/MZVgo+0O2DQFcoX2FjyO/m62DsSKD2fLFLwGh2pH8/19R98YAj683Xc8Tf8/DgAAeOOnf77Rze+9e/7g4Rvvvjr/4pzbm+IafOcQAfgkGDqHfe8xF0MW1wYiQewZlYEuBrgmCNzw9osBb71zg2HfWzKcIHQDXIjI5xNaLvBdRC2M+eMJy7kgdBGhXy27yn0HKVm4HyOkVc1oC06lu2JJRjBSLhS7RS6qw871Jn6Rbee+afgxgMJe9flrRDetAA6vD+kK5iT/OCr2C/EM6/+y+QR08o6WrH9vakeuSQ02RX9ezX2WFi9qy9WHPKirv1VbmQqYNZOw1YbYdXChoS4zjh+ecLrPYObtnPJGZRZ4gJXQMw4efR+Qq/rz2dBnXBq6waMbvOKvl4qUmrIfO8B51TS0BkwTI5eKwjOkqd4/CFDhMC0rEYd07pMaTseiisydxzB6VAvDJNFMv1YJ59SwLBWNBWNwZs8mxW1ZmZxF9/Pe20yHAAeCJwcmgTfxWJQCXyKYaHv50NYATlEvS8uKebf1razMvqYDTmVUaEBt8ASqdqOLtgINVzgvW9ltDkHBtgJcV4mF1cnXTFBk3aO2KnyxB7aVQXg1hbgOBqlMDQ7fg3O/ebOL0x9W/v9QB8DNm39C0sP70/j0ybu42b0XH46ZiLoKoO8dnt0xxlGHQaFF3J8LpumMUgocqeji5fNbPN17LGHG4cUBT958ijB0aMuyDcC4ZMyvjijHBcOtQy3Kce+GgNgHFZgQKdF3ySDv4XuPfkeQ5s2yayU9WcYcqd4ezHDdANfv4cJ+094TSAdntoklkFpvXXfZzRM9Tlw0XBiRJbzxyhNQwc0q3V1ve3KsQ7RN/Wc3etOwCy6zaeoZnGeV4FrZT7B1H62g0gxOk7Ydfg8XgzLumn6tznsAGp8FFBBXzPcnvP7wjHnRiTyZwGjoHW5uAkoRzLlqCm4ksLA6+6q65Vox1NZgstul4DTrCs/3QLcjfdMXICVBqwtStmoLALcAOEHhgtoqhHSV7BwhJ9tOOCATbYDLVhQjJyxgex947xCDBnlq+CcQTGfQmroAq6n/nHg0IyE1UZRucACVhjoz2tAgUWPPRASNi8Z6NwZaQctZ06QYkFKQZqVTVXMDeq/JTRJ1PehFU6thJp5qKcJMhvgyBmBj1QuI069hrQWzyYXBl7dbZf3euKtB47Z2hFzFk6+IdYAIr4Oj33GOXh0Ow+fu/n+kA+DPfO3P4X/67/6zevf2V987vPwnvzy9fv3jweMn1OFFeLoP2A9+m1pOuYBbtsQgFX88f+uAw65HjBHjkycalOG8+sgrI7CgzQvm+yPKcbIvSBA6Qnczag59VEZ+nQs4M8IuKPJrp+W76wcl5DBr2e8dyAd1V1VR+2280cDMlXnHq/HG8tbhTK67AptoY+RdrLOfc9FfrfG0aFzbAbri5VcTnjQQsgI/y6IrR2a0soDTAgErLtu4AbpD0jmHbkgIoavqB+CiB43XGHHvIoIvapdNDeeHglQ0gGU3BoArctXQ0pWZvyZA51xRk7IPo5lmMgNhCDqkqpoDEcegitDAYG768xVo2aGanE/PRIaXgNYYKRFqdXCBLw1RILje24BRkBcV1UvT2coawLkfVO25LkqqjcmD7cODI+w6jwoxmy/QLHiUAXghePs+1pbhk1eK06PVGaO2hlZEu7DWwLkinxLyuaBkyxOgS6DnCoFp+TLTIML2/oWZhOoVyWd9+Eu7bIkdoNW0AyiqZqE0+XwvwFXs19UWuQnwe0T4BrO8/gJq2I92AJRccHjrJ6QPv3bc3/a/A6L3S2v/rK/Olybo+4BuCKhNkHICoeLZoUcIA14/zDgMHvu7PcabAY6A/tkzhN0N0JIq0Yq5CFNBWxLyUtEwaxDmqBYt70WHOY5UG+AIfujhh/HiYXdR24OWNb7MDyrHdRGIDq7f689JvKTWYt3br3p8y7NnbTWIzPFnswK5FvV8Ipj5YsK5wB4Aja6SrYc3UU4r6mJnpexwUuNNKwVSC3wkM6gIWqn2pvM2E9DILy4Jaa7I86x261uVLZelgEVTl/NSkaug7wJubjp9aOHhizaL80mJSTUXEKl7rhTGzaFHFz3OZdFxpNF0amH4SBgPSmkuWRORa25oGShJUewuNoROhUu1MpZcUdYHZI3gsoEcRb02xUI5xHTxYoagsfcIUJAHE5CbhoIGW9NyZgQP9J0GxVz6Z9X9o619tqAwEEqBrwSRgsYdfNAtkBNG5AyqBZwLkAvqqSA9FLTE28O4DgHRVLCzNEbKSshyTrcl7cqsU+zHRBo0Qmupf702tEWODwT2pFuaNe/PHH/tapy0komvmS4sNHmHfywi30y5zT9M+f9DHQAA8Of+7L+D//w/+rm6f/Hl9/pn7/+9+/df/URkecMzMHhdkUy5YSoFQ+fx1peeoO9G9O95BGqIMagb704QDyPICcp5Rj0nCDtwzahlRq1ZM+ybQxx03J/OFS01xB3ggpbOPga46M0hR9uNoUO0BHEBiD3Ij6C4szDT/uK7R7NknSvFHl128/pqP5br6u1fbZBoPD65Opul6bQeV1GxaPZq1c38s/b4RIoIWyW42v/rGkrFOA0ladZdCA6hDxDzPwgYdU44fnTC+WHC/vmAMDiUuWF6SIg72ihG6ngDqFM4vAihitpvpTBKKii5bWKTfhcw7IMeyqxRdIO9S5pzmsjDap0uU0WeGmrTld6yMJpUjBEIwatku2WAGLHX3nlT1DlCi4K+8/p3BT0EIhEGS80VZngxyu16m0cN8gxkvP6yxnSrQq86MTyXQ4BgjU9gVj9BywT2DZ4diAsoBn21UgUvBZwqytJwngtOx4qWLod6MFnvesNXBlJmLJYs7M0YVPgyEto+d1F3zpqrHEn5mc4TUGzV55RGzKur0XwDjfXAWBdOn1wrCpFUoe/0hF/2Dh/cvvzyD3X7/9AHwOnhiJc/9XOtxd9578Mf/OB/u3///k815ufek48GLMyVIRV48mLE3RvPFPkFgEuFD0FPuBjUR14TyvGEdJzhe0Vjt6whJKUyovMYDj28J7SlgAsjHRkNAkeCYe+UtpNX3vy6W2e18cZRd/Vhpz92nXLsxSKqPoXBv+rRTbijmwMFUWC1BosNIoUt1lou2XaGzbJZrc0A1I6mIRgWkMFFh3yrgKeu79BsKTvqQ8+poCZGrRU1OsTW4J0y+lqqOH50wkfvPUAg2Lu99pLzguk443bYoeui3rSOlItAQG2MZW7IS9HY7MJouaIUXavsdgH7Q4DrBMtJ25V+8IhBQ0tzbphOis72npAXvdldUMyYcyq2QbS0IQg6L/CRtP+tFott3yFHqiB0nlCyEZ2Dwxg9ErTiqI03USTRpe+nysiVTR2nyVOris5vYxgCkQ7VViNPEUFxhI4dJDeQ+fCX3MBZiVenqeJoNKtgk/oV7pkt2GMdylXGhuEiskqpPX6LMRk90aS+zuu8BWTfF7vVkXW9593K99ftTBUdLFa5oFs3wKgeDAWE3+96/83nNyE15/DHegAAwO07PynTqz84vfjyV/6fj3/w7m9gPv1Y590bzKKJqLmh84S72xHj7Q185zHcZUhuqtqr1Sbd1WCyOkTznYejBscMBw82ayoR4IPA3+rOvZQGnpO9uAzORct0HzZUggs9XLeHG56C+hsbCAad1ot7ZKbRzd2KtPYXYY7Ip9x3tM0B6KrMb5eBHqBCHVn0Yd+qBdbPNSk3b/1cNeBjMTuvKgHViqw9Zk0VddEdsmNSpFWqaKIYrXzOOL0+Y5kLnr1xwM1hhHPAsmTU0uBCgPcdPAkIFWVR1JkiuKoFdLAeAk3XpLHzGG4CQkcoqSEvDf3gMd6oo7JmxvlccJ6KYbccHOnaMPa6UnNCaAbgXBVrRFoWMxEiqbde15TOqhPSgW6ocKkprNOR7vdJbbjBrHTVJudg0SFls+2OXUJhpW82vXm35PJw1T9XA36woHJFXhipqra/Zsa86MHS2Gi/omvIFemVqq7xNuutDefcWovbzIltaLz6/kGm3bcth5iOAfYxLqlC+nEUOWYHzMoVlMf3FS7j6x90nv7ufvCvXj4d5d0Jf/wHwL/37/6H+C/+0/+gvvXjP/vew7vf+9WPv/17/1qr/GJemtPcNMHTQ4/dbgBBLbZoqwnGvPW1wi0LiAbtBaNH3PdwUQdBsYsY9h5dpygwDhHx5gZxf4NYK+r5rLdAHzfhhOv6DZ1FoQf5Pajb2Q3eIGyYsi0/rdktrqsbWs0ijMsEf/19m75nveUrhJcLcMMyBHQ/PyvOu+okGZK3nT+XbKETAYCg5QqIeu0pRIhoL77utkttYOj0u5lgp1bBeU44TxWB9cHth4j97Q7dEFFTRln04Q9dhAsOdSlIp6aVBDecHxLSpG0GN70Zg4ExujGAgkdKhFaB2AWMvYPrHJackGuFD4Rxp8M21wnG4DF0HqCKtGhvHqP2/qlUoLGuswy/1Vlpv1l1vdMUJEfwCIDt/dUDYuispterdxaPZl7/Yj22C3qjiqXzkE3bYQ99I9nk09fBnLWIUoks9rtVwZyVKOygMxhmJVzPxWTIBNMZ2N9xDfFkQS2CrOs4MyKZRBhA7wQxEDIBiXXQybJWKzr4q23NdlXrcRIgr6Ql+txHMzvCt4ZIv9YHevhhh38/8gHw3d/9fdx+6adlun//9PztL317/uj9f3Q+Hv9kWOpdjA5dFxC8A1FDW2Ys54z5PiH03aZ7lsIo03nD14fBmcpOd/jDTUS/c+h2HcIQ4LoeYbyF7/dwIelmwXsd/pESfpwnIAw20NMpPpHfduTkr2yUoMchGKtZjawyWKf2BCvfV3etCXfaDC5nleAKW9QzQUqBlBM4TxflX0u6R2cyTh/gqBoJN0GkaAIwnLLs8vrmZuSc4SAoCyNNaZO4TqeECofD0xFd0Diy4dCrbsK4+WH0cIHALWM5nnG8nyFMaLVhPllwpvHqd7uI0AfNrO8cqvXKRIrIYhKUc8WcG8QDu7tgYRe6GgykGgAWgusIXadvqVYdxGXj+1/vrG3u4g1pvVJ2LYa+Np3gZxO6qCzXmHn28K8qP76S1bLl/BFkW9zETiuUUvSGb2bhvYzM9QChplbjJTWkFe0O3lB2S2Hkq+y9tmG8r1h8NtjLVs5f3mFk0yBBF52mV7dPIMCvB3swcZPlTTbGRgJ2V2wXvir/mekHweNvEeF3e0/l/fnwozz/8F99660f+jf/1m//Q/ziz/8rklOR00ff744fH/+FztPLw6HDbhxRGehvesTOY3p1QjpOuqvfD3ai6mqllWr5cbzZIJW/VhH6gP5uj3hzA79/At/vlFJTtL92/Q5+uAN1t8rW897CMroNpClWsq/47Osd/irPJfJbquoWi/3ImVE2TDYkA5zA6QSeX0PyA6SedFXYKtpyRD3fo80nDSchQssFrTTj/hFcjMbHV64ft2aMPxjMhFFTw3xMOB8X1NQwnQumc0YqjJIrwIybuw4v3rnF/jDCdQ79PsBHPQDQKvrBwzlBOiacXi3IS0Hw+j0uVRANg7VWYKHTA4AsaJPszdmq4rnPp4JSG0JPCB2hMUMagarT+AIWsAlv+s4ZSk2/VucMdfYJP7vzDmGFuVjmPVtEd4huGxI6goW3uO19suk36LGZsq2RW6sAyDsQa2hoq+YENLSaszTglBlzZkyFkdYIcNEyfyqMuSj3T65st/V6wt9sXccXZEOz/zrCtgz2njBE1Q4s9sE6XMSj64DPWbJ7ZSBVbPFjIZh3A5sVZNX95yb093e9/6tD575Lw4vG29/6x1wBAMA/+L++ibsv/4y8fu+7DzfP3/nt4wf3PwhY/uRNH8LhyYhpYTjfobEgzRlAQ4xeX7CVnwZBmwtip0nD+bSgPSzISW/s8UDoQRaBFUAk5utfTJ8/mFBHFWEaeHmdWmue/DXDzkxGjyW8G1zfLhF5RNHBqiBk9ZfrFL+A8wmcXik4A6ITfQRIXVDOmoITt/grLWN957dgEcVhebi+s9bAsOFVZwBpTpjOM5ZUFULBrLx60VXROETc3fYYxggKHkwVdUqoM6PMaQNF3H844+H1gro0jLsOw9ghV8aePPrgUGvFYuEa+nUoI18Ms92yoBad65TS0HUOPmikequibkkTTnlirEr3us6eiK84hybLNk1V9IQYw0VVXZoNvrSCaPSJrFFo8nS1QSV5t7UF0TL4ir12a6wCm6agVn3IY1CAbSVT8lWtqNab3YkabSC6ZkxFtl9bqTwNl4Om2dS/mcLv4AUdAc0RTo1wLCZgWM35RgPOVT+uW3f47nKAafu3Zg2oJJoI6IMeILU9Hl5fbn/61f3gv/vySV9f1R/pcf7RKwAA+N3f/y5+/k//S5zmhdv53dtQlx8/3PVPnr55oHHXYf/sFuQJ83FBGCN2dzv46HXinJQyq7MzzZfPKeP4asZyTkqDGToN1oju4r2WCmGnZN1uZ1N5aANIK0vPA04DNMiFjdG38fm2Q0AeDfvokql0wWWzCmx0C2AYrbqA8xEtnbZpDOesgaPnGemo5TU5uYhBbB/toMPPlizh1249aQ21VLTMmI8L5uOMKkbUKVU1384jRodxFzEcesShg+8CvCdwqji/mnB+yMi5athlZXz0wRkff7iARXB3N2B3020023EMNquii9ORaLuF2Conv7VOoso3IfVKgUDRRFqj02m2ia7ZymEWhViRbTpc8MqG7DyGXY/YRzUqwSo2v07GvVGM9EAhm/jXpNsGFtUZrH54dxWGQeaY5ipIlTGnhvOituUh6udZBUhJUWKLKQwdE7jqQ13M3FTahc3ncPk72IJA11YpOODp6PDiNuJm59EFTRueiyURm24fVrZXuSQFbWB22eBO+vVU4Nx04Bk8MHTqX6gNm87BODOZQb859v6v3Izh9+9u+nYq/Y98APzIR8av/51fx1/6S/+x3H7/26+nN9/+1WM6/qwjvIhduPMEDPsetTgMuwFxDIh9hIjeiHkpoE53n5wFpSoRuIkaNfrBIURNYONa1BUYHCh0ymiLA8h7I/h4Jew+Cks2dI8qZ0Brmi657cZawz9XyIZcB2IaoUFP5QbiBCnLhZNfNKZb1YTBwkATltMCSQ2xi5BMSpJxurevddKQCREsk0WNiw6tRBilFZSl4vxaJb4xRiCSud2ALhBubzvs7zo0IZSZMd8vaNFhPiecHxLgPUIMKKkhLRllqegioYv2ALWqaK+mgZhtI0/abAMAi1Mnmyf00cE7FfO0GuCjgMSpzz6yZik6sgfVQTxQ7funMdsegZzSf1nTldZ2jJxDZY9iLhkHozCxVhhs2wmFvjitJlPbVngimsrTBEiNUaoN/xhYFu3jMzdtCQC46JBMUtya4cLt1nWkluJaGcUyABuram/1da0S3vX1WIXjHQF3g8OLu4jd3mtk+FwxFka48oU5ETATktmGvWEgm9lCalMp8Cr7Lyxm+iE44xnUBuSmw0UlAokI6Pve0a866/0/Wm7wR/kn/FH+0F/+y/81/mZ3mz4AACAASURBVMK//afzfDp/J716/29Ke/jnWmn/PLx3XBuYFabY9Xo7s8lzAZ1qu8GjiSAlgXiP/W3EMOr0OnRR1zqr+o28+vJX3/4auk7dJQl3I+HyY/DmdumbEm9tB6RcyXyvcNqsLYM0gbQFXE6Qslwis9m2BSJ2COkLFzvFgDnvNkyrVF3llVzhxKy3U0XwDg46DFrtYw8PCdO54mbXwTnNJcxV4KShHyJubiP6XcD5VJFS0V086YR8rQ5EBKezrrWGPmLc69eRlwJ4A1daDDY51c4Lm+7B/BK6+RKEYKgq6I6/HzSNN6UKHyKGIWqYZqoI8Bq+6QTijQTkPYJ3aM1rBLhN81l0HVmFN0sLsxKgmsFCuDJKVi9CCA6tsVKk7PqL3qmyL1vkfGINdGmM46wHjok60fU67xDRr93UufBrBXe1319FN9fRXI9C1K3/X/dwXRDc7hx2twEyRE0VKryZgQBF53nYhkAIkaCuRxssZwYWCxRxlmIspCElntTt1xhIReG6m9kUNAVPvzX27m+H4I7F30ll90/vAPjG//oN/MW/+O/L/QfvPjx56+2/Tw/tNzjnd3zwL1qa9c1RlaXeGiu0I6iXvs4FXDQ6KgYPRIdhFzHe9ArnIGfx12RDvR5w0YQ4th/2Nh9Y5bH2MF/EOabJd7Sp8jRYw10x8x/bdNVpl60wKOD5NdryCtKyOQPjZlwR1lhsLqrwi50HhbXj0Kn+csyYHhLmOZuDUJAbsN936LwGU0aTNtc5wwkrV65W5CVDmgaThuDBFZiOVem7c4UIo+scuo7Qx4AYPea5IBe9NfsxKGknaVYeVdkGoY0BTw5wDeQArl69ALQq6PQQaDoVQIgOsdO3SQePEDycd3DMBr4Qtb2ukWB+pSJZfp/osHft5uqqAzB1XTN+YK2MXBvIBEcpVf0+iSbwMAucEBYT7+SFMS8Fp8TWW6uFd4gO8QqhvYaQ6o2vacLrnDeLoHrTJl9N7tkqgWDl+2q39aY5EABPRo+bQ0TrIqqzXEc7kNIW7UVbCIhY7b/Wm9U8Ag4XHNg6FyBbD3oTCuX2KPpL4Oi7+57+xu1N+M7NrquvW48/6j/hj/oH/9u/8j/g3/gZKq6P363B/+95yf+yRHlG59lVF5CSIKaKCA9eGDU0OPKg6MFeBSQd6e459h18p/FdcJ057LCReLXc1kGfIGgFIM6QyhaKuVYH3NRfD1INAF1NotfU22ueik2X1Vab9CWrC+r0GvX8sVqWfQRc1NuiVX3BWNHX647bg+A8g6tgfig4PRRMUzG+YdW5hXfoqgrBa2lozZnzTiuPJmrpBTnc3hDGXnPrzqdypXQT7IaIofdgErRGmOeKaVajztATfNBbxQcVGa1AzNjR1iEBupFw0LKevA6notN3oMhqfHF2OzIcM4LlLuZqyLCgWQ9sXnc9ADxa061PLZZoZBbZVhpaqZauAyy5qgrPxDjSBGlRFR5FK5OTVi41NyypbZFaS7aSvzGqtw2C8/CkhqFSLavQHv5AhNxUuqtiII0Sq1c8/gYg2UDQWaugZbn2/N6QX08Gh64PmJ3yKl0WzFPDfVIRULATqIimJjlZQ0NMn2APtTcOwsr2l+uknyYorAeDJwOyAGdP+GYX3P8xRP8w9EEw4Z/+AfDX/se/hrf//L8qXzr4s9+//OYyvfd/1nP6Mtf6snt6C+8d0mROH3cpPUPv4CMhRr1JfOwMy+UsFbezI7fakMpDELHtfaApLsRisZBs2n538dujWXDnGqrJELbobYGl8IpN+Nk0+llpOpLQljPy+R4oBX7otYQ8z6qZRzGeHqGmhsrGLyzaT5faFFDJgi4G+K7Dg+m5u6AJOa0WpEXx2+I8xAWESHBRIEVVeXe3EV10OM8NuegAz3utZ8bB6fe3NlQxPoIjxF7XY411QkZE8JZb7xzggkcIKmBqTW/H6JR6I9RQqt76lZWPzwLjNArEMYJTgEs1p170HoUJmet2q3sAgYo+OEWTm8jUcq0JyPp8Nvx1zU3JOY21ZSoK/xDWYV4parYpTTDPFaeposnFeBM9QZyDVIarAHtGNii+sCAW2uS4XoDEOv1fVXitCWZLAm4sWKw0D9CDgaFAUCe6ShRTAdIKUwkNDoI0ZXx8anio+rAC+pZoG2JE2YaogrguoWxkFW31B1kJwKs68EIKtm1VIdA/dIRfaoLvtP+PvHeLtXU96/v+z/MevjHGnOuwbbNtKIfQAIFILUhAIGnTBNI2iWilSpGi3PWmuUqrNFIqobZSI7UXSIl60famVW9SlQgRcAveBAw25miCY+NyMGBjYm8fwPu0DnPOMb7vew/P04vneb8x1lbaqsKH7e0hbe21115rrrnmHO/7PYf///cXbU/WA/4kr/gn+c3/4//2fvzP/+3f6KdHf/RiWZ7+M2rzdxSVtxxCDIfrhOPtgnWtSLtgAiEG8pQQUzTGGhEoui9bbC0GbtZLbysAfnb5CT/A1C56+Iv0mws819D1D9gGXNyjI0J4oFmlQsoM9BkqDe14Aykz4jQhHu5BqoLKyZJ1pNsEvZtPobSOtnScThW9NheQCA67gCmboixFQuwdUQl17ljnhuqyr7zf4epqwuFgYpx1EUgHcjb4SF0rmCPSFGzf7s7ILh2t24FFBKZMGxhCBzgmuOsuWFWw3aGqICFwsElz8FLbKEBy7nmb2Bs/2oUjMEkvp2jADiJ0OG/QsbWtWEUzvP3iRMva5Iy9dnSNdEU/Wd9emhiLcFWPvHaJeVObrqtfCKqQAARRMCyBOCpZck5XnJYO8bJe1JSAORiOfu6yafUhChbb47emiM32/qfqjw+vBmSU6GwZmAMa9Lgo7p0sS7GJ4MlNxaMVqETn3/u6AA8Z3x/fWEcmowY3a6PkMgJCnkV92/+iV1KgX95P/KEY6NT4WmuPX7oLAAA+/uIr+qe+4U8fA+8+3MNH38f17uuJ9Wt21wm9BbvhQeAckFNC3u8QxkAPGMbxLRlHW4XyDhz3FpcFep0Osp9jk8SeOVY92AzgHIPtrCpVQFagey8+JLy9OMe/Q+qCPltghraGui5W1qVkA0jtiLsISERd1cvSgtNp3SCUq+vqbYBr6r9SmpV+taLWbuiq1d40ITJSCph2AVdXEfceJhBZC9D7iKM2m+k+s4t3CAEMJkatBX1toMgONWVbvbFuXoWYyC5cZqMFtWYTdh2iEznvusQEOlsrRTarDq77jyluc4RBtR07d1OvWWJzEd1irGwv40/XaglGnci/ZoK6dKx3Da0rKkxDX4oN86DAUi0EdO/bjFrFn5zkkV3dkN04i3OaB9XGwDbFCObkaN7XD9kuNb+AxKLNigB3zfrt5POQ7pAXFjvQbVB3FXitKMqpI7mC8NFJMauJl8aJjRfxD+PtPrYA2zy7A2u3amEo0WmgJOUZ2u8cAj6cIv3MlMLnrvdBZj78SY/vn/wC+If/6y/hp9/zTvnYz//jR4X4A5Hor9S1vD3kGNKeDbapQAwB+bBHPjjJZgxHmiPGndALzubiy1eglICQ3M1hxpaxuhqTffXsqI3O5SEixAOxXQGZ7QIYAm6p0HbayD59nlGOd2hlRoDtu5UNQy7rDGkNbVkg1YzYfS04HSvm08BG2TctxgtgtApOR8NpLWvDWropJSPj3r2MaRcRdxnMwQg50fRySgbBVDH3mjQxticDoiaE6T7VlmrDu9E7x0yIWSDdKqeYyBgASmhzR3MACxEh5uhgC3rGGUleeaUQECa+2KoSmJ0V2A2hFkJAKdUksd17eF/dSu2u9bBxuzZTGVa1Pfw6d8ynhmUVUHQOIBGaKNZusxRtgqbAcURrN/tzqZn0tqpidsGV+QXIfApKiLAnfOuC05DleQqvyjndxwsiHJs58Q6JkIdMxFV+YzswcpiJCHMH2kmQnDNQ9MwbxLaEsjmKsLdvl3FfA3IqQPUgkWHi44tJ1dhGMuMPrzK/a7+Pv51SmBtfKT4Pr/j5+CA//e6fx1eXZY37f+23NHz2vfPd6e0cw9eFHDntjV3HRKaCyzbtN7LtSK1RUArgzcK7c/x28hgutsNLgwvPfvDFIrjpjEXaFHwyyv8V2k7GCRhx1r2ir7Mr/AR1XjAfT1Bl7A87wzC1jr5YiMZ6qlju2pZZV2v1ffooa9UjncjtyTaplyZY17apzmIgXN/LeO5tV+ApWP/vOXbLnWHB17kishlAjkerHNSDNlq12KrAjLVbn8iuSiMGUiakbPv6GCP2+wiCVR21drAScgwgF90YdMRz+LqlDw3ZbmAg+a/tvfvE3nMIiZBzRsrZn8R1U8uFwNhFRlkrTqul7NS1Yz5VL5dNpbeeOpbFzEI5MyIz1tX69xjYvf2ml2hDc+9BGyw2ke8KLF03GEcKViy2zRtgz4s2ZgZbgo+BQ2mcrm5/511wfqgLo9ymYmnCz4hwdNMhVzGH354Gl+9sAhpKwMCOJIO7+/qFhNlbtVFZPUP7AdCVlAgvBab37afwy/cP8cnhMMlL8xXeMBfA//AP/ye88DM/2h/9wa995ukn/vk/XV7++PN8c/qPdvcPb00Ho66E4Ks8z2LT7pbe1kEhmY13ug+KO0vkcU35NkJhU/VZOgv7Hl5cg3bOyCO4L19tDWlhmEdTE9aCvi7Wq7cKVnHd/mrAh2lCmDK0GhhiXVaUteN4V7HMJi3V1iCwdRupuiqs26os2sR8LYLih059TRhEkVPAfsh4R64cAbV11JsKYhO2IFoIh3pWXKsK6TY3iMnAHOK9OZP18XnPSHvbehAJpn1EnhLWeUEpxcAeU0QnK23JdQv29O5nI80I0hqSCR/eiSdeqgLTPiNNE0AJrS+2MvOYbXvK2sU3nypCIKxLx81ddaSWnVzplheIaNN57bpN+BMzKmzQyNFtwaRAOT8WmWjj5DMNtR05w8U0/FB3CrqNmGAo7yrnsE71dN7x9NaLvj8lsu1BVwT/PWrfFDusQqh61v3XEfl9xsHY98fb1e7BH/UcxGTDSRqR3k7/fZYMPHOg30iJX8hT/GwIod61PT5fr/j5+kC/9KsfwL/z57+7vPKJj/zB0vF+Xtc/RxQeTodDmA7XoLzzkl3PXIDeQSkjHK4R9tdb36/j1w3IpkcpQ6M7ynwb0M/hyYox0TfjjoqJTmQ9+gVgqr1yOqLVBiaGxmxxUDA7cnABj7SOMq843ZywrGYYqc3daa2hi6BXe3MU70v3VxlX19kEP2qDsFpt73+42qGWhhgJMSWUYmu3mGw1B2XPSiRXSgYwMe4lC00RHtLpUYorDtceawUgEoOjoa3ta2Zrz14bylpBENu6REbXC72UqHMZ/KBsxii7CVoTm+R3+/128QoiE7QUHNcVd8fF/n+ICCAspaKI4rTays5YgzbLKMWquOBPZragaaxFPFHXhoTVUeFNPAacyaovtbUd+RO0+xYgsi9htiGxsQLVs/doHLh47iDhVVVtZi0mX/OBCI0uBqmWdIewyftpMyEZv8GtvM7qf31Qp4it8oTOLJohUMWZWP7sod+4fyQU6F9eZXrh6hB+6+qQjlMO+uSUPm8XwP9vL8D/0+tXf+n9+IZv/tPgJ38gMe5Okfs9lvr1cUr34uGK0uEeOO3NtjveuRDwtEc8PABPVybfGrbeURNdQJCNyPPMV9eTcAfYQzwC2/FadYGUO2id0ZcFbZ3RSoOqo5ic+S+D+lIqljvj6M+3Zqg5zYbMgih2U8CUI1rtWGbr/8n37dMhY7/z7AAl9Gpo9IfP7XB1vQMFi9DaHzKghBjMoJKyBaDmGLDfB+RdRMjJ1noZmHIE54C0Y0RWE//sA3b7aDl6sCf0ugjK3DbeYe9iIapy7te7nvl0RLAhWvOcQY+v6m6d1fH0VBuETcn2632p4N4x3y14+vSI1pptdMRw4fPa7AnbxeS7q2wEnebY6+4UHgRChe3gAxtLIAGoa8NxNdQYu+GnVUFtZvzpsEm6eFBGIOPwP+P5H+nqfA4TFbH9+xjc1uYbBwAxEHI8w0v0Ir13WIA9n3WbPY22p7hKUPTZxIhtUD3AKO7287eIXTDOA7gM+RwRECB6kgK95/4h/uj9q/zZ/S7VU9uhSHjjXQAA8Cu/8Kv4u//ND0mapttWbl+uy81bieUb8mF/SIdrcDqAOJl9N2RwsKgtzvfAKW8sPgrxwrt/XgNaSi25+8xXeSquzHO0dl0hZTbGXl+BvkBqQV0WtFpNexAtNMMeOx2kAhLBerfi5tGM092K+a7gNHes1cIrYyBc7Y1OW9aKZW1I2Ur6NBl7DwT0buo+qOXeH64SKEfrMfcRh+tkIZDdrrbW7ZBEsoGckAE5VCqYjAycckDK7JHhAvasACJCqxbjJcXmEMH8sC7kIYRoK1c7eO5QDNaq9NagpfmXeag2bS2XcsLhao+UXM4rirY0rLcrytpwe6q4OxYz+Th85Hi7YK4dFNlWd9WCREXV8yKMfbe6x5687s6ZkSfGNJkNeK2Ku6VvsVi929DPMj5sterN+hbJ1encm4+DZ36xs7JUfXDYR96eX4QpMaZkbIrRmrFXCra6J5dJX+zo4SaqCzuvbpblQUIi/x4QYjyjyi6KsDPV5wL8aStAOgXGB3LkH73axY8w49jDtd7WjM/nK+Lz/Prw73wU3/lvfOf62qc+9rFFPvmrWeS7e1mek9IDTxEc7UDbAGZvq7g4eSl1GalF2xNevfTdMCoDybWl4Y74a4vMknKCtgJAINV4g3Vd0btgtw8GXOzd0FurbLiAMnesczUYp6+gMIIhXDi0loK1LogJuHedMe0SBAEdJmFFb6aaCwTliCqE0B3xzeyOO8W8NnA1oEbgYIOptUOrZSIQutOQFXmXwQIIrBVh6UAyHwUHqwiMiUIOy9CNwRhCMKWhtM1e21p3Db6Ld2ICxQSR6opeYxoEcpRYaZDS0Y4Fy6ki7yPKGMqNdB5X6dVAyFDkGNGIDLVVPbKrqUV4VeMKTruANAXsJjt8BLtAEUY6kVUPtZimfvxZxDZYo5Hyg/NTX0UxAprpUsrbFc0L7BjZVCIu7s/BlKTNFYYqevb+j5LcH89CBv5oY/1Jg+Jjb1ejCZ0n+uPzMJGqblUCLkI9Li8ERxlWInzsauKfzIk/GALdAvi8H/7PewUAAL/w3l/Ct337v4n20u/0mKYlJ72fIr4upnQ/7A5k2C43+LBp+jmksz8cz4p+sKEk9Dw61WrKvpF7Lw06ENvVLoC+3BnCqzWUtaA4QJTJJuzr3LDcVtw8WbHMzSbTc0UpbROxkBsyxqqvdcHdsWBtFdfXe9x/cAXmcDaUtL4hvJTsCSGw0m9Kwfr0BtQiqKu9Hff7iJy9R2R16q5p+Lt0H+qRc+k9yJLMYRdCQKSAFICc4Ohs2mYoI6xaxXfmQ4c/6tdqKcHpcIWQJiv/SzHjjgjKWnG8m7HMBXVtmI8FVYBpb/oMbYKdB2y0ahdAF7VsQCLc3RS89njFae5Y5o7T2jGvZgqaEuNwCNgdwnmA6OKjMqvPSWhbiY42cLQ0m31OXEK7IRvdm6AK8ie6dvfxD6VisI/Zm7pDz+k/RbEO159Y5Bj5inVuY3hH26AuBJsD0cWOP0UXXrlSEUxgF2G1bhfKlhD8r+b+C0AvcaAXHuzj/3nYxU9zoFVp0s67N/4FAADve88v4j/7r/87TdP+ppfbz0HWKbB8XUzTPc47opAu/Ppn/LaO6/r1G06VLZIL0oBmh90isptHbC2QcoKUGW05oZUVDBsGlVJdGUcesNFxd1Nwuim4u7UsglYMuNlHaSpnFnxzSWqtHSrAfp9x/8EB05RMHixiOXwwAQ+T77WDzTNiCLZ2C4Ky2lMnsWDKAdMhmuZdBSEo2J16ZglQ1xaoG6js55gJIUXrHcUSbhVnAVJv47DbUFDEhDcjGiyNFVYxTuH+3hUUjPX2hHp3Qi0NS2k4Hgt6MSlvrR3zYnX4tAt2WNe+WWZbtcFdb4IghDo3vPrKjEc3tjJdasfiVuQYCDmY/sEsy7p9nZfFkOOry5sDWwmdIiNEP3BM6Be6D/EFUfAQURH1Yakj493i232gR24wKj776A2YV8Gpn5/EA8U1ObWp+ecR/KJJkRA3X4V9njFaZYJN0HOBQ/P1HsGkv5d0Cj3PDhTAE2Z+T078T6YcfjcnnpUmXcMDfCFeEV+g10f/5WfwZ7/pO1bt6+/Nf/zBH+P5+HWcbv8q58N1CBlKupFjmT38gp6d4mxJPNLPYR7isl61gZdUf/r3gr7MaGVFWX29mH1R2M9xVL0qerGU2lYatIkDGgilWNkfvOy338fIOWAtHSEQcgrIkzV0VcRWgs6ggwSExMjB1nNFFcwBic0P36pVCvsdIVIGMUNTsLFWr1gXU+lFB9DHGM7ioqhmFYa6pt9K+2Ut6L37UNEVcZ5pBzXw5RjwWalqK9ReFMvSkDm4xqBiWRaUaroKUkBrs0omELonchJZuS8e0z0fO/TkJba3Z/OpYT5WPH68bshsuI5+qPaW2iFH+5zyZFLktVql4NIQiLurt/7cWYa9qUd/WeqPepbeGKr1c6eI4EjwseXsjjvrntZjK1aDgIiaPHfkiQYlMDEiAwc2sVYHwN0gKeqQj8uZ9YYdHIaiizhwgMB0JlBsC4nzFmAG0YdioJ+4f4i/NyWe5Qt4+L9gFQAAvOfdP4/v+J4/h+n0qS71eNfK8W2Q8mdCjM/FvCci74fFJ7XugiCHeRg334M0PTgD0u3HIxq7LejLHfpyhCyz0Xk85EKahW50j65iJUgnm5avzQ4Ym998QBqrO9LgQysCMGV7eo8DmVIAxWD8eyaEzOBI4BgAUqQUsN9FswczI2W4v15ADOwOEft9Rkhp1HuQ3lGXjvm2ohfdDCFpZ4EgIfqacjgbicyGu1p/rj6fGHvq3mR7MqmaMi75+qq1jrI0nE4Fp+NqcItdRG8V83FGU8WUginc1o6y9g2sGdiasXU1XFjz3f0yd5yWBhEbqElX3J06llW8VWHsolUda7MtQHFAR3Dg53FuWBaxAk90UywSW2JOTHyWIfsTMxEjMqGTa/Sbp+hsDxZy4ZgdzOD7NXVNgLjTbxzO4JN68jKexh/o1QeFM1OQh07iEjt5QfohvdQs2CGv5xofl52YJ4ULE/3+lPhHdpl/YcrhtcDUlvhWfCFfX7ALAADe8zPvxb/9nV+PREsFp6PKehVj+FrOV/eVMw1pLoewkXnHBTDKfe0VUhcr+bvHgLcZvczo8xFtPkGKIbhFTTxCnKBQ9FZNC1AFfelYjubUq0tDICMZqwjWpW+rr8G7V+/VOJgjEQDSFDFNARSjWTQjYbeziCvxvjMGCzFtHlFNEISoAAlCAKYpI4TkaOqCWs2jUKtRIFMO2O0T4mQfl73f3UQr3VqO7gfZPPvhQqfv6bpC7l4DZHXmYGm4PRUc71bMs4mbpHv0V7NBX4hWv66zPcVbt8iuNkRJYlJebW5XLfbPupqJKCdGHHZX9im85/ihC+Zild9w4omaTmCt4uk4QCNFSnboGkYwKG/bgO59fAxmAirtgtPX7XMd2obBepVt1K7+cLYNgwmpCDEzpuhlfrKv+bhoyA8/NpsEbfv/UWnISO8Z1hX//2MWM7iAY35wGQNuRRJ9jgO9cH8X33nYxU8z06qcvyB9/xftAgCA9/zqH+Bv/73/SkTCk7o8fZR2++c57r4WnHZ+2rfVDdGZBqm9AK1ApULKCinLRveRekQ9HX21JyCOCNFWh0PYEgCI9+11Nantcqpb3BZ8ilurxVy3Js6uZzDbOiq4/p29pD8cEvaHDM4mqgkM5GiEH4hr9pVQpUPUeH+1mnuPyKPBFOirHeAmdSNZmpQ34HA9IftcAGwDPHHRSikmK1b3upfafY01zFWKqADVBi0dfW2oc8PdbcXT2xWngcxqbiHWaLbdZhJkKR0pMEoT3N4VlKaIOYCzKRd7s92+isl1ldxNN0w1I9LKf44CWcS36vYkbv5jcliGsFUBUwpIiYBoXoLDFNDUKo8YCIHNA9HJnuw5MVSARWwzIg49Ue/fRwKPR1LYCtJ1AZ3O/XgMJp/Ou4Bd5q20H/Nmeeaw6+bYkwt3X3cD1Dj85DfD0PyP1qBfmNqYcDnafkTE74mBf3iawu/myLNy1jU8xBf6FfFFeH3yc7e4np+u8fr535GEf1JFdyTy/SHE5+CDLKitb0iNuKjVSMBQ9cn+AmLj/Nd1xbrMxtyngEDB+rvaUNcCBoGEUGabOrdFsM6W1DNAFK0KTlJwmk3pFtjKvi6mzZ6maF56ZiAEqAqmiZGmYMk3VVHmiuPict8E5B2byEQcjzWo4lXBO39ztmYBoNHMOOwuxpwtmpvHiqoKxtem1+brLN2UfhD1oSBD1GyxLIo2F8w3M45zc7Kv4LiY6GW/M0FRUEEX9o8PHG8bemuWCKzWD6+zEZUGLqu7/32EfI65BgdTMMJjy2pxc5KnOw87clTCQoQrMh2ANMVVYkw7ExhtUd9wr74ApepWznexGQO5krA7/LN3M/0Ika//PJJ7EIXFWgp1Cx6NS4DtdDKTlfwDQgvZHuvkdl0M8dLr3tfigibxonWU+ur6BfE2pHvJf9mWXVAoH4PoF1Okf/rgKv5uinwS+uIc/i/aBfD3/s5/gX/0gz+gD+7tbsvafrXVupee35GzfG/KFIjI7fle+vcVus7o9WSsum77fcJiUMm1mJw3RJB0B3IQltuC43EFgxFAmOeK2ZNd7Y2rhloKDGV70i2L7e0P+4RpCliLTZ/zIWFK7JLTCJHmEeKW8Npqw/FmQVk7ONgbmeAGG9i8ITrSmeMQhrAP1QQpBnvSdMszjIkxQNSqCo7Re2D7+0MND9aGJsHfyMwXCskuuHu64HMvnfDq0xXSvMd29Z9KwNTYUdoRfbzhu4uohCC31VRya0dIhCom423F6tcyIqykgdh6603xpAAAIABJREFUaIq2WVCX8yr07HAkIAcGdULNgl0ICMXiuu9dJ1AkHOfmq9QhGBIfCvpMINhKto4Yc0/hqY5o42DDNWbaiME+O7Y8yUDYZeMwsgLJtwI61okjUcwvmX6+AxDZtlO96zMHX53wo+rOUTpreIemn3lLC9twFeL0IX/mzQL6UAz8I1f7+Os58i0RMH+RDv8X7QIAgL//Qz+Ff/SD/4FOKdzGOL2fQ/i6UNtzkfGtxMT2xWFb89UVfV3Ry2IHDwCJ5ev1LhYsoooAResV810DCWM9NRyfVn9CGdVG1fbMzSOperOePPosNkXCuhrpJsSErPZE4MwIk/sQmm0HmihoNdrPslaUKggpYMpmveXMiJk3Ak70YdLoAYmMia9qfW33NRQHthSknH2YZBcPBYK0hnSa0Wu1/r+PdZ4TdkQRuIE7UJaCJ09mvPTagid3FSkxHuxNJ7AUweNbsZaFTVTUQRB0BFZMkRGUNv6e+t9X/M/pqwuwbAOIUq3nryoIgZGHSAcWfBmiHazWDOWtPtwLzjYIAhwcDntU2wpsxqNNMmyXQjVcrn0+HgbbRyYf0WbAGbMFIyfopvILrpwUFSQmJCVQMQZBcCz6qHLEXUKbDpUN7nmp1hmy3UDnw/+Mhl/OcpY27lfoM0O/JqhE9Pu7xO/KiT9w7yq/lgLVuRC+mK/4xfzD/v4PvYCffOF/lz6/+mp98tGfRLl7R+/1oap+tfEjG6QWoNrUX6RBulN8ekOZZ6yzHfCcIpQsPfV07JC1GmBy7ei1YtWK0gW7Q0bOCQ2OgvLBE1FHjmwhG8NNJr7OG2Ia7sbD74q62gK5islEewfSLmG3D56vp0h79vx4X/m4aYmV0LSbJiBGn9i7HiBHpJTBeYe4uzKBVPCnfwjQ3pAPBb2uqMsM4AnqOkO6oLeK3s0B2VrHzZMZr7y2oq6C+7uAhw8z3nI/o1fBy48LXruxSytFA4QMY0pgo9IQYyMY2YE5m4OUbDsRXJzDbPANKab758hbbHZMLrQRoKzdzT6KlBmTpSTYk7CavqLPAiqCPAWUoFgdLKJkWG+ly0Qe3YAZ6OfcwcEyCGFwHn2gNy4i8fCRxIhESGSf06ad8Mi0MeFXpbN5zb+fm/y4W2WCSyffKP0dCMob1+8sy1ZscwEB6EVm+qnrXfj5KYeXtUuj6Rpr3795LwAA+NQfv4qv/6qpSgyfUrp6Zzs9+Rpp8gOB8RyoU3dOALmff4AwpatRdUrb1IHicVbqQ566Wr5crw11WXBcG+6rYj9Fx4ydU2ys9/OIqhxc7mtBmSkFSFOURaEkqI3Rm1F74eusEG1glCdyg8eZBjSUYRTsWcQWdm+lvV8KrXSXpQbEKYPSZKyEsIdy9gm2pwlNQOwNsZxAIWE93qKVGbXdoazFsvWWiidPC27vGvaZ8PBewtueP+DeczsbHPIR89JwXM48RGYyLBXZ5KyCrfphILBulllx4klKZl7S4FyGxWR43TUBvY/pvk3fq9owsHVFVwsPDVWwFlPc0CJ4euq4OVbsGDjkAETGLN1y8gIZ88/RYwzbbAjpFj5kdCVbzQXX/DOfGQlmerJUnuCKwQKg+WHungvQfNYQPZtPXd3ZcV4rklNBGVZ59QEOHevF5jHf/jC5BK1c0IUFik8GpnfFwD/NgT/BREtH1Mfr/ot9HL/4F8B/+rf/cwDAC+/6X9r86BO/XeW1H2btV6r0lwPJcySFpC2QXiDdfPtWAXQDekiDglEdRNGaoa0yGyATbt5oGJP8AOVsfWqs/vS4mMZGQsjRzC7VE3ODPbnm1bz55A1eYCAn2ozeQxmmqtDqajSIiV/IUFQheDpyUbRSUVzEc3Y7nkfBxBaJpur4LQ7W3xOBQgNTQLofwOmAcnqCdS5Yl2L79KF3F8E+RVw/t8P9t11hd2/annStCT77xyecipftiZB2tuEwcrmDOruezS0AqrseD5HM5AM36BQ7KK0b049h/X7rHuYh6q5LW0fWKpsTj13j//hpwU1VPLyKmzBU2Xz7cD++ynmCTw5+Eyd+KPvBx9m9yGFYSZwcdOE+XP3zldcLz7YS3lKA6shI9AHeaAtw3iZumwC4aKy1s8EIr9P723AV0gUvEvNPhkDvjIF+d60y5zzpGp7Dl+IV8SV6vfjSjMPNy4tW+bWYNJpSq/9l1OW5Xm5JWoEoGTdAOnqpqKVuOKpBcRlRrRoMpInxjRfFfsrYH3ZGF4Yi7xJQO9pqwRMp2SUR+Rz3XLtCVhssttJNdZd1s3eyKIrn5U2RbeotdpEw2ZvTBkSeB+9pOArb4S+nBSkbFCQODqIIyCyAVkn0Zt8aYg86VZAIFAxOVzbiVMF0uMPp7gRxhj2xP42bIk0B+6uMtM8QuDuvCW7vGuZHKyKbwm43BSgpZljNPtobGWh2/1qLACXKtuNfiukByIEkixqpKCbGKh3FRVUBvkbzQxwSgzMBq1VU11cJOybcu45IVxFzEyARosdjNdfjjydpiIwdWRUQVIwWF3lb49pcwD9vXzs2WPCe+M+N95AxJHSbGXQ1tNellmDc/OQVg445hOBiZT0QZWem3zj0Q4RkBDJ6CUQ/mxO/az/xRwm4bRp0+RId/i/pBfB3/pO/i//+v/wP9d51vgX4VxCFFAqt7ft6WR9Kb8QxgzhCWkVvhsdqXZFHn+fyqlLtG5ZixD6dnwAAgWPyvDp782Sf4ofowygmsHgvWm10O8IqtHVMZIBxcrWikIAZyBMh7SOqNpMdJ7cD69kW2rtA0cDx/GVu7r/PPDl3UCDcQWRBodwXmNB9AtjKTYxMA/HLJCaE3Q67wx4pJ6yzOR1VbOpfq6AcK9pptRzBfDGldpEKBzqLbfxpH8hK6bULarUBKUdrtUoT3J0UzcMqqi/SD5NVM63af3dySfCGbzsDRNlNMvBSPGTG4RARs80dChSLiMVsBTJ8uKjPF6yKiYk9r6+Dd3YwO415wLkF602N0JMjoiPPKEawdNQ6XH8Xw0bFORZM9Swe8jAQXwdY5LuH/G29v5oacVOxO/qsn4eGInb43xsDvXC1Dx/ZZ74lkCzpeXwpX19wIdD/2+vdv/wxfN/3fBNSCgXAS4A8qsenb+vL3dcQNHOIxMGhF7U6X68jhAiVYPHUvaP2Ztw3Uj8wJuZJiXHYs6er2s58ita3570dAhrhD00gLNjtI3YZBrLoQJoCciKEpOAIhGxT7rQLoJzQVdD1rKDr3ViBcMGKujFljImHimz0muK5BN3LyLHjhz85TXmmHuNFW1lO6OhlwXI6oq0VbbHkoLUZmBPd4sZLFdS54ubxjJdfOuLx42KZg5kRdwb9rO54y4HAQ1nnQiliO9Rj0j3AF2N3HpPp+JdieXyiakGe/YwlHxpZjma5HU9rRIYkQmNb+c2LGYZUrVIgscM4vn6BCbudXaalCSQauKN3G+KNqmtUKBWEsMuOPVdwtjjyXk081D30s3T7d5MzwEMu+vcBsNFuM6eBLTf1n4WOjoTfMTxtglFFCIheUqKfjYHeeZjChx/em15NkUvXiMb7r9wL4NlLIJa2LC+Vm1dP2urzkP52aJ/Yd9W1FNS1bgehFkVb7SmV94y8Z3C0MrvWDoVJb/e7gClZecYsyJmAKNBgoIre2ARFEFAUHA4BVzv/OQWmXUCcAIoCzmQ8A7Y3nnnVTUgEmDiougMvxoDEBuwwSjFvsAiIJ+f6Ss928KYOZJeHjMk2x2xBo/A9uwoYAtKGMp+wHM35WEtDqwKOlrpUquLW7c5Pnyx4/GjBzW1FFYv7ipOlBHX3QKivz5qqgUcTYYrmc6DgP2bbBoTR13uiTem2jRnhH73qeVAa2WGX6gIsO3iBCZxMJLO6lFeqzU9CDthPARPR9pSGz0g4sYuFLhgAvt0BnLm3Ckq30j0FgoZgNmixdqsU2YxLwzhUu6L2cy7gKPE3P18Xk5Q33dKCbQ5gB/5y6HcB9hQieolAPxsD/9i9Q/yNwy68xkQ17a5wJ/fwpX59yS+Ay0ug3LxU6np8mYnvVOQbIP1rCJ1tA2BwkMABpJYsDCh21zvce+sDXD24j/3VtcEzWIyvr92JMj4Ech99FYuRNsUWb+WzQsBsqsDerA/eXdkFo6TPTILED/+Q5ko3q6+STfbZVWfmMLSnWPcYsLJUzKcCqR3ogjj6Vu1Aq843aIB2MJvNuBdjG6BXoBe05Q7r8RbL3R3WebEn8FA0+iS/ihpaywM5FEDMFkACPhvRm55LYbC581JiHHLwlaFu1lbbgVv5zDBwxyW/engqUraPMWwdwwM/0op4rBPJe+cxH/CqIkWr4gZCbGhnuwuRxlyhFTHhDdvmpnfnAbiRiAa+qxv/sDXBWs627X4h2R1qPfV8AfWUjo3K7JdR07Ou//XO9YEP81XfSwp6bwj0znuH+Bu7zK8x06qI+kY4/G+YC2BcAn/+WzOYsfQuL0lrE6F/k/T2sBUhdBP3JApWEgaLDNjfu8LVW5/H7sFbka8eYHd9H7v9HjkGqHQc5xV3d93kuAKIBkM8OQoMYjALGxXZE7z7N56JjLUfn92Jj3+PRBzLejMzUkpsYh941LSjw8ldf9IE9a7gyWsnLHNFXao9WUpDXQpkLWilQNYVsi7QckJfT+jzEX25g6wn1OUWp6ePMd88xXI8YT6uWIoN3gzT7ZBNV6BNkx/6SJ5OfHajBRfvjJVaTqbDjz4jiEyYi6A08V9nHteU2MAfQ0JLQGCrjkbYScxO0hfYgQ5WRXAgaHDNBBGKKpRtHZtS2Nj51dWAxO4G3HpsayPqahsF+3ax2XwVkMBuArIqzXITBOoPkrXIdujbZYWBcybfdjF4a1Bd5SiDFaC4DJZ/5hKxRDEb+IVA7zxM/H8dduEVZlpBUZfwFrxRXhFvoNc/+Mcv4h/8x98gaKdXIe1dPeMBq/wtLfKNAcy7HFwey9jvkodZqt0E+b6l40RFCldAuLZwkfgynj56ir40LCshqPW+HRXaCAxBiBZFTQw0dAgEwWJy7WC57DW6JwBkT74Yg5eerjqL7tpT9am/bOz9dbX8vKgMrYq7pxWl2awgpxnJI2PyZMrCq0NGTAYJjbsJIYXt8ildsK4Fy6ngdLcYxkwUtQhksTitJnYJEFwKHMwhZaEThLKapz9OERuTg8im9urWYT077CzcxZDsSIxpCmD1vrvThuk6DFNNZCxVbP/fHbLp6TxGSvJZjepmqY2+Ii2luu/fNgnRP56S/XcvFiC6VqusEimkWsKQDGWeWiy9+rqw+/pvHOZxeKtbiIMf5LbZqsfhPicd8QWzP1wc/E3aa1VBJaZPBaL3BaafuH8VP7hL/ITpjXf433AXwLgEfvBv3O8x4ON3C36YpSOq/K0k+o2JEktMqF2QKNhwp1TU0wlh6lAK/o3foaWM9GCPh1NEnAKOj29xfFKgUgB1eo8KYghIKSJwBEdFo+b6cGsJerPI58gEjbrlNtF0HtIN0OZWIou1FKV2K6FVcbxb0QthH9PgS+P21LCusmnOF+fl7xLj3rWFg2bvhw/7gOSquMGkW9duDsdqk3MdGvmqG2SziT35WK3nD8yG+ypGNwoHe2JT6yirHehSbQbBibYknYG4kuGI8aSiLgoN5wFnSubm8xzM7Wsi4wANMMlIxe1ATlbVxehw1WLmJ0rJtjbAdhkMQU3v1rczkcmgPeOP03AACqTqtgGqvh7tY7Doh7f5ilPYeH9DYrz18548MaqmwfR368Uo98dm4wTQJ5To50Kgnz7swm8/uM6vqWprnd9wh/8N1QJcvn7l91b8hW+dBMATgD4bAnFQ/dpI+pCCUq0NUkwB2KtFdHOaQGnyPtRK/biLCDuT2uYUwDB8mKJvyKiUrEwVAkL2sAaf6IRgfezoj2lTJp57WsD6zCH91CFNrQ3rYlJdqYJyV3C6sZVhCObBb02MkSc2gLpdm3HzSsdxFjw9Vrz2tODpTcFybJiXjqd3FTd3FbdzxXzqBufwwyEwXz5E8dYHGQ8eTkhTAHcTzijZCrQsgqUKpsS4vk7IezMGtWqDstHHBh+yNa8ghM7OuoGzZrcLk2PPYgrQEFC6JR8HtlapbtRbqxZSDl51sa8qzQfBRGi+7hWn8ajYE797G9K9lC/NNyNih7/rBX3Ip/yrD+2qXxgbenvIdi/juP3n1eW8tvmgTcPf/ND3i69R37Df6DHQ76ZI/0cM/LOHXfjIW+5Pr+2mUDnucSv38UZ8vSEvgHEJ/FvfNgkTPVHFZ0nRVPAOEbwFqoxuVhaVjlpXE+dNEzgm/4ao950JHHbI085krCRAKfZGGWW/dAjrhnaSsVN38Ka4+CO4L33AJ2kgqIfRQ2QbKPalYp6bCY5UUY4Nrz2ecZoLhCzwEwrczR1LMdVcdJZgYHtyr8X+Gez6qoql+poNuoWIqjjv0M03rMBzVxFX18nsqEvH6dQsp57IGAqRsD9EpMwmuOk2hRenFjfoRjBOySTCa7fNSc6MlCNCisjThDztocnETTmT49JsPpATo7Xu4Zd0Zu67lFoHKJ+DOz/NxGUXp7kgSzXRUXfff2s+iHOC7wbjcAGWdruo1qZY2hjePQvvkH7O/BuCoY0B4ByAPkxcw8Un50PfzxhfFaAGpo/uEr1zn/mFKYfff8v93ePdFJpgwqN1jzfq6w17AWyVwLdNAtDjrvzJ3rjW2r+6S3vAhBA5EKeE1gXrvBg6KmfElJ1953l3FBHyhHTISDmh14KyFvv/TnlVn+cSbEOA7mutLfraKoLovTq54kO6ee0higAGKUFbw83NiuNtsd5eCDdPC15+tOCVxyuOc/f0YMXtseO2dBAD96aAKdtTk8l08FNi7CezC3OkjVuQnBvoXikgmGBlyFRdeoZWBcupYV4F+4MRjTrZTj4mK+Fb6dCmWzrP9kQkm+ZPO0u2rNXK990hIk0W3LpLe4SwQ0WEkiCyeFwakILxC1Z3DjKzl+S2UREnLWtXpyIZ5Ui8Ae8e/FlKx1KxgVGa0ibvHb362A4oLGyzNmw8Qrn4twy7rv/caFWa0vZrOs7rPSN1nr+uA/fnSm4lwmMFfShG+rGrid8toI8HpqcP7k3yRj/8b/gLYFwC3/PNkxLRrRA+XaQ9XUu7L1WeA3iiKZISUOcFLM2eLDkjpAyTtZgAiEJCyBlx2tmQbrGIMHmdDlxGpr2ep/jsh+4c+cLbGqo2wXrq6EvFxAFRgXJc8corM9a7Blbgya3g0c2K27nibja67t2p47g0FCfVBFgMdvTh4xQZu2wXwmEf3WLL7jy0PL3BSc3JbGkbn45NCHN72yCLJewgEnaHCCRGUd0kq+JPUbrg521puAGIPuXXS0hGio5JswgzkJOJ1TiMy2KmLG2GCm9K2wATvjocW5S19m1zURZrabpz+3QLLHGMmG8uivMdxlDvUqsv4od5NOejOhD1ZCJf/fnKrgpQlVzENNoAnL3+3lK2i1WnT/6bEn2OmX45BfrRGOl9xPwigFtB0BLfirknvNFfb/gLAADe/9EV3/tnJo1Tuk27w4t3t+sf9d6lqjzsvd8nKEvpWOcVy7y4Dzwj5gkUM2gkRahdBgENaEeUWjcU+fb9dSJwd4It+cSficyC263hE7USlUXRjh1PHp2wnArm2xWPHs14+VFBCECOhKe3Ba89LShiw8TgB6160m4KZHBKgl8AFvjBwWPHkpXLDHLPgSefd8X1xLi+iuBA6M6yTu5y7G5jjZlA2S4XdRhKDufPgwOdZxo0OAD29Gcik/0KkFwTb09bIxQ3bRCtaL2il4rZMwGHIKtUcXY+bQSjDWQCj0B3L34rNnQ1jcbZRksyCEA2yCtV4N3BZu8ehqrWrYUTl4ivDg4ZLYC+bmdfB7ZLz3FipOe13tDyjzWpXxJVQJ8gpvfEwC/kyL8RA38WhDviqNP9t+PL5fVlcQGMS+CvfNfz2hWnl16+efH6we5jtcnae3+bdnlQi4Z5FpqPK1pZECDG4ndeHmHUgRUod1jnW6xrsVLey3wiMiho4I2iE3P0QZZYktDSthlAORZo7ZDa8eqrC/741RmPbwteu2u4XTt2u4C33J8gXfDkrlpZzwGRrc9nJmSn5naHWyQmIw4P8xGd/fk8hlHVBnkRiuceZuSrhA5gnjvWRZECY5/t0uNEyIe49dwUGeTocrjMdvD1arNtwpAxj7VrqQKQDUS1C05LR1dbCfZuh3JdG0ptKK4qHAxOFdmCNeG4se4XbKtDt2DyXMsuuPBSXOQInlbBzSKYqycyn8vwLUSqdXcyqi0SFq8W5Ly82Vh8AnPujUuBRCFqw+CB6n49tts1mjMx/W4K9M9ypJ+ZEn2Emf6YvgwP/xtyDfj/tSJ8bpr12//1PL/97Yffi7y7Qa+vHJfyN6nRdwQKD0BC6+mIJ698FiJHXD/3NuTrhwhpcknngvX4BKfjjLK2s3XTM6JDsOn0oMIOYUqtHXVpON1VxLUjJMbpyWp5ASDczR13S99in0sTPLltuNoV1CpIwQ5793gp+I4+ZUv23athzCIByoruiUADIxVgJX9pgrkKehXEQ0TYRwgzSquoKlDnEhjN1kp/yZ6H6Cq+QLaSKy7fjcnSiVszk9M+B1Q58/K7EDRGWz/WZvFkEUhqMe9FgOqCp8vXiLwGqWPAxaqJMYVvZ+BG7y6zbQAc8VWb6TJIFHerYKk6PDmmziML5xjZh9VLe1FblVaQx4fpM7JeVd9KXNB54WSh7pXA0PbbWpcAgjDhCRM+tM/001PiXyfmT+0yv7ZWWbqGL7vD/2V3AQDA43WPX/g94Lu+hVue4qdjvP7xO5lfae34N5nbX5wmfj4E4rYW3Lz6CG2esb/3CGm/BzOjlYLTzQ1ONyfU2kBO/DVPf0dPFuQRI5y2g80Ciq44HhvK0wLObNDRU/dZgD15xwAtqGA+VXzmJUWO9pQ/7IO9ycjewBCTv6bJFHrongkA+BTePu5aFclDTdYiQDDScJy8WvHx9CEH6OQZepEx5WRZAgA4BQvJcPpvbcB66qiqWJPp40Mws82UAk5Lw+OjsQbizib8rZvhJydHoBFQen+mXx6gEVFFbTYLIN9OdE8OAsYAT0db7U9636s76qyMLD3PE7gcHvYOk2cTORrOh7GbKs9+7Qji2FBdOE/zB2SUxspPnw2msqc+KRFmDvhMIHyIiX6Gmf9FzuFz14d8J11aStOX1NL7FdEC/Ktagu//rud1f3V/3j/3tZ959dHdZ9BnTIm/ihT3RzRbbw1lWbGeTijzCcebO8zHBVKb75P70LHamzfwpuaDu9ssXBPgKjjdVayroDbB8dSxeI8bxxDO99SBCIccEDzKKgdzEHIavb2X9cEm8uT5ceNAjKw7gk3fRyksorg6BOymgP0hYrcPEJAn3DpolAHKAYcHV7jaZ6B1H/RZa1NXCyJZFnsijxVjjIQ0RSgY80lwnKut9nYJMRAgRrQIHt5ZhbDUjhHi7lt5MHx1N7eNJsTjpHVs4R0DmS1ihiDxnL/abMdfZTg17TIAbZGG29eKvO9fqjrV57y3Bzbmp4l4zt58X3Ge14CXjP/tUlJSJpxyxG+HQC+EwC/kxL/FTH8UI988vDd1Tnu8UXT9X1EXAAD84m8+xV//975XY5rKH378k5977mH4BBRrKe2rVfQtKTCH6E/d1tFKg5Rq8lO1aG5pAo4BIbkwxafTrRpXv6wd2u3JVZeGMhtLcL+PWNaOtQruHSJyMtrMcPztc8AusR8Amy10H2aJD97g2OgR/wU5Z9dbYpIN3mqxy8gfeLi+sq1ASoyQAzQxrq8zcg72+7sAMeD6wT0cdhPW0lB7N5UdCIGs7C4C7O8lTIeENlZvYCyNsaxiPEYO0MCg3lHX5v4CgiiZe64L4oUPPvq8ZD41rJ4dyN5nNTfrWNiITevh4qpS/NB3QW2m7OsCawNc7x+Itj5/bBVsOOgGJb3o2QWb1XtbAY7efmP+X+gAhk5Ax4CQRAkvBcav7xL/5D7zL+QU/uBqF14SxalJ0DW8FcuXwaT/TXsBAMDP/srH8IEP/Q5yWts3vOPqEYfwidr0jgj3Q+A9Me1jYmKyNFtmmI8gxXOoG5u0bXj0S7MDv3gcNlRxOlY8vbE1nijhMAUzlxQ16+pVNBWhx05NwabnTXyyH2zV1Lo4UcwJQoGQ2dOIOrCuNhRrPglnTwPObqtlJuz2ATx5bmBgNBD2+4T7h7Sl9Bp9J2JKEdLFQCRdoGJQUBBBIuP6/oSUDIeuqugU0DhYqAcEtVq+QCkO9wShgcyP7xuTgQTrTcBQzEUxz20rZXo1WGtxOGgXYO126NrQK3SrAsbBx/Z01o3HT5cH1Xv5xZN/6eIwjyzAMRiUod7DebIvFzt99dAOa/hIlWgOAR+NTD8XI/94jvT+3RRfvH+dHgeikvJOsX8r3gyv+Gb4SzxZd/i1jwN/4c9y4xQ+ff3Wqx9J1D7eTvNfnUv9/l2gbyKiqYoSCIgxYreLiB04HitqKViHwbwL5qXaeq9abNiy2n76eNdxmjsSkyG6XHxSPOTiLSnjSSuoZL58EDAFxpRtZdbZVHja7cmFAPRFwQk47I35X5yUqwJMmTEFwtV1BBNtLPs0GTwz+v1V1451bbg3WVS3QNHWhqevPkWoq80E1Cb1tXTbatioH9VtxOSocjO/wLIOI0NXO8BNFY2A7M1x69b6tNLRiiv9us0HGmHr71u3iqY0uygCnf33Yz/PhM33/7o5Imiz7QyPvn3NB7ew+k3Bep4ljHXekOySP+1l20acL4nLl88NX4mM39pnem8K/AEO/Il95leVaDnsklaZ8KTs8GZ5fdlXAJevX/voiu/7ruf1sM8nRv/UWvtHuuojBd4C4G21tLR2JTDbwC5E9JHT12XrS2tX1KWhroLl1DHPdgnMi2zs+K4WOlH86RI8qw5ervJkuK1dtn7d1HtGuVFPCZZaLrMwAAATbUlEQVRuDj4F4ZACMgNdxfBmKeBwFXH1IOPedcL+OiMeEuIuuOzX+XbV4s57t993WhpK6c7ysxani2IVwlrFduPNpvbG2O9oa4M0uwSMkmurzdY61s3SDE/AoYsJv2JZOtbSsS6Ctdpk3hBmdsmVYjv7NnL7HNJZHdjZXac/lHnPrhHs113GcY0V4IByXAZtjliwMUsYSK8OG7wOrUCHx3RdMFlBdOKA3w9MP5ci/3hg+kBK4ZMP7+dXA1PhkPVGHmLpEW+m15vqAgCAX/qtp3jvh5/gO/5U6CGGm+nq6sUQw0sqEluXvXY5oEtoXUm6q/rcQVSabE+NtXSUU8N66phnOzjd0Vn2lbO90AjKWIuVuCCyabQz9iMRcmYEsvTZVt244oz4MW1mAg6ZcT0FXF0nPLyfce9+QthH5ByxvzJ1Iwhoa9suoupJvXPpOBX7sSrAk+3+IYq52OE0F16AcPBVWvc5iC3tawcW8QzAtVlJ7kYb8rK7uU23FCvrWx3JS4rSbJg4fPel6jbAG8KqPmKxXLu/ATRxocO/OPTNYS7jx+PJPzYPpFsGh88wzvbcQVVqFyW/YJT7AIG0g6oSfTowPnCV6Sf3md895fCR/RQ+o8DtWx7sOuIVjnqNN+PrTXcBXFYDf+k7n9dpSqcnt6dPKvQjhPBIBVprn9ba72nrrMUhHK2jrtUGhb6uarWjNd2CLWIiWxs6yEJg4ZZ6sfPW4ZgTXx+6VdjmA8DpaNLXIcy5/FirCKZoFuCrXTTKcWCkXUQIAVPMSJGxLgUkimmKKD5XsNWa2BQ8Bs8YBKS5ZLY5L9GBHjHYsPNUbCAHtt148c+7i7r7zWO0VA1m0tQiw1c35wz1nFckQ2e/+lCvXBB35OJg9otfex7E2SVk7QIuPp5CxWYo9XXDOlxeIHSB89KLcA69PPg0PAMVhJeV8Jsx0E/lSO9iog9POXziwf38amQqKe/1Rh5gfZM99b8iLgAA+OXfeooPfuRlPH56rN/4Nfce3f+qb/y9kKffnpfl8br2+9r6vb60LE0okOXNL6eKdmzQKqhiE+nBo4vJlHUUzkCJ0UsmZiCYe46ZtuTHJmqQCbZh1zzb9GuXDH4RA28+g6WayKcs3abwTQzvFSxuLJKlBTeLm0FKAcqW3Mt2hgEyeAYHwro01LVZwlCIdhFUoxKzr9vmapHqgW0t2bbASzfrtLM0uhS7FMWf6LWOA+zUYbKZxfDOE5yo7IarQROuF068emHL3cI29fzfw5wzBnhVzwm8W1tw8fP6ukPfYNsG8WkC2RLjFLzczzbk+7UU+UVm+mwI/PQtD3ZdwzVOeoU3++tNfQEAwNojXrqJ+Ot/7S/JV73jHUs53b6s2n6/1/5im4uo6AGqDx/c2/Fzzx1AIaIVE/HMHhcVh4x2ZL+DbNceLD12TPMtCFKHhhchn+PBmj+p6molchjmG3L+nCOtm+Np1mLlNfv2oJaG27sFt7crqo5puZr/HrTNAdRPzuDg1SZQsihzdWJx7wYrqe6hhyqil9HV/fNQc0XWKqjFAz3cftzFdPbVU3mFGKzADnZJCUxay2phTL1bdVH7EOE82/5cuvTwzCrO5wO+eeju2OMxH1CgES7DNjef/vgwTTeghwbSOTB9OgR88JDpJ3Kkd4dAH713SJ+92sdXW5cFPOnKz2GViK+E15v+Ahiv9/3zP8QL7/t9fPe3THJ9PZ1eefXuUzHxbyrw0rLUvRBP6TBd3bu/42kfoK3j9rZt5bUx8x1v7cBJOHdOyH4cXBDEgRAzI0aj0k4jsKQB82LrtOJkmioG5xjimhQJV9cJ0yHaBJsJnckgISfLRpBhYXZHYvb13nHpFtHlLsXmlF11ArGKE39Gib40Ozwe/W0luE3rqQp66TY/WNVsx75rHxN99naIVBGbzQEenzqOi/3Zt4vgyWz8PTCw9gua78VKblwsZw+BnvX3cjEb0PPEv3drV7qvB4Fh7jEfP2/SCupEmCPj08T0Gxzop2PknyCiDyv044HplcMuLm99sOtx9wA93sNX0ov+4rd/O77SXtep4u33C/7ad39VOD09Hv7oj2++JYJ+4G0Pp+97/vmrb354b3pHu5vDZ/7oiNeeFnQyLX7wN2xKxtM/dXGjDJAjYwps3DxYJLhlxBtoRAGsi+DxY/cGZEZIhOSpQXGDcbKt/aaA21NFgFUgcjEpE8AkwCDoKnjAlszz8rGCGNjtgnMIu2G2A1mWnR/uquYpWN27kMnVc8HCOIMCuhqMZHaaD3ml0LtVCKY29ouoKaQIniwC80oplAlFgCkA97I9hWe5iNO6eMoXHzKyfx7FW5Dh8/cc0E26N4Q+bfT9Mvz7Z8c2kyqAIqBPBcbHAtMHY6B/QcBn9xO/HAM9vj21NeSDXD98G75SX1+RF8B4HWLFw3zCA1rjVeQHu4m/+f717t9/x/3p371O8i1Pj+VtN3ctpMkO4Lx0KBT7HLAPjGP3oEsf9A3lXnSrKwAstaNXU/DV1lGLuf6yo7mT9xW1C/YHg+vFRKBkgRMEIEYz6AQ2ie28dqNRCNAWQey2kpwZiJmwz+bSOy3dDrkfoOL9/FjhjRYjRUZ122yerF1YTv93e2fXI9mRlOE3IjPPqY+u/rCZcduzYK/XtrQX4N0F7QUgLrjgCvEr+C38F+64RsJcgFYCaVfrNYu9tsR4GH9MT7f7o7qqTp2TGRFcZOapWgutABnB7lRKrVb3aKrVXScjIyPeeF5F3GZQiRUNQixBpFbu60kuySBD7vc7JijnthspEFwmOG+TYSiWY/pLbbsM+OAypGTIQ0k1U0i0B+GQ3QivjVkEFYVftmXjfCtZAvhKgafe0T80nv6JgS+mLV94RzdmGI6mXhPPLfIcL/LyL/Ivv0kBm3SCS92kYKvrV+fy423kTzzhvaWTP1+t4x965jcXwb9ipB4EdL0giqFtcmrPLvvYiQKblL0IHNM4XFO1BQ75dJ03VHj6xfE2Zb4+BzeqBWMUkGQACHEZkkmaoR9F+y7F234gw1o0b1QwfGmjbZNhXZBidZhJCuYMyK0+2+vnR8v/R0zyCLBYcQmuVmDVPKRM25XWHBd6sFIOVFyuQA75zt8V08wRwFleo6r8sEfUZZf/FobizWcF1okd0sv26D3YKxkYkJhw7wnPmel9IrxPTD9jwufzli8c0w0Iw3ziNfHCOp7isF7wAFBX5BkiZvZk08Xnm9X1Syfun9e9/OJmlf5mMWn/LGzpT4OzNww4FbFFEmXHxVk3MNoJAQlI253PXIqKYcgz6E2T+XguZPGJxKx5z66+WTY8aRgcsq5gSFTUekUn3+fOQL56ZP1B1DzzLgAk7IAbJoZeDV1U9AX9raUNmMV/tgNnlB3FxRzVyuhv7XKgVNiLTCD322kPjIq8qYdyMvdFDUiV1FM5/cDOXLW8RubwFwiJ7ukAij6ibvixLriXNdSP8noKwh2RfeGZPvCMn7ocAJ5NW37ORDdUNn7kY+t4cnjgDwHgP1+Jp7jH1N77t35o9O7qfG63zPbJINu/FU1/DLN3g9r3TPBo6PVkNg/sZy4/1MWY0wpfkJmQ+iyXFTb0ULTFGCOJFVIOxloAXJ4IzF7deWMwCqq6ymmjwjuGlTkDVUPjacRmeZc/r7qUxTt7XnVF+ftLfHxCNieNg5WZhBKgqsquHMPVOahxxe2oBg/CaMw69uRlj9VXtAR1rp5KcY7oa4YcFfVVW4MAYpkSNPm6gXd5qwj3jnDnCLcg+sgYP2HCTxrPn89ad2tmd0w0zCZOB3dqHTWHB/wQAP6rgaBF4of2ZDvEZ+vb6/O5/ZjIPu4HvBYI3595+6PJgO8p4dUWdkItLwhg0WKqSYRp40GQssE0p8EwtEWgk5gw8QQXCNxwrpBvNfvXq6ElwnTC4zixaLlSmI20YFaDBoYwZQvtmIt7m07gmeAnDqYGlt09WrX6+AFMZXMD8AZ422nuqzWWWT7hgcwoUMNuNt+APhbeQAkeZjaCNurgDtc03jJCnRjoy9Hu9iW8tvMQqGy/UtCrGYcQ4c4xnjiij5zDh7NAj8XwVEHPAHzhmLrgyRrvdHBn1lE4PNCHAPA/W0INNv6hfbpNsZXrG0myPG7tsRr+rgfejoP+cELp99qmeffkyJ/HXs+6Xnzrsjg1Ievd0efW3DAoqCK8zdAL4KJmoUxSbHpBXyrgveW5/sXEITSMrhhqNoHBJc3ui9YeRU8wFMwWGEAoXgeOQIFH0w/WXetN9uW4yHP2407TPUx2Pe0lf8TxhN+N2UL3ZL32NTFPCTKp3NytTAJib1DH9pj+4xWBYAzriahTwx0RrryjDycN/aMYPlHDbdu6q7bxd33S7baX2CwemriA7vD4HgLAN7WUPDr/0OCRLjWlz64vNq+f8hWSfbAc9DVi+d3pxP9+27ofcuMeWbSjmGRGDjMCMYfsgNnHLKdtQsZnJAO6mCcEUcQu5HNf3RRYbbOun1yxHi+bq3GEId8a4JBP/UzS2RmaEAgyKBwyJ18l3/tZdyo5NRuVjKlg0FFqCZXHt5+y16tDFe6Md/JC34klpa9T1hWPpjk5GbsaYxehTuXR7ut6rzdC74Br5+hTgB4z4QMGfs6Ea3Z8NW/dZZ+0I+I0nwY9a5xddAuY0eGBPQSA/71F7DE5fWTPYcNydXkjSZeTRh53g74XZtPfPj1uf7C66d5qKLyl6/4dG+ShJ3cWDF76wuxjgrPdRuu2OS1G44ru3eDKXf12yKPFzjG2ZrjfZiXhMCgCIaPCykx+9iQkOI9RoLPtDRpL4a/Sd3UPxTUO11QL7l0GoAL4wiBIWgLYXgsQ2J+nzwFthHCUQl7CTrJbq3ejFiAHiOzBlrX5HQH3zLRS4Klj+vms4feT2hMwXcwm/mKI0plB2tbLw5cbfbY5xnVC/kGH9d9/nl9kHcA3uabpOf3Fn5y785Nm2nd6hBDe+Ojji+/Mg32fHP2BEzsftunEYLMo1jqmQARa95my6xwhtMWK2wAWIBYj0sr73/+8HbJApvU0ttSsqPykAEm4tPZMsgw4St6kfRlZhu275tRh+VJ4LDvdUTH1rEW6UqkfLbj28FuxKPP29vr474Ix5TcpSQMRtkZ0L4bbwHhOoCeO6cNpwNM+2Wfs+Goxddc+uPsh6nY29el4njf9YR0ygP9Xq/MP7a9/pAnY3v/VX3579eXV+qvlgH8h4O+nwb/y4OXpW5vl5l2Yvf75V9tH6OVcDcfs+UiY2iGaSyp5RIBz3lw3vOxhy9tJRnVvk2SWQPaihmcaEedaZwVSLioS88i6L5n5eI+Xkr57zrqEWPtu2Al1VHbDd0y5Vy8lEBAVsQ+ANNh40tdinitxQq34sRIt1XDnHTozfEZEH7eePp15PI2KZ87x1aTlG4p6p4bog9PFLGgIzp5tjrHZHJ61Qwbwa7LOZ0vEJPSDt4/dO6/N25vL5WzVpcWHn60fyiDffmnh3vzWg+nbX94Oj5brdOZUf8szpuzoiIAJMZmCuE9GZFo2er77V6RWXa7itVGpxLlt2EWrxLMxNU/VKbdq67ny9vL3UduHxU3HatMdQFs4Gn3xDay8Py2Y8SFvfjXCoIaODJ0QRTF0jrAk0Efs6F8nHk+HZJcGupu17mIS6Ja9kyHK0HgW70g6//DwEB0CwG9WQFhtIi/ve3fSoH3n1aZ97cF08fj59ux6Gb+zCHgzeJwS83cD43cSKIhzxxJlYqItgGmu78NYjRRgLX1+jTryB1I5cqXw8ri67u4ZaaY9/NaIxi7FwCS7Sr5I7kZYwW83LluGD8mgBFOiaIYtmfVs6DPHk7po+BJE/07AE3Z01zCeR7UrIrpxTLezhi9dcLLp0jBrXVrMG51MPADYIcU/BIAXJiCkpLRe986btOfH3DrnJsZ0FKM86KN9az7l1x3sWBSvEtMbavYygZxXXZDZJBFREmtSshnBtLh8+27QRhX1NiFFiusqkbjM+ouqiXeZGKACJEAGwZDEpDYQjMlcViUPRkhmkCg29IpejW4c01MmfNkyfTHxuEmG1SbZJTPfOUf3beDbhtGRY+0GiSImx/NGXjppDxv+UAN4cVd58A0hcytmvFyTgbad0PXt8PjI2/tTj5Yct32y46h6KoopTB+cNPR6cLRwAJujV8D0NgE9gDtHOIuGB9utTgDQOlpPQHDAVBSAJ1DDlkw3q167OWHaEFrJQ32bdcKlGa8BmBE6KHo2GIiuQbj1jFUTcBWj3ZliYKJNCHw3aXjVOGw46XpQjexIg2c7O27TLJ/uMMAuNscYADw73OcPAeCwduuiBgTA+OhMN0C8d/crFaFVFy/uN5FVjY8bhKPAbaDctDPwVBSnYsYwiJjNNgnTLqGFISSjaWCaIXcfIUZEAiMimTSszOBotu1V10lJBJm/AQDE1HvHy+BpSzmb6DyjO5p4bZPGu1VmJrWBdNI6ZYL64NQWu/v7UoHlYbMfrgCH9c2vV2b3MFXadJFFlMyAdS8Uk3JMSqpGi5Zd46jKcxAa7wFDHGTsng/J9H5Q+TqW2zmy2dTL6TxoStnV8GjeWJ0qNJBdbBaHN+KQARzW/03WsCj7EFLfTRdy+21/7i3t1R0AVIF8rPdvBnDyK37O/d7T0vWHv/tvyvoPfyrKzMSVxh8AAAAASUVORK5CYII=";PlanetData.SATURN="data:image/png;base64,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";PlanetData.URANUS="data:image/png;base64,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";PlanetData.NEPTUNE="data:image/png;base64,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";PlanetData.PLUTO="data:image/png;base64,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";

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var self$6;
  var interval;
  var poiFeatureCollection;
  var RADS = Math.PI / 180; // convert degrees to radians

  var EPS$1 = 1.0e-12; // machine error constant

  var pname = new Array("Mercury", "Venus", "Sun", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto");

  function frealstr(num, width, fract) {
    var str = num.toFixed(fract);
    var len = str.length;
    var real = "";
    var i;

    for (i = 0; i < width - len; i++) {
      // append leading spaces
      real += " ";
    }

    for (i = 0; i < len; i++) {
      // append digits
      real += str.charAt(i);
    }

    return real;
  }
  /*
   * Json template for a point
   */


  function poiDesc(mizarLayer, type, name, obj) {
    var style;

    if (type === Constants.GEOMETRY.Point) {
      style = {
        fillColor: [1, 1, 1, 1],
        opacity: 1,
        useDegreeSize: true,
        degreeSize: [obj.angularSize[0], obj.angularSize[1]],
        iconUrl: obj.icon
      };
    } else {
      style = new FeatureStyle({
        label: name,
        strokeColor: FeatureStyle.fromStringToColor(obj.color),
        fillColor: FeatureStyle.fromStringToColor(obj.color)
      });
    }

    return {
      geometry: {
        type: Constants.GEOMETRY.Point,
        gid: "planet" + type + "_" + name,
        coordinates: [obj.ra, obj.dec],
        crs: {
          type: "name",
          properties: {
            name: Constants.CRS.Equatorial
          }
        }
      },
      properties: {
        name: name,
        distance: frealstr(obj.rvec, 9, 6) + " AU",
        style: style
      }
    };
  } // right ascension, declination coordinate structure


  function Coord() {
    this.ra = parseFloat("0"); // right ascension [deg]

    this.dec = parseFloat("0"); // declination [deg]

    this.rvec = parseFloat("0"); // distance [AU]
  } // day number to/from J2000 (Jan 1.5, 2000)


  function day_number(y, m, d, hour, mins) {
    var h = hour + mins / 60;
    return 367 * y - Math.floor(7 * (y + Math.floor((m + 9) / 12)) / 4) + Math.floor(275 * m / 9) + d - 730531.5 + h / 24;
  }
  /**************************************************************************************************************/
  // orbital element structure


  function Elem() {
    this.color = ""; // color of the planet

    this.radius = parseFloat("0"); // planet radius in meters

    this.a = parseFloat("0"); // semi-major axis [AU]

    this.e = parseFloat("0"); // eccentricity of orbit

    this.i = parseFloat("0"); // inclination of orbit [deg]

    this.O = parseFloat("0"); // longitude of the ascending node [deg]

    this.w = parseFloat("0"); // longitude of perihelion [deg]

    this.L = parseFloat("0"); // mean longitude [deg]
  } // return the integer part of a number


  function abs_floor(x) {
    var r;

    if (x >= 0.0) {
      r = Math.floor(x);
    } else {
      r = Math.ceil(x);
    }

    return r;
  } // return an angle in the range 0 to 2pi radians


  function mod2pi(x) {
    var b = x / (2 * Math.PI);
    var a = 2 * Math.PI * (b - abs_floor(b));

    if (a < 0) {
      a = 2 * Math.PI + a;
    }

    return a;
  } // compute the true anomaly from mean anomaly using iteration
  //  M - mean anomaly in radians
  //  e - orbit eccentricity


  function true_anomaly(M, e) {
    var V, E1; // initial approximation of eccentric anomaly

    var E = M + e * Math.sin(M) * (1.0 + e * Math.cos(M));

    do // iterate to improve accuracy
    {
      E1 = E;
      E = E1 - (E1 - e * Math.sin(E1) - M) / (1 - e * Math.cos(E1));
    } while (Math.abs(E - E1) > EPS$1); // convert eccentric anomaly to true anomaly


    V = 2 * Math.atan(Math.sqrt((1 + e) / (1 - e)) * Math.tan(0.5 * E));

    if (V < 0) {
      V = V + 2 * Math.PI;
    } // modulo 2pi


    return V;
  }
  /**
   * Computes the elements of the orbit for planet-i at day number-d
   * @param p - result
   * @param i - planet-i
   * @param d - day number
   * @throws {RangeError} function mean_elements() failed!
   */


  function mean_elements(p, i, d) {
    var cy = d / 36525; // centuries since J2000

    switch (i) {
      case 0:
        // Mercury
        p.color = "rgb(170,150,170)";
        p.a = 0.38709893 + 0.00000066 * cy;
        p.e = 0.20563069 + 0.00002527 * cy;
        p.i = Numeric.toRadian(7.00487 - 23.51 * cy / 3600);
        p.O = Numeric.toRadian(48.33167 - 446.3 * cy / 3600);
        p.w = Numeric.toRadian(77.45645 + 573.57 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(252.25084 + 538101628.29 * cy / 3600));
        p.radius = [2440530.0, 2438260.0];
        p.icon = PlanetData.MERCURY;
        break;

      case 1:
        // Venus
        p.color = "rgb(245,222,179)";
        p.a = 0.72333199 + 0.00000092 * cy;
        p.e = 0.00677323 - 0.00004938 * cy;
        p.i = Numeric.toRadian(3.39471 - 2.86 * cy / 3600);
        p.O = Numeric.toRadian(76.68069 - 996.89 * cy / 3600);
        p.w = Numeric.toRadian(131.53298 - 108.8 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(181.97973 + 210664136.06 * cy / 3600));
        p.radius = [6051800.0, 6051800.0];
        p.icon = PlanetData.VENUS;
        break;

      case 2:
        // Earth/Sun
        p.color = "rgb(255,193,37)";
        p.a = 1.00000011 - 0.00000005 * cy;
        p.e = 0.01671022 - 0.00003804 * cy;
        p.i = Numeric.toRadian(0.00005 - 46.94 * cy / 3600);
        p.O = Numeric.toRadian(-11.26064 - 18228.25 * cy / 3600);
        p.w = Numeric.toRadian(102.94719 + 1198.28 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(100.46435 + 129597740.63 * cy / 3600));
        p.radius = [695700000.0, 695700000.0];
        p.icon = PlanetData.SUN;
        break;

      case 3:
        // Mars
        p.color = "rgb(255,50,50)";
        p.a = 1.52366231 - 0.00007221 * cy;
        p.e = 0.09341233 + 0.00011902 * cy;
        p.i = Numeric.toRadian(1.85061 - 25.47 * cy / 3600);
        p.O = Numeric.toRadian(49.57854 - 1020.19 * cy / 3600);
        p.w = Numeric.toRadian(336.04084 + 1560.78 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(355.45332 + 68905103.78 * cy / 3600));
        p.radius = [3396190.0, 3376200.0];
        p.icon = PlanetData.MARS;
        break;

      case 4:
        // Jupiter
        p.color = "rgb(255,150,150)";
        p.a = 5.20336301 + 0.00060737 * cy;
        p.e = 0.04839266 - 0.0001288 * cy;
        p.i = Numeric.toRadian(1.3053 - 4.15 * cy / 3600);
        p.O = Numeric.toRadian(100.55615 + 1217.17 * cy / 3600);
        p.w = Numeric.toRadian(14.75385 + 839.93 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(34.40438 + 10925078.35 * cy / 3600));
        p.radius = [71492000.0, 66854000.0];
        p.icon = PlanetData.JUPITER;
        break;

      case 5:
        // Saturn
        p.color = "rgb(200,150,150)";
        p.a = 9.53707032 - 0.0030153 * cy;
        p.e = 0.0541506 - 0.00036762 * cy;
        p.i = Numeric.toRadian(2.48446 + 6.11 * cy / 3600);
        p.O = Numeric.toRadian(113.71504 - 1591.05 * cy / 3600);
        p.w = Numeric.toRadian(92.43194 - 1948.89 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(49.94432 + 4401052.95 * cy / 3600));
        p.radius = [60268000.0 * 2.5, 54364000.0];
        p.icon = PlanetData.SATURN;
        break;

      case 6:
        // Uranus
        p.color = "rgb(130,150,255)";
        p.a = 19.19126393 + 0.00152025 * cy;
        p.e = 0.04716771 - 0.0001915 * cy;
        p.i = Numeric.toRadian(0.76986 - 2.09 * cy / 3600);
        p.O = Numeric.toRadian(74.22988 - 1681.4 * cy / 3600);
        p.w = Numeric.toRadian(170.96424 + 1312.56 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(313.23218 + 1542547.79 * cy / 3600));
        p.radius = [25559000.0, 24973000.0];
        p.icon = PlanetData.URANUS;
        break;

      case 7:
        // Neptune
        p.color = "rgb(100,100,255)";
        p.a = 30.06896348 - 0.00125196 * cy;
        p.e = 0.00858587 + 0.0000251 * cy;
        p.i = Numeric.toRadian(1.76917 - 3.64 * cy / 3600);
        p.O = Numeric.toRadian(131.72169 - 151.25 * cy / 3600);
        p.w = Numeric.toRadian(44.97135 - 844.43 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(304.88003 + 786449.21 * cy / 3600));
        p.radius = [24764000.0, 24341000.0];
        p.icon = PlanetData.NEPTUNE;
        break;

      case 8:
        // Pluto
        p.color = "rgb(100,100,255)";
        p.a = 39.48168677 - 0.00076912 * cy;
        p.e = 0.24880766 + 0.00006465 * cy;
        p.i = Numeric.toRadian(17.14175 + 11.07 * cy / 3600);
        p.O = Numeric.toRadian(110.30347 - 37.33 * cy / 3600);
        p.w = Numeric.toRadian(224.06676 - 132.25 * cy / 3600);
        p.L = mod2pi(Numeric.toRadian(238.92881 + 522747.9 * cy / 3600));
        p.radius = [1188300.0, 1188300.0];
        p.icon = PlanetData.PLUTO;
        break;

      default:
        throw RangeError("function mean_elements() failed!", "PlanetProvider.js");
    }
  } // compute RA, DEC, and distance of planet-p for day number-d
  // result returned in structure obj in degrees and astronomical units


  function get_coord(obj, p, d) {
    var planet = new Elem();
    mean_elements(planet, p, d);
    var ap = planet.a;
    var ep = planet.e;
    var ip = planet.i;
    var op = planet.O;
    var pp = planet.w;
    var lp = planet.L;
    var earth = new Elem();
    mean_elements(earth, 2, d);
    var ae = earth.a;
    var ee = earth.e; //var ie = earth.i;
    //var oe = earth.O;

    var pe = earth.w;
    var le = earth.L; // position of Earth in its orbit

    var me = mod2pi(le - pe);
    var ve = true_anomaly(me, ee);
    var re = ae * (1 - ee * ee) / (1 + ee * Math.cos(ve)); // heliocentric rectangular coordinates of Earth

    var xe = re * Math.cos(ve + pe);
    var ye = re * Math.sin(ve + pe);
    var ze = 0.0; // position of planet in its orbit

    var mp = mod2pi(lp - pp);
    var vp = true_anomaly(mp, planet.e);
    var rp = ap * (1 - ep * ep) / (1 + ep * Math.cos(vp)); // heliocentric rectangular coordinates of planet

    var xh = rp * (Math.cos(op) * Math.cos(vp + pp - op) - Math.sin(op) * Math.sin(vp + pp - op) * Math.cos(ip));
    var yh = rp * (Math.sin(op) * Math.cos(vp + pp - op) + Math.cos(op) * Math.sin(vp + pp - op) * Math.cos(ip));
    var zh = rp * (Math.sin(vp + pp - op) * Math.sin(ip));

    if (p === 2) {
      // earth --> compute sun
      xh = 0;
      yh = 0;
      zh = 0;
    } // convert to geocentric rectangular coordinates


    var xg = xh - xe;
    var yg = yh - ye;
    var zg = zh - ze; // rotate around x axis from ecliptic to equatorial coords

    var ecl = 23.439281 * RADS; //value for J2000.0 frame

    var xeq = xg;
    var yeq = yg * Math.cos(ecl) - zg * Math.sin(ecl);
    var zeq = yg * Math.sin(ecl) + zg * Math.cos(ecl); // find the RA and DEC from the rectangular equatorial coords

    obj.ra = Numeric.toDegree(mod2pi(Math.atan2(yeq, xeq)));
    obj.dec = Numeric.toDegree(Math.atan(zeq / Math.sqrt(xeq * xeq + yeq * yeq)));
    obj.rvec = Math.sqrt(xeq * xeq + yeq * yeq + zeq * zeq);
    obj.color = planet.color;
    const distanceMeters = obj.rvec * 1.496e11;
    obj.angularSize = [Numeric.toDegree(2 * planet.radius[0] / distanceMeters), Numeric.toDegree(2 * planet.radius[1] / distanceMeters)];
    obj.icon = planet.icon;
  }
  /**
   *    Handle features on layer
   */


  var computePositions = function (mizarLayer) {
    var pois = [];
    var now = new Date();
    var year = now.getUTCFullYear();
    var month = now.getUTCMonth() + 1;
    var day = now.getUTCDate();
    var hour = now.getUTCHours();
    var mins = now.getUTCMinutes();
    var secs = now.getUTCSeconds(); // compute day number for date/time

    var dn = day_number(year, month, day, hour, mins + secs / 60);
    var obj = new Coord(); // compute location of objects

    for (var p = 0; p < 9; p++) {
      get_coord(obj, p, dn); // Add label

      var poi_label = poiDesc(mizarLayer, "Label", pname[p], obj);
      pois.push(poi_label); // Add point itself

      var poi_point = poiDesc(mizarLayer, Constants.GEOMETRY.Point, pname[p], obj);
      pois.push(poi_point);
    } // Create feature collection


    poiFeatureCollection = {
      type: "FeatureCollection",
      features: pois
    };
    mizarLayer.addFeatureCollection(poiFeatureCollection);
  };
  /**************************************************************************************************************/

  /**
   * @name PlanetProvider
   * @class
   *    Providing planet positions based on ephemeris computations
   * @param {Object} options
   * @augments AbstractProvider
   * @constructor
   * @memberof module:Provider
   * @see http://www.abecedarical.com/javascript/script_planet_orbits.html
   */


  var PlanetProvider = function (options) {
    AbstractProvider.prototype.constructor.call(this, options);
    self$6 = this;
  };
  /**
   * Loads files
   * @param {Layer} layer - Mizar layer
   * @param {Object} configuration - configuration
   * @param {int} [configuration.interval = 60000] - Recomputes planet position every minute if not defined
   * @memberof PlanetProvider#
   */


  PlanetProvider.prototype.loadFiles = function (layer, configuration) {
    interval = configuration.interval ? configuration.interval : 60000;
    self$6.handleFeatures(layer);
  };
  /**
   * Calculate planets position and add them to the passed layer
   * @function handleFeatures
   * @memberof PlanetProvider#
   * @param {Layer} layer
   */


  PlanetProvider.prototype.handleFeatures = function (layer) {
    computePositions(layer);
    setInterval(function () {
      layer.removeFeatureCollection(poiFeatureCollection);
      computePositions(layer);
    }, interval);
  };
  /**
   * Returns the Sun position at the date.
   * @param {date} date
   * @returns {float[]} the Sun position
   */


  PlanetProvider.prototype.getSunPosition = function (date) {
    var year = date.getUTCFullYear();
    var month = date.getUTCMonth() + 1;
    var day = date.getUTCDate();
    var hour = date.getUTCHours();
    var mins = date.getUTCMinutes();
    var secs = date.getUTCSeconds(); // compute day number for date/time

    var dn = day_number(year, month, day, hour, mins + secs / 60);
    var obj = new Coord();
    get_coord(obj, 2, dn);
    return obj;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Atmosphere layer configuration
   * @typedef {AbstractLayer.configuration} AbstractLayer.atmosphere_configuration
   * @property {float} [kr=0.0025] the rayleigh parameter
   * @property {float} [km=0.0015] the mie parameter
   * @property {float} [sunBrightness=15] The Sun brightness
   * @property {float} [exposure=2.0] the exposure, use for basic high dynamic range
   * @property {float[]} [wavelength=[0.650, 0.570, 0.475]] the RGB color of the sun
   * @property {float[]} [lightDir=[1, 0, 0]] The location of the light in (x,y,z)
   */

  /**
   * @name AtmosphereLayer
   * @class
   * Creates an atmosphere on the planet.
   * @augments AbstractLayer
   * @param {AbstractLayer.atmosphere_configuration} options - Atmosphere configuration.
   * @constructor
   * @memberof module:Layer
   */

  var AtmosphereLayer = function (options) {
    var currentDate = new Date();
    var tomorrow = new Date();
    tomorrow.setDate(currentDate.getDate() + 1);
    options.dimension = {
      time: {
        units: "ISO8601",
        unitSymbol: null,
        default: null,
        multipleValues: null,
        nearestValue: null,
        current: null,
        value: currentDate.toISOString() + "/" + tomorrow.toISOString() + "/PT1H"
      }
    }; // For rendering

    options.zIndex = Constants.DISPLAY.RENDERING;
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.Atmosphere, options);

    if (!this.name) {
      this.name = "Atmosphere";
    }

    this.kr = options.kr || 0.0025;
    this.km = options.km || 0.0015;
    this.sunBrightness = options.sunBrightness || 15.0;
    this.exposure = options.exposure || 2.0;
    this.wavelength = options.wavelength || [0.65, 0.57, 0.475];
    this.lightDir = options.lightDir || _computeLightDir.call(this, new Date()); // internal properties

    this._skyProgram = null;
    this._groundProgram = null;
    this._originalProgram = null;
    this._isValid = false;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, AtmosphereLayer);
  /**************************************************************************************************************/

  /**
   * Computes light direction
   * @param date date
   * @returns {number[]} [x, y, z]
   * @private
   */

  function _computeLightDir(date) {
    var sunProvider = new PlanetProvider();
    var sunPosition = sunProvider.getSunPosition(date);
    var latitude = sunPosition.dec;
    var longitude = -Utils.GHA(date, sunPosition.ra);
    var coords = Utils.longLat2XYZ(longitude, latitude);
    return [coords.x, coords.y, coords.z];
  }
  /**
   * @function getInformationType
   * @memberof AtmosphereLayer#
   */


  AtmosphereLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.ATMOSPHERE;
  };
  /**
   * Attaches the atmosphere layer to the planet.
   * @function _attach
   * @memberof AtmosphereLayer#
   * @param {Planet} g Planet
   * @private
   */


  AtmosphereLayer.prototype._attach = function (g) {
    this.globe = g;
    this._innerRadius = this.getGlobe().getCoordinateSystem().getGeoide().getRadius();
    this._outerRadius = this._innerRadius * 1.005;
    var renderContext = g.getRenderContext(); // Setup program, uniform now that we have the render context

    this._skyFromSpaceProgram = new Program(renderContext);

    this._skyFromSpaceProgram.loadFromFile("SkyFromSpaceVert.glsl", "SkyFrag.glsl");

    this._skyFromAtmosphereProgram = new Program(renderContext);

    this._skyFromAtmosphereProgram.loadFromFile("SkyFromAtmosphereVert.glsl", "SkyFrag.glsl");

    this._groundFromSpaceProgram = new Program(renderContext);

    this._groundFromSpaceProgram.loadFromFile("GroundFromSpaceVert.glsl", "GroundFrag.glsl");

    this._groundFromAtmosphereProgram = new Program(renderContext);

    this._groundFromAtmosphereProgram.loadFromFile("GroundFromAtmosphereVert.glsl", "GroundFrag.glsl"); // Check if the atmosphre is valid : all programs must be OK


    this._isValid = this._skyFromSpaceProgram.glProgram !== null && this._skyFromAtmosphereProgram.glProgram !== null && this._groundFromSpaceProgram.glProgram !== null && this._groundFromAtmosphereProgram.glProgram !== null;

    if (!this._isValid) {
      return;
    }

    this._skyFromSpaceProgram.apply();

    this._initUniforms(this._skyFromSpaceProgram.uniforms);

    this._skyFromAtmosphereProgram.apply();

    this._initUniforms(this._skyFromAtmosphereProgram.uniforms);

    this._groundFromSpaceProgram.apply();

    this._initUniforms(this._groundFromSpaceProgram.uniforms);

    this._groundFromAtmosphereProgram.apply();

    this._initUniforms(this._groundFromAtmosphereProgram.uniforms); // Create the sphere


    var vertices = [];
    var indices = [];
    var nbEl = 72;
    var nbAz = 144; // Create the vertices

    var el;
    var az;

    for (el = -nbEl; el <= nbEl; el++) {
      var elevation = el * (Math.PI * 0.5) / nbEl;

      for (az = -nbAz; az <= nbAz; az++) {
        var azimuth = az * Math.PI / nbAz;
        var x = this._outerRadius * Math.cos(azimuth) * Math.cos(elevation);
        var y = this._outerRadius * Math.sin(azimuth) * Math.cos(elevation);
        var z = this._outerRadius * Math.sin(elevation);
        vertices.push(x);
        vertices.push(y);
        vertices.push(z);
      }
    } // build the sphere triangles


    for (el = 0; el < 2 * nbEl; el++) {
      for (az = 0; az < 2 * nbAz; az++) {
        indices.push(el * (2 * nbAz + 1) + az);
        indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
        indices.push(el * (2 * nbAz + 1) + az + 1);
        indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
        indices.push(el * (2 * nbAz + 1) + az);
        indices.push((el + 1) * (2 * nbAz + 1) + az);
      }
    }

    var gl = renderContext.gl;
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    this._indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    this._numIndices = indices.length;
    this._originalProgram = g.getTileManager().program;
    g.preRenderers.push(this);
    g.getTileManager().addPostRenderer(this);
  };
  /**************************************************************************************************************/

  /**
   * Initializes uniforms.
   * @function _initUniforms
   * @memberof AtmosphereLayer#
   * @param uniforms
   * @private
   */


  AtmosphereLayer.prototype._initUniforms = function (uniforms) {
    var gl = this.getGlobe().getRenderContext().gl;
    var g = -0.95; // The Mie phase asymmetry factor

    var scale = 1.0 / (this._outerRadius - this._innerRadius);
    var rayleighScaleDepth = 0.25; //var mieScaleDepth = 0.1;

    vec3.normalize(this.lightDir);
    gl.uniform1f(uniforms.fKrESun, this.kr * this.sunBrightness);
    gl.uniform1f(uniforms.fKmESun, this.kr * this.sunBrightness);
    gl.uniform1f(uniforms.fKr4PI, this.kr * 4.0 * Math.PI);
    gl.uniform1f(uniforms.fKm4PI, this.km * 4.0 * Math.PI);
    gl.uniform1f(uniforms.fExposure, this.exposure);
    var wavelength = [Math.pow(this.wavelength[0], 4.0), Math.pow(this.wavelength[1], 4.0), Math.pow(this.wavelength[2], 4.0)];
    gl.uniform3f(uniforms.v3InvWavelength, 1.0 / wavelength[0], 1.0 / wavelength[1], 1.0 / wavelength[2]);
    gl.uniform3f(uniforms.v3LightPos, this.lightDir[0], this.lightDir[1], this.lightDir[2]);
    gl.uniform1f(uniforms.fInnerRadius, this._innerRadius);
    gl.uniform1f(uniforms.fInnerRadius2, this._innerRadius * this._innerRadius);
    gl.uniform1f(uniforms.fOuterRadius, this._outerRadius);
    gl.uniform1f(uniforms.fOuterRadius2, this._outerRadius * this._outerRadius);
    gl.uniform1f(uniforms.fScale, scale);
    gl.uniform1f(uniforms.fScaleDepth, rayleighScaleDepth);
    gl.uniform1f(uniforms.fScaleOverScaleDepth, scale / rayleighScaleDepth);
    gl.uniform1f(uniforms.g, g);
    gl.uniform1f(uniforms.g2, g * g);
  };
  /**************************************************************************************************************/

  /**
   * Pre-rendesr the atmoshpere.
   * @function preRender
   * @memberof AtmosphereLayer#
   */


  AtmosphereLayer.prototype.preRender = function () {
    if (!this._isValid) {
      return;
    }

    var tileManager = this.getGlobe().getTileManager();

    if (!this.isVisible()) {
      tileManager.program = this._originalProgram;
      return;
    }

    var rc = this.getGlobe().getRenderContext();
    var gl = rc.gl;
    var x, y, z; // Compute the eye position from the view matrix : the eye position is equals to [0,0,0] * inv(viewMatrix)
    // Optimized to avoid to compute the view matrix inverse

    var vm = rc.viewMatrix;
    x = vm[12];
    y = vm[13];
    z = vm[14];
    var eyePos = [-(vm[0] * x + vm[1] * y + vm[2] * z), -(vm[4] * x + vm[5] * y + vm[6] * z), -(vm[8] * x + vm[9] * y + vm[10] * z)];
    var eyeHeight = vec3.length(eyePos);
    this._skyProgram = eyeHeight < this._outerRadius ? this._skyFromAtmosphereProgram : this._skyFromSpaceProgram;
    this._groundProgram = eyeHeight < this._outerRadius ? this._groundFromAtmosphereProgram : this._groundFromSpaceProgram;

    this._skyProgram.apply();

    gl.uniform3f(this._skyProgram.uniforms.v3CameraPos, eyePos[0], eyePos[1], eyePos[2]);
    gl.uniform1f(this._skyProgram.uniforms.fCameraHeight2, eyeHeight * eyeHeight);
    gl.uniform1f(this._skyProgram.uniforms.fCameraHeight, eyeHeight);

    this._groundProgram.apply();

    var earthCenter = [0.0, 0.0, 0.0];
    mat4.multiplyVec3(rc.viewMatrix, earthCenter);
    gl.uniform3f(this._groundProgram.uniforms.earthCenter, earthCenter[0], earthCenter[1], earthCenter[2]);
    vec3.normalize(this.lightDir);
    x = this.lightDir[0];
    y = this.lightDir[1];
    z = this.lightDir[2];
    var mat = rc.viewMatrix;
    var lightDirUpdated = [];
    lightDirUpdated[0] = mat[0] * x + mat[4] * y + mat[8] * z;
    lightDirUpdated[1] = mat[1] * x + mat[5] * y + mat[9] * z;
    lightDirUpdated[2] = mat[2] * x + mat[6] * y + mat[10] * z;
    gl.uniform3f(this._groundProgram.uniforms.lightDir, lightDirUpdated[0], lightDirUpdated[1], lightDirUpdated[2]);
    gl.uniform3f(this._groundProgram.uniforms.v3CameraPos, eyePos[0], eyePos[1], eyePos[2]);
    gl.uniform1f(this._groundProgram.uniforms.fCameraHeight2, eyeHeight * eyeHeight);
    gl.uniform1f(this._groundProgram.uniforms.fCameraHeight, eyeHeight);
    tileManager.program = this._groundProgram; //	rc.minFar = 2.0;
  };
  /**************************************************************************************************************/

  /**
   * Renders the atmosphere.
   * @function render
   * @memberof AtmosphereLayer#
   */


  AtmosphereLayer.prototype.render = function () {
    if (!this._isValid || !this.isVisible() || !this.getGlobe()) {
      return;
    }

    var rc = this.getGlobe().getRenderContext();
    var gl = rc.gl;
    gl.enable(gl.CULL_FACE);

    this._skyProgram.apply();

    gl.uniformMatrix4fv(this._skyProgram.uniforms.projectionMatrix, false, rc.projectionMatrix);
    gl.uniformMatrix4fv(this._skyProgram.uniforms.viewMatrix, false, rc.viewMatrix);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.vertexAttribPointer(this._skyProgram.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.drawElements(gl.TRIANGLES, this._numIndices, gl.UNSIGNED_SHORT, 0);
    gl.disable(gl.CULL_FACE);
  };

  AtmosphereLayer.prototype.setTime = function (time) {
    this.setParameter("time", time);
  };

  AtmosphereLayer.prototype.setParameter = function (param, value) {
    if (param === "time") {
      var time = Time.parse(value);
      this.time = time;
      var date = new Date(time.date);
      this.lightDir = _computeLightDir.call(this, date);

      this._skyFromSpaceProgram.apply();

      this._initUniforms(this._skyFromSpaceProgram.uniforms);

      this._skyFromAtmosphereProgram.apply();

      this._initUniforms(this._skyFromAtmosphereProgram.uniforms);

      this._groundFromSpaceProgram.apply();

      this._initUniforms(this._groundFromSpaceProgram.uniforms);

      this._groundFromAtmosphereProgram.apply();

      this._initUniforms(this._groundFromAtmosphereProgram.uniforms);

      this.forceRefresh();
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  var lon2merc = function (lon) {
    return lon * 20037508.34 / 180;
  };

  var lat2merc = function (lat) {
    var y = Math.log(Math.tan(Numeric.toRadian(90 + lat))) / (Math.PI / 180);
    return y * 20037508.34 / 180;
  };

  var tile2long = function (x, z) {
    return x / Math.pow(2, z) * 360 - 180;
  };

  var tile2lat = function (y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  };
  /**************************************************************************************************************/

  /** @constructor
     Tile constructor
     */


  var MercatorTile = function (level, x, y) {
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
    this.level = level;
    this.x = x;
    this.y = y;
    this.key = this.level + "#" + this.x + "#" + this.y;
    this.type = Constants.TILE.MERCATOR_TILE;
    this.geoBound = new GeoBound(tile2long(x, level), tile2lat(y + 1, level), tile2long(x + 1, level), tile2lat(y, level));
    this.bound = new GeoBound(lon2merc(this.geoBound.west), lat2merc(this.geoBound.south), lon2merc(this.geoBound.east), lat2merc(this.geoBound.north));
  };
  /**************************************************************************************************************/

  /** Inhertis from tile */


  MercatorTile.prototype = new Tile();
  /**************************************************************************************************************/

  /** @export
     Get elevation at a geo position
     */

  MercatorTile.prototype.getElevation = function (lon, lat) {
    // TODO
    return 0.0;
  };

  MercatorTile.prototype.getKey = function () {
    return this.key;
  };
  /**************************************************************************************************************/

  /**
     Create the children
     */


  MercatorTile.prototype.createChildren = function () {
    // Create the children
    var tile00 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y);
    var tile10 = new MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y);
    var tile01 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y + 1);
    var tile11 = new MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y + 1);
    tile00.initFromParent(this, 0, 0);
    tile10.initFromParent(this, 1, 0);
    tile01.initFromParent(this, 0, 1);
    tile11.initFromParent(this, 1, 1);
    this.children = [tile00, tile10, tile01, tile11];
  };
  /**************************************************************************************************************/

  /**
     Convert coordinates in longitude,latitude to coordinate in "tile space"
     Tile space means coordinates are between [0,tesselation-1] if inside the tile
     Used by renderers algorithm to clamp coordinates on the tile
     */


  MercatorTile.prototype.lonlat2tile = function (coordinates) {
    var tpl = Math.pow(2, this.level);
    var factor = this.config.tesselation - 1;
    var tileCoords = [];

    for (var i = 0; i < coordinates.length; i++) {
      var x = (coordinates[i][0] + 180.0) / 360.0;
      var sinLat = Math.sin(Numeric.toRadian(coordinates[i][1]));
      var y = 0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4.0 * Math.PI);
      tileCoords.push([factor * (x * tpl - this.x), factor * (y * tpl - this.y)]);
    }

    return tileCoords;
  };
  /**************************************************************************************************************/

  /**
     Generate vertices for tile
     */


  MercatorTile.prototype.generateVertices = function (elevations) {
    // Compute tile matrix
    this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
    var invMatrix = mat4.create();
    mat4.inverse(this.matrix, invMatrix);
    this.inverseMatrix = invMatrix; // Build the vertices

    var size = this.config.tesselation;
    var vertices = new Float32Array(3 * size * (size + 6));
    var step = 1.0 / (size - 1); //var radius = this.config.coordinateSystem.geoide.radius;

    var scale = this.config.coordinateSystem.geoide.heightScale;
    var offset = 0;
    var twoPowLevel = Math.pow(2, this.level);
    var pos3d = [0.0, 0.0, 0.0];
    var v = this.y;

    for (var j = 0; j < size; j++) {
      var n = Math.PI * (1.0 - 2.0 * v / twoPowLevel);
      var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
      lat = Numeric.toDegree(lat); //var cosLat = Math.cos(lat);
      //var sinLat = Math.sin(lat);

      var u = this.x;

      for (var i = 0; i < size; i++) {
        var lon = 180 * (2.0 * u / twoPowLevel - 1.0);
        var height = elevations ? scale * elevations[offset] : 0.0;
        this.config.coordinateSystem.fromGeoTo3D([lon, lat, height], pos3d);
        var x = pos3d[0];
        var y = pos3d[1];
        var z = pos3d[2];
        var vertexOffset = offset * 3;
        vertices[vertexOffset] = invMatrix[0] * x + invMatrix[4] * y + invMatrix[8] * z + invMatrix[12];
        vertices[vertexOffset + 1] = invMatrix[1] * x + invMatrix[5] * y + invMatrix[9] * z + invMatrix[13];
        vertices[vertexOffset + 2] = invMatrix[2] * x + invMatrix[6] * y + invMatrix[10] * z + invMatrix[14];
        offset++;
        u += step;
      }

      v += step;
    }

    return vertices;
  };
  /**************************************************************************************************************/

  /**
     Override buildSkirtVertices for mercator.
     Use skirt to "fill" the pole
     */


  MercatorTile.prototype.buildSkirtVertices = function (center, srcOffset, srcStep, dstOffset) {
    var size = this.config.tesselation;
    var vertexSize = this.config.vertexSize;
    var numTilesY = Math.pow(2, this.level); // Check if the tile is at the north (isTop) or south (isBottom) pole

    var isTop = this.y === 0 && dstOffset === vertexSize * (size * size);
    var isBottom = this.y === numTilesY - 1 && dstOffset === vertexSize * ((size + 1) * size);

    if (isTop || isBottom) {
      var vertices = this.vertices;
      var pt = this.config.coordinateSystem.fromGeoTo3D(isTop ? [0.0, 90.0, 0.0] : [0.0, -90.0, 0.0]);
      mat4.multiplyVec3(this.inverseMatrix, pt);

      for (var i = 0; i < size; i++) {
        vertices[dstOffset] = pt[0];
        vertices[dstOffset + 1] = pt[1];
        vertices[dstOffset + 2] = pt[2];

        for (var n = 3; n < vertexSize; n++) {
          vertices[dstOffset + n] = vertices[srcOffset + n];
        }

        dstOffset += vertexSize;
      } // Recompute the bbox to have correct culling
      //this.bbox.compute(this.vertices,dstOffset + vertexSize*size,vertexSize);
      //this.radius = this.bbox.getRadius();

    } else {
      Tile.prototype.buildSkirtVertices.call(this, center, srcOffset, srcStep, dstOffset);
    }
  };
  /**************************************************************************************************************/

  /**
   MercatorTiling constructor
   @constructor
   */


  var MercatorTiling = function (startLevel) {
    this.startLevel = startLevel;
    this.level0NumTilesX = Math.pow(2, this.startLevel);
  };
  /** inherits from geotiling */


  MercatorTiling.prototype = new GeoTiling();
  /**************************************************************************************************************/

  /**
   Generate the tiles for level zero
   */

  MercatorTiling.prototype.generateLevelZeroTiles = function (config) {
    config.skirt = !config.coordinateSystem.isFlat();
    config.cullSign = 1;
    config.srs = "EPSG:3857";

    config.project = function (coord) {
      return [lon2merc(coord[0]), lat2merc(coord[1])];
    };

    var level0Tiles = [];
    var level0NumTilesX = Math.pow(2, this.startLevel);
    var level0NumTilesY = Math.pow(2, this.startLevel);

    for (var j = 0; j < level0NumTilesY; j++) {
      for (var i = 0; i < level0NumTilesX; i++) {
        var tile = new MercatorTile(this.startLevel, i, j);
        tile.config = config;
        level0Tiles.push(tile);
      }
    }

    return level0Tiles;
  };
  /**************************************************************************************************************/

  /**
   Locate a level zero tile
   */


  MercatorTiling.prototype._lon2LevelZeroIndex = function (lon) {
    var x = (lon + 180) / 360;
    return Math.min(this.level0NumTilesX - 1, Math.floor(x * this.level0NumTilesX));
  };
  /**************************************************************************************************************/

  /**
   Locate a level zero tile
   */


  MercatorTiling.prototype._lat2LevelZeroIndex = function (lat) {
    var sinLatitude = Math.sin(Numeric.toRadian(lat));
    var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
    return Math.min(this.level0NumTilesX - 1, Math.floor(y * this.level0NumTilesX));
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  var BingTileSystem = function () {
    var MinLatitude = -85.05112878;
    var MaxLatitude = 85.05112878;
    var MinLongitude = -180;
    var MaxLongitude = 180;
    /**
     * Clips a number to the specified minimum and maximum values.
     * @param n - The number to clip.
     * @param minValue - Minimum allowable value.
     * @param maxValue - Maximum allowable value.
     * @returns {number} The clipped value.
     * @private
     * @constructor
     */

    function Clip(n, minValue, maxValue) {
      return Math.min(Math.max(n, minValue), maxValue);
    }
    /**
     * Determines the map width and height (in pixels) at a specified level of detail.
     * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
     * @returns {number} The map width and height in pixels.
     * @constructor
     * @private
     */


    function MapSize(levelOfDetail) {
      return 256 << levelOfDetail;
    }
    /**
     * Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
     * into pixel XY coordinates at a specified level of detail.
     * @param latitude - Latitude of the point, in degrees
     * @param longitude - Longitude of the point, in degrees
     * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
     * @returns {float[]} [Output parameter receiving the X coordinate in pixels, Output parameter receiving the Y coordinate in pixels]
     * @constructor
     */


    function LatLongToPixelXY(latitude, longitude, levelOfDetail) {
      latitude = Clip(latitude, MinLatitude, MaxLatitude);
      longitude = Clip(longitude, MinLongitude, MaxLongitude);
      var x = (longitude + 180) / 360;
      var sinLatitude = Math.sin(latitude * Math.PI / 180);
      var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
      var mapSize = MapSize(levelOfDetail);
      var pixelX = Clip(x * mapSize + 0.5, 0, mapSize - 1);
      var pixelY = Clip(y * mapSize + 0.5, 0, mapSize - 1);
      return [Math.floor(pixelX), Math.floor(pixelY)];
    }
    /**
     * Converts tile XY coordinates into a QuadKey at a specified level of detail.
     * @param tileX - Tile X coordinate
     * @param tileY - Tile Y coordinate
     * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
     * @returns {string} A string containing the QuadKey
     * @constructor
     * @private
     */


    function TileXYToQuadKey(tileX, tileY, levelOfDetail) {
      var quadKey = "";

      for (var i = levelOfDetail; i > 0; i--) {
        var digit = "0";
        var mask = 1 << i - 1;

        if ((tileX & mask) !== 0) {
          digit++;
        }

        if ((tileY & mask) !== 0) {
          digit++;
          digit++;
        }

        quadKey += digit;
      }

      return quadKey;
    }

    return {
      tileXYToQuadKey: TileXYToQuadKey,
      latLongToPixelXY: LatLongToPixelXY
    };
  }();
  /**************************************************************************************************************/

  /**
   * Bing layer configuration
   * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.bing_configuration
   * @property {int} [baseLevel=2]
   * @property {onreadyCallback} [onready] - CallBack function.
   * @property {string} imageSet the image set to use, can be Aerial, Road
   * @property {string} key the bing key to use
   */

  /**
   * Callback when the layer is ready.
   * @callback onreadyCallback
   * @param {BingLayer} Bing layer
   */

  /**
   * @name BingLayer
   * @class
   *     Bing Maps is a web mapping service provided as a part of Microsoft's Bing suite of search engines and powered
   * by the Bing Maps for Enterprise framework.
   * @augments AbstractRasterLayer
   * @param {AbstractRasterLayer.bing_configuration} options -Bing Layer configuration
   * @see {@link https://en.wikipedia.org/wiki/Bing_Maps}
   * @memberof module:Layer
   */


  var BingLayer = function (options) {
    // Call ancestor
    AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.Bing, options);
    this.tilePixelSize = 256;
    this.tiling = new MercatorTiling(options.baseLevel || 2);
    this.numberOfLevels = 18;
    this.baseUrl = "";
    this.baseUrlSubDomains = [];
    this._ready = false;
    var self = this; // Need to provide a global callback for JSONP

    window._bingTileProviderCallback = function (result) {
      self.baseUrl = Proxy.proxify(result.resourceSets[0].resources[0].imageUrl);
      self.baseUrlSubDomains = Proxy.proxify(result.resourceSets[0].resources[0].imageUrlSubdomains);
      self._ready = true; // Call callback if set

      if (options.onready && options.onready instanceof Function) {
        options.onready(self);
      } // Request a frame


      if (self.globe) {
        self.globe.getRenderContext().requestFrame();
      }
    }; // JSONP Call : needed because of cross-site origin policy


    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = Proxy.proxify("http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" + options.imageSet + "?jsonp=_bingTileProviderCallback&key=" + options.key);
    script.id = "_bingTileProviderCallback";
    document.getElementsByTagName("head")[0].appendChild(script);
  };

  Utils.inherits(AbstractRasterLayer, BingLayer);
  /**************************************************************************************************************/

  /**
   * Returns an url for the given tile.
   * @function getUrl
   * @memberof BingLayer#
   * @param {Tile} tile Tile
   * @returns {string} Url
   */

  BingLayer.prototype.getUrl = function (tile) {
    var url = this.baseUrl.replace("{quadkey}", BingTileSystem.tileXYToQuadKey(tile.x, tile.y, tile.level));
    url = url.replace("{subdomain}", this.baseUrlSubDomains[Math.floor(Math.random() * this.baseUrlSubDomains.length)]);
    return this.allowRequest(url, tile.level);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * Open Street Map configuration
   * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.osm_configuration
   * @property {int} [tilePixelSize=256]
   * @property {int} [baseLevel=2]
   * @property {int} [numberOfLevels=21]
   */

  /**
   * @name OSMLayer
   * @class
   *    A layer to display data coming from OpenStreetMap server. OpenStreetMap (OSM) is a collaborative project to
   * create a free editable map of the world
   * @augments AbstractRasterLayer
   * @param {AbstractRasterLayer.osm_configuration} options - OSM Configuration
   * @memberof module:Layer
   */

  var OSMLayer = function (options) {
    options.tilePixelSize = options.tilePixelSize || 256;
    options.tiling = new MercatorTiling(options.baseLevel || 2);
    options.numberOfLevels = options.numberOfLevels || 21;
    AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.OSM, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRasterLayer, OSMLayer);
  /**************************************************************************************************************/

  /**
   * Returns an url for the given tile.
   * @function getUrl
   * @memberof OSMLayer#
   * @param {Tile} tile Tile
   * @return {string} Url
   */

  OSMLayer.prototype.getUrl = function (tile) {
    var url = this.baseUrl + "/" + tile.level + "/" + tile.x + "/" + tile.y + ".png";
    return this.allowRequest(url, tile.level);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * TileWireFrameLayer configuration
   * @typedef {AbstractLayer.configuration} AbstractLayer.tileWireFrame_configuration
   * @property [outline=false]
   */

  /**
   * @name TileWireframeLayer
   * @class
   *    This layer draws an TileWireframe  layer
   * @augments AbstractLayer
   * @param {AbstractLayer.tileWireFrame_configuration} options - TileWireFrame configuration
   * @memberof module:Layer
   * @constructor
   */

  var TileWireframeLayer = function (options) {
    options.zIndex = Constants.DISPLAY.RENDERING;
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.TileWireframe, options);
    this.outline = options.outline || false;
    this.globe = null;
    this.program = null;
    this.indexBuffer = null;
    this.subIndexBuffer = [null, null, null, null];
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, TileWireframeLayer);
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof TileWireframeLayer#
   */

  TileWireframeLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.VECTOR;
  };
  /**
   * Build the index buffer
   * @function buildIndexBuffer
   * @memberof TileWireframeLayer#
   */


  TileWireframeLayer.prototype.buildIndexBuffer = function () {
    var gl = this.getGlobe().getRenderContext().gl;
    var size = this.getGlobe().getTileManager().tileConfig.tesselation;
    var indices = [];
    var i, j, ii, n, k;
    var step = this.outline ? size - 1 : 1;
    var ib; // Build horizontal lines

    for (j = 0; j < size; j += step) {
      for (i = 0; i < size - 1; i++) {
        indices.push(j * size + i);
        indices.push(j * size + i + 1);
      }
    } // Build vertical lines


    for (j = 0; j < size; j += step) {
      for (i = 0; i < size - 1; i++) {
        indices.push(i * size + j);
        indices.push((i + 1) * size + j);
      }
    }

    ib = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    ib.numIndices = indices.length;
    this.indexBuffer = ib;
    var halfTesselation = (size - 1) / 2;
    step = this.outline ? halfTesselation : 1;

    for (ii = 0; ii < 4; ii++) {
      i = ii % 2;
      j = Math.floor(ii / 2); // Build the sub grid for 'inside' tile

      indices = [];

      for (n = halfTesselation * j; n < halfTesselation * (j + 1) + 1; n += step) {
        for (k = halfTesselation * i; k < halfTesselation * (i + 1); k++) {
          indices.push(n * size + k);
          indices.push(n * size + k + 1);
        }
      }

      for (n = halfTesselation * i; n < halfTesselation * (i + 1) + 1; n += step) {
        for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
          indices.push(k * size + n);
          indices.push((k + 1) * size + n);
        }
      }

      ib = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      ib.numIndices = indices.length;
      this.subIndexBuffer[ii] = ib;
    }
  };
  /**************************************************************************************************************/

  /**
   * Attaches the layer to the planet
   * @function _attach
   * @memberof TileWireframeLayer#
   * @param {AbstractGlobe} g globe
   * @private
   */


  TileWireframeLayer.prototype._attach = function (g) {
    AbstractLayer.prototype._attach.call(this, g);

    if (this.isVisible()) {
      this.getGlobe().getTileManager().addPostRenderer(this);
    }

    if (!this.program) {
      var vertexShader = "attribute vec3 vertex;\n";
      vertexShader += "uniform mat4 modelViewMatrix;\n";
      vertexShader += "uniform mat4 projectionMatrix;\n";
      vertexShader += "void main(void) \n";
      vertexShader += "{\n";
      vertexShader += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
      vertexShader += "}\n";
      var fragmentShader = "precision highp float; \n";
      fragmentShader += "uniform vec3 color; \n";
      fragmentShader += "uniform float alpha; \n";
      fragmentShader += "void main(void)\n";
      fragmentShader += "{\n";
      fragmentShader += "	gl_FragColor = vec4(color,alpha);\n";
      fragmentShader += "}\n";
      this.program = new Program(this.getGlobe().getRenderContext());
      this.program.createFromSource(vertexShader, fragmentShader);
      this.buildIndexBuffer();
    }
  };
  /**************************************************************************************************************/

  /**
   * Detaches the layer from the planet
   * @function _detach
   * @memberof TileWireframeLayer#
   * @private
   */


  TileWireframeLayer.prototype._detach = function () {
    this.getGlobe().getTileManager().removePostRenderer(this);

    AbstractLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/

  /**
   * Renders the tiles outline
   * @function render
   * @memberof TileWireframeLayer#
   * @param {Array} tiles Array of Tile
   */


  TileWireframeLayer.prototype.render = function (tiles) {
    var rc = this.getGlobe().getRenderContext();
    var gl = rc.gl;
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL); // Setup program

    this.program.apply();
    gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, rc.projectionMatrix);
    var vertexAttribute = this.program.attributes.vertex;
    var currentIB = null;

    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      var isLoaded = tile.state === Tile.State.LOADED;
      var isLevelZero = tile.parentIndex === -1; // Update uniforms for modelview matrix

      mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
      gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, rc.modelViewMatrix);
      var color = this.getStyle().getStrokeColor();
      gl.uniform3f(this.program.uniforms.color, color[0], color[1], color[2]);
      gl.uniform1f(this.program.uniforms.alpha, this.getOpacity()); // Bind the vertex buffer

      gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
      gl.vertexAttribPointer(vertexAttribute, 3, gl.FLOAT, false, 4 * tile.config.vertexSize, 0);
      var indexBuffer = isLoaded || isLevelZero ? this.indexBuffer : this.subIndexBuffer[tile.parentIndex]; // Bind the index buffer only if different (index buffer is shared between tiles)

      if (currentIB !== indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        currentIB = indexBuffer;
      } // Draw the tiles in wireframe mode


      var numIndices = currentIB.numIndices;
      gl.drawElements(gl.LINES, numIndices, gl.UNSIGNED_SHORT, 0);
    }

    gl.disable(gl.BLEND);
    gl.depthFunc(gl.LESS);
  };
  /**************************************************************************************************************/

  /**
   * Get/Set visibility of the layer
   * @function setVisible
   * @memberof TileWireframeLayer#
   * @param {boolean} arg Visiblity
   */


  TileWireframeLayer.prototype.setVisible = function (arg) {
    AbstractLayer.prototype.setVisible.call(this, arg);

    if (typeof arg === "boolean") {
      if (this.isVisible()) {
        this.getGlobe().getTileManager().addPostRenderer(this);
      } else {
        this.getGlobe().getTileManager().removePostRenderer(this);
      }
    }

    return this.isVisible();
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**************************************************************************************************************/

  /** @constructor
   Mesh constructor
   */
  var Mesh = function (renderContext) {
    this.renderContext = renderContext;
    this.vertexBuffer = null;
    this.tcoordBuffer = null;
    this.indexBuffer = null;
    this.colorBuffer = null;
    this.numVertices = 0;
    this.mode = renderContext.gl.TRIANGLES;
  };
  /**************************************************************************************************************/

  /*
   Mesh setVertices method
   */


  Mesh.prototype.setVertices = function (vertices) {
    var gl = this.renderContext.gl;

    if (this.vertexBuffer === null) {
      this.vertexBuffer = gl.createBuffer();
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    this.numVertices = vertices.length;
  };
  /**************************************************************************************************************/

  /*
   Mesh setTexCoords method
   */


  Mesh.prototype.setTexCoords = function (tcoords) {
    var gl = this.renderContext.gl;

    if (this.tcoordBuffer === null) {
      this.tcoordBuffer = gl.createBuffer();
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tcoords), gl.STATIC_DRAW);
  };
  /**************************************************************************************************************/

  /*
   Mesh setColors method
   */


  Mesh.prototype.setColors = function (colors) {
    var gl = this.renderContext.gl;

    if (this.colorBuffer === null) {
      this.colorBuffer = gl.createBuffer();
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
  };
  /**************************************************************************************************************/

  /*
   Mesh setIndices method
   */


  Mesh.prototype.setIndices = function (indices) {
    var gl = this.renderContext.gl;

    if (this.indexBuffer === null) {
      this.indexBuffer = gl.createBuffer();
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    this.numIndices = indices.length;
  };
  /**************************************************************************************************************/

  /*
   Convert to wireframe (for debug purposes)
   */


  Mesh.prototype.setIndicesToWireframe = function (indices) {
    this.mode = this.renderContext.gl.LINES; // Convert indices

    var wireframeIndices = [];
    wireframeIndices.length = 2 * indices.length;

    for (var i = 0; i < indices.length; i += 3) {
      wireframeIndices[2 * i] = indices[i];
      wireframeIndices[2 * i + 1] = indices[i + 1];
      wireframeIndices[2 * i + 2] = indices[i + 1];
      wireframeIndices[2 * i + 3] = indices[i + 2];
      wireframeIndices[2 * i + 4] = indices[i + 2];
      wireframeIndices[2 * i + 5] = indices[i];
    }

    this.setIndices(wireframeIndices);
  };
  /**************************************************************************************************************/

  /*
   Mesh render method
   */


  Mesh.prototype.render = function (attributes) {
    var gl = this.renderContext.gl; // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0);

    if (attributes.hasOwnProperty("tcoord")) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
      gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
    }

    if (attributes.hasOwnProperty("color")) {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
      gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);
    }

    if (this.indexBuffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      gl.drawElements(this.mode, this.numIndices, gl.UNSIGNED_SHORT, 0);
    } else {
      gl.drawArrays(this.mode, 0, this.numVertices / 3);
    }
  };
  /**************************************************************************************************************/

  /*
   Mesh dispose method
   */


  Mesh.prototype.dispose = function () {
    var gl = this.renderContext.gl;

    if (this.indexBuffer) {
      gl.deleteBuffer(this.indexBuffer);
    }

    if (this.vertexBuffer) {
      gl.deleteBuffer(this.vertexBuffer);
    }

    if (this.tcoordBuffer) {
      gl.deleteBuffer(this.tcoordBuffer);
    }

    if (this.colorBuffer) {
      gl.deleteBuffer(this.colorBuffer);
    }

    this.indexBuffer = null;
    this.vertexBuffer = null;
    this.tcoordBuffer = null;
    this.colorBuffer = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   *    GL Textures pool
   *    @constructor
   */

  var TexturePool = function (pgl) {
    // TODO : changement gl en pgl pour éviter doublon
    var gl = pgl;
    var glTextures = [];
    /**
           Create a non power of two texture from an image
           */

    var createNewGLTexture = function (image) {
      var tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return tex;
    };
    /**
           Reuse a GL texture
           */


    var reuseGLTexture = function (image) {
      var glTexture = glTextures.pop();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      return glTexture;
    };
    /**
           Create a GL texture
           */


    this.createGLTexture = function (image) {
      if (glTextures.length > 0) {
        return reuseGLTexture(image);
      } else {
        return createNewGLTexture(image);
      }
    };
    /**
           Dispose a GL texture
           */


    this.disposeGLTexture = function (texture) {
      glTextures.push(texture);
    };

    this.disposeAll = function () {
      for (var i = 0; i < glTextures.length; i++) {
        gl.deleteTexture(glTextures[i]);
      }

      glTextures.length = 0;
    };
  };
  /**************************************************************************************************************/

  /**
   * CoordinateGridLayer configuration
   * @typedef {AbstractLayer.configuration} AbstractLayer.coordinateGrid_configuration
   * @property {float} [longitudeSample=15] - Longitude sampling in decimal degree
   * @property {float} [latitudeSample=10] - Latitude sampling in decimal degree
   * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - The coordinate system of the grid
   * @property {string} [longFormat="Deg"] Representation of longitude axe(HMS, DMS, Deg)
   * @property {string} [latFormat="Deg"] Representation of latitude axe(HMS, DMS, Deg)
   * @property {Integer} [tesselation=2] Tesselation order (only for latitude bands currently)
   */

  /**
   * @name CoordinateGridLayer
   * @class
   *    A layer for coordinate grid
   * @augments AbstractLayer
   * @param {AbstractLayer.coordinateGrid_configuration} options - coordinate grid layer configuration
   * @constructor
   * @memberof module:Layer
   */


  var CoordinateGridLayer = function (options) {
    AbstractLayer.prototype.constructor.call(this, Constants.LAYER.CoordinateGrid, options);
    this.globe = null; // Equatorial coordinates label renderables

    this.labels = {}; // WebGL textures

    this.texturePool = null;
    this.longitudeSample = options.longitudeSample || 15; // *24 = 360

    this.latitudeSample = options.latitudeSample || 10; // *18 = 180
    // Canvas for generation of equatorial coordinate labels

    this.canvas2d = document.createElement("canvas");
    this.canvas2d.width = 100;
    this.canvas2d.height = 20; // Grid buffers

    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.gridCrs = CoordinateSystemFactory.create(options.coordinateSystem);
    this.longFormat = options.longFormat ? options.longFormat : "Deg";
    this.latFormat = options.latFormat ? options.latFormat : "Deg"; // Keep trace on geoBound

    this.geoBound = {};
    this.tesselation = options.tesselation || 2;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractLayer, CoordinateGridLayer);
  /**************************************************************************************************************/

  /**
   * @function getInformationType
   * @memberof CoordinateGridLayer#
   */

  CoordinateGridLayer.prototype.getInformationType = function () {
    return Constants.INFORMATION_TYPE.VECTOR;
  };
  /**
   * Generates an image data from text.
   * @function generateImageData
   * @memberof CoordinateGridLayer#
   * @param {string} text Text generated in canvas
   * @return {Object} Context of 2D canvas
   */


  CoordinateGridLayer.prototype.generateImageData = function (text) {
    var ctx = this.canvas2d.getContext("2d");
    ctx.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
    ctx.fillStyle = FeatureStyle.fromColorToString(this.getStyle().getStrokeColor());
    ctx.font = "18px sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "center";
    var x = this.canvas2d.width / 2;
    ctx.fillText(text, x, 0);
    return ctx.getImageData(0, 0, this.canvas2d.width, this.canvas2d.height);
  };
  /**************************************************************************************************************/

  /**
   * Attaches the layer to the globe.
   * @function _attach
   * @memberof CoordinateGridLayer#
   * @param {Planet} g Planet
   * @private
   */


  CoordinateGridLayer.prototype._attach = function (g) {
    AbstractLayer.prototype._attach.call(this, g);

    if (this.isVisible()) {
      this.getGlobe().getTileManager().addPostRenderer(this);
    }

    if (!this.gridProgram) {
      /*  var vertexShader = "\
               attribute vec3 vertex;\n\
               uniform mat4 viewProjectionMatrix;\n\
               void main(void) \n\
               {\n\
               gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
               }\n\
               ";*/
      var vertexShader = "attribute vec3 vertex;\n";
      vertexShader += "uniform mat4 viewProjectionMatrix;\n";
      vertexShader += "void main(void) \n";
      vertexShader += "{\n";
      vertexShader += "gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
      vertexShader += "}\n";
      /*                var fragmentShader = "\
               precision highp float; \n\
               uniform float alpha; \n\
               uniform vec3 color; \n\
               void main(void)\n\
               {\n\
               gl_FragColor = vec4(color,alpha);\n\
               }\n\
               ";*/

      var fragmentShader = "precision highp float; \n";
      fragmentShader += "uniform float alpha; \n";
      fragmentShader += "uniform vec3 color; \n";
      fragmentShader += "void main(void)\n";
      fragmentShader += "{\n";
      fragmentShader += "gl_FragColor = vec4(color,alpha);\n";
      fragmentShader += "}\n";
      /*                var vertexLabelShader = "\
               attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
               uniform mat4 viewProjectionMatrix; \n\
               uniform vec3 poiPosition; // world position \n\
               uniform vec2 poiScale; // x,y scale \n\
               \n\
               varying vec2 texCoord; \n\
               \n\
               void main(void)  \n\
               { \n\
               // Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
               texCoord = vertex.xy + vec2(0.5); \n\
               // Invert y \n\
               texCoord.y = 1.0 - texCoord.y; \n\
               \n\
               // Compute poi position in clip coordinate \n\
               gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
               gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
               } \n\
               ";*/

      var vertexLabelShader = "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
      vertexLabelShader += "uniform mat4 viewProjectionMatrix; \n";
      vertexLabelShader += "uniform vec3 poiPosition; // world position \n";
      vertexLabelShader += "uniform vec2 poiScale; // x,y scale \n";
      vertexLabelShader += "\n";
      vertexLabelShader += "varying vec2 texCoord; \n";
      vertexLabelShader += "\n";
      vertexLabelShader += "void main(void)  \n";
      vertexLabelShader += "{ \n";
      vertexLabelShader += "// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
      vertexLabelShader += "texCoord = vertex.xy + vec2(0.5); \n";
      vertexLabelShader += "// Invert y \n";
      vertexLabelShader += "texCoord.y = 1.0 - texCoord.y; \n";
      vertexLabelShader += "\n";
      vertexLabelShader += "// Compute poi position in clip coordinate \n";
      vertexLabelShader += "gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
      vertexLabelShader += "gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
      vertexLabelShader += "} \n";
      /*    var fragmentLabelShader = "\
               #ifdef GL_ES \n\
               precision highp float; \n\
               #endif \n\
               \n\
               varying vec2 texCoord; \n\
               uniform sampler2D texture; \n\
               uniform float alpha; \n\
               \n\
               void main(void) \n\
               { \n\
               vec4 textureColor = texture2D(texture, texCoord); \n\
               gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n\
               } \n\
               ";*/

      var fragmentLabelShader = "#ifdef GL_ES \n";
      fragmentLabelShader += "precision highp float; \n";
      fragmentLabelShader += "#endif \n";
      fragmentLabelShader += "\n";
      fragmentLabelShader += "varying vec2 texCoord; \n";
      fragmentLabelShader += "uniform sampler2D texture; \n";
      fragmentLabelShader += "uniform float alpha; \n";
      fragmentLabelShader += "\n";
      fragmentLabelShader += "void main(void) \n";
      fragmentLabelShader += "{ \n";
      fragmentLabelShader += "	vec4 textureColor = texture2D(texture, texCoord); \n";
      fragmentLabelShader += "	gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n";
      fragmentLabelShader += "} \n";
      this.gridProgram = new Program(this.getGlobe().getRenderContext());
      this.labelProgram = new Program(this.getGlobe().getRenderContext());
      this.gridProgram.createFromSource(vertexShader, fragmentShader);
      this.labelProgram.createFromSource(vertexLabelShader, fragmentLabelShader);
    } // Texture used to show the equatorial coordinates


    this.labelMesh = new Mesh(this.getGlobe().getRenderContext());
    var vertices = [-0.5, -0.5, 0.0, -0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, -0.5, 0.0];
    var indices = [0, 3, 1, 1, 3, 2];
    this.labelMesh.setVertices(vertices);
    this.labelMesh.setIndices(indices); // Init grid buffers

    var gl = this.getGlobe().getRenderContext().gl;
    this.vertexBuffer = gl.createBuffer();
    this.indexBuffer = gl.createBuffer(); // Init texture pool

    if (!this.texturePool) {
      this.texturePool = new TexturePool(gl);
    }
  };
  /**************************************************************************************************************/

  /**
   * Detaches the layer from the globe.
   * @function _detach
   * @memberof CoordinateGridLayer#
   * @private
   */


  CoordinateGridLayer.prototype._detach = function () {
    var gl = this.getGlobe().getRenderContext().gl;
    gl.deleteBuffer(this.vertexBuffer);
    gl.deleteBuffer(this.indexBuffer);
    this.texturePool.disposeAll();

    for (var i in this.labels) {
      if (this.labels.hasOwnProperty(i)) {
        delete this.labels[i];
      }
    }

    this.getGlobe().getTileManager().removePostRenderer(this);

    AbstractLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/

  /**
   * Clamps the geoBound to longitude/latitude samples.
   * @function clampGeoBound
   * @memberof CoordinateGridLayer#
   * @param {GeoBound} geoBound Bbox
   * @return {GeoBound} Bbox clamped
   */


  CoordinateGridLayer.prototype.clampGeoBound = function (geoBound) {
    geoBound.west = Math.floor(geoBound.west / this.longitudeSample) * this.longitudeSample;
    geoBound.east = Math.ceil(geoBound.east / this.longitudeSample) * this.longitudeSample;
    geoBound.north = Math.ceil(geoBound.north / this.latitudeSample) * this.latitudeSample;
    geoBound.south = Math.floor(geoBound.south / this.latitudeSample) * this.latitudeSample;
    return geoBound;
  };
  /**
   * Renders the grid.
   * @function render
   * @memberof CoordinateGridLayer#
   * @param {Array} tiles Tiles
   */


  CoordinateGridLayer.prototype.render = function (tiles) {
    var renderContext = this.getGlobe().getRenderContext();
    var gl = renderContext.gl;
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Compute current geoBound
    //TODO a modifier

    var geoBound; // Transform geoBound computed in default coordinate system to coordinate system of current grid if different

    var self = this;
    geoBound = this.getGlobe().getViewportGeoBound(function (coordinate) {
      //return coordinate;
      return self.globe.getCoordinateSystem().convert(coordinate, Constants.CRS.Equatorial, self.gridCrs.getGeoideName());
    }); // Clamp geoBound angles to longitude/latitude samples

    geoBound = this.clampGeoBound(geoBound); // Regenerate grid & labels only if geoBound has changed

    if (this.geoBound.west !== geoBound.west || this.geoBound.east !== geoBound.east || this.geoBound.north !== geoBound.north || this.geoBound.south !== geoBound.south) {
      this.geoBound = geoBound;
      this.computeSamples();
      this.generateGridBuffers();
      this.generateLabels();
    } else {
      this.updateLabels();
    }
    /*** Render grid ***/


    this.gridProgram.apply();
    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
    gl.uniformMatrix4fv(this.gridProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
    gl.uniform1f(this.gridProgram.uniforms.alpha, this.getOpacity());
    var color = this.getStyle().getStrokeColor();
    gl.uniform3f(this.gridProgram.uniforms.color, color[0], color[1], color[2]);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(this.gridProgram.attributes.vertex, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.drawElements(gl.LINES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    /*** Render labels ***/

    this.labelProgram.apply();
    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
    gl.uniformMatrix4fv(this.labelProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
    gl.uniform1i(this.labelProgram.uniforms.texture, 0);
    var pixelSizeVector = renderContext.computePixelSizeVector();

    for (var n in this.labels) {
      if (this.labels.hasOwnProperty(n)) {
        var label = this.labels[n]; // Bind point texture

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, label.texture); // 2.0 * because normalized device coordinates goes from -1 to 1

        var scale = [2.0 * label.textureWidth / renderContext.canvas.width, 2.0 * label.textureHeight / renderContext.canvas.height];
        gl.uniform2fv(this.labelProgram.uniforms.poiScale, scale); // gl.uniform2fv(this.labelProgram.uniforms["tst"], [ 0.5 / (label.textureWidth), 0.5 / (label.textureHeight)  ]);
        // Poi culling

        var worldPoi = label.pos3d;
        var poiVec = label.vertical;
        scale = label.textureHeight * (pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3]);
        var x = poiVec[0] * scale + worldPoi[0];
        var y = poiVec[1] * scale + worldPoi[1];
        var z = poiVec[2] * scale + worldPoi[2];
        gl.uniform3f(this.labelProgram.uniforms.poiPosition, x, y, z);
        gl.uniform1f(this.labelProgram.uniforms.alpha, 1.0);
        this.labelMesh.render(this.labelProgram.attributes);
        label.needed = false;
      }
    }

    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/

  /**
   * Get/Set visibility of the layer.
   * @function setVisible
   * @memberof CoordinateGridLayer#
   * @param {boolean} arg Visibility or not
   */


  CoordinateGridLayer.prototype.setVisible = function (arg) {
    AbstractLayer.prototype.setVisible.call(this, arg);

    if (typeof arg === "boolean") {
      if (this.isVisible()) {
        this.getGlobe().getTileManager().addPostRenderer(this);
      } else {
        this.getGlobe().getTileManager().removePostRenderer(this);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Computes samples depending on geoBound.
   * @function computeSamples
   * @memberof CoordinateGridLayer#
   */


  CoordinateGridLayer.prototype.computeSamples = function () {
    var dlong = this.geoBound.east - this.geoBound.west; // if under-sampled and not divergent

    while (dlong / this.longitudeSample < 3.0 && this.longitudeSample > 1.0) {
      this.longitudeSample /= 2;
      this.latitudeSample /= 2;
    } // if over-sampled and not exceed the initial value


    while (dlong / this.longitudeSample > 7.0 && this.longitudeSample < 15.0) {
      this.longitudeSample *= 2;
      this.latitudeSample *= 2;
    }
  };
  /**************************************************************************************************************/

  /**
   * Generates buffers object of the grid.
   * @function generateGridBuffers
   * @memberof CoordinateGridLayer#
   */


  CoordinateGridLayer.prototype.generateGridBuffers = function () {
    var phiStart, phiStop;
    var latNumber, phi, i; // Difference is larger than hemisphere

    if (this.geoBound.east - this.geoBound.west > 180.0) {
      // pole in the viewport
      phiStart = 0;
      phiStop = 360;
    } else {
      phiStart = this.geoBound.west;
      phiStop = this.geoBound.east;
    } // TODO adaptative generation of theta value
    // for (var theta = geoBound.south; theta <= geoBound.north; theta+=latStep) {


    var vertexPositionData = [];
    var latitudeBands = 180.0 / this.latitudeSample;

    for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
      var theta = latNumber * Math.PI / latitudeBands;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);

      for (phi = phiStart; phi <= phiStop; phi += this.longitudeSample) {
        // Tesselation
        var step = this.longitudeSample / this.tesselation;

        for (i = 0; i < this.tesselation; i++) {
          var radPhi = Numeric.toRadian(phi + i * step);
          var sinPhi = Math.sin(radPhi);
          var cosPhi = Math.cos(radPhi); // z is the up vector

          var radius = this.getGlobe().getCoordinateSystem().getGeoide().getRadius();
          var x = cosPhi * sinTheta * radius;
          var y = sinPhi * sinTheta * radius;
          var z = cosTheta * radius; //TODO a modifier

          if (this.gridCrs.getGeoideName() !== Constants.CRS.Equatorial) {
            var geo = this.getGlobe().getCoordinateSystem().from3DToGeo([x, y, z]);
            geo = this.getGlobe().getCoordinateSystem().convert(geo, this.gridCrs.getGeoideName(), Constants.CRS.Equatorial);
            var eq = this.getGlobe().getCoordinateSystem().fromGeoTo3D(geo);
            vertexPositionData.push(eq[0], eq[1], eq[2]);
          } else {
            vertexPositionData.push(x, y, z);
          }
        }
      }
    }

    var gl = this.getGlobe().getRenderContext().gl;
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    this.vertexBuffer.itemSize = 3;
    this.vertexBuffer.numItems = vertexPositionData.length / 3;
    var indexData = [];
    var longitudeBands = (phiStop - phiStart) / this.longitudeSample + 1;
    var longNumber; // Tesselation

    longitudeBands *= this.tesselation;

    for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
      for (phi = phiStart, longNumber = 0; phi < phiStop; phi += this.longitudeSample, longNumber += this.tesselation) {
        var first = latNumber * longitudeBands + longNumber % (longitudeBands - 1);
        var second = first + longitudeBands; // Horizontal lines

        for (i = 0; i < this.tesselation; i++) {
          indexData.push(first + i);
          indexData.push(first + i + 1);
        } // Vertical lines


        indexData.push(first + this.tesselation);
        indexData.push(second + this.tesselation);
        indexData.push(second);
        indexData.push(first);
      }
    }

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
    this.indexBuffer.itemSize = 1;
    this.indexBuffer.numItems = indexData.length;
  };
  /**************************************************************************************************************/

  /**
   * Builds the angle representation.
   * @function buildAngle
   * @memberof CoordinateGridLayer#
   * @param {string} format The building format("HMS", "DMS" or "Deg")
   * @param {float} angle The angle to build
   * @return {string} Label
   */


  CoordinateGridLayer.prototype.buildAngle = function (format, angle) {
    var label;

    switch (format) {
      case "Deg":
        label = angle + "°";
        break;

      case "HMS":
        label = this.getGlobe().getCoordinateSystem().fromDegreesToHMS(angle);
        break;

      case "DMS":
        label = this.getGlobe().getCoordinateSystem().fromDegreesToDMS(angle);
        break;

      default:
        ErrorDialog.open(Constants.LEVEL.ERROR, "Format not supported");
        return null;
    }

    return label;
  };
  /**************************************************************************************************************/

  /**
   * Computes the geographic center of canvas in grid's coordinate system
   * @function computeGeoCenter
   * @memberof CoordinateGridLayer#
   * @return {Array} Geocenter as array of float
   */


  CoordinateGridLayer.prototype.computeGeoCenter = function () {
    var ray = Ray.createFromPixel(this.getGlobe().getRenderContext(), this.getGlobe().getRenderContext().canvas.width / 2.0, this.getGlobe().getRenderContext().canvas.height / 2.0);
    var center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.getGlobe().getCoordinateSystem().getGeoide().getRadius()));
    var geoCenter = [];
    this.getGlobe().getCoordinateSystem().from3DToGeo(center3d, geoCenter); // Convert geoCenter into grid's coordinate system

    geoCenter = this.getGlobe().getCoordinateSystem().convert(geoCenter, Constants.CRS.Equatorial, this.gridCrs.getGeoideName());
    return geoCenter;
  };
  /**************************************************************************************************************/

  /**
   * Updates 3D position of a given label.
   * @function updateLabel
   * @memberof CoordinateGridLayer#
   * @param {string} label The label id in labels object
   * @param {float[]} posGeo Updated geographic position of label
   */


  CoordinateGridLayer.prototype.updateLabel = function (label, posGeo) {
    posGeo = this.getGlobe().getCoordinateSystem().convert(posGeo, this.gridCrs.getGeoideName(), Constants.CRS.Equatorial);
    var pos3d = this.getGlobe().getCoordinateSystem().fromGeoTo3D(posGeo);
    var vertical = vec3.create();
    vec3.normalize(pos3d, vertical);
    this.labels[label].pos3d = pos3d;
    this.labels[label].vertical = vertical;
    this.labels[label].needed = true;
  };
  /**************************************************************************************************************/

  /**
   * Updates the position of all labels.
   * @function updateLabels
   * @memberof CoordinateGridLayer.prototype
   */


  CoordinateGridLayer.prototype.updateLabels = function () {
    var geoCenter = this.computeGeoCenter();

    for (var x in this.labels) {
      if (this.labels.hasOwnProperty(x)) {
        // Compute position of label
        var posGeo;

        if (this.labels[x].type === "lat") {
          posGeo = [this.labels[x].angle, geoCenter[1]];
        } else if (this.labels[x].type === "long") {
          posGeo = [geoCenter[0], this.labels[x].angle];
        }

        this.updateLabel(x, posGeo);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Generates labels of the grid.
   * @function generateLabels
   * @memberof CoordinateGridLayer#
   */


  CoordinateGridLayer.prototype.generateLabels = function () {
    var phiStop, phiStart;
    var imageData, phi, x, posGeo, angle, theta; // Difference is larger than hemisphere

    if (this.geoBound.east - this.geoBound.west > 180.0) {
      // pole in the viewport => generate all longitude bands
      phiStart = 0;
      phiStop = 360;
    } else {
      phiStart = this.geoBound.west;
      phiStop = this.geoBound.east;
    }

    var geoCenter = this.computeGeoCenter();
    var label;

    for (phi = phiStart; phi < phiStop; phi += this.longitudeSample) {
      // convert to positive [0..360[
      angle = phi < 0 ? phi + 360 : phi;
      label = this.buildAngle(this.longFormat, angle);

      if (!this.labels["lat_" + label]) {
        this.labels["lat_" + label] = {
          angle: phi,
          type: "lat"
        };
        imageData = this.generateImageData(label);

        this._buildTextureFromImage(this.labels["lat_" + label], imageData);
      } // Compute position of label


      posGeo = [phi, geoCenter[1]];
      this.updateLabel("lat_" + label, posGeo);
    } // TODO <!> Adaptative rendering isn't totally implemented for theta due to difficulty to compute extrem latitude using geoBound <!>


    var thetaStart = Math.min(this.geoBound.north, this.geoBound.south);
    var thetaStop = Math.max(this.geoBound.north, this.geoBound.south);

    for (theta = thetaStart; theta <= thetaStop; theta += this.latitudeSample) {
      // 	for (var theta = -90; theta < 90; theta+=this.latitudeSample) {
      label = this.buildAngle(this.latFormat, theta);

      if (!this.labels["long_" + label]) {
        this.labels["long_" + label] = {
          angle: theta,
          type: "long"
        };
        imageData = this.generateImageData(label);

        this._buildTextureFromImage(this.labels["long_" + label], imageData);
      } // Compute position of label


      posGeo = [geoCenter[0], theta];
      this.updateLabel("long_" + label, posGeo);
    } // Dispose texture if not needed


    for (x in this.labels) {
      if (!this.labels[x].needed) {
        this.texturePool.disposeGLTexture(this.labels[x].texture);
        delete this.labels[x];
      }
    }
  };
  /**************************************************************************************************************/

  /*
   * Builds a texture from an image and store in a renderable
   * @function _buildTextureFromImage
   * @memberof CoordinateGridLayer#
   * @param {boolean} renderable Is renderable ?
   * @param {Object} image Image object
   */


  CoordinateGridLayer.prototype._buildTextureFromImage = function (renderable, image) {
    renderable.texture = this.texturePool.createGLTexture(image);
    renderable.textureWidth = image.width;
    renderable.textureHeight = image.height;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
       Tile constructor

       Quadrilateral which composes one tile of HEALPix sphere

       nside : 2^order
       order : log2(nside);
       pix : pixel index number
       face : face number = [0..11]
       @constructor
       */

  var HEALPixTile = function (order, pix, face) {
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
    this.level = this.order = order;
    this.nside = Math.pow(2, this.order);
    this.pixelIndex = pix;
    this.face = face;
    this.key = this.level + "#" + this.pixelIndex;
    this.type = Constants.TILE.HEALPIX_TILE; // Compute texture transform

    /*	var width = 1728/64;
           var height = 1856/64;
           this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

    this.bound = this.geoBound = null;
  };
  /**************************************************************************************************************/

  /** inherits from Tile */


  HEALPixTile.prototype = new Tile();
  /**************************************************************************************************************/

  HEALPixTile.prototype.getKey = function () {
    return this.key;
  };
  /**
       Create the children
       */


  HEALPixTile.prototype.createChildren = function () {
    // Create the children
    var child00 = new HEALPixTile(this.order + 1, this.pixelIndex * 4, this.face);
    var child10 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 2, this.face);
    var child01 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 1, this.face);
    var child11 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 3, this.face);
    child00.initFromParent(this, 0, 0);
    child10.initFromParent(this, 1, 0);
    child01.initFromParent(this, 0, 1);
    child11.initFromParent(this, 1, 1);
    this.children = [child00, child10, child01, child11];
  };
  /**************************************************************************************************************/

  /**
       Compute the local matrix for the tile
       */


  HEALPixTile.prototype.computeLocalMatrix = function (vertices) {
    var matrix = mat4.create();
    var east = vec3.create();
    var north = vec3.create();
    var up = vec3.create();
    var mx = 0;
    var my = 0;
    var mz = 0;

    for (var i = 0; i < vertices.length; i++) {
      mx += vertices[i][0];
      my += vertices[i][1];
      mz += vertices[i][2];
    }

    var barycenter = vec3.create([mx / vertices.length, my / vertices.length, mz / vertices.length]);
    vec3.set(barycenter, up);
    vec3.normalize(up);
    vec3.subtract(vertices[0], vertices[3], north);
    vec3.cross(up, north, east);
    vec3.normalize(east);
    vec3.cross(up, east, north);
    vec3.normalize(north);
    matrix[0] = east[0];
    matrix[1] = east[1];
    matrix[2] = east[2];
    matrix[3] = 0.0;
    matrix[4] = north[0];
    matrix[5] = north[1];
    matrix[6] = north[2];
    matrix[7] = 0.0;
    matrix[8] = up[0];
    matrix[9] = up[1];
    matrix[10] = up[2];
    matrix[11] = 0.0;
    matrix[12] = barycenter[0];
    matrix[13] = barycenter[1];
    matrix[14] = barycenter[2];
    matrix[15] = 1.0;
    return matrix;
  };
  /**************************************************************************************************************/


  function _computeWorldSpaceVertices(config, nside, pixelIndex, face) {
    // Build the vertices
    var size = config.tesselation;
    var worldSpaceVertices = [];
    var step = 1.0 / (size - 1); // xyf calculation

    var pix = pixelIndex & nside * nside - 1;
    var ix = HEALPixBase.compress_bits(pix);
    var iy = HEALPixBase.compress_bits(pix >>> 1); // Compute array of worldspace coordinates

    for (var u = 0; u < size; u++) {
      for (var v = 0; v < size; v++) {
        var vertice = HEALPixBase.fxyf((ix + u * step) / nside, (iy + v * step) / nside, face); // Take sphere radius into account

        vertice[0] *= config.coordinateSystem.getGeoide().getRadius();
        vertice[1] *= config.coordinateSystem.getGeoide().getRadius();
        vertice[2] *= config.coordinateSystem.getGeoide().getRadius(); //TODO a modifier

        if (config.coordinateSystem.getGeoideName() !== Constants.CRS.Equatorial) {
          var geo = config.coordinateSystem.getWorldFrom3D(vertice);
          var eq = config.coordinateSystem.convert(geo, config.coordinateSystem.getGeoideName(), Constants.CRS.Equatorial);
          worldSpaceVertices[u * size + v] = config.coordinateSystem.get3DFromWorld(eq);
        } else {
          worldSpaceVertices[u * size + v] = vertice;
        }
      }
    }

    return worldSpaceVertices;
  }

  function _computeCorners(config, worldSpaceVertices) {
    var corners = [];
    var size = config.tesselation;
    corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[0]));
    corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size - 1]));
    corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * (size - 1)]));
    corners.push(config.coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * size - 1]));
    return corners;
  }

  HEALPixTile.prototype.getCorners = function () {
    var worldSpaceVertices = _computeWorldSpaceVertices(this.config, this.nside, this.pixelIndex, this.face);

    var corners = _computeCorners(this.config, worldSpaceVertices);

    return corners;
  };
  /**
       Generate vertices for tile
       */


  HEALPixTile.prototype.generateVertices = function () {
    var size = this.config.tesselation;

    var worldSpaceVertices = _computeWorldSpaceVertices(this.config, this.nside, this.pixelIndex, this.face);

    var corners = _computeCorners(this.config, worldSpaceVertices); // Compute geoBound using corners of tile


    this.geoBound = new GeoBound();
    this.geoBound.computeFromCoordinates(corners);
    this.bound = this.geoBound; // Compute tile matrix

    this.matrix = this.computeLocalMatrix(worldSpaceVertices);
    var invMatrix = mat4.create();
    mat4.inverse(this.matrix, invMatrix);
    this.inverseMatrix = invMatrix; // Compute tile matrix

    /*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
           var geoCenter = coordinateSystem.getWorldFrom3D(center);
           this.matrix = coordinateSystem.getLHVTransform( geoCenter );
           var invMatrix = mat4.create();
           mat4.inverse( this.matrix, invMatrix );
           this.inverseMatrix = invMatrix;*/
    // Build the vertices

    var vertices = new Float32Array(3 * size * size); // Vertex coordinates in local space

    var vertexOffset = 0;

    for (var i = 0; i < worldSpaceVertices.length; i++) {
      vertices[vertexOffset] = invMatrix[0] * worldSpaceVertices[i][0] + invMatrix[4] * worldSpaceVertices[i][1] + invMatrix[8] * worldSpaceVertices[i][2] + invMatrix[12];
      vertices[vertexOffset + 1] = invMatrix[1] * worldSpaceVertices[i][0] + invMatrix[5] * worldSpaceVertices[i][1] + invMatrix[9] * worldSpaceVertices[i][2] + invMatrix[13];
      vertices[vertexOffset + 2] = invMatrix[2] * worldSpaceVertices[i][0] + invMatrix[6] * worldSpaceVertices[i][1] + invMatrix[10] * worldSpaceVertices[i][2] + invMatrix[14];
      vertexOffset += 3;
    }

    return vertices;
  };
  /**************************************************************************************************************/

  /**
   *    HEALPixTiling constructor
   *    @name HEALPixTiling
   *
   *    @param order Starting tiling order
   *    @param options Options
   *        <ul>
   *            <li>coordSystem: Coordinate system of the given tiling</li>
   *        </ul>
   *    @constructor
   */


  var HEALPixTiling = function (order, options) {
    this.order = order;
    this.nside = Math.pow(2, this.order);
    this.coordinateSystem = options.coordinateSystem; // TODO undefined coord system
  };
  /**************************************************************************************************************/

  /**
       Generate the tiles for level zero
       */


  HEALPixTiling.prototype.generateLevelZeroTiles = function (config, tilePool) {
    config.skirt = false;
    config.cullSign = -1;
    config.tesselation = 5; // TODO : change name to avoid ambiguity

    config.coordinateSystem = this.coordinateSystem;
    this.coordinateSystem = config.coordinateSystem;
    var level0Tiles = [];
    var qpf = Math.pow(this.nside, 2); // quad per face

    var nFaces = 12;
    var nQuads = nFaces * qpf;

    for (var i = 0; i < nQuads; i++) {
      var face = Math.floor(i / qpf);
      var tile = new HEALPixTile(this.order, i, face);
      tile.config = config;
      level0Tiles.push(tile);
    }

    return level0Tiles;
  }; // Get all the coordinates of a geometry


  var _getGeometryCoordinates = function (geometry) {
    var coords, n;

    switch (geometry.type) {
      case Constants.GEOMETRY.Point:
        coords = [];
        coords.push(geometry.coordinates);
        break;

      case Constants.GEOMETRY.MultiPoint:
      case Constants.GEOMETRY.LineString:
        coords = geometry.coordinates;
        break;

      case Constants.GEOMETRY.MultiLineString:
        coords = [];

        for (n = 0; n < geometry.coordinates.length; n++) {
          coords = coords.concat(geometry.coordinates[n]);
        }

        break;

      case Constants.GEOMETRY.Polygon:
        coords = geometry.coordinates[0];
        break;

      case Constants.GEOMETRY.MultiPolygon:
        coords = [];

        for (n = 0; n < geometry.coordinates.length; n++) {
          coords = coords.concat(geometry.coordinates[n][0]);
        }

        break;

      case Constants.GEOMETRY.GeometryCollection:
        coords = [];

        for (n = 0; n < geometry.geometries.length; n++) {
          coords = coords.concat(_getGeometryCoordinates(geometry.geometries[n]));
        }

        break;
    }

    return coords;
  };
  /**************************************************************************************************************/

  /**
       Get the level zero tiles that overlaps the given geometry
       */


  HEALPixTiling.prototype.getOverlappedLevelZeroTiles = function (geometry) {
    var tileIndices = [];

    var coords = _getGeometryCoordinates(geometry);

    if (!coords) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "HEALPixTiling.js", "Invalid geometry type or not supported.");
      return tileIndices;
    }

    var indexMap = {};

    for (var i = 0; i < coords.length; i++) {
      var index = this.lonlat2LevelZeroIndex(coords[i][0], coords[i][1]);

      if (!indexMap[index]) {
        indexMap[index] = true;
        tileIndices.push(index);
      }
    }

    return tileIndices;
  };
  /**************************************************************************************************************/

  /**
       Locate a level zero tile
       */


  HEALPixTiling.prototype.lonlat2LevelZeroIndex = function (lon, lat) {
    //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
    //lon = geo[0];
    //lat = geo[1];
    return HEALPixBase.lonLat2pix(this.order, lon, lat);
  };
  /**************************************************************************************************************/

  /**
       Return tile of given longitude/latitude from tiles array if exists, null otherwise
       */


  HEALPixTiling.prototype.findInsideTile = function (lon, lat, tiles) {
    //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
    //lon = geo[0];
    //lat = geo[1];
    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);

      if (index === tile.pixelIndex) {
        return tile;
      }
    }

    return null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @namespace
   * GENERAL_WAVELENGTH
   * @property {string} Radio - Radio
   * @property {string} Millimeter - Millimeter
   * @property {string} Infrared - Infrared
   * @property {string} Optical - Optical
   * @property {string} UV - UV
   * @property {string} EUV - EUV
   * @property {string} X-ray - X-ray
   * @property {string} Gamma-ray - Gamma-ray
   */

  var GENERAL_WAVELENGTH = {
    Radio: "Radio",
    Millimeter: "Millimeter",
    Infrared: "Infrared",
    Optical: "Optical",
    UV: "UV",
    EUV: "EUV",
    "X-ray": "X-ray",
    "Gamma-ray": "Gamma-ray"
  };
  /**
   * @namespace
   * HIPS_FRAME
   * @property {string} equatorial - equatorial
   * @property {string} galactic - galactic
   * @property {string} ecliptic - ecliptic
   * @property {string} horizontalLocal - horizontalLocal
   */

  var HIPS_FRAME = {
    equatorial: Constants.CRS.Equatorial,
    galactic: Constants.CRS.Galactic,
    ecliptic: "ecliptic",
    horizontalLocal: Constants.CRS.HorizontalLocal
  };
  /**
   * @namespace
   * HIPS_TILE_FORMAT
   * @property {string} jpeg - jpeg
   * @property {string} png - png
   * @property {string} fits - fits
   * @property {string} tsv - tsv
   */

  var HIPS_TILE_FORMAT = {
    jpeg: "jpeg",
    png: "png",
    fits: "fits",
    tsv: "tsv"
  };
  /**
   * @namespace
   * SAMPLING
   * @property {string} none - none
   * @property {string} nearest - nearest
   * @property {string} bilinear - bilinear
   */

  var SAMPLING = {
    none: "non",
    nearest: "nearest",
    bilinear: "bilinear"
  };
  /**
   * @namespace
   * PIXEL_OVERLAY
   * @property {string} add - add
   * @property {string} mean - mean
   * @property {string} first - first
   * @property {string} border_fading - border_fading
   * @property {string} custom - custom
   */

  var PIXEL_OVERLAY = {
    add: "add",
    mean: "mean",
    first: "first",
    border_fading: "border_fading",
    custom: "custom"
  };
  /**
   * @namespace
   * SKY_VAL
   * @property {string} none - none
   * @property {string} hips_estimation - hips_estimation
   * @property {string} fits_keyword - fits_keyword
   */

  var SKY_VAL = {
    none: "none",
    hips_estimation: "hips_estimation",
    fits_keyword: "fits_keyword"
  };
  /**
   * @namespace
   * DATA_PRODUCT_TYPE
   * @property {string} image - image
   * @property {string} cube - cube
   * @property {string} catalog - catalog
   * @property {string} meta - meta
   */

  var DATA_PRODUCT_TYPE = {
    image: "image",
    cube: "cube",
    catalog: "catalog",
    meta: "meta"
  };
  /**
   * @namespace
   * SUB_TYPE_DATA
   * @property {string} color - color
   * @property {string} live - live
   */

  var SUB_TYPE_DATA = {
    color: "color",
    live: "live"
  };
  /**
   * Hips data model
   * Mandatory, description, isMultiple, default value, distinctvalue, isArray
   * @namespace
   * HIPS_METADATA
   * @property {string} creator_did - Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J
   * @property {string} [publisher_id] - Unique ID of the HiPS publisher – Format: IVOID - Ex : ivo://CDS
   * @property {string} [obs_collection] - Short name of original data set – Format: one word – Ex : 2MASS
   * @property {string} obs_title - Data set title – Format: free text, one line – Ex : HST F110W observations
   * @property {string} [obs_description] - Data set description – Format: free text, longer free text description of the dataset
   * @property {string} [obs_ack] - Acknowledgment mention"
   * @property {string} [prov_progenitor] - Provenance of the original data – Format: free text
   * @property {string} [bib_reference] - Bibliographic reference
   * @property {string} [bib_reference_url] - URL to bibliographic reference
   * @property {string} [obs_copyright] - Copyright mention – Format: free text
   * @property {string} [obs_copyright_url] - URL to a copyright mention
   * @property {GENERAL_WAVELENGTH} [obs_regime] - General wavelength
   * @property {string} [data_ucd] - UCD describing data contents
   * @property {string} hips_version="1.4" - Number of HiPS version – Format: number
   * @property {string} [hips_builder] - Name and version of the tool used for building the HiPS – Format: free text
   * @property {string} [hips_publisher] - Institute or person who built the HiPS – Format: free text – Ex : CDS (T.Boch)
   * @property {string} [hips_creation_date] - HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
   * @property {string} hips_release_date - Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
   * @property {string} [hips_service_url] - HiPS access url – Format: URL
   * @property {string} hips_status - HiPS status
   * @property {string} [hips_estsize] - HiPS size estimation – Format: positive integer – Unit : KB
   * @property {HIPS_FRAME} hips_frame - Coordinate frame reference
   * @property {int} hips_order - Deepest HiPS order – Format: positive integer
   * @property {int} [hips_tile_width=512] - Tiles width in pixels – Format: positive integer
   * @property {HIPS_TILE_FORMAT} hips_tile_format - List of available tile formats
   * @property {string} [hips_pixel_cut] - Suggested pixel display cut range (physical values) – Format: min max
   * @property {string} [hips_data_range] - Pixel data range taken into account during the HiPS generation (physical values) – Format: min max – Ex : -18.5 510.5
   * @property {SAMPLING} [hips_sampling] - Sampling applied for the HiPS generation
   * @property {PIXEL_OVERLAY} [hips_overlay] - Pixel composition method applied on the image overlay region during HiPS generation
   * @property {SKY_VAL} [hips_skyval] - Sky background subtraction method applied during HiPS generation
   * @property {string} [hips_pixel_bitpix] - Fits tile BITPIX code
   * @property {string} [data_pixel_bitpix] - Original data BITPIX code
   * @property {DATA_PRODUCT_TYPE} dataproduct_type - Type of data
   * @property {SUB_TYPE_DATA} [dataproduct_subtype] - Subtype of data
   * @property {string} [hips_progenitor_url] - URL to an associated progenitor HiPS
   * @property {int} [hips_cat_nrows] -  Number of rows of the HiPS catalog
   * @property {int} [hips_cube_depth] - Number of frames of the HiPS cube
   * @property {int} [hips_cube_firstframe=0] - Initial first index frame to display for a HiPS cube
   * @property {float} [data_cube_crpix3] - Coef for computing physical channel value
   * @property {float} [data_cube_crval3] - Coef for computing physical channel value
   * @property {float} [data_cube_cdelt3] - Coef for computing physical channel value
   * @property {string} [data_cube_bunit3] - Third axis unit
   * @property {float} [hips_initial_ra] - Default RA display position (ICRS frame) – Unit : degrees
   * @property {float} [hips_initial_dec] - Default DEC display position (ICRS frame) – Unit : degrees
   * @property {float} [hips_initial_fov] - Default display size – Unit : degrees
   * @property {float} [hips_pixel_scale] - HiPS pixel angular resolution at the highest order – Unit : degrees
   * @property {float} [s_pixel_scale] - Best pixel angular resolution of the original images – Unit : degrees
   * @property {float} [t_min] - Start time of the observations - Representation: MJD
   * @property {float} [t_max] - Stop time of the observations - Representation: MJD
   * @property {float} [em_min] - Start in spectral coordinates – Unit: meters
   * @property {float} [em_max] - Stop in spectral coordinates – Unit: meters
   * @property {string} [client_category] - / separated keywords suggesting a display hierarchy to the client – Ex : Image/InfraRed
   * @property {string} [client_sort_key] - Sort key suggesting a display order to the client inside a client_category – Sort : alphanumeric
   * @property {string} [addendum_did] - In case of “live” HiPS, creator_did of the added HiPS
   * @property {float} [moc_sky_fraction] - Fraction of the sky covers by the MOC associated to the HiPS – Format: real between 0 and 1
   */

  var HipsVersion_1_4 = {
    creator_did: ["R", "Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J", false, null, null, false],
    publisher_id: [null, "Unique ID of the HiPS publisher – Format: IVOID - Ex : ivo://CDS", false, null, null, false],
    obs_collection: [null, "Short name of original data set – Format: one word – Ex : 2MASS", false, null, null, false],
    obs_title: ["R", "Data set title – Format: free text, one line – Ex : HST F110W observations", false, null, null, false],
    obs_description: ["S", "Data set description – Format: free text, longer free text description of the dataset", false, null, null, false],
    obs_ack: [null, "Acknowledgment mention", false, null, null, false],
    prov_progenitor: ["S", "Provenance of the original data – Format: free text", true, null, null, false],
    bib_reference: [null, "Bibliographic reference", true, null, null, false],
    bib_reference_url: [null, "URL to bibliographic reference", true, null, null, false],
    obs_copyright: [null, "Copyright mention – Format: free text", false, null, null, false],
    obs_copyright_url: [null, "URL to a copyright mention", false, null, null, false],
    obs_regime: ["S", "General wavelength – Format: word", true, null, GENERAL_WAVELENGTH, false],
    data_ucd: [null, "UCD describing data contents", true, null, null, false],
    hips_version: ["R", "Number of HiPS version – Format: number", false, "1.4", null, false],
    hips_builder: [null, "Name and version of the tool used for building the HiPS – Format: free text", false, null, null, false],
    hips_publisher: [null, "Institute or person who built the HiPS – Format: free text – Ex : CDS (T.Boch)", false, null, null, false],
    hips_creation_date: ["S", "HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ", false, null, null, false],
    hips_release_date: ["R", "Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ", false, null, null, false],
    hips_service_url: [null, "HiPS access url – Format: URL", false, null, null, false],
    hips_status: ["R", "HiPS status", false, "public master clonableOnce", null, true],
    hips_estsize: [null, "HiPS size estimation – Format: positive integer – Unit : KB", false, null, null, false],
    hips_frame: ["R", "Coordinate frame reference", false, null, HIPS_FRAME, false],
    hips_order: ["R", "Deepest HiPS order – Format: positive integer", false, null, null, false],
    hips_tile_width: [null, "Tiles width in pixels – Format: positive integer", false, 512, null, false],
    hips_tile_format: ["R", "List of available tile formats. The first one is the default suggested to the client", false, null, HIPS_TILE_FORMAT, true],
    hips_pixel_cut: [null, "Suggested pixel display cut range (physical values) – Format: min max", null, null, null, true],
    hips_data_range: [null, "Pixel data range taken into account during the HiPS generation (physical values) – Format: min max – Ex : -18.5 510.5", false, null, null, true],
    hips_sampling: [null, "Sampling applied for the HiPS generation", false, null, SAMPLING, false],
    hips_overlay: [null, "Pixel composition method applied on the image overlay region during HiPS generation", false, null, PIXEL_OVERLAY, false],
    hips_skyval: [null, "Sky background subtraction method applied during HiPS generation", false, null, SKY_VAL, false],
    hips_pixel_bitpix: [null, "Fits tile BITPIX code", false, null, null, false],
    data_pixel_bitpix: [null, "Original data BITPIX code", false, null, null],
    dataproduct_type: ["R", "Type of data", false, null, DATA_PRODUCT_TYPE, false],
    dataproduct_subtype: ["RD", "Subtype of data", false, null, SUB_TYPE_DATA, false],
    hips_progenitor_url: [null, "URL to an associated progenitor HiPS", false, null, null, false],
    hips_cat_nrows: ["S", "Number of rows of the HiPS catalog", false, null, null, false],
    hips_cube_depth: ["RD", "Number of frames of the HiPS cube", false, null, null, false],
    hips_cube_firstframe: [null, "Initial first index frame to display for a HiPS cube", false, 0, null, false],
    data_cube_crpix3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
    data_cube_crval3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
    data_cube_cdelt3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
    data_cube_bunit3: [null, "Third axis unit (see FITS doc)", false, null, null, false],
    hips_initial_ra: ["S", "Default RA display position (ICRS frame) – Unit : degrees", false, null, null, false],
    hips_initial_dec: ["S", "Default DEC display position (ICRS frame) – Unit : degrees", false, null, null, false],
    hips_initial_fov: ["S", "Default display size – Unit : degrees", false, null, null, false],
    hips_pixel_scale: [null, "HiPS pixel angular resolution at the highest order – Unit : degrees", false, null, null, false],
    s_pixel_scale: [null, "Best pixel angular resolution of the original images – Unit : degrees", false, null, null, false],
    t_min: ["S", "Start time of the observations - Representation: MJD", false, null, null, false],
    t_max: ["S", "Stop time of the observations - Representation: MJD", false, null, null, false],
    em_min: ["S", "Start in spectral coordinates – Unit: meters", false, null, null, false],
    em_max: ["S", "Stop in spectral coordinates – Unit: meters", false, null, null, false],
    client_category: [null, "/ separated keywords suggesting a display hierarchy to the client – Ex : Image/InfraRed", false, null, null, false],
    client_sort_key: [null, "Sort key suggesting a display order to the client inside a client_category – Sort : alphanumeric", false, null, null, false],
    addendum_did: [null, "In case of “live” HiPS, creator_did of the added HiPS", true, null, null, false],
    moc_sky_fraction: [null, "Fraction of the sky covers by the MOC associated to the HiPS – Format: real between 0 and 1", false, null, null, false]
  };
  /**
   * Checks if the required attribute is stored in hipsMetadata.<br>
   * when the attribute is not stored, then store this information in requiredKeywordNotFound.
   * @param {HIPS_METADATA} hipsMetadata
   * @param {string} mandatory - "R" is a required parameter
   * @param {string} key - attribute to check
   * @param {string} description Key's description
   * @param requiredKeywordNotFound - Array or required information not found
   * @private
   */

  function _checkRequiredParameters(hipsMetadata, mandatory, key, description, requiredKeywordNotFound) {
    if (mandatory === "R" && !hipsMetadata.hasOwnProperty(key)) {
      //Fix for version=1.2
      if (key === "creator_did" && hipsMetadata.hips_version === "1.2") {
        hipsMetadata.creator_did = hipsMetadata.publisher_did;
        ErrorDialog.open(Constants.LEVEL.WARNING, "Deprecated Hips version <b>1.2</b> for " + hipsMetadata.obs_title, "please update it - <i>use creator_did=publisher_did</i>");
      } //Fix for version=1.3
      else if (key === "creator_did" && hipsMetadata.hips_version === "1.3") {
          hipsMetadata.creator_did = hipsMetadata.publisher_did;
          ErrorDialog.open(Constants.LEVEL.WARNING, "Deprecated Hips version <b>1.3</b> for " + hipsMetadata.obs_title, "please update it - <i>use creator_did=publisher_did</i>");
        } else if (key === "obs_title" && hipsMetadata.hips_version === "1.3") {
          hipsMetadata.obs_title = hipsMetadata.obs_collection;
          ErrorDialog.open(Constants.LEVEL.WARNING, "Deprecated Hips version <b>1.3</b> for " + hipsMetadata.obs_title, "please update it - <i>use obs_title=obs_collection</i>");
        } //Fox for version 1.4
        else if (key === "obs_title" && hipsMetadata.hips_version === "1.4") {
            hipsMetadata.obs_title = hipsMetadata.obs_collection;
            ErrorDialog.open(Constants.LEVEL.WARNING, "obs_title not found in v1.4 for " + hipsMetadata.obs_title, "use obs_title, please fix it");
          } else if (key === "creator_did" && hipsMetadata.hips_version === "1.4") {
            hipsMetadata.creator_did = hipsMetadata.publisher_did;
            ErrorDialog.open(Constants.LEVEL.WARNING, "creator_did not found in v1.4 for " + hipsMetadata.obs_title, "use creator_did, please fix it");
          } /// very old version
          else if (key === "hips_version" && !hipsMetadata.hasOwnProperty("hips_version")) {
              hipsMetadata.hips_version = "very old one";
              ErrorDialog.open(Constants.LEVEL.WARNING, "Deprecated Hips version <b>unknown</b> for " + hipsMetadata.obs_title, "please update it - <i>use a version in your metadata</i>");
            } else if (key === "creator_did" && !hipsMetadata.hasOwnProperty("hips_version")) {
              hipsMetadata.creator_did = hipsMetadata.publisher_did;
              ErrorDialog.open(Constants.LEVEL.WARNING, "Deprecated Hips version <b>unknown</b> for " + hipsMetadata.obs_title, "please update it - <i>use creator_did = pulisher_did</i>");
            } //Error
            else {
                requiredKeywordNotFound.push(key + " (" + description + ") is not present. ");
              }
    }
  }
  /**
   *
   * @param {boolean} valueArray - is an Array
   * @param {string} key - attribute
   * @param {HIPS_METADATA} hipsMetadata
   * @private
   */


  function _transformAStringToArray(valueArray, key, hipsMetadata) {
    if (valueArray && hipsMetadata.hasOwnProperty(key)) {
      hipsMetadata[key] = hipsMetadata[key].split(/\s+/);
    }
  }
  /**
   * fills hipsMetadata with the default value when the key is not present
   * @param {string} key - key
   * @param {string} defaultValue - default value
   * @param {HIPS_METADATA} hipsMetadata
   * @private
   */


  function _fillWithDefaultValue(key, defaultValue, hipsMetadata) {
    if (defaultValue !== null && !hipsMetadata.hasOwnProperty(key)) {
      hipsMetadata[key] = defaultValue;
    }
  }
  /**
   * Validates and fixes metadata
   * @param {HIPS_METADATA} hipsMetadata
   * @throws RangeError - "unvalid hips metadata"
   */


  function _validateAndFixHips(hipsMetadata) {
    var requiredKeywordNotFound = [];
    var valueNotRight = [];
    var values, mandatory, description, defaultValue, distinctValue, valueArray; //  isMutiple,

    for (var key in HipsVersion_1_4) {
      if (HipsVersion_1_4.hasOwnProperty(key)) {
        values = HipsVersion_1_4[key];
        mandatory = values[0];
        description = values[1];
        defaultValue = values[3];
        distinctValue = values[4];
        valueArray = values[5]; // checking the required parameter is here

        _checkRequiredParameters.call(this, hipsMetadata, mandatory, key, description, requiredKeywordNotFound); // Transforms a key's value into an array when it is necessary and store the result in hipsMetadata


        _transformAStringToArray.call(this, valueArray, key, hipsMetadata); // checking the value of the parameter among a list of values
        //_checkValueAmongEnumeratedList.call(this, key, valueArray, description, distinctValue, hipsMetadata, valueNotRight);
        // checking the key is here when a default value exists


        _fillWithDefaultValue.call(this, key, defaultValue, hipsMetadata);
      }
    }

    if (requiredKeywordNotFound.length > 0 || valueNotRight.length > 0) {
      var name = hipsMetadata.obs_title ? hipsMetadata.obs_title : hipsMetadata.obs_collection;
      var url = hipsMetadata.hips_service_url ? hipsMetadata.hips_service_url : this.baseUrl;
      throw new RangeError("HipsMetadata.js: unvalid hips metadata for " + name + " (" + url + "): \n" + requiredKeywordNotFound.toString() + "\n" + valueNotRight.toString());
    }
  }
  /**
   * Loads Hips properties
   * @param baseUrl
   * @throws ReferenceError - Unable to load the Hips
   * @return {*}
   */


  function _loadHipsProperties(baseUrl) {
    var properties = $__default['default'].ajax({
      type: "GET",
      datatype: "text",
      url: Proxy.proxify(baseUrl + "/properties"),
      async: false,
      beforeSend: function (xhr) {
        xhr.setRequestHeader("Accept", "text/plain");
      }
    }).responseText;

    if (typeof properties === "undefined") {
      throw new ReferenceError("Unable to load the Hips at " + baseUrl, "HipsMetadata.js");
    }

    var hipsProperties = _parseProperties.call(this, properties);

    _validateAndFixHips.call(this, hipsProperties);

    return hipsProperties;
  }
  /**
   * Parses properties
   * @param propertiestext
   * @return {{}}
   */


  function _parseProperties(propertiestext) {
    var propertyMap = {};
    var lines = propertiestext.split(/\r?\n/);
    var currentLine = "";
    $__default['default'].each(lines, function (i, value) {
      //check if it is a comment line
      if (!/^\s*(#|!|$)/.test(value)) {
        // line is whitespace or first non-whitespace character is '#' or '!'
        value = value.replace(/^\s*/, ""); // remove space at start of line

        currentLine += value;

        if (/(\\\\)*\\$/.test(currentLine)) {
          // line ends with an odd number of '\' (backslash)
          //line ends with continuation character, remember it and don't process further
          currentLine = currentLine.replace(/\\$/, "");
        } else {
          /^\s*((?:[^\s:=\\]|\\.)+)\s*[:=\s]\s*(.*)$/.test(currentLine); // sub-matches pick out key and value

          var nkey = RegExp.$1;
          var nvalue = RegExp.$2;

          if (propertyMap.hasOwnProperty(nkey)) {
            propertyMap[nkey] = propertyMap[nkey].isPrototypeOf(Array) ? propertyMap[nkey].push(nvalue) : [propertyMap[nkey], nvalue];
          } else {
            propertyMap[nkey] = nvalue;
          }

          currentLine = "";
        }
      }
    });
    return propertyMap;
  }
  /**
   * @name HipsMetadata
   * @class
   * Creates the Hips data model. When baseUrl is an URL, then the Hips properties is loaded by requesting
   * the properties file.
   * When the baseURl is the Hips description coming from registry, then the description is validated and fixed if needed.
   * @param baseUrl
   * @constructor
   */


  var HipsMetadata = function (baseUrl) {
    if (baseUrl == null) ; else if (typeof baseUrl === "string") {
      this.baseUrl = baseUrl;
      this.hipsMetadata = _loadHipsProperties.call(this, baseUrl);
    } else {
      this.hipsMetadata = baseUrl; // In hips registry, each record must provide at least creator_did, hips_release_date, hips_service_url, hips_status

      try {
        _validateAndFixHips.call(this, this.hipsMetadata);
      } catch (e) {
        this.baseUrl = this.hipsMetadata.hips_service_url;
        this.hipsMetadata = _loadHipsProperties.call(this, this.baseUrl);
      }
    }
  };
  /**
   * @name setMetadata
   * @param metadata
   * @memberof HipsMetadata#
   */


  HipsMetadata.prototype.setMetadata = function (metadata) {
    this.hipsMetadata = metadata;
    this.baseUrl = metadata.hips_service_url;
  };
  /**
   * Supported {@link GENERAL_WAVELENGTH wavelength}
   * @name GeneralWavelength
   * @memberof HipsMetadata#
   */


  HipsMetadata.prototype.GeneralWavelength = GENERAL_WAVELENGTH;
  /**
   * Supported {@link HIPS_FRAME Hips frame}
   * @name HipsFrame
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.HipsFrame = HIPS_FRAME;
  /**
   * Supported {@link HIPS_TILE_FORMAT Hips tile format}
   * @name HipsTileFormat
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.HipsTileFormat = HIPS_TILE_FORMAT;
  /**
   * Supported {@link SAMPLING Sampling}
   * @name Sampling
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.Sampling = SAMPLING;
  /**
   * Supported {@link PIXEL_OVERLAY pixel overlay}
   * @name PixelOverlay
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.PixelOverlay = PIXEL_OVERLAY;
  /**
   * Supported {@link SKY_VAL SkyVal}
   * @name SkyVal
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.SkyVal = SKY_VAL;
  /**
   * Supported {@link DATA_PRODUCT_TYPE DataProductType}
   * @name DataProductType
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.DataProductType = DATA_PRODUCT_TYPE;
  /**
   * Supported {@link SUB_TYPE_DATA SubTypeData}
   * @name SubTypeData
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.SubTypeData = SUB_TYPE_DATA;
  /**
   * Returns the Hips metadata.
   * @function getHipsMetadata
   * @returns {HIPS_METADATA}
   * @memberof HipsMetadata#
   */

  HipsMetadata.prototype.getHipsMetadata = function () {
    return this.hipsMetadata;
  };
  /**
   * Returns base URL
   * @function getBaseUrl
   * @returns {string} the URL of the Hips
   * @memberof HipsMetadata#
   */


  HipsMetadata.prototype.getBaseUrl = function () {
    return this.baseUrl;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * AbstractHipsLayer configuration
   * @typedef {AbstractLayer.configuration} AbstractHipsLayer.configuration
   * @property {Crs} [coordinateSystem = CoordinateSystemFactory.create({geoideName: Constants.MappingCrsHips2Mizar[this.hipsMetadata.hips_frame]})] - Coordinate reference system
   * @property {int} [tilePixelSize = hipsMetadata['hips_tile_width'] - Tiles width in pixels
   * @property {int} [baseLevel = 2] - min HiPS order
   * @property {HEALPixTiling} [tiling = new HEALPixTiling(options.baseLevel, {coordinateSystem: options.coordinateSystem})] - Tiling
   * @property {int} [numberOfLevels = hipsMetadata['hips_order']] - Deepest order min
   * @property {string} [name = hipsMetadata['obs_title']] - Data set title
   * @property {string} [attribution = <a href=\"" + this.hipsMetadata['obs_copyright_url'] + "\" target=\"_blank\">" + this.hipsMetadata['obs_copyright'] + "</a>"] - URL to a copyright mention
   * @property {string} [ack = hipsMetadata['obs_ack']] - Acknowledgment mention
   * @property {string} [icon = ""] - icon used as metadata representation on the map
   * @property {string} [description = hipsMetadata['obs_description']] - Data set description
   * @property {boolean} [visible = false] visibility by default on the map
   * @property {Object} properties - other metadata
   * @property {float} [properties.initialRa = undefined] - Initial RA
   * @property {float} [properties.initialDec = undefined] - Initial DEC
   * @property {float} [properties.initialFov = undefined] - Initial field of view
   * @property {float} [properties.mocCoverage = undefined] - Sky fraction coverage
   * @property {boolean} [pickable = false] - Pickable layer
   * @property {Array} [availableServices = {}] - List of services related to the layer
   * @property {Array} [format = hipsMetadata['hips_tile_format']] - List of available tile formats
   * @property {string} [baseUrl =  hipsMetadata['hips_service_url']] - Endpoint service
   * @property {string} [category = Image] - Default category
   * @property {boolean} background - Tell if the layer is set as background
   */

  /**
   * @name AbstractHipsLayer
   * @class
   * Abstract class for HIPS
   * @augments AbstractRasterLayer
   * @param {HipsMetadata} hipsMetadata
   * @param {AbstractHipsLayer.configuration} options - AbstractHipsLayer configuration
   * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
   * @throws ReferenceError - Some required parameters are missing
   * @constructor
   */

  var AbstractHipsLayer = function (hipsMetadata, options) {
    _checkAndSetDefaultOptions.call(this, options);

    this.hipsMetadata = _createMetadata.call(this, hipsMetadata, options.baseUrl);

    _overloadHipsMetataByConfiguration.call(this, options, this.hipsMetadata);

    options.tiling = new HEALPixTiling(options.baseLevel || 2, {
      coordinateSystem: options.coordinateSystem
    });
    options.icon = options.hasOwnProperty("icon") ? options.icon : options.mizarBaseUrl ? options.mizarBaseUrl + "css/images/star.png" : "";
    options.visible = options.hasOwnProperty("visible") ? options.visible : false;
    options.properties = options.hasOwnProperty("properties") ? options.properties : {};
    options.pickable = options.hasOwnProperty("pickable") ? options.pickable : false;
    options.services = options.hasOwnProperty("services") ? options.services : {};
    options.category = options.hasOwnProperty("category") ? options.category : "Image"; //this.hipsMetadata.client_category;

    if (this.hipsMetadata.hasOwnProperty("moc_access_url")) {
      options.services.Moc = {
        baseUrl: this.hipsMetadata.moc_access_url,
        skyFraction: this.hipsMetadata.moc_sky_fraction
      };
    } //Hack : set Galactic layer as background because only background owns two grids (equetorial and galactic)


    if (options.coordinateSystem.getGeoideName() === Constants.CRS.Galactic) {
      options.background = true;
    }

    AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.Hips, options);
    this.fitsSupported = _$1.contains(this.hipsMetadata.hips_tile_format, "fits");
  };
  /**
   * Check options.
   * @param options
   * @throws ReferenceError - Some required parameters are missing
   * @private
   */


  function _checkAndSetDefaultOptions(options) {
    if (!options) {
      throw new ReferenceError("Some required parameters are missing", "AbstractHipsLayer.js");
    } else {
      options.category = options.category || "Image";
      options.pickable = options.pickable || false;
    }
  }
  /**
   * Creates metadata.
   * @param hipsMetadata
   * @param baseUrl
   * @returns {*}
   * @private
   */


  function _createMetadata(hipsMetadata, baseUrl) {
    var metadata = hipsMetadata;

    if (typeof metadata === "undefined") {
      var hipsProperties = new HipsMetadata(baseUrl);
      metadata = hipsProperties.getHipsMetadata();
    }

    return metadata;
  }
  /**
   *
   * @param options
   * @param hipsMetadata
   * @private
   */


  function _overloadHipsMetataByConfiguration(options, hipsMetadata) {
    options.coordinateSystem = options.hasOwnProperty("coordinateSystem") ? CoordinateSystemFactory.create(options.coordinateSystem) : CoordinateSystemFactory.create({
      geoideName: Constants.MappingCrsHips2Mizar[hipsMetadata.hips_frame]
    });
    options.tilePixelSize = options.hasOwnProperty("tilePixelSize") ? options.tilePixelSize : hipsMetadata.hips_tile_width;
    options.baseLevel = options.hasOwnProperty("baseLevel") ? options.baseLevel : hipsMetadata.hasOwnProperty("hips_order_min") && hipsMetadata.hips_order_min >= 2 ? parseInt(hipsMetadata.hips_order_min) : 2;
    options.numberOfLevels = options.hasOwnProperty("numberOfLevels") ? options.numberOfLevels : parseInt(hipsMetadata.hips_order);
    options.name = options.hasOwnProperty("name") ? options.name : hipsMetadata.obs_title;
    options.attribution = options.hasOwnProperty("attribution") ? options.attribution : '<a href="' + hipsMetadata.obs_copyright_url + '" target="_blank">' + hipsMetadata.obs_copyright + "</a>";
    options.copyrightUrl = options.hasOwnProperty("copyrightUrl") ? options.copyrightUrl : hipsMetadata.obs_copyright_url;
    options.ack = options.hasOwnProperty("ack") ? options.ack : hipsMetadata.obs_ack;
    options.description = options.hasOwnProperty("description") ? options.description : hipsMetadata.obs_description;
    options.format = options.hasOwnProperty("format") ? options.format : hipsMetadata.hips_tile_format;
    options.baseUrl = options.hasOwnProperty("baseUrl") ? options.baseUrl : hipsMetadata.hips_service_url;
    options.properties = options.hasOwnProperty("properties") ? options.properties : {};

    if (hipsMetadata.hasOwnProperty("obs_initial_ra")) {
      options.properties.initialRa = parseFloat(hipsMetadata.obs_initial_ra);
    }

    if (hipsMetadata.hasOwnProperty("obs_initial_dec")) {
      options.properties.initialDec = parseFloat(hipsMetadata.obs_initial_dec);
    }

    if (hipsMetadata.hasOwnProperty("obs_initial_fov")) {
      options.properties.initialFov = Math.sqrt(360 * 360 / Math.PI * parseFloat(hipsMetadata.obs_initial_fov));
    }

    if (hipsMetadata.hasOwnProperty("moc_sky_fraction")) {
      options.properties.moc_sky_fraction = parseFloat(hipsMetadata.moc_sky_fraction);
    }
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractRasterLayer, AbstractHipsLayer);
  /**************************************************************************************************************/

  /**
   * Returns the Metadata related to Hips protocol.
   * @return {Object}
   * @memberof AbstractHipsLayer#
   */

  AbstractHipsLayer.prototype.getHipsMetadata = function () {
    return this.hipsMetadata;
  };

  var crc32 = createCommonjsModule(function (module) {
  (function () {

  	var table = [],
  		poly = 0xEDB88320; // reverse polynomial

  	// build the table
  	function makeTable() {
  		var c, n, k;

  		for (n = 0; n < 256; n += 1) {
  			c = n;
  			for (k = 0; k < 8; k += 1) {
  				if (c & 1) {
  					c = poly ^ (c >>> 1);
  				} else {
  					c = c >>> 1;
  				}
  			}
  			table[n] = c >>> 0;
  		}
  	}

  	function strToArr(str) {
  		// sweet hack to turn string into a 'byte' array
  		return Array.prototype.map.call(str, function (c) {
  			return c.charCodeAt(0);
  		});
  	}

  	/*
  	 * Compute CRC of array directly.
  	 *
  	 * This is slower for repeated calls, so append mode is not supported.
  	 */
  	function crcDirect(arr) {
  		var crc = -1, // initial contents of LFBSR
  			i, j, l, temp;

  		for (i = 0, l = arr.length; i < l; i += 1) {
  			temp = (crc ^ arr[i]) & 0xff;

  			// read 8 bits one at a time
  			for (j = 0; j < 8; j += 1) {
  				if ((temp & 1) === 1) {
  					temp = (temp >>> 1) ^ poly;
  				} else {
  					temp = (temp >>> 1);
  				}
  			}
  			crc = (crc >>> 8) ^ temp;
  		}

  		// flip bits
  		return crc ^ -1;
  	}

  	/*
  	 * Compute CRC with the help of a pre-calculated table.
  	 *
  	 * This supports append mode, if the second parameter is set.
  	 */
  	function crcTable(arr, append) {
  		var crc, i, l;

  		// if we're in append mode, don't reset crc
  		// if arr is null or undefined, reset table and return
  		if (typeof crcTable.crc === 'undefined' || !append || !arr) {
  			crcTable.crc = 0 ^ -1;

  			if (!arr) {
  				return;
  			}
  		}

  		// store in temp variable for minor speed gain
  		crc = crcTable.crc;

  		for (i = 0, l = arr.length; i < l; i += 1) {
  			crc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];
  		}

  		crcTable.crc = crc;

  		return crc ^ -1;
  	}

  	// build the table
  	// this isn't that costly, and most uses will be for table assisted mode
  	makeTable();

  	module.exports = function (val, direct) {
  		var val = (typeof val === 'string') ? strToArr(val) : val,
  			ret = direct ? crcDirect(val) : crcTable(val);

  		// convert to 2's complement hex
  		return (ret >>> 0).toString(16);
  	};
  	module.exports.direct = crcDirect;
  	module.exports.table = crcTable;
  }());
  });

  /*
   * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $
   *
   * original:
   * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
   */

  var rawinflate = createCommonjsModule(function (module) {
  /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0.0.1
   * LastModified: Dec 25 1999
   */

  /* Interface:
   * data = inflate(src);
   */

  (function () {
  	/* constant parameters */
  	var WSIZE = 32768, // Sliding Window size
  		STORED_BLOCK = 0,
  		STATIC_TREES = 1,
  		DYN_TREES = 2,

  	/* for inflate */
  		lbits = 9, // bits in base literal/length lookup table
  		dbits = 6, // bits in base distance lookup table

  	/* variables (inflate) */
  		slide,
  		wp, // current position in slide
  		fixed_tl = null, // inflate static
  		fixed_td, // inflate static
  		fixed_bl, // inflate static
  		fixed_bd, // inflate static
  		bit_buf, // bit buffer
  		bit_len, // bits in bit buffer
  		method,
  		eof,
  		copy_leng,
  		copy_dist,
  		tl, // literal length decoder table
  		td, // literal distance decoder table
  		bl, // number of bits decoded by tl
  		bd, // number of bits decoded by td

  		inflate_data,
  		inflate_pos,


  /* constant tables (inflate) */
  		MASK_BITS = [
  			0x0000,
  			0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
  			0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
  		],
  		// Tables for deflate from PKZIP's appnote.txt.
  		// Copy lengths for literal codes 257..285
  		cplens = [
  			3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  			35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  		],
  /* note: see note #13 above about the 258 in this list. */
  		// Extra bits for literal codes 257..285
  		cplext = [
  			0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
  			3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid
  		],
  		// Copy offsets for distance codes 0..29
  		cpdist = [
  			1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  			257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  			8193, 12289, 16385, 24577
  		],
  		// Extra bits for distance codes
  		cpdext = [
  			0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
  			7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
  			12, 12, 13, 13
  		],
  		// Order of the bit length code lengths
  		border = [
  			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  		];
  	/* objects (inflate) */

  	function HuftList() {
  		this.next = null;
  		this.list = null;
  	}

  	function HuftNode() {
  		this.e = 0; // number of extra bits or operation
  		this.b = 0; // number of bits in this code or subcode

  		// union
  		this.n = 0; // literal, length base, or distance base
  		this.t = null; // (HuftNode) pointer to next level of table
  	}

  	/*
  	 * @param b-  code lengths in bits (all assumed <= BMAX)
  	 * @param n- number of codes (assumed <= N_MAX)
  	 * @param s- number of simple-valued codes (0..s-1)
  	 * @param d- list of base values for non-simple codes
  	 * @param e- list of extra bits for non-simple codes
  	 * @param mm- maximum lookup bits
  	 */
  	function HuftBuild(b, n, s, d, e, mm) {
  		this.BMAX = 16; // maximum bit length of any code
  		this.N_MAX = 288; // maximum number of codes in any set
  		this.status = 0; // 0: success, 1: incomplete table, 2: bad input
  		this.root = null; // (HuftList) starting table
  		this.m = 0; // maximum lookup bits, returns actual

  	/* Given a list of code lengths and a maximum table size, make a set of
  	   tables to decode that set of codes. Return zero on success, one if
  	   the given code set is incomplete (the tables are still built in this
  	   case), two if the input is invalid (all zero length codes or an
  	   oversubscribed set of lengths), and three if not enough memory.
  	   The code with value 256 is special, and the tables are constructed
  	   so that no bits beyond that code are fetched when that code is
  	   decoded. */
  		var a; // counter for codes of length k
  		var c = [];
  		var el; // length of EOB code (value 256)
  		var f; // i repeats in table every f entries
  		var g; // maximum code length
  		var h; // table level
  		var i; // counter, current code
  		var j; // counter
  		var k; // number of bits in current code
  		var lx = [];
  		var p; // pointer into c[], b[], or v[]
  		var pidx; // index of p
  		var q; // (HuftNode) points to current table
  		var r = new HuftNode(); // table entry for structure assignment
  		var u = [];
  		var v = [];
  		var w;
  		var x = [];
  		var xp; // pointer into x or c
  		var y; // number of dummy codes added
  		var z; // number of entries in current table
  		var o;
  		var tail; // (HuftList)

  		tail = this.root = null;

  		// bit length count table
  		for (i = 0; i < this.BMAX + 1; i++) {
  			c[i] = 0;
  		}
  		// stack of bits per table
  		for (i = 0; i < this.BMAX + 1; i++) {
  			lx[i] = 0;
  		}
  		// HuftNode[BMAX][]  table stack
  		for (i = 0; i < this.BMAX; i++) {
  			u[i] = null;
  		}
  		// values in order of bit length
  		for (i = 0; i < this.N_MAX; i++) {
  			v[i] = 0;
  		}
  		// bit offsets, then code stack
  		for (i = 0; i < this.BMAX + 1; i++) {
  			x[i] = 0;
  		}

  		// Generate counts for each bit length
  		el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
  		p = b; pidx = 0;
  		i = n;
  		do {
  			c[p[pidx]]++; // assume all entries <= BMAX
  			pidx++;
  		} while (--i > 0);
  		if (c[0] === n) { // null input--all zero length codes
  			this.root = null;
  			this.m = 0;
  			this.status = 0;
  			return;
  		}

  		// Find minimum and maximum length, bound *m by those
  		for (j = 1; j <= this.BMAX; j++) {
  			if (c[j] !== 0) {
  				break;
  			}
  		}
  		k = j; // minimum code length
  		if (mm < j) {
  			mm = j;
  		}
  		for (i = this.BMAX; i !== 0; i--) {
  			if (c[i] !== 0) {
  				break;
  			}
  		}
  		g = i; // maximum code length
  		if (mm > i) {
  			mm = i;
  		}

  		// Adjust last length count to fill out codes, if needed
  		for (y = 1 << j; j < i; j++, y <<= 1) {
  			if ((y -= c[j]) < 0) {
  				this.status = 2; // bad input: more codes than bits
  				this.m = mm;
  				return;
  			}
  		}
  		if ((y -= c[i]) < 0) {
  			this.status = 2;
  			this.m = mm;
  			return;
  		}
  		c[i] += y;

  		// Generate starting offsets into the value table for each length
  		x[1] = j = 0;
  		p = c;
  		pidx = 1;
  		xp = 2;
  		while (--i > 0) { // note that i == g from above
  			x[xp++] = (j += p[pidx++]);
  		}

  		// Make a table of values in order of bit lengths
  		p = b; pidx = 0;
  		i = 0;
  		do {
  			if ((j = p[pidx++]) !== 0) {
  				v[x[j]++] = i;
  			}
  		} while (++i < n);
  		n = x[g]; // set n to length of v

  		// Generate the Huffman codes and for each, make the table entries
  		x[0] = i = 0; // first Huffman code is zero
  		p = v; pidx = 0; // grab values in bit order
  		h = -1; // no tables yet--level -1
  		w = lx[0] = 0; // no bits decoded yet
  		q = null; // ditto
  		z = 0; // ditto

  		// go through the bit lengths (k already is bits in shortest code)
  		for (null; k <= g; k++) {
  			a = c[k];
  			while (a-- > 0) {
  				// here i is the Huffman code of length k bits for value p[pidx]
  				// make tables up to required level
  				while (k > w + lx[1 + h]) {
  					w += lx[1 + h]; // add bits already decoded
  					h++;

  					// compute minimum size table less than or equal to *m bits
  					z = (z = g - w) > mm ? mm : z; // upper limit
  					if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
  						// too few codes for k-w bit table
  						f -= a + 1; // deduct codes from patterns left
  						xp = k;
  						while (++j < z) { // try smaller tables up to z bits
  							if ((f <<= 1) <= c[++xp]) {
  								break; // enough codes to use up j bits
  							}
  							f -= c[xp]; // else deduct codes from patterns
  						}
  					}
  					if (w + j > el && w < el) {
  						j = el - w; // make EOB code end at table
  					}
  					z = 1 << j; // table entries for j-bit table
  					lx[1 + h] = j; // set table size in stack

  					// allocate and link in new table
  					q = [];
  					for (o = 0; o < z; o++) {
  						q[o] = new HuftNode();
  					}

  					if (!tail) {
  						tail = this.root = new HuftList();
  					} else {
  						tail = tail.next = new HuftList();
  					}
  					tail.next = null;
  					tail.list = q;
  					u[h] = q; // table starts after link

  					/* connect to last table, if there is one */
  					if (h > 0) {
  						x[h] = i; // save pattern for backing up
  						r.b = lx[h]; // bits to dump before this table
  						r.e = 16 + j; // bits in this table
  						r.t = q; // pointer to this table
  						j = (i & ((1 << w) - 1)) >> (w - lx[h]);
  						u[h - 1][j].e = r.e;
  						u[h - 1][j].b = r.b;
  						u[h - 1][j].n = r.n;
  						u[h - 1][j].t = r.t;
  					}
  				}

  				// set up table entry in r
  				r.b = k - w;
  				if (pidx >= n) {
  					r.e = 99; // out of values--invalid code
  				} else if (p[pidx] < s) {
  					r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
  					r.n = p[pidx++]; // simple code is just the value
  				} else {
  					r.e = e[p[pidx] - s]; // non-simple--look up in lists
  					r.n = d[p[pidx++] - s];
  				}

  				// fill code-like entries with r //
  				f = 1 << (k - w);
  				for (j = i >> w; j < z; j += f) {
  					q[j].e = r.e;
  					q[j].b = r.b;
  					q[j].n = r.n;
  					q[j].t = r.t;
  				}

  				// backwards increment the k-bit code i
  				for (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {
  					i ^= j;
  				}
  				i ^= j;

  				// backup over finished tables
  				while ((i & ((1 << w) - 1)) !== x[h]) {
  					w -= lx[h]; // don't need to update q
  					h--;
  				}
  			}
  		}

  		/* return actual size of base table */
  		this.m = lx[1];

  		/* Return true (1) if we were given an incomplete table */
  		this.status = ((y !== 0 && g !== 1) ? 1 : 0);
  	}


  	/* routines (inflate) */

  	function GET_BYTE() {
  		if (inflate_data.length === inflate_pos) {
  			return -1;
  		}
  		return inflate_data[inflate_pos++] & 0xff;
  	}

  	function NEEDBITS(n) {
  		while (bit_len < n) {
  			bit_buf |= GET_BYTE() << bit_len;
  			bit_len += 8;
  		}
  	}

  	function GETBITS(n) {
  		return bit_buf & MASK_BITS[n];
  	}

  	function DUMPBITS(n) {
  		bit_buf >>= n;
  		bit_len -= n;
  	}

  	function inflate_codes(buff, off, size) {
  		// inflate (decompress) the codes in a deflated (compressed) block.
  		// Return an error code or zero if it all goes ok.
  		var e; // table entry flag/number of extra bits
  		var t; // (HuftNode) pointer to table entry
  		var n;

  		if (size === 0) {
  			return 0;
  		}

  		// inflate the coded data
  		n = 0;
  		for (;;) { // do until end of block
  			NEEDBITS(bl);
  			t = tl.list[GETBITS(bl)];
  			e = t.e;
  			while (e > 16) {
  				if (e === 99) {
  					return -1;
  				}
  				DUMPBITS(t.b);
  				e -= 16;
  				NEEDBITS(e);
  				t = t.t[GETBITS(e)];
  				e = t.e;
  			}
  			DUMPBITS(t.b);

  			if (e === 16) { // then it's a literal
  				wp &= WSIZE - 1;
  				buff[off + n++] = slide[wp++] = t.n;
  				if (n === size) {
  					return size;
  				}
  				continue;
  			}

  			// exit if end of block
  			if (e === 15) {
  				break;
  			}

  			// it's an EOB or a length

  			// get length of block to copy
  			NEEDBITS(e);
  			copy_leng = t.n + GETBITS(e);
  			DUMPBITS(e);

  			// decode distance of block to copy
  			NEEDBITS(bd);
  			t = td.list[GETBITS(bd)];
  			e = t.e;

  			while (e > 16) {
  				if (e === 99) {
  					return -1;
  				}
  				DUMPBITS(t.b);
  				e -= 16;
  				NEEDBITS(e);
  				t = t.t[GETBITS(e)];
  				e = t.e;
  			}
  			DUMPBITS(t.b);
  			NEEDBITS(e);
  			copy_dist = wp - t.n - GETBITS(e);
  			DUMPBITS(e);

  			// do the copy
  			while (copy_leng > 0 && n < size) {
  				copy_leng--;
  				copy_dist &= WSIZE - 1;
  				wp &= WSIZE - 1;
  				buff[off + n++] = slide[wp++] = slide[copy_dist++];
  			}

  			if (n === size) {
  				return size;
  			}
  		}

  		method = -1; // done
  		return n;
  	}

  	function inflate_stored(buff, off, size) {
  		/* "decompress" an inflated type 0 (stored) block. */
  		var n;

  		// go to byte boundary
  		n = bit_len & 7;
  		DUMPBITS(n);

  		// get the length and its complement
  		NEEDBITS(16);
  		n = GETBITS(16);
  		DUMPBITS(16);
  		NEEDBITS(16);
  		if (n !== ((~bit_buf) & 0xffff)) {
  			return -1; // error in compressed data
  		}
  		DUMPBITS(16);

  		// read and output the compressed data
  		copy_leng = n;

  		n = 0;
  		while (copy_leng > 0 && n < size) {
  			copy_leng--;
  			wp &= WSIZE - 1;
  			NEEDBITS(8);
  			buff[off + n++] = slide[wp++] = GETBITS(8);
  			DUMPBITS(8);
  		}

  		if (copy_leng === 0) {
  			method = -1; // done
  		}
  		return n;
  	}

  	function inflate_fixed(buff, off, size) {
  		// decompress an inflated type 1 (fixed Huffman codes) block.  We should
  		// either replace this with a custom decoder, or at least precompute the
  		// Huffman tables.

  		// if first time, set up tables for fixed blocks
  		if (!fixed_tl) {
  			var i; // temporary variable
  			var l = []; // 288 length list for huft_build (initialized below)
  			var h; // HuftBuild

  			// literal table
  			for (i = 0; i < 144; i++) {
  				l[i] = 8;
  			}
  			for (null; i < 256; i++) {
  				l[i] = 9;
  			}
  			for (null; i < 280; i++) {
  				l[i] = 7;
  			}
  			for (null; i < 288; i++) { // make a complete, but wrong code set
  				l[i] = 8;
  			}
  			fixed_bl = 7;

  			h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);
  			if (h.status !== 0) {
  				console.error("HufBuild error: " + h.status);
  				return -1;
  			}
  			fixed_tl = h.root;
  			fixed_bl = h.m;

  			// distance table
  			for (i = 0; i < 30; i++) { // make an incomplete code set
  				l[i] = 5;
  			}
  			fixed_bd = 5;

  			h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);
  			if (h.status > 1) {
  				fixed_tl = null;
  				console.error("HufBuild error: " + h.status);
  				return -1;
  			}
  			fixed_td = h.root;
  			fixed_bd = h.m;
  		}

  		tl = fixed_tl;
  		td = fixed_td;
  		bl = fixed_bl;
  		bd = fixed_bd;
  		return inflate_codes(buff, off, size);
  	}

  	function inflate_dynamic(buff, off, size) {
  		// decompress an inflated type 2 (dynamic Huffman codes) block.
  		var i; // temporary variables
  		var j;
  		var l; // last length
  		var n; // number of lengths to get
  		var t; // (HuftNode) literal/length code table
  		var nb; // number of bit length codes
  		var nl; // number of literal/length codes
  		var nd; // number of distance codes
  		var ll = [];
  		var h; // (HuftBuild)

  		// literal/length and distance code lengths
  		for (i = 0; i < 286 + 30; i++) {
  			ll[i] = 0;
  		}

  		// read in table lengths
  		NEEDBITS(5);
  		nl = 257 + GETBITS(5); // number of literal/length codes
  		DUMPBITS(5);
  		NEEDBITS(5);
  		nd = 1 + GETBITS(5); // number of distance codes
  		DUMPBITS(5);
  		NEEDBITS(4);
  		nb = 4 + GETBITS(4); // number of bit length codes
  		DUMPBITS(4);
  		if (nl > 286 || nd > 30) {
  			return -1; // bad lengths
  		}

  		// read in bit-length-code lengths
  		for (j = 0; j < nb; j++) {
  			NEEDBITS(3);
  			ll[border[j]] = GETBITS(3);
  			DUMPBITS(3);
  		}
  		for (null; j < 19; j++) {
  			ll[border[j]] = 0;
  		}

  		// build decoding table for trees--single level, 7 bit lookup
  		bl = 7;
  		h = new HuftBuild(ll, 19, 19, null, null, bl);
  		if (h.status !== 0) {
  			return -1; // incomplete code set
  		}

  		tl = h.root;
  		bl = h.m;

  		// read in literal and distance code lengths
  		n = nl + nd;
  		i = l = 0;
  		while (i < n) {
  			NEEDBITS(bl);
  			t = tl.list[GETBITS(bl)];
  			j = t.b;
  			DUMPBITS(j);
  			j = t.n;
  			if (j < 16) { // length of code in bits (0..15)
  				ll[i++] = l = j; // save last length in l
  			} else if (j === 16) { // repeat last length 3 to 6 times
  				NEEDBITS(2);
  				j = 3 + GETBITS(2);
  				DUMPBITS(2);
  				if (i + j > n) {
  					return -1;
  				}
  				while (j-- > 0) {
  					ll[i++] = l;
  				}
  			} else if (j === 17) { // 3 to 10 zero length codes
  				NEEDBITS(3);
  				j = 3 + GETBITS(3);
  				DUMPBITS(3);
  				if (i + j > n) {
  					return -1;
  				}
  				while (j-- > 0) {
  					ll[i++] = 0;
  				}
  				l = 0;
  			} else { // j === 18: 11 to 138 zero length codes
  				NEEDBITS(7);
  				j = 11 + GETBITS(7);
  				DUMPBITS(7);
  				if (i + j > n) {
  					return -1;
  				}
  				while (j-- > 0) {
  					ll[i++] = 0;
  				}
  				l = 0;
  			}
  		}

  		// build the decoding tables for literal/length and distance codes
  		bl = lbits;
  		h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);
  		if (bl === 0) { // no literals or lengths
  			h.status = 1;
  		}
  		if (h.status !== 0) {
  			if (h.status !== 1) {
  				return -1; // incomplete code set
  			}
  			// **incomplete literal tree**
  		}
  		tl = h.root;
  		bl = h.m;

  		for (i = 0; i < nd; i++) {
  			ll[i] = ll[i + nl];
  		}
  		bd = dbits;
  		h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);
  		td = h.root;
  		bd = h.m;

  		if (bd === 0 && nl > 257) { // lengths but no distances
  			// **incomplete distance tree**
  			return -1;
  		}
  /*
  		if (h.status === 1) {
  			// **incomplete distance tree**
  		}
  */
  		if (h.status !== 0) {
  			return -1;
  		}

  		// decompress until an end-of-block code
  		return inflate_codes(buff, off, size);
  	}

  	function inflate_start() {
  		if (!slide) {
  			slide = []; // new Array(2 * WSIZE); // slide.length is never called
  		}
  		wp = 0;
  		bit_buf = 0;
  		bit_len = 0;
  		method = -1;
  		eof = false;
  		copy_leng = copy_dist = 0;
  		tl = null;
  	}

  	function inflate_internal(buff, off, size) {
  		// decompress an inflated entry
  		var n, i;

  		n = 0;
  		while (n < size) {
  			if (eof && method === -1) {
  				return n;
  			}

  			if (copy_leng > 0) {
  				if (method !== STORED_BLOCK) {
  					// STATIC_TREES or DYN_TREES
  					while (copy_leng > 0 && n < size) {
  						copy_leng--;
  						copy_dist &= WSIZE - 1;
  						wp &= WSIZE - 1;
  						buff[off + n++] = slide[wp++] = slide[copy_dist++];
  					}
  				} else {
  					while (copy_leng > 0 && n < size) {
  						copy_leng--;
  						wp &= WSIZE - 1;
  						NEEDBITS(8);
  						buff[off + n++] = slide[wp++] = GETBITS(8);
  						DUMPBITS(8);
  					}
  					if (copy_leng === 0) {
  						method = -1; // done
  					}
  				}
  				if (n === size) {
  					return n;
  				}
  			}

  			if (method === -1) {
  				if (eof) {
  					break;
  				}

  				// read in last block bit
  				NEEDBITS(1);
  				if (GETBITS(1) !== 0) {
  					eof = true;
  				}
  				DUMPBITS(1);

  				// read in block type
  				NEEDBITS(2);
  				method = GETBITS(2);
  				DUMPBITS(2);
  				tl = null;
  				copy_leng = 0;
  			}

  			switch (method) {
  			case STORED_BLOCK:
  				i = inflate_stored(buff, off + n, size - n);
  				break;

  			case STATIC_TREES:
  				if (tl) {
  					i = inflate_codes(buff, off + n, size - n);
  				} else {
  					i = inflate_fixed(buff, off + n, size - n);
  				}
  				break;

  			case DYN_TREES:
  				if (tl) {
  					i = inflate_codes(buff, off + n, size - n);
  				} else {
  					i = inflate_dynamic(buff, off + n, size - n);
  				}
  				break;

  			default: // error
  				i = -1;
  				break;
  			}

  			if (i === -1) {
  				if (eof) {
  					return 0;
  				}
  				return -1;
  			}
  			n += i;
  		}
  		return n;
  	}

  	function inflate(arr) {
  		var buff = [], i;

  		inflate_start();
  		inflate_data = arr;
  		inflate_pos = 0;

  		do {
  			i = inflate_internal(buff, buff.length, 1024);
  		} while (i > 0);
  		inflate_data = null; // G.C.
  		return buff;
  	}

  	module.exports = inflate;
  }());
  });

  /*
   * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $
   *
   * Original:
   *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
   */

  var rawdeflate = createCommonjsModule(function (module) {
  /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0.1
   * LastModified: Dec 25 1999
   */

  /* Interface:
   * data = deflate(src);
   */

  (function () {
  	/* constant parameters */
  	var WSIZE = 32768, // Sliding Window size
  		STORED_BLOCK = 0,
  		STATIC_TREES = 1,
  		DYN_TREES = 2,

  	/* for deflate */
  		DEFAULT_LEVEL = 6,
  		//INBUF_EXTRA = 64, // Extra buffer
  		OUTBUFSIZ = 1024 * 8,
  		window_size = 2 * WSIZE,
  		MIN_MATCH = 3,
  		MAX_MATCH = 258,
  		// for SMALL_MEM
  		LIT_BUFSIZE = 0x2000,
  //		HASH_BITS = 13,
  	//for MEDIUM_MEM
  	//	LIT_BUFSIZE = 0x4000,
  	//	HASH_BITS = 14,
  	// for BIG_MEM
  	//	LIT_BUFSIZE = 0x8000,
  		HASH_BITS = 15,
  		DIST_BUFSIZE = LIT_BUFSIZE,
  		HASH_SIZE = 1 << HASH_BITS,
  		HASH_MASK = HASH_SIZE - 1,
  		WMASK = WSIZE - 1,
  		NIL = 0, // Tail of hash chains
  		TOO_FAR = 4096,
  		MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
  		MAX_DIST = WSIZE - MIN_LOOKAHEAD,
  		SMALLEST = 1,
  		MAX_BITS = 15,
  		MAX_BL_BITS = 7,
  		LENGTH_CODES = 29,
  		LITERALS = 256,
  		END_BLOCK = 256,
  		L_CODES = LITERALS + 1 + LENGTH_CODES,
  		D_CODES = 30,
  		BL_CODES = 19,
  		REP_3_6 = 16,
  		REPZ_3_10 = 17,
  		REPZ_11_138 = 18,
  		HEAP_SIZE = 2 * L_CODES + 1,
  		H_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),

  	/* variables */
  		free_queue,
  		qhead,
  		qtail,
  		initflag,
  		outbuf = null,
  		outcnt,
  		outoff,
  		complete,
  		window,
  		d_buf,
  		l_buf,
  		prev,
  		bi_buf,
  		bi_valid,
  		block_start,
  		ins_h,
  		hash_head,
  		prev_match,
  		match_available,
  		match_length,
  		prev_length,
  		strstart,
  		match_start,
  		eofile,
  		lookahead,
  		max_chain_length,
  		max_lazy_match,
  		compr_level,
  		good_match,
  		nice_match,
  		dyn_ltree,
  		dyn_dtree,
  		static_ltree,
  		static_dtree,
  		bl_tree,
  		l_desc,
  		d_desc,
  		bl_desc,
  		bl_count,
  		heap,
  		heap_len,
  		heap_max,
  		depth,
  		length_code,
  		dist_code,
  		base_length,
  		base_dist,
  		flag_buf,
  		last_lit,
  		last_dist,
  		last_flags,
  		flags,
  		flag_bit,
  		opt_len,
  		static_len,
  		deflate_data,
  		deflate_pos;

  	/* objects (deflate) */

  	function DeflateCT() {
  		this.fc = 0; // frequency count or bit string
  		this.dl = 0; // father node in Huffman tree or length of bit string
  	}

  	function DeflateTreeDesc() {
  		this.dyn_tree = null; // the dynamic tree
  		this.static_tree = null; // corresponding static tree or NULL
  		this.extra_bits = null; // extra bits for each code or NULL
  		this.extra_base = 0; // base index for extra_bits
  		this.elems = 0; // max number of elements in the tree
  		this.max_length = 0; // max bit length for the codes
  		this.max_code = 0; // largest code with non zero frequency
  	}

  	/* Values for max_lazy_match, good_match and max_chain_length, depending on
  	 * the desired pack level (0..9). The values given below have been tuned to
  	 * exclude worst case performance for pathological files. Better values may be
  	 * found for specific files.
  	 */
  	function DeflateConfiguration(a, b, c, d) {
  		this.good_length = a; // reduce lazy search above this match length
  		this.max_lazy = b; // do not perform lazy search above this match length
  		this.nice_length = c; // quit search above this match length
  		this.max_chain = d;
  	}

  	function DeflateBuffer() {
  		this.next = null;
  		this.len = 0;
  		this.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read
  		this.off = 0;
  	}

  	/* constant tables */
  	var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
  	var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  	var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
  	var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  	var configuration_table = [
  		new DeflateConfiguration(0, 0, 0, 0),
  		new DeflateConfiguration(4, 4, 8, 4),
  		new DeflateConfiguration(4, 5, 16, 8),
  		new DeflateConfiguration(4, 6, 32, 32),
  		new DeflateConfiguration(4, 4, 16, 16),
  		new DeflateConfiguration(8, 16, 32, 32),
  		new DeflateConfiguration(8, 16, 128, 128),
  		new DeflateConfiguration(8, 32, 128, 256),
  		new DeflateConfiguration(32, 128, 258, 1024),
  		new DeflateConfiguration(32, 258, 258, 4096)
  	];


  	/* routines (deflate) */

  	function deflate_start(level) {
  		var i;

  		if (!level) {
  			level = DEFAULT_LEVEL;
  		} else if (level < 1) {
  			level = 1;
  		} else if (level > 9) {
  			level = 9;
  		}

  		compr_level = level;
  		initflag = false;
  		eofile = false;
  		if (outbuf !== null) {
  			return;
  		}

  		free_queue = qhead = qtail = null;
  		outbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called
  		window = []; // new Array(window_size); // window.length never called
  		d_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called
  		l_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called
  		prev = []; // new Array(1 << BITS); // prev.length never called

  		dyn_ltree = [];
  		for (i = 0; i < HEAP_SIZE; i++) {
  			dyn_ltree[i] = new DeflateCT();
  		}
  		dyn_dtree = [];
  		for (i = 0; i < 2 * D_CODES + 1; i++) {
  			dyn_dtree[i] = new DeflateCT();
  		}
  		static_ltree = [];
  		for (i = 0; i < L_CODES + 2; i++) {
  			static_ltree[i] = new DeflateCT();
  		}
  		static_dtree = [];
  		for (i = 0; i < D_CODES; i++) {
  			static_dtree[i] = new DeflateCT();
  		}
  		bl_tree = [];
  		for (i = 0; i < 2 * BL_CODES + 1; i++) {
  			bl_tree[i] = new DeflateCT();
  		}
  		l_desc = new DeflateTreeDesc();
  		d_desc = new DeflateTreeDesc();
  		bl_desc = new DeflateTreeDesc();
  		bl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called
  		heap = []; // new Array(2*L_CODES+1); // heap.length never called
  		depth = []; // new Array(2*L_CODES+1); // depth.length never called
  		length_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called
  		dist_code = []; // new Array(512); // dist_code.length never called
  		base_length = []; // new Array(LENGTH_CODES); // base_length.length never called
  		base_dist = []; // new Array(D_CODES); // base_dist.length never called
  		flag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called
  	}

  	function reuse_queue(p) {
  		p.next = free_queue;
  		free_queue = p;
  	}

  	function new_queue() {
  		var p;

  		if (free_queue !== null) {
  			p = free_queue;
  			free_queue = free_queue.next;
  		} else {
  			p = new DeflateBuffer();
  		}
  		p.next = null;
  		p.len = p.off = 0;

  		return p;
  	}

  	function head1(i) {
  		return prev[WSIZE + i];
  	}

  	function head2(i, val) {
  		return (prev[WSIZE + i] = val);
  	}

  	/* put_byte is used for the compressed output, put_ubyte for the
  	 * uncompressed output. However unlzw() uses window for its
  	 * suffix table instead of its output buffer, so it does not use put_ubyte
  	 * (to be cleaned up).
  	 */
  	function put_byte(c) {
  		outbuf[outoff + outcnt++] = c;
  		if (outoff + outcnt === OUTBUFSIZ) {
  			qoutbuf();
  		}
  	}

  	/* Output a 16 bit value, lsb first */
  	function put_short(w) {
  		w &= 0xffff;
  		if (outoff + outcnt < OUTBUFSIZ - 2) {
  			outbuf[outoff + outcnt++] = (w & 0xff);
  			outbuf[outoff + outcnt++] = (w >>> 8);
  		} else {
  			put_byte(w & 0xff);
  			put_byte(w >>> 8);
  		}
  	}

  	/* ==========================================================================
  	 * Insert string s in the dictionary and set match_head to the previous head
  	 * of the hash chain (the most recent string with same hash key). Return
  	 * the previous length of the hash chain.
  	 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
  	 *    input characters and the first MIN_MATCH bytes of s are valid
  	 *    (except for the last MIN_MATCH-1 bytes of the input file).
  	 */
  	function INSERT_STRING() {
  		ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + MIN_MATCH - 1] & 0xff)) & HASH_MASK;
  		hash_head = head1(ins_h);
  		prev[strstart & WMASK] = hash_head;
  		head2(ins_h, strstart);
  	}

  	/* Send a code of the given tree. c and tree must not have side effects */
  	function SEND_CODE(c, tree) {
  		send_bits(tree[c].fc, tree[c].dl);
  	}

  	/* Mapping from a distance to a distance code. dist is the distance - 1 and
  	 * must not have side effects. dist_code[256] and dist_code[257] are never
  	 * used.
  	 */
  	function D_CODE(dist) {
  		return (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;
  	}

  	/* ==========================================================================
  	 * Compares to subtrees, using the tree depth as tie breaker when
  	 * the subtrees have equal frequency. This minimizes the worst case length.
  	 */
  	function SMALLER(tree, n, m) {
  		return tree[n].fc < tree[m].fc || (tree[n].fc === tree[m].fc && depth[n] <= depth[m]);
  	}

  	/* ==========================================================================
  	 * read string data
  	 */
  	function read_buff(buff, offset, n) {
  		var i;
  		for (i = 0; i < n && deflate_pos < deflate_data.length; i++) {
  			buff[offset + i] = deflate_data[deflate_pos++] & 0xff;
  		}
  		return i;
  	}

  	/* ==========================================================================
  	 * Initialize the "longest match" routines for a new file
  	 */
  	function lm_init() {
  		var j;

  		// Initialize the hash table. */
  		for (j = 0; j < HASH_SIZE; j++) {
  			// head2(j, NIL);
  			prev[WSIZE + j] = 0;
  		}
  		// prev will be initialized on the fly */

  		// Set the default configuration parameters:
  		max_lazy_match = configuration_table[compr_level].max_lazy;
  		good_match = configuration_table[compr_level].good_length;
  		{
  			nice_match = configuration_table[compr_level].nice_length;
  		}
  		max_chain_length = configuration_table[compr_level].max_chain;

  		strstart = 0;
  		block_start = 0;

  		lookahead = read_buff(window, 0, 2 * WSIZE);
  		if (lookahead <= 0) {
  			eofile = true;
  			lookahead = 0;
  			return;
  		}
  		eofile = false;
  		// Make sure that we always have enough lookahead. This is important
  		// if input comes from a device such as a tty.
  		while (lookahead < MIN_LOOKAHEAD && !eofile) {
  			fill_window();
  		}

  		// If lookahead < MIN_MATCH, ins_h is garbage, but this is
  		// not important since only literal bytes will be emitted.
  		ins_h = 0;
  		for (j = 0; j < MIN_MATCH - 1; j++) {
  			// UPDATE_HASH(ins_h, window[j]);
  			ins_h = ((ins_h << H_SHIFT) ^ (window[j] & 0xff)) & HASH_MASK;
  		}
  	}

  	/* ==========================================================================
  	 * Set match_start to the longest match starting at the given string and
  	 * return its length. Matches shorter or equal to prev_length are discarded,
  	 * in which case the result is equal to prev_length and match_start is
  	 * garbage.
  	 * IN assertions: cur_match is the head of the hash chain for the current
  	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
  	 */
  	function longest_match(cur_match) {
  		var chain_length = max_chain_length; // max hash chain length
  		var scanp = strstart; // current string
  		var matchp; // matched string
  		var len; // length of current match
  		var best_len = prev_length; // best match length so far

  		// Stop when cur_match becomes <= limit. To simplify the code,
  		// we prevent matches with the string of window index 0.
  		var limit = (strstart > MAX_DIST ? strstart - MAX_DIST : NIL);

  		var strendp = strstart + MAX_MATCH;
  		var scan_end1 = window[scanp + best_len - 1];
  		var scan_end = window[scanp + best_len];

  		var i, broke;

  		// Do not waste too much time if we already have a good match: */
  		if (prev_length >= good_match) {
  			chain_length >>= 2;
  		}

  		// Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

  		do {
  			// Assert(cur_match < encoder->strstart, "no future");
  			matchp = cur_match;

  			// Skip to next match if the match length cannot increase
  			// or if the match length is less than 2:
  			if (window[matchp + best_len] !== scan_end  ||
  					window[matchp + best_len - 1] !== scan_end1 ||
  					window[matchp] !== window[scanp] ||
  					window[++matchp] !== window[scanp + 1]) {
  				continue;
  			}

  			// The check at best_len-1 can be removed because it will be made
  			// again later. (This heuristic is not always a win.)
  			// It is not necessary to compare scan[2] and match[2] since they
  			// are always equal when the other bytes match, given that
  			// the hash keys are equal and that HASH_BITS >= 8.
  			scanp += 2;
  			matchp++;

  			// We check for insufficient lookahead only every 8th comparison;
  			// the 256th check will be made at strstart+258.
  			while (scanp < strendp) {
  				broke = false;
  				for (i = 0; i < 8; i += 1) {
  					scanp += 1;
  					matchp += 1;
  					if (window[scanp] !== window[matchp]) {
  						broke = true;
  						break;
  					}
  				}

  				if (broke) {
  					break;
  				}
  			}

  			len = MAX_MATCH - (strendp - scanp);
  			scanp = strendp - MAX_MATCH;

  			if (len > best_len) {
  				match_start = cur_match;
  				best_len = len;
  				{
  					if (len >= nice_match) {
  						break;
  					}
  				}

  				scan_end1 = window[scanp + best_len - 1];
  				scan_end = window[scanp + best_len];
  			}
  		} while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);

  		return best_len;
  	}

  	/* ==========================================================================
  	 * Fill the window when the lookahead becomes insufficient.
  	 * Updates strstart and lookahead, and sets eofile if end of input file.
  	 * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
  	 * OUT assertions: at least one byte has been read, or eofile is set;
  	 *    file reads are performed for at least two bytes (required for the
  	 *    translate_eol option).
  	 */
  	function fill_window() {
  		var n, m;

  	 // Amount of free space at the end of the window.
  		var more = window_size - lookahead - strstart;

  		// If the window is almost full and there is insufficient lookahead,
  		// move the upper half to the lower one to make room in the upper half.
  		if (more === -1) {
  			// Very unlikely, but possible on 16 bit machine if strstart == 0
  			// and lookahead == 1 (input done one byte at time)
  			more--;
  		} else if (strstart >= WSIZE + MAX_DIST) {
  			// By the IN assertion, the window is not empty so we can't confuse
  			// more == 0 with more == 64K on a 16 bit machine.
  			// Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

  			// System.arraycopy(window, WSIZE, window, 0, WSIZE);
  			for (n = 0; n < WSIZE; n++) {
  				window[n] = window[n + WSIZE];
  			}

  			match_start -= WSIZE;
  			strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
  			block_start -= WSIZE;

  			for (n = 0; n < HASH_SIZE; n++) {
  				m = head1(n);
  				head2(n, m >= WSIZE ? m - WSIZE : NIL);
  			}
  			for (n = 0; n < WSIZE; n++) {
  			// If n is not on any hash chain, prev[n] is garbage but
  			// its value will never be used.
  				m = prev[n];
  				prev[n] = (m >= WSIZE ? m - WSIZE : NIL);
  			}
  			more += WSIZE;
  		}
  		// At this point, more >= 2
  		if (!eofile) {
  			n = read_buff(window, strstart + lookahead, more);
  			if (n <= 0) {
  				eofile = true;
  			} else {
  				lookahead += n;
  			}
  		}
  	}

  	/* ==========================================================================
  	 * Processes a new input file and return its compressed length. This
  	 * function does not perform lazy evaluationof matches and inserts
  	 * new strings in the dictionary only for unmatched strings or for short
  	 * matches. It is used only for the fast compression options.
  	 */
  	function deflate_fast() {
  		while (lookahead !== 0 && qhead === null) {
  			var flush; // set if current block must be flushed

  			// Insert the string window[strstart .. strstart+2] in the
  			// dictionary, and set hash_head to the head of the hash chain:
  			INSERT_STRING();

  			// Find the longest match, discarding those <= prev_length.
  			// At this point we have always match_length < MIN_MATCH
  			if (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {
  				// To simplify the code, we prevent matches with the string
  				// of window index 0 (in particular we have to avoid a match
  				// of the string with itself at the start of the input file).
  				match_length = longest_match(hash_head);
  				// longest_match() sets match_start */
  				if (match_length > lookahead) {
  					match_length = lookahead;
  				}
  			}
  			if (match_length >= MIN_MATCH) {
  				// check_match(strstart, match_start, match_length);

  				flush = ct_tally(strstart - match_start, match_length - MIN_MATCH);
  				lookahead -= match_length;

  				// Insert new strings in the hash table only if the match length
  				// is not too large. This saves time but degrades compression.
  				if (match_length <= max_lazy_match) {
  					match_length--; // string at strstart already in hash table
  					do {
  						strstart++;
  						INSERT_STRING();
  						// strstart never exceeds WSIZE-MAX_MATCH, so there are
  						// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
  						// these bytes are garbage, but it does not matter since
  						// the next lookahead bytes will be emitted as literals.
  					} while (--match_length !== 0);
  					strstart++;
  				} else {
  					strstart += match_length;
  					match_length = 0;
  					ins_h = window[strstart] & 0xff;
  					// UPDATE_HASH(ins_h, window[strstart + 1]);
  					ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + 1] & 0xff)) & HASH_MASK;

  				//#if MIN_MATCH !== 3
  				//		Call UPDATE_HASH() MIN_MATCH-3 more times
  				//#endif

  				}
  			} else {
  				// No match, output a literal byte */
  				flush = ct_tally(0, window[strstart] & 0xff);
  				lookahead--;
  				strstart++;
  			}
  			if (flush) {
  				flush_block(0);
  				block_start = strstart;
  			}

  			// Make sure that we always have enough lookahead, except
  			// at the end of the input file. We need MAX_MATCH bytes
  			// for the next match, plus MIN_MATCH bytes to insert the
  			// string following the next match.
  			while (lookahead < MIN_LOOKAHEAD && !eofile) {
  				fill_window();
  			}
  		}
  	}

  	function deflate_better() {
  		// Process the input block. */
  		while (lookahead !== 0 && qhead === null) {
  			// Insert the string window[strstart .. strstart+2] in the
  			// dictionary, and set hash_head to the head of the hash chain:
  			INSERT_STRING();

  			// Find the longest match, discarding those <= prev_length.
  			prev_length = match_length;
  			prev_match = match_start;
  			match_length = MIN_MATCH - 1;

  			if (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {
  				// To simplify the code, we prevent matches with the string
  				// of window index 0 (in particular we have to avoid a match
  				// of the string with itself at the start of the input file).
  				match_length = longest_match(hash_head);
  				// longest_match() sets match_start */
  				if (match_length > lookahead) {
  					match_length = lookahead;
  				}

  				// Ignore a length 3 match if it is too distant: */
  				if (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {
  					// If prev_match is also MIN_MATCH, match_start is garbage
  					// but we will ignore the current match anyway.
  					match_length--;
  				}
  			}
  			// If there was a match at the previous step and the current
  			// match is not better, output the previous match:
  			if (prev_length >= MIN_MATCH && match_length <= prev_length) {
  				var flush; // set if current block must be flushed

  				// check_match(strstart - 1, prev_match, prev_length);
  				flush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

  				// Insert in hash table all strings up to the end of the match.
  				// strstart-1 and strstart are already inserted.
  				lookahead -= prev_length - 1;
  				prev_length -= 2;
  				do {
  					strstart++;
  					INSERT_STRING();
  					// strstart never exceeds WSIZE-MAX_MATCH, so there are
  					// always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
  					// these bytes are garbage, but it does not matter since the
  					// next lookahead bytes will always be emitted as literals.
  				} while (--prev_length !== 0);
  				match_available = false;
  				match_length = MIN_MATCH - 1;
  				strstart++;
  				if (flush) {
  					flush_block(0);
  					block_start = strstart;
  				}
  			} else if (match_available) {
  				// If there was no match at the previous position, output a
  				// single literal. If there was a match but the current match
  				// is longer, truncate the previous match to a single literal.
  				if (ct_tally(0, window[strstart - 1] & 0xff)) {
  					flush_block(0);
  					block_start = strstart;
  				}
  				strstart++;
  				lookahead--;
  			} else {
  				// There is no previous match to compare with, wait for
  				// the next step to decide.
  				match_available = true;
  				strstart++;
  				lookahead--;
  			}

  			// Make sure that we always have enough lookahead, except
  			// at the end of the input file. We need MAX_MATCH bytes
  			// for the next match, plus MIN_MATCH bytes to insert the
  			// string following the next match.
  			while (lookahead < MIN_LOOKAHEAD && !eofile) {
  				fill_window();
  			}
  		}
  	}

  	function init_deflate() {
  		if (eofile) {
  			return;
  		}
  		bi_buf = 0;
  		bi_valid = 0;
  		ct_init();
  		lm_init();

  		qhead = null;
  		outcnt = 0;
  		outoff = 0;

  		if (compr_level <= 3) {
  			prev_length = MIN_MATCH - 1;
  			match_length = 0;
  		} else {
  			match_length = MIN_MATCH - 1;
  			match_available = false;
  		}

  		complete = false;
  	}

  	/* ==========================================================================
  	 * Same as above, but achieves better compression. We use a lazy
  	 * evaluation for matches: a match is finally adopted only if there is
  	 * no better match at the next window position.
  	 */
  	function deflate_internal(buff, off, buff_size) {
  		var n;

  		if (!initflag) {
  			init_deflate();
  			initflag = true;
  			if (lookahead === 0) { // empty
  				complete = true;
  				return 0;
  			}
  		}

  		n = qcopy(buff, off, buff_size);
  		if (n === buff_size) {
  			return buff_size;
  		}

  		if (complete) {
  			return n;
  		}

  		if (compr_level <= 3) {
  			// optimized for speed
  			deflate_fast();
  		} else {
  			deflate_better();
  		}

  		if (lookahead === 0) {
  			if (match_available) {
  				ct_tally(0, window[strstart - 1] & 0xff);
  			}
  			flush_block(1);
  			complete = true;
  		}

  		return n + qcopy(buff, n + off, buff_size - n);
  	}

  	function qcopy(buff, off, buff_size) {
  		var n, i, j;

  		n = 0;
  		while (qhead !== null && n < buff_size) {
  			i = buff_size - n;
  			if (i > qhead.len) {
  				i = qhead.len;
  			}
  			// System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
  			for (j = 0; j < i; j++) {
  				buff[off + n + j] = qhead.ptr[qhead.off + j];
  			}

  			qhead.off += i;
  			qhead.len -= i;
  			n += i;
  			if (qhead.len === 0) {
  				var p;
  				p = qhead;
  				qhead = qhead.next;
  				reuse_queue(p);
  			}
  		}

  		if (n === buff_size) {
  			return n;
  		}

  		if (outoff < outcnt) {
  			i = buff_size - n;
  			if (i > outcnt - outoff) {
  				i = outcnt - outoff;
  			}
  			// System.arraycopy(outbuf, outoff, buff, off + n, i);
  			for (j = 0; j < i; j++) {
  				buff[off + n + j] = outbuf[outoff + j];
  			}
  			outoff += i;
  			n += i;
  			if (outcnt === outoff) {
  				outcnt = outoff = 0;
  			}
  		}
  		return n;
  	}

  	/* ==========================================================================
  	 * Allocate the match buffer, initialize the various tables and save the
  	 * location of the internal file attribute (ascii/binary) and method
  	 * (DEFLATE/STORE).
  	 */
  	function ct_init() {
  		var n; // iterates over tree elements
  		var bits; // bit counter
  		var length; // length value
  		var code; // code value
  		var dist; // distance index

  		if (static_dtree[0].dl !== 0) {
  			return; // ct_init already called
  		}

  		l_desc.dyn_tree = dyn_ltree;
  		l_desc.static_tree = static_ltree;
  		l_desc.extra_bits = extra_lbits;
  		l_desc.extra_base = LITERALS + 1;
  		l_desc.elems = L_CODES;
  		l_desc.max_length = MAX_BITS;
  		l_desc.max_code = 0;

  		d_desc.dyn_tree = dyn_dtree;
  		d_desc.static_tree = static_dtree;
  		d_desc.extra_bits = extra_dbits;
  		d_desc.extra_base = 0;
  		d_desc.elems = D_CODES;
  		d_desc.max_length = MAX_BITS;
  		d_desc.max_code = 0;

  		bl_desc.dyn_tree = bl_tree;
  		bl_desc.static_tree = null;
  		bl_desc.extra_bits = extra_blbits;
  		bl_desc.extra_base = 0;
  		bl_desc.elems = BL_CODES;
  		bl_desc.max_length = MAX_BL_BITS;
  		bl_desc.max_code = 0;

  	 // Initialize the mapping length (0..255) -> length code (0..28)
  		length = 0;
  		for (code = 0; code < LENGTH_CODES - 1; code++) {
  			base_length[code] = length;
  			for (n = 0; n < (1 << extra_lbits[code]); n++) {
  				length_code[length++] = code;
  			}
  		}
  	 // Assert (length === 256, "ct_init: length !== 256");

  		// Note that the length 255 (match length 258) can be represented
  		// in two different ways: code 284 + 5 bits or code 285, so we
  		// overwrite length_code[255] to use the best encoding:
  		length_code[length - 1] = code;

  		// Initialize the mapping dist (0..32K) -> dist code (0..29) */
  		dist = 0;
  		for (code = 0; code < 16; code++) {
  			base_dist[code] = dist;
  			for (n = 0; n < (1 << extra_dbits[code]); n++) {
  				dist_code[dist++] = code;
  			}
  		}
  		// Assert (dist === 256, "ct_init: dist !== 256");
  		// from now on, all distances are divided by 128
  		for (dist >>= 7; code < D_CODES; code++) {
  			base_dist[code] = dist << 7;
  			for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
  				dist_code[256 + dist++] = code;
  			}
  		}
  		// Assert (dist === 256, "ct_init: 256+dist !== 512");

  		// Construct the codes of the static literal tree
  		for (bits = 0; bits <= MAX_BITS; bits++) {
  			bl_count[bits] = 0;
  		}
  		n = 0;
  		while (n <= 143) {
  			static_ltree[n++].dl = 8;
  			bl_count[8]++;
  		}
  		while (n <= 255) {
  			static_ltree[n++].dl = 9;
  			bl_count[9]++;
  		}
  		while (n <= 279) {
  			static_ltree[n++].dl = 7;
  			bl_count[7]++;
  		}
  		while (n <= 287) {
  			static_ltree[n++].dl = 8;
  			bl_count[8]++;
  		}
  		// Codes 286 and 287 do not exist, but we must include them in the
  		// tree construction to get a canonical Huffman tree (longest code
  		// all ones)
  		gen_codes(static_ltree, L_CODES + 1);

  		// The static distance tree is trivial: */
  		for (n = 0; n < D_CODES; n++) {
  			static_dtree[n].dl = 5;
  			static_dtree[n].fc = bi_reverse(n, 5);
  		}

  		// Initialize the first block of the first file:
  		init_block();
  	}

  	/* ==========================================================================
  	 * Initialize a new block.
  	 */
  	function init_block() {
  		var n; // iterates over tree elements

  		// Initialize the trees.
  		for (n = 0; n < L_CODES;  n++) {
  			dyn_ltree[n].fc = 0;
  		}
  		for (n = 0; n < D_CODES;  n++) {
  			dyn_dtree[n].fc = 0;
  		}
  		for (n = 0; n < BL_CODES; n++) {
  			bl_tree[n].fc = 0;
  		}

  		dyn_ltree[END_BLOCK].fc = 1;
  		opt_len = static_len = 0;
  		last_lit = last_dist = last_flags = 0;
  		flags = 0;
  		flag_bit = 1;
  	}

  	/* ==========================================================================
  	 * Restore the heap property by moving down the tree starting at node k,
  	 * exchanging a node with the smallest of its two sons if necessary, stopping
  	 * when the heap property is re-established (each father smaller than its
  	 * two sons).
  	 *
  	 * @param tree- tree to restore
  	 * @param k- node to move down
  	 */
  	function pqdownheap(tree, k) {
  		var v = heap[k],
  			j = k << 1; // left son of k

  		while (j <= heap_len) {
  			// Set j to the smallest of the two sons:
  			if (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {
  				j++;
  			}

  			// Exit if v is smaller than both sons
  			if (SMALLER(tree, v, heap[j])) {
  				break;
  			}

  			// Exchange v with the smallest son
  			heap[k] = heap[j];
  			k = j;

  			// And continue down the tree, setting j to the left son of k
  			j <<= 1;
  		}
  		heap[k] = v;
  	}

  	/* ==========================================================================
  	 * Compute the optimal bit lengths for a tree and update the total bit length
  	 * for the current block.
  	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
  	 *    above are the tree nodes sorted by increasing frequency.
  	 * OUT assertions: the field len is set to the optimal bit length, the
  	 *     array bl_count contains the frequencies for each bit length.
  	 *     The length opt_len is updated; static_len is also updated if stree is
  	 *     not null.
  	 */
  	function gen_bitlen(desc) { // the tree descriptor
  		var tree = desc.dyn_tree;
  		var extra = desc.extra_bits;
  		var base = desc.extra_base;
  		var max_code = desc.max_code;
  		var max_length = desc.max_length;
  		var stree = desc.static_tree;
  		var h; // heap index
  		var n, m; // iterate over the tree elements
  		var bits; // bit length
  		var xbits; // extra bits
  		var f; // frequency
  		var overflow = 0; // number of elements with bit length too large

  		for (bits = 0; bits <= MAX_BITS; bits++) {
  			bl_count[bits] = 0;
  		}

  		// In a first pass, compute the optimal bit lengths (which may
  		// overflow in the case of the bit length tree).
  		tree[heap[heap_max]].dl = 0; // root of the heap

  		for (h = heap_max + 1; h < HEAP_SIZE; h++) {
  			n = heap[h];
  			bits = tree[tree[n].dl].dl + 1;
  			if (bits > max_length) {
  				bits = max_length;
  				overflow++;
  			}
  			tree[n].dl = bits;
  			// We overwrite tree[n].dl which is no longer needed

  			if (n > max_code) {
  				continue; // not a leaf node
  			}

  			bl_count[bits]++;
  			xbits = 0;
  			if (n >= base) {
  				xbits = extra[n - base];
  			}
  			f = tree[n].fc;
  			opt_len += f * (bits + xbits);
  			if (stree !== null) {
  				static_len += f * (stree[n].dl + xbits);
  			}
  		}
  		if (overflow === 0) {
  			return;
  		}

  		// This happens for example on obj2 and pic of the Calgary corpus

  		// Find the first bit length which could increase:
  		do {
  			bits = max_length - 1;
  			while (bl_count[bits] === 0) {
  				bits--;
  			}
  			bl_count[bits]--; // move one leaf down the tree
  			bl_count[bits + 1] += 2; // move one overflow item as its brother
  			bl_count[max_length]--;
  			// The brother of the overflow item also moves one step up,
  			// but this does not affect bl_count[max_length]
  			overflow -= 2;
  		} while (overflow > 0);

  		// Now recompute all bit lengths, scanning in increasing frequency.
  		// h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
  		// lengths instead of fixing only the wrong ones. This idea is taken
  		// from 'ar' written by Haruhiko Okumura.)
  		for (bits = max_length; bits !== 0; bits--) {
  			n = bl_count[bits];
  			while (n !== 0) {
  				m = heap[--h];
  				if (m > max_code) {
  					continue;
  				}
  				if (tree[m].dl !== bits) {
  					opt_len += (bits - tree[m].dl) * tree[m].fc;
  					tree[m].fc = bits;
  				}
  				n--;
  			}
  		}
  	}

  	  /* ==========================================================================
  	   * Generate the codes for a given tree and bit counts (which need not be
  	   * optimal).
  	   * IN assertion: the array bl_count contains the bit length statistics for
  	   * the given tree and the field len is set for all tree elements.
  	   * OUT assertion: the field code is set for all tree elements of non
  	   *     zero code length.
  	   * @param tree- the tree to decorate
  	   * @param max_code- largest code with non-zero frequency
  	   */
  	function gen_codes(tree, max_code) {
  		var next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length
  		var code = 0; // running code value
  		var bits; // bit index
  		var n; // code index

  		// The distribution counts are first used to generate the code values
  		// without bit reversal.
  		for (bits = 1; bits <= MAX_BITS; bits++) {
  			code = ((code + bl_count[bits - 1]) << 1);
  			next_code[bits] = code;
  		}

  		// Check that the bit counts in bl_count are consistent. The last code
  		// must be all ones.
  		// Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, "inconsistent bit counts");
  		// Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  		for (n = 0; n <= max_code; n++) {
  			var len = tree[n].dl;
  			if (len === 0) {
  				continue;
  			}
  			// Now reverse the bits
  			tree[n].fc = bi_reverse(next_code[len]++, len);

  			// Tracec(tree !== static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
  		}
  	}

  	/* ==========================================================================
  	 * Construct one Huffman tree and assigns the code bit strings and lengths.
  	 * Update the total bit length for the current block.
  	 * IN assertion: the field freq is set for all tree elements.
  	 * OUT assertions: the fields len and code are set to the optimal bit length
  	 *     and corresponding code. The length opt_len is updated; static_len is
  	 *     also updated if stree is not null. The field max_code is set.
  	 */
  	function build_tree(desc) { // the tree descriptor
  		var tree = desc.dyn_tree;
  		var stree = desc.static_tree;
  		var elems = desc.elems;
  		var n, m; // iterate over heap elements
  		var max_code = -1; // largest code with non zero frequency
  		var node = elems; // next internal node of the tree

  		// Construct the initial heap, with least frequent element in
  		// heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
  		// heap[0] is not used.
  		heap_len = 0;
  		heap_max = HEAP_SIZE;

  		for (n = 0; n < elems; n++) {
  			if (tree[n].fc !== 0) {
  				heap[++heap_len] = max_code = n;
  				depth[n] = 0;
  			} else {
  				tree[n].dl = 0;
  			}
  		}

  		// The pkzip format requires that at least one distance code exists,
  		// and that at least one bit should be sent even if there is only one
  		// possible code. So to avoid special checks later on we force at least
  		// two codes of non zero frequency.
  		while (heap_len < 2) {
  			var xnew = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);
  			tree[xnew].fc = 1;
  			depth[xnew] = 0;
  			opt_len--;
  			if (stree !== null) {
  				static_len -= stree[xnew].dl;
  			}
  			// new is 0 or 1 so it does not have extra bits
  		}
  		desc.max_code = max_code;

  		// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
  		// establish sub-heaps of increasing lengths:
  		for (n = heap_len >> 1; n >= 1; n--) {
  			pqdownheap(tree, n);
  		}

  		// Construct the Huffman tree by repeatedly combining the least two
  		// frequent nodes.
  		do {
  			n = heap[SMALLEST];
  			heap[SMALLEST] = heap[heap_len--];
  			pqdownheap(tree, SMALLEST);

  			m = heap[SMALLEST]; // m = node of next least frequency

  			// keep the nodes sorted by frequency
  			heap[--heap_max] = n;
  			heap[--heap_max] = m;

  			// Create a new node father of n and m
  			tree[node].fc = tree[n].fc + tree[m].fc;
  			//	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
  			if (depth[n] > depth[m] + 1) {
  				depth[node] = depth[n];
  			} else {
  				depth[node] = depth[m] + 1;
  			}
  			tree[n].dl = tree[m].dl = node;

  			// and insert the new node in the heap
  			heap[SMALLEST] = node++;
  			pqdownheap(tree, SMALLEST);

  		} while (heap_len >= 2);

  		heap[--heap_max] = heap[SMALLEST];

  		// At this point, the fields freq and dad are set. We can now
  		// generate the bit lengths.
  		gen_bitlen(desc);

  		// The field len is now set, we can generate the bit codes
  		gen_codes(tree, max_code);
  	}

  	/* ==========================================================================
  	 * Scan a literal or distance tree to determine the frequencies of the codes
  	 * in the bit length tree. Updates opt_len to take into account the repeat
  	 * counts. (The contribution of the bit length codes will be added later
  	 * during the construction of bl_tree.)
  	 *
  	 * @param tree- the tree to be scanned
  	 * @param max_code- and its largest code of non zero frequency
  	 */
  	function scan_tree(tree, max_code) {
  		var n, // iterates over all tree elements
  			prevlen = -1, // last emitted length
  			curlen, // length of current code
  			nextlen = tree[0].dl, // length of next code
  			count = 0, // repeat count of the current code
  			max_count = 7, // max repeat count
  			min_count = 4; // min repeat count

  		if (nextlen === 0) {
  			max_count = 138;
  			min_count = 3;
  		}
  		tree[max_code + 1].dl = 0xffff; // guard

  		for (n = 0; n <= max_code; n++) {
  			curlen = nextlen;
  			nextlen = tree[n + 1].dl;
  			if (++count < max_count && curlen === nextlen) {
  				continue;
  			} else if (count < min_count) {
  				bl_tree[curlen].fc += count;
  			} else if (curlen !== 0) {
  				if (curlen !== prevlen) {
  					bl_tree[curlen].fc++;
  				}
  				bl_tree[REP_3_6].fc++;
  			} else if (count <= 10) {
  				bl_tree[REPZ_3_10].fc++;
  			} else {
  				bl_tree[REPZ_11_138].fc++;
  			}
  			count = 0; prevlen = curlen;
  			if (nextlen === 0) {
  				max_count = 138;
  				min_count = 3;
  			} else if (curlen === nextlen) {
  				max_count = 6;
  				min_count = 3;
  			} else {
  				max_count = 7;
  				min_count = 4;
  			}
  		}
  	}

  	/* ==========================================================================
  	 * Send a literal or distance tree in compressed form, using the codes in
  	 * bl_tree.
  	 *
  	 * @param tree- the tree to be scanned
  	 * @param max_code- and its largest code of non zero frequency
  	 */
  	function send_tree(tree, max_code) {
  		var n; // iterates over all tree elements
  		var prevlen = -1; // last emitted length
  		var curlen; // length of current code
  		var nextlen = tree[0].dl; // length of next code
  		var count = 0; // repeat count of the current code
  		var max_count = 7; // max repeat count
  		var min_count = 4; // min repeat count

  		// tree[max_code+1].dl = -1; */  /* guard already set */
  		if (nextlen === 0) {
  			max_count = 138;
  			min_count = 3;
  		}

  		for (n = 0; n <= max_code; n++) {
  			curlen = nextlen;
  			nextlen = tree[n + 1].dl;
  			if (++count < max_count && curlen === nextlen) {
  				continue;
  			} else if (count < min_count) {
  				do {
  					SEND_CODE(curlen, bl_tree);
  				} while (--count !== 0);
  			} else if (curlen !== 0) {
  				if (curlen !== prevlen) {
  					SEND_CODE(curlen, bl_tree);
  					count--;
  				}
  			// Assert(count >= 3 && count <= 6, " 3_6?");
  				SEND_CODE(REP_3_6, bl_tree);
  				send_bits(count - 3, 2);
  			} else if (count <= 10) {
  				SEND_CODE(REPZ_3_10, bl_tree);
  				send_bits(count - 3, 3);
  			} else {
  				SEND_CODE(REPZ_11_138, bl_tree);
  				send_bits(count - 11, 7);
  			}
  			count = 0;
  			prevlen = curlen;
  			if (nextlen === 0) {
  				max_count = 138;
  				min_count = 3;
  			} else if (curlen === nextlen) {
  				max_count = 6;
  				min_count = 3;
  			} else {
  				max_count = 7;
  				min_count = 4;
  			}
  		}
  	}

  	/* ==========================================================================
  	 * Construct the Huffman tree for the bit lengths and return the index in
  	 * bl_order of the last bit length code to send.
  	 */
  	function build_bl_tree() {
  		var max_blindex; // index of last bit length code of non zero freq

  		// Determine the bit length frequencies for literal and distance trees
  		scan_tree(dyn_ltree, l_desc.max_code);
  		scan_tree(dyn_dtree, d_desc.max_code);

  		// Build the bit length tree:
  		build_tree(bl_desc);
  		// opt_len now includes the length of the tree representations, except
  		// the lengths of the bit lengths codes and the 5+5+4 bits for the counts.

  		// Determine the number of bit length codes to send. The pkzip format
  		// requires that at least 4 bit length codes be sent. (appnote.txt says
  		// 3 but the actual value used is 4.)
  		for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
  			if (bl_tree[bl_order[max_blindex]].dl !== 0) {
  				break;
  			}
  		}
  		// Update opt_len to include the bit length tree and counts */
  		opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  		// Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  		// encoder->opt_len, encoder->static_len));

  		return max_blindex;
  	}

  	/* ==========================================================================
  	 * Send the header for a block using dynamic Huffman trees: the counts, the
  	 * lengths of the bit length codes, the literal tree and the distance tree.
  	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
  	 */
  	function send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree
  		var rank; // index in bl_order

  		// Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  		// Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, "too many codes");
  		// Tracev((stderr, "\nbl counts: "));
  		send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
  		send_bits(dcodes - 1,   5);
  		send_bits(blcodes - 4,  4); // not -3 as stated in appnote.txt
  		for (rank = 0; rank < blcodes; rank++) {
  			// Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
  			send_bits(bl_tree[bl_order[rank]].dl, 3);
  		}

  		// send the literal tree
  		send_tree(dyn_ltree, lcodes - 1);

  		// send the distance tree
  		send_tree(dyn_dtree, dcodes - 1);
  	}

  	/* ==========================================================================
  	 * Determine the best encoding for the current block: dynamic trees, static
  	 * trees or store, and output the encoded block to the zip file.
  	 */
  	function flush_block(eof) { // true if this is the last block for a file
  		var opt_lenb, static_lenb, // opt_len and static_len in bytes
  			max_blindex, // index of last bit length code of non zero freq
  			stored_len, // length of input block
  			i;

  		stored_len = strstart - block_start;
  		flag_buf[last_flags] = flags; // Save the flags for the last 8 items

  		// Construct the literal and distance trees
  		build_tree(l_desc);
  		// Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
  		// encoder->opt_len, encoder->static_len));

  		build_tree(d_desc);
  		// Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
  		// encoder->opt_len, encoder->static_len));
  		// At this point, opt_len and static_len are the total bit lengths of
  		// the compressed block data, excluding the tree representations.

  		// Build the bit length tree for the above two trees, and get the index
  		// in bl_order of the last bit length code to send.
  		max_blindex = build_bl_tree();

  	 // Determine the best encoding. Compute first the block length in bytes
  		opt_lenb = (opt_len + 3 + 7) >> 3;
  		static_lenb = (static_len + 3 + 7) >> 3;

  	//  Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));

  		if (static_lenb <= opt_lenb) {
  			opt_lenb = static_lenb;
  		}
  		if (stored_len + 4 <= opt_lenb && block_start >= 0) { // 4: two words for the lengths
  			// The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.
  			// Otherwise we can't have processed more than WSIZE input bytes since
  			// the last block flush, because compression would have been
  			// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
  			// transform a block into a stored block.
  			send_bits((STORED_BLOCK << 1) + eof, 3);  /* send block type */
  			bi_windup();         /* align on byte boundary */
  			put_short(stored_len);
  			put_short(~stored_len);

  			// copy block
  			/*
  				p = &window[block_start];
  				for (i = 0; i < stored_len; i++) {
  					put_byte(p[i]);
  				}
  			*/
  			for (i = 0; i < stored_len; i++) {
  				put_byte(window[block_start + i]);
  			}
  		} else if (static_lenb === opt_lenb) {
  			send_bits((STATIC_TREES << 1) + eof, 3);
  			compress_block(static_ltree, static_dtree);
  		} else {
  			send_bits((DYN_TREES << 1) + eof, 3);
  			send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
  			compress_block(dyn_ltree, dyn_dtree);
  		}

  		init_block();

  		if (eof !== 0) {
  			bi_windup();
  		}
  	}

  	/* ==========================================================================
  	 * Save the match info and tally the frequency counts. Return true if
  	 * the current block must be flushed.
  	 *
  	 * @param dist- distance of matched string
  	 * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)
  	 */
  	function ct_tally(dist, lc) {
  		l_buf[last_lit++] = lc;
  		if (dist === 0) {
  			// lc is the unmatched char
  			dyn_ltree[lc].fc++;
  		} else {
  			// Here, lc is the match length - MIN_MATCH
  			dist--; // dist = match distance - 1
  			// Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

  			dyn_ltree[length_code[lc] + LITERALS + 1].fc++;
  			dyn_dtree[D_CODE(dist)].fc++;

  			d_buf[last_dist++] = dist;
  			flags |= flag_bit;
  		}
  		flag_bit <<= 1;

  		// Output the flags if they fill a byte
  		if ((last_lit & 7) === 0) {
  			flag_buf[last_flags++] = flags;
  			flags = 0;
  			flag_bit = 1;
  		}
  		// Try to guess if it is profitable to stop the current block here
  		if (compr_level > 2 && (last_lit & 0xfff) === 0) {
  			// Compute an upper bound for the compressed length
  			var out_length = last_lit * 8;
  			var in_length = strstart - block_start;
  			var dcode;

  			for (dcode = 0; dcode < D_CODES; dcode++) {
  				out_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);
  			}
  			out_length >>= 3;
  			// Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));
  			if (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {
  				return true;
  			}
  		}
  		return (last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE);
  		// We avoid equality with LIT_BUFSIZE because of wraparound at 64K
  		// on 16 bit machines and because stored blocks are restricted to
  		// 64K-1 bytes.
  	}

  	  /* ==========================================================================
  	   * Send the block data compressed using the given Huffman trees
  	   *
  	   * @param ltree- literal tree
  	   * @param dtree- distance tree
  	   */
  	function compress_block(ltree, dtree) {
  		var dist; // distance of matched string
  		var lc; // match length or unmatched char (if dist === 0)
  		var lx = 0; // running index in l_buf
  		var dx = 0; // running index in d_buf
  		var fx = 0; // running index in flag_buf
  		var flag = 0; // current flags
  		var code; // the code to send
  		var extra; // number of extra bits to send

  		if (last_lit !== 0) {
  			do {
  				if ((lx & 7) === 0) {
  					flag = flag_buf[fx++];
  				}
  				lc = l_buf[lx++] & 0xff;
  				if ((flag & 1) === 0) {
  					SEND_CODE(lc, ltree); /* send a literal byte */
  					//	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
  				} else {
  					// Here, lc is the match length - MIN_MATCH
  					code = length_code[lc];
  					SEND_CODE(code + LITERALS + 1, ltree); // send the length code
  					extra = extra_lbits[code];
  					if (extra !== 0) {
  						lc -= base_length[code];
  						send_bits(lc, extra); // send the extra length bits
  					}
  					dist = d_buf[dx++];
  					// Here, dist is the match distance - 1
  					code = D_CODE(dist);
  					//	Assert (code < D_CODES, "bad d_code");

  					SEND_CODE(code, dtree); // send the distance code
  					extra = extra_dbits[code];
  					if (extra !== 0) {
  						dist -= base_dist[code];
  						send_bits(dist, extra); // send the extra distance bits
  					}
  				} // literal or match pair ?
  				flag >>= 1;
  			} while (lx < last_lit);
  		}

  		SEND_CODE(END_BLOCK, ltree);
  	}

  	/* ==========================================================================
  	 * Send a value on a given number of bits.
  	 * IN assertion: length <= 16 and value fits in length bits.
  	 *
  	 * @param value- value to send
  	 * @param length- number of bits
  	 */
  	var Buf_size = 16; // bit size of bi_buf
  	function send_bits(value, length) {
  		// If not enough room in bi_buf, use (valid) bits from bi_buf and
  		// (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
  		// unused bits in value.
  		if (bi_valid > Buf_size - length) {
  			bi_buf |= (value << bi_valid);
  			put_short(bi_buf);
  			bi_buf = (value >> (Buf_size - bi_valid));
  			bi_valid += length - Buf_size;
  		} else {
  			bi_buf |= value << bi_valid;
  			bi_valid += length;
  		}
  	}

  	/* ==========================================================================
  	 * Reverse the first len bits of a code, using straightforward code (a faster
  	 * method would use a table)
  	 * IN assertion: 1 <= len <= 15
  	 *
  	 * @param code- the value to invert
  	 * @param len- its bit length
  	 */
  	function bi_reverse(code, len) {
  		var res = 0;
  		do {
  			res |= code & 1;
  			code >>= 1;
  			res <<= 1;
  		} while (--len > 0);
  		return res >> 1;
  	}

  	/* ==========================================================================
  	 * Write out any remaining bits in an incomplete byte.
  	 */
  	function bi_windup() {
  		if (bi_valid > 8) {
  			put_short(bi_buf);
  		} else if (bi_valid > 0) {
  			put_byte(bi_buf);
  		}
  		bi_buf = 0;
  		bi_valid = 0;
  	}

  	function qoutbuf() {
  		var q, i;
  		if (outcnt !== 0) {
  			q = new_queue();
  			if (qhead === null) {
  				qhead = qtail = q;
  			} else {
  				qtail = qtail.next = q;
  			}
  			q.len = outcnt - outoff;
  			// System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);
  			for (i = 0; i < q.len; i++) {
  				q.ptr[i] = outbuf[outoff + i];
  			}
  			outcnt = outoff = 0;
  		}
  	}

  	function deflate(arr, level) {
  		var i, buff;

  		deflate_data = arr;
  		deflate_pos = 0;
  		if (typeof level === "undefined") {
  			level = DEFAULT_LEVEL;
  		}
  		deflate_start(level);

  		buff = [];

  		do {
  			i = deflate_internal(buff, buff.length, 1024);
  		} while (i > 0);

  		deflate_data = null; // G.C.
  		return buff;
  	}

  	module.exports = deflate;
  	module.exports.DEFAULT_LEVEL = DEFAULT_LEVEL;
  }());
  });

  var deflateJs = createCommonjsModule(function (module) {
  (function () {

  	module.exports = {
  		'inflate': rawinflate,
  		'deflate': rawdeflate
  	};
  }());
  });

  var gzip = createCommonjsModule(function (module) {
  (function () {

  	var crc32$1 = crc32,
  		deflate = deflateJs,
  		// magic numbers marking this file as GZIP
  		ID1 = 0x1F,
  		ID2 = 0x8B,
  		compressionMethods = {
  			'deflate': 8
  		},
  		possibleFlags = {
  			'FTEXT': 0x01,
  			'FHCRC': 0x02,
  			'FEXTRA': 0x04,
  			'FNAME': 0x08,
  			'FCOMMENT': 0x10
  		},
  		osMap = {
  			'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS
  			'amiga': 1, // Amiga
  			'vmz': 2, // VMS (VAX or Alpha AXP)
  			'unix': 3, // Unix
  			'vm/cms': 4, // VM/CMS
  			'atari': 5, // Atari
  			'hpfs': 6, // HPFS file system (OS/2, NT 3.x)
  			'macintosh': 7, // Macintosh
  			'z-system': 8, // Z-System
  			'cplm': 9, // CP/M
  			'tops-20': 10, // TOPS-20
  			'ntfs': 11, // NTFS file system (NT)
  			'qdos': 12, // SMS/QDOS
  			'acorn': 13, // Acorn RISC OS
  			'vfat': 14, // VFAT file system (Win95, NT)
  			'vms': 15, // MVS (code also taken for PRIMOS)
  			'beos': 16, // BeOS (BeBox or PowerMac)
  			'tandem': 17, // Tandem/NSK
  			'theos': 18 // THEOS
  		},
  		os = 'unix',
  		DEFAULT_LEVEL = 6;

  	function putByte(n, arr) {
  		arr.push(n & 0xFF);
  	}

  	// LSB first
  	function putShort(n, arr) {
  		arr.push(n & 0xFF);
  		arr.push(n >>> 8);
  	}

  	// LSB first
  	function putLong(n, arr) {
  		putShort(n & 0xffff, arr);
  		putShort(n >>> 16, arr);
  	}

  	function putString(s, arr) {
  		var i, len = s.length;
  		for (i = 0; i < len; i += 1) {
  			putByte(s.charCodeAt(i), arr);
  		}
  	}

  	function readByte(arr) {
  		return arr.shift();
  	}

  	function readShort(arr) {
  		return arr.shift() | (arr.shift() << 8);
  	}

  	function readLong(arr) {
  		var n1 = readShort(arr),
  			n2 = readShort(arr);

  		// JavaScript can't handle bits in the position 32
  		// we'll emulate this by removing the left-most bit (if it exists)
  		// and add it back in via multiplication, which does work
  		if (n2 > 32768) {
  			n2 -= 32768;

  			return ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);
  		}

  		return (n2 << 16) | n1;
  	}

  	function readString(arr) {
  		var charArr = [];

  		// turn all bytes into chars until the terminating null
  		while (arr[0] !== 0) {
  			charArr.push(String.fromCharCode(arr.shift()));
  		}

  		// throw away terminating null
  		arr.shift();

  		// join all characters into a cohesive string
  		return charArr.join('');
  	}

  	/*
  	 * Reads n number of bytes and return as an array.
  	 *
  	 * @param arr- Array of bytes to read from
  	 * @param n- Number of bytes to read
  	 */
  	function readBytes(arr, n) {
  		var i, ret = [];
  		for (i = 0; i < n; i += 1) {
  			ret.push(arr.shift());
  		}

  		return ret;
  	}

  	/*
  	 * ZIPs a file in GZIP format. The format is as given by the spec, found at:
  	 * http://www.gzip.org/zlib/rfc-gzip.html
  	 *
  	 * Omitted parts in this implementation:
  	 */
  	function zip(data, options) {
  		var flags = 0,
  			level,
  			out = [];

  		if (!options) {
  			options = {};
  		}
  		level = options.level || DEFAULT_LEVEL;

  		if (typeof data === 'string') {
  			data = Array.prototype.map.call(data, function (char) {
  				return char.charCodeAt(0);
  			});
  		}

  		// magic number marking this file as GZIP
  		putByte(ID1, out);
  		putByte(ID2, out);

  		putByte(compressionMethods['deflate'], out);

  		if (options.name) {
  			flags |= possibleFlags['FNAME'];
  		}

  		putByte(flags, out);
  		putLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);

  		// put deflate args (extra flags)
  		if (level === 1) {
  			// fastest algorithm
  			putByte(4, out);
  		} else if (level === 9) {
  			// maximum compression (fastest algorithm)
  			putByte(2, out);
  		} else {
  			putByte(0, out);
  		}

  		// OS identifier
  		putByte(osMap[os], out);

  		if (options.name) {
  			// ignore the directory part
  			putString(options.name.substring(options.name.lastIndexOf('/') + 1), out);

  			// terminating null
  			putByte(0, out);
  		}

  		deflate.deflate(data, level).forEach(function (byte) {
  			putByte(byte, out);
  		});

  		putLong(parseInt(crc32$1(data), 16), out);
  		putLong(data.length, out);

  		return out;
  	}

  	function unzip(data, options) {
  		// start with a copy of the array
  		var arr = Array.prototype.slice.call(data, 0),
  			t,
  			compressionMethod,
  			flags,
  			mtime,
  			xFlags,
  			crc,
  			size,
  			res;

  		// check the first two bytes for the magic numbers
  		if (readByte(arr) !== ID1 || readByte(arr) !== ID2) {
  			throw 'Not a GZIP file';
  		}

  		t = readByte(arr);
  		t = Object.keys(compressionMethods).some(function (key) {
  			compressionMethod = key;
  			return compressionMethods[key] === t;
  		});

  		if (!t) {
  			throw 'Unsupported compression method';
  		}

  		flags = readByte(arr);
  		mtime = readLong(arr);
  		xFlags = readByte(arr);
  		t = readByte(arr);
  		Object.keys(osMap).some(function (key) {
  			if (osMap[key] === t) {
  				return true;
  			}
  		});

  		// just throw away the bytes for now
  		if (flags & possibleFlags['FEXTRA']) {
  			t = readShort(arr);
  			readBytes(arr, t);
  		}

  		// just throw away for now
  		if (flags & possibleFlags['FNAME']) {
  			readString(arr);
  		}

  		// just throw away for now
  		if (flags & possibleFlags['FCOMMENT']) {
  			readString(arr);
  		}

  		// just throw away for now
  		if (flags & possibleFlags['FHCRC']) {
  			readShort(arr);
  		}

  		if (compressionMethod === 'deflate') {
  			// give deflate everything but the last 8 bytes
  			// the last 8 bytes are for the CRC32 checksum and filesize
  			res = deflate.inflate(arr.splice(0, arr.length - 8));
  		}

  		if (flags & possibleFlags['FTEXT']) {
  			res = Array.prototype.map.call(res, function (byte) {
  				return String.fromCharCode(byte);
  			}).join('');
  		}

  		crc = readLong(arr);
  		if (crc !== parseInt(crc32$1(res), 16)) {
  			throw 'Checksum does not match';
  		}

  		size = readLong(arr);
  		if (size !== res.length) {
  			throw 'Size of decompressed file not correct';
  		}

  		return res;
  	}

  	module.exports = {
  		zip: zip,
  		unzip: unzip,
  		get DEFAULT_LEVEL() {
  			return DEFAULT_LEVEL;
  		}
  	};
  }());
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * HipsFits configuration
   * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.hipsFits_configuration
   * @property {Function} onready - Callback function
   */

  /**
   * @name HipsFitsLayer
   * @class
   * This layer draws an Hips Fits Image
   * @augments AbstractHipsLayer
   * @param {Object} hipsMetadata - HIPS Metadata
   * @param {AbstractHipsLayer.hipsFits_configuration} options - HipsFits configuration
   * @memberof module:Layer
   * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
   */

  var HipsFitsLayer = function (hipsMetadata, options) {
    AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, options);
    this._ready = false;
    this.fitsSupported = true; // allsky

    this.levelZeroImage = null; // TODO use DynamicImage shaders by unifying shader programs between TileManager and ConvexPolygonRenderer
    //		* inverse Y coordinates, some var names refactor..

    this.rawFragShader = "precision lowp float; \n";
    this.rawFragShader += "varying vec2 texCoord;\n";
    this.rawFragShader += "uniform sampler2D colorTexture; \n";
    this.rawFragShader += "uniform float opacity; \n";
    this.rawFragShader += "uniform float inversed; \n";
    this.rawFragShader += "bool isnan(float val) {\n";
    this.rawFragShader += "		return (val <= 0.0 || 0.0 <= val) ? ((val == 5e-324) ? true : false) : true;\n";
    this.rawFragShader += "}\n";
    this.rawFragShader += "void main(void)\n";
    this.rawFragShader += "{\n";
    this.rawFragShader += "	vec4 color = texture2D(colorTexture, vec2(texCoord.x, (inversed == 1.) ? 1.0 - texCoord.y : texCoord.y));\n";
    this.rawFragShader += "	gl_FragColor = vec4(color.r,color.g,color.b, color.a*opacity);\n";
    this.rawFragShader += "	if (isnan( (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3. ) )\n";
    this.rawFragShader += "	{\n";
    this.rawFragShader += "		gl_FragColor.a = 0.;\n";
    this.rawFragShader += "	}\n";
    this.rawFragShader += "}\n";
    this.colormapFragShader = "precision lowp float; \n";
    this.colormapFragShader += "varying vec2 texCoord;\n";
    this.colormapFragShader += "uniform sampler2D colorTexture; \n";
    this.colormapFragShader += "uniform sampler2D colormap; \n";
    this.colormapFragShader += "uniform float min; \n";
    this.colormapFragShader += "uniform float max; \n";
    this.colormapFragShader += "uniform float opacity; \n";
    this.colormapFragShader += "bool isnan(float val) {\n";
    this.colormapFragShader += "	return (val <= 0.0 || 0.0 <= val) ? false : true;\n";
    this.colormapFragShader += "}\n";
    this.colormapFragShader += "void main(void)\n";
    this.colormapFragShader += "{\n";
    this.colormapFragShader += "	float i = texture2D(colorTexture,vec2(texCoord.x, 1.0 - texCoord.y)).r;\n";
    this.colormapFragShader += "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
    this.colormapFragShader += "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
    this.colormapFragShader += "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b, cmValue.a*opacity);\n";
    this.colormapFragShader += "	if (isnan( i ) )\n";
    this.colormapFragShader += "	{\n";
    this.colormapFragShader += "		 gl_FragColor.a = 0.;\n";
    this.colormapFragShader += "	}\n";
    this.colormapFragShader += "}\n";
    var self = this;
    this.customShader = {
      fragmentCode: this.rawFragShader,
      updateUniforms: function (gl, program) {
        // Level zero image is required to init uniforms
        gl.uniform1f(program.uniforms.inversed, self.inversed);

        if (self.levelZeroImage) {
          gl.uniform1f(program.uniforms.max, self.levelZeroImage.tmax);
          gl.uniform1f(program.uniforms.min, self.levelZeroImage.tmin);
          gl.activeTexture(gl.TEXTURE1);
          gl.bindTexture(gl.TEXTURE_2D, self.levelZeroImage.colormapTex);
          gl.uniform1i(program.uniforms.colormap, 1);
          gl.uniform1f(program.uniforms.opacity, self.getOpacity());
        }
      }
    }; // Request for level zero image

    this.imageRequest = new ImageRequest({
      successCallback: function () {
        var data, res;
        self._ready = true;

        if (self.format === "fits") {
          // Unzip if g-zipped
          try {
            data = new Uint8Array(self.imageRequest.image);
            res = gzip.unzip(data);
            self.imageRequest.image = new Uint8Array(res).buffer;
          } catch (err) {
            if (err !== "Not a GZIP file") {
              // G-zip error
              this.failCallback();
              return;
            } else {
              // Image isn't g-zipped, handle image as fits
              data = null;
            }
          }

          self.handleImage(self.imageRequest);
          var fitsData = self.imageRequest.image;

          if (self.globe) {
            // Create level zero image
            var gl = self.globe.getRenderContext().gl;
            self.levelZeroImage = new DynamicImage(self.globe.getRenderContext(), fitsData.typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);

            self.getLevelZeroTexture = function () {
              return self.levelZeroImage.texture;
            };
          }
        } else {
          self.levelZeroImage = this.image;
          self.getLevelZeroTexture = null;
        } // Call callback if set


        if (options.onready && options.onready instanceof Function) {
          options.onready(self);
        } // Request a frame


        if (self.globe) {
          self.globe.getRenderContext().requestFrame();
        }
      },

      /**
       * @fires Context#baseLayersError
       */
      failCallback: function () {
        if (self.globe) {
          self.globe.publishEvent(Constants.EVENT_MSG.BASE_LAYERS_ERROR, self);
          self._ready = false;
        }
      },
      abortCallback: function (iq) {
        self._ready = false;
      }
    });
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractHipsLayer, HipsFitsLayer);
  /**************************************************************************************************************/

  /**
   * Attach the Hips Fits layer to the globe
   * @function _attach
   * @memberof HipsFitsLayer.prototype
   * @param {AbstractGlobe} g Globe to attach
   * @private
   */

  HipsFitsLayer.prototype._attach = function (g) {
    AbstractHipsLayer.prototype._attach.call(this, g); // Enable float texture extension to have higher luminance range


    var gl = this.getGlobe().getRenderContext().gl;
    this.requestLevelZeroImage();
    var ext = gl.getExtension("OES_texture_float");

    if (!ext) {
      // TODO
      ErrorDialog.open(Constants.LEVEL.DEBUG, "HipsFitsLayer.js", "no OES_texture_float");
      this.fitsSupported = false; //return;
    }
  };
  /**************************************************************************************************************/

  /**
   * Detach the Hips Fits layer from the globe
   * @function _detach
   * @memberof HipsFitsLayer#
   * @private
   */


  HipsFitsLayer.prototype._detach = function () {
    // Abort image request if in progress
    if (!this._ready) {
      this.imageRequest.abort();
    }

    this._ready = false;
    this.disposeResources();

    AbstractHipsLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/

  /**
   * Get url from a given tile
   * @function getUrl
   * @memberof HipsFitsLayer#
   * @param {Tile} tile Tile object
   */


  HipsFitsLayer.prototype.getUrl = function (tile) {
    var url = this.baseUrl;
    url += "/Norder";
    url += tile.order;
    url += "/Dir";
    url += Math.floor(tile.pixelIndex / 10000.0) * 10000.0;
    url += "/Npix";
    url += tile.pixelIndex;
    url += "." + this.format;
    return this.allowRequest(url);
  };
  /**************************************************************************************************************/

  /**
   * Extracts fits data from levelZeroImage.pixels to fitsPixel according to pixel index
   * @function extractFitsData
   * @memberof HipsFitsLayer#
   * @param pi Pixel index
   * @param fitsPixel Resulting typed vector containing fits data
   * @param sx X-offset of fitsPixel
   * @param sy Y-offset of fitsPixel
   */


  HipsFitsLayer.prototype.extractFitsData = function (pi, fitsPixel, sx, sy) {
    var size = 64;
    var width = this.levelZeroImage.width;
    var pixels = this.levelZeroImage.pixels;
    var startIndex = size * width * (28 - Math.floor(pi / 27)) + pi % 27 * size; // Extract fits data

    var typedLine;

    for (var i = 0; i < size; i++) {
      typedLine = pixels.subarray(startIndex + i * width, startIndex + i * width + size);
      fitsPixel.set(typedLine, sy + i * 128 + sx);
    }
  };
  /**************************************************************************************************************/

  /**
   * Generates the level0 texture for the tiles
   * @function generateLevel0Textures
   * @memberof HipsFitsLayer#
   * @param tiles
   * @param tilePool
   */


  HipsFitsLayer.prototype.generateLevel0Textures = function (tiles, tilePool) {
    var fitsPixel;
    var pi, sx, sy;
    var i, tile;
    var imgData;

    if (this.format !== "fits") {
      // Create a canvas to build the texture
      var canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      var context = canvas.getContext("2d");

      for (i = 0; i < tiles.length; i++) {
        tile = tiles[i]; // Top left

        pi = tile.pixelIndex * 4;
        sx = pi % 27 * 64;
        sy = Math.floor(pi / 27) * 64;
        context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 0, 64, 64); // Top right

        pi = tile.pixelIndex * 4 + 2;
        sx = pi % 27 * 64;
        sy = Math.floor(pi / 27) * 64;
        context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 0, 64, 64); // Bottom left

        pi = tile.pixelIndex * 4 + 1;
        sx = pi % 27 * 64;
        sy = Math.floor(pi / 27) * 64;
        context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 64, 64, 64); // Bottom right

        pi = tile.pixelIndex * 4 + 3;
        sx = pi % 27 * 64;
        sy = Math.floor(pi / 27) * 64;
        context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 64, 64, 64);
        imgData = context.getImageData(0, 0, 128, 128);
        imgData.dataType = "byte";
        tile.texture = tilePool.createGLTexture(imgData);
        tile.imageSize = 128;
      }
    } else {
      for (i = 0; i < tiles.length; i++) {
        tile = tiles[i];
        fitsPixel = new Float32Array(128 * 128); // Top left

        pi = tile.pixelIndex * 4;
        this.extractFitsData(pi, fitsPixel, 0, 128 * 64); // Top right

        pi = tile.pixelIndex * 4 + 2;
        this.extractFitsData(pi, fitsPixel, 64, 128 * 64); // Bottom left

        pi = tile.pixelIndex * 4 + 1;
        this.extractFitsData(pi, fitsPixel, 0, 0); // Bottom right

        pi = tile.pixelIndex * 4 + 3;
        this.extractFitsData(pi, fitsPixel, 64, 0);
        imgData = {
          typedArray: fitsPixel,
          width: 128,
          height: 128,
          dataType: "float"
        };
        tile.texture = tilePool.createGLTexture(imgData);
        tile.imageSize = 128;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Handles the fits image.
   * @function handleImage
   * @memberof HipsFitsLayer#
   * @param imgRequest
   */


  HipsFitsLayer.prototype.handleImage = function (imgRequest) {
    if (!(imgRequest.image instanceof Image)) {
      var fits = FitsLoader.parseFits(imgRequest.image);
      var fitsData = fits.getHDU().data;
      var bpe = fitsData.arrayType.BYTES_PER_ELEMENT;
      var float32array, float64array;
      var i;

      if (fitsData.arrayType.name === "Float64Array") {
        float64array = new Float64Array(fitsData.view.buffer, fitsData.begin, fitsData.length / bpe); // bpe = 8

        float32array = new Float32Array(fitsData.length / bpe); // Create Float32Array from Float64Array

        for (i = 0; i < float64array.length; i++) {
          float32array[i] = float64array[i];
        }
      } else {
        float32array = new Float32Array(fitsData.view.buffer, fitsData.begin, fitsData.length / bpe); // with gl.FLOAT, bpe = 4
      } // // Handle different types/formats.. just in case.
      // var dataType;
      // var typedArray;
      // var gl = this.globe.getRenderContext().gl;
      // var glType;
      // if ( fitsData.arrayType.name == "Float32Array" )
      // {
      // 	typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT );
      // 	dataType = "float";
      // 	glType = gl.FLOAT;
      // 	glFormat = gl.LUMINANCE;
      // }
      // else if ( fitsData.arrayType.name == "Uint8Array" )
      // {
      // 	typedArray = new Uint8Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT )
      // 	dataType = "int";
      // 	glType = gl.UNSIGNED_BYTE;
      // 	glFormat = gl.LUMINANCE;
      // }


      imgRequest.image = {
        typedArray: float32array,
        width: fitsData.width,
        height: fitsData.height,
        dataType: "float"
      };
    }
  };
  /**************************************************************************************************************/

  /**
   * Requests level zero image
   * @function requestLevelZeroImage
   * @memberof HipsFitsLayer#
   */


  HipsFitsLayer.prototype.requestLevelZeroImage = function () {
    // Set dataType always to jpg if fits isn't supported by graphic card
    if (!this.fitsSupported) {
      this.format = "jpg";
    } // Revert to raw rendering


    this.customShader.fragmentCode = this.rawFragShader;

    if (this.format === "fits") {
      this.inversed = 1.0;
    } else {
      this.inversed = 0.0;
    }

    var url = this.baseUrl + "/Norder3/Allsky." + this.format;
    this.imageRequest.send(url);
  };
  /**************************************************************************************************************/

  /**
   * Disposes the allocated resources
   * @function disposeResources
   * @memberof HipsFitsLayer#
   */


  HipsFitsLayer.prototype.disposeResources = function () {
    // Dispose level zero image & texture
    if (this.levelZeroImage && this.levelZeroImage.dispose) {
      this.levelZeroImage.dispose();
    }

    if (this.levelZeroTexture) {
      this.getGlobe().getRenderContext().gl.deleteTexture(this.levelZeroTexture);
    }

    this.levelZeroImage = null;
    this.levelZeroTexture = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * HipsFits configuration
   * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.graphic_configuration
   * @property {Function} onready - Callback function
   */

  /**
   * @name HipsGraphicLayer
   * @class
   * This layer draws an Hips Image
   * @augments AbstractHipsLayer
   * @param {HipsMetadata} hipsMetadata
   * @param {AbstractHipsLayer.graphic_configuration} options - HipsGraphic configuration
   * @memberof module:Layer
   * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
   * @fires Context#baseLayersError
   */

  var HipsGraphicLayer = function (hipsMetadata, options) {
    //options.format = options.format || "jpg";
    AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, options);
    this._ready = false; // allsky

    this.levelZeroImage = new Image();
    var self = this;
    this.levelZeroImage.crossOrigin = "";

    this.levelZeroImage.onload = function () {
      self._ready = true; // Call callback if set

      if (options.onready && options.onready instanceof Function) {
        options.onready(self);
      } // Request a frame


      if (self.globe) {
        self.globe.getRenderContext().requestFrame();
      }
    };

    this.levelZeroImage.onerror = function (event) {
      var error = self.getHipsMetadata();
      error.message = "Cannot load " + self.levelZeroImage.src;
      self.globe.publishEvent(Constants.EVENT_MSG.BASE_LAYERS_ERROR, error);
      self._ready = false;
      ErrorDialog.open(Constants.LEVEL.WARNING, "Cannot load " + self.levelZeroImage.src);
    };
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractHipsLayer, HipsGraphicLayer);
  /**************************************************************************************************************/

  /**
   * Attaches the raster layer to the planet.
   * @function _attach
   * @memberof HipsGraphicLayer#
   * @param g Globe
   * @private
   */

  HipsGraphicLayer.prototype._attach = function (g) {
    AbstractHipsLayer.prototype._attach.call(this, g); // Load level zero image now, only for background


    this.loadOverview();
  };
  /**
   * Loads image overview
   * @function loadOverview
   * @memberof HipsGraphicLayer
   */


  HipsGraphicLayer.prototype.loadOverview = function () {
    if (this.isBackground()) {
      this.levelZeroImage.src = this.allowRequest(this.baseUrl + "/Norder3/Allsky." + this.format);
    }
  };
  /**************************************************************************************************************/

  /**
   * Returns an url from a given tile.
   * @function getUrl
   * @memberof HipsGraphicLayer#
   * @param {Tile} tile Tile
   * @return {string} Url
   */


  HipsGraphicLayer.prototype.getUrl = function (tile) {
    var url = this.baseUrl;
    url += "/Norder";
    url += tile.order;
    url += "/Dir";
    var indexDirectory = Math.floor(tile.pixelIndex / 10000.0) * 10000.0;
    url += indexDirectory;
    url += "/Npix";
    url += tile.pixelIndex;
    url += "." + this.format;
    return this.allowRequest(url);
  };
  /**************************************************************************************************************/

  /**
   * Generates the level0 texture for the tiles.
   * @function generateLevel0Textures
   * @memberof HipsGraphicLayer
   * @param {Tile} tiles
   * @param {TilePool} tilePool
   */


  HipsGraphicLayer.prototype.generateLevel0Textures = function (tiles, tilePool) {
    // Create a canvas to build the texture
    var canvas = document.createElement("canvas");
    canvas.width = 128;
    canvas.height = 128;
    var i, pi, sx, sy, tile;
    var context = canvas.getContext("2d");

    for (i = 0; i < tiles.length; i++) {
      tile = tiles[i]; // Top left

      pi = tile.pixelIndex * 4;
      sx = pi % 27 * 64;
      sy = Math.floor(pi / 27) * 64;
      context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 0, 64, 64); // Top right

      pi = tile.pixelIndex * 4 + 2;
      sx = pi % 27 * 64;
      sy = Math.floor(pi / 27) * 64;
      context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 0, 64, 64); // Bottom left

      pi = tile.pixelIndex * 4 + 1;
      sx = pi % 27 * 64;
      sy = Math.floor(pi / 27) * 64;
      context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 64, 64, 64); // Bottom right

      pi = tile.pixelIndex * 4 + 3;
      sx = pi % 27 * 64;
      sy = Math.floor(pi / 27) * 64;
      context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 64, 64, 64);
      var imgData = context.getImageData(0, 0, 128, 128);
      imgData.dataType = "byte";
      tile.texture = tilePool.createGLTexture(imgData);
      tile.imageSize = 128;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * WCSElevation configuration
   * @typedef {AbstractRasterLayer.wms_configuration} AbstractRasterLayer.wmsElevation_configuration
   * @property {int} [tilePixelSize = 33]
   */

  /**
   * @name WMSElevationLayer
   * @class
   *    Creates a layer for elevation data using WMS protocol based on a GeoTiling(4, 2)
   *    with a pixelSize = 33 by default. The only supported format is currently image/x-aaigrid.
   * @augments WMSLayer
   * @param {AbstractLayer.wmsElevation_configuration} options - WMSElevation configuration
   * @constructor
   * @memberof module:Layer
   */

  var WMSElevationLayer = function (options) {
    options.format = "image/x-aaigrid";
    options.tilePixelSize = options.tilePixelSize || 33;
    WMSLayer.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(WMSLayer, WMSElevationLayer);
  /**************************************************************************************************************/

  /**
   * Parse a elevation response
   * @function parseElevations
   * @memberof WMSElevationLayer#
   * @param {string} text Response as text
   * @return {float[]} Array of float
   */

  WMSElevationLayer.prototype.parseElevations = function (text) {
    var elevations = [];
    var lines = text.trim().split("\n");

    for (var i = 5; i < lines.length; i++) {
      var elts = lines[i].trim().split(/\s+/);

      for (var n = 0; n < elts.length; n++) {
        elevations.push(parseInt(elts[n], 10));
      }
    }

    return elevations;
  };

  var Utils$1 = {};
  Utils$1.inherits = function (base, sub) {
    function tempCtor() {}
    tempCtor.prototype = base.prototype;
    sub.prototype = new tempCtor();
    sub.prototype.constructor = sub;
  };
  Utils$1.makeHttpObject = function () {
    try {
      return new XMLHttpRequest();
    } catch (erreur) {}
    try {
      return new ActiveXObject("Msxml2.XMLHTTP");
    } catch (erreur) {}
    try {
      return new ActiveXObject("Microsoft.XMLHTTP");
    } catch (erreur) {}
    throw new Error("The object creation for making HTTP requests has failed.");
  };
  Utils$1.guid = function () {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
  };
  Utils$1.findValueByKeyword = function (listKeywords, keyword) {
    var result = undefined;
    for (i = 0; i < listKeywords.length; i++) {
      var currentKeyword = listKeywords[i];
      if (currentKeyword[0] === keyword) {
        result = currentKeyword[1];
        break;
      }
    }
    return result;
  };
  Utils$1.parseXML = function (val) {
    if (document.implementation && document.implementation.createDocument) {
      xmlDoc = new DOMParser().parseFromString(val, "text/xml");
    } else if (window.ActiveXObject) {
      xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
      xmlDoc.loadXML(val);
    } else {
      alert("Your browser cannot handle this script");
      return null;
    }
    return xmlDoc;
  };

  var Cache$1 = function () {
    this.nodeID = {};
    this.nodeName = {};
    this.warnings = [];
  };
  Cache$1.prototype.getEltsByID = function () {
    return this.nodeID;
  };
  Cache$1.prototype.getEltsByName = function () {
    return this.nodeName;
  };
  Cache$1.prototype.getWarnings = function () {
    return this.warnings;
  };
  Cache$1.prototype.addEntryID = function (id, node) {
    this.nodeID[id] = node;
  };
  Cache$1.prototype.addEntryName = function (name, node) {
    if (this.nodeName.hasOwnProperty(name)) {
      this.nodeName[name].push(node);
    } else {
      this.nodeName[name] = [];
      this.nodeName[name].push(node);
    }
  };
  Cache$1.prototype.addWarning = function (warning) {
    this.warnings.push(warning);
  };

  var AbstractNode = function (childNode, tagName) {
    if (typeof tagName === "undefined") {
      throw new Error("tagName is undefined for " + childNode);
    }
    this.tagName = tagName;
    this.attributes = {};
    if (childNode != null && childNode.nodeType == 1) {
      for (var i = 0, l = childNode.attributes.length; i < l; i++) {
        var attribute = childNode.attributes[i];
        this.attributes[attribute.name] = attribute.value;
      }
      if (this.attributes.hasOwnProperty("ID")) {
        var cache = Singleton.getInstance();
        cache.addEntryID(this.attributes["ID"], this);
      }
      if (this.attributes.hasOwnProperty("name")) {
        var cache = Singleton.getInstance();
        cache.addEntryName(this.attributes["name"], this);
      }
    }
  };
  AbstractNode.prototype.getAttributes = function () {
    return this.attributes;
  };
  AbstractNode.prototype.hasAttribute = function (name) {
    return this.attributes.hasOwnProperty(name);
  };
  AbstractNode.prototype.hasAttributes = function () {
    return Object.keys(this.attributes).length == 0 ? false : true;
  };
  AbstractNode.prototype.getTagName = function () {
    return this.tagName;
  };
  AbstractNode.prototype.getCache = function () {
    return Singleton.getInstance();
  };
  var Singleton = (function () {
    var instance;
    function createInstance() {
      var object = new Cache$1();
      return object;
    }
    return {
      getInstance: function () {
        if (!instance) {
          instance = createInstance();
        }
        return instance;
      }
    };
  })();

  var Constants$1 = function () {};
  Constants$1.API = {
    version: "[VERSION_API]"
  };
  Constants$1.TAG = {
    BINARY: "BINARY",
    BINARY2: "BINARY2",
    COOSYS: "COOSYS",
    DATA: "DATA",
    DEFINITIONS: "DEFINITIONS",
    DESCRIPTION: "DESCRIPTION",
    FIELD: "FIELD",
    FIELDref: "FIELDref",
    FITS: "FITS",
    GROUP: "GROUP",
    INFO: "INFO",
    VOTABLE: "VOTABLE",
    LINK: "LINK",
    MAX: "MAX",
    MIN: "MIN",
    OPTION: "OPTION",
    PARAM: "PARAM",
    PARAMref: "PARAMref",
    RESOURCE: "RESOURCE",
    STREAM: "STREAM",
    TABLE: "TABLE",
    TABLEDATA: "TABLEDATA",
    TD: "TD",
    TR: "TR",
    VALUES: "VALUES"
  };

  var Description = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.DESCRIPTION);
    this.value;
    var element = childNode.childNodes[0];
    if (element != null && element.nodeType == 3) {
      this.value = element.textContent == null ? null : element.textContent.trim();
    }
  };
  Utils$1.inherits(AbstractNode, Description);
  Description.prototype.getContent = function () {
    return this.value;
  };

  var Fieldref = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.FIELDref);
  };
  Utils$1.inherits(AbstractNode, Fieldref);
  Fieldref.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Fieldref.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Fieldref.prototype.utype = function () {
    return this.attributes["utype"];
  };

  var Paramref = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.PARAMref);
  };
  Utils$1.inherits(AbstractNode, Paramref);
  Paramref.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Paramref.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Paramref.prototype.utype = function () {
    return this.attributes["utype"];
  };

  var Min = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.MIN);
  };
  Utils$1.inherits(AbstractNode, Min);
  Min.prototype.value = function () {
    return this.attributes["value"];
  };
  Min.prototype.inclusive = function () {
    return this.attributes["inclusive"];
  };

  var Max = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.MAX);
  };
  Utils$1.inherits(AbstractNode, Max);
  Max.prototype.value = function () {
    return this.attributes["value"];
  };
  Max.prototype.inclusive = function () {
    return this.attributes["inclusive"];
  };

  var Option = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.OPTION);
    var self = this;
    this.options = parseOptionTag(self, childNode);
  };
  var parseOptionTag = function (self, childNode) {
    var options = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.OPTION) {
          options.push(new Option(element));
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in Option node");
        }
      }
    }
    return options;
  };
  Utils$1.inherits(AbstractNode, Option);
  Option.prototype.name = function () {
    return this.attributes["name"];
  };
  Option.prototype.value = function () {
    return this.attributes["value"];
  };
  Option.prototype.getOptions = function () {
    return this.options;
  };

  var Values = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.VALUES);
    var self = this;
    var result = parseValuesTag(self, childNode);
    this.min = result[0];
    this.max = result[1];
    this.options = result[2];
  };
  var parseValuesTag = function (self, childNode) {
    var min;
    var max;
    var options = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.MIN:
            min = new Min(element);
            break;
          case Constants$1.TAG.MAX:
            max = new Max(element);
            break;
          case Constants$1.TAG.OPTION:
            options.push(new Option(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Values node");
        }
      }
    }
    return [min, max, options];
  };
  Utils$1.inherits(AbstractNode, Values);
  Values.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Values.prototype.type = function () {
    return this.attributes["type"];
  };
  Values.prototype.null = function () {
    return this.attributes["null"];
  };
  Values.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Values.prototype.getMin = function () {
    return this.min;
  };
  Values.prototype.getMax = function () {
    return this.max;
  };
  Values.prototype.getOptions = function () {
    return this.options;
  };

  var Link = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.LINK);
  };
  Utils$1.inherits(AbstractNode, Link);
  Link.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Link.prototype.content_role = function () {
    return this.attributes["content-role"];
  };
  Link.prototype.content_type = function () {
    return this.attributes["content-type"];
  };
  Link.prototype.title = function () {
    return this.attributes["title"];
  };
  Link.prototype.value = function () {
    return this.attributes["value"];
  };
  Link.prototype.href = function () {
    return this.attributes["href"];
  };
  Link.prototype.gref = function () {
    return this.attributes["gref"];
  };
  Link.prototype.action = function () {
    return this.attributes["action"];
  };

  var Field = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.FIELD);
    var self = this;
    var result = parseField(self, childNode);
    this.description = result[0];
    this.values = result[1];
    this.links = result[2];
  };
  var parseField = function (self, childNode) {
    var description;
    var values;
    var links = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.DESCRIPTION:
            description = new Description(element);
            break;
          case Constants$1.TAG.VALUES:
            values = new Values(element);
            break;
          case Constants$1.TAG.LINK:
            links.push(new Link(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Field node");
        }
      }
    }
    return [description, values, links];
  };
  Utils$1.inherits(AbstractNode, Field);
  Field.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Field.prototype.unit = function () {
    return this.attributes["unit"];
  };
  Field.prototype.datatype = function () {
    return this.attributes["datatype"];
  };
  Field.prototype.precision = function () {
    return this.attributes["precision"];
  };
  Field.prototype.width = function () {
    return this.attributes["width"];
  };
  Field.prototype.xtype = function () {
    return this.attributes["xtype"];
  };
  Field.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Field.prototype.name = function () {
    return this.attributes["name"];
  };
  Field.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Field.prototype.utype = function () {
    return this.attributes["utype"];
  };
  Field.prototype.arraysize = function () {
    return this.attributes["arraysize"];
  };
  Field.prototype.type = function () {
    return this.attributes["type"];
  };
  Field.prototype.getDescription = function () {
    return this.description;
  };
  Field.prototype.getValues = function () {
    return this.values;
  };
  Field.prototype.getLinks = function () {
    return this.links;
  };

  var Param = function (childNode) {
    Field.prototype.constructor.call(this, childNode, Constants$1.TAG.PARAM);
  };
  Utils$1.inherits(Field, Param);
  Param.prototype.value = function () {
    return this.attributes["value"];
  };

  var Group = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.GROUP);
    var self = this;
    var result = parseGroup(self, childNode);
    this.description = result[0];
    this.fieldrefs = result[1];
    this.paramrefs = result[2];
    this.params = result[3];
    this.groups = result[4];
  };
  var parseGroup = function (self, childNode) {
    var description;
    var fieldrefs = [];
    var paramrefs = [];
    var params = [];
    var groups = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.DESCRIPTION:
            description = new Description(element);
            break;
          case Constants$1.TAG.FIELDref:
            fieldrefs.push(new Fieldref(element));
            break;
          case Constants$1.TAG.PARAMref:
            paramrefs.push(new Paramref(element));
            break;
          case Constants$1.TAG.PARAM:
            params.push(new Param(element));
            break;
          case Constants$1.TAG.GROUP:
            groups.push(new Group(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Group node");
        }
      }
    }
    return [description, fieldrefs, paramrefs, params, groups];
  };
  Utils$1.inherits(AbstractNode, Group);
  Group.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Group.prototype.name = function () {
    return this.attributes["name"];
  };
  Group.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Group.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Group.prototype.utype = function () {
    return this.attributes["utype"];
  };
  Group.prototype.getDescription = function () {
    return this.description;
  };
  Group.prototype.getFieldrefs = function () {
    return this.fieldrefs;
  };
  Group.prototype.getParamrefs = function () {
    return this.paramrefs;
  };
  Group.prototype.getParams = function () {
    return this.params;
  };
  Group.prototype.getGroups = function () {
    return this.groups;
  };

  var Coosys = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.COOSYS);
    var self = this;
    this.value = parseCoordinateSystem(self, childNode);
  };
  Utils$1.inherits(AbstractNode, Coosys);
  var parseCoordinateSystem = function (self, childNode) {
    var value;
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element != null && element.nodeType == 3) {
        value = element.textContent == null ? null : element.textContent.trim();
      } else {
        self.getCache().addWarning("unknown element " + element + " in Coosys node");
      }
    }
    return value;
  };
  Coosys.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Coosys.prototype.equinox = function () {
    return this.attributes["equinox"];
  };
  Coosys.prototype.epoch = function () {
    return this.attributes["epoch"];
  };
  Coosys.prototype.system = function () {
    return this.attributes["system"];
  };
  Coosys.prototype.getContent = function () {
    return this.value;
  };

  var Definitions$1 = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.DEFINITIONS);
    var self = this;
    var result = parseDefinitions(self, childNode);
    this.coosys = result[0];
    this.param = result[1];
  };
  var parseDefinitions = function (self, childNode) {
    var coosyss = [];
    var params = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.COOSYS:
            coosyss.push(new Coosys(element));
            break;
          case Constants$1.TAG.PARAM:
            params.push(new Param(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Definitions node");
        }
        if (nodeName == Constants$1.TAG.COOSYS) {
          coosyss.push(new Coosys(element));
        } else if (nodeName == Constants$1.TAG.PARAM) {
          params.push(new Param(element));
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in Definitions node");
        }
      }
    }
    return [coosyss, params];
  };
  Utils$1.inherits(AbstractNode, Definitions$1);
  Definitions$1.prototype.getCoosyss = function () {
    return this.coosys;
  };
  Definitions$1.prototype.getParams = function () {
    return this.param;
  };

  var Info = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.INFO);
    var element = childNode.childNodes[0];
    if (element != null && element.nodeType == 3) {
      this.val = element.textContent == null ? null : element.textContent.trim();
    }
  };
  Info.prototype.name = function () {
    return this.attributes["name"];
  };
  Info.prototype.value = function () {
    return this.attributes["value"];
  };
  Info.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Info.prototype.unit = function () {
    return this.attributes["unit"];
  };
  Info.prototype.xtype = function () {
    return this.attributes["xtype"];
  };
  Info.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Info.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Info.prototype.utype = function () {
    return this.attributes["utype"];
  };
  Info.prototype.getContent = function () {
    return this.val;
  };

  var Td = function (childNode, options) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.TD);
    if (options == null) {
      this.value = childNode.textContent == null ? "" : childNode.textContent.trim();
    } else {
      this.value = options == null ? "" : options.trim();
    }
  };
  Utils$1.inherits(AbstractNode, Td);
  Td.prototype.encoding = function () {
    return this.attributes["encoding"];
  };
  Td.prototype.getContent = function () {
    return this.value;
  };

  var Tr = function (childNode, options) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.TR);
    if (options == null) {
      var self = this;
      this.tds = parseTr(self, childNode);
    } else {
      this.tds = [];
      for (var i = 0; i < options.length; i++) {
        this.tds.push(new Td(null, options[i]));
      }
    }
  };
  var parseTr = function (self, childNode) {
    var tds = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.TD) {
          tds.push(new Td(element));
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in Tr node");
        }
      }
    }
    return tds;
  };
  Utils$1.inherits(AbstractNode, Tr);
  Tr.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Tr.prototype.getTds = function () {
    return this.tds;
  };

  var AbstractData = function (childNode, name) {
    AbstractNode.prototype.constructor.call(this, childNode, name);
  };
  Utils$1.inherits(AbstractNode, AbstractData);

  var TableData = function (childNode, options) {
    AbstractData.prototype.constructor.call(this, childNode, Constants$1.TAG.TABLEDATA);
    if (options == null) {
      var self = this;
      this.trs = parseTableData(self, childNode);
    } else {
      this.trs = [];
      for (var i = 0; i < options.length; i++) {
        this.trs.push(new Tr(null, options[i]));
      }
    }
  };
  var parseTableData = function (self, childNode) {
    var trs = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.TR) {
          trs.push(new Tr(element));
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in TableData node");
        }
      }
    }
    return trs;
  };
  Utils$1.inherits(AbstractData, TableData);
  TableData.prototype.getTrs = function () {
    return this.trs;
  };

  var TAB_DATA_SIZE = {
    short: 16,
    int: 32,
    float: 32,
    double: 64,
    unsignedByte: 8
  };
  var Base64 = function (fields) {
    this.ptrStream = 0;
    this.bufferTabBits = [];
    this.fields = fields;
  };
  Base64.prototype.computeDataSize = function (datatype, fieldNumber, stream) {
    var dataSize = 0;
    if (datatype === "char") {
      if ((/\*/).test(this.fields[fieldNumber].arraysize())) {
        var tabBits = this.streamB64(32, stream);
        dataSize = 8 * bin2uint32(tabBits);
        tabBits = [];
      } else {
        dataSize = 8 * this.fields[fieldNumber].arraysize();
      }
    } else {
      dataSize = TAB_DATA_SIZE[datatype];
    }
    return dataSize;
  };
  Base64.prototype.streamB64 = function (datasize, stream) {
    var tabBits = [];
    var bufferLength = this.bufferTabBits.length;
    var needBit = Math.ceil((datasize - bufferLength) / 6);
    for (var i = 0; i < bufferLength; i += 1) {
      tabBits.push(this.bufferTabBits[i]);
    }
    this.bufferTabBits = [];
    for (var i = 0; i < needBit; i += 1) {
      if (stream.charCodeAt(this.ptrStream) == 10) {
        i -= 1;
      } else {
        var nb = b64ToUint6(stream.charCodeAt(this.ptrStream));
        for (var z = 32; z > 0; z >>= 1) {
          if (tabBits.length !== datasize) {
            tabBits.push((nb & z) === z ? "1" : "0");
          } else {
            this.bufferTabBits.push((nb & z) === z ? "1" : "0");
          }
        }
      }
      this.ptrStream += 1;
    }
    return tabBits;
  };
  Base64.prototype.decodeValue = function (datatype, datasize, fieldNumber, stream) {
    var value;
    var tabBits = [];
    if (datatype != "NULL") {
      tabBits = this.streamB64(datasize, stream);
    }
    switch (datatype) {
      case "short":
        value = bin2short16(tabBits);
        break;
      case "int":
        value = bin2int32(tabBits);
        break;
      case "float":
        value = bin2float32(tabBits);
        value = value.toFixed(this.fields[fieldNumber].precision());
        break;
      case "double":
        value = bin2double64(tabBits);
        value = value.toFixed(this.fields[fieldNumber].precision());
        break;
      case "unsignedByte":
        value = bin2ubyte8(tabBits);
        break;
      case "char":
        value = bin2string(tabBits);
        break;
      case "NULL":
        value = "NULL";
        break;
    }
    if (value === "NaN" || value === "NULL" || value === 0) {
      value = "";
    }
    return value;
  };
  Base64.prototype.decode = function (stream) {
    var trs = [];
    var fieldNumber = 0;
    var streamLength = stream.length;
    var nbFields = this.fields.length;
    var tds = [];
    do {
      var datatype = this.fields[fieldNumber].datatype();
      var datasize = this.computeDataSize(datatype, fieldNumber, stream);
      if (datasize == 0) {
        datatype = "NULL";
      }
      var value = this.decodeValue(datatype, datasize, fieldNumber, stream);
      tds.push(value);
      if (fieldNumber === nbFields - 1) {
        fieldNumber = 0;
        trs.push(tds);
        tds = [];
      } else {
        fieldNumber += 1;
      }
    } while (this.ptrStream < streamLength);
    return trs;
  };
  function bin2short16(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(2);
    dataview = new DataView(buffer);
    binary = TabBits.join("");
    dataview.setUint16(0, parseInt(binary, 2));
    return dataview.getInt16(0);
  }
  function bin2int32(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(4);
    dataview = new DataView(buffer);
    binary = TabBits.join("");
    dataview.setUint32(0, parseInt(binary, 2));
    return dataview.getInt32(0);
  }
  function bin2float32(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(4);
    dataview = new DataView(buffer);
    binary = TabBits.join("");
    dataview.setUint32(0, parseInt(binary, 2));
    return dataview.getFloat32(0);
  }
  function bin2double64(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(8);
    dataview = new DataView(buffer);
    binary = TabBits.slice(0, 32).join("");
    dataview.setUint32(0, parseInt(binary, 2));
    binary = "";
    binary = TabBits.slice(32, 64).join("");
    dataview.setUint32(4, parseInt(binary, 2));
    return dataview.getFloat64(0);
  }
  function bin2ubyte8(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(1);
    dataview = new DataView(buffer);
    binary = TabBits.join("");
    dataview.setUint8(0, parseInt(binary, 2));
    return dataview.getUint8(0);
  }
  function bin2string(TabBits) {
    var lenght, binary, i, j, str;
    lenght = TabBits.length / 8;
    binary = [];
    str = "";
    j = 0;
    for (i = 0; i < lenght; i += 1) {
      binary = TabBits.slice(j, j + 8);
      str = str.concat(String.fromCharCode(bin2ubyte8(binary)));
      binary = [];
      j += 8;
    }
    return str;
  }
  function bin2uint32(TabBits) {
    var buffer, dataview, binary;
    buffer = new ArrayBuffer(4);
    dataview = new DataView(buffer);
    binary = TabBits.join("");
    dataview.setUint32(0, parseInt(binary, 2));
    return dataview.getUint32(0);
  }
  function b64ToUint6(caractere) {
    var byte;
    if (caractere > 64 && caractere < 91) {
      byte = caractere - 65;
    } else if (caractere > 96 && caractere < 123) {
      byte = caractere - 71;
    } else if (caractere > 47 && caractere < 58) {
      byte = caractere + 4;
    } else if (caractere === 43) {
      byte = 62;
    } else if (caractere === 47) {
      byte = 63;
    }
    return byte;
  }

  var Stream = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.STREAM);
    this.value = childNode.textContent;
  };
  Utils$1.inherits(AbstractNode, Stream);
  Stream.prototype.type = function () {
    return this.attributes["type"];
  };
  Stream.prototype.href = function () {
    return this.attributes["href"];
  };
  Stream.prototype.actuate = function () {
    return this.attributes["actuate"];
  };
  Stream.prototype.encoding = function () {
    return this.attributes["encoding"];
  };
  Stream.prototype.expires = function () {
    return this.attributes["expires"];
  };
  Stream.prototype.rights = function () {
    return this.attributes["rights"];
  };
  Stream.prototype.getContent = function (decode, fields) {
    var result;
    if (decode == null || !decode) {
      result = this.value;
    } else {
      var base64 = new Base64(fields);
      result = new TableData(null, base64.decode(this.value));
    }
    return result;
  };

  var Binary = function (childNode) {
    AbstractData.prototype.constructor.call(this, childNode, Constants$1.TAG.BINARY);
    this.stream = parseBinary(childNode);
  };
  var parseBinary = function (childNode) {
    var stream;
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.STREAM) {
          stream = new Stream(element);
        } else {
          throw new Error("Unknown element");
        }
      }
    }
    return stream;
  };
  Utils$1.inherits(AbstractData, Binary);
  Binary.prototype.getStream = function () {
    return this.stream;
  };

  var Binary2 = function (childNode) {
    AbstractData.prototype.constructor.call(this, childNode, Constants$1.TAG.BINARY2);
    var self = this;
    this.stream = parseBinary2(self, childNode);
  };
  var parseBinary2 = function (self, childNode) {
    var stream;
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.STREAM) {
          stream = new Definitions(element);
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in Binary2 node");
        }
      }
    }
    return stream;
  };
  Utils$1.inherits(AbstractData, Binary2);
  Binary2.prototype.getStream = function () {
    return this.stream;
  };

  var Fits = function (childNode) {
    AbstractData.prototype.constructor.call(this, childNode, Constants$1.TAG.FITS);
    var self = this;
    this.stream = parseFits$2(self, childNode);
  };
  var parseFits$2 = function (self, childNode) {
    var stream;
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        if (nodeName == Constants$1.TAG.STREAM) {
          stream = new Definitions(element);
        } else {
          self.getCache().addWarning("unknown element " + nodeName + " in Fits node");
        }
      }
    }
    return stream;
  };
  Utils$1.inherits(AbstractData, Fits);
  Fits.prototype.getStream = function () {
    return this.stream;
  };
  Fits.prototype.extnum = function () {
    return this.attributes["extnum"];
  };

  var Data = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.DATA);
    var self = this;
    var result = parseData(self, childNode);
    this.data = result[0];
    this.infos = result[1];
  };
  var parseData = function (self, childNode) {
    var data;
    var infos = [];
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.TABLEDATA:
            data = new TableData(element);
            break;
          case Constants$1.TAG.BINARY:
            data = new Binary(element);
            break;
          case Constants$1.TAG.BINARY2:
            data = new Binary2(element);
            break;
          case Constants$1.TAG.FITS:
            data = new Fits(element);
            break;
          case Constants$1.TAG.INFO:
            infos.push(new Info(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Data node");
        }
      }
    }
    return [data, infos];
  };
  Utils$1.inherits(AbstractNode, Data);
  Data.prototype.getData = function () {
    return this.data;
  };
  Data.prototype.getDataImplementationName = function () {
    return this.data.getTagName();
  };
  Data.prototype.getInfos = function () {
    return this.infos;
  };

  var Table = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.TABLE);
    var self = this;
    var result = parseTable(self, childNode);
    this.fields = result[0];
    this.params = result[1];
    this.groups = result[2];
    this.links = result[3];
    this.data = result[4];
    this.description = result[5];
    this.infos = result[6];
  };
  var parseTable = function (self, childNodes) {
    var fields = [];
    var params = [];
    var groups = [];
    var links = [];
    var data;
    var description;
    var infos = [];
    for (var i = 0; childNodes != null && i < childNodes.childNodes.length; i++) {
      var element = childNodes.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.DESCRIPTION:
            description = new Description(element);
            break;
          case Constants$1.TAG.FIELD:
            fields.push(new Field(element));
            break;
          case Constants$1.TAG.PARAM:
            params.push(new Param(element));
            break;
          case Constants$1.TAG.GROUP:
            groups.push(new Group(element));
            break;
          case Constants$1.TAG.LINK:
            links.push(new Link(element));
            break;
          case Constants$1.TAG.DATA:
            data = new Data(element);
            break;
          case Constants$1.TAG.INFO:
            infos.push(new Info(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Table node");
        }
      }
    }
    return [fields, params, groups, links, data, description, infos];
  };
  Utils$1.inherits(AbstractNode, Table);
  Table.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Table.prototype.name = function () {
    return this.attributes["name"];
  };
  Table.prototype.ref = function () {
    return this.attributes["ref"];
  };
  Table.prototype.ucd = function () {
    return this.attributes["ucd"];
  };
  Table.prototype.utype = function () {
    return this.attributes["utype"];
  };
  Table.prototype.nrows = function () {
    return this.attributes["nrows"];
  };
  Table.prototype.getFields = function () {
    return this.fields;
  };
  Table.prototype.getParams = function () {
    return this.params;
  };
  Table.prototype.getGroups = function () {
    return this.groups;
  };
  Table.prototype.getLinks = function () {
    return this.links;
  };
  Table.prototype.getData = function () {
    return this.data;
  };
  Table.prototype.getInfos = function () {
    return this.infos;
  };
  Table.prototype.getDescription = function () {
    return this.description;
  };

  var Resource = function (childNode) {
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.RESOURCE);
    var self = this;
    var result = parseResource(self, childNode);
    this.description = result[0];
    this.infos = result[1];
    this.coosyss = result[2];
    this.params = result[3];
    this.groups = result[4];
    this.abstractSequences = result[5];
  };
  var parseResource = function (self, childNode) {
    var description;
    var infos = [];
    var coosyss = [];
    var groups = [];
    var params = [];
    var abstractSequences = [];
    var end = 0;
    var nbFound = 0;
    for (var i = 0; childNode != null && i < childNode.childNodes.length; i++) {
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.DESCRIPTION:
            description = new Description(element);
            nbFound++;
            break;
          case Constants$1.TAG.INFO:
            infos.push(new Info(element));
            nbFound++;
            break;
          case Constants$1.TAG.COOSYS:
            coosyss.push(new Coosys());
            nbFound++;
            break;
          case Constants$1.TAG.GROUP:
            groups.push(new Group());
            nbFound++;
            break;
          case Constants$1.TAG.PARAM:
            params.push(new Param());
            nbFound++;
            break;
          default:
            end = i;
        }
      }
      if (end != 0) {
        break;
      }
    }
    if (nbFound > end) {
      end = nbFound;
    }
    for (var i = end; childNode != null && i < childNode.childNodes.length; i++) {
      var seqElts = {};
      var seqLinks = [];
      var seqInfos = [];
      var element = childNode.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.LINK:
            seqLinks.push(new Link(element));
            break;
          case Constants$1.TAG.TABLE:
            seqElts["TABLE"] = new Table(element);
            if (seqLinks.length != 0) {
              seqElts["LINKS"] = seqLinks;
              abstractSequences.push(seqElts["LINKS"]);
              seqElts["LINKS"] = [];
              seqLinks = [];
            }
            if (seqInfos.length != 0) {
              seqElts["INFOS"] = seqInfos;
              abstractSequences.push(seqElts["INFOS"]);
              seqElts["INFOS"] = [];
              seqInfos = [];
            }
            abstractSequences.push(seqElts["TABLE"]);
            break;
          case Constants$1.TAG.RESOURCE:
            seqElts["RESOURCE"] = new Resource(element);
            if (seqLinks.length != 0) {
              seqElts["LINKS"] = seqLinks;
              abstractSequences.push(seqElts["LINKS"]);
              seqElts["LINKS"] = [];
              seqLinks = [];
            }
            if (seqInfos.length != 0) {
              seqElts["INFOS"] = seqInfos;
              abstractSequences.push(seqElts["INFOS"]);
              seqElts["INFOS"] = [];
              seqInfos = [];
            }
            abstractSequences.push(seqElts["RESOURCE"]);
            break;
          case Constants$1.TAG.INFO:
            seqInfos.push(new Info(element));
            if (i == childNode.childNodes.length - 1) {
              abstractSequences.push(seqInfos);
            }
            break;
          default:
            self.getCache().addWarning("Unkknown element " + nodeName + " in RESOURCE node");
        }
      }
    }
    return [description, infos, coosyss, params, groups, abstractSequences];
  };
  Utils$1.inherits(AbstractNode, Resource);
  Resource.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Resource.prototype.name = function () {
    return this.attributes["name"];
  };
  Resource.prototype.utype = function () {
    return this.attributes["utype"];
  };
  Resource.prototype.type = function () {
    return this.attributes["type"];
  };
  Resource.prototype.getDescription = function () {
    return this.description;
  };
  Resource.prototype.getInfos = function () {
    return this.infos;
  };
  Resource.prototype.getCoosyss = function () {
    return this.coosyss;
  };
  Resource.prototype.getGroups = function () {
    return this.groups;
  };
  Resource.prototype.getParams = function () {
    return this.params;
  };
  Resource.prototype.getResourcesOrTables = function () {
    return this.abstractSequences;
  };

  var UCD_ID = ["meta.record", "meta.id;meta.main", "VOX:Image_Titleq"];
  var UCD_RA = ["pos.eq.ra;meta.main", "POS_EQ_RA_MAIN"];
  var UCD_DEC = ["pos.eq.dec;meta.main", "POS_EQ_DEC_MAIN"];
  var GeoJson = function (votable) {
    this.votable = votable;
    this.featureCollection = process(this.votable);
  };
  GeoJson.prototype.getGeoJSon = function (option) {
    var pretty = option | false;
    return JSON.stringify(this.featureCollection, null, pretty);
  };
  function process(votable) {
    var featureCollection = {
      "type": "FeatureCollection",
      "features": []
    };
    var coosys = findAndGetGlobalCoosys(votable);
    if (coosys != null) {
      featureCollection["crs"] = {
        "type": "name",
        "properties": {
          "name": coosys
        }
      };
    }
    var features = [];
    var resources = votable.getResources();
    for (var i = 0; i < resources.length; i++) {
      processResource(resources[i], features);
    }
    featureCollection["features"] = features;
    function findAndGetGlobalCoosys(votable) {
      var coosys;
      var defs = votable.getDefinitions();
      if (defs != null) {
        coosys = defs.getCoosyss()[0];
      }
      if (votable.getCoosyss()[0] != null) {
        coosys = votable.getCoosyss()[0];
      }
      return coosys;
    }
    return featureCollection;
  }
  function processResource(resource, features) {
    var resourcesOrTables = resource.getResourcesOrTables();
    for (var i = 0; i < resourcesOrTables.length; i++) {
      var resourceOrTable = resourcesOrTables[i];
      if (resourceOrTable.getTagName() == Constants$1.TAG.RESOURCE) {
        processResource(resourceOrTable, features);
      } else if (resourceOrTable.getTagName() == Constants$1.TAG.TABLE) {
        processTable(resourceOrTable, features);
      }
    }
  }
  function processTable(table, features) {
    var fields = table.getFields();
    var data = table.getData();
    var trs;
    var infos = table.getInfos();
    switch (data.getDataImplementationName()) {
      case Constants$1.TAG.TABLEDATA:
        var tableData = data.getData();
        trs = tableData.getTrs();
        break;
      case Constants$1.TAG.BINARY:
        var binary = data.getData();
        var tableData = binary.getStream().getContent(true, fields);
        trs = tableData.getTrs();
        break;
      case Constants$1.TAG.BINARY2:
        throw new Error("Binary2 not implemented");
      case Constants$1.TAG.FITS:
        throw new Error("Fits not implemented");
      default:
        throw new Error("Type of data not implemented for " + table);
    }
    creatureFeatures(fields, infos, trs, features);
  }
  function creatureFeatures(fields, infos, trs, features) {
    for (var i = 0; i < trs.length; i++) {
      var tds = trs[i].getTds();
      features.push(createFeature(fields, infos, tds));
    }
  }
  function createFeature(fields, infos, tds) {
    var feature = {
      "type": "Feature",
      "geometry": null,
      "properties": {}
    };
    var coreMetadata = {};
    for (var i = 0; i < tds.length; i++) {
      var td = tds[i];
      var field = fields[i];
      var values = field.getValues();
      var nullValue = values != null ? values.null() : null;
      var ucd = field.ucd();
      var datatype = field.datatype();
      var value = td.getContent();
      var name = field.name();
      if (filter(UCD_RA, ucd)) {
        coreMetadata["RA"] = Number.parseFloat(value);
        coreMetadata["COOSYS"] = field.ref();
      } else if (filter(UCD_DEC, ucd)) {
        coreMetadata["DEC"] = Number.parseFloat(value);
      } else if (filter(UCD_ID, ucd)) {
        coreMetadata["ID"] = value;
      } else {
        var properties = feature.properties;
        if (value != nullValue) {
          properties[name] = parseDatatype(value, datatype);
        }
      }
    }
    if (!coreMetadata.hasOwnProperty("ID")) {
      coreMetadata["ID"] = Utils$1.guid();
    }
    for (var i = 0; i < infos.length; i++) {
      var info = infos[i];
      properties[info.name()] = info.value();
    }
    checkCoreMetadata(coreMetadata);
    var geometry = {
      "type": "Point",
      "coordinates": [coreMetadata.RA, coreMetadata.DEC],
      "crs": {
        "type": "name",
        "properties": {
          "name": coreMetadata.COOSYS
        }
      }
    };
    feature["geometry"] = geometry;
    function checkCoreMetadata(coreMetadata) {
      if (!(coreMetadata.hasOwnProperty("RA") && coreMetadata.hasOwnProperty("DEC") && coreMetadata.hasOwnProperty("COOSYS") && coreMetadata.hasOwnProperty("ID"))) {
        throw new Error("core metadata missing " + JSON.stringify(coreMetadata));
      }
    }
    function parseDatatype(value, type) {
      var result;
      switch (type) {
        case "short":
        case "int":
        case "long":
          result = Number.parseInt(value);
          break;
        case "float":
        case "double":
          result = Number.parseFloat(value);
          break;
        default:
          result = value;
      }
      return result;
    }
    function filter(arr, criteria) {
      var result = arr.filter(function (obj) {
        return obj === criteria;
      });
      return result.length == 0 ? false : true;
    }
    return feature;
  }

  var Votable = function (xml) {
    xml = checkInputFormat(xml);
    var childNode = xml.documentElement;
    AbstractNode.prototype.constructor.call(this, childNode, Constants$1.TAG.VOTABLE);
    var self = this;
    var result = parseVotableTag(self, childNode);
    this.definitions = result[0];
    this.infos = result[1];
    this.resources = result[2];
    this.description = result[3];
    this.coosyss = result[4];
    this.groups = result[5];
    this.params = result[6];
  };
  function checkInputFormat(xml) {
    if (xml == null) {
      throw new Error("xml cannot be null");
    } else if (typeof xml === "string") {
      var parser = new DOMParser();
      xml = parser.parseFromString(xml, "application/xml");
    } else if (xml.documentElement != null) ; else {
      throw new Error("This object is not supported");
    }
    var tag = xml.documentElement.localName;
    if (tag != Constants$1.TAG.VOTABLE) {
      throw new Error("This input is not a VOTable");
    }
    return xml;
  }
  var parseVotableTag = function (self, childNode) {
    var root = childNode;
    var definitions;
    var infos = [];
    var resources = [];
    var description;
    var coosyss = [];
    var groups = [];
    var params = [];
    for (var i = 0; i < root.childNodes.length; i++) {
      var element = root.childNodes[i];
      if (element.nodeType == 1) {
        var nodeName = element.localName;
        switch (nodeName) {
          case Constants$1.TAG.DEFINITIONS:
            definitions = new Definitions$1(element);
            break;
          case Constants$1.TAG.INFO:
            infos.push(new Info(element));
            break;
          case Constants$1.TAG.RESOURCE:
            resources.push(new Resource(element));
            break;
          case Constants$1.TAG.DESCRIPTION:
            description = new Description(element);
            break;
          case Constants$1.TAG.COOSYS:
            coosyss.push(new Coosys(element));
            break;
          case Constants$1.TAG.GROUP:
            groups.push(new Group(element));
            break;
          case Constants$1.TAG.PARAM:
            params.push(new Param(element));
            break;
          default:
            self.getCache().addWarning("unknown element " + nodeName + " in Votable node");
        }
      }
    }
    return [definitions, infos, resources, description, coosyss, groups, params];
  };
  Utils$1.inherits(AbstractNode, Votable);
  Votable.prototype.ID = function () {
    return this.attributes["ID"];
  };
  Votable.prototype.version = function () {
    return this.attributes["version"];
  };
  Votable.prototype.getInfos = function () {
    return this.infos;
  };
  Votable.prototype.getDefinitions = function () {
    return this.definitions;
  };
  Votable.prototype.getResources = function () {
    return this.resources;
  };
  Votable.prototype.getCoosyss = function () {
    return this.coosyss;
  };
  Votable.prototype.getGroups = function () {
    return this.groups;
  };
  Votable.prototype.getParams = function () {
    return this.params;
  };
  Votable.prototype.getDescription = function () {
    return this.description;
  };
  Votable.prototype.getVotableEltByID = function (ID) {
    return this.getCache().getEltsByID()[ID];
  };
  Votable.prototype.getVotableEltsByName = function (name) {
    return this.getCache().getEltsByName()[name];
  };
  Votable.prototype.convertToGeoJSon = function (option) {
    var geoJson = new GeoJson(this);
    return geoJson.getGeoJSon(option);
  };

  var JsVotable$1 = {};
  JsVotable$1.Constants = Constants$1;
  JsVotable$1.Votable = Votable;
  JsVotable$1.Binary = Binary;
  JsVotable$1.Binary2 = Binary2;
  JsVotable$1.Coosys = Coosys;
  JsVotable$1.Data = Data;
  JsVotable$1.Definitions = Definitions$1;
  JsVotable$1.Description = Description;
  JsVotable$1.Field = Field;
  JsVotable$1.Fieldref = Fieldref;
  JsVotable$1.Fits = Fits;
  JsVotable$1.Group = Group;
  JsVotable$1.Info = Info;
  JsVotable$1.Link = Link;
  JsVotable$1.Max = Max;
  JsVotable$1.Min = Min;
  JsVotable$1.Option = Option;
  JsVotable$1.Param = Param;
  JsVotable$1.Paramref = Paramref;
  JsVotable$1.Resource = Resource;
  JsVotable$1.Stream = Stream;
  JsVotable$1.Table = Table;
  JsVotable$1.TableData = TableData;
  JsVotable$1.Td = Td;
  JsVotable$1.Tr = Tr;
  JsVotable$1.Values = Values;
  JsVotable$1.version = {
    major: 2,
    minor: 0,
    patch: 2,
    date: "2019-02-15",
    toString: function () {
      return this.major + "." + this.minor + "." + this.patch;
    }
  };
  window.JsVotable = JsVotable$1;

  var PREFIX_COMMENT = "#";
  var Csv = function (csv, commonSeparator, headerInfo) {
    checkInputFormat$1(csv);
    this.store = parseCSV(csv, commonSeparator, headerInfo);
  };
  function checkInputFormat$1(csv) {
    if (csv == null) {
      throw new Error("csv cannot be null");
    } else if (typeof csv !== "string") {
      throw new Error("This object is not supported");
    } else ;
  }
  function parseCSV(csv, commonSeparator, headerInfo) {
    var rows = csv.split("\n");
    var lineWithData = 0;
    for (var i = 0; i < rows.length && isUselessRow(rows[i], commonSeparator, headerInfo.name); i++) {
      lineWithData++;
    }
    return parseRows(rows, lineWithData, commonSeparator, headerInfo);
  }
  function isUselessRow(row, commonSeparator, headerName) {
    return row.startsWith(PREFIX_COMMENT) || row.length == 0 || headerName.toString() == row.split(commonSeparator).toString();
  }
  function parseRows(rows, lineWithData, commonSeparator, headerInfo) {
    var store = [];
    for (var i = lineWithData; i < rows.length; i++) {
      if (rows[i].length !== 0) {
        store.push(parseRow(rows[i], commonSeparator, headerInfo));
      }
    }
    return store;
  }
  function parseRow(row, commonSeparator, headerInfo) {
    var store = {};
    var tds = row.split(commonSeparator);
    for (var i = 0; i < tds.length; i++) {
      store[headerInfo.name[i]] = parseDatatype(tds[i], headerInfo.datatype[i]);
    }
    return store;
  }
  function parseDatatype(value, type) {
    var result;
    switch (type) {
      case "short":
      case "int":
      case "long":
        result = Number.parseInt(value);
        break;
      case "float":
      case "double":
        result = Number.parseFloat(value);
        break;
      default:
        result = value;
    }
    return result;
  }
  Csv.prototype.getStore = function () {
    return this.store;
  };
  Csv.prototype.getGeoJSon = function (mapping, frame) {
    var RA = mapping.RA;
    var DEC = mapping.DEC;
    var ID = mapping.ID;
    var features = [];
    for (var i = 0; i < this.store.length; i++) {
      var feature = {
        "type": "Feature",
        "id": this.store[i][ID],
        "geometry": {
          "type": "Point",
          "coordinates": [this.store[i][RA], this.store[i][DEC]],
          "crs": {
            "type": "name",
            "properties": {
              "name": frame
            }
          }
        }
      };
      var newStore = JSON.parse(JSON.stringify(this.store[i]));
      delete newStore[RA];
      delete newStore[DEC];
      delete newStore[ID];
      feature["properties"] = newStore;
      features.push(feature);
    }
    var featureCollection = {
      "type": "FeatureCollection",
      "features": features
    };
    return featureCollection;
  };

  var JsCsv$1 = {};
  JsCsv$1.Csv = Csv;
  JsCsv$1.version = {
    major: 1,
    minor: 1,
    patch: 4,
    date: "2019-02-15",
    toString: function () {
      return this.major + "." + this.minor + "." + this.patch;
    }
  };
  window.JsCsv = JsCsv$1;

  var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMBQkVBRMIQtMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAvklEQVQY012QMWpCURBFz3yfG7CIwSatpLGwsJJsQEHssr2UttapkkK0zRJEFPKLj5UYPGme8vgDt5l7uNwZKEYNdaZO1FR6VQkBT8AbMAGe1e7dTwXUB8bAFPgF9sBWPUXENbWgBTAELkCTw7bqMdR5kTQCehlogB/gE/iqcs9OVhT9I8v7EZU6UJfqh3pWa3WlvqsvakoRcVOPwCYnvQI1sM67Q0T8JYAWvAEOwDewj4jr4z0teJdf84AA/gF1uG92uhcfoAAAAABJRU5ErkJggg==";

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  function _setDefaultOptions(options) {
    options.icon = options.icon || img;
    options.background = false;
    options.category = options.category || "Catalog";
    options.pickable = options.pickable || true;
    return options;
  }
  /**
   * Hips catalogue configuration
   * @typedef {AbstractLayer.configuration} AbstractLayerstar.hipsCat_configuration
   * @property {string} serviceUrl - Endpoint to reach the Hips catalogue
   * @property {int} [minOrder = 2] - min order
   * @property {int} [maxRequests = 4] - Max requests in parallel
   * @property {boolean} [invertY = false]
   */

  /**
   * Create a HIPS catalogue
   * @param {AbstractLayer.hipsCat_configuration} options - Hip catalogue configuration
   * @constructor
   * @memberof module:Layer
   * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
   */


  const HipsCatLayer = function (hipsMetadata, options) {
    AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, _setDefaultOptions(options));
    let i;
    const propertiesObj = new Properties(this.allowRequest(options.baseUrl) + "/properties");
    const properties = propertiesObj.getProperties();
    const hips_order = properties.hips_order;
    this.serviceUrl = this.allowRequest(options.baseUrl);
    this.minOrder = options.minOrder || 2;
    this.maxOrder = Number.parseInt(hips_order, 10);
    this.maxRequests = options.maxRequests || 4;
    this.invertY = options.invertY || false;
    let xhr = new XMLHttpRequest();
    xhr.open("GET", Proxy.proxify(this.allowRequest(options.baseUrl + "/metadata.xml")), false);
    xhr.setRequestHeader("Accept", "application/xml");
    xhr.send(null);
    const jsVotable = new JsVotable.Votable(xhr.responseXML);
    const resource = jsVotable.getResources()[0];
    const table = resource.getResourcesOrTables()[0];
    this.fields = table.getFields();
    this.raColNumber = null;
    this.decColNumber = null;
    this.sourceId = null;

    for (i = 0; i < this.fields.length; i++) {
      const ucd = this.fields[i].ucd();

      if (ucd === "pos.eq.ra;meta.main") {
        this.raColNumber = this.fields[i].name();
      } else if (ucd === "pos.eq.dec;meta.main") {
        this.decColNumber = this.fields[i].name();
      } else if (ucd === "meta.id;meta.main") {
        this.sourceId = this.fields[i].name();
      }
    }

    this.extId = "hipsCat"; // Used for picking management

    this.features = []; // Counter set, indicates how many times the feature has been requested

    this.featuresSet = {}; // Maximum two requests for now

    this.freeRequests = [];
    this.tilesToLoad = []; // Build the request objects

    for (i = 0; i < this.maxRequests; i++) {
      xhr = new XMLHttpRequest();
      this.freeRequests.push(xhr);
    }
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractHipsLayer, HipsCatLayer);
  /**************************************************************************************************************/

  /**
   * Parse properties file of the Hips catalogue
   * @param url
   * @constructor
   */

  var Properties = function (url) {
    this.properties = {};
    let i;
    const xhr = new XMLHttpRequest();
    xhr.open("GET", Proxy.proxify(url), false);
    xhr.setRequestHeader("Accept", "text/plain");
    xhr.send();
    const content = xhr.responseText;
    content.trim();
    const lines = content.split("\n");

    for (i = 0; lines !== null && i < lines.length; i++) {
      const line = lines[i];

      if (line.indexOf("#") > -1 || !line.trim()) {
        continue;
      }

      const keywordValue = line.split("=");
      const keyword = keywordValue[0].replace(/^\s+|\s+$/g, "");
      const value = keywordValue[1].replace(/^\s+|\s+$/g, "");
      this.properties[keyword] = value;
    }
  };
  /**
   * Returns the properties
   * @return {{}}
   */


  Properties.prototype.getProperties = function () {
    return this.properties;
  };
  /**
   * Attaches the layer to the globe
   * @param g The globe
   * @private
   */


  HipsCatLayer.prototype._attach = function (g) {
    AbstractHipsLayer.prototype._attach.call(this, g);

    this.extId += this.id;
    g.getTileManager().addPostRenderer(this);
  };
  /**************************************************************************************************************/

  /**
   * Detaches the layer from the globe
   * @private
   */


  HipsCatLayer.prototype._detach = function () {
    this.getGlobe().getTileManager().removePostRenderer(this);

    AbstractHipsLayer.prototype._detach.call(this);
  };
  /**************************************************************************************************************/

  /**
   * Launches request to the HipsCatLayer service
   * @param tile
   * @param url
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#features:added
   */


  HipsCatLayer.prototype.launchRequest = function (tile, url) {
    const tileData = tile.extension[this.extId]; // const index = null;

    if (this.freeRequests.length === 0) {
      return;
    } // Set that the tile is loading its data for HipsCatLayer


    tileData.state = HipsCatLayer.TileState.LOADING; // Pusblish the start load event, only if there is no pending requests

    if (this.maxRequests === this.freeRequests.length) {
      this.getGlobe().publishEvent(Constants.EVENT_MSG.LAYER_START_LOAD, this);
    }

    const xhr = this.freeRequests.pop();
    const self = this;
    xhr.open("GET", Proxy.proxify(url));
    xhr.setRequestHeader("Accept", "application/xml");
    xhr.send(null);

    xhr.onreadystatechange = function (e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          const response = {};
          const headerInfo = {
            name: [],
            datatype: []
          };
          self.fields.forEach(function (field) {
            headerInfo.name.push(field.name());
            headerInfo.datatype.push(field.datatype());
          });
          const csv = new JsCsv.Csv(xhr.response, "\t", headerInfo);
          const geoJson = csv.getGeoJSon({
            RA: self.raColNumber,
            DEC: self.decColNumber,
            ID: self.sourceId
          }, "Equatorial");
          const features = geoJson.features;
          response.features = features;
          response.totalResults = features.length; //var response = JSON.parse(xhr.response);

          tileData.complete = response.totalResults === response.features.length; //self.updateFeatures(response.features);

          let i;

          for (i = response.features.length - 1; i >= 0; i--) {
            const feature = response.features[i]; // Eliminate already added features from response

            const alreadyAdded = self.featuresSet.hasOwnProperty(feature.id);
            if (alreadyAdded) response.features.splice(i, 1);
            feature.properties.style = this.style;
            self.addFeature(feature, tile);
          }

          self.globe.refresh(); // Publish event that layer have received new features

          if (response.hasOwnProperty(features) && response.features.length > 0) {
            self.globe.publishEvent(Constants.EVENT_MSG.FEATURED_ADDED, {
              layer: self,
              features: response.features
            });
          }
        } else if (xhr.status >= 400) {
          tileData.complete = true;
        }

        tileData.state = HipsCatLayer.TileState.LOADED;
        self.freeRequests.push(xhr); // Publish the end load event, only if there is no pending requests

        if (self.maxRequests === self.freeRequests.length) {
          self.globe.publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, self);
        }
      }
    };
  };
  /**************************************************************************************************************/

  /**
   * Adds feature to the layer and to the tile extension
   * @param feature
   * @param tile
   */


  HipsCatLayer.prototype.addFeature = function (feature, tile) {
    const tileData = tile.extension[this.extId];
    let featureData; // Add feature if it doesn't exist

    if (!this.featuresSet.hasOwnProperty(feature.id)) {
      this.features.push(feature);
      featureData = {
        index: this.features.length - 1,
        tiles: [tile]
      };
      this.featuresSet[feature.id] = featureData;
    } else {
      featureData = this.featuresSet[feature.id]; // Store the tile

      featureData.tiles.push(tile); // Always use the base feature to manage geometry indices

      feature = this.features[featureData.index];
    } // Add feature id


    tileData.featureIds.push(feature.id); // Set the identifier on the geometry

    feature.geometry.gid = feature.id; // Add to renderer
    //this.addFeatureToRenderer(feature, tile);
    // MS: Feature could be added from ClusterOpenSearch which have features with different styles

    const style = feature.properties.style ? feature.properties.style : this.style;
    this.getGlobe().getRendererManager().addGeometryToTile(this, feature.geometry, style, tile);
  };
  /**************************************************************************************************************/

  /**
   * Removes feature from Dynamic HipsCatLayer layer
   * @param identifier
   * @param tile
   */


  HipsCatLayer.prototype.removeFeature = function (identifier, tile) {
    const featureIt = this.featuresSet[identifier];

    if (!featureIt) {
      return;
    } // Remove tile from array


    const tileIndex = featureIt.tiles.indexOf(tile);

    if (tileIndex >= 0) {
      featureIt.tiles.splice(tileIndex, 1);
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "HipsCatLayer internal error : tile not found when removing feature");
    }

    if (featureIt.tiles.length === 0) {
      // Remove it from the set
      delete this.featuresSet[identifier]; // Remove it from the array by swapping it with the last feature to optimize removal.

      const lastFeature = this.features.pop();

      if (featureIt.index < this.features.length) {
        // Set the last feature at the position of the removed feature
        this.features[featureIt.index] = lastFeature; // Update its index in the Set.

        this.featuresSet[lastFeature.id].index = featureIt.index;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Modifies feature style
   * @param feature
   * @param style
   */


  HipsCatLayer.prototype.modifyFeatureStyle = function (feature, style) {
    feature.properties.style = style;
    const featureData = this.featuresSet[feature.id];

    if (featureData) {
      let i;

      for (i = 0; i < featureData.tiles.length; i++) {
        const tile = featureData.tiles[i];
        this.getGlobe().getRendererManager().removeGeometryFromTile(feature.geometry, tile);
        this.getGlobe().getRendererManager().addGeometryToTile(this, feature.geometry, style, tile);
      }
    }
  };

  HipsCatLayer.TileState = {
    LOADING: 0,
    LOADED: 1,
    NOT_LOADED: 2,
    INHERIT_PARENT: 3
  };
  /**************************************************************************************************************/

  /**
   * Generates the tile data
   * @param tile
   */

  HipsCatLayer.prototype.generate = function (tile) {
    if (this.minOrder <= tile.order && tile.order <= this.maxOrder) {
      tile.extension[this.extId] = new OSData(this, tile, null);
    }
  };
  /**************************************************************************************************************/

  /**
   * HipsCatLayer renderable
   * @param layer
   * @param tile
   * @param p
   * @constructor
   */


  var OSData = function (layer, tile, p) {
    this.layer = layer;
    this.parent = p;
    this.tile = tile;
    this.featureIds = []; // exclusive parameter to remove from layer

    this.state = HipsCatLayer.TileState.NOT_LOADED;
    this.complete = false;
    this.childrenCreated = false;
  };
  /**************************************************************************************************************/

  /**
   * Traverse
   * @param tile
   */


  OSData.prototype.traverse = function (tile) {
    let i;
    if (!this.layer.isVisible()) return;
    if (tile.state !== Tile.State.LOADED) return; // Check if the tile need to be loaded

    if (this.state === HipsCatLayer.TileState.NOT_LOADED) {
      this.layer.tilesToLoad.push(this);
    } // Create children if needed


    if (this.state === HipsCatLayer.TileState.LOADED && !this.complete && tile.state === Tile.State.LOADED && tile.children && !this.childrenCreated) {
      for (i = 0; i < 4; i++) {
        if (!tile.children[i].extension[this.layer.extId]) tile.children[i].extension[this.layer.extId] = new OSData(this.layer, tile.children[i], this);
      }

      this.childrenCreated = true; // HACK : set renderable to have children

      const renderables = tile.extension.renderer ? tile.extension.renderer.renderables : [];

      for (i = 0; i < renderables.length; i++) {
        if (renderables[i].bucket.layer === this.layer) renderables[i].hasChildren = true;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Disposes renderable data from tile
   * @param renderContext
   * @param tilePool
   */


  OSData.prototype.dispose = function (renderContext, tilePool) {
    let i;

    if (this.parent && this.parent.childrenCreated) {
      this.parent.childrenCreated = false; // HACK : set renderable to not have children!

      const renderables = this.parent.tile.extension.renderer ? this.parent.tile.extension.renderer.renderables : [];

      for (i = 0; i < renderables.length; i++) {
        if (renderables[i].bucket.layer === this.layer) renderables[i].hasChildren = false;
      }
    }

    for (i = 0; i < this.featureIds.length; i++) {
      this.layer.removeFeature(this.featureIds[i], this.tile);
    }

    this.tile = null;
    this.parent = null;
  };
  /**************************************************************************************************************/

  /**
   * Builds URL
   * @param tile
   * @return {*}
   */


  HipsCatLayer.prototype.buildUrl = function (tile) {
    let url;

    if (tile.order <= 0) {
      url = this.serviceUrl + "/Norder" + tile.order + "/Allsky.xml";
    } else {
      url = this.serviceUrl;
      url += "/Norder";
      url += tile.order;
      url += "/Dir";
      const indexDirectory = Math.floor(tile.pixelIndex / 10000) * 10000;
      url += indexDirectory;
      url += "/Npix";
      url += tile.pixelIndex;
      url += ".tsv";
    }

    return url;
  };
  /**
   * Get Tile URL.
   * @param tile
   * @returns {*}
   */


  HipsCatLayer.prototype.getUrl = function (tile) {
    return this.allowRequest(this.buildUrl(tile));
  };
  /**************************************************************************************************************/

  /**
   * Internal function to sort tiles
   * @param t1
   * @param t2
   * @return {number}
   * @private
   */


  function _sortTilesByDistance$2(t1, t2) {
    return t1.tile.distance - t2.tile.distance;
  }
  /**
   * Render function
   *
   * @param tiles The array of tiles to render
   */


  HipsCatLayer.prototype.render = function (tiles) {
    let i;
    if (!this.visible) return; // Sort tiles

    this.tilesToLoad.sort(_sortTilesByDistance$2); // Load data for the tiles if needed

    for (i = 0; i < this.tilesToLoad.length && this.freeRequests.length > 0; i++) {
      const tile = this.tilesToLoad[i].tile;
      const url = this.buildUrl(tile);

      if (url) {
        this.launchRequest(tile, url);
      }
    }

    this.tilesToLoad.length = 0;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name GeoJsonLayer
   * @class
   *    Create a layer to display vector data in GeoJSON format.
   * @augments AbstractVectorLayer
   * @param {AbstractLayer.geojson_configuration} options - GeoJsonLayer configuration
   * @constructor
   * @memberof module:Layer
   */

  var GeoJsonLayer = function (options) {
    AbstractVectorLayer.prototype.constructor.call(this, Constants.LAYER.GeoJSON, options);
    this.gid = 0;
  };
  /**
   * Check if the GeoJSon has a valid geometry attribute
   * @param {Object} feature - GeoJSON feature
   * @throws {RangeError} Invalid GeoJson
   * @private
   */


  function _checkValidGeoJson(feature) {
    var geometry = feature.geometry;

    if (!geometry || !geometry.type) {
      throw new RangeError("GeoJsonLayer.js: Invalid GeoJson");
    }
  }
  /**
   * Set the global crs when the geometry has not crs.
   * If no globalCrs, then WGS84 is set
   * @param {Object} feature - GeoJSON feature
   * @param {Object} globalCrs - GeoJSON crs element
   * @returns {Object} the feature
   * @private
   */


  function _setCrs(feature, globalCrs) {
    if (!feature.geometry.crs) {
      feature.geometry.crs = globalCrs ? globalCrs : {
        type: "name",
        properties: {
          name: Constants.CRS.WGS84
        }
      };
    }

    return feature;
  }
  /**
   * Sets an unique ID of the GeoJSON geometry
   * @param {Object} feature - GeoJSON feature
   * @returns {Object} GeoJSON feature
   * @private
   */


  function _setID(feature) {
    feature.geometry.gid = this.ID + "_GeoJSON_" + this.gid;
    this.gid++;
    return feature;
  }
  /**
   * Checks whether a geometry type such a point has a geometry.
   * @param {Object} geometry
   * @returns {Boolean} true when the point has an altitude otherwse false
   * @private
   */


  function _hasPointAltitude(geometry) {
    return geometry.type === Constants.GEOMETRY.Point && geometry.coordinates.length == 3;
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractVectorLayer, GeoJsonLayer);
  /**************************************************************************************************************/

  /**
   * Adds a feature collection, in GeoJSON format
   * @function addFeatureCollection
   * @memberof GeoJsonLayer#
   * @param {GeoJSON} featureCollection Feature Collection
   * @throws {ReferenceError} Error, featureCollection is null
   */

  GeoJsonLayer.prototype.addFeatureCollection = function (featureCollection) {
    // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
    if (featureCollection == null) {
      throw new ReferenceError("Error, featureCollection is null", "GeoJsonLayer.js");
    }

    var defaultCrs = {
      type: "name",
      properties: {
        name: Constants.CRS.WGS84
      }
    }; //check if crs is global at the featureCollection

    var crs = featureCollection.crs ? featureCollection.crs : defaultCrs;
    var features = featureCollection.features;

    if (features) {
      var bbox = [Number.MAX_VALUE, Number.MAX_VALUE, -1 * Number.MAX_VALUE, -1 * Number.MAX_VALUE];

      for (var i = 0; i < features.length; i++) {
        this.addFeature(features[i], crs);
        var tmpBox = Utils.getBBox(features[i].geometry);
        bbox[0] = Math.min(bbox[0], tmpBox.west);
        bbox[1] = Math.min(bbox[1], tmpBox.south);
        bbox[2] = Math.max(bbox[2], tmpBox.east);
        bbox[3] = Math.max(bbox[3], tmpBox.north);
      } // When there is an altitude for a geometry type as point, set this option to make possible
      // intersection algorithm


      if (_hasPointAltitude(features[0].geometry)) {
        this.pickingNoDEM = true;
      }

      this.options.properties = {
        bbox: bbox,
        initialRa: (bbox[0] + bbox[2]) * 0.5,
        initialDec: (bbox[1] + bbox[3]) * 0.5
      };
      this.properties = this.options.properties;
    }
  };
  /**
   * Set data type of the GeoJSON : Point or LineString
   * @param feature
   * @memberof GeoJsonLayer#
   * @private
   */


  GeoJsonLayer.prototype._setDataType = function (feature) {
    if (!this.datatype) {
      if (feature.geometry.type.startsWith(Constants.GEOMETRY.Point)) {
        this.dataType = Constants.GEOMETRY.Point;
      } else {
        this.dataType = Constants.GEOMETRY.LineString;
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a feature to the layer
   * @function addFeature
   * @memberof GeoJsonLayer.prototype
   * @param {GeoJSON} feature Feature
   */


  GeoJsonLayer.prototype.addFeature = function (feature, globalCrs) {
    //feature.properties.style = this.style;
    _checkValidGeoJson.call(this, feature);

    feature = _setCrs.call(this, feature, globalCrs);
    feature = _setID.call(this, feature);

    this._setDataType(feature);

    AbstractVectorLayer.prototype.addFeature.call(this, feature);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name OpenSearchRequestPool
   * @class
   * This class manages the request pool of OpenSearch
   * @memberof module:Layer
   */

  var OpenSearchRequestPool = function () {
    this.maxRunningRequests = 4;
    this.maxPoolingRequests = 50; // Running requests

    this.runningRequests = []; // Atomic management when reseting

    this.resetMode = false; // Pooling requests

    this.freeRequests = [];
    this.poolingRequests = [];
    this.awaitingRequests = [];
    this.layers = []; // Build all free requests

    for (var i = 0; i < this.maxPoolingRequests; i++) {
      var xhr = new XMLHttpRequest();
      xhr.numRequest = i;
      this.freeRequests.push(xhr);
    }

    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[New] " + this.getPoolsStatus());
  };
  /**************************************************************************************************************/

  /**
   * Return the pool status
   * @function getPoolStatus
   * @memberof OpenSearchRequestPool#
   * @return {string} Pool status
   */


  OpenSearchRequestPool.prototype.getPoolsStatus = function () {
    var message = "";
    message += "Run : " + this.runningRequests.length + "/" + this.maxRunningRequests + " , ";
    message += "Wait : " + this.poolingRequests.length + "/" + this.maxPoolingRequests;
    return message;
  };
  /**************************************************************************************************************/

  /**
   * Get a free request
   * @function getFreeRequest
   * @memberof OpenSearchRequestPool#
   * @return {Object} Free request
   */


  OpenSearchRequestPool.prototype.getFreeRequest = function () {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[getFreeRequest]");

    if (this.freeRequests.length === 0) {
      // Take oldest request in pool and use it
      var xhr = this.poolingRequests.splice(0, 1)[0];
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "Oldest pooling request cancel and reused");
      return xhr;
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "Take one request from pool");
      return this.freeRequests.pop();
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a query to the pool
   *  Note : Query is ALWAYS ADDED at the end of the pool, the it's a FILO queue
   * @function addQuery
   * @memberof OpenSearchRequestPool#
   * @param {string} url Url query to get
   * @param {Tile} tile Tile associated with the query
   * @param {Layer} layer
   */


  OpenSearchRequestPool.prototype.addQuery = function (url, tile, layer) {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[addQuery]");

    if (this.resetMode === true) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "addQuery halt, reset mode");
      return;
    }

    var key = tile.getKey(); // Add layer to list

    if (typeof this.layers[layer.getID()] === "undefined") {
      this.layers[layer.getID()] = layer;
    } // First check if query is style wanted


    if (this.isQueryStillWanted(key, layer.getID(), url)) {
      // Query still in pool or running, so do not add it again
      return;
    } // get query slot


    var xhr = this.getFreeRequest(); // set value for managing

    var self = this; // Associate the key

    xhr.key = key;
    xhr.layer = layer;
    xhr.url = url; // The server sometimes times out (e.g. too many requests)
    // In this case, finish the request and retry later.

    xhr.ontimeout = function () {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSeachRequestPool", "Server Timeout, resend later");
      self.manageFinishedRequest(xhr);
      self.poolingRequests.push(xhr);
    };

    xhr.onabort = function () {
      ErrorDialog.open(Constants.LEVEL.ERROR, "OpenSearchRequestPool", "Request aborted");
      self.manageFinishedRequest(xhr);
    };

    xhr.onerror = function () {
      ErrorDialog.open(Constants.LEVEL.ERROR, "OpenSearchRequestPool", "Request error: " + xhr.status);
      self.manageFinishedRequest(xhr);
    };

    xhr.onload = function () {
      if (xhr.status === 200 && xhr.response !== null) {
        const response = JSON.parse(xhr.response);
        var nbFeaturesTotalPerTile = response.properties.totalResults; //TODO cache : degrade resolution
        //xhr.layer.cache.storeInCache(url, response.features, nbFeaturesTotalPerTile);

        xhr.layer.computeFeaturesResponse(response.features, tile, nbFeaturesTotalPerTile);
      } else if (xhr.status >= 400) {
        //tileData.complete = true;
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", xhr.responseText);
        return;
      }

      self.manageFinishedRequest(xhr);
    };

    xhr.open("GET", Proxy.proxify(url));
    xhr.setRequestHeader("Accept", "application/json"); // Add request to pooling (last position)

    this.poolingRequests.push(xhr); // Check if request can be done

    this.checkPool();
  };
  /**
   * Check for each layer if there is remaining load needed
   * Check if there is any remaining query in the pool
   * @function checkPool
   * @memberof OpenSearchRequestPool#
   */


  OpenSearchRequestPool.prototype.checkEachLayerFinished = function () {
    for (var key in this.layers) {
      var current = this.layers[key];

      for (var i = 0; i < this.runningRequests.length; i++) {
        if (typeof this.runningRequests[i].layer !== "undefined" && this.runningRequests[i].layer.getID() === key) {
          return;
        }
      }

      for (i = 0; i < this.poolingRequests.length; i++) {
        if (typeof this.poolingRequests[i].layer !== "undefined" && this.poolingRequests[i].layer.getID() === key) {
          return;
        }
      } // no request running, stop ihm indicator


      current.getGlobe().publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, current);
    }
  };
  /**************************************************************************************************************/

  /**
   * Check if there is any remaining query in the pool
   * @function checkPool
   * @memberof OpenSearchRequestPool#
   */


  OpenSearchRequestPool.prototype.checkPool = function () {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[checkPool]" + this.getPoolsStatus());

    if (this.resetMode === true) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "checkPool halt, reset mode");
      return;
    }

    if (this.runningRequests.length === this.maxRunningRequests) {
      // Running pool is full, wait for a free slot
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "no running slot available, wait");
      return;
    }

    this.checkEachLayerFinished(); // There is at least one slot free

    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "before : " + this.getPoolsStatus()); // Remove it from pool

    var xhr = this.poolingRequests.pop();

    if (typeof xhr !== "undefined") {
      // Place it into running
      this.runningRequests.push(xhr); // Start ihm indicator

      xhr.layer.getGlobe().publishEvent(Constants.EVENT_MSG.LAYER_START_LOAD, xhr.layer); // Launch request

      xhr.send();
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "after : " + this.getPoolsStatus()); // check for another request

      this.checkPool();
    }
  };
  /**************************************************************************************************************/

  /**
   * Manage data returned by a query
   * @function manageFinishedRequest
   * @memberof OpenSearchRequestPool#
   * @param {Object} xhr Query
   */


  OpenSearchRequestPool.prototype.manageFinishedRequest = function (xhr) {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[manageFinishedRequest]");

    if (this.resetMode === true) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "manageFinishedRequest halt, reset mode");
      return;
    }

    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "before : " + this.getPoolsStatus()); // Get index of ended request

    var index = -1;

    for (var i = 0; i < this.runningRequests.length; i++) {
      if (this.runningRequests[i].numRequest === xhr.numRequest) {
        index = i;
      }
    } // Remove the query


    if (index >= -1) {
      this.runningRequests.splice(index, 1);
    } // Set it into pool


    this.freeRequests.push(xhr);
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "after : " + this.getPoolsStatus());
    this.checkPool();
  };
  /**************************************************************************************************************/

  /**
   * Check if query (based on bound) is still wanted (in pool or running)
   * @function isQueryStillWanted
   * @memberof OpenSearchRequestPool#
   * @param {string} key Key of the query
   * @return {Boolean} true if query is still in pool
   */


  OpenSearchRequestPool.prototype.isQueryStillWanted = function (key, layerID, url) {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[isQueryStillWanted]");

    for (var i = 0; i < this.runningRequests.length; i++) {
      // Recheck if runningRequests is modified outside
      if (typeof this.runningRequests[i] !== "undefined" && this.runningRequests[i].key === key && this.runningRequests[i].layer.getID() === layerID && this.runningRequests[i].url === url) {
        return true;
      }
    }

    for (i = 0; i < this.poolingRequests.length; i++) {
      // Recheck if poolingRequests is modified outside
      if (typeof this.poolingRequests[i] !== "undefined" && this.poolingRequests[i].key === key && this.poolingRequests[i].url === url) {
        return true;
      }
    }

    return false;
  };
  /**************************************************************************************************************/

  /**
   * Reset the pool
   * @function reset
   * @memberof OpenSearchRequestPool#
   */


  OpenSearchRequestPool.prototype.resetPool = function () {
    this.resetMode = true;
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[resetPool]");
    this.removeRunningQueries();
    this.removePoolQueries();
    this.resetMode = false;
  };
  /**************************************************************************************************************/

  /**
   * Remove running queries
   * @function removeRunningQueries
   * @memberof OpenSearchRequestPool#
   */


  OpenSearchRequestPool.prototype.removeRunningQueries = function () {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[removeRunningQueries]");
    var xhr = this.runningRequests.pop();

    while (xhr !== null && typeof xhr !== "undefined") {
      xhr.abort();
      this.freeRequests.push(xhr);
      xhr = this.runningRequests.pop();
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove pool queries
   * @function removePoolQueries
   * @memberof OpenSearchRequestPool#
   */


  OpenSearchRequestPool.prototype.removePoolQueries = function () {
    ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRequestPool", "[removePoolQueries]");
    var xhr = this.poolingRequests.pop();

    while (xhr !== null && typeof xhr !== "undefined") {
      this.freeRequests.push(xhr);
      xhr = this.poolingRequests.pop();
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const openSearchRequestPool = new OpenSearchRequestPool();

  function createHips(hipsMetadata, options) {
    var hipsProperties;

    if (typeof hipsMetadata === "undefined") {
      hipsProperties = new HipsMetadata(options.baseUrl);
    } else if (hipsMetadata instanceof HipsMetadata) {
      hipsProperties = hipsMetadata;
    } else {
      hipsProperties = new HipsMetadata();
      hipsProperties.setMetadata(hipsMetadata);
    }

    var metadata = hipsProperties.getHipsMetadata();
    var formats = options.hasOwnProperty("hips_tile_format") ? options.hips_tile_format : metadata.hips_tile_format;
    var dataProducts = options.hasOwnProperty("dataproduct_type") ? options.dataproduct_type : metadata.dataproduct_type;
    var layer;

    switch (dataProducts) {
      case hipsProperties.DataProductType.catalog:
        layer = createHipsCats(metadata, options);
        break;

      case hipsProperties.DataProductType.cube:
        throw new RangeError("LayerFactor.js: Hips : cannot handle cube dataproduct");

      case hipsProperties.DataProductType.image:
        options.category = options.hasOwnProperty("category") ? options.category : "Image";
        var hasPNG = $__default['default'].inArray(hipsProperties.HipsTileFormat.png, formats) !== -1;
        var hasJPEG = $__default['default'].inArray(hipsProperties.HipsTileFormat.jpeg, formats) !== -1;
        var hasFits = $__default['default'].inArray(hipsProperties.HipsTileFormat.fits, formats) !== -1;

        if (options.format) {
          switch (options.format) {
            case hipsProperties.HipsTileFormat.png:
              layer = createHipsGraphic(metadata, options);
              break;

            case "jpg":
              layer = createHipsGraphic(metadata, options);
              break;

            case hipsProperties.HipsTileFormat.fits:
              layer = createHipsFits(metadata, options);
              break;

            default:
              // try to get one by default => try jpeg ... maybe I am lucky
              layer = createHipsGraphic(metadata, options);
          }
        } else {
          if (hasPNG) {
            options.format = hipsProperties.HipsTileFormat.png;
            layer = createHipsGraphic(metadata, options);
          } else if (hasJPEG) {
            options.format = "jpg"; // the right extension should be "jpeg" but jpg is used

            layer = createHipsGraphic(metadata, options);
          } else if (hasFits) {
            options.format = hipsProperties.HipsTileFormat.fits;
            layer = createHipsFits(metadata, options);
          } else {
            // try to get one by default => it happens for old Hips version ... maybe I am lucky
            options.format = "jpg";
            layer = createHipsGraphic(metadata, options);
          }
        }

        break;

      case hipsProperties.DataProductType.meta:
        throw new RangeError("LayerFactor.js: Hips : cannot handle META dataproduct");

      default:
        throw new RangeError("LayerFactor.js: Hips : Unknown dataproduct type");
    } //if(fileExists(options.baseUrl+"/Moc.fits") === 200) {
    //    options.serviceUrl = options.baseUrl+"/Moc.fits";
    //    layer.services.push(this.createMoc(options));
    //}


    return layer;
  }

  function createHipsFits(hipsMetadata, options) {
    return new HipsFitsLayer(hipsMetadata, options);
  }

  function createHipsGraphic(hipsMetadata, options) {
    return new HipsGraphicLayer(hipsMetadata, options);
  }

  function createHipsCats(hipsMetadata, options) {
    return new HipsCatLayer(hipsMetadata, options);
  }
  /**
       Create and get a MOC Layer
       @function createMoc
       @private
       @memberof LayerFactory.prototype
       @param options Configuration properties for the MOC layer. See {@link MocLayer} for properties
       @return {MocLayer} layer
       */


  function createMoc(options) {
    options.style.fill = true;
    options.style.fillColor[3] = 0.3; // make transparent

    var layer = new MocLayer(options);
    layer.dataType = "line";
    return layer;
  }
  /**
       Create and get an OpenSearch Layer
       @function createOpenSearch
       @private
       @memberof LayerFactory.prototype
       @param options Configuration properties for the OpenSearch layer. See {@link OpenSearchLayer} for properties
       @return {OpenSearchLayer} layer
       */


  function createOpenSearch(options) {
    options.openSearchRequestPool = openSearchRequestPool;
    var layer = new OpenSearchLayer(options);

    if (options.displayProperties) {
      layer.displayProperties = options.displayProperties;
    }

    layer.pickable = options.hasOwnProperty("pickable") ? options.pickable : true;
    return layer;
  }

  var LayerFactory = {
    /**
     * Factory for Layer.
     * @param {Object} options - See the base properties {@link AbstractLayer.configuration} and specific properties for specific layers
     * @param {string} options.type - one of the following value {@link LAYER}
     * @return {AbstractLayer} - Object to handle Layer
     * @alias module:Layer.LayerFactory.create
     * @throws RangeError - "Unable to create the layer"
     * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
     * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
     * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
     * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
     * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
     * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
     * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
     * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
     * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
     * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
     * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
     * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
     * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
     * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.AsynchroneWMSLayer AsynchroneWMSLayer} : A layer to draw images coming from the WMS server (asynchrone loading to manage GetCapabilities)
     * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
     * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
     */
    create: function (options) {
      var layer;

      switch (options.type) {
        case Constants.LAYER.WMS:
          layer = new WMSLayer(options);
          break;

        case Constants.LAYER.WMTS:
          layer = new WMTSLayer(options);
          break;

        case Constants.LAYER.WMSElevation:
          layer = new WMSElevationLayer(options);
          break;

        case Constants.LAYER.WCSElevation:
          layer = new WCSElevationLayer(options);
          break;

        case Constants.LAYER.GeoJSON:
          layer = new GeoJsonLayer(options);
          layer.pickable = options.hasOwnProperty("pickable") ? options.pickable : true;
          break;

        case Constants.LAYER.Vector:
          layer = new VectorLayer(options);
          layer.pickable = options.hasOwnProperty("pickable") ? options.pickable : true;
          layer.deletable = options.hasOwnProperty("deletable") ? options.deletable : false;
          break;

        case Constants.LAYER.Atmosphere:
          layer = new AtmosphereLayer(options);
          break;

        case Constants.LAYER.Bing:
          layer = new BingLayer(options);
          break;

        case Constants.LAYER.GroundOverlay:
          layer = new GroundOverlayLayer(options);
          break;

        case Constants.LAYER.OSM:
          layer = new OSMLayer(options);
          break;

        case Constants.LAYER.HipsGrid:
        case Constants.LAYER.TileWireframe:
          layer = new TileWireframeLayer(options);
          break;

        case Constants.LAYER.HipsCat:
          layer = new HipsCatLayer(options.hipsMetadata, options);
          break;

        case Constants.LAYER.CoordinateGrid:
          layer = new CoordinateGridLayer(options);
          break;

        case Constants.LAYER.Hips:
          layer = createHips(options.hipsMetadata, options);
          break;

        case Constants.LAYER.Moc:
          layer = createMoc(options);
          break;

        case Constants.LAYER.OpenSearch:
          layer = createOpenSearch(options);
          break;

        default:
          throw new RangeError("LayerFactor.js: Unable to create the layer " + options.type);
      }

      return layer;
    }
  };

  /*
   BSD-2-Clause
   @preserve
  */

  var wmsCapabilities_min = createCommonjsModule(function (module, exports) {
  (function(f,m){module.exports=m();})(commonjsGlobal,function(){function f(a){return void 0!==a}function m(a,c,b){if(a.nodeType===u.CDATA_SECTION||a.nodeType===u.TEXT)c?b.push(String(a.nodeValue).replace(/(\r\n|\r|\n)/g,"")):b.push(a.nodeValue);else for(a=a.firstChild;a;a=a.nextSibling)m(a,c,b);return b}function F(a){for(a=a.nextElementSibling||a.nextSibling;a&&
  a.nodeType!==u.ELEMENT;)a=a.nextSibling;return a}function h(a,c,b){b=f(b)?b:{};var d;var n=0;for(d=a.length;n<d;++n)b[a[n]]=c;return b}function A(a,c){return function(b,d){b=a.call(f(c)?c:this,b,d);f(b)&&d[d.length-1].push(b);}}function l(a,c,b,d,e){d.push(a);for(a=b.firstElementChild||b.firstChild;a&&a.nodeType!==u.ELEMENT;)a=a.nextSibling;for(;a;a=F(a))b=c[a.namespaceURI||null],f(b)&&(b=b[a.localName],f(b)&&b.call(e,a,d));return d.pop()}function b(a,c,b){return function(d,e){var n=a.call(f(b)?b:
  this,d,e);f(n)&&(e=e[e.length-1],d=f(c)?c:d.localName,e[d]=n);}}function k(a,c,b){return function(d,e){var n=a.call(f(b)?b:this,d,e);if(f(n)){e=e[e.length-1];d=f(c)?c:d.localName;var g=[];(d in e?e[d]:e[d]=g).push(n);}}}function r(a){if(a=/^\s*(true|1)|(false|0)\s*$/.exec(a))return f(a[1])||!1}function t(a){return p(m(a,!1,[]).join(""))}function p(a){if(a=/^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(a))return parseFloat(a[1])}function w(a){return v(m(a,!1,[]).join(""))}function v(a){if(a=/^\s*(\d+)\s*$/.exec(a))return parseInt(a[1],
  10)}function e(a){return m(a,!1,[]).join("").replace(G,"")}function x(a){return a.getAttributeNS("http://www.w3.org/1999/xlink","href")}function B(a){return [p(a.getAttribute("minx")),p(a.getAttribute("miny")),p(a.getAttribute("maxx")),p(a.getAttribute("maxy"))]}function q(a,c){return l({},H,a,c)}function y(a,c){return l({},I,a,c)}function C(a,c){c=q(a,c);if(f(c))return a=[v(a.getAttribute("width")),v(a.getAttribute("height"))],c.size=a,c}function D(a,c){return l([],J,a,c)}var u={ELEMENT:1,ATTRIBUTE:2,
  TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12},z=function(a){this._parser=new a;};z.prototype.toDocument=function(a){return this._parser.parseFromString(a,"application/xml")};z.prototype.getAllTextContent=function(a,c){return m(a,c,[]).join("").join("")};var G=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,g=[null,"http://www.opengis.net/wms"],M=h(g,{Service:b(function(a,c){return l({},K,a,c)}),Capability:b(function(a,
  c){return l({},L,a,c)})}),L=h(g,{Request:b(function(a,c){return l({},N,a,c)}),Exception:b(function(a,c){return l([],O,a,c)}),Layer:b(function(a,c){var b=r(a.getAttribute("queryable"));return l({queryable:f(b)?b:!1},E,a,c)})}),K=h(g,{Name:b(e),Title:b(e),Abstract:b(e),KeywordList:b(D),OnlineResource:b(x),ContactInformation:b(function(a,c){return l({},P,a,c)}),Fees:b(e),AccessConstraints:b(e),LayerLimit:b(w),MaxWidth:b(w),MaxHeight:b(w)}),P=h(g,{ContactPersonPrimary:b(function(a,c){return l({},Q,a,
  c)}),ContactPosition:b(e),ContactAddress:b(function(a,c){return l({},R,a,c)}),ContactVoiceTelephone:b(e),ContactFacsimileTelephone:b(e),ContactElectronicMailAddress:b(e)}),Q=h(g,{ContactPerson:b(e),ContactOrganization:b(e)}),R=h(g,{AddressType:b(e),Address:b(e),City:b(e),StateOrProvince:b(e),PostCode:b(e),Country:b(e)}),O=h(g,{Format:A(e)}),E=h(g,{Name:b(e),Title:b(e),Abstract:b(e),KeywordList:b(D),CRS:k(e),SRS:k(e),EX_GeographicBoundingBox:b(function(a,c){var b=l({},S,a,c);if(f(b)){a=b.westBoundLongitude;
  c=b.southBoundLatitude;var d=b.eastBoundLongitude;b=b.northBoundLatitude;if(f(a)&&f(c)&&f(d)&&f(b))return [a,c,d,b]}}),LatLonBoundingBox:b(function(a,b){a=B(a);if(f(a[0])&&f(a[1])&&f(a[2])&&f(a[3]))return a}),BoundingBox:k(function(a,b){b=B(a);var c=[p(a.getAttribute("resx")),p(a.getAttribute("resy"))];return {crs:a.getAttribute("CRS")||a.getAttribute("SRS"),extent:b,res:c}}),Dimension:k(function(a,b){return {name:a.getAttribute("name"),units:a.getAttribute("units"),unitSymbol:a.getAttribute("unitSymbol"),
  "default":a.getAttribute("default"),multipleValues:r(a.getAttribute("multipleValues")),nearestValue:r(a.getAttribute("nearestValue")),current:r(a.getAttribute("current")),values:e(a)}}),Attribution:b(function(a,b){return l({},T,a,b)}),AuthorityURL:k(function(a,b){b=q(a,b);if(f(b))return b.name=a.getAttribute("name"),b}),Identifier:k(e),MetadataURL:k(function(a,b){b=q(a,b);if(f(b))return b.type=a.getAttribute("type"),b}),DataURL:k(q),FeatureListURL:k(q),Style:k(function(a,b){return l({},U,a,b)}),MinScaleDenominator:b(t),
  MaxScaleDenominator:b(t),ScaleHint:b(function(a,b){b=parseFloat(a.getAttribute("min"));a=parseFloat(a.getAttribute("max"));return {min:b,max:a}}),Layer:k(function(a,b){var c=b[b.length-1];b=l({},E,a,b);if(f(b)){var d=r(a.getAttribute("queryable"));f(d)||(d=c.queryable);b.queryable=f(d)?d:!1;d=v(a.getAttribute("cascaded"));f(d)||(d=c.cascaded);b.cascaded=d;d=r(a.getAttribute("opaque"));f(d)||(d=c.opaque);b.opaque=f(d)?d:!1;d=r(a.getAttribute("noSubsets"));f(d)||(d=c.noSubsets);b.noSubsets=f(d)?d:!1;
  d=p(a.getAttribute("fixedWidth"));f(d)||(d=c.fixedWidth);b.fixedWidth=d;a=p(a.getAttribute("fixedHeight"));f(a)||(a=c.fixedHeight);b.fixedHeight=a;a=["Style","CRS","AuthorityURL"];d=0;for(var e=a.length;d<e;d++){var g=a[d],h=c[g];if(f(h)){var k=[];k=g in b?b[g]:b[g]=k;k=k.concat(h);b[g]=k;}}a="EX_GeographicBoundingBox BoundingBox Dimension Attribution MinScaleDenominator MaxScaleDenominator".split(" ");d=0;for(e=a.length;d<e;d++)g=a[d],f(b[g])||(b[g]=c[g]);return b}})}),T=h(g,{Title:b(e),OnlineResource:b(x),
  LogoURL:b(C)}),S=h(g,{westBoundLongitude:b(t),eastBoundLongitude:b(t),southBoundLatitude:b(t),northBoundLatitude:b(t)}),N=h(g,{GetCapabilities:b(y),GetMap:b(y),GetFeatureInfo:b(y)}),I=h(g,{Format:k(e),DCPType:k(function(a,b){return l({},V,a,b)})}),V=h(g,{HTTP:b(function(a,b){return l({},W,a,b)})}),W=h(g,{Get:b(q),Post:b(q)}),U=h(g,{Name:b(e),Title:b(e),Abstract:b(e),LegendURL:k(C),StyleSheetURL:b(q),StyleURL:b(q)}),H=h(g,{Format:b(e),OnlineResource:b(x)}),J=h(g,{Keyword:A(e)});g=function(a,b){b||
  "undefined"===typeof window||(b=window.DOMParser);this.version=void 0;this._parser=new z(b);this._data=a;};g.prototype.data=function(a){this._data=a;return this};g.prototype.toJSON=function(a){a=a||this._data;return this.parse(a)};g.prototype.parse=function(a){return this._readFromDocument(this._parser.toDocument(a))};g.prototype._readFromDocument=function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType==u.ELEMENT)return this.readFromNode(a);return null};g.prototype.readFromNode=function(a){this.version=
  a.getAttribute("version");return l({version:this.version},M,a,[])||null};return g});
  //# sourceMappingURL=wms-capabilities.min.js.map
  });

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates an instance of WMS server
   * A WMS server exposes a set of {@link WMSLayer WMS} layers.
   * @param {Options} options Options
   * @param {string} [options.baseUrl] Base URL of the getCapabilities
   * @param {string} [options.getCapabilities] GetCapabilities
   * @memberof module:Registry
   * @constructor
   */

  var WMSServer = function (options) {
    if (options.getCapabilities) {
      options.baseUrl = Utils.computeBaseUrlFromCapabilities(options.getCapabilities, ["service", "request", "version"]);
    } else if (options.baseUrl) {
      options.getCapabilities = WMSServer.getCapabilitiesFromBaseURl(options.baseUrl, options);
    } else {
      throw new ReferenceError("No URL to access to the server is defined", "WMSLayer.js");
    }

    this.options = options;
  };
  /**
   * Skip when the current layer is not included in the list of defined layers (layersFromConf)
   * @param {string[]} layersFromConf List of user-defined layer
   * @param {string} currentLayer
   * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
   * @function _mustBeSkipped
   * @memberof WMSServer#
   * @private
   */


  function _mustBeSkipped(layersFromConf, currentLayerName) {
    return layersFromConf.length !== 0 && !_$1.contains(layersFromConf, currentLayerName);
  }
  /**
   * Capabilities has a group ?
   * @param {string} jsonLayer layer
   * @returns  {boolean} true when layers are grouped otherwise false
   * @function _hasGroup
   * @memberof WMSServer#
   * @private
   */


  function _hasGroup(jsonLayer) {
    return Array.isArray(jsonLayer.Layer);
  }
  /**
   * Computes attribution from capabilities
   * @param {string} layerDescription User-defined layer description
   * @param {string} jsonLayers Metadata on the layers
   * @param {string} jsonLayer layer description from capabilities
   * @function _computeAttribution
   * @memberof WMSServer#
   * @private
   */


  function _computeAttribution(layerDescription, jsonLayers, jsonLayer) {
    var attribution, logo, title;

    if (layerDescription.attribution) {
      attribution = layerDescription.attribution;
    } else if (jsonLayer.Attribution != null) {
      logo = jsonLayer.Attribution.LogoURL != null ? "<img src='" + jsonLayer.Attribution.LogoURL.OnlineResource + "' height='25px'/> " : "";
      title = jsonLayer.Attribution.Title != null ? jsonLayer.Attribution.Title : "";
      attribution = logo + title;
    } else if (jsonLayers.Attribution != null) {
      logo = jsonLayers.Attribution.LogoURL != null ? "<img src='" + jsonLayers.Attribution.LogoURL.OnlineResource + "' height='25px'/> " : "";
      title = jsonLayers.Attribution.Title != null ? jsonLayers.Attribution.Title : "";
      attribution = logo + title;
    } else {
      attribution = null;
    }

    return attribution;
  }
  /**
   * Computes copyright
   * @param {string} layerDescription User-defined layer description
   * @param {string} jsonLayers Metadata on the layers
   * @param {string} jsonLayer layer description from capabilities
   * @function _computeCopyrightURL
   * @memberof WMSServer#
   * @private
   */


  function _computeCopyrightURL(layerDescription, jsonLayers, jsonLayer) {
    var copyrightURL;

    if (layerDescription.copyrightUrl) {
      copyrightURL = layerDescription.copyrightUrl;
    } else if (jsonLayer.Attribution != null) {
      copyrightURL = jsonLayer.Attribution.OnlineResource != null ? jsonLayer.Attribution.OnlineResource : "";
    } else if (jsonLayers.Attribution != null) {
      copyrightURL = jsonLayers.Attribution.OnlineResource != null ? jsonLayers.Attribution.OnlineResource : "";
    } else {
      copyrightURL = "";
    }

    return copyrightURL;
  }
  /**
   * Computes the bbox center.
   * if bbox is null then center is defined as [0,0, 100000]
   * @param {bbox_type|null} bbox
   * @returns {center_type} the central position of the camera and the distance from which the bbox is embedded
   * @function _computeCenterBbox
   * @memberof WMSServer#
   * @private
   */


  function _computeCenterBbox(bbox) {
    var centerLong = 0.5 * (bbox[0] + bbox[2]);
    var centerLat = 0.5 * (bbox[1] + bbox[3]);
    return [centerLong, centerLat];
  }
  /**
   * Converts a bbox string to an array of float.
   * @param {string[]} jsonBbox. bbox as string. First element is the lower left corner. 2nd element is the upper right corner
   * @returns {bbox_type} bbox as an array
   * @function _bbox
   * @memberof WMSServer#
   * @private
   */


  function _bbox(jsonLayer) {
    var bbox = jsonLayer.EX_GeographicBoundingBox;
    var result;

    if (bbox == null) {
      result = [-180, -90, 180, 90];
    } else {
      var long1 = bbox[0] > 180 ? bbox[0] - 360 : bbox[0];
      var long2 = bbox[2] > 180 ? bbox[2] - 360 : bbox[2];
      result = [long1, bbox[1], long2, bbox[3]];
    }

    return result;
  }
  /**
   * Boox for grouped layer
   * @param {string} jsonLayer layer from capabilities
   * @returns  {bbox_type} bbox as an array
   * @function _bboxGroup
   * @memberof WMSServer#
   * @private
   */


  function _bboxGroup(jsonLayer) {
    var result;

    if (_hasGroup.call(this, jsonLayer)) {
      var layer, layerBbox;
      var minLong = 180,
          maxLong = -180,
          minLat = 90,
          maxLat = -90;

      for (var i = 0; i < jsonLayer.Layer.length; i++) {
        layer = jsonLayer.Layer[i];
        layerBbox = _bbox.call(this, layer);
        minLong = Math.min(minLong, layerBbox[0]);
        minLat = Math.min(minLat, layerBbox[1]);
        maxLong = Math.max(maxLong, layerBbox[2]);
        maxLat = Math.max(maxLat, layerBbox[3]);
      }

      result = [minLong, minLat, maxLong, maxLat];
    } else {
      result = _bbox.call(this, jsonLayer);
    }

    return result;
  }
  /**
   * Returns the metadata
   * @param {metadata~requestCallback} callback
   * @param {serverLayerFallback} fallback
   * @function getMetadata
   * @memberof WMSServer#
   */


  WMSServer.prototype.getMetadata = function (callback, fallback) {
    var self = this;
    Utils.requestUrl(this.options.getCapabilities, "text", "application/xml", {}, function (response) {
      var metadata = new wmsCapabilities_min().parse(response);
      callback(self.options, metadata);
    }, function (e) {
      if (fallback) {
        e.setLayerDescription(self.options);
        fallback(e);
      }
    });
  };
  /**
   * The dimension.
   * @typedef {Object} dimension_type
   * @property {string} units - Units of the dimension.
   * @property {string} unitSymbol - Unit symbol.
   * @property {string} default - default value.
   * @property {string} multipleValues - multiples values.
   * @property {string} nearestValue - nearest vlaue.
   * @property {string} value - value.
   */

  /**
   * Parses the dimension from capabilities
   * @param {Array.<dimension_type>} dimension
   * @returns {{}} a hash of name => dimension
   * @function _parseDimension
   * @memberof WMSServer#
   * @private
   */


  function _parseDimension(dimension) {
    if (dimension == null) {
      return null;
    }

    var dim = {};

    for (var i = 0; i < dimension.length; i++) {
      var currentDim = dimension[i];
      var myDim = {
        units: currentDim.units,
        unitSymbol: currentDim.unitSymbol,
        default: currentDim.default,
        multipleValues: currentDim.multipleValues,
        nearestValue: currentDim.nearestValue,
        value: currentDim.values
      };
      dim[currentDim.name] = myDim;
    }

    return dim;
  }
  /**
   * Create a layer
   * @param {*} layerDescription
   * @param {*} jsonLayers
   * @param {*} jsonLayer
   * @returns {Layer} the layer
   * @function _createLayer
   * @memberof WMSServer#
   * @private
   */


  function _createLayer(layerDescription, jsonLayers, jsonLayer) {
    var attribution = [];

    if (_hasGroup.call(this, jsonLayer)) {
      for (var i = 0; i < jsonLayer.Layer.length; i++) {
        var layer = jsonLayer.Layer[i];
        attribution.push(_computeAttribution.call(this, layerDescription, jsonLayers, layer));
      }
    } else {
      attribution.push(_computeAttribution.call(this, layerDescription, jsonLayers, jsonLayer));
    }

    var copyrightURL = _computeCopyrightURL.call(this, layerDescription, jsonLayers, jsonLayer);

    var bbox = _bboxGroup.call(this, jsonLayer);

    var center = _computeCenterBbox.call(this, bbox);

    var layerDesc = Object.assign({}, layerDescription, {});
    layerDesc.name = layerDescription.name || jsonLayer.Title;
    layerDesc.format = layerDescription.format || "image/png";
    layerDesc.layers = jsonLayer.Name;
    layerDesc.description = layerDescription.description || jsonLayer.Abstract != null ? jsonLayer.Abstract : jsonLayers.Abstract;
    layerDesc.attribution = attribution.join("<br/>");
    layerDesc.copyrightUrl = copyrightURL;
    layerDesc.autoFillTimeTravel = layerDescription.autoFillTimeTravel;
    layerDesc.properties = {
      initialRa: center[0],
      initialDec: center[1],
      bbox: bbox
    };
    layerDesc.dimension = _parseDimension.call(this, jsonLayer.Dimension);
    layerDesc.metadataAPI = jsonLayer;
    return LayerFactory.create(layerDesc);
  }
  /**
   * Create layers
   * @param {*} layerDescription
   * @param {*} layersFromConf
   * @param {*} jsonLayers
   * @function _createLayers
   * @memberof WMSServer#
   * @private
   */


  function _createLayers(layerDescription, layersFromConf, jsonLayers) {
    var layers = [];

    for (var i = 0; i < jsonLayers.Layer.length; i++) {
      var jsonLayer = jsonLayers.Layer[i];

      if (jsonLayer.Layer != null) {
        layers = layers.concat(_createLayers(layerDescription, layersFromConf, jsonLayer));
      }

      if (_mustBeSkipped.call(this, layersFromConf, jsonLayer.Name)) {
        continue;
      }

      layers.push(_createLayer.call(this, layerDescription, jsonLayers, jsonLayer));
    }

    return layers;
  }
  /**
   * Create WMS layers from WMS capabilities
   * @param {serverLayerCallback} callback
   * @param {serverLayerFallback} fallback
   * @function createLayers
   * @memberof WMSServer#
   */


  WMSServer.prototype.createLayers = function (callback, fallback) {
    this.getMetadata(function (layerDescription, metadata) {
      var layersFromConf = layerDescription.hasOwnProperty("layers") ? layerDescription.layers.trim().split(/\s*,\s*/) : [];
      var jsonLayers = metadata.Capability.Layer;

      var layers = _createLayers(layerDescription, layersFromConf, jsonLayers);

      callback(layers);
    }, fallback);
  };

  WMSServer.getXmlFeatureToJson = function (xmlString) {
    var featureResponse = xmlString.trim();
    var responseFeature = Utils.xml2json(featureResponse, "");
    var result = {};

    for (var elt in responseFeature) {
      if (elt.includes("_layer")) {
        var layer = responseFeature[elt];
        var name = layer["gml:name"];
        var layerName = elt.replace("_layer", "");
        var featureInLayerName = elt.replace("_layer", "_feature");
        var featureInLayer = layer[featureInLayerName];
        delete featureInLayer["gml:boundedBy"];
        featureInLayer.description = name;
        result[layerName] = featureInLayer;
      }
    }

    var feature = {
      properties: {}
    };
    feature.properties = result;
    feature.properties.title = "Layer Information";
    return feature;
  };

  WMSServer.getFeatureInfo = function (baseUrl, bbox, layers, options) {
    options = options || {};
    var url = baseUrl;
    url = Utils.addParameterTo(url, "service", "wms");
    url = Utils.addParameterTo(url, "version", "1.3.0");
    url = Utils.addParameterTo(url, "request", "GetFeatureInfo");

    if (options.styles) {
      url = Utils.addParameterTo(url, "styles", options.styles);
    } else {
      url = Utils.addParameterTo(url, "styles", "");
    }

    if (options.styles) {
      url = Utils.addParameterTo(url, "crs", options.crs);
    } else {
      url = Utils.addParameterTo(url, "crs", "CRS:84");
    }

    url = Utils.addParameterTo(url, "layers", layers.join());

    if (options.query_layers) {
      url = Utils.addParameterTo(url, "query_layers", options.query_layers.join());
    } else {
      url = Utils.addParameterTo(url, "query_layers", layers.join());
    }

    if (options.time) {
      url = Utils.addParameterTo(url, "time", options.time);
    }

    if (options.width) {
      url = Utils.addParameterTo(url, "width", options.width);
    } else {
      url = Utils.addParameterTo(url, "width", 3);
    }

    if (options.height) {
      url = Utils.addParameterTo(url, "height", options.height);
    } else {
      url = Utils.addParameterTo(url, "height", 3);
    }

    if (options.x) {
      url = Utils.addParameterTo(url, "x", options.x);
    } else {
      url = Utils.addParameterTo(url, "x", 1);
    }

    if (options.y) {
      url = Utils.addParameterTo(url, "y", options.y);
    } else {
      url = Utils.addParameterTo(url, "y", 1);
    }

    if (options.format) {
      url = Utils.addParameterTo(url, "info_format", options.format);
    } else {
      url = Utils.addParameterTo(url, "info_format", "application/vnd.ogc.gml");
    }

    url = Utils.addParameterTo(url, "bbox", bbox[0] + "," + bbox[1] + "," + bbox[2] + "," + bbox[3]);
    return url;
  };
  /**
   * Returns the capabilities
   * @param {string} baseUrl GetCapabilities URL
   * @param {Object} options
   * @param {string} [options.version = 1.0.0] WCS version
   * @function getCapabilitiesFromBaseURL
   * @memberof WMSServer#
   * @returns {string} describeCoverage URL
   */


  WMSServer.getCapabilitiesFromBaseURl = function (baseUrl, options) {
    var getCapabilitiesUrl = baseUrl;
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "service", "WMS");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "request", "getCapabilities");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "version", options.hasOwnProperty("version") ? options.version : "1.3.0");
    return getCapabilitiesUrl;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   * @name WMSFeatureInfoReverseNameResolver
   * @class
   *   Plugin to access to Default reverse name resolver
   * @augments AbstractReverseNameResolver
   * @param {Context} options - Context
   * @memberof module:ReverseNameResolver
   */

  var WMSFeatureInfoReverseNameResolver = function (options) {
    AbstractReverseNameResolver.prototype.constructor.call(this, options);
  };
  /**
   * Retrieve all visible WMS layers
   * @param {AbstractContext} context
   * @param {double[]} position
   * @returns {Layer[]} layers
   */


  function _getAllVisibleWMSLayer(context, pos) {
    var layersByWMSServer = {};

    for (var i = 0; i < context.getLayers().length; i++) {
      var layer = context.getLayers()[i];
      var bbox = layer.getProperties().bbox;
      var time;

      if (layer.containsDimension("time")) {
        time = Time.parse(layer.time);
      } else {
        time = null;
      }

      if (layer.type === Constants.LAYER.WMS && layer.isVisible() && UtilsIntersection.isValueBetween(pos[0], bbox[0], bbox[2]) && UtilsIntersection.isValueBetween(pos[1], bbox[1], bbox[3]) && (time === null || time !== null && time.isInTimeDefinition(layer.getDimensions().time.value))) {
        var baseUrl = layer.baseUrl;

        if (!layersByWMSServer.hasOwnProperty(baseUrl)) {
          layersByWMSServer[baseUrl] = [];
        }

        layersByWMSServer[baseUrl] = layersByWMSServer[baseUrl].concat(layer.layers.split(","));
      }
    }

    return layersByWMSServer;
  }
  /**
   * Draw area on map based on a coordinate and number of pixels of the rectangle
   * @param {AbstractContext} context
   * @param {float[]} coord - coordinate on the center of the rectangle
   * @param {Array} nbPixels -  of pixels on the map along longitude and latitude
   * @param {Object} resolution - Resolution in degree/pixel along longitude, latitude
   */


  function _drawAreaOnMap(context, coord, nbPixels, resolution) {
    var vectorLayer = LayerFactory.create({
      type: "Vector",
      visible: true
    });
    context.addDraw(vectorLayer);
    var feature = {
      id: "view0",
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [[[-nbPixels[0] * resolution.x + coord[0], -nbPixels[1] * resolution.y + coord[1]], [nbPixels[0] * resolution.x + coord[0], -nbPixels[1] * resolution.y + coord[1]], [nbPixels[0] * resolution.x + coord[0], nbPixels[1] * resolution.y + coord[1]], [-nbPixels[0] * resolution.x + coord[0], nbPixels[1] * resolution.y + coord[1]], [-nbPixels[0] * resolution.x + coord[0], -nbPixels[1] * resolution.y + coord[1]]]]
      }
    };
    vectorLayer.addFeature(feature);
    setTimeout(function () {
      vectorLayer.removeFeature(feature);
    }, 2000);
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractReverseNameResolver, WMSFeatureInfoReverseNameResolver);
  /**************************************************************************************************************/

  /**
   * @function handle
   * @memberof WMSFeatureInfoReverseNameResolver#
   * @param {Object} options
   */

  WMSFeatureInfoReverseNameResolver.prototype.handle = function (options) {
    var pos = options.pos;
    var mizarAPI = options.mizarAPI;
    var ctx = mizarAPI.getActivatedContext();
    var nbPixels = [50, 25];

    var layersByWMSServer = _getAllVisibleWMSLayer.call(this, ctx, pos);

    var featuresInfo = [];
    var start = 0;
    var keys = Object.keys(layersByWMSServer);
    var end = keys.length;

    function getQueryableLayers(url, options) {
      Utils.requestUrl(url, "text", "text/plain", null, function (response) {
        var feature = WMSServer.getXmlFeatureToJson(response);
        feature.properties.title = "Layer Information";
        featuresInfo.push(feature);
        start++;

        if (start < end) {
          url = layersByWMSServer[keys[start]];
          getQueryableLayers(url);
        } else {
          if (options.success) {
            options.success({
              copyright: "MIZAR",
              features: featuresInfo
            });
          }
        }
      }, function (err) {
        if (options && options.error) {
          options.error(err);
        }
      });
    }

    if (pos != null) {
      var renderCtx = ctx.getRenderContext();
      var fov = renderCtx.getFov();
      var distance = ctx.getNavigation().getDistance();
      var x = Math.tan(Numeric.toRadian(fov) * 0.5) * distance;
      var alpha = Numeric.toDegree(Math.asin(0.5 * x / ctx.getCoordinateSystem().getGeoide().getRealPlanetRadius()));
      var resolution = {
        x: alpha / renderCtx.getCanvas().width,
        y: alpha / renderCtx.getCanvas().height
      };

      _drawAreaOnMap.call(this, ctx, pos, nbPixels, resolution);

      var bbox = [pos[0] - resolution.x * nbPixels[0], pos[1] - resolution.y * nbPixels[1], pos[0] + resolution.x * nbPixels[0], pos[1] + resolution.y * nbPixels[1]];
      var url = WMSServer.getFeatureInfo(keys[start], bbox, layersByWMSServer[keys[start]]);
      getQueryableLayers(url, options);
    } else {
      if (options && options.error) {
        options.error("error");
      }
    }
  };
  /**
   * @function remove
   * @memberof WMSFeatureInfoReverseNameResolver#
   */


  WMSFeatureInfoReverseNameResolver.prototype.remove = function (options) {};

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var mizarAPI$8;
  var context$2;
  var reverseNameResolverImplementation = null;
  var ReverseNameResolver = {
    init: function (m) {
      mizarAPI$8 = m;
      this.setContext(mizarAPI$8.getActivatedContext());
    },

    /**************************************************************************************************************/

    /**
     *    Send request to reverse name resolver service for the given gepoint
     *    @param geoPick    Geographic position of point of interest
     *    @param options
     *        <li>success: Function called on success with the response of server as argument</li>
     *        <li>error: Function called on error with the xhr object as argument</li>
     *    @fires Mizar#plugin:not_found
     */
    sendRequest: function (geoPick, options) {
      // Currently only sky context is handled

      if (mizarAPI$8.getActivatedContext().getMode() === Constants.CONTEXT.Sky) {
        // Find max order
        var maxOrder = 3;
        mizarAPI$8.getActivatedContext().getTileManager().visitTiles(function (tile) {
          if (maxOrder < tile.order) {
            maxOrder = tile.order;
          }
        });
        options.maxOrder = maxOrder;
        options.pos = geoPick;
        options.mizarAPI = mizarAPI$8;

        if (reverseNameResolverImplementation) {
          reverseNameResolverImplementation.handle(options);
        } else {
          mizarAPI$8.publish(Constants.EVENT_MSG.PLUGIN_NOT_FOUND, "No reverse name resolver found");
        }
      } else if (mizarAPI$8.getActivatedContext().getMode() === Constants.CONTEXT.Planet) {
        options.pos = geoPick;
        options.mizarAPI = mizarAPI$8;

        if (reverseNameResolverImplementation) {
          reverseNameResolverImplementation.handle(options);
        } else {
          mizarAPI$8.publish(Constants.EVENT_MSG.PLUGIN_NOT_FOUND, "No reverse name resolver found");
        }
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "ReverseNameResolver.js", "Not implemented yet");

        if (options && options.error) {
          options.error();
        }
      }
    },

    /**
     *    Set new context
     */
    setContext: function (ctx) {
      context$2 = ctx; //instantiate reverse name resolver nameResolverImplementation object

      var reverseNameResolverClass;

      if (typeof context$2.getContextConfiguration().reverseNameResolver !== "undefined") {
        reverseNameResolverClass = require(context$2.getContextConfiguration().reverseNameResolver.jsObject);
        reverseNameResolverImplementation = new reverseNameResolverClass(context$2);
      } else {
        //Use default reverse name resolver if none defined...
        reverseNameResolverImplementation = new DefaultReverseNameResolver(context$2);
      }
    }
  };

  /**
   * @class
   * Store time sample
   * @constructor
   */

  var TimeSample = function () {
    this.start = null;
    this.end = null;
    this.stepValue = null;
    this.stepKind = null;
    this.layerID = null;
  };
  /**************************************************************************************************************/

  /**
   * Get the start date
   * @function getStart
   * @return {Date} Start date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getStart = function () {
    return this.start;
  };
  /**************************************************************************************************************/

  /**
   * Set the start date of sample
   * @function setStart
   * @param {Date} date Start date
   * @memberof TimeSample#
   */


  TimeSample.prototype.setStart = function (date) {
    this.start = Moment__default['default'].utc(date);
  };
  /**************************************************************************************************************/

  /**
   * Get the end date
   * @function getEnd
   * @return {Date} End date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getEnd = function () {
    return this.end;
  };
  /**************************************************************************************************************/

  /**
   * Set the end date
   * @function setEnd
   * @param {Date} date End date
   * @memberof TimeSample#
   */


  TimeSample.prototype.setEnd = function (date) {
    this.end = Moment__default['default'].utc(date);
  };
  /**************************************************************************************************************/

  /**
   * Get the step value
   * @function getStepValue
   * @return {Integer} Step value
   * @memberof TimeSample#
   */


  TimeSample.prototype.getStepValue = function () {
    return this.stepValue;
  };
  /**************************************************************************************************************/

  /**
   * Set the step value
   * @function setStepValue
   * @param {Integer} stepValue Step value
   * @memberof TimeSample#
   */


  TimeSample.prototype.setStepValue = function (stepValue) {
    this.stepValue = stepValue;
  };
  /**************************************************************************************************************/

  /**
   * Get the step kind
   * @function getStepKind
   * @return {string} Step kind
   * @memberof TimeSample#
   */


  TimeSample.prototype.getStepKind = function () {
    return this.stepKind;
  };
  /**************************************************************************************************************/

  /**
   * Set the step kind
   * @function setStepKind
   * @param {string} stepKind Step kind
   * @memberof TimeSample#
   */


  TimeSample.prototype.setStepKind = function (stepKind) {
    this.stepKind = stepKind;
  };
  /**************************************************************************************************************/

  /**
   * Set the layer ID
   * @function setLayerID
   * @param {string} layerID Layer ID
   * @memberof TimeSample#
   */


  TimeSample.prototype.setLayerID = function (layerID) {
    this.layerID = layerID;
  };
  /**************************************************************************************************************/

  /**
   * Get the layer ID
   * @function getLayerID
   * @return {string} Layer ID
   * @memberof TimeSample#
   */


  TimeSample.prototype.getLayerID = function () {
    return this.layerID;
  };
  /**************************************************************************************************************/

  /**
   * Get next date
   * @function getNextDate
   * @return {Date} Next date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getNextDate = function (date) {
    var nextDate = null;
    nextDate = Moment__default['default'].utc(date).add(this.stepValue, this.stepKind);

    if (nextDate > this.end) {
      nextDate = null;
    }

    return nextDate;
  };
  /**************************************************************************************************************/

  /**
   * Get previous date
   * @function getPreviousDate
   * @return {Date} Previous date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getPreviousDate = function (date) {
    var previousDate = null;
    previousDate = Moment__default['default'].utc(date).subtract(this.stepValue, this.stepKind);

    if (previousDate < this.start) {
      previousDate = null;
    }

    return previousDate;
  };
  /**************************************************************************************************************/

  /**
   * Get first date AFTER a specified date
   * @function getFirstDateAfter
   * @param {Date} date Date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getFirstDateAfter = function (date) {
    var foundDate = null;
    var foundPeriod = {
      from: null,
      to: null
    };
    var foundDisplay = null;

    if (date < this.start) {
      // trivial case, first date is after !
      foundDate = this.start;
      foundDisplay = Moment__default['default'](foundDate.toISOString()).format(Moment__default['default'](foundDate).creationData().format);
    } else if (date > this.end) {
      // trivial case, date is after the last date
      foundDate = null;
    } else {
      // go to search
      var currentDate = this.start;
      var isDone = false;

      while (!isDone) {
        currentDate = this.getNextDate(currentDate);

        if (currentDate === null) {
          // Null found, no more date, stop it whith found date set to null
          isDone = true;
          foundDate = null;
        }

        if (currentDate > date) {
          isDone = true;
          foundDate = currentDate;
        }
      }
    }

    if (foundDate !== null) {
      foundPeriod.from = foundDate;
      foundPeriod.to = foundDate;
      foundDisplay = Moment__default['default'](foundDate.toISOString()).format(Moment__default['default'](foundDate).creationData().format);
    }

    return {
      date: foundDate,
      period: foundPeriod,
      display: foundDisplay
    };
  };
  /**************************************************************************************************************/

  /**
   * Get first date BEFORE a specified date
   * @function getFirstDateBefore
   * @param {Date} date Date
   * @memberof TimeSample#
   */


  TimeSample.prototype.getFirstDateBefore = function (date) {
    var foundDate = null;
    var foundPeriod = {
      from: null,
      to: null
    };
    var foundDisplay = null;

    if (date > this.end) {
      // trivial case, end date is before !
      foundDate = this.end;
      foundDisplay = Moment__default['default'](foundDate.toISOString()).format(Moment__default['default'](foundDate).creationData().format);
    } else if (date < this.start) {
      // trivial case, date is before the first date
      foundDate = null;
    } else {
      // go to search
      var currentDate = this.start;
      var previousDate = null;
      var isDone = false;

      while (!isDone) {
        previousDate = currentDate;
        currentDate = this.getNextDate(currentDate);

        if (currentDate === null) {
          // Null found, no more date, stop it whith found date set to null
          isDone = true;
          foundDate = previousDate;
        }

        if (currentDate > date) {
          isDone = true;
          foundDate = previousDate;
        }
      }
    }

    if (foundDate !== null) {
      foundDisplay = Moment__default['default'](foundDate.toISOString()).format(Moment__default['default'](foundDate).creationData().format);
      foundPeriod.from = foundDate;
      foundPeriod.to = foundDate;
    }

    return {
      date: foundDate,
      period: foundPeriod,
      display: foundDisplay
    };
  };
  /**************************************************************************************************************/

  /**
   * Get min date
   * @function getMinDate
   * @return {Date} Min date or null
   * @memberof TimeSample#
   */


  TimeSample.prototype.getMinDate = function () {
    return this.getStart();
  };
  /**************************************************************************************************************/

  /**
   * Get max date
   * @function getMaxDate
   * @return {Date} Max date or null
   * @memberof TimeSample#
   */


  TimeSample.prototype.getMaxDate = function () {
    return this.getEnd();
  };
  /**************************************************************************************************************/

  /**
   * Get string representation
   * @function toString
   * @return {string} String representation
   * @memberof TimeSample#
   */


  TimeSample.prototype.toString = function () {
    return Moment__default['default'](this.start) + " / " + Moment__default['default'](this.end) + " / " + this.stepValue + this.stepKind + " / ID=" + this.layerID;
  };

  // This was a ciruclar dependency. The NO_ID property doesn't even exist in TimeTravelParams

  const TimeTravelParams = {
    NO_ID: "no_value_for_no_id"
  };
  /**
   * @class
   * Stock time sample
   * @constructor
   */

  var TimeEnumerated = function () {
    // Array of enumerated values
    this.enumeratedValues = null;
    this.currentIndex = null;
  };
  /**************************************************************************************************************/

  /**
   * Sort enumerated values by date
   * @function sortTime
   * @param {Date} a First date
   * @param {Date} b Second date
   * @memberof TimeEnumerated#
   * @private
   */


  function sortTime(a, b) {
    return a.date > b.date ? 1 : -1;
  }
  /**************************************************************************************************************/

  /**
   * Get the current index
   * @function getCurrentIndex
   * @return Integer Current index
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getCurrentIndex = function () {
    return this.currentIndex;
  };
  /**************************************************************************************************************/

  /**
   * Parse date
   * @function parseDate
   * @param {string} value Date to parse
   * @return {Json} date { "date", "display", "period" { "from", "to" } }
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.parseDate = function (value) {
    value = value.trim();
    var date = null;
    var period = null;
    var regExpYear = /^\d{4}$/;
    var regExpMonth = /^\d{4}-\d{2}$/;
    var regExpDay = /^\d{4}-\d{2}-\d{2}$/;

    if (typeof value === "string") {
      // Year management
      if (regExpYear.test(value)) {
        date = Moment__default['default'].utc(value, "YYYY");
        period = {};
        period.from = date;
        period.to = Moment__default['default'].utc(period.from).endOf(Constants.TIME_STEP.YEAR);
      } // Month management
      else if (regExpMonth.test(value)) {
          date = Moment__default['default'].utc(value, "YYYY-MM");
          period = {};
          period.from = date;
          period.to = Moment__default['default'].utc(period.from).endOf(Constants.TIME_STEP.MONTH);
        } // Day management
        else if (regExpDay.test(value)) {
            date = Moment__default['default'].utc(value, "YYYY-MM-DD");
            period = {};
            period.from = date;
            period.to = Moment__default['default'].utc(period.from).endOf(Constants.TIME_STEP.DAY);
          }

      if (date === null) {
        date = Moment__default['default'].utc(value);
        period = {};
        period.from = date;
        period.to = date;
      }
    } else {
      date = Moment__default['default'].utc(value);
    }

    return {
      date: date,
      display: value,
      period: period
    };
  };
  /**************************************************************************************************************/

  /**
   * Add date to enumerated values (check if still present)
   * @function addDateToEnumeratedValues
   * @param {Json} date Date
   * @param {string} ID Id
   * @memberof TimeEnumerated#
   * @private
   */


  TimeEnumerated.prototype.addDateToEnumeratedValues = function (date, ID) {
    if (this.enumeratedValues === null) {
      this.enumeratedValues = [];
    }

    for (var i = 0; i < this.enumeratedValues.length; i++) {
      if (this.enumeratedValues[i].display === date.display) {
        // Still found : add only id
        if (this.enumeratedValues[i].ids && this.enumeratedValues[i].ids.length) {
          this.enumeratedValues[i].ids.push(ID);
          return;
        }
      }
    } // Not found, add all


    date.ids = [];
    date.ids.push(ID);
    this.enumeratedValues.push(date);
  };
  /**************************************************************************************************************/

  /**
   * Remove enumerated values for ID
   * @function removeEnumeratedValuesForID
   * @param {string} ID Id
   * @memberof TimeEnumerated#
   * @private
   */


  TimeEnumerated.prototype.removeEnumeratedValuesForID = function (ID) {
    if (ID === null) {
      ID = TimeTravelParams.NO_ID;
    }

    if (this.enumeratedValues) {
      for (var i = this.enumeratedValues.length - 1; i >= 0; i--) {
        if (this.enumeratedValues[i].ids && this.enumeratedValues[i].ids.length) {
          var index = this.enumeratedValues[i].ids.indexOf(ID);

          if (index !== -1) {
            this.enumeratedValues[i].ids.splice(index, 1);
          }

          if (this.enumeratedValues[i].ids.length === 0) {
            this.enumeratedValues.splice(i, 1);
          }
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Add enumerated values for ID
   * @function addEnumeratedValuesForID
   * @param {Array<String>} values Array of enumerated values
   * @param {string} ID Id
   * @memberof TimeEnumerated#
   * @private
   */


  TimeEnumerated.prototype.addEnumeratedValuesForID = function (values, ID) {
    if (values === null) {
      // By pass
      return;
    }

    if (ID === null) {
      ID = TimeTravelParams.NO_ID;
    } // TODO soon : check format, need conversion ?


    var date = null;

    for (var i = 0; i < values.length; i++) {
      date = this.parseDate(values[i]);
      this.addDateToEnumeratedValues(date, ID);
    } // sort tab


    this.enumeratedValues.sort(sortTime);
    this.currentIndex = 0;
    this.currentDate = this.enumeratedValues[this.currentIndex].date;
  };
  /**************************************************************************************************************/

  /**
   * Get first date AFTER a specified date
   * @function getFirstDateAfter
   * @param Date date date
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getFirstDateAfter = function (date) {
    var foundDate = null;
    return foundDate;
  };
  /**************************************************************************************************************/

  /**
   * Get first date BEFORE a specified date
   * @function getFirstDateBefore
   * @param Date date date
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getFirstDateBefore = function (date) {
    var foundDate = null;
    return foundDate;
  };
  /**************************************************************************************************************/

  /**
   * Get first date AFTER a specified date
   * @function getFirstDateAfter
   * @param {Date} date Date
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getFirstDateAfter = function (date) {
    var foundDate = null;
    var foundPeriod = {
      from: null,
      to: null
    };
    var foundDisplay = null;

    if (this.enumeratedValues && this.enumeratedValues.length > 0) {
      if (date < this.enumeratedValues[0].date) {
        // trivial case, first date is before the first element
        foundDate = this.enumeratedValues[0].date;
        foundPeriod = this.enumeratedValues[0].period;
        foundDisplay = this.enumeratedValues[0].display;
      } else if (date > this.enumeratedValues[this.enumeratedValues.length - 1].date) {
        // trivial case, date is after the last date
        foundDate = null;
      } else {
        // go to search
        var cpt = 0;
        var isDone = false;

        while (!isDone) {
          var currentDate = this.enumeratedValues[cpt].date;

          if (currentDate > date) {
            isDone = true;
            foundDate = this.enumeratedValues[cpt].date;
            foundPeriod = this.enumeratedValues[cpt].period;
            foundDisplay = this.enumeratedValues[cpt].display;
          }

          cpt++;
          isDone = isDone || cpt >= this.enumeratedValues.length;
        }
      }
    }

    return {
      date: foundDate,
      period: foundPeriod,
      display: foundDisplay
    };
  };
  /**************************************************************************************************************/

  /**
   * Get first date BEFORE a specified date
   * @function getFirstDateBefore
   * @param {Date} date Date
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getFirstDateBefore = function (date) {
    var foundDate = null;
    var foundPeriod = {
      from: null,
      to: null
    };
    var foundDisplay = null;

    if (this.enumeratedValues && this.enumeratedValues.length > 0) {
      if (date > this.enumeratedValues[this.enumeratedValues.length - 1].date) {
        // trivial case, end date is before !
        foundDate = this.enumeratedValues[this.enumeratedValues.length - 1].date;
        foundPeriod = this.enumeratedValues[this.enumeratedValues.length - 1].period;
        foundDisplay = this.enumeratedValues[this.enumeratedValues.length - 1].display;
      } else if (date < this.enumeratedValues[0].date) {
        // trivial case, date is before the first date
        foundDate = null;
      } else {
        // go to search
        var cpt = this.enumeratedValues.length - 1;
        var isDone = false;

        while (!isDone) {
          while (!isDone) {
            var currentDate = this.enumeratedValues[cpt].date;

            if (currentDate < date) {
              isDone = true;
              foundDate = this.enumeratedValues[cpt].date;
              foundPeriod = this.enumeratedValues[cpt].period;
              foundDisplay = this.enumeratedValues[cpt].display;
            }

            cpt--;
            isDone = isDone || cpt < 0;
          }
        }
      }
    }

    return {
      date: foundDate,
      period: foundPeriod,
      display: foundDisplay
    };
  };
  /**************************************************************************************************************/

  /**
   * Get string representation
   * @function toString
   * @return {string} String representation
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.toString = function () {
    var res = "";

    if (this.enumeratedValues) {
      for (var i = 0; i < this.enumeratedValues.length; i++) {
        res += this.enumeratedValues[i].display + " / ";
      }
    }

    return res;
  };
  /**************************************************************************************************************/

  /**
   * Is empty ?
   * @function isEmpty
   * @return {Boolean} is empty ?
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.isEmpty = function () {
    return !(this.enumeratedValues && this.enumeratedValues.length > 0);
  };
  /**************************************************************************************************************/

  /**
   * Get min date
   * @function getMinDate
   * @return {Date} Min date or null
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getMinDate = function () {
    var result = null;

    if (this.enumeratedValues && this.enumeratedValues.length > 0) {
      result = this.enumeratedValues[0].date;
    }

    return result;
  };
  /**************************************************************************************************************/

  /**
   * Get max date
   * @function getMaxDate
   * @return {Date} Max date or null
   * @memberof TimeEnumerated#
   */


  TimeEnumerated.prototype.getMaxDate = function () {
    var result = null;

    if (this.enumeratedValues && this.enumeratedValues.length > 0) {
      result = this.enumeratedValues[this.enumeratedValues.length - 1].date;
    }

    return result;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name TimeTravelParams
   * @class
   * Management of time travel
   */

  var TimeTravelParams$1 = function () {
    this.currentDate = new Date();
    this.currentPeriod = {
      from: null,
      to: null
    }; // this.currentDisplayDate = moment(this.currentDate).format(moment(this.currentDate).creationData().format);

    this.currentDisplayDate = this.currentDate.toISOString();
    this.minDate = null;
    this.maxDate = null;
    this.ctx = null; // List of samples

    this.samples = []; // Enumerated values

    this.enumeratedValues = new TimeEnumerated(); // TODO: internationalized

    Moment__default['default'].locale("fr");
  };
  /**************************************************************************************************************/

  /**
   * Set the context
   * @function setContext
   * @param ctx Context context
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.setContext = function (ctx) {
    this.ctx = ctx;
    this.apply();
  };
  /**************************************************************************************************************/

  /**
   * Set the current date
   * @function setCurrentDate
   * @param date Date current date
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.setCurrentDate = function (date) {
    this.currentDate = Moment__default['default'].utc(date);
  };
  /**************************************************************************************************************/

  /**
   * Get the current date
   * @function getCurrentDate
   * @return Date current date
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getCurrentDate = function () {
    return this.currentDate;
  };
  /**************************************************************************************************************/

  /**
   * Get the current period
   * @function getCurrentPeriod
   * @return {Json} period { "from", "to" }
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getCurrentPeriod = function () {
    return this.currentPeriod;
  };
  /**************************************************************************************************************/

  /**
   * Add a sample
   * @function addSample
   * @param {Date} start Start date
   * @param {Date} end End date
   * @param {string} stepKind Step kind
   * @param {Integer} stepValue Step value
   * @param {string} ID Layer ID
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.addSample = function (start, end, stepKind, stepValue, ID) {
    var sample = new TimeSample();
    sample.setStart(start);
    sample.setEnd(end);
    sample.setStepKind(stepKind);
    sample.setStepValue(stepValue);
    sample.setLayerID(ID);
    this.samples.push(sample);
  };
  /**************************************************************************************************************/

  /**
   * Add values
   * @function add values
   * @param {Json} parameters Parameters
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.addValues = function (parameters) {
    if (!parameters) {
      return;
    }

    var saveCurrentValue = this.currentDate;

    if (parameters.enumeratedValues) {
      // Add to enumerated
      this.enumeratedValues.addEnumeratedValuesForID(parameters.enumeratedValues, parameters.ID);
    } else if (parameters.start && parameters.end && parameters.stepKind && parameters.stepValue && parameters.ID) {
      // Add a new sample
      this.addSample(parameters.start, parameters.end, parameters.stepKind, parameters.stepValue, parameters.ID);
    } else {
      ErrorDialog.open(Constants.LEVEL.WARNING, "Can't understand add values for time travel with parameters : " + parameters);
    }

    this.setToNearestValue(saveCurrentValue);
  };
  /**************************************************************************************************************/

  /**
   * Remove values
   * @function remove values
   * @param {Json} parameters Parameters
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.removeValues = function (parameters) {
    if (!parameters) {
      return;
    }

    var saveCurrentValue = this.currentDate;

    if (parameters.ID) {
      // Remove values into enumerated values
      this.enumeratedValues.removeEnumeratedValuesForID(parameters.ID); // Remove samples with ID

      var newSamples = [];

      for (var i = 0; i < this.samples.length; i++) {
        if (this.samples[i].getLayerID() !== parameters.ID) {
          newSamples.push(this.samples[i]);
        }
      }

      this.samples = newSamples;
    }

    this.setToNearestValue(saveCurrentValue);
  };
  /**************************************************************************************************************/

  /**
   * Get next date
   * @function getNextDate
   * @return {Date} Date
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getNextDate = function (date) {
    var minDate = {
      date: null
    };
    var allDates = [];
    var aDate = null;

    for (var i = 0; i < this.samples.length; i++) {
      aDate = this.samples[i].getFirstDateAfter(date);

      if (aDate.date !== null) {
        allDates.push(aDate);
      }
    }

    aDate = this.enumeratedValues.getFirstDateAfter(date);

    if (aDate.date !== null) {
      allDates.push(aDate);
    }

    for (i = 0; i < allDates.length; i++) {
      var currentNextDate = allDates[i];

      if (minDate.date === null) {
        minDate = currentNextDate;
      } else {
        if (Math.abs(currentNextDate - date) < Math.abs(minDate - date)) {
          minDate = currentNextDate;
        }
      }
    }

    return minDate;
  };
  /**************************************************************************************************************/

  /**
   * Get previous date
   * @function getNextDate
   * @return {Date} Date
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getPreviousDate = function (date) {
    var minDate = {
      date: null
    };
    var allDates = [];
    var aDate = null;

    for (var i = 0; i < this.samples.length; i++) {
      aDate = this.samples[i].getFirstDateBefore(date);

      if (aDate.date !== null) {
        allDates.push(aDate);
      }
    }

    aDate = this.enumeratedValues.getFirstDateBefore(date);

    if (aDate.date !== null) {
      allDates.push(aDate);
    }

    for (i = 0; i < allDates.length; i++) {
      var currentPreviousDate = allDates[i];

      if (minDate.date === null) {
        minDate = currentPreviousDate;
      } else {
        if (Math.abs(currentPreviousDate.date - date) < Math.abs(minDate.date - date)) {
          minDate = currentPreviousDate;
        }
      }
    }

    return minDate;
  };
  /**************************************************************************************************************/

  /**
   * Set to nearest value (call only for enumerated)
   * @function setToNearestValue
   * @param {Date} date date
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.setToNearestValue = function (date) {
    var previousExistingDate = this.getPreviousDate(date);
    var nextExistingDate = this.getNextDate(date);

    if (previousExistingDate.date === null && nextExistingDate.date === null) {
      // No date found
      this.currentDate = new Date();
      this.currentDisplayDate = Moment__default['default'](this.currentDate).format("Do MMM Y");
      this.currentPeriod = {
        from: this.currentDate,
        to: this.currentDate
      };
    } else if (previousExistingDate.date === null) {
      // Only before
      this.currentDate = nextExistingDate.date;
      this.currentDisplayDate = nextExistingDate.display;
      this.currentPeriod = nextExistingDate.period;
    } else if (nextExistingDate.date === null) {
      // Only after
      this.currentDate = previousExistingDate.date;
      this.currentDisplayDate = previousExistingDate.display;
      this.currentPeriod = previousExistingDate.period;
    } else {
      // Search nearest
      var deltaPrevious = Math.abs(date - previousExistingDate.date);
      var deltaNext = Math.abs(nextExistingDate.date - date);

      if (deltaPrevious < deltaNext) {
        this.currentDate = previousExistingDate.date;
        this.currentDisplayDate = previousExistingDate.display;
        this.currentPeriod = previousExistingDate.period;
      } else {
        this.currentDate = nextExistingDate.date;
        this.currentDisplayDate = nextExistingDate.display;
        this.currentPeriod = nextExistingDate.period;
      }
    }

    this.apply();
  };
  /**************************************************************************************************************/

  /**
   * Update
   * @function update
   * @param {Json} parameters Parameters
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.update = function (parameters) {
    if (!parameters) {
      return;
    }

    if (parameters.add) {
      this.addValues(parameters.add);
    }

    if (parameters.remove) {
      this.removeValues(parameters.remove);
    } // update metadata


    this.minDate = this.getMinDate();
    this.maxDate = this.getMaxDate(); // apply !

    this.apply();
  };
  /**************************************************************************************************************/

  /**
   * Apply current date to IHM (launch event)
   * @function apply
   * @memberof TimeTravelParams#
   * @fires Context#globalTime:changed
   */


  TimeTravelParams$1.prototype.apply = function () {
    var details = {
      date: this.currentDate,
      display: this.currentDisplayDate,
      period: this.currentPeriod
    };
    this.ctx.publish(Constants.EVENT_MSG.GLOBAL_TIME_CHANGED, details);
  };
  /**************************************************************************************************************/

  /**
   * Rewind to previous time step
   * @function rewind
   * @memberof TimeTravelParams#
   * @fires Context#globalTime:changed
   */


  TimeTravelParams$1.prototype.rewind = function () {
    if (!this.isEmpty()) {
      var previousDate = this.getPreviousDate(Moment__default['default'](this.currentDate).subtract(1, Constants.TIME_STEP.MILLISECOND));

      if (previousDate.date !== null) {
        this.currentDate = previousDate.date;
        this.currentPeriod = previousDate.period;
        this.currentDisplayDate = previousDate.display;
        this.apply();
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Forward to next time step
   * @function forward
   * @memberof TimeTravelParams#
   * @fires Context#globalTime:changed
   */


  TimeTravelParams$1.prototype.forward = function () {
    if (!this.isEmpty()) {
      var nextDate = this.getNextDate(Moment__default['default'](this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND));

      if (nextDate.date !== null) {
        this.currentDate = nextDate.date;
        this.currentPeriod = nextDate.period;
        this.currentDisplayDate = nextDate.display;
        this.apply();
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Get date formated (when there is no enumerated values)
   * @function getDateFormated
   * @param {Date} date Date
   * @return String Date formated
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getDateFormated = function (date) {
    // Check with STEP kind value
    var formatPattern; // = "LLLL";

    if (this.stepKind === Constants.TIME_STEP.YEAR) {
      formatPattern = "Y";
    } else if (this.stepKind === Constants.TIME_STEP.QUARTER || this.stepKind === Constants.TIME_STEP.MONTH) {
      formatPattern = "MMM Y";
    } else if (this.stepKind === Constants.TIME_STEP.WEEK || this.stepKind === Constants.TIME_STEP.DAY || this.stepKind === Constants.TIME_STEP.ENUMERATED) {
      formatPattern = "Do MMM Y";
    } else if (this.stepKind === Constants.TIME_STEP.HOUR || this.stepKind === Constants.TIME_STEP.MINUTE) {
      formatPattern = "Do MMM Y HH:mm";
    } else if (this.stepKind === Constants.TIME_STEP.SECOND) {
      formatPattern = "Do MMM Y   HH:mm:ss";
    } else {
      formatPattern = "Do MMM Y   HH:mm:ss.SSS";
    }

    return Moment__default['default'].utc(this.currentDate).format(formatPattern);
  };
  /**************************************************************************************************************/

  /**
   * Return date to display on IHM
   * @function getCurrentDisplayDate
   * @return String Date formated
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getCurrentDisplayDate = function () {
    return this.currentDisplayDate;
    /*
      var result = null;
      if (this.stepKind === Constants.TIME_STEP.ENUMERATED) {
          if (this.enumeratedValues.length>0) {
              result = this.enumeratedValues[this.currentIndex].display;
          } else {
              result = this.getDateFormated(new Date());
          }
      } else {
          result = this.getDateFormated(this.currentDate);
      }
      return result;
      */
  };
  /**************************************************************************************************************/

  /**
   * Is current date the first ?
   * @function isCurrentDateTheFirst
   * @return boolean If the current date is the first of range
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.isCurrentDateTheFirst = function () {
    if (this.isEmpty() === true) {
      this.isFirstDate = true;
    } else {
      var previousDate = this.getPreviousDate(Moment__default['default'](this.currentDate).subtract(1, Constants.TIME_STEP.MILLISECOND));
      this.isFirstDate = previousDate.date === null;
    }

    return this.isFirstDate;
  };
  /**************************************************************************************************************/

  /**
   * Is current date the last ?
   * @function isCurrentDateTheLast
   * @return boolean If the current date is the last of range
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.isCurrentDateTheLast = function () {
    if (this.isEmpty() === true) {
      this.isLastDate = true;
    } else {
      var nextDate = this.getNextDate(Moment__default['default'](this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND));
      this.isLastDate = nextDate.date === null;
    }

    return this.isLastDate;
  };
  /**************************************************************************************************************/

  /**
   * Get min date
   * @function getMinDate
   * @return {Date} Min date or null
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getMinDate = function () {
    var result = null;
    var allDates = [];

    for (var i = 0; i < this.samples.length; i++) {
      allDates.push(this.samples[i].getMinDate());
    }

    allDates.push(this.enumeratedValues.getMinDate());

    for (i = 0; i < allDates.length; i++) {
      if (result === null) {
        result = allDates[i];
      } else if (allDates[i] < result && allDates[i] !== null) {
        result = allDates[i];
      }
    }

    return result;
  };
  /**************************************************************************************************************/

  /**
   * Get max date
   * @function getMaxDate
   * @return {Date} Max date or null
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.getMaxDate = function () {
    var result = null;
    var allDates = [];

    for (var i = 0; i < this.samples.length; i++) {
      allDates.push(this.samples[i].getMaxDate());
    }

    allDates.push(this.enumeratedValues.getMaxDate());

    for (i = 0; i < allDates.length; i++) {
      if (result === null) {
        result = allDates[i];
      } else if (allDates[i] > result && allDates[i] !== null) {
        result = allDates[i];
      }
    }

    return result;
  };
  /**************************************************************************************************************/

  /**
   * Is time travel empty ?
   * @function toString
   * @return {Boolean} Is time travel empty
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.isEmpty = function () {
    var hasSamples = this.samples && this.samples.length > 0;
    return !hasSamples && this.enumeratedValues.isEmpty();
  };
  /**************************************************************************************************************/
  // /**
  //  * Get all steps
  //  * @function toString
  //  * @return {string} String representation
  //  * @memberof TimeTravelParams#
  //  */
  // TimeTravelParams.prototype.getAllSteps = function () {
  //     throw "TimeTravelParams.getAllSteps : deactivated because too long to execute";
  //     var res = [];
  //     var aDate = this.minDate;
  //     res.push(aDate);
  //     var nextDate = this.getNextDate(
  //         moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
  //     );
  //     while (nextDate.date !== null) {
  //         aDate = nextDate.date;
  //         res.push(aDate);
  //         if (res.length % 500 === 0) {
  //             console.log(res.length);
  //         }
  //         nextDate = this.getNextDate(
  //             moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
  //         );
  //     }
  //     return res;
  // };

  /**************************************************************************************************************/

  /**
   * Get string representation
   * @function toString
   * @return {string} String representation
   * @memberof TimeTravelParams#
   */


  TimeTravelParams$1.prototype.toString = function () {
    var res = "";
    res += "Metadata : \n";
    res += "  Start date : " + Moment__default['default'](this.minDate).format(Constants.TIME.DEFAULT_FORMAT) + " : " + this.minDate + "\n";
    res += "  End date   : " + Moment__default['default'](this.maxDate).format(Constants.TIME.DEFAULT_FORMAT) + " : " + this.maxDate + "\n";

    if (this.samples) {
      for (var i = 0; i < this.samples.length; i++) {
        res += "Sample : " + this.samples[i].toString() + "\n";
      }
    }

    if (!this.enumeratedValues.isEmpty()) {
      res += "Enumerated : " + this.enumeratedValues.toString() + "\n";
    }

    return res;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   *    Private variables
   */

  var params = new TimeTravelParams$1();
  var parentElement = null;
  var ctx$2 = null;
  /**************************************************************************************************************/

  /**
   * Go Rewind
   * @fires Context#globalTime:changed
   */

  function goRewind() {
    params.rewind();
  }
  /**
   * Go Forward
   * @fires Context#globalTime:changed
   */


  function goForward() {
    params.forward();
  }
  /**
   * Choose time
   *
   */


  function chooseTime(date) {
    if (date instanceof Date || typeof date === "string") {
      params.setCurrentDate(date);
    }
  }
  /**************************************************************************************************************/

  /**
   *    Remove time travel element
   *
   */


  function remove$2() {
    ctx$2.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD, goForward);
    ctx$2.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
    ctx$2.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
    document.getElementById(parentElement).innerHTML = "";
  }
  /**************************************************************************************************************/

  /**
   *    reset values
   *
   */


  function reset() {
    params.reset();
  }
  /**
   *    update
   *
   */


  function update(parameters) {
    params.update(parameters);
  }
  /**
   *    get current date
   *
   */


  function getCurrentDate() {
    return params.getCurrentDate();
  }

  function isCurrentDateTheFirst() {
    return params.isCurrentDateTheFirst();
  }

  function isCurrentDateTheLast() {
    return params.isCurrentDateTheLast();
  }
  /**************************************************************************************************************/


  var TimeTravelCore = {
    init: function (options) {
      parentElement = options.element;
      ctx$2 = options.ctx;
      params.setContext(ctx$2); // subscribe

      if (ctx$2) {
        ctx$2.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD, goForward);
        ctx$2.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
        ctx$2.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
      }
    },
    reset: reset,
    update: update,
    goForward: goForward,
    goRewind: goRewind,
    isCurrentDateTheFirst: isCurrentDateTheFirst,
    isCurrentDateTheLast: isCurrentDateTheLast,
    chooseTime: chooseTime,
    remove: remove$2,
    getCurrentDate: getCurrentDate
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * image:added
   * Called when an image has been added
   * @event Mizar#image:added
   * @type {json}
   */

  /**
   * image:removed.<br/>
   * Called when an image has been removed
   * @event Mizar#image:removed
   * @type {json}
   */

  /**
   * image:downloaded.<br/>
   * Called when an image has been downloaded
   * @event Mizar#image:downloaded
   * @type {json}
   */

  var ServiceFactory = {
    create: function (serviceType, userOptions) {
      var obj;

      switch (serviceType) {
        case Constants.SERVICE.FitsVisu:
          obj = FitsVisu;
          break;

        case Constants.SERVICE.Histogram:
          obj = HistogramCore;
          break;

        case Constants.SERVICE.ImageProcessing:
          obj = ImageProcessingCore;
          break;

        case Constants.SERVICE.MeasureToolPlanet:
          obj = MeasureToolPlanetCore;
          break;

        case Constants.SERVICE.MeasureToolSky:
          obj = MeasureToolSkyCore;
          break;

        case Constants.SERVICE.MocBase:
          obj = MocBase;
          break;

        case Constants.SERVICE.MollweideViewer:
          obj = MollweideViewerCore;
          break;

        case Constants.SERVICE.TimeTravel:
          obj = TimeTravelCore;
          break;

        case Constants.SERVICE.PickingManager:
          obj = PickingManagerCore;
          break;

        case Constants.SERVICE.Samp:
          obj = SampCore;
          break;

        case Constants.SERVICE.SelectionTool:
          obj = new SelectionToolCore(userOptions);
          break;

        case Constants.SERVICE.NameResolver:
          obj = NameResolver;
          break;

        case Constants.SERVICE.ReverseNameResolver:
          obj = ReverseNameResolver;
          break;

        case Constants.SERVICE.ExportTool:
          obj = ExportToolCore;
          break;

        case Constants.SERVICE.FitsHips:
          obj = FitsHips;
          break;

        default:
          throw new RangeError("ServiceFactory.js: Cannot retrieve service " + serviceType);
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name AbstractRegistryHandler
   * @class
   *  Abstract Registry Handler
   * @param {object} options
   * @implements {RegistryHandler}
   */

  var AbstractRegistryHandler = function () {
    this.next = {
      handleRequest: function (layerDescription, callback, fallback) {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "AbstractRegistryHandler.js", "All strategies exhausted.");
      }
    };
  };
  /**
   * @function setNext
   * @memberof AbstractRegistryHandler#
   */


  AbstractRegistryHandler.prototype.setNext = function (next) {
    this.next = next;
    return next;
  };
  /**
   * @function handleRequest
   * @memberof AbstractRegistryHandler#
   */


  AbstractRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {};
  /**
   * Handles pending layers.
   * @function _handlePendingLayers
   * @memberof AbstractRegistryHandler#
   * @param {Layer[]} pendingLayers Pending layers
   * @param {Layer[]} List pf layers
   */


  AbstractRegistryHandler.prototype._handlePendingLayers = function (pendingLayers, layers) {
    //TODO : I loose the callback of pendingLayers
    for (var i = 0; i < layers.length && pendingLayers.length !== 0; i++) {
      var layer = layers[i];

      if (pendingLayers.length != 0 && layer.isBackground()) {
        var j = pendingLayers.length;

        while (j > 0) {
          j--;
          var pendingLayerDescription = pendingLayers[j];

          try {
            layers.push(LayerFactory.create(pendingLayerDescription));
            pendingLayers.splice(j, 1);
          } catch (RangeError) {
            ErrorDialog.open(Constants.LEVEL.DEBUG, "Failed to create layer", RangeError.message);
          }
        }

        break;
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates a WMS handler to create {@link WMSLayer WMS layers}
   * @param {*} pendingLayers
   * @augments AbstractRegistryHandler
   * @memberof module:Registry
   * @constructor
   * @see {@link WMSServer}
   */

  var WMSServerRegistryHandler = function (pendingLayers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, WMSServerRegistryHandler);
  /**************************************************************************************************************/

  /**
   * @function handleRequest
   * @memberof WMSServerRegistryHandler#
   */

  WMSServerRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    try {
      if (layerDescription.type === Constants.LAYER.WMS) {
        var wmsServer = new WMSServer(layerDescription);
        var self = this;
        wmsServer.createLayers(function (layers) {
          //TODO : I loose the callback of pendingLayers
          self._handlePendingLayers(self.pendingLayers, layers);

          callback(layers);
        }, fallback);
      } else {
        this.next.handleRequest(layerDescription, callback, fallback);
      }
    } catch (e) {
      if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "WMSServerRegistryHandler.js", e);
      }
    }
  };

  /* Copyright 2015 William Summers, MetaTribal LLC
   * adapted from https://developer.mozilla.org/en-US/docs/JXON
   *
   * Licensed under the MIT License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     https://opensource.org/licenses/MIT
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var xmlToJSON_1 = createCommonjsModule(function (module) {
  /**
   * @author William Summers
   *
   */

  var xmlToJSON = (function () {

      this.version = "1.3.5";

      var options = { // set up the default options
          mergeCDATA: true, // extract cdata and merge with text
          grokAttr: true, // convert truthy attributes to boolean, etc
          grokText: true, // convert truthy text/attr to boolean, etc
          normalize: true, // collapse multiple spaces to single space
          xmlns: true, // include namespaces as attribute in output
          namespaceKey: '_ns', // tag name for namespace objects
          textKey: '_text', // tag name for text nodes
          valueKey: '_value', // tag name for attribute values
          attrKey: '_attr', // tag for attr groups
          cdataKey: '_cdata', // tag for cdata nodes (ignored if mergeCDATA is true)
          attrsAsObject: true, // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.
          stripAttrPrefix: true, // remove namespace prefixes from attributes
          stripElemPrefix: true, // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property
          childrenAsArray: true // force children into arrays
      };

      var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      var trimMatch = new RegExp(/^\s+|\s+$/g);

      this.grokType = function (sValue) {
          if (/^\s*$/.test(sValue)) {
              return null;
          }
          if (/^(?:true|false)$/i.test(sValue)) {
              return sValue.toLowerCase() === "true";
          }
          if (isFinite(sValue)) {
              return parseFloat(sValue);
          }
          return sValue;
      };

      this.parseString = function (xmlString, opt) {
          return this.parseXML(this.stringToXML(xmlString), opt);
      };

      this.parseXML = function (oXMLParent, opt) {

          // initialize options
          for (var key in opt) {
              options[key] = opt[key];
          }

          var vResult = {},
              nLength = 0,
              sCollectedTxt = "";

          // parse namespace information
          if (options.xmlns && oXMLParent.namespaceURI) {
              vResult[options.namespaceKey] = oXMLParent.namespaceURI;
          }

          // parse attributes
          // using attributes property instead of hasAttributes method to support older browsers
          if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {
              var vAttribs = {};

              for (nLength; nLength < oXMLParent.attributes.length; nLength++) {
                  var oAttrib = oXMLParent.attributes.item(nLength);
                  vContent = {};
                  var attribName = '';

                  if (options.stripAttrPrefix) {
                      attribName = oAttrib.name.replace(prefixMatch, '');

                  } else {
                      attribName = oAttrib.name;
                  }

                  if (options.grokAttr) {
                      vContent[options.valueKey] = this.grokType(oAttrib.value.replace(trimMatch, ''));
                  } else {
                      vContent[options.valueKey] = oAttrib.value.replace(trimMatch, '');
                  }

                  if (options.xmlns && oAttrib.namespaceURI) {
                      vContent[options.namespaceKey] = oAttrib.namespaceURI;
                  }

                  if (options.attrsAsObject) { // attributes with same local name must enable prefixes
                      vAttribs[attribName] = vContent;
                  } else {
                      vResult[options.attrKey + attribName] = vContent;
                  }
              }

              if (options.attrsAsObject) {
                  vResult[options.attrKey] = vAttribs;
              }
          }

          // iterate over the children
          if (oXMLParent.hasChildNodes()) {
              for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
                  oNode = oXMLParent.childNodes.item(nItem);

                  if (oNode.nodeType === 4) {
                      if (options.mergeCDATA) {
                          sCollectedTxt += oNode.nodeValue;
                      } else {
                          if (vResult.hasOwnProperty(options.cdataKey)) {
                              if (vResult[options.cdataKey].constructor !== Array) {
                                  vResult[options.cdataKey] = [vResult[options.cdataKey]];
                              }
                              vResult[options.cdataKey].push(oNode.nodeValue);

                          } else {
                              if (options.childrenAsArray) {
                                  vResult[options.cdataKey] = [];
                                  vResult[options.cdataKey].push(oNode.nodeValue);
                              } else {
                                  vResult[options.cdataKey] = oNode.nodeValue;
                              }
                          }
                      }
                  } /* nodeType is "CDATASection" (4) */
                  else if (oNode.nodeType === 3) {
                      sCollectedTxt += oNode.nodeValue;
                  } /* nodeType is "Text" (3) */
                  else if (oNode.nodeType === 1) { /* nodeType is "Element" (1) */

                      if (nLength === 0) {
                          vResult = {};
                      }

                      // using nodeName to support browser (IE) implementation with no 'localName' property
                      if (options.stripElemPrefix) {
                          sProp = oNode.nodeName.replace(prefixMatch, '');
                      } else {
                          sProp = oNode.nodeName;
                      }

                      vContent = xmlToJSON.parseXML(oNode);

                      if (vResult.hasOwnProperty(sProp)) {
                          if (vResult[sProp].constructor !== Array) {
                              vResult[sProp] = [vResult[sProp]];
                          }
                          vResult[sProp].push(vContent);

                      } else {
                          if (options.childrenAsArray) {
                              vResult[sProp] = [];
                              vResult[sProp].push(vContent);
                          } else {
                              vResult[sProp] = vContent;
                          }
                          nLength++;
                      }
                  }
              }
          } else if (!sCollectedTxt) { // no children and no text, return null
              if (options.childrenAsArray) {
                  vResult[options.textKey] = [];
                  vResult[options.textKey].push(null);
              } else {
                  vResult[options.textKey] = null;
              }
          }

          if (sCollectedTxt) {
              if (options.grokText) {
                  var value = this.grokType(sCollectedTxt.replace(trimMatch, ''));
                  if (value !== null && value !== undefined) {
                      vResult[options.textKey] = value;
                  }
              } else if (options.normalize) {
                  vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '').replace(/\s+/g, " ");
              } else {
                  vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '');
              }
          }

          return vResult;
      };


      // Convert xmlDocument to a string
      // Returns null on failure
      this.xmlToString = function (xmlDoc) {
          try {
              var xmlString = xmlDoc.xml ? xmlDoc.xml : (new XMLSerializer()).serializeToString(xmlDoc);
              return xmlString;
          } catch (err) {
              return null;
          }
      };

      // Convert a string to XML Node Structure
      // Returns null on failure
      this.stringToXML = function (xmlString) {
          try {
              var xmlDoc = null;

              if (window.DOMParser) {

                  var parser = new DOMParser();
                  xmlDoc = parser.parseFromString(xmlString, "text/xml");

                  return xmlDoc;
              } else {
                  xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                  xmlDoc.async = false;
                  xmlDoc.loadXML(xmlString);

                  return xmlDoc;
              }
          } catch (e) {
              return null;
          }
      };

      return this;
  }).call({});

  if ( module !== null && module.exports) module.exports = xmlToJSON;
  });

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**
   * @class
   * WMTS metadata from capabilities.
   * @param {string} json
   * @constructor
   * @memberof module:Registry
   */
  var WMTSMetadata = function (json) {
    this.serviceIdentification = new ServiceIdentification(json.Capabilities.ServiceIdentification);
    this.serviceProvider = new ServiceProvider(json.Capabilities.ServiceProvider); //this.operationsMetadata;

    this.contents = new Contents(json.Capabilities.Contents); //this.themes;

    this.serviceMetadataURL = WMTSMetadata.getValueTag(json.Capabilities._attrhref);
  };
  /**
   * @class
   * Creates ServiceIdentification object.
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var ServiceIdentification = function (json) {
    if (json === undefined) {
      this.version = null;
      this.title = null;
      this.abstract = null;
      this.keywords = null;
      this.serviceType = null;
      this.fees = null;
      this.accessConstraints = null;
    } else {
      this.version = WMTSMetadata.getValueTag(json._attrversion);
      this.title = WMTSMetadata.getValueTag(json.Title);
      this.abstract = WMTSMetadata.getValueTag(json.Abstract);
      this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
      this.serviceType = WMTSMetadata.getValueTag(json.ServiceType);
      this.fees = WMTSMetadata.getValueTag(json.Fees);
      this.accessConstraints = WMTSMetadata.parseAccessConstraints(json.AccessConstraints);
    }
  };
  /**
   * @class
   * Creates ServiceProvider object.
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var ServiceProvider = function (json) {
    if (json === undefined) {
      this.providerName = null;
      this.providerSite = null;
      this.serviceContact = null;
    } else {
      this.providerName = WMTSMetadata.getValueTag(json.ProviderName);
      this.providerSite = null;
      this.serviceContact = new ServiceContact(json.ServiceContact);
    }
  };
  /**
   * @class
   * Creates ServiceContact object.
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var ServiceContact = function (json) {
    if (json === undefined) {
      this.individualName = null;
      this.positionName = null;
      this.contactInfo = null;
      this.role = null;
    } else {
      this.individualName = WMTSMetadata.getValueTag(json.IndividualName);
      this.positionName = WMTSMetadata.getValueTag(json.PositionName);
      this.contactInfo = new ContactInfo(json.ContactInfo);
      this.role = WMTSMetadata.getValueTag(json.Role);
    }
  };
  /**
   * @class
   * Creates ContactInfo object.
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var ContactInfo = function (json) {
    if (json === undefined) {
      this.phone = null;
      this.address = null;
      this.onlineResource = null;
      this.hoursOfService = null;
      this.contactInstructions = null;
    } else {
      this.phone = new Phone(json.Phone);
      this.address = new Address(json.Address);
      this.onlineResource = null;
      this.hoursOfService = WMTSMetadata.getValueTag(json.HoursOfService);
      this.contactInstructions = WMTSMetadata.getValueTag(json.ContactInstructions);
    }
  };
  /**
   * @class
   * Create Phone object
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var Phone = function (json) {
    if (json === undefined) {
      this.voice = null;
      this.facsimile = null;
    } else {
      this.voice = WMTSMetadata.parseVoice(json.Voice);
      this.facsimile = WMTSMetadata.parsePhone(json.Facsimile);
    }
  };
  /**
   * @class
   * Create Address object
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var Address = function (json) {
    if (json === undefined) {
      this.deliveryPoint = null;
      this.city = null;
      this.administrativeArea = null;
      this.postalCode = null;
      this.country = null;
      this.electronicMailAddress = null;
    } else {
      this.deliveryPoint = WMTSMetadata.getValueTag(json.DeliveryPoint);
      this.city = WMTSMetadata.getValueTag(json.City);
      this.administrativeArea = WMTSMetadata.getValueTag(json.AdministrativeArea);
      this.postalCode = WMTSMetadata.getValueTag(json.PostalCode);
      this.country = WMTSMetadata.getValueTag(json.Country);
      this.electronicMailAddress = WMTSMetadata.getValueTag(json.ElectronicMailAddress);
    }
  };
  /**
   * @class
   * Create Contents object
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var Contents = function (json) {
    if (json === undefined) {
      this.layers = null;
      this.tileMatrixSets = null;
    } else {
      this.layers = WMTSMetadata.parseLayer(json.Layer);
      this.tileMatrixSets = new TileMatrixSet(json.TileMatrixSet);
    }
  };
  /**
   * @class
   * Create Layer object
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var Layer = function (json) {
    if (json === undefined) {
      this.identifier = null;
      this.format = null;
      this.infoFormat = null;
      this.style = null;
      this.tileMatrixSetLink = null;
      this.title = null;
      this.abstract = null;
      this.wgs84BoundingBox = null;
      this.boundingBox = null;
      this.keywords = null;
      this.metadata = null;
      this.datasetDescriptionSummary = null;
      this.otherSource = null;
      this.dimension = null;
      this.resourceURL = null;
    } else {
      this.identifier = WMTSMetadata.getValueTag(json.Identifier);
      this.format = WMTSMetadata.parseFormat(json.Format);
      this.infoFormat = null;
      this.style = null;
      this.tileMatrixSetLink = WMTSMetadata.parseTileMatrixSetLink(json.TileMatrixSetLink);
      this.title = WMTSMetadata.getValueTag(json.Title);
      this.abstract = WMTSMetadata.getValueTag(json.Abstract);
      this.wgs84BoundingBox = WMTSMetadata.parseWGS84BoundingBox(json.WGS84BoundingBox);
      this.boundingBox = WMTSMetadata.parseBoundingBox(json.BoundingBox);
      this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
      this.metadata = null;
      this.datasetDescriptionSummary = null;
      this.otherSource = null;
      this.dimension = null;
      this.resourceURL = null;
    }
  };
  /**
   * @class
   * Create TileMatrixSet object
   * @param {string} json
   * @constructor
   * @memberof WMTSMetadata#
   */


  var TileMatrixSet = function (json) {
    this.identifier = null;
    this.supportedCRS = null;
    this.wellKnownScaleSet = null;
    this.tileMatrix = null;
  };
  /**
   * Parses layer element
   * @param {string} json
   * @returns {Layer[]} Returns Array of Layer object
   * @function parseLayer
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseLayer = function (json) {
    var layers = [];

    if (json === undefined) ; else if (Array.isArray(json)) {
      for (var i = 0; i < json.length; i++) {
        layers.push(new Layer(json[i]));
      }
    } else {
      layers.push(new Layer(json));
    }

    return layers;
  };
  /**
   * Parses TileMatrixSetLink element
   * @param {string} json
   * @returns {string[]} Returns array of parseTileMatrixSetLink value.
   * @function parseTileMatrixSetLink
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseTileMatrixSetLink = function (json) {
    var tileMatrixSetLink = [];

    if (json === undefined) ; else if (Array.isArray(json)) {
      for (var i = 0; i < json.length; i++) {
        tileMatrixSetLink.push(WMTSMetadata.getValueTag(json.TileMatrixSet[i]));
      }
    } else {
      tileMatrixSetLink.push(WMTSMetadata.getValueTag(json.TileMatrixSet));
    }

    return tileMatrixSetLink;
  };
  /**
   * Parses Format element
   * @param {string} json
   * @returns {string[]} Array of format.
   * @function parseFormat
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseFormat = function (json) {
    var formats = [];

    if (json === undefined) ; else if (Array.isArray(json)) {
      for (var i = 0; i < json.length; i++) {
        formats.push(WMTSMetadata.getValueTag(json.Format[i]));
      }
    } else {
      formats.push(WMTSMetadata.getValueTag(json));
    }

    return formats;
  };
  /**
   * Get Value
   * @param {string} json
   * @returns {string} Returns the value
   * @function getValueTag
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.getValueTag = function (json) {
    var result;

    if (json !== undefined) {
      result = json.hasOwnProperty("_text") ? WMTSMetadata.getText(json) : WMTSMetadata.getValue(json);
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Get Text
   * @param {string} json
   * @return {string} Returns the text
   * @function getText
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.getText = function (keyword) {
    return keyword._text;
  };
  /**
   * Get Value
   * @param {string} json
   * @returns {string} Returns the value
   * @function getValue
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.getValue = function (keyword) {
    return keyword._value;
  };
  /**
   * Parses keyword list
   * @param {string} json
   * @returns {string[]} Returns the array of keyword.
   * @function parseKeywordList
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseKeywordList = function (keywordsJson) {
    var keywords = [];

    if (keywordsJson !== undefined && keywordsJson.hasOwnProperty("Keyword")) {
      if (Array.isArray(keywordsJson.Keyword)) {
        for (var keyword in keywordsJson.Keyword) {
          keywords.push(WMTSMetadata.getValueTag(keywordsJson.Keyword[keyword]));
        }
      } else {
        keywords.push(WMTSMetadata.getValueTag(keywordsJson.Keyword));
      }
    }

    return keywords;
  };
  /**
   * Parses Voice
   * @param {string} json
   * @returns {string[]} Returns the array of voice
   * @function parseVoice
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseVoice = function (json) {
    var voices = [];

    if (json !== undefined && json.hasOwnProperty("Voice")) {
      if (Array.isArray(json.Voice)) {
        for (var voice in json.Voice) {
          voices.push(WMTSMetadata.getValueTag(json.Voice[voice]));
        }
      } else {
        voices.push(WMTSMetadata.getValueTag(json.Voice));
      }
    }

    return voices;
  };
  /**
   * Parses Fac simile element
   * @param {string} json
   * @returns {string[]} Returns the array of Facsimile
   * @function parseFacsimile
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseFacsimile = function (json) {
    var phones = [];

    if (json !== undefined && json.hasOwnProperty("Facsimile")) {
      if (Array.isArray(json.Facsimile)) {
        for (var facs in json.Facsimile) {
          phones.push(WMTSMetadata.getValueTag(json.Facsimile[facs]));
        }
      } else {
        phones.push(WMTSMetadata.getValueTag(json.Facsimile));
      }
    }

    return phones;
  };
  /**
   * Parses AccessConstraints element
   * @param {string} json
   * @return {string[]} Returns the array of AccessConstraints
   * @function parseAccessConstraints
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseAccessConstraints = function (json) {
    var acccessConstraints = [];

    if (json !== undefined && json.hasOwnProperty("AccessConstraints")) {
      if (Array.isArray(json.AccessConstraints)) {
        for (var access in json.AccessConstraints) {
          acccessConstraints.push(WMTSMetadata.getValueTag(json.AccessConstraints[access]));
        }
      } else {
        acccessConstraints.push(WMTSMetadata.getValueTag(json.AccessConstraints));
      }
    }

    return acccessConstraints;
  };
  /**
   * Parses WGS84BoundingBox element
   * @param {string} json
   * @returns {string[]} Returns the WGS84 bounding box
   * @function parseWGS84BoundingBox
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseWGS84BoundingBox = function (wgs84BoundingBoxJson) {
    var wgs84BoundingBox = [];

    if (wgs84BoundingBoxJson !== undefined) {
      if (Array.isArray(wgs84BoundingBoxJson)) {
        for (var i = 0; i < wgs84BoundingBoxJson.length; i++) {
          var wgs84 = wgs84BoundingBoxJson[i];
          wgs84BoundingBox.push({
            lowerCorner: WMTSMetadata.getValueTag(wgs84.LowerCorner),
            upperCorner: WMTSMetadata.getValueTag(wgs84.UpperCorner)
          });
        }
      } else {
        wgs84BoundingBox.push({
          lowerCorner: WMTSMetadata.getValueTag(wgs84BoundingBoxJson.LowerCorner),
          upperCorner: WMTSMetadata.getValueTag(wgs84BoundingBoxJson.UpperCorner)
        });
      }
    }

    return wgs84BoundingBox;
  };
  /**
   * Parses BoundingBox element
   * @param {string} json
   * @return {string[]} Returns the bounding box
   * @function parseBoundingBox
   * @memberof WMTSMetadata#
   * @private
   */


  WMTSMetadata.parseBoundingBox = function (BoundingBoxJson) {
    //TODO crs dimensions
    var boundingBox = [];

    if (BoundingBoxJson !== undefined) {
      if (Array.isArray(BoundingBoxJson)) {
        for (var i = 0; i < BoundingBoxJson.length; i++) {
          var bbox = BoundingBoxJson[i];
          boundingBox.push({
            lowerCorner: WMTSMetadata.getValueTag(bbox.LowerCorner),
            upperCorner: WMTSMetadata.getValueTag(bbox.UpperCorner)
          });
        }
      } else {
        boundingBox.push({
          lowerCorner: WMTSMetadata.getValueTag(BoundingBoxJson.LowerCorner),
          upperCorner: WMTSMetadata.getValueTag(BoundingBoxJson.UpperCorner)
        });
      }
    }

    return boundingBox;
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates an instance of WMTS server
   * A WMTS server exposes a set of {@link WMTSLayer WMTS} layers.
   * @param {Options} options Options
   * @param {string} [options.baseUrl] Base URL of the getCapabilities
   * @param {string} [options.getCapabilities] GetCapabilities
   * @memberof module:Registry
   */

  var WMTSServer = function (options) {
    if (options.getCapabilities) {
      options.baseUrl = Utils.computeBaseUrlFromCapabilities(options.getCapabilities, ["service", "request", "version"]);
    } else if (options.baseUrl) {
      options.getCapabilities = WMTSServer.getCapabilitiesFromBaseURl(options.baseUrl, options);
    } else {
      throw new ReferenceError("No URL to access to the server is defined", "WMSLayer.js");
    }

    this.options = options;
  };
  /**
   * Skip when the current layer is not included in the list of defined layers (layersFromConf)
   * @param {string[]} layersFromConf List of user-defined layer
   * @param {string} currentLayer
   * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
   * @function _mustBeSkipped
   * @memberof WMTSServer#
   * @private
   */


  function _mustBeSkipped$1(layersFromConf, currentLayer) {
    return layersFromConf.length !== 0 && !_$1.contains(layersFromConf, currentLayer.identifier) || !_$1.contains(currentLayer.tileMatrixSetLink, "WGS84");
  }
  /**
   * Returns the metadata
   * @param {metadata~requestCallback} callback
   * @param {serverLayerFallback} fallback
   * @function getMetadata
   * @memberof WMTSServer#
   */


  WMTSServer.prototype.getMetadata = function (callback, fallback) {
    var self = this;
    Utils.requestUrl(this.options.getCapabilities, "text", "application/xml", {}, function (response) {
      var myOptions = {
        mergeCDATA: true,
        xmlns: false,
        attrsAsObject: false,
        childrenAsArray: false
      };
      var result = xmlToJSON_1.parseString(response, myOptions);
      var metadata = new WMTSMetadata(result);
      callback(self.options, metadata);
    }, function (e) {
      if (fallback) {
        e.setLayerDescription(self.options);
        fallback(e);
      }
    });
  };
  /**
   * Create WMS layers from WMS capabilities
   * @param {serverLayerCallback} callback
   * @param {serverLayerFallback} fallback
   * @function createLayers
   * @memberof WMTSServer#
   */


  WMTSServer.prototype.createLayers = function (callback, fallback) {
    this.getMetadata(function (layerDescription, metadata) {
      var layersFromConf = layerDescription.hasOwnProperty("layers") ? layerDescription.layers.trim().split(/\s*,\s*/) : [];
      var jsonLayers = metadata.contents;
      var layers = [];

      for (var i = 0; i < jsonLayers.layers.length; i++) {
        var jsonLayer = jsonLayers.layers[i];

        if (_mustBeSkipped$1.call(this, layersFromConf, jsonLayer)) {
          continue;
        }

        var attribution;

        if (layerDescription.attribution) {
          attribution = layerDescription.attribution;
        } else {
          attribution = null;
        }

        var copyrightURL = null;
        var layerDesc = Object.assign({}, layerDescription, {});
        layerDesc.name = layerDescription.name || jsonLayer.identifier;
        layerDesc.format = layerDescription.format || "image/png";
        layerDesc.layers = jsonLayer.title;
        layerDesc.description = layerDescription.description || jsonLayer.abstract != null ? jsonLayer.abstract : jsonLayers.abstract;
        layerDesc.attribution = attribution;
        layerDesc.copyrightUrl = copyrightURL;
        var layer = LayerFactory.create(layerDesc);
        layers.push(layer);
      }

      callback(layers);
    }, fallback);
  };
  /**
   * Returns the capabilities
   * @param {string} baseUrl GetCapabilities URL
   * @param {Object} options
   * @param {string} [options.version = 1.0.0] WCS version
   * @function getCapabilitiesFromBaseURL
   * @memberof WMTServer#
   * @returns {string} describeCoverage URL
   */


  WMTSServer.getCapabilitiesFromBaseURl = function (baseUrl, options) {
    var getCapabilitiesUrl = baseUrl;
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "service", "WMTS");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "request", "getCapabilities");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "version", options.hasOwnProperty("version") ? options.version : "1.0.0");
    return getCapabilitiesUrl;
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Creates a WMTS handler to create {@link WMTSLayer WMTS layers}
   * @param {*} pendingLayers
   * @augments AbstractRegistryHandler
   * @memberof module:Registry
   * @see {@link WMTSServer}
   * @constructor
   */

  var WMTSServerRegistryHandler = function (pendingLayers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, WMTSServerRegistryHandler);
  /**************************************************************************************************************/

  /**
   * @function handleRequest
   * @memberof WMTSServerRegistryHandler#
   */

  WMTSServerRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    try {
      if (layerDescription.type === Constants.LAYER.WMTS) {
        var wmtsServer = new WMTSServer(layerDescription);
        var self = this;
        wmtsServer.createLayers(function (layers) {
          //TODO : I loose the callback of pendingLayers
          self._handlePendingLayers(self.pendingLayers, layers);

          callback(layers);
        }, fallback);
      } else {
        this.next.handleRequest(layerDescription, callback, fallback);
      }
    } catch (e) {
      if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "WMTSServerRegistryHandler.js", e);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates an instance of WCS server
   * A WCS server exposes a set of {@link WCSElevationLayer WCS} layers.
   * @param {Options} options Options
   * @param {string} [options.baseUrl] Base URL of the getCapabilities
   * @param {string} [options.getCapabilities] GetCapabilities
   * @constructor
   * @memberof module:Registry
   */

  var WCSServer = function (options) {
    if (options.getCapabilities) {
      options.baseUrl = Utils.computeBaseUrlFromCapabilities(options.getCapabilities, ["service", "request", "version"]);
    } else if (options.baseUrl) {
      options.getCapabilities = WCSServer.getCapabilitiesFromBaseURL(options.baseUrl, options);
    } else {
      throw new ReferenceError("No URL to access to the server is defined", "WCSServer.js");
    }

    options.describeCoverage = WCSServer.describeCoverageFromBaseURL(options.baseUrl, options);
    this.options = options;
  };
  /**
   * Skip when the current layer is not included in the list of defined layers (layersFromConf)
   * @param {string[]} layersFromConf List of user-defined layer
   * @param {string} currentLayer
   * @returns {boolean} true wen the currentLayer is not included in the list of user-defined layers otherwise false
   * @function _mustBeSkipped
   * @memberof WCSServer#
   * @private
   */


  function _mustBeSkipped$2(layersFromConf, currentLayer) {
    return layersFromConf.length !== 0 && !_$1.contains(layersFromConf, currentLayer.name._text);
  }
  /**
   * Converts a bbox string to an array of float.
   * @param {string[]} jsonBbox. bbox as string. First element is the lower left corner. 2nd element is the upper right corner
   * @returns {bbox_type} bbox as an array
   * @function _bbox
   * @memberof WCSServer#
   * @private
   */


  function _bbox$1(jsonBbox) {
    var pos = jsonBbox.pos;

    var pos1 = pos[0]._text.split(" ");

    var pos2 = pos[1]._text.split(" ");

    return [parseFloat(pos1[0]), parseFloat(pos1[1]), parseFloat(pos2[0]), parseFloat(pos2[1])];
  }
  /**
   * @typedef bbox_type
   * @type {array}
   * @property {string} 0 longitude in degee of the lower left corner.
   * @property {string} 1 latitude in degee of the lower left corner.
   * @property {string} 2 longitude in degee of the upper right corner.
   * @property {string} 3 latitude in degee of the upper right corner.
   */

  /**
   * @typedef center_type
   * @type {array}
   * @property {string} 0 longitude in degee.
   * @property {string} 1 latitude in degee.
   * @property {string} 2 distance from ground in meter.
   */

  /**
   * Computes the bbox center.
   * if bbox is null then center is defined as [0,0, 100000]
   * @param {bbox_type|null} bbox
   * @returns {center_type} the central position of the camera and the distance from which the bbox is embedded
   * @function _computeCenterBbox
   * @memberof WCSServer#
   * @private
   */


  function _computeCenterBbox$1(bbox) {
    var center;

    if (bbox == null) {
      center = [0, 0, 100000];
    } else {
      var centerLong = 0.5 * (bbox[0] + bbox[2]);
      var centerLat = 0.5 * (bbox[1] + bbox[3]);
      var deltaLong = bbox[2] - bbox[0];

      if (deltaLong > 180) {
        deltaLong = 180;
      }

      var deltaLat = bbox[3] - bbox[1];
      var delta = deltaLong > deltaLat ? deltaLat : deltaLong;
      var distance = Math.abs(delta) * 3000000 / 180;
      center = [centerLong, centerLat, distance];
    }

    return center;
  }
  /**
   * Returns the time values seprated with a comma.
   * @param {*} lonlat
   * @returns {string} time seprated by a value
   * @function _timeVal
   * @memberof WCSServer#
   * @private
   */


  function _timeVal(lonlat) {
    var values;

    if (lonlat.timePosition == null) {
      values = null;
    } else {
      var timeArr = [];
      var time = lonlat.timePosition;

      for (var i = 0; i < time.length; i++) {
        timeArr.push(time[i]._text);
      }

      values = timeArr.join(",");
    }

    return values;
  }
  /**
   * Returns the metadata
   * @param {metadata~requestCallback} callback
   * @param {serverLayerFallback} fallback
   * @function getMetadata
   * @memberof WCSServer#
   */


  WCSServer.prototype.getMetadata = function (callback, fallback) {
    var self = this;
    Utils.requestUrl(this.options.getCapabilities, "text", "application/xml", {}, function (response) {
      var myOptions = {
        mergeCDATA: true,
        xmlns: false,
        attrsAsObject: false,
        childrenAsArray: false
      };
      var metadata = xmlToJSON_1.parseString(response, myOptions);
      callback(self.options, metadata);
    }, function (e) {
      if (fallback) {
        e.setLayerDescription(self.options);
        fallback(e);
      }
    });
  };
  /**
   * Returns the coverage
   * @param {*} callback
   * @param {*} fallback
   * @function getCoverage
   * @memberof WCSServer#
   */


  WCSServer.prototype.getCoverage = function (callback, fallback) {
    var self = this;
    Utils.requestUrl(this.options.describeCoverage, "text", "application/xml", {}, function (response) {
      var myOptions = {
        mergeCDATA: true,
        xmlns: false,
        attrsAsObject: false,
        childrenAsArray: false
      };
      var metadata = xmlToJSON_1.parseString(response, myOptions);
      callback(self.options, metadata);
    }, function (e) {
      if (fallback) {
        e.setLayerDescription(self.options);
        fallback(e);
      }
    });
  };
  /**
   * This callback creates the layers from the WCS capabilities.
   * @callback metadata~requestCallback
   * @param {string} layerDescription layerDescription
   * @param {string} metadata WCS capabiilties
   */

  /**
   * Create WCS layers from WCS capabilities
   * @param {serverLayerCallback} callback
   * @param {serverLayerFallback} fallback
   * @function createLayers
   * @memberof WCSServer#
   */


  WCSServer.prototype.createLayers = function (callback, fallback) {
    this.getMetadata(function (layerDescription, metadata) {
      // extracts layers from layer description if set
      var layersFromConf = layerDescription.hasOwnProperty("layers") ? layerDescription.layers.trim().split(/\s*,\s*/) : []; // retrieves the list of layers from capabilities

      var jsonLayers = [];
      var contentMetadata = metadata.WCS_Capabilities.ContentMetadata;

      if (Array.isArray(contentMetadata.CoverageOfferingBrief)) {
        jsonLayers = contentMetadata.CoverageOfferingBrief;
      } else {
        jsonLayers.push(contentMetadata);
      } // iter on each layer


      var layers = [];

      for (var i = 0; i < jsonLayers.length; i++) {
        // get a layer
        var jsonLayer = jsonLayers[i].CoverageOfferingBrief;

        if (_mustBeSkipped$2.call(this, layersFromConf, jsonLayer)) {
          continue;
        } // get attribution


        var attribution;

        if (layerDescription.attribution) {
          attribution = layerDescription.attribution;
        } else {
          attribution = null;
        } // no copyright information from WCS capabilities


        var copyrightURL = null; // clone the layerDescription and fill it

        var layerDesc = Object.assign({}, layerDescription, {});
        layerDesc.name = layerDescription.name || jsonLayer.label._text;
        layerDesc.format = layerDescription.format;
        layerDesc.layers = jsonLayer.name._text;
        layerDesc.description = layerDescription.description;
        layerDesc.attribution = attribution;
        layerDesc.copyrightUrl = copyrightURL;

        var bbox = _bbox$1.call(this, jsonLayer.lonLatEnvelope);

        var center = _computeCenterBbox$1.call(this, bbox);

        layerDesc.properties = {
          initialRa: center[0],
          initialDec: center[1],
          initialFov: center[2],
          bbox: bbox
        }; // extract time capabilities and fillt the layer description

        var timeValue = _timeVal.call(this, jsonLayer.lonLatEnvelope);

        layerDesc.dimension = {};

        if (timeValue != null) {
          layerDesc.dimension.time = {
            units: "ISO8601",
            unitSymbol: null,
            default: null,
            multipleValues: null,
            nearestValue: null,
            current: null,
            value: timeValue
          };
        }

        layerDesc.metadataAPI = jsonLayer; // get the first value of the time range

        if (layerDesc.dimension.time && layerDesc.dimension.time.value != null) {
          layerDesc.time = layerDesc.dimension.time.value.split(",")[0];
        } // create the layer


        var layer = LayerFactory.create(layerDesc);
        layers.push(layer);
      }

      callback(layers);
    }, fallback);
  };
  /**
   * Returns the capabilities
   * @param {string} baseUrl GetCapabilities URL
   * @param {Object} options
   * @param {string} [options.version = 1.0.0] WCS version
   * @function getCapabilitiesFromBaseURL
   * @memberof WCSServer#
   * @returns {string} describeCoverage URL
   */


  WCSServer.getCapabilitiesFromBaseURL = function (baseUrl, options) {
    var getCapabilitiesUrl = baseUrl;
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "service", "WCS");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "request", "getCapabilities");
    getCapabilitiesUrl = Utils.addParameterTo(getCapabilitiesUrl, "version", options.hasOwnProperty("version") ? options.version : "1.0.0");
    return getCapabilitiesUrl;
  };
  /**
   * Describes the coverage
   * @param {string} baseUrl describeCoverage URL
   * @param {Object} options Options
   * @param {string} [options.version = 1.0.0] WCS version
   * @function describeCoverageFromBaseURL
   * @memberof WCSServer#
   * @returns {string} describeCoverage URL
   */


  WCSServer.describeCoverageFromBaseURL = function (baseUrl, options) {
    var describeCoverageUrl = baseUrl;
    describeCoverageUrl = Utils.addParameterTo(describeCoverageUrl, "service", "WCS");
    describeCoverageUrl = Utils.addParameterTo(describeCoverageUrl, "request", "describeCoverage");
    describeCoverageUrl = Utils.addParameterTo(describeCoverageUrl, "version", options.hasOwnProperty("version") ? options.version : "1.0.0");
    return describeCoverageUrl;
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates a WCS Server Handler
   * @param {*} layers
   * @param {*} pendingLayers
   * @augments AbstractRegistryHandler
   * @memberof module:Registry
   * @constructor
   */

  var WCSServerRegistryHandler = function (layers, pendingLayers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.layers = layers;
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, WCSServerRegistryHandler);
  /**************************************************************************************************************/

  /**
   * Destroys the TileWireFrame if it exists and returns its layer description.
   * @param layers list of layers to load
   * @function _destroyTileWireFrame
   * @memberof WCSServerRegistryHandler#
   * @private
   */

  function _destroyTileWireFrame(layers) {
    var i, layerDescription;
    var isFound = false;

    for (i = 0; i < layers.length; i++) {
      var layer = layers[i];

      if (layer.getType() === Constants.LAYER.TileWireframe) {
        isFound = true;
        break;
      }
    }

    if (isFound) {
      var layerToRemove = layers[i];
      layerDescription = layerToRemove.options;

      layerToRemove._detach();

      layers.splice(i, 1);
    }

    return layerDescription;
  }
  /**
   * Moves the TileWireFrameLayer to render at this end.
   * @param layers layers to render
   * @param AbstractRegistryHandler Registry
   * @param callback callback
   * @param fallback fallback
   * @function _moveTileWireFrameLayer
   * @memberof WCSServerRegistryHandler#
   * @private
   */


  function _moveTileWireFrameLayer(layers, AbstractRegistryHandler, callback, fallback) {
    var layerDescription = _destroyTileWireFrame(layers);

    if (layerDescription) {
      AbstractRegistryHandler.next.handleRequest(layerDescription, callback, fallback);
    }
  }
  /**
   * @function handleRequest
   * @memberof WCSServerRegistryHandler#
   */


  WCSServerRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    try {
      if (layerDescription.type === Constants.LAYER.WCSElevation) {
        var wcsServer = new WCSServer(layerDescription);
        var self = this;
        wcsServer.createLayers(function (layers) {
          //TODO : I loose the callback of pendingLayers
          self._handlePendingLayers(self.pendingLayers, layers);

          callback(layers);

          _moveTileWireFrameLayer(self.layers, self, callback, fallback);
        }, fallback);
      } else {
        this.next.handleRequest(layerDescription, callback, fallback);
      }
    } catch (e) {
      if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, e);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name OpenSearchParam
   * @class
   * All informations describing a parameter in an OpenSearch form
   * @param {Object} a json object describing the param
   * @memberof module:Layer
   */

  var OpenSearchParam = function (paramJson) {
    // init all values
    this.name = null; // Name of parameters

    this.value = null; // Value identifying the parameters

    this.title = null; // Title of parameter (for display)

    this.minInclusive = null; // (Level 1 Control - Number) Min value inclusive

    this.maxInclusive = null; // (Level 1 Control - Number) Max value inclusive

    this.pattern = null; // (Level 1 Control - String) Pattern

    this.options = null; // List of values if list provided

    this.currentValue = null; // Value to pass to parameter

    this.defaultValue = null; // Default value

    this.displayValue = ""; // Display value

    this.parseJson(paramJson);
  };
  /**************************************************************************************************************/

  /**
   * Parse Json
   * @function parseJson
   * @memberof OpenSearchParam#
   * @param {Object} paramJson Json object
   */


  OpenSearchParam.prototype.parseJson = function (paramJson) {
    this.name = OpenSearchUtils.getAttributeValue(paramJson, "name");
    this.name = this.name.replace(/\./g, "_");
    this.value = OpenSearchUtils.getAttributeValue(paramJson, "value");
    this.title = OpenSearchUtils.getAttributeValue(paramJson, "title");
    this.minInclusive = OpenSearchUtils.getAttributeValue(paramJson, "minInclusive");
    this.maxInclusive = OpenSearchUtils.getAttributeValue(paramJson, "maxInclusive");
    this.pattern = OpenSearchUtils.getAttributeValue(paramJson, "pattern");

    if (this.pattern === null) {
      this.patternAttribute = "";
    } else {
      this.patternAttribute = 'pattern="' + this.pattern + '" ';
    }

    if (paramJson.Option !== undefined) {
      this.options = [];

      if (paramJson.Option.length !== undefined) {
        for (var i = 0; i < paramJson.Option.length; i++) {
          this.options.push(OpenSearchUtils.getAttributeValue(paramJson.Option[i], "value"));
        }
      } else {
        this.options.push(OpenSearchUtils.getAttributeValue(paramJson.Option, "value"));
      }
    }

    if (this.options !== null) {
      this.type = "options";
    } else if (this.minInclusive !== null || this.maxInclusive !== null) {
      this.type = "number";

      if (this.title === null) {
        this.title = "";
      }

      if (this.maxInclusive === null) {
        this.title += "( >= " + this.minInclusive + " )";
      } else if (this.minInclusive === null) {
        this.title += "( <= " + this.maxInclusive + " )";
      } else {
        this.title += "( between " + this.minInclusive + " and " + this.maxInclusive + " )";
      }
    } else if (this.value.startsWith("{time:") === true) {
      this.type = "datetime";
    } else {
      this.type = "text";
    }

    if (this.title === null) {
      this.titleAttribute = "";
    } else {
      this.titleAttribute = 'title="' + this.title + '" ';
    }
  };
  /**************************************************************************************************************/

  /**
   * Return string representation
   * @function toString
   * @memberof OpenSearchParam#
   * @return {string} String representation
   */


  OpenSearchParam.prototype.toString = function () {
    var res = "";

    if (this.name !== null) {
      res += "     name : " + this.name + "\n";
    }

    if (this.value !== null) {
      res += "     value : " + this.value + "\n";
    }

    if (this.title !== null) {
      res += "     title : " + this.title + "\n";
    }

    if (this.minInclusive !== null) {
      res += "     minInclusive : " + this.minInclusive + "\n";
    }

    if (this.maxInclusive !== null) {
      res += "     maxInclusive : " + this.maxInclusive + "\n";
    }

    if (this.pattern !== null) {
      res += "     pattern : " + this.pattern + "\n";
    }

    if (this.options != null) {
      res += "     options : ";

      for (var i = 0; i < this.options.length; i++) {
        res += this.options[i] + ", ";
      }

      res += "\n";
    }

    return res;
  };
  /**************************************************************************************************************/

  /**
   * Get current value transformed (from IHM to Request)
   * @function currentValueTransformed
   * @memberof OpenSearchParam#
   * @return {string} Current value transformed
   */


  OpenSearchParam.prototype.currentValueTransformed = function () {
    // Only for date time, all other : no change
    if (this.type !== "datetime") {
      return this.currentValue;
    }

    if (this.currentValue === null || typeof this.currentValue === "undefined") {
      return this.currentValue;
    }

    var deb = this.currentValue.substr(0, 10);
    var fin = this.currentValue.substr(-5);
    var res = deb + "T" + fin + ":00.00";
    return res;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name OpenSearchForm
   * @class
   * All informations describing an OpenSearch form
   * @param {Object} paramsJson a json object describing the form
   * @param {string} type form to load (application/json or application/atom+xml)
   * @memberof module:Layer
   */

  var OpenSearchForm = function (paramsJson, type) {
    // init all values
    this.type = null; // type of form (only application/json supported)

    this.template = null; // url template with params

    this.parameters = []; // list of params

    this.ignoredParameters = [];
    this.ignoredParameters.push("searchTerms");
    this.ignoredParameters.push("count");
    this.ignoredParameters.push("startIndex");
    this.ignoredParameters.push("startPage");
    this.ignoredParameters.push("language");
    this.ignoredParameters.push("inputEncoding");
    this.ignoredParameters.push("outputEncoding");

    var elts = _parseJson.call(this, paramsJson, type, this.ignoredParameters);

    if (elts !== null) {
      this.type = elts.type;
      this.template = elts.template;
      this.parameters = elts.parameters;
    }
  };
  /**
   * Parse the json
   * @param {Object} paramsJson Parameteres
   * @param {string} type Type
   * @param {Array} ignoredParameters parameters to ignore
   * @return {{type:string, template:Object, parameters:OpenSearchParam[]}|null}
   * @private
   */


  function _parseJson(paramsJson, type, ignoredParameters) {
    var elts;

    if (Array.isArray(paramsJson)) {
      // Management of an array
      for (var i = 0; i < paramsJson.length; i++) {
        elts = _parseUrl.call(this, paramsJson[i], type, ignoredParameters);

        if (elts !== null) {
          break;
        } else {
          elts = null;
        }
      }
    } else {
      elts = _parseUrl.call(this, paramsJson, type, ignoredParameters);
    }

    return elts;
  }
  /**
   * Parse url for request
   * @param {Objet} urlJson Json urls founded
   * @param {type} type Url type searched
   * @param {Array} ignoredParameters parameters to ignore
   * @return {{type:string, template:Object, parameters:OpenSearchParam[]}|null}
   * @private
   */


  function _parseUrl(urlJson, type, ignoredParameters) {
    var elts;
    var typeValue = OpenSearchUtils.getAttributeValue(urlJson, "type");

    if (typeValue !== type) {
      // Not the good type, do not take it into account
      elts = null;
    } else {
      elts = {
        type: typeValue,
        template: OpenSearchUtils.getAttributeValue(urlJson, "template"),
        parameters: _parseParameters.call(this, urlJson.Parameter, ignoredParameters)
      };
    }

    return elts;
  }
  /**
   * Parses parameters
   * @param {Objer[]} listParameters list of Opensearch parameters
   * @param {String[]} ignoredParameters parameters to not parse
   * @return {OpenSearchParam[]} List of OpenSearch parameters
   * @private
   */


  function _parseParameters(listParameters, ignoredParameters) {
    var parameters = [];

    if (Array.isArray(listParameters)) {
      for (var i = 0; i < listParameters.length; i++) {
        var param = new OpenSearchParam(listParameters[i]);
        param.isDisplayed = true;

        for (var j = 0; j < ignoredParameters.length; j++) {
          if (param.value === "{" + ignoredParameters[j] + "}") {
            param.isDisplayed = false;
          }
        }

        if (param.value.startsWith("{geo:")) {
          param.isDisplayed = false;
        }

        parameters.push(param);
      }
    } else {
      parameters.push(new OpenSearchParam(listParameters));
    }

    return parameters;
  }
  /**
   * Get a string representation of the form
   * @function toString
   * @memberof OpenSearchForm#
   * @return {string} String representation of the form
   */


  OpenSearchForm.prototype.toString = function () {
    var res = "";
    res += "  type : " + this.type + "\n";
    res += "  template : " + this.template + "\n";
    res += "  parameters :\n";

    for (var i = 0; i < this.parameters.length; i++) {
      res += this.parameters[i].toString() + "\n";
    }

    return res;
  };

  OpenSearchForm.prototype.setParametersValueFrom = function (properties) {
    _$1.each(this.parameters, function (parameter) {
      Object.keys(properties).forEach(function (key, index) {
        if (parameter.name === "p_" + key) {
          parameter.value = index[key];
        }
      });
    });
  };
  /**
   * Update form parameters from GUI form
   * @function updateFromGUI
   * @memberof OpenSearchForm#
   */


  OpenSearchForm.prototype.updateFromGUI = function () {
    for (var i = 0; i < this.parameters.length; i++) {
      var param = this.parameters[i];
      var val = $__default['default']("#p_" + param.name).val();

      if (val !== "") {
        param.currentValue = val;
      } else {
        param.currentValue = null;
      }
    }
  };

  /**
   * @class
   * Creates an instance of WMS server
   * A WMS server exposes a set of {@link OpenSearchLayer open search} layers.
   * @param {Options} options Options
   * @param {string} [options.baseUrl] Base URL of the getCapabilities
   * @param {string} [options.getCapabilities] GetCapabilities
   * @memberof module:Registry
   * @constructor
   */

  var OpenSearchServer = function (options) {
    // when url contains .xml, it means that the XML descriptor is there
    if (options.baseUrl && options.baseUrl.indexOf(".xml") !== -1) {
      options.getCapabilities = options.baseUrl;
    }

    if (!options.getCapabilities) {
      throw new ReferenceError("No URL to access to the server is defined", "OpenSearchServer.js");
    }

    this.options = options;
  };
  /**
   * Create layer
   * @param {*} layerDescription
   * @param {*} jsonLayer
   * @function _createLayer
   * @memberof OpenSearchServer#
   * @private
   */


  function _createLayer$1(layerDescription, openSearchRoot) {
    var layerDesc = Object.assign({}, layerDescription, {});
    layerDesc.name = layerDescription.name || OpenSearchUtils.getValue(openSearchRoot, "ShortName");
    layerDesc.description = layerDescription.description || OpenSearchUtils.getValue(openSearchRoot, "Description");
    layerDesc.attribution = layerDescription.attribution || OpenSearchUtils.getValue(openSearchRoot, "Attribution");
    layerDesc.properties = {};
    layerDesc.properties.longName = OpenSearchUtils.getValue(openSearchRoot, "LongName");
    layerDesc.properties.syndicationRight = OpenSearchUtils.getValue(openSearchRoot, "SyndicationRight");
    layerDesc.properties.developper = OpenSearchUtils.getValue(openSearchRoot, "Developper");
    var urls = openSearchRoot.Url;
    layerDesc.services = {};
    layerDesc.services.queryForm = new OpenSearchForm(urls, "application/json");
    OpenSearchUtils.initNavigationValues(layerDesc.services.queryForm);
    return LayerFactory.create(layerDesc);
  }
  /**
   * Create WMS layers from WMS capabilities
   * @param {serverLayerCallback} callback
   * @param {serverLayerFallback} fallback
   * @function createLayers
   * @memberof OpenSearchServer#
   */


  OpenSearchServer.prototype.createLayers = function (callback, fallback) {
    this.getMetadata(function (layerDescription, metadata) {
      var layers = [];
      var jsonLayer = metadata.OpenSearchDescription;

      var layer = _createLayer$1(layerDescription, jsonLayer);

      layers.push(layer);
      callback(layers);
    }, fallback);
  };

  OpenSearchServer.prototype.getMetadata = function (callback, fallback) {
    var self = this;
    Utils.requestUrl(this.options.getCapabilities, "text", "application/xml", {}, function (response) {
      var myOptions = {
        mergeCDATA: true,
        xmlns: false,
        attrsAsObject: false,
        childrenAsArray: false
      };
      var metadata = xmlToJSON_1.parseString(response, myOptions);
      callback(self.options, metadata);
    }, function (e) {
      if (fallback) {
        e.setLayerDescription(self.options);
        fallback(e);
      }
    });
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * Creates an OpenSearch handler to create {@link OpenSearchServer OpenSearch layers}
   * @param {*} pendingLayers
   * @augments AbstractRegistryHandler
   * @memberof module:Registry
   * @constructor
   * @see {@link WMSServer}
   */

  var OpenSearchRegistryHandler = function (pendingLayers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, OpenSearchRegistryHandler);
  /**************************************************************************************************************/

  /**
   * @function handleRequest
   * @memberof OpenSearchRegistryHandler#
   */

  OpenSearchRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    try {
      if (layerDescription.type === Constants.LAYER.OpenSearch) {
        var openSearchServer = new OpenSearchServer(layerDescription);
        var self = this;
        openSearchServer.createLayers(function (layers) {
          //TODO : I loose the callback of pendingLayers
          self._handlePendingLayers(self.pendingLayers, layers);

          callback(layers);
        }, fallback);
      } else {
        this.next.handleRequest(layerDescription, callback, fallback);
      }
    } catch (e) {
      if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "OpenSearchRegistryHandler.js", e);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * Creates a pending layer handler
   * @param {*} pendingLayers
   * @param {*} layers
   * @constructor
   * @augments AbstractRegistryHandler
   * @memberof module:Registry
   * @constructor
   */

  var PendingLayersRegistryHandler = function (pendingLayers, layers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.layers = layers;
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, PendingLayersRegistryHandler);
  /**************************************************************************************************************/

  /**
   * Check whether a layerbackground is already loaded.
   * @returns {boolean} true when the layer background is already defined otherwise false
   * @function hasLayerBackground
   * @memberof PendingLayersRegistryHandler#
   */

  PendingLayersRegistryHandler.prototype.hasLayerBackground = function () {
    var hasBackground = false;

    for (var i = 0; i < this.layers.length; i++) {
      var layer = this.layers[i];

      if (layer.isBackground()) {
        hasBackground = true;
        break;
      }
    }

    return hasBackground;
  };
  /**
   * @function handleRequest
   * @memberof PendingLayersRegistryHandler#
   */


  PendingLayersRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    if ((layerDescription.type === Constants.LAYER.Atmosphere || layerDescription.type === Constants.LAYER.TileWireframe) && !this.hasLayerBackground()) {
      this.pendingLayers.push(layerDescription);
    } else {
      this.next.handleRequest(layerDescription, callback, fallback);
    }
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @class
   * This handler processes the layerdescription as a simple {@link LayerFactory}
   * @param {string[]} pendingLayers List of pending layer description
   * @augments AbstractRegistryHandler
   * @constructor
   * @memberof module:Registry
   */

  var LayerRegistryHandler = function (pendingLayers) {
    AbstractRegistryHandler.prototype.constructor.call(this);
    this.pendingLayers = pendingLayers;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractRegistryHandler, LayerRegistryHandler);
  /**************************************************************************************************************/

  /**
   * @function handleRequest
   * @memberof LayerRegistryHandler#
   */

  LayerRegistryHandler.prototype.handleRequest = function (layerDescription, callback, fallback) {
    var layers = [];

    try {
      var layer = LayerFactory.create(layerDescription);
      layers.push(layer);

      this._handlePendingLayers(this.pendingLayers, layers);

      callback(layers);
    } catch (e) {
      if (e instanceof RangeError && this.next != null) {
        this.next.handleRequest(layerDescription, callback, fallback);
      } else if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.DEBUG, "Unknown error in LayerRegistryHanlder", e);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const MAX_ROTATION = 360;
  /**
   *    Private variables
   */

  var parentElement$1 = null;
  var ctx$3 = null;
  var crs = null;
  var svgDoc = null;
  /**************************************************************************************************************/

  /**
   * Aligns with north.
   * @param {object} event
   * @private
   */

  function _alignWithNorth(event) {
    var coordinateSystem = ctx$3.getCoordinateSystem();
    var radius = coordinateSystem.getGeoide().getRadius(); // scale the up direction to the sphere's surface in order to have the right value after projection.

    var up = [0, 0, radius];
    var temp = [];
    coordinateSystem.from3DToGeo(up, temp);
    temp = coordinateSystem.convert(temp, coordinateSystem.getGeoideName(), crs);
    coordinateSystem.fromGeoTo3D(temp, up);
    ctx$3.getNavigation().moveUpTo(up);
  }
  /**************************************************************************************************************/


  function updateNorthPlanet() {
    var navigation = ctx$3.getNavigation();
    var currentHeading = navigation.getHeading();
    var upHeading = 0;
    var degNorth = (currentHeading - upHeading + MAX_ROTATION) % MAX_ROTATION;
    var northText = svgDoc.getElementById("NorthText");
    northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
  }

  function updateNorthAzimuth() {
    var navigation = ctx$3.getNavigation();
    var currentHeading = navigation.getHeading();
    var upHeading = 0;
    var degNorth = (upHeading - currentHeading + MAX_ROTATION) % MAX_ROTATION;
    var northText = svgDoc.getElementById("NorthText");
    northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
  }

  function updateNorthSky() {
    var geo = [];
    var coordinateSystem = ctx$3.getCoordinateSystem();
    var center = ctx$3.getNavigation().center3d ? ctx$3.getNavigation().center3d : ctx$3.getNavigation().geoCenter;
    coordinateSystem.from3DToGeo(center, geo);
    geo = coordinateSystem.convert(geo, crs, coordinateSystem.getGeoideName());
    var LHV = [];
    coordinateSystem.getLHVTransform(geo, LHV);
    var temp = [];
    var north = [LHV[4], LHV[5], LHV[6]];
    var vertical = [LHV[8], LHV[9], LHV[10]];
    var up = vec3.create(ctx$3.getNavigation().up);
    vec3.scale(up, coordinateSystem.getGeoide().getRadius());
    coordinateSystem.from3DToGeo(up, temp);
    temp = coordinateSystem.convert(temp, crs, coordinateSystem.getGeoideName());
    coordinateSystem.fromGeoTo3D(temp, up);
    vec3.normalize(up); // Find angle between up and north

    var cosNorth = vec3.dot(up, north) / (vec3.length(up) * vec3.length(north));
    var radNorth = Math.acos(cosNorth);

    if (isNaN(radNorth)) {
      return;
    }

    var degNorth = Numeric.toDegree(radNorth); // Find sign between up and north

    var sign;
    vec3.cross(up, north, temp);
    sign = vec3.dot(temp, [vertical[0], vertical[1], vertical[2]]);

    if (sign < 0) {
      degNorth *= -1;
    }

    var northText = svgDoc.getElementById("NorthText");
    northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
  }
  /**
   * Function updating the north position on compass
   */


  function updateNorth() {
    var mode = ctx$3.getMode();

    switch (mode) {
      case Constants.CONTEXT.Sky:
        updateNorthSky();
        break;

      case Constants.CONTEXT.Planet:
        updateNorthPlanet();
        break;

      case Constants.CONTEXT.Ground:
        updateNorthAzimuth();
        break;

      default:
        throw new RangeError("CompassCore.js: CompassCore is not supported for this context");
    }
  }
  /**************************************************************************************************************/

  /**
   *    Remove compass element
   *
   */


  function remove$3() {
    document.getElementById(parentElement$1).innerHTML = "";
  }
  /**************************************************************************************************************/


  var CompassCore = {
    init: function (options) {
      parentElement$1 = options.element; //ctx = options.ctx;
      //crs = ctx.getCoordinateSystem().getGeoideName();
      //svgDoc = options.svgDoc;
    },
    setSvg: function (svg) {
      svgDoc = svg;
    },
    setCtx: function (context) {
      ctx$3 = context;
      crs = context.getCoordinateSystem().getGeoideName();
    },
    updateNorth: updateNorth,
    _alignWithNorth: _alignWithNorth,
    remove: remove$3
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const COMPASS_SVG = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0idGV4dC9jc3MiIGhyZWY9ImNvbXBhc3MuY3NzIj8+PHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjUyMCIKICAgaGVpZ2h0PSI1MjAiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuNDguMSByOTc2MCIKICAgc29kaXBvZGk6ZG9jbmFtZT0iY29tcGFzc05vcnRoMi5zdmciCiAgIHZpZXdCb3g9Ii0yMjAgLTIyMCA1MjAgNTIwIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczQzIj4KICAgIDxyYWRpYWxHcmFkaWVudAogICAgICAgaWQ9ImdyYWQxIgogICAgICAgY3g9IjAiCiAgICAgICBjeT0iMCIKICAgICAgIHI9IjIwNyIKICAgICAgIGZ4PSIwIgogICAgICAgZnk9IjAiCiAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wCiAgICAgICAgIG9mZnNldD0iMC43NSIKICAgICAgICAgaWQ9InN0b3A2IgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojZmZmZmZmO3N0b3Atb3BhY2l0eTowIiAvPgogICAgICA8c3RvcAogICAgICAgICBvZmZzZXQ9IjAuOTQ5OTk5OTkiCiAgICAgICAgIGlkPSJzdG9wOCIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2ZmOTkwMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3AKICAgICAgICAgb2Zmc2V0PSIxMDAlIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjpyZ2IoMjU1LCAyNTUsIDI1NSk7c3RvcC1vcGFjaXR5OjAiCiAgICAgICAgIGlkPSJzdG9wMTAiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEyODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwMCIKICAgICBpZD0ibmFtZWR2aWV3NDEiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjAuNDEzMTgxODMiCiAgICAgaW5rc2NhcGU6Y3g9IjEwMy43NDIwNiIKICAgICBpbmtzY2FwZTpjeT0iNDguNTQ5MDc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkVhc3QiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpndWlkZS1iYm94PSJ0cnVlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMwMTAiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPGcKICAgICBpZD0iT3V0ZXJDaXJjbGUiCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4xNDI4MTM4LDAsMCwxLjEwNTc4OCwwLjMwODI3MzYsNC42MTQ3ODQpIj4KICAgIDxnCiAgICAgICBpZD0iZzMyNjciCiAgICAgICBzdHlsZT0ib3BhY2l0eTowLjYiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOmN5PSIwIgogICAgICAgICBzb2RpcG9kaTpjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJtIDIwNywwIGMgMCwxMTQuMzIyOTQgLTkyLjY3NzA2LDIwNyAtMjA3LDIwNyAtMTE0LjMyMjk0LDAgLTIwNywtOTIuNjc3MDYgLTIwNywtMjA3IDAsLTExNC4zMjI5NCA5Mi42NzcwNiwtMjA3IDIwNywtMjA3IDExNC4zMjI5NCwwIDIwNyw5Mi42NzcwNiAyMDcsMjA3IHoiCiAgICAgICAgIGlkPSJjaXJjbGUyNCIKICAgICAgICAgcj0iMjA3IgogICAgICAgICBzdHlsZT0ib3BhY2l0eTowLjc1O2ZpbGw6dXJsKCNncmFkMSkiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMTA1MjI3OSwwLDAsMS4xMDUyMjc5LDM0LDMyKSIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzE4IgogICAgICAgc3R5bGU9InN0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxMCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuOTY1NTg4OTksMCwwLDAuOTcxMzI0MTUsMzQsMzIpIj4KICAgICAgPGNpcmNsZQogICAgICAgICByPSIyMTEiCiAgICAgICAgIGlkPSJjaXJjbGUyMCIKICAgICAgICAgZD0ibSAyMTEsMCBjIDAsMTE2LjUzMjA4IC05NC40Njc5MiwyMTEgLTIxMSwyMTEgLTExNi41MzIwOCwwIC0yMTEsLTk0LjQ2NzkyIC0yMTEsLTIxMSAwLC0xMTYuNTMyMDggOTQuNDY3OTIsLTIxMSAyMTEsLTIxMSAxMTYuNTMyMDgsMCAyMTEsOTQuNDY3OTIgMjExLDIxMSB6IgogICAgICAgICBjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6cng9IjIxMSIKICAgICAgICAgc29kaXBvZGk6cnk9IjIxMSIgLz4KICAgIDwvZz4KICA8L2c+CiAgPGcKICAgICBpZD0iU291dGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjU3ODM4MywzNi45NzA0MzUpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ciCiAgICAgICBkPSJNIDM5LjQxNiw5NS4xNiBDIDMzLjY1LDEwMy45NSAzMC43NiwxMTAuNSAyOC45MywxMTcuMTggMTUuMjQsMTEzLjQzIDEzLjU0LDEyNy4xNSAyMy4wNCwxMzEgMTMuNzEsMTQ1LjggNy44NCwxNzMuOTMgMCwyMTIgTCAwLDEwMyBhIDEwMywxMDMgMCAwIDAgMzkuNDE2LC03Ljg0IHoiIC8+CiAgICA8dXNlCiAgICAgICBoZWlnaHQ9IjQ0MCIKICAgICAgIHdpZHRoPSI0NDAiCiAgICAgICB5PSIwIgogICAgICAgeD0iMCIKICAgICAgIGlkPSJzb3V0aCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93IiAvPgogIDwvZz4KICA8ZwogICAgIGlkPSJFYXN0IgogICAgIGNsYXNzPSJhcnJvdyIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDEsLTEsMCwzOC44MDYyMSwzNy4yMjA0MjkpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNiIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZiIKICAgICAgIGlkPSJzb3V0aC01IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNiIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iTm9ydGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwtMSw0MS45MDI3OCw0My43ODMzNzYpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNi0wIgogICAgICAgZD0iTSAzOS40MTYsOTUuMTYgQyAzMy42NSwxMDMuOTUgMzAuNzYsMTEwLjUgMjguOTMsMTE3LjE4IDE1LjI0LDExMy40MyAxMy41NCwxMjcuMTUgMjMuMDQsMTMxIDEzLjcxLDE0NS44IDcuODQsMTczLjkzIDAsMjEyIEwgMCwxMDMgYSAxMDMsMTAzIDAgMCAwIDM5LjQxNiwtNy44NCB6IiAvPgogICAgPHVzZQogICAgICAgaGVpZ2h0PSI0NDAiCiAgICAgICB3aWR0aD0iNDQwIgogICAgICAgeT0iMCIKICAgICAgIHg9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmIgogICAgICAgaWQ9InNvdXRoLTUtNiIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93LTYtMCIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iV2VzdCIKICAgICBjbGFzcz0iYXJyb3ciCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwxLDAsMzcuMzc0NzU4LDM5LjU0NzAyMykiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaWQ9IkhhbGZBcnJvdy02LTAtNSIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgaWQ9InNvdXRoLTUtNi0yIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNi0wLTUiIC8+CiAgPC9nPgogIDx0ZXh0CiAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICBzdHlsZT0iZm9udC1zaXplOjkwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7Zm9udC1mYW1pbHk6VGltZXMgTmV3IFJvbWFuOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246J1RpbWVzIE5ldyBSb21hbiwgQm9sZCciCiAgICAgeD0iMTkuMjU0ODc1IgogICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgaWQ9Ik5vcnRoVGV4dCIKICAgICBzb2RpcG9kaTpsaW5lc3BhY2luZz0iMTMwJSIKICAgICB0cmFuc2Zvcm09InNjYWxlKDEuMDA4MzY2NSwwLjk5MTcwMjkyKSI+PHRzcGFuCiAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgaWQ9InRzcGFuMzAyNCIKICAgICAgIHg9IjE5LjI1NDg3NSIKICAgICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjgwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjFweDtmb250LWZhbWlseTpUaW1lcyBOZXcgUm9tYW47LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjonVGltZXMgTmV3IFJvbWFuLCBCb2xkJyI+TjwvdHNwYW4+PC90ZXh0PgogIDxnCiAgICAgaWQ9IklubmVyQ2lyY2xlIgogICAgIHN0eWxlPSJvcGFjaXR5OjAuNiIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOS4yNjA3MjYsNDEuMjEwMTIxKSI+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OCIKICAgICAgIGlkPSJnNyI+CiAgICAgIDxjaXJjbGUKICAgICAgICAgc29kaXBvZGk6cng9Ijc1IgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJNIDc1LDAgQyA3NSw0MS40MjEzNTYgNDEuNDIxMzU2LDc1IDAsNzUgLTQxLjQyMTM1Niw3NSAtNzUsNDEuNDIxMzU2IC03NSwwIGMgMCwtNDEuNDIxMzU2IDMzLjU3ODY0NCwtNzUgNzUsLTc1IDQxLjQyMTM1NiwwIDc1LDMzLjU3ODY0NCA3NSw3NSB6IgogICAgICAgICBpZD0iY2lyY2xlOSIKICAgICAgICAgcj0iNzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpyeT0iNzUiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzFiMWIxYjtzdHJva2Utd2lkdGg6MSIKICAgICAgIGlkPSJnMTEiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSI3MSIKICAgICAgICAgc29kaXBvZGk6cng9IjcxIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6Y3g9IjAiCiAgICAgICAgIGN5PSIwIgogICAgICAgICBjeD0iMCIKICAgICAgICAgZD0iTSA3MSwwIEMgNzEsMzkuMjEyMjE3IDM5LjIxMjIxNyw3MSAwLDcxIC0zOS4yMTIyMTcsNzEgLTcxLDM5LjIxMjIxNyAtNzEsMCBjIDAsLTM5LjIxMjIxNyAzMS43ODc3ODMsLTcxIDcxLC03MSAzOS4yMTIyMTcsMCA3MSwzMS43ODc3ODMgNzEsNzEgeiIKICAgICAgICAgaWQ9ImNpcmNsZTEzIgogICAgICAgICByPSI3MSIgLz4KICAgICAgPGNpcmNsZQogICAgICAgICBzb2RpcG9kaTpyeT0iNzkiCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI3OSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBjeT0iMCIKICAgICAgICAgY3g9IjAiCiAgICAgICAgIGQ9Ik0gNzksMCBDIDc5LDQzLjYzMDQ5NSA0My42MzA0OTUsNzkgMCw3OSAtNDMuNjMwNDk1LDc5IC03OSw0My42MzA0OTUgLTc5LDAgYyAwLC00My42MzA0OTUgMzUuMzY5NTA1LC03OSA3OSwtNzkgNDMuNjMwNDk1LDAgNzksMzUuMzY5NTA1IDc5LDc5IHoiCiAgICAgICAgIGlkPSJjaXJjbGUxNSIKICAgICAgICAgcj0iNzkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K";
  /**
   * Create a compass Widget
   * @param options
   * @throws {ReferenceError} can't get the div to insert the compass
   * @throws {ReferenceError} Can't get the element name
   * @constructor
   * @fires Context#modifiedNavigation
   */

  var Compass = function (options) {
    /**
     *    Private variables
     */
    this.svgDoc = null;
    this.panFactor = options.panFactor ? options.panFactor : 30;
    this.parentElement = options.element;
    this.ctx = null;
    this.isMobile = options.isMobile;
    this.options = options;
    this._lastMouseX = -1;
    this._lastMouseY = -1;
    this._balanceX = -1;
    this._balanceY = -1;
    this._dx = 0;
    this._dy = 0;
    this.dragging = false;
    this.east = null;
    this.west = null;
    this.south = null;
    this.north = null;
    this.northText = null;
    this.outerCircle = null; //var self = this;
    // Add compass object to parent element
    // Don't use <object> HTML tag due to cross-origin nature of svg

    if (this.parentElement == null) {
      throw new ReferenceError("Can't get the element name from the options parameters");
    } else if (document.getElementById(this.parentElement) === null) {
      throw new ReferenceError("can't get the Div " + this.parentElement + " to insert the compass");
    } else ;

    this.init();
  };
  /**************************************************************************************************************/

  /**
   * Handles mouse down event.
   * @param {Event} event
   * @param {Compass} self
   * @private
   */


  function _handleMouseDown$3(event, self) {
    if (event.type.search("touch") >= 0) {
      event.layerX = event.changedTouches[0].offsetX;
      event.layerY = event.changedTouches[0].offsetY;
      self._balanceX = event.layerX;
      self._balanceY = event.layerY;
    } else {
      self._balanceX = 0;
      self._balanceY = 0;
    }

    self.dragging = true;

    var _outerCircleRadius = self.outerCircle.ownerSVGElement.clientWidth / 2;

    self._lastMouseX = event.layerX - self._balanceX - _outerCircleRadius;
    self._lastMouseY = event.layerY - self._balanceY - _outerCircleRadius;
    self._dx = 0;
    self._dy = 0;
  }
  /**
   * Handles mouse move event.
   * @param {Event} event
   * @param {Compass} self
   * @private
   */


  function _handleMouseMove$3(event, self) {
    if (event.type.search("touch") >= 0) {
      event.layerX = event.changedTouches[0].offsetX - self._balanceX;
      event.layerY = event.changedTouches[0].offsetY - self._balanceY;
    }

    if (!self.dragging) {
      return;
    }

    var _outerCircleRadius = self.outerCircle.ownerSVGElement.clientWidth / 2;

    var c = self._lastMouseX * (event.layerY - _outerCircleRadius) - self._lastMouseY * (event.layerX - _outerCircleRadius); // c>0 -> clockwise, counterclockwise otherwise

    self.ctx.getNavigation().rotate(c, 0);
    self._lastMouseX = event.layerX - _outerCircleRadius;
    self._lastMouseY = event.layerY - _outerCircleRadius;
    CompassCore.updateNorth();
  }
  /**
   * Handles mouse up event.
   * @param {Event} event
   * @param {Compass} self
   * @private
   */


  function _handleMouseUp$3(event, self) {
    event.preventDefault();
    self.dragging = false; // TODO add inertia
  }
  /**
   * Updates north compass from east move.
   * @param {Compass} self
   * @private
   */


  function _updateNorthFromEast(self) {
    self.ctx.getNavigation().pan(self.panFactor, 0.0);
    CompassCore.updateNorth();
  }
  /**
   * Updates north compass from west move.
   * @param {Compass} self
   * @private
   */


  function _updateNorthFromWest(self) {
    self.ctx.getNavigation().pan(-self.panFactor, 0.0);
    CompassCore.updateNorth();
  }
  /**
   * Updates north compass from north move.
   * @param {Compass} self
   * @private
   */


  function _updateNorthFromNorth(self) {
    self.ctx.getNavigation().pan(0, self.panFactor);
    CompassCore.updateNorth();
  }
  /**
   * Updates north compass from south move.
   * @param {Compass} self
   * @private
   */


  function _updateNorthFromSouth(self) {
    self.ctx.getNavigation().pan(0, -self.panFactor);
    CompassCore.updateNorth();
  }
  /**
   * Init compass.
   */


  Compass.prototype.init = function () {
    CompassCore.init({
      element: this.parentElement
    });
  };
  /**
   *    Remove compass element
   */


  Compass.prototype.remove = CompassCore.remove;
  Compass.prototype.setCtx = CompassCore.setCtx;
  Compass.prototype.setSvg = CompassCore.setSvg;
  /**************************************************************************************************************/

  /**
   * Attachs the compass to the context.
   * @function attachTo
   * @memberof Compass#
   */

  Compass.prototype.attachTo = function (context) {
    var self = this;
    this.ctx = context;
    this.setCtx(context);
    $__default['default'].get(COMPASS_SVG, function (response) {
      // Import contents of the svg document into this document
      self.svgDoc = document.importNode(response.documentElement, true);
      self.ctx = context;
      /* Svg interactive elements */

      self.east = self.svgDoc.getElementById("East"); //get the inner element by id

      self.west = self.svgDoc.getElementById("West"); //get the inner element by id

      self.south = self.svgDoc.getElementById("South"); //get the inner element by id

      self.north = self.svgDoc.getElementById("North"); //get the inner element by id

      self.northText = self.svgDoc.getElementById("NorthText");
      self.outerCircle = self.svgDoc.getElementById("OuterCircle"); // Update width/height

      self.svgDoc.height.baseVal.value = 100;
      self.svgDoc.width.baseVal.value = 100; // Append the imported SVG root element to the appropriate HTML element

      document.getElementById(self.parentElement).innerHTML = '<div id="objectCompass"></div>';
      $__default['default']("#objectCompass").append(self.svgDoc);
      self.setSvg(self.svgDoc); //self.setCtx(self.ctx);

      self.options.svgDoc = self.svgDoc; //self.attachTo(self.ctx);

      self.svgDoc.addEventListener("mousedown", function (event) {
        _handleMouseDown$3(event, self);
      });
      self.svgDoc.addEventListener("mousemove", function (event) {
        _handleMouseMove$3(event, self);
      });
      self.svgDoc.addEventListener("mouseup", function (event) {
        _handleMouseUp$3(event, self);
      });
      self.east.addEventListener("click", function () {
        _updateNorthFromEast(self);
      });
      self.west.addEventListener("click", function () {
        _updateNorthFromWest(self);
      });
      self.north.addEventListener("click", function () {
        _updateNorthFromNorth(self);
      });
      self.south.addEventListener("click", function () {
        _updateNorthFromSouth(self);
      });
      self.northText.addEventListener("click", CompassCore._alignWithNorth);

      if (self.isMobile) {
        var passiveSupported = Utils.isPassiveSupported();
        self.svgDoc.addEventListener("touchstart", function (event) {
          _handleMouseDown$3(event, self);
        }, passiveSupported ? {
          passive: true
        } : false);
        self.svgDoc.addEventListener("touchup", function (event) {
          _handleMouseUp$3(event, self);
        });
        self.svgDoc.addEventListener("touchmove", function (event) {
          _handleMouseMove$3(event, self);
        }, passiveSupported ? {
          passive: true
        } : false);
        self.northText.addEventListener("touchstart", CompassCore._alignWithNorth, passiveSupported ? {
          passive: true
        } : false);
      } // Update fov when moving


      self.ctx.subscribe(Constants.EVENT_MSG.NAVIGATION_MODIFIED, CompassCore.updateNorth);
      self.ctx.subscribe(Constants.EVENT_MSG.CRS_MODIFIED, CompassCore.updateNorth); // Publish modified event to update compass north

      $__default['default']("#" + self.parentElement).css("display", "block");
    }, "xml");
  };
  /**
   * Detaches the tracker from the context.
   * @function detach
   * @memberof Compass#
   */


  Compass.prototype.detach = function () {
    var self = this;
    this.svgDoc.removeEventListener("mousedown", function (event) {
      _handleMouseDown$3(event, self);
    });
    this.svgDoc.removeEventListener("mousemove", function (event) {
      _handleMouseMove$3(event, self);
    });
    this.svgDoc.removeEventListener("mouseup", function (event) {
      _handleMouseUp$3(event, self);
    });
    this.east.removeEventListener("click", function () {
      _updateNorthFromEast(self);
    });
    this.west.removeEventListener("click", function () {
      _updateNorthFromWest(self);
    });
    this.north.removeEventListener("click", function () {
      _updateNorthFromNorth(self);
    });
    this.south.removeEventListener("click", function () {
      _updateNorthFromSouth(self);
    });
    this.northText.removeEventListener("click", CompassCore._alignWithNorth);

    if (this.isMobile) {
      var passiveSupported = Utils.isPassiveSupported();
      this.svgDoc.removeEventListener("touchstart", function (event) {
        _handleMouseDown$3(event, self);
      });
      this.svgDoc.removeEventListener("touchup", function (event) {
        _handleMouseUp$3(event, self);
      });
      this.svgDoc.removeEventListener("touchmove", function (event) {
        _handleMouseMove$3(event, self);
      }, passiveSupported ? {
        passive: true
      } : false);
      this.northText.removeEventListener("touchstart", CompassCore._alignWithNorth, passiveSupported ? {
        passive: true
      } : false);
    } // Update fov when moving


    this.ctx.unsubscribe(Constants.EVENT_MSG.NAVIGATION_MODIFIED, CompassCore.updateNorth);
    this.ctx.unsubscribe(Constants.EVENT_MSG.CRS_MODIFIED, CompassCore.updateNorth);
    this.ctx = null;
  };
  /**
   * Destroys the elements.
   * @function destroy
   * @memberof Compass#
   */


  Compass.prototype.destroy = function () {
    this.detach();
    this.remove();
    this.svgDoc = null;
    this.panFactor = null;
    this.parentElement = null;
    this.ctx = null;
    this.isMobile = null;
    this._lastMouseX = -1;
    this._lastMouseY = -1;
    this._balanceX = -1;
    this._balanceY = -1;
    this._dx = 0;
    this._dy = 0;
    this.dragging = false;
    this.east = null;
    this.west = null;
    this.south = null;
    this.north = null;
    this.northText = null;
    this.outerCircle = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * @name AbstractTracker
   * @class
   *    Abstract class for tracker (position, elevation...)
   * @param {Object} options
   * @param {string} options.element DIV ID where the element is inserted
   * @param {string} [options.position] position of thetracker
   * @throws {ReferenceError} Can't get the Div to insert the tracker
   * @throws {ReferenceError} Can't get the element name
   * @implements {Tracker}
   */

  var AbstractTracker = function (options) {
    this.options = options;
    this.context = null;
    this.navigation = null;
    this.element = options.element;

    if (this.element == null) {
      throw new ReferenceError("Can't get the element name from the options parameters");
    } else if (document.getElementById(this.element) == null) {
      throw new ReferenceError("Can' get the div " + this.element + " in the web page to insert " + this.constructor.name);
    } else {
      document.getElementById(this.element).innerHTML = "";

      if (options.position) {
        $__default['default']("#" + this.element).css(options.position, "2px");
      }
    }
  };
  /**
   * Returns the navigation.
   * @function _getNavigation
   * @memberof AbstractTracker#
   * @private
   */


  AbstractTracker.prototype._getNavigation = function () {
    return this.navigation;
  };
  /**
   * Sets the navigation
   * @function _setNavigation
   * @memberof AbstractTracker#
   */


  AbstractTracker.prototype._setNavigation = function (navigation) {
    this.navigation = navigation;
  };
  /**
   * Returns the globe.
   * @function _getGlobe
   * @memberof AbstractTracker#
   * @private
   */


  AbstractTracker.prototype._getGlobe = function () {
    return this.globe;
  };
  /**
   * Sets the globe
   * @function _setGlobe
   * @memberof AbstractTracker#
   * @private
   */


  AbstractTracker.prototype._setGlobe = function (globe) {
    this.globe = globe;
  };
  /**
   * Returns the DIV element in which the result is written.
   * @function _getElement
   * @memberof AbstractTracker#
   * @private
   */


  AbstractTracker.prototype._getElement = function () {
    return this.element;
  };
  /**
   * Updates the tracker.
   * @function update
   * @memberof AbstractTracker#
   * @abstract
   */


  AbstractTracker.prototype.update = function (event) {
    throw new SyntaxError("AbstractTracker.js: update from AbstractTracker not implemented");
  };
  /**
   * @function compute
   * @memberof AbstractTracker#
   * @abstract
   */


  AbstractTracker.prototype.compute = function (geoPosition) {
    throw new SyntaxError("AbstractTracker.js: compute from AbstractTracker not implemented");
  };
  /**
   * @function attachTo
   * @memberof AbstractTracker#
   */


  AbstractTracker.prototype.attachTo = function (context) {
    this._setGlobe(context._getGlobe());

    this._setNavigation(context.getNavigation());

    this._getGlobe().getRenderContext().canvas.addEventListener("mousemove", this.update);

    if (this.options.isMobile) {
      var passiveSupported = Utils.isPassiveSupported();

      this._getGlobe().getRenderContext().canvas.addEventListener("touchmove", this.update, passiveSupported ? {
        passive: true
      } : false);
    }
  };
  /**
   * @function detach
   * @memberof AbstractTracker#
   */


  AbstractTracker.prototype.detach = function () {
    document.getElementById(this._getElement()).innerHTML = "";

    this._getGlobe().getRenderContext().canvas.removeEventListener("mousemove", this.update);

    if (this.options.isMobile) {
      this._getGlobe().getRenderContext().canvas.removeEventListener("touchmove", this.update);
    }
  };
  /**
   * @function destroy
   * @memberof AbstractTracker#
   */


  AbstractTracker.prototype.destroy = function () {
    document.getElementById(this._getElement()).innerHTML = "";
    this.element = null;
    this.options = null; // we do do not destroy the globe now. It will be destroyed later on in the context
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  const crsInfo = '<div id="crsInfo" style="text-align: left" title="Coordinate Reference System information"></div>'; // Create the div, use jQuery UI dialog

  let $text$1 = "";
  const $crsInfo = $__default['default'](crsInfo).appendTo("body").dialog({
    autoOpen: false,
    width: 500,
    minHeight: 300,
    maxHeight: 500,
    dialogClass: "crsBox" //beforeClose: function( event, ui ) { $text = ""; }

  });
  let $active$1 = false;
  var CrsDialog = {
    /**
     *    Open dialog
     *
     *    @param html HTML text
     */
    open: function (crs) {
      if (this.isActive()) {
        this.destroy();
      }

      const geoBound = crs.getGeoBound();
      $text$1 += "<p align='center'><u><i><b>" + crs.getName() + " CRS description </b></i></u></p>";
      $text$1 += "<p align='justify'>" + crs.getDescription() + "</p>";
      $text$1 += "<table>" + "<caption><i>Sphere parameters</i></caption>" + "<tr><th>Parameter</th><th>Value</th></tr>" + "<tr><td>Projection</td><td>" + (crs.isProjected() ? crs.getProjection().getName() : "3D") + "</td></tr>" + "<tr><td>radius (meters)</td><td>" + crs.getGeoide().getRealPlanetRadius() + "</td></tr>" + "<tr><td>" + crs.getLongitudeLabel() + "</td><td>[" + geoBound.getWest() + "&deg; , " + geoBound.getEast() + "&deg;]</td></tr>" + "<tr><td>" + crs.getLatitudeLabel() + "</td><td>[" + geoBound.getSouth() + "&deg; , " + geoBound.getNorth() + "&deg;]</td></tr>" + "</table>";
      $crsInfo.on("dialogclose", function (event) {
        $active$1 = false;
      });
    },
    view: function () {
      $crsInfo.html($text$1).dialog("open");
      $crsInfo.scrollTop(5000);
      $active$1 = true;
    },
    hide: function () {
      $crsInfo.dialog("close");
      $active$1 = false;
    },
    isActive: function () {
      return $active$1;
    },
    destroy: function () {
      this.hide();
      $text$1 = "";
      $active$1 = false;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var self$7;
  var posTrackerInfoHTML = '<input type="button" id="posTrackerInfoButton"/>';
  /**
   * @name PositionTracker
   * @class
   *    Position Tracker
   * @augments AbstractTracker
   * @param {AbstractTracker_position_configuration} options - Position tracker configuration
   * @constructor
   * @memberof module:Tracker
   */

  var PositionTracker = function (options) {
    AbstractTracker.prototype.constructor.call(this, options);
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractTracker, PositionTracker);
  /**************************************************************************************************************/

  /**
   * @function update
   * @memberof PositionTracker#
   */

  PositionTracker.prototype.update = function (event) {
    if (event.type.search("touch") >= 0) {
      event.offsetX = event.changedTouches[0].offsetX;
      event.offsetY = event.changedTouches[0].offsetY;
    }

    if (document.getElementById(self$7._getElement())) {
      var $crsInfo = $__default['default']("#" + self$7._getElement() + "Info");

      var geoPos = self$7._getGlobe().getLonLatFromPixel(event.offsetX, event.offsetY);

      if (geoPos) {
        var astro = self$7.compute([geoPos[0], geoPos[1]]);
        document.getElementById(self$7._getElement()).innerHTML = astro[0] + " x " + astro[1];

        if ($crsInfo.css("display") == "none") {
          $crsInfo.show();
        }
      } else {
        document.getElementById(self$7._getElement()).innerHTML = "";

        if ($crsInfo.css("display") != "none") {
          $crsInfo.hide();
        }
      }
    }
  };
  /**
   * @function compute
   * @memberof PositionTracker#
   */


  PositionTracker.prototype.compute = function (geoPosition) {
    return this._getGlobe().getCoordinateSystem().formatCoordinates([geoPosition[0], geoPosition[1]]);
  };
  /**
   * Attachs the tracker to the context.
   *
   * Attachs the tracker to the context by calling the attachTo method from the AbstractTracker. Then, the CrsDialog
   * is filled with Crs information. Finally, the onClick event is set to get the Crs information. The onClick event
   * is enabled on the <i>#posTrackerInfoButton</i> ID
   *
   * @function attachTo
   * @memberof PositionTracker#
   * @param {Context} context context
   * @see {@link CrsDialog}
   * @see {@link AbstrackTracker#attachTo}
   */


  PositionTracker.prototype.attachTo = function (context) {
    AbstractTracker.prototype.attachTo.call(this, context);
    $__default['default'](posTrackerInfoHTML).appendTo("#" + this._getElement() + "Info");
    CrsDialog.open(context._getGlobe().getCoordinateSystem());
    $__default['default']("#posTrackerInfoButton").on("click", function () {
      if (CrsDialog.isActive() === true) {
        CrsDialog.hide();
      } else {
        CrsDialog.view();
      }
    });
    self$7 = this;
  };
  /**
   * Detaches the tracker.
   *
   * Detaches the tracker from the glob by calling the detach method from the AbstractTracker. Then, the onClick
   * event is removed and the CrsDialog is destroyed as well.
   *
   * @function detach
   * @memberof PositionTracker#
   */


  PositionTracker.prototype.detach = function () {
    $__default['default']("#posTrackerInfoButton").off("click");
    $__default['default']("#" + this._getElement() + "Info").empty();
    CrsDialog.destroy();
    AbstractTracker.prototype.detach.call(this);
    self$7 = null;
  };
  /**
   * Destroys the position tracker.
   * @function destroy
   * @memberof AbstractTracker.prototype
   */


  PositionTracker.prototype.destroy = function () {
    this.detach(this);
    AbstractTracker.prototype.destroy.call(this);
    self$7 = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var self$8;
  /**
   * @name ElevationTracker
   * @class
   *   Elevation Tracker
   * @augments AbstractTracker
   * @param {AbstractTracker_elevation_configuration} options - Elevation tracker configuration
   * @constructor
   * @memberof module:Tracker
   */

  var ElevationTracker = function (options) {
    AbstractTracker.prototype.constructor.call(this, options);
    this.scale = null;

    if (options.elevationLayer != null) {
      this.scale = options.elevationLayer.getScale();
    }
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractTracker, ElevationTracker);
  /**************************************************************************************************************/

  /**
   * Sets the scale layer taken from the elevationLayer
   * @param {WCSElevationLayer}elevationLayer
   */

  ElevationTracker.prototype.setScaleLayer = function (elevationLayer) {
    this.scale = elevationLayer.getScale();
    this.options.elevationLayer = elevationLayer;
  };
  /**
   * @function update
   * @memberof AbstractTracker.prototype
   */


  ElevationTracker.prototype.update = function (event) {
    if (event.type.search("touch") >= 0) {
      event.offsetX = event.changedTouches[0].offsetX;
      event.offsetY = event.changedTouches[0].offsetY;
    }

    if (document.getElementById(self$8._getElement()) && self$8.options.elevationLayer && self$8.options.elevationLayer.isRequested()) {
      var geoPos = self$8._getGlobe().getLonLatFromPixel(event.offsetX, event.offsetY);

      if (geoPos && self$8.scale) {
        var elevation = self$8.compute([geoPos[0], geoPos[1]]);
        document.getElementById(self$8._getElement()).innerHTML = "Elevation : " + Numeric.roundNumber(elevation / self$8.scale, 0) + " meters";
      } else {
        document.getElementById(self$8._getElement()).innerHTML = "";
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * @function compute
   * @memberof ElevationTracker#
   */


  ElevationTracker.prototype.compute = function (geoPosition) {
    return this._getGlobe().getElevation(geoPosition[0], geoPosition[1]);
  };
  /**
   * @function attachTo
   * @memberof ElevationTracker#
   */


  ElevationTracker.prototype.attachTo = function (context) {
    AbstractTracker.prototype.attachTo.call(this, context);
    self$8 = this;
  };
  /**
   * @function detach
   * @memberof ElevationTracker#
   */


  ElevationTracker.prototype.detach = function () {
    AbstractTracker.prototype.detach.call(this);
    self$8 = null;
  };
  /**
   * @function destroy
   * @memberof ElevationTracker#
   */


  ElevationTracker.prototype.destroy = function () {
    this.detach.call(this);
    AbstractTracker.prototype.destroy.call(this);
    this.scale = null;
    self$8 = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   *    Private variables
   */

  var parentElement$2 = null;
  var ctx$4 = null;
  const REWIND_SVG = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTExIDE4VjZsLTguNSA2IDguNSA2em0uNS02bDguNSA2VjZsLTguNSA2eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+";
  const FORWARD_SVG = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+ICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";
  const HOUR_GLASS_SVG = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTYgMnY2aC4wMUw2IDguMDEgMTAgMTJsLTQgNCAuMDEuMDFINlYyMmgxMnYtNS45OWgtLjAxTDE4IDE2bC00LTQgNC0zLjk5LS4wMS0uMDFIMThWMkg2em0xMCAxNC41VjIwSDh2LTMuNWw0LTQgNCA0em0tNC01bC00LTRWNGg4djMuNWwtNCA0eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";
  /**
   * Create a time travel Widget
   * @param options
   * @throws {ReferenceError} Can't get the Div to insert the time tracker
   * @throws {ReferenceError} Can't get the element name
   * @constructor
   * @fires Context#globalTime:set
   * @fires Context#globalTime:rewind
   * @fires Context#globalTime:forward
   */

  var TimeTravel = function (options) {
    parentElement$2 = options.element;
    ctx$4 = options.ctx; // Add compass object to parent element
    // Don't use <object> HTML tag due to cross-origin nature of svg

    if (parentElement$2 == null) {
      throw new ReferenceError("Can't get the element name from the options parameters");
    } else if (document.getElementById(options.element) == null) {
      throw new ReferenceError("Can' get the div " + parentElement$2 + " in the web page to insert " + this.constructor.name);
    } else ;

    var svgRewindDoc = null;
    var svgForwardDoc = null;
    var svgHourGlassDoc = null;
    document.getElementById(parentElement$2).innerHTML = '<div id="objectForward"></div><div id="objectHourGlass"></div><div id="objectRewind"></div>';

    var _handleMouseUp = function (name) {
      ctx$4.publish(name, ctx$4);
    };

    var _handleMouseUpSet = function (event) {
      _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_SET);
    };

    var _handleMouseUpForward = function (event) {
      _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD);
    };

    var _handleMouseUpRewind = function (event) {
      _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_REWIND);
    };

    ctx$4.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_CHANGED, this.updateDisplayDate);
    TimeTravelCore.init(options);
    $__default['default'].get(HOUR_GLASS_SVG, function (response) {
      // Import contents of the svg document into this document
      svgHourGlassDoc = document.importNode(response.documentElement, true); // Update width/height

      svgHourGlassDoc.height.baseVal.value = 32;
      svgHourGlassDoc.width.baseVal.value = 32; // Append the imported SVG root element to the appropriate HTML element

      $__default['default']("#objectHourGlass").append(svgHourGlassDoc);
      options.svgHourGlassDoc = svgHourGlassDoc;
      $__default['default']("#objectHourGlass svg").css({
        float: "right",
        fill: TimeTravelCore.isCurrentDateTheFirst() && TimeTravelCore.isCurrentDateTheLast() ? "#333333" : "white"
      });
      svgHourGlassDoc.addEventListener("mouseup", _handleMouseUpSet);

      if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
        $__default['default']("#" + parentElement$2).css("display", "block");
      }
    }, "xml");
    $__default['default'].get(REWIND_SVG, function (response) {
      // Import contents of the svg document into this document
      svgRewindDoc = document.importNode(response.documentElement, true); // Update width/height

      svgRewindDoc.height.baseVal.value = 32;
      svgRewindDoc.width.baseVal.value = 32; // Append the imported SVG root element to the appropriate HTML element

      $__default['default']("#objectRewind").append(svgRewindDoc);
      $__default['default']("#objectRewind svg").css({
        float: "right",
        fill: TimeTravelCore.isCurrentDateTheFirst() ? "#333333" : "white"
      });
      options.svgRewindDoc = svgRewindDoc;
      svgRewindDoc.addEventListener("mouseup", _handleMouseUpRewind);

      if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
        $__default['default']("#" + parentElement$2).css("display", "block");
      }
    }, "xml");
    $__default['default'].get(FORWARD_SVG, function (response) {
      // Import contents of the svg document into this document
      svgForwardDoc = document.importNode(response.documentElement, true); // Update width/height

      svgForwardDoc.height.baseVal.value = 32;
      svgForwardDoc.width.baseVal.value = 32; // Append the imported SVG root element to the appropriate HTML element

      $__default['default']("#objectForward").append(svgForwardDoc);
      $__default['default']("#objectForward svg").css({
        float: "right",
        fill: TimeTravelCore.isCurrentDateTheLast() ? "#333333" : "white"
      });
      options.svgForwardDoc = svgForwardDoc;
      svgForwardDoc.addEventListener("mouseup", _handleMouseUpForward);

      if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
        $__default['default']("#" + parentElement$2).css("display", "block");
      }
    }, "xml");
  };
  /**************************************************************************************************************/

  /**
   * Update display date and send current date to context
   * @function updateDisplayDate
   * @param {Time.configuration} date Time configuration
   * @memberof TimeTravel#
   */


  TimeTravel.prototype.updateDisplayDate = function (date) {
    if (document.getElementById("textTimeTravelDiv") !== null) {
      if (TimeTravelCore.isCurrentDateTheFirst() && TimeTravelCore.isCurrentDateTheLast()) {
        document.getElementById("textTimeTravelDiv").innerHTML = "";
      } else {
        document.getElementById("textTimeTravelDiv").innerHTML = date.display;
      }
    }

    ctx$4.setTime(date);
    var theColorRewind = $__default['default']("#objectRewind:hover svg").css("fill") === "rgb(255, 0, 0)" ? "red" : "white";
    var theColorForward = $__default['default']("#objectForward:hover svg").css("fill") === "rgb(255, 0, 0)" ? "red" : "white";
    $__default['default']("#objectRewind svg").css({
      float: "right",
      fill: TimeTravelCore.isCurrentDateTheFirst() ? "#333333" : theColorRewind
    });
    $__default['default']("#objectForward svg").css({
      float: "right",
      fill: TimeTravelCore.isCurrentDateTheLast() ? "#333333" : theColorForward
    });
    $__default['default']("#objectHourGlass svg").css({
      float: "right",
      fill: TimeTravelCore.isCurrentDateTheFirst() && TimeTravelCore.isCurrentDateTheLast() ? "#333333" : "white"
    });
    $__default['default']("#objectRewind svg").mouseover(function () {
      if (TimeTravelCore.isCurrentDateTheFirst()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "red");
      }
    }).mouseout(function () {
      if (TimeTravelCore.isCurrentDateTheFirst()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "white");
      }
    });
    $__default['default']("#objectForward svg").mouseover(function () {
      if (TimeTravelCore.isCurrentDateTheLast()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "red");
      }
    }).mouseout(function () {
      if (TimeTravelCore.isCurrentDateTheLast()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "white");
      }
    });
    $__default['default']("#objectHourGlass svg").mouseover(function () {
      if (TimeTravelCore.isCurrentDateTheFirst() && TimeTravelCore.isCurrentDateTheLast()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "red");
      }
    }).mouseout(function () {
      if (TimeTravelCore.isCurrentDateTheFirst() && TimeTravelCore.isCurrentDateTheLast()) {
        $__default['default'](this).css("fill", "#333333");
      } else {
        $__default['default'](this).css("fill", "white");
      }
    });
  };
  /**
   *    functions
   */


  TimeTravel.prototype.remove = TimeTravelCore.remove;
  TimeTravel.prototype.goRewind = TimeTravelCore.goRewind;
  TimeTravel.prototype.goForward = TimeTravelCore.goForward;
  TimeTravel.prototype.chooseTime = TimeTravelCore.chooseTime;

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   * Default div ID for attribution.
   */
  const ATTIBUTION_ID_DEFAULT = "attribution";
  /**
   * Create HTML attribution.
   */

  function _createHTMLAttribution(layer) {
    var attribution;
    var title = layer.getAck() != null ? layer.getAck() : "";

    if (layer.getCopyrightUrl() !== "" && layer.getCopyrightUrl() !== undefined) {
      attribution = '<a class="whiteLink" href="' + layer.getCopyrightUrl() + '" target="_blank" title="' + title + '">' + layer.getAttribution() + "</a>";
    } else {
      attribution = layer.getAttribution();
    }

    return attribution;
  }
  /**
      @name AttributionHandler
      @class
      Manage the attributions
      @param {Globe} globe Globe
      @param options Configuration properties
      <ul>
      <li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
      </ul>
  */


  var AttributionHandler = function (globe, options) {
    // Search for the element to use
    var elt = options ? options.element : undefined;

    if (elt) {
      if (typeof elt === "string") {
        this.element = document.getElementById(elt);
      } else {
        this.element = elt;
      }

      if (this.element && !elt.hasOwnProperty(this.element)) {
        this.element.id = ATTIBUTION_ID_DEFAULT;
      }
    } // Only add the attribution handler to the globe if element is not null


    if (this.element) {
      globe.attributionHandler = this;
    }
  };
  /**
   * Remove attribution from HTML
   * @function removeAttribution
   * @memberof AttributionHandler.prototype
   * @param {Layer} layer Layer
   */


  AttributionHandler.prototype.removeAttribution = function (layer) {
    if (this.element) {
      var div = document.getElementById(this.element.id + "_" + layer.id);

      if (div) {
        this.element.removeChild(div);
      }
    }
  };
  /**
   * Add attribution in HTML
   * @function addAttribution
   * @memberof AttributionHandler.prototype
   * @param {Layer} layer Layer
   */


  AttributionHandler.prototype.addAttribution = function (layer) {
    if (this.element) {
      var div = document.createElement("div");
      div.innerHTML = _createHTMLAttribution.call(this, layer);
      div.id = this.element.id + "_" + layer.id;

      if (layer.id === 0) {
        // Background layer
        this.element.insertBefore(div, this.element.firstChild);
      } else {
        this.element.appendChild(div);
      }
    }
  };
  /**
   * Enables all HTML attribution.
   * @function enable
   * @memberof AttributionHandler.prototype
   * @param {Layer} layer Layer
   */


  AttributionHandler.prototype.enable = function (layer) {
    if (this.element && layer && layer.isVisible()) {
      var div = document.getElementById(this.element.id + "_" + layer.id);

      if (div) {
        div.style.display = "block";
      }
    }
  };
  /**
   * Disables all HTML attribution.
   * @function disable
   * @memberof AttributionHandler.prototype
   * @param {Layer} layer Layer
   */


  AttributionHandler.prototype.disable = function (layer) {
    if (this.element && layer && layer.isVisible()) {
      var div = document.getElementById(this.element.id + "_" + layer.id);

      if (div) {
        div.style.display = "none";
      }
    }
  };
  /**
   * Toggle attribution
   * @function toggleAttribution
   * @memberof AttributionHandler.prototype
   * @param {Layer} layer Layer
   */


  AttributionHandler.prototype.toggleAttribution = function (layer) {
    if (this.element) {
      var div = document.getElementById(this.element.id + "_" + layer.id);

      if (div) {
        this.removeAttribution(layer);
      } else {
        this.addAttribution(layer);
      }
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
    @name VectorRenderer
    @class
  	  VectorRenderer constructor
    @param {AbstractGlobe} globe AbstractGlobe
    @constructor
    */

  var VectorRenderer = function (globe) {
    this.tileManager = globe.tileManager;
    this.globe = globe;
    this.buckets = [];
    this.maxTilePerGeometry = 100;
    this.levelZeroTiledGeometries = [];
  };
  /**************************************************************************************************************/

  /**
   * Find a compatible bucket
   * @function findBucket
   * @memberof VectorRenderer.prototype
   * @param layer
   * @param style
   * @return {Bucket} Bucket
   */


  VectorRenderer.prototype.findBucket = function (layer, style) {
    // Find an existing bucket for the given style
    for (var i = 0; i < this.buckets.length; i++) {
      var bucket = this.buckets[i];

      if (bucket.layer === layer && bucket.isCompatible(style)) {
        return bucket;
      }
    }

    return null;
  };
  /**************************************************************************************************************/

  /**
   * Generate the level zero for a tile
   * @function generateLevelZero
   * @memberof VectorRenderer.prototype
   * @param {Tile} tile Tile
   */


  VectorRenderer.prototype.generateLevelZero = function (tile) {
    for (var i = 0; i < this.levelZeroTiledGeometries.length; i++) {
      var geometry = this.levelZeroTiledGeometries[i]; // Check that the geometry is on this tile

      var isFound = false;

      for (var n = 0; n < geometry._tileIndices.length && !isFound; n++) {
        var t = this.tileManager.level0Tiles[geometry._tileIndices[n]];
        isFound = t === tile;
      } // Found the tile, so add it


      if (isFound) {
        this._addGeometryToTile(geometry._bucket, geometry, tile);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Recursively add a geometry to a tile
   * @function _recursiveAddGeometryToTile
   * @memberof VectorRenderer.prototype
   * @param {Bucket} bucket Bucket
   * @param geometry
   * @param {Tile} tile Tile
   * @private
   */


  VectorRenderer.prototype._recursiveAddGeometryToTile = function (bucket, geometry, tile) {
    var renderable = this._addGeometryToTile(bucket, geometry, tile);

    if (renderable && renderable.generateChild && tile.children) {
      for (var i = 0; i < 4; i++) {
        if (tile.children[i].state === Tile.State.LOADED) {
          renderable.hasChildren = true;

          this._recursiveAddGeometryToTile(bucket, geometry, tile.children[i]);
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to a vector renderer
   * @function addGeometry
   * @memberof VectorRenderer.prototype
   * @param layer
   * @param geometry
   * @param style
   */


  VectorRenderer.prototype.addGeometry = function (layer, geometry, style) {
    var bucket = this.getOrCreateBucket(layer, geometry, style);
    geometry._bucket = bucket;
    var tileIndices = this.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null;

    if (tileIndices && tileIndices.length < this.maxTilePerGeometry) {
      // Add geometry to each tile in range
      for (var i = 0; i < tileIndices.length; i++) {
        var tile = this.tileManager.level0Tiles[tileIndices[i]];

        if (tile && tile.state === Tile.State.LOADED) {
          this._recursiveAddGeometryToTile(bucket, geometry, tile);
        }
      }

      geometry._tileIndices = tileIndices;
      this.levelZeroTiledGeometries.push(geometry);
    } else {
      // Attach to mainRenderable
      if (!bucket.mainRenderable) {
        bucket.mainRenderable = bucket.createRenderable();
      }

      bucket.mainRenderable.add(geometry);
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from a vector renderer
   * @function removeGeometry
   * @memberof VectorRenderer.prototype
   * @param geometry
   * @private
   */


  VectorRenderer.prototype.removeGeometry = function (geometry) {
    var tileIndices = geometry._tileIndices;

    if (tileIndices) {
      // Remove from tile
      for (var i = 0; i < tileIndices.length; i++) {
        var tile = this.tileManager.level0Tiles[tileIndices[i]];
        this.removeGeometryFromTile(geometry, tile);
      } // Remove from geometry arrays


      this.levelZeroTiledGeometries.splice(this.levelZeroTiledGeometries.indexOf(geometry), 1);
      geometry._tileIndices = null;
    } else {
      var bucket = geometry._bucket;

      if (bucket.mainRenderable) {
        var numGeometries = bucket.mainRenderable.remove(geometry);

        if (numGeometries === 0) {
          bucket.mainRenderable.dispose(this.renderContext);
          bucket.mainRenderable = null;
        }
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Get or create a bucket for the given configuration
   * @function getOrCreateBucket
   * @memberof VectorRenderer.prototype
   * @param layer
   * @param geometry
   * @param style
   * @return {Bucket} Bucket
   */


  VectorRenderer.prototype.getOrCreateBucket = function (layer, geometry, style) {
    // Then find an existing bucket
    var bucket = this.findBucket(layer, style);

    if (!bucket) {
      bucket = this.createBucket(layer, style);
      bucket.renderer = this;
      bucket.id = this.globe.getRendererManager().bucketId++;
      this.buckets.push(bucket);
    }

    return bucket;
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to a tile
   * @function addGeometryToTile
   * @memberof VectorRenderer.prototype
   * @param layer
   * @param geometry
   * @param style
   * @param {Tile} tile Tile
   */


  VectorRenderer.prototype.addGeometryToTile = function (layer, geometry, style, tile) {
    var bucket = this.getOrCreateBucket(layer, geometry, style);
    geometry._bucket = bucket;
    return this._addGeometryToTile(bucket, geometry, tile);
  };
  /**************************************************************************************************************/

  /**
   * Internal method to add a geometry to a tile
   * @function _addGeometryToTile
   * @memberof VectorRenderer.prototype
   * @param {Bucket} bucket Buckeont
   * @param geometry
   * @param {Tile} tile Tile
   * @private
   */


  VectorRenderer.prototype._addGeometryToTile = function (bucket, geometry, tile) {
    var tileData = tile.extension.renderer;

    if (!tileData) {
      tileData = tile.extension.renderer = new RendererTileData(this.globe.getRendererManager());
    }

    var renderable = tileData.getRenderable(bucket);
    var needsToAdd = false;

    if (!renderable) {
      renderable = bucket.createRenderable();
      needsToAdd = true;
    }

    if (renderable.add(geometry, tile)) {
      if (needsToAdd) {
        tileData.renderables.push(renderable);
      }

      return renderable;
    }

    return null;
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from a tile (recursive)
   * @function _removeGeometryFromTile
   * @memberof VectorRenderer.prototype
   * @param geometry
   * @param {Bound} bbox Bbox of geometry
   * @param {Tile} tile Tile
   * @param {Integer} level Level
   * @private
   */


  VectorRenderer.prototype._removeGeometryFromTile = function (geometry, bbox, tile, level) {
    var maxLevel = 0;

    if (bbox !== null && UtilsIntersection.boundsIntersects(bbox, tile.bound) === false) {
      return maxLevel;
    }

    var tileData = null;

    if (tile && tile.extension) {
      tileData = tile.extension.renderer;
    }

    if (tileData) {
      var i = 0;

      while (i < tileData.renderables.length) {
        var renderable = tileData.renderables[i];
        var renderer = renderable.bucket.renderer;

        if (renderer === this) {
          // Remove renderable
          var numGeometries = renderable.remove(geometry);

          if (numGeometries === 0) {
            tileData.renderables.splice(i, 1);
          } else {
            i++;
          } // Remove geometry from children if needed


          if (renderable.hasChildren === true && tile.children) {
            for (var n = 0; n < 4; n++) {
              if (tile.children[n].state === Tile.State.LOADED) {
                var levelReturned = this._removeGeometryFromTile(geometry, bbox, tile.children[n], level + 1);

                if (levelReturned > maxLevel) {
                  maxLevel = levelReturned;
                }
              }
            }
          }
        } else {
          i++;
        }
      }
    }

    return maxLevel;
  };
  /**
   * Remove a geometry from a tile
   * @function removeGeometryFromTile
   * @memberof VectorRenderer.prototype
   * @param geometry
   * @param {Tile} tile Tile
   */


  VectorRenderer.prototype.removeGeometryFromTile = function (geometry, tile) {
    var bbox = geometry.type === "Point" ? null : Utils.getBBox(geometry);

    this._removeGeometryFromTile(geometry, bbox, tile, 0);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       Basic module to generate texture from text
       */

  var Text = function () {
    var fontSize = 18;
    var margin = 1;
    var canvas2d = null;

    var initialize = function () {
      canvas2d = document.createElement("canvas");
      canvas2d.width = 512;
      canvas2d.height = fontSize + 2 * margin;
    };

    var generateImageData = function (text, textColor) {
      if (!canvas2d) {
        initialize();
      }

      var fillColor = textColor;

      if (!fillColor) {
        fillColor = "#fff";
      } else {
        if (fillColor instanceof Array) {
          fillColor = FeatureStyle.fromColorToString(textColor);
        }
      }

      var ctx = canvas2d.getContext("2d");
      ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
      ctx.fillStyle = fillColor;
      ctx.font = fontSize + "px sans-serif";
      ctx.textBaseline = "top";
      ctx.shadowColor = "#000";
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      ctx.shadowBlur = 2;
      ctx.fillText(text, margin, margin); //ctx.lineWidth = 1.0;
      //ctx.strokeText(text, margin, margin);

      var metrics = ctx.measureText(text);
      return ctx.getImageData(0, 0, Math.floor(metrics.width) + 2 * margin, canvas2d.height);
    };

    return {
      generateImageData: generateImageData
    };
  }();
  /**************************************************************************************************************/

  /**
       @name PointRenderer
       @class
           POI Renderer constructor
       @param {AbstractGlobe} globe AbstractGlobe
       @augments VectorRenderer
       @constructor
       */


  var PointRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe); // Store object for rendering

    this.renderContext = globe.tileManager.renderContext;
    this.tileConfig = globe.tileManager.tileConfig; // For stats

    this.numberOfRenderPoints = 0;
    var vertexShader = "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
    vertexShader += "uniform mat4 viewProjectionMatrix; \n";
    vertexShader += "uniform vec3 poiPosition; // world position \n";
    vertexShader += "uniform vec2 poiScale; // x,y scale \n";
    vertexShader += "uniform vec2 tst; \n";
    vertexShader += "\n";
    vertexShader += "varying vec2 texCoord; \n";
    vertexShader += "\n";
    vertexShader += "void main(void)  \n";
    vertexShader += "{ \n";
    vertexShader += "	// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
    vertexShader += "	texCoord = vertex.xy + vec2(0.5) + tst; \n";
    vertexShader += "	// Invert y \n";
    vertexShader += "	texCoord.y = 1.0 - texCoord.y; \n";
    vertexShader += "	\n";
    vertexShader += "	// Compute poi position in clip coordinate \n";
    vertexShader += "	gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
    vertexShader += "	gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
    vertexShader += "} \n";
    var fragmentShader = "precision lowp float; \n";
    fragmentShader += "varying vec2 texCoord; \n";
    fragmentShader += "uniform sampler2D texture; \n";
    fragmentShader += "uniform float alpha; \n";
    fragmentShader += "uniform vec3 color; \n";
    fragmentShader += "\n";
    fragmentShader += "void main(void) \n";
    fragmentShader += "{ \n";
    fragmentShader += "	vec4 textureColor = texture2D(texture, texCoord); \n";
    fragmentShader += "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
    fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
    fragmentShader += "} \n";
    this.program = new Program(this.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
    var vertices = new Float32Array([-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0]);
    var gl = this.renderContext.gl;
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    this.defaultTexture = null;
  };

  Utils.inherits(VectorRenderer, PointRenderer);
  /**************************************************************************************************************/

  /**
   * Build a default texture
   * @function _buildDefaultTexture
   * @memberof PointRenderer.prototype
   * @param {Bucket} bucket Bucket
   * @private
   */

  PointRenderer.prototype._buildDefaultTexture = function (bucket) {
    if (!this.defaultTexture) {
      var gl = this.renderContext.gl;
      this.defaultTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
      var whitePixel = new Uint8Array([255, 255, 255, 255]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
    }

    bucket.texture = this.defaultTexture;
    bucket.textureWidth = 10;
    bucket.textureHeight = 10;
  };
  /**************************************************************************************************************/

  /**
   * Build a texture from an image and store in a bucket
   * @function _buildTextureFromImage
   * @memberof PointRenderer.prototype
   * @param {Bucket} bucket Bucket
   * @param image
   * @private
   */


  PointRenderer.prototype._buildTextureFromImage = function (bucket, image) {
    bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(image);
    bucket.textureWidth = image.width;
    bucket.textureHeight = image.height;
  };
  /**************************************************************************************************************/

  /**
       @name PointRenderable
       @class
           Renderable constructor for Point
       @param {Bucket} bucket Bucket
       @constructor
       */


  var PointRenderable = function (bucket) {
    this.bucket = bucket;
    this.points = [];
    this.geometries = [];
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to the renderable
   * @function add
   * @memberof PointRenderable.prototype
   * @param geometry
   * @return {Boolean} If the geometry has been successfully added to the renderable
   */


  PointRenderable.prototype.add = function (geometry, stockGeometry) {
    // TODO: Find a better way to access to coordinate system
    var coordinateSystem = this.bucket.layer.getGlobe().getCoordinateSystem();
    var posGeo = geometry.coordinates.slice(0);

    if (stockGeometry !== false) {
      this.geometries.push(geometry);
    }

    posGeo = coordinateSystem.convert(posGeo, geometry.crs.properties.name, coordinateSystem.getGeoideName());
    var csBound = new GeoBound(coordinateSystem.getGeoBound().getWest(), coordinateSystem.getGeoBound().getSouth(), coordinateSystem.getGeoBound().getEast(), coordinateSystem.getGeoBound().getNorth());

    if (csBound.isPointInside(posGeo)) {
      const globe = this.bucket.renderer.globe;
      const altitude = globe.isSky() ? 0.0 : coordinateSystem.getElevation(globe, geometry) + 200;
      posGeo.push(altitude);
      var pos3d = coordinateSystem.get3DFromWorld(posGeo);
      var vertical = coordinateSystem.getVerticalAt3D(pos3d);
      var found = false;

      for (var j = 0; j < this.points.length; ++j) {
        if (this.points[j].geometry === geometry) {
          found = true;
        }
      }

      if (!found) {
        this.points.push({
          pos3d: pos3d,
          vertical: vertical,
          geometry: geometry
        });
      }

      return true;
    } else {
      return false;
    }
  };
  /**************************************************************************************************************/


  PointRenderable.prototype.updateElevations = function () {
    this.points = [];

    for (var i = 0; i < this.geometries.length; i++) {
      this.add(this.geometries[i], false);
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from the renderable
   * @function remove
   * @memberof PointRenderable.prototype
   * @param geometry
   * @return {Integer} Number of points after remove
   */


  PointRenderable.prototype.remove = function (geometry) {
    for (var j = 0; j < this.points.length; j++) {
      if (this.points[j].geometry === geometry) {
        this.points.splice(j, 1);
        return this.points.length;
      }
    }

    return this.points.length;
  };
  /**************************************************************************************************************/

  /**
   * Dispose the renderable
   * @function dispose
   * @memberof PointRenderable.prototype
   * @param renderContext
   */


  PointRenderable.prototype.dispose = function (renderContext) {// Nothing to do
  };
  /**************************************************************************************************************/

  /**
       @name PointBucket
       @class
           Bucket constructor for PointRenderer
       @param layer
       @param style
       @constructor
       */


  var PointBucket = function (layer, style) {
    this.layer = layer;
    this.style = new FeatureStyle(style);
    this.renderer = null;
    this.texture = null;
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof PointBucket.prototype
   * @return {PointRenderable} Renderable
   */


  PointBucket.prototype.createRenderable = function () {
    return new PointRenderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Check if a bucket is compatible
   * @function isCompatible
   * @memberof PointBucket.prototype
   * @param style
   * @return {Boolean} Is compatible ?
   */


  PointBucket.prototype.isCompatible = function (style) {
    return this.style.iconUrl === style.iconUrl && this.style.icon === style.icon && this.style.label === style.label;
  };
  /**************************************************************************************************************/

  /**
   * Create bucket to render a point
   * @function createBucket
   * @memberof PointRenderer.prototype
   * @param layer
   * @param style
   * @return {PointBucket} Bucket
   */


  PointRenderer.prototype.createBucket = function (layer, style) {
    // Create a bucket
    var bucket = new PointBucket(layer, style); // Initialize bucket : create the texture

    if (style.label) {
      var imageData = Text.generateImageData(style.label, style.textColor);

      this._buildTextureFromImage(bucket, imageData);
    } else if (style.iconUrl) {
      var image = new Image();
      image.crossOrigin = "";
      var self = this;

      image.onload = function () {
        self._buildTextureFromImage(bucket, image);

        self.renderContext.requestFrame();
      };

      image.onerror = function () {
        self._buildDefaultTexture(bucket);
      };

      image.src = Proxy.proxify(style.iconUrl);
    } else if (style.icon) {
      this._buildTextureFromImage(bucket, style.icon);
    } else {
      this._buildDefaultTexture(bucket);
    }

    return bucket;
  };
  /**************************************************************************************************************/

  /**
   * Render all the POIs
   * @function render
   * @memberof PointRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  PointRenderer.prototype.render = function (renderables, start, end) {
    this.numberOfRenderPoints = 0;
    var renderContext = this.renderContext;
    var gl = this.renderContext.gl; // TODO
    //var level = renderContext.renderers[0].tileManager.visibleTiles[0].level;
    //if(level < 5) {
    //    return;
    //}
    // end todo
    // Setup states
    // gl.disable(gl.DEPTH_TEST);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Setup program

    this.program.apply(); // The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage

    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
    gl.uniformMatrix4fv(this.program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
    gl.uniform1i(this.program.uniforms.texture, 0); // Compute eye direction from inverse view matrix

    mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
    var camZ = [renderContext.modelViewMatrix[8], renderContext.modelViewMatrix[9], renderContext.modelViewMatrix[10]];
    vec3.normalize(camZ);
    vec3.scale(camZ, this.tileConfig.cullSign, camZ); // Compute pixel size vector to offset the points from the earth

    var pixelSizeVector = renderContext.computePixelSizeVector(); // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(this.program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
    var scale;
    var currentBucket = null;

    for (var n = start; n < end; n++) {
      var renderable = renderables[n]; // renderable.updateElevations();

      var bucket = renderable.bucket;

      if (renderable.points.length === 0) {
        continue;
      }

      if (bucket !== currentBucket) {
        // Bind point texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bucket.texture); // 2.0 * because normalized device coordinates goes from -1 to 1

        scale = [2.0 * bucket.textureWidth / renderContext.canvas.width, 2.0 * bucket.textureHeight / renderContext.canvas.height];
        gl.uniform2fv(this.program.uniforms.poiScale, scale);
        gl.uniform2fv(this.program.uniforms.tst, [0.5 / bucket.textureWidth, 0.5 / bucket.textureHeight]);
      }

      for (var i = 0; i < renderable.points.length; i++) {
        // Poi culling
        var worldPoi = renderable.points[i].pos3d;
        var poiVec = renderable.points[i].vertical;
        scale = bucket.textureHeight * (pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3]);
        scale *= this.tileConfig.cullSign;
        var scaleInKm = scale / this.globe.getCoordinateSystem().getGeoide().getHeightScale() * 0.001;

        if (scaleInKm > bucket.style.pointMaxSize) {
          continue;
        }

        if (vec3.dot(poiVec, camZ) > 0 && renderContext.worldFrustum.containsSphere(worldPoi, scale) >= 0) {
          var x = poiVec[0] * scale + worldPoi[0];
          var y = poiVec[1] * scale + worldPoi[1];
          var z = poiVec[2] * scale + worldPoi[2];
          gl.uniform3f(this.program.uniforms.poiPosition, x, y, z);
          gl.uniform1f(this.program.uniforms.alpha, bucket.layer.getOpacity());
          var color = bucket.style.getFillColor();
          gl.uniform3f(this.program.uniforms.color, color[0], color[1], color[2]);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
          this.numberOfRenderPoints++;
        }
      }
    } //    gl.enable(gl.DEPTH_TEST);


    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof PointRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Can apply ?
   */


  PointRenderer.prototype.canApply = function (type, style) {
    return type === Constants.GEOMETRY.Point && style.iconUrl === null;
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new PointRenderer(globe);
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   @name BatchRenderable
   @class
    Base renderable
   @constructor
   */
  var BatchRenderable = function (bucket) {
    this.bucket = bucket;
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.vertices = [];
    this.triIndices = [];
    this.lineIndices = [];
    this.geometryInfos = [];
    this.bufferDirty = true;
    this.vertexSize = 3;
    this.indexType = 0;
    this.vertexBufferShared = false;
  };
  /**
     Remove a geometry from the renderable
     @function remove
     @memberof BatchRenderable.prototype
     @param {JSON} geometry Geometry
   */


  BatchRenderable.prototype.remove = function (geometry) {
    var fiIndex = -1; // Find the feature

    var vertexIt = 0;
    var lineIndexIt = 0;
    var triIndexIt = 0;
    var n;

    for (var i = 0; i < this.geometryInfos.length; i++) {
      var fi = this.geometryInfos[i];

      if (fi.geometry === geometry) {
        // Remove feature from vertex and index buffer
        this.vertices.splice(vertexIt, fi.vertexCount);
        this.lineIndices.splice(lineIndexIt, fi.lineIndexCount);
        this.triIndices.splice(triIndexIt, fi.triIndexCount); // Update index buffer

        var vertexOffset = fi.vertexCount / this.vertexSize;

        for (n = lineIndexIt; n < this.lineIndices.length; n++) {
          this.lineIndices[n] -= vertexOffset;
        }

        for (n = triIndexIt; n < this.triIndices.length; n++) {
          this.triIndices[n] -= vertexOffset;
        }

        fiIndex = i;
        break;
      }

      vertexIt += fi.vertexCount;
      lineIndexIt += fi.lineIndexCount;
      triIndexIt += fi.triIndexCount;
    }

    if (fiIndex >= 0) {
      this.bufferDirty = true; // Remove the feature from the infos array

      this.geometryInfos.splice(fiIndex, 1);
      return this.vertices.length;
    } else {
      return this.vertices.length;
    }
  };
  /**
     Add a feature to the renderable
     @function add
     @memberof BatchRenderable.prototype
     @param {JSON} geometry Geometry
     @param {?} tile Tile
   */


  BatchRenderable.prototype.add = function (geometry, tile) {
    var hasTile = typeof tile !== "undefined";
    this.tile = tile; // Store previous number of vertices/indices needed for "after-build" computation

    var numVertices = this.vertices.length;
    var numLineIndices = this.lineIndices.length;
    var numTriIndices = this.triIndices.length;
    var geometryInTile = hasTile === false;

    if (hasTile === true) {
      geometryInTile = this.build(geometry, tile);
    }

    if (geometryInTile) {
      this.geometryInfos.push({
        geometry: geometry,
        vertexCount: this.vertices.length - numVertices,
        lineIndexCount: this.lineIndices.length - numLineIndices,
        triIndexCount: this.triIndices.length - numTriIndices
      });
      this.bufferDirty = true;
      return true;
    } else {
      // Feature not in the tile
      return false;
    }
  };
  /**
     Dispose graphics data
     @function dispose
     @memberof BatchRenderable.prototype
     @param {renderContext} renderContext Render context
   */


  BatchRenderable.prototype.dispose = function (renderContext) {
    if (typeof renderContext === "undefined") {
      return;
    }

    var gl = renderContext.gl;

    if (this.indexBuffer) {
      gl.deleteBuffer(this.indexBuffer);
    }

    this.indexBuffer = null;

    if (this.vertexBuffer && !this.vertexBufferShared) {
      gl.deleteBuffer(this.vertexBuffer);
      this.vertexBuffer = null;
    }
  };
  /**
     Must be call before rendering
     @function bindBuffers
     @memberof BatchRenderable.prototype
     @param {renderContext} renderContext Render context
   */


  BatchRenderable.prototype.bindBuffers = function (renderContext) {
    var gl = renderContext.gl;

    if (this.bufferDirty) {
      this.dispose(renderContext); // Create vertex buffer if needed

      if (this.vertexBuffer) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      } else {
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
      } // Create index buffer


      this.indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      var indices;

      if (this.triIndices.length > 0) {
        if (this.lineIndices.length > 0) {
          indices = this.triIndices.concat(this.lineIndices);
        } else {
          indices = this.triIndices;
        }
      } else {
        indices = this.lineIndices;
      }

      var vertexCount = this.vertices.length / this.vertexSize;

      if (vertexCount > 65535) {
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
        this.indexType = gl.UNSIGNED_INT;
      } else {
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        this.indexType = gl.UNSIGNED_SHORT;
      }

      this.bufferDirty = false;
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /** @constructor
   *    TiledVectorRenderable constructor
   */

  var TiledVectorRenderable = function (bucket) {
    BatchRenderable.prototype.constructor.call(this, bucket);
    this.tile = null; // The tiled vector renderable always has a children

    this.hasChildren = true;
  };
  /**************************************************************************************************************/


  Utils.inherits(BatchRenderable, TiledVectorRenderable);
  /**************************************************************************************************************/

  /**
   * Initialize a child renderable
   */

  TiledVectorRenderable.prototype.initChild = function (i, j) {
    var child = new TiledVectorRenderable(this.bucket);
    child.tile = this.tile;
    child.vertexBufferShared = true;
    child.vertexBuffer = this.vertexBuffer;
    child.vertices = this.vertices;
    child.buildChildrenIndices(this, j * 2 + i);
    return child;
  };
  /**************************************************************************************************************/

  /**
   * Generate a child renderable
   */


  TiledVectorRenderable.prototype.generateChild = function (tile) {
    for (var j = 0; j < this.geometryInfos.length; j++) {
      this.bucket.renderer._addGeometryToTile(this.bucket, this.geometryInfos[j].geometry, tile);
    }
  };
  /**************************************************************************************************************/

  /**
   * Build children indices.
   * Children indices are used to render a tile children when it is not completely loaded.
   */


  TiledVectorRenderable.prototype.buildChildrenIndices = function (parent, index) {
    var n;
    var vertexOffset1, vertexOffset2, vertexOffset3;
    var x1, x2, x3, i;
    var y1, y2, y3, j;

    for (n = 0; n < parent.triIndices.length; n += 3) {
      vertexOffset1 = 3 * parent.triIndices[n];
      vertexOffset2 = 3 * parent.triIndices[n + 1];
      vertexOffset3 = 3 * parent.triIndices[n + 2];
      x1 = parent.vertices[vertexOffset1];
      x2 = parent.vertices[vertexOffset2];
      x3 = parent.vertices[vertexOffset3];
      i = 0;

      if (x1 > 0 || x1 === 0 && x2 > 0 || x1 === 0 && x2 === 0 && x3 > 0) {
        i = 1;
      }

      y1 = parent.vertices[vertexOffset1 + 1];
      y2 = parent.vertices[vertexOffset2 + 1];
      y3 = parent.vertices[vertexOffset3 + 1];
      j = 1;

      if (y1 > 0 || y1 === 0 && y2 > 0 || y1 === 0 && y2 === 0 && y3 > 0) {
        j = 0;
      }

      if (index === 2 * j + i) {
        this.triIndices.push(parent.triIndices[n], parent.triIndices[n + 1], parent.triIndices[n + 2]);
      }
    }

    for (n = 0; n < parent.lineIndices.length / 2; n++) {
      vertexOffset1 = 3 * parent.lineIndices[2 * n];
      vertexOffset2 = 3 * parent.lineIndices[2 * n + 1];
      x1 = parent.vertices[vertexOffset1];
      x2 = parent.vertices[vertexOffset2];
      i = 0;

      if (x1 > 0 || x1 === 0 && x2 > 0) {
        i = 1;
      }

      y1 = parent.vertices[vertexOffset1 + 1];
      y2 = parent.vertices[vertexOffset2 + 1];
      j = 1;

      if (y1 > 0 || y1 === 0 && y2 > 0) {
        j = 0;
      }

      if (index === 2 * j + i) {
        this.lineIndices.push(parent.lineIndices[2 * n], parent.lineIndices[2 * n + 1]);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   *    Add a feature to the renderable
   *    @return    Boolean indicating if geometry intersects the given tile
   */


  TiledVectorRenderable.prototype.build = function (geometry, tile) {
    this.tile = tile;
    var i, j;
    var tileInRange;

    if (typeof this.bucket.layer.minLevel === "undefined" || typeof this.bucket.layer.maxLevel === "undefined") {
      tileInRange = true;
    } else {
      tileInRange = this.bucket.layer.minLevel <= tile.level && tile.level <= this.bucket.layer.maxLevel;
    }

    if (tileInRange) {
      var coords = geometry.coordinates;

      switch (geometry.type) {
        case Constants.GEOMETRY.LineString:
          this.buildVerticesAndIndices(tile, coords);
          break;

        case Constants.GEOMETRY.Polygon:
          for (i = 0; i < coords.length; i++) {
            this.buildVerticesAndIndices(tile, coords[i]);
          }

          break;

        case Constants.GEOMETRY.MultiLineString:
          for (i = 0; i < coords.length; i++) {
            this.buildVerticesAndIndices(tile, coords[i]);
          }

          break;

        case Constants.GEOMETRY.MultiPolygon:
          for (j = 0; j < coords.length; j++) {
            for (i = 0; i < coords[j].length; i++) {
              this.buildVerticesAndIndices(tile, coords[j][i]);
            }
          }

          break;
      }
    }

    return tile.geoBound.intersectsGeometry(geometry);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /** @constructor
   TiledVectorRenderer constructor
   */

  var TiledVectorRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe);
    var vertexShader = "attribute vec3 vertex; \n";
    vertexShader += "uniform float zOffset; \n";
    vertexShader += "uniform mat4 modelViewMatrix;\n";
    vertexShader += "uniform mat4 projectionMatrix;\n";
    vertexShader += "\n";
    vertexShader += "void main(void)  \n";
    vertexShader += "{ \n";
    vertexShader += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n";
    vertexShader += "} \n";
    var fragmentShader = "#ifdef GL_ES \n";
    fragmentShader += "precision highp float; \n";
    fragmentShader += "#endif \n";
    fragmentShader += "uniform vec4 color; \n";
    fragmentShader += "\n";
    fragmentShader += "void main(void) \n";
    fragmentShader += "{ \n";
    fragmentShader += "	gl_FragColor = color; \n";
    fragmentShader += "} \n";
    this.program = new Program(this.tileManager.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
  };

  Utils.inherits(VectorRenderer, TiledVectorRenderer);
  /**************************************************************************************************************/

  /**
   Render all redenrable on the given tiles
   */

  TiledVectorRenderer.prototype.render = function (renderables, start, end) {
    var renderContext = this.tileManager.renderContext;
    var gl = renderContext.gl;
    var modelViewMatrix = mat4.create(); // Setup program

    this.program.apply();
    gl.depthFunc(gl.LEQUAL); // Do not write into z-buffer : the tiled vector are clamped to terrain, so the z of terrain should not change

    gl.depthMask(false);
    gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, renderContext.projectionMatrix);
    var currentStyle = null;

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      var tile = renderable.tile;
      mat4.multiply(renderContext.viewMatrix, tile.matrix, modelViewMatrix);
      gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, modelViewMatrix);
      gl.uniform1f(this.program.uniforms.zOffset, tile.radius * 0.0007);
      currentStyle = renderable.bucket.style;
      renderable.bindBuffers(renderContext);
      gl.vertexAttribPointer(this.program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

      if (renderable.triIndices.length > 0) {
        gl.uniform4f(this.program.uniforms.color, currentStyle.fillColor[0], currentStyle.fillColor[1], currentStyle.fillColor[2], currentStyle.fillColor[3] * renderable.bucket.layer.getOpacity());
        gl.drawElements(gl.TRIANGLES, renderable.triIndices.length, renderable.indexType, 0);
      }

      if (renderable.lineIndices.length > 0) {
        gl.lineWidth(currentStyle.strokeWidth);
        gl.uniform4f(this.program.uniforms.color, currentStyle.strokeColor[0], currentStyle.strokeColor[1], currentStyle.strokeColor[2], currentStyle.strokeColor[3] * renderable.bucket.layer.getOpacity());
        var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
        gl.drawElements(gl.LINES, renderable.lineIndices.length, renderable.indexType, renderable.triIndices.length * size);
      }
    }

    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       @name LineRenderer
       @class
           LineStringRenderable manages lineString data to be rendered on a tile.
       @augments TiledVectorRenderable
       @param {Bucket} bucket Bucket
       @constructor
       */

  var LineStringRenderable = function (bucket) {
    TiledVectorRenderable.prototype.constructor.call(this, bucket);
  };
  /**************************************************************************************************************/
  // Inheritance


  Utils.inherits(TiledVectorRenderable, LineStringRenderable);
  /**************************************************************************************************************/

  /**************************************************************************************************************/

  /**
   * Check if a geometry crosses the date line
   * @function _fixDateLine
   * @memberof LineStringRenderable.prototype
   * @param {Tile} tile Tile
   * @param coords
   * @return {Array} Lines
   * @private
   */

  LineStringRenderable.prototype._fixDateLine = function (tile, coords) {
    var newCoords = [];
    var lines = [newCoords];

    for (var n = 0; n < coords.length - 1; n++) {
      newCoords.push(coords[n]);
      var x1 = coords[n][0];
      var y1 = coords[n][1];
      var x2 = coords[n + 1][0];
      var y2 = coords[n + 1][1];

      if (Math.abs(x2 - x1) > 180) {
        if (x1 < 0) {
          x1 += 360;
        }

        if (x2 < 0) {
          x2 += 360;
        }

        var t = (180 - x1) / (x2 - x1);

        if (t > 0 && t < 1) {
          var y = y1 + t * (y2 - y1);
          var x = coords[n][0] > 0 ? 180 : -180;
          newCoords.push([x, y]);
          newCoords = [[-x, y]];
          lines.push(newCoords);
        }
      }
    }

    newCoords.push(coords[coords.length - 1]); //newCoords.push( coords[0] );

    return lines;
  };
  /**
   * Build vertices and indices from the coordinates.
   * Clamp a line string on a tile
   * @function buildVerticesAndIndices
   * @memberof LineStringRenderable.prototype
   * @param {Tile} tile Tile
   * @param coords
   */


  LineStringRenderable.prototype.buildVerticesAndIndices = function (tile, coords) {
    if (coords.length === 0) {
      return;
    } // Fix date line for coordinates first


    var coordinates = this._fixDateLine(tile, coords);

    for (var i = 0; i < coordinates.length; i++) {
      this._buildVerticesAndIndices(tile, coordinates[i]);
    }
  };
  /**
   * Build vertices and indices from the coordinates.
   * Clamp a line string on a tile
   * @function _buildVerticesAndIndices
   * @memberof LineStringRenderable.prototype
   * @param {Tile} tile Tile
   * @param coords
   * @private
   */


  LineStringRenderable.prototype._buildVerticesAndIndices = function (tile, coords) {
    var size = tile.config.tesselation;
    var vs = tile.config.vertexSize;
    coords.push(coords[coords.length - 1]); // Convert lon/lat coordinates to tile coordinates (between [0,size-1] inside the tile)

    var tileCoords = tile.lonlat2tile(coords);

    for (var i = 0; i < coords.length - 1; i++) {
      var u1 = tileCoords[i][0];
      var v1 = tileCoords[i][1];
      var u2 = tileCoords[i + 1][0];
      var v2 = tileCoords[i + 1][1];
      var intersections = [];
      var n, v, res, u;
      var vertexOffset, x, y, z; // Intersect the segment with the tile grid
      // First intersect with columns
      // uStart, uEnd represent a range of the tile columns that the segement can intersect

      var uStart = Math.max(-1, Math.min(u1, u2));
      var uEnd = Math.min(size - 1, Math.max(u1, u2));

      for (n = Math.floor(uStart) + 1; n < Math.floor(uEnd) + 1; n++) {
        u = n;
        res = Numeric.lineIntersection(u1, v1, u2, v2, u, 0.0, u, size - 1);

        if (res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0) {
          v = res[1] * (size - 1);
          var vFloor = Math.floor(v);
          var vFrac = v - vFloor;
          vertexOffset = vs * (vFloor * size + n);
          x = (1.0 - vFrac) * tile.vertices[vertexOffset] + vFrac * tile.vertices[vertexOffset + vs * size];
          y = (1.0 - vFrac) * tile.vertices[vertexOffset + 1] + vFrac * tile.vertices[vertexOffset + vs * size + 1];
          z = (1.0 - vFrac) * tile.vertices[vertexOffset + 2] + vFrac * tile.vertices[vertexOffset + vs * size + 2];
          intersections.push([res[0], x, y, z]);
        }
      } // Then intersect with rows
      // vStart, vEnd represent a range of the tile rows that the segement can intersect


      var vStart = Math.max(-1, Math.min(v1, v2));
      var vEnd = Math.min(size - 1, Math.max(v1, v2));

      for (n = Math.floor(vStart) + 1; n < Math.floor(vEnd) + 1; n++) {
        v = n;
        res = Numeric.lineIntersection(u1, v1, u2, v2, 0.0, v, size - 1, v);

        if (res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0) {
          u = res[1] * (size - 1);
          var uFloor = Math.floor(u);
          var uFrac = u - uFloor;
          vertexOffset = vs * (n * size + uFloor);
          x = (1.0 - uFrac) * tile.vertices[vertexOffset] + uFrac * tile.vertices[vertexOffset + vs];
          y = (1.0 - uFrac) * tile.vertices[vertexOffset + 1] + uFrac * tile.vertices[vertexOffset + vs + 1];
          z = (1.0 - uFrac) * tile.vertices[vertexOffset + 2] + uFrac * tile.vertices[vertexOffset + vs + 2];
          intersections.push([res[0], x, y, z]);
        }
      } // Sort intersections found on the segment


      intersections.sort(function (a, b) {
        return a[0] > b[0];
      }); // Build the vertices from the intersections found

      var startIndex = this.vertices.length / 3;
      var vec;

      if (u1 >= 0.0 && u1 <= size - 1 && v1 >= 0.0 && v1 <= size - 1) {
        vec = tile.computePosition(u1, v1);
        this.vertices.push(vec[0]);
        this.vertices.push(vec[1]);
        this.vertices.push(vec[2]);
      }

      for (n = 0; n < intersections.length; n++) {
        this.vertices.push(intersections[n][1]);
        this.vertices.push(intersections[n][2]);
        this.vertices.push(intersections[n][3]);
      }

      if (u2 >= 0.0 && u2 <= size - 1 && v2 >= 0.0 && v2 <= size - 1) {
        vec = tile.computePosition(u2, v2);
        this.vertices.push(vec[0]);
        this.vertices.push(vec[1]);
        this.vertices.push(vec[2]);
      }

      var endIndex = this.vertices.length / 3;

      for (n = startIndex; n < endIndex - 1; n++) {
        this.lineIndices.push(n);
        this.lineIndices.push(n + 1);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   @name LineStringRenderer
   @class
  	LineStringRenderer manages lineString data to be rendered on a tile.
   @augments TiledVectorRenderer
   @param {Planet} planet Planet
   @constructor
   */


  var LineStringRenderer = function (globe) {
    TiledVectorRenderer.prototype.constructor.call(this, globe);
  }; // Inheritance


  Utils.inherits(TiledVectorRenderer, LineStringRenderer);
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof LineStringRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Can apply ?
   */

  LineStringRenderer.prototype.canApply = function (type, style) {
    if (this.globe.isSky()) {
      return false;
    }

    if (!style.onTerrain) {
      return false;
    }

    const result = (type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString || !style.fill && (type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon)) && !style.gradientLength;
    return result;
  };
  /**************************************************************************************************************/

  /**
    @name LineStringBucket
    @class
   	  Bucket constructor for LineStringRenderer
    @param layer
  	@param style
    @constructor
    */


  var LineStringBucket = function (layer, style) {
    this.layer = layer;
    this.style = new FeatureStyle(style);
    this.renderer = null;
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof LineStringBucket.prototype
   * @return {LineStringRenderable} Renderable
   */


  LineStringBucket.prototype.createRenderable = function () {
    return new LineStringRenderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Check if a bucket is compatible
   * @function isCompatible
   * @memberof LineStringBucket.prototype
   * @param style
   * @return {Boolean} Is compatible ?
   */


  LineStringBucket.prototype.isCompatible = function (style) {
    var result = this.style.strokeColor[0] === style.strokeColor[0] && this.style.strokeColor[1] === style.strokeColor[1] && this.style.strokeColor[2] === style.strokeColor[2] && this.style.strokeColor[3] === style.strokeColor[3] && this.style.strokeWidth === style.strokeWidth;
    return result;
  };
  /**************************************************************************************************************/

  /**
   * Get or create a bucket to store a feature with the given style
   * @function createBucket
   * @memberof LineStringRenderer.prototype
   * @param layer
   * @param style
   * @return {LineStringBucket} Bucket
   */


  LineStringRenderer.prototype.createBucket = function (layer, style) {
    // Create a bucket
    return new LineStringBucket(layer, style);
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new LineStringRenderer(globe);
  });

  var pnltri = createCommonjsModule(function (module, exports) {

  /**
   * @author jahting / http://www.ameco.tv/
   *
   *	(Simple) Polygon Near-Linear Triangulation
   *	  with fast ear-clipping for polygons without holes
   *
   */
   
  var PNLTRI = { REVISION: '2.1.1' };

  //	#####  Global Constants  #####


  //	#####  Global Variables  #####


  /**
   * @author jahting / http://www.ameco.tv/
   */

  PNLTRI.Math = {

  	random: Math.random,		// function to use for random number generation

  	// generate random ordering in place:
  	//	Fisher-Yates shuffle
  	array_shuffle: function( inoutArray ) {
  		for (var i = inoutArray.length - 1; i > 0; i-- ) {
  			var j = Math.floor( PNLTRI.Math.random() * (i+1) );
  			var tmp = inoutArray[i];
  			inoutArray[i] = inoutArray[j];
  			inoutArray[j] = tmp;
  		}
  		return	inoutArray;
  	},


  	//	like compare (<=>)
  	//		yA > yB resp. xA > xB: 1, equal: 0, otherwise: -1
  	compare_pts_yx: function ( inPtA, inPtB ) {
  		var deltaY = inPtA.y - inPtB.y;
  		if ( deltaY < PNLTRI.Math.EPSILON_N ) {
  			return -1;
  		} else if ( deltaY > PNLTRI.Math.EPSILON_P ) {
  			return 1;
  		} else {
  			var deltaX = inPtA.x - inPtB.x;
  			if ( deltaX < PNLTRI.Math.EPSILON_N ) {
  				return -1;
  			} else if ( deltaX > PNLTRI.Math.EPSILON_P ) {
  				return  1;
  			} else {
  				return  0;
  			}
  		}
  	},


  	ptsCrossProd: function ( inPtVertex, inPtFrom, inPtTo ) {
  		// two vectors: ( v0: inPtVertex -> inPtFrom ), ( v1: inPtVertex -> inPtTo )
  		// CROSS_SINE: sin(theta) * len(v0) * len(v1)
  		return	( inPtFrom.x - inPtVertex.x ) * ( inPtTo.y - inPtVertex.y ) -
  				( inPtFrom.y - inPtVertex.y ) * ( inPtTo.x - inPtVertex.x );
  		// <=> crossProd( inPtFrom-inPtVertex, inPtTo-inPtVertex )
  		// == 0: colinear (angle == 0 or 180 deg == PI rad)
  		// > 0:  v1 lies left of v0, CCW angle from v0 to v1 is convex ( < 180 deg )
  		// < 0:  v1 lies right of v0, CW angle from v0 to v1 is convex ( < 180 deg )
  	},

  };

  // precision of floating point arithmetic
  //	PNLTRI.Math.EPSILON_P = Math.pow(2,-32);	// ~ 0.0000000001
  	PNLTRI.Math.EPSILON_P = Math.pow(2,-43);	// ~ 0.0000000000001
  	PNLTRI.Math.EPSILON_N = -PNLTRI.Math.EPSILON_P;

  //	Problem with EPSILON-compares:
  //	- especially when there is a x-coordinate ordering on equal y-coordinates
  //		=> either NO EPSILON-compares on y-coordinates, since almost equal y
  //			can have very different x - so they are not nearly close
  //		or EPSILON must be bigger: Solution so far.
  /**
   * @author jahting / http://www.ameco.tv/
   */

  /** @constructor */
  PNLTRI.PolygonData = function ( inPolygonChainList ) {

  	// list of polygon vertices
  	//	.x, .y: coordinates
  	this.vertices = [];

  	// list of polygon segments, original polygons ane holes
  	//	and additional ones added during the subdivision into
  	//	uni-y-monotone polygons (s. this.monoSubPolyChains)
  	//	doubly linked by: snext, sprev
  	this.segments = [];
  	this.diagonals = [];

  	// for the ORIGINAL polygon chains
  	this.idNextPolyChain = 0;
  	//	for each original chain: lies the polygon inside to the left?
  	//	"true": winding order is CCW for a contour or CW for a hole
  	//	"false": winding order is CW for a contour or CCW for a hole
  	this.PolyLeftArr = [];

  	// indices into this.segments: at least one for each monoton chain for the polygon
  	//  these subdivide the polygon into uni-y-monotone polygons, that is
  	//  polygons that have only one segment between ymax and ymin on one side
  	//  and the other side has monotone increasing y from ymin to ymax
  	// the monoSubPolyChains are doubly linked by: mnext, mprev
  	this.monoSubPolyChains = [];

  	// list of triangles: each 3 indices into this.vertices
  	this.triangles = [];

  	// initialize optional polygon chains
  	if ( inPolygonChainList ) {
  		for (var i=0, j=inPolygonChainList.length; i<j; i++) {
  			this.addPolygonChain( inPolygonChainList[i] );
  		}
  	}

  };


  PNLTRI.PolygonData.prototype = {

  	constructor: PNLTRI.PolygonData,


  	/*	Accessors  */

  	nbVertices: function () {
  		return	this.vertices.length;
  	},
  	getSegments: function () {
  		return	this.segments;
  	},
  	getFirstSegment: function () {
  		return	this.segments[0];
  	},
  	getMonoSubPolys: function () {
  		return	this.monoSubPolyChains;
  	},
  	getTriangles: function () {
  		return	this.triangles.concat();
  	},

  	nbPolyChains: function () {
  		return	this.idNextPolyChain;
  	},

  	// for the polygon data AFTER triangulation
  	//	returns an Array of flags, one flag for each polygon chain:
  	//		lies the inside of the polygon to the left?
  	//		"true" implies CCW for contours and CW for holes
  	get_PolyLeftArr: function () {
  		return	this.PolyLeftArr.concat();
  	},
  	set_PolyLeft_wrong: function ( inChainId ) {
  		this.PolyLeftArr[inChainId] = false;
  	},


  	/*	Helper  */

  	// checks winding order by calculating the area of the polygon
  	isClockWise: function ( inStartSeg ) {
  		var cursor = inStartSeg, doubleArea = 0;
  		do {
  			doubleArea += ( cursor.vFrom.x - cursor.vTo.x ) * ( cursor.vFrom.y + cursor.vTo.y );
  			cursor = cursor.snext;
  		} while ( cursor != inStartSeg );
  		return	( doubleArea < 0 );
  	},


  	/*	Operations  */

  	appendVertexEntry: function ( inVertexX, inVertexY ) {			// private
  		var vertex = {
  				id: this.vertices.length,	// vertex id, representing input sequence
  				x: inVertexX,				// coordinates
  				y: inVertexY,
  			};
  		this.vertices.push( vertex );
  		return	vertex;
  	},


  	createSegmentEntry: function ( inVertexFrom, inVertexTo ) {			// private
  		return	{
  			chainId: this.idNextPolyChain,
  			// end points of segment
  			vFrom: inVertexFrom,	// -> start point entry in vertices
  			vTo: inVertexTo,		// -> end point entry in vertices
  			// upward segment? (i.e. vTo > vFrom) !!! only valid for sprev,snext NOT for mprev,mnext !!!
  			upward: ( PNLTRI.Math.compare_pts_yx(inVertexTo, inVertexFrom) == 1 ),
  			// doubly linked list of original polygon chains (not the monoChains !)
  			sprev: null,			// previous segment
  			snext: null,			// next segment
  			//
  			//	for performance reasons:
  			//	 initialization of all fields added later
  			//
  			// for trapezoids
  			rootFrom: null,			// root of partial tree where vFrom is located
  			rootTo: null,			// root of partial tree where vTo is located
  			is_inserted: false,		// already inserted into QueryStructure ?
  			// for assigning depth: trapezoids
  			trLeft: null,			// one trapezoid bordering on the left of this segment
  			trRight: null,			// one trapezoid bordering on the right of this segment
  			// for monochains
  			mprev: null,			// doubly linked list for monotone chains (sub-polygons)
  			mnext: null,
  			marked: false,			// already visited during unique monoChain identification ?
  		};
  	},

  	appendSegmentEntry: function ( inSegment ) {				// private
  		this.segments.push( inSegment );
  		return	inSegment;
  	},


  	appendDiagonalsEntry: function ( inDiagonal ) {				// <<<<<	public
  		this.diagonals.push( inDiagonal );
  		return	inDiagonal;
  	},


  	addVertexChain: function ( inRawPointList ) {			// private

  		function verts_equal( inVert1, inVert2 ) {
  			return ( ( Math.abs(inVert1.x - inVert2.x) < PNLTRI.Math.EPSILON_P ) &&
  					 ( Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P ) );
  		}

  		function verts_colinear_chain( inVert1, inVert2, inVert3 ) {
  			if ( Math.abs( PNLTRI.Math.ptsCrossProd( inVert2, inVert1, inVert3 ) ) > PNLTRI.Math.EPSILON_P )	return false;
  			// only real sequences, not direction reversals
  			var low, middle, high;
  			if ( Math.abs( inVert1.y - inVert2.y ) < PNLTRI.Math.EPSILON_P ) {
  				// horizontal line
  				middle = inVert2.x;
  				if ( inVert1.x < inVert3.x ) {
  					low = inVert1.x;
  					high = inVert3.x;
  				} else {
  					low = inVert3.x;
  					high = inVert1.x;
  				}
  			} else {
  				middle = inVert2.y;
  				if ( inVert1.y < inVert3.y ) {
  					low = inVert1.y;
  					high = inVert3.y;
  				} else {
  					low = inVert3.y;
  					high = inVert1.y;
  				}
  			}
  			return	( ( ( low - middle ) < PNLTRI.Math.EPSILON_P ) && ( ( middle - high ) < PNLTRI.Math.EPSILON_P ) );
  		}

  		var newVertices = [];
  		var newVertex, acceptVertex, lastIdx;
  		for ( var i=0; i < inRawPointList.length; i++ ) {
  			newVertex = this.appendVertexEntry( inRawPointList[i].x, inRawPointList[i].y );
  			// suppresses zero-length segments
  			acceptVertex = true;
  			lastIdx = newVertices.length-1;
  			if ( lastIdx >= 0 ) {
  				if ( verts_equal( newVertex, newVertices[lastIdx] ) ) {
  					acceptVertex = false;
  				} else if ( lastIdx > 0 ) {
  					if ( verts_colinear_chain( newVertices[lastIdx-1], newVertices[lastIdx], newVertex ) ) {
  						newVertices.pop();
  					}
  				}
  			}
  			if ( acceptVertex )	newVertices.push( newVertex );
  		}
  		// compare last vertices to first: suppresses zero-length and co-linear segments
  		lastIdx = newVertices.length - 1;
  		if ( ( lastIdx > 0 ) &&
  			 verts_equal( newVertices[lastIdx], newVertices[0] ) ) {
  			newVertices.pop();
  			lastIdx--;
  		}
  		if ( lastIdx > 1 ) {
  			if ( verts_colinear_chain( newVertices[lastIdx-1], newVertices[lastIdx], newVertices[0] ) ) {
  				newVertices.pop();
  				lastIdx--;
  			}
  			if ( ( lastIdx > 1 ) &&
  				 verts_colinear_chain( newVertices[lastIdx], newVertices[0], newVertices[1] ) ) {
  				newVertices.shift();
  			}
  		}

  		return	newVertices;
  	},


  	addPolygonChain: function ( inRawPointList ) {			// <<<<<< public

  		// vertices
  		var newVertices = this.addVertexChain( inRawPointList );
  		if ( newVertices.length < 3 ) {
  			console.log( "Polygon has < 3 vertices!", newVertices );
  			return	0;
  		}

  		// segments
  		var	saveSegListLength = this.segments.length;
  		//
  		var	segment, firstSeg, prevSeg;
  		for ( var i=0; i < newVertices.length-1; i++ ) {
  			segment = this.createSegmentEntry( newVertices[i], newVertices[i+1] );
  			if (prevSeg) {
  				segment.sprev = prevSeg;
  				prevSeg.snext = segment;
  			} else {
  				firstSeg = segment;
  			}
  			prevSeg = segment;
  			this.appendSegmentEntry( segment );
  		}
  		// close polygon
  		segment = this.createSegmentEntry( newVertices[newVertices.length-1], newVertices[0] );
  		segment.sprev = prevSeg;
  		prevSeg.snext = segment;
  		this.appendSegmentEntry( segment );
  		firstSeg.sprev = segment;
  		segment.snext = firstSeg;

  		this.PolyLeftArr[this.idNextPolyChain++] = true;
  		return	this.segments.length - saveSegListLength;
  	},


  	/* Monotone Polygon Chains */

  	// Generate the uni-y-monotone sub-polygons from
  	//	the trapezoidation of the polygon.

  	create_mono_chains: function () {						// <<<<<< public
  		var newMono, newMonoTo, toFirstOutSeg, fromRevSeg;
  		for ( var i = 0, j = this.segments.length; i < j; i++) {
  			newMono = this.segments[i];
  			if ( this.PolyLeftArr[newMono.chainId] ) {
  				// preserve winding order
  				newMonoTo = newMono.vTo;			// target of segment
  				newMono.mprev = newMono.sprev;		// doubly linked list for monotone chains (sub-polygons)
  				newMono.mnext = newMono.snext;
  			} else {
  				// reverse winding order
  				newMonoTo = newMono.vFrom;
  				newMono = newMono.snext;
  				newMono.mprev = newMono.snext;
  				newMono.mnext = newMono.sprev;
  			}
  			if ( fromRevSeg = newMono.vFrom.lastInDiag ) {		// assignment !
  				fromRevSeg.mnext = newMono;
  				newMono.mprev = fromRevSeg;
  				newMono.vFrom.lastInDiag = null;		// cleanup
  			}
  			if ( toFirstOutSeg = newMonoTo.firstOutDiag ) {		// assignment !
  				toFirstOutSeg.mprev = newMono;
  				newMono.mnext = toFirstOutSeg;
  				newMonoTo.firstOutDiag = null;			// cleanup
  			}
  		}
  	},

  	// For each monotone polygon, find the ymax (to determine the two
  	// y-monotone chains) and skip duplicate monotone polygons

  	unique_monotone_chains_max: function () {			// <<<<<< public

  		function find_monotone_chain_max( frontMono ) {
  			var frontPt, firstPt, ymaxPt;

  			var monoPosmax = frontMono;
  			firstPt = ymaxPt = frontMono.vFrom;

  			frontMono.marked = true;
  			frontMono = frontMono.mnext;
  			while ( frontPt = frontMono.vFrom ) {				// assignment !
  				if (frontMono.marked) {
  					if ( frontPt == firstPt )	break;	// mono chain completed
  					console.log("ERR unique_monotone: segment in two chains", firstPt, frontMono );
  					return	null;
  				} else {
  /*					if ( frontPt == firstPt ) {			// check for robustness
  						console.log("ERR unique_monotone: point double", firstPt, frontMono );
  					}		*/
  					frontMono.marked = true;
  				}
  				if ( PNLTRI.Math.compare_pts_yx( frontPt, ymaxPt ) == 1 ) {
  					ymaxPt = frontPt;
  					monoPosmax = frontMono;
  				}
  				frontMono = frontMono.mnext;
  			}
  			return	monoPosmax;
  		}

  		var frontMono, monoPosmax;

  		// assumes attribute "marked" is NOT yet "true" for any mono chain segment
  		this.monoSubPolyChains = [];
  		// loop through all original segments
  		for ( var i = 0, j = this.segments.length; i < j; i++ ) {
  			frontMono = this.segments[i];
  			if ( frontMono.marked )		continue;		// already in a processed mono chain
  			monoPosmax = find_monotone_chain_max( frontMono );
  			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
  		}
  		// loop through all additional segments (diagonals)			// TODO: Testcase for mono chain without original segments !!!
  /*		for ( var i = 0, j = this.diagonals.length; i < j; i++ ) {
  			frontMono = this.diagonals[i];
  			if ( frontMono.marked )		continue;		// already in a processed mono chain
  			monoPosmax = find_monotone_chain_max( frontMono );
  			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
  		}	*/
  		return	this.monoSubPolyChains;
  	},


  	/* Triangles */

  	clearTriangles: function () {
  		this.triangles = [];
  	},

  	addTriangle: function ( inVert1, inVert2, inVert3 ) {
  		this.triangles.push( [ inVert1.id, inVert2.id, inVert3.id ] );
  	},

  };

  /**
   * Simple Polygon Triangulation by Ear Clipping
   *
   * description of technique employed:
   *	http://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/polygon1.htm
   *
   * This code is a quick port of code written in C++ which was submitted to
   *	flipcode.com by John W. Ratcliff  // July 22, 2000
   * See original code and more information here:
   *	http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
   *
   * ported to actionscript by Zevan Rosser
   *	http://actionsnippet.com/?p=1462
   *
   * ported to javascript by Joshua Koo
   *	http://www.lab4games.net/zz85/blog
   *
   * adapted to doubly linked list by Juergen Ahting
   *	http://www.ameco.tv
   *
   */

  /** @constructor */
  PNLTRI.EarClipTriangulator = function ( inPolygonData ) {

  	this.polyData	= inPolygonData;

  };


  PNLTRI.EarClipTriangulator.prototype = {

  	constructor: PNLTRI.EarClipTriangulator,


  	// triangulates first doubly linked segment list in this.polyData
  	//	algorithm uses ear-clipping and runs in O(n^2) time

  	triangulate_polygon_no_holes: function () {

  		function isEarAt( vertex ) {

  			var prevX = vertex.mprev.vFrom.x;
  			var prevY = vertex.mprev.vFrom.y;

  			var vertX = vertex.vFrom.x;
  			var vertY = vertex.vFrom.y;

  			var nextX = vertex.mnext.vFrom.x;
  			var nextY = vertex.mnext.vFrom.y;

  			var vnX = nextX - vertX,  vnY = nextY - vertY;
  			var npX = prevX - nextX,  npY = prevY - nextY;
  			var pvX = vertX - prevX,  pvY = vertY - prevY;

  			// concave angle at vertex -> not an ear to cut off
  			if ( PNLTRI.Math.EPSILON_P > ( ( pvX * vnY ) - ( vnX * pvY ) ) ) return false;

  			// check whether any other point lieas within the triangle abc
  			var vStop	= vertex.mprev.mprev;
  			var vOther	= vertex.mnext;
  			while ( vOther != vStop ) {
  				vOther = vOther.mnext;
  				var otherX = vOther.vFrom.x;
  				var otherY = vOther.vFrom.y;

  				var poX = otherX - prevX,  poY = otherY - prevY;
  					// just in case there are several vertices with the same coordinate
  					if ( ( poX === 0 ) && ( poY === 0 ) )		continue;	// vOther == vertex.mprev
  				var voX = otherX - vertX,  voY = otherY - vertY;
  					if ( ( voX === 0 ) && ( voY === 0 ) )		continue;	// vOther == vertex
  				var noX = otherX - nextX,  noY = otherY - nextY;
  					if ( ( noX === 0 ) && ( noY === 0 ) )		continue;	// vOther == vertex.mnext

  				// if vOther is inside triangle abc -> not an ear to cut off
  				if ( ( ( vnX * voY - vnY * voX ) >= PNLTRI.Math.EPSILON_N ) &&
  					 ( ( pvX * poY - pvY * poX ) >= PNLTRI.Math.EPSILON_N ) &&
  					 ( ( npX * noY - npY * noX ) >= PNLTRI.Math.EPSILON_N ) ) return false;
  			}
  			return true;

  		}

  		var myPolyData = this.polyData;
  		var startSeg = myPolyData.getFirstSegment();

  		// create a counter-clockwise ordered doubly linked list (monoChain links)

  		var cursor = startSeg;
  		if ( myPolyData.isClockWise( startSeg ) ) {
  			do {	// reverses chain order
  				cursor.mprev = cursor.snext;
  				cursor.mnext = cursor.sprev;
  				cursor = cursor.sprev;
  			} while ( cursor != startSeg );
  			myPolyData.set_PolyLeft_wrong(0);
  		} else {
  			do {
  				cursor.mprev = cursor.sprev;
  				cursor.mnext = cursor.snext;
  				cursor = cursor.snext;
  			} while ( cursor != startSeg );
  		}

  		//  remove all vertices except 2, creating 1 triangle every time

  		var vertex = startSeg;
  		var fullLoop = vertex;   // prevent infinite loop on "defective" polygons

  		while ( vertex.mnext != vertex.mprev ) {
  			if ( isEarAt( vertex ) ) {
  				// found a triangle ear to cut off
  				this.polyData.addTriangle( vertex.mprev.vFrom, vertex.vFrom, vertex.mnext.vFrom );
  				// remove vertex from the remaining chain
  				vertex.mprev.mnext = vertex.mnext;
  				vertex.mnext.mprev = vertex.mprev;
  				vertex = vertex.mnext;
  				fullLoop = vertex;			// reset error detection
  			} else {
  				vertex = vertex.mnext;
  				// loop?: probably non-simple polygon -> stop with error
  				if ( vertex == fullLoop )	return false;
  			}
  		}

  		return true;

  	},

  /*	// takes one element of a double linked segment list
  	//	works on array of vertices

  	triangulate_polygon_no_holes: function () {
  		var startSeg = this.polyData.getFirstSegment();

  		function vertList( inStartSeg ) {
  			var verts = [];
  			// we want a counter-clockwise polygon in verts
  			var doubleArea = 0.0;
  			var cursor = inStartSeg;
  			var p,q;
  			var idx = 0;
  			do {
  				p = cursor.sprev.vFrom;
  				q = cursor.vFrom;
  				doubleArea += p.x * q.y - q.x * p.y;
  				verts[idx++] = q;
  				cursor = cursor.snext;
  			} while ( cursor != inStartSeg );
  			if ( doubleArea < 0.0 ) {
  				verts = verts.reverse();
  				var tmp = verts.pop();
  				verts.unshift( tmp );
  			}
  			return	verts;
  		}

  		function snip( verts, u, v, w, n ) {

  			var ax = verts[ u ].x;
  			var ay = verts[ u ].y;

  			var bx = verts[ v ].x;
  			var by = verts[ v ].y;

  			var cx = verts[ w ].x;
  			var cy = verts[ w ].y;

  			if ( PNLTRI.Math.EPSILON_P > ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) ) ) return false;

  			var aX, aY, bX, bY, cX, cY;

  			aX = cx - bx;  aY = cy - by;
  			bX = ax - cx;  bY = ay - cy;
  			cX = bx - ax;  cY = by - ay;

  			var p, px, py;

  			var apx, apy, bpx, bpy, cpx, cpy;
  			var cCROSSap, bCROSScp, aCROSSbp;

  			for ( p = 0; p < n; p ++ ) {

  				px = verts[ p ].x
  				py = verts[ p ].y

  				apx = px - ax;  apy = py - ay;
  					if ( ( apx == 0 ) && ( apy == 0 ) )		continue;
  				bpx = px - bx;  bpy = py - by;
  					if ( ( bpx == 0 ) && ( bpy == 0 ) )		continue;
  				cpx = px - cx;  cpy = py - cy;
  					if ( ( cpx == 0 ) && ( cpy == 0 ) )		continue;

  				// see if p is inside triangle abc

  				aCROSSbp = aX * bpy - aY * bpx;
  				cCROSSap = cX * apy - cY * apx;
  				bCROSScp = bX * cpy - bY * cpx;

  				if ( ( aCROSSbp >= PNLTRI.Math.EPSILON_N ) &&
  					 ( bCROSScp >= PNLTRI.Math.EPSILON_N ) &&
  					 ( cCROSSap >= PNLTRI.Math.EPSILON_N ) ) return false;

  			}

  			return true;

  		};

  		var result = [];

  		var	verts = vertList( startSeg );

  		var n = verts.length;
  		var nv = n;

  		var u, v, w;

  		//  remove nv - 2 vertices, creating 1 triangle every time

  		var count = 2 * nv;   // error detection

  		for ( v = nv - 1; nv > 2; ) {

  			// if we loop, it is probably a non-simple polygon

  			if ( ( count -- ) <= 0 )	return false;

  			// three consecutive vertices in current polygon, <u,v,w>

  			u = v; 	 	if ( nv <= u ) u = 0;     // previous
  			v = u + 1;  if ( nv <= v ) v = 0;     // new v
  			w = v + 1;  if ( nv <= w ) w = 0;     // next

  			if ( snip( verts, u, v, w, nv ) ) {

  				// output Triangle

  				this.polyData.addTriangle( verts[ u ], verts[ v ], verts[ w ] );

  				// remove v from the remaining polygon

  				var s, t;

  				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

  					verts[ s ] = verts[ t ];

  				}

  				nv --;

  				v --;
  				if ( v < 0 )	v = nv-1;

  				// reset error detection counter

  				count = 2 * nv;

  			}

  		}

  		return true;

  	},		*/

  };

  /**
   * @author jahting / http://www.ameco.tv/
   *
   *	Algorithm to create the trapezoidation of a polygon with holes
   *	 according to Seidel's algorithm [Sei91]
   */

  /** @constructor */
  PNLTRI.Trapezoid = function ( inHigh, inLow, inLeft, inRight ) {

  	this.vHigh = inHigh ? inHigh : { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY };
  	this.vLow  = inLow  ? inLow  : { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY };

  	this.lseg = inLeft;
  	this.rseg = inRight;

  //	this.uL = null;				// -> Trapezoid: upper left neighbor
  //	this.uR = null;				// -> Trapezoid: upper right neighbor
  //	this.dL = null;				// -> Trapezoid: lower left neighbor
  //	this.dR = null;				// -> Trapezoid: lower right neighbor

  //	this.sink = null;			// link to corresponding SINK-Node in QueryStructure

  //	this.usave = null;			// temp: uL/uR, preserved for next step
  //	this.uleft = null;			// temp: from uL? (true) or uR (false)

  	this.depth = -1;			// no depth assigned yet

  	this.monoDone = false;		// monotonization: done with trying to split this trapezoid ?

  };

  PNLTRI.Trapezoid.prototype = {

  	constructor: PNLTRI.Trapezoid,

  	clone: function () {
  		var newTrap = new PNLTRI.Trapezoid( this.vHigh, this.vLow, this.lseg, this.rseg );

  		newTrap.uL = this.uL;
  		newTrap.uR = this.uR;

  		newTrap.dL = this.dL;
  		newTrap.dR = this.dR;

  		newTrap.sink = this.sink;

  		return	newTrap;
  	},


  	splitOffLower: function ( inSplitPt ) {
  		var trLower = this.clone();				// new lower trapezoid

  		this.vLow = trLower.vHigh = inSplitPt;

  		// L/R unknown, anyway changed later
  		this.dL = trLower;		// setBelow
  		trLower.uL = this;		// setAbove
  		this.dR = trLower.uR = null;

  		// setAbove
  		if ( trLower.dL )	trLower.dL.uL = trLower;	// dL always connects to uL
  		if ( trLower.dR )	trLower.dR.uR = trLower;	// dR always connects to uR

  		return	trLower;
  	},

  };


  /*==============================================================================
   *
   *============================================================================*/

  // PNLTRI.qsCounter = 0;

  /** @constructor */
  PNLTRI.QsNode = function ( inTrapezoid ) {
  //	this.qsId = PNLTRI.qsCounter++;				// Debug only
  	// Only SINK-nodes are created directly.
  	// The others originate from splitting trapezoids
  	// - by a horizontal line: SINK-Node -> Y-Node
  	// - by a segment: SINK-Node -> X-Node
  	this.trap = inTrapezoid;
  	inTrapezoid.sink = this;
  };

  PNLTRI.QsNode.prototype = {

  	constructor: PNLTRI.QsNode,

  };

  /*==============================================================================
   *
   *============================================================================*/

  /** @constructor */
  PNLTRI.QueryStructure = function ( inPolygonData ) {
  	// initialise the query structure and trapezoid list
  	var initialTrap = new PNLTRI.Trapezoid( null, null, null, null );
  	this.trapArray = [];
  	this.appendTrapEntry( initialTrap );

  //	PNLTRI.qsCounter = 0;
  	this.root = new PNLTRI.QsNode( initialTrap );

  	if ( inPolygonData ) {
  		/*
  		 * adds and initializes specific attributes for all segments
  		 *	// -> QueryStructure: roots of partial tree where vertex is located
  		 *	rootFrom, rootTo:	for vFrom, vTo
  		 *	// marker
  		 *	is_inserted:	already inserted into QueryStructure ?
  		 */
  		var segListArray = inPolygonData.getSegments();
  		for ( var i = 0; i < segListArray.length; i++ ) {
  			segListArray[i].rootFrom = segListArray[i].rootTo = this.root;
  			segListArray[i].is_inserted = false;
  		}
  	}
  };

  PNLTRI.QueryStructure.prototype = {

  	constructor: PNLTRI.QueryStructure,

  	getRoot: function () {
  		return this.root;
  	},


  	appendTrapEntry: function ( inTrapezoid ) {
  		inTrapezoid.trapID = this.trapArray.length;			// for Debug
  		this.trapArray.push( inTrapezoid );
  	},
  	cloneTrap: function ( inTrapezoid ) {
  		var trap = inTrapezoid.clone();
  		this.appendTrapEntry( trap );
  		return	trap;
  	},


  	splitNodeAtPoint: function ( inNode, inPoint, inReturnUpper ) {
  		// inNode: SINK-Node with trapezoid containing inPoint
  		var trUpper = inNode.trap;							// trUpper: trapezoid includes the point
  		if (trUpper.vHigh == inPoint)	return	inNode;				// (ERROR) inPoint is already inserted
  		if (trUpper.vLow == inPoint)	return	inNode;				// (ERROR) inPoint is already inserted
  		var trLower = trUpper.splitOffLower( inPoint );		// trLower: new lower trapezoid
  		this.appendTrapEntry( trLower );

  		// SINK-Node -> Y-Node
  		inNode.yval = inPoint;
  		inNode.trap = null;

  		inNode.right = new PNLTRI.QsNode( trUpper );		// Upper trapezoid sink
  		inNode.left = new PNLTRI.QsNode( trLower );			// Lower trapezoid sink

  		return	inReturnUpper ? trUpper.sink : trLower.sink;
  	},


  	/*
  	 * Mathematics & Geometry helper methods
  	 */

  	fpEqual: function ( inNum0, inNum1 ) {
  		 return		Math.abs( inNum0 - inNum1 ) < PNLTRI.Math.EPSILON_P;
  	},


  	// Checks, whether the vertex inPt is to the left of line segment inSeg.
  	//	Returns:
  	//		>0: inPt is left of inSeg,
  	//		<0: inPt is right of inSeg,
  	//		=0: inPt is co-linear with inSeg
  	//
  	//	ATTENTION: always viewed from -y, not as if moving along the segment chain !!

  	is_left_of: function ( inSeg, inPt, inBetweenY ) {
  		var retVal;
  		var dXfrom = inSeg.vFrom.x - inPt.x;
  		var dXto = inSeg.vTo.x - inPt.x;
  		var dYfromZero = this.fpEqual( inSeg.vFrom.y, inPt.y );
  		if ( this.fpEqual( inSeg.vTo.y, inPt.y ) ) {
  			if ( dYfromZero )	return 0;		// all points on a horizontal line
  			retVal = dXto;
  		} else if ( dYfromZero ) {
  			retVal = dXfrom;
  /*		} else if ( inBetweenY && ( dXfrom * dXto > 0 ) ) {
  			// both x-coordinates of inSeg are on the same side of inPt
  			if ( Math.abs( dXto ) >= PNLTRI.Math.EPSILON_P )	return	dXto;
  			retVal = dXfrom;	*/
  		} else {
  			if ( inSeg.upward ) {
  				return	PNLTRI.Math.ptsCrossProd( inSeg.vFrom, inSeg.vTo, inPt );
  			} else {
  				return	PNLTRI.Math.ptsCrossProd( inSeg.vTo, inSeg.vFrom, inPt );
  			}
  		}
  		if ( Math.abs( retVal ) < PNLTRI.Math.EPSILON_P )		return	0;
  		return	retVal;
  	},


  	/*
  	 * Query structure main methods
  	 */

  	//	This method finds the Nodes in the QueryStructure corresponding
  	//   to the trapezoids that contain the endpoints of inSegment,
  	//	 starting from Nodes rootFrom/rootTo and replacing them with the results.

  	segNodes: function ( inSegment ) {
  		this.ptNode( inSegment, true );
  		this.ptNode( inSegment, false );
  	},

  	// TODO: may need to prevent infinite loop in case of messed up
  	//	trapezoid structure (s. test_add_segment_special_6)

  	ptNode: function ( inSegment, inUseFrom ) {
  		var ptMain, ptOther, qsNode;
  		if ( inUseFrom ) {
  			ptMain = inSegment.vFrom;
  			ptOther = inSegment.vTo;		// used if ptMain is not sufficient
  			qsNode = inSegment.rootFrom;
  		} else {
  			ptMain = inSegment.vTo;
  			ptOther = inSegment.vFrom;
  			qsNode = inSegment.rootTo;
  		}
  		var compRes;
  		var isInSegmentShorter;

  		while ( qsNode ) {
  			if ( qsNode.yval ) {			// Y-Node: horizontal line
  											// 4 times as often as X-Node
  				qsNode = ( PNLTRI.Math.compare_pts_yx( ( ( ptMain == qsNode.yval ) ?	// is the point already inserted ?
  									ptOther : ptMain ), qsNode.yval ) == -1 ) ?
  									qsNode.left : qsNode.right;						// below : above
  			} else if ( qsNode.seg ) {		// X-Node: segment (~vertical line)
  											// 0.8 to 1.5 times as often as SINK-Node
  				if ( ( ptMain == qsNode.seg.vFrom ) ||
  					 ( ptMain == qsNode.seg.vTo ) ) {
  					// the point is already inserted
  					if ( this.fpEqual( ptMain.y, ptOther.y ) ) {
  						// horizontal segment
  						if ( !this.fpEqual( qsNode.seg.vFrom.y, qsNode.seg.vTo.y ) ) {
  							qsNode = ( ptOther.x < ptMain.x ) ? qsNode.left : qsNode.right;		// left : right
  						} else {	// co-linear horizontal reversal: test_add_segment_special_7
  							if ( ptMain == qsNode.seg.vFrom ) {
  								// connected at qsNode.seg.vFrom
  //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vFrom", inUseFrom, inSegment, qsNode )
  								isInSegmentShorter = inSegment.upward ?
  										( ptOther.x >= qsNode.seg.vTo.x ) :
  										( ptOther.x <  qsNode.seg.vTo.x );
  								qsNode = ( isInSegmentShorter ?
  												inSegment.sprev.upward :
  												qsNode.seg.snext.upward ) ? qsNode.right : qsNode.left;		// above : below
  							} else {
  								// connected at qsNode.seg.vTo
  //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vTo", inUseFrom, inSegment, qsNode );
  								isInSegmentShorter = inSegment.upward ?
  										( ptOther.x <  qsNode.seg.vFrom.x ) :
  										( ptOther.x >= qsNode.seg.vFrom.x );
  								qsNode = ( isInSegmentShorter ?
  												inSegment.snext.upward :
  												qsNode.seg.sprev.upward ) ? qsNode.left : qsNode.right;		// below : above
  							}
  						}
  						continue;
  					} else {
  						compRes = this.is_left_of( qsNode.seg, ptOther, false );
  						if ( compRes === 0 ) {
  							// co-linear reversal (not horizontal)
  							//	a co-linear continuation would not reach this point
  							//  since the previous Y-node comparison would have led to a sink instead
  //							console.log("ptNode: co-linear, going back on previous segment", ptMain, ptOther, qsNode );
  							// now as we have two consecutive co-linear segments we have to avoid a cross-over
  							//	for this we need the far point on the "next" segment to the SHORTER of our two
  							//	segments to avoid that "next" segment to cross the longer of our two segments
  							if ( ptMain == qsNode.seg.vFrom ) {
  								// connected at qsNode.seg.vFrom
  //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vFrom", ptMain, ptOther, qsNode );
  								isInSegmentShorter = inSegment.upward ?
  										( ptOther.y >= qsNode.seg.vTo.y ) :
  										( ptOther.y <  qsNode.seg.vTo.y );
  								compRes = isInSegmentShorter ?
  										this.is_left_of( qsNode.seg, inSegment.sprev.vFrom, false ) :
  										-this.is_left_of( qsNode.seg, qsNode.seg.snext.vTo, false );
  							} else {
  								// connected at qsNode.seg.vTo
  //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vTo", ptMain, ptOther, qsNode );
  								isInSegmentShorter = inSegment.upward ?
  										( ptOther.y <  qsNode.seg.vFrom.y ) :
  										( ptOther.y >= qsNode.seg.vFrom.y );
  								compRes = isInSegmentShorter ?
  										this.is_left_of( qsNode.seg, inSegment.snext.vTo, false ) :
  										-this.is_left_of( qsNode.seg, qsNode.seg.sprev.vFrom, false );
  							}
  						}
  					}
  				} else {
  /*					if ( ( PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vFrom ) *			// TODO: Testcase
  							PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vTo )
  						   ) == 0 ) {
  						console.log("ptNode: Pts too close together#2: ", ptMain, qsNode.seg );
  					}		*/
  					compRes = this.is_left_of( qsNode.seg, ptMain, true );
  					if ( compRes === 0 ) {
  						// touching: ptMain lies on qsNode.seg but is none of its endpoints
  						//	should happen quite seldom
  						compRes = this.is_left_of( qsNode.seg, ptOther, false );
  						if ( compRes === 0 ) {
  							// co-linear: inSegment and qsNode.seg
  							//	includes case with ptOther connected to qsNode.seg
  							var tmpPtOther = inUseFrom ? inSegment.sprev.vFrom : inSegment.snext.vTo;
  							compRes = this.is_left_of( qsNode.seg, tmpPtOther, false );
  						}
  					}
  				}
  				if ( compRes > 0 ) {
  					qsNode = qsNode.left;
  				} else if ( compRes < 0 ) {
  					qsNode = qsNode.right;
  				} else {
  					// ???	TODO - not reached with current tests
  					//				possible at all ?
  					return qsNode;
  					// qsNode = qsNode.left;		// left
  					// qsNode = qsNode.right;		// right
  				}
  			} else {		// SINK-Node: trapezoid area
  							// least often
  				if ( !qsNode.trap )	{ console.log("ptNode: unknown type", qsNode); }
  				if ( inUseFrom )	{ inSegment.rootFrom = qsNode; }
  				else				{ inSegment.rootTo = qsNode; }
  				return qsNode;
  			}
  		}	// end while - should not exit here
  	},


   	// Add a new segment into the trapezoidation and update QueryStructure and Trapezoids
  	// 1) locates the two endpoints of the segment in the QueryStructure and inserts them
  	// 2) goes from the high-end trapezoid down to the low-end trapezoid
  	//		changing all the trapezoids in between.
  	// Except for the high-end and low-end no new trapezoids are created.
  	// For all in between either:
  	// - the existing trapezoid is restricted to the left of the new segment
  	//		and on the right side the trapezoid from above is extended downwards
  	// - or the other way round:
  	//	 the existing trapezoid is restricted to the right of the new segment
  	//		and on the left side the trapezoid from above is extended downwards

  	add_segment: function ( inSegment ) {
  		var scope = this;

  		// functions handling the relationship to the upper neighbors (uL, uR)
  		//	of trNewLeft and trNewRight

  		function fresh_seg_or_upward_cusp() {
  			// trCurrent has at most 1 upper neighbor
  			//	and should also have at least 1, since the high-point trapezoid
  			//	has been split off another one, which is now above
  			var trUpper = trCurrent.uL || trCurrent.uR;

  			// trNewLeft and trNewRight CANNOT have been extended from above
  			if ( trUpper.dL && trUpper.dR ) {
  				// upward cusp: top forms a triangle

  				// ATTENTION: the decision whether trNewLeft or trNewRight is the
  				//	triangle trapezoid formed by the two segments has already been taken
  				//	when selecting trCurrent as the left or right lower neighbor to trUpper !!

  				if ( trCurrent == trUpper.dL ) {
  					//	*** Case: FUC_UC_LEFT; prev: ----
  					// console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg to the left!" );
  					//		  upper
  					//   -------*-------
  					//		   + \
  					//	  NL  +   \
  					//		 +	NR \
  					//		+		\
  					trNewRight.uL	= null;			// setAbove; trNewRight.uR, trNewLeft unchanged
  					trUpper.dL		= trNewLeft;	// setBelow; dR: unchanged, NEVER null
  				} else {
  					//	*** Case: FUC_UC_RIGHT; prev: ----
  					// console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg from the right!" );
  					//		  upper
  					//   -------*-------
  					//		   / +
  					//		  /   +	 NR
  					//		 /	NL +
  					//		/		+
  					trNewLeft.uR	= null;			// setAbove; trNewLeft.uL, trNewRight unchanged
  					trUpper.dR		= trNewRight;	// setBelow; dL: unchanged, NEVER null
  				}
  			} else {
  				//	*** Case: FUC_FS; prev: "splitOffLower"
  				// console.log( "fresh_seg_or_upward_cusp: fresh segment, high adjacent segment still missing" );
  				//		  upper
  				//   -------*-------
  				//		   +
  				//	  NL  +
  				//		 +	NR
  				//		+
  				trNewRight.uL = null;			// setAbove; trNewLeft unchanged, set by "splitOffLower"
  				trNewRight.uR = trUpper;
  				trUpper.dR = trNewRight;		// setBelow; trUpper.dL unchanged, set by "splitOffLower"
  			}
   		}

  		function continue_chain_from_above() {
  			// trCurrent has at least 2 upper neighbors
  			if ( trCurrent.usave ) {
  				// 3 upper neighbors (part II)
  				if ( trCurrent.uleft ) {
  					//	*** Case: CC_3UN_LEFT; prev: 1B_3UN_LEFT
  					// console.log( "continue_chain_from_above: 3 upper neighbors (part II): u0a, u0b, uR(usave)" );
  					// => left gets one, right gets two of the upper neighbors
  					// !! trNewRight cannot have been extended from above
  					//		and trNewLeft must have been !!
  					//		   +		/
  					//	  C.uL  + C.uR / C.usave
  					//    - - - -+----*----------
  					//		NL	  +		NR
  					trNewRight.uL = trCurrent.uR;		// setAbove
  					trNewRight.uR = trCurrent.usave;
  					trNewRight.uL.dL = trNewRight;		// setBelow; trNewRight.uL.dR == null, unchanged
  					trNewRight.uR.dR = trNewRight;		// setBelow; trNewRight.uR.dL == null, unchanged
  				} else {
  					//	*** Case: CC_3UN_RIGHT; prev: 1B_3UN_RIGHT
  					// console.log( "continue_chain_from_above: 3 upper neighbors (part II): uL(usave), u1a, u1b" );
  					// => left gets two, right gets one of the upper neighbors
  					// !! trNewLeft cannot have been extended from above
  					//		and trNewRight must have been !!
  					//			\		 +
  					//	 C.usave \ C.uL + C.uR
  					//   ---------*----+- - - -
  					//			NL    +   NR
  					trNewLeft.uR = trCurrent.uL;		// setAbove; first uR !!!
  					trNewLeft.uL = trCurrent.usave;
  					trNewLeft.uL.dL = trNewLeft;		// setBelow; dR == null, unchanged
  					trNewLeft.uR.dR = trNewLeft;		// setBelow; dL == null, unchanged
  				}
  				trNewLeft.usave = trNewRight.usave = null;
  			} else if ( trCurrent.vHigh == trFirst.vHigh ) {		// && meetsHighAdjSeg ??? TODO
  				//	*** Case: CC_2UN_CONN; prev: ----
  				// console.log( "continue_chain_from_above: 2 upper neighbors, fresh seg, continues high adjacent seg" );
  				// !! trNewLeft and trNewRight cannot have been extended from above !!
  				//	  C.uL	 /  C.uR
  				//   -------*---------
  				//	   NL  +	NR
  				trNewRight.uR.dR = trNewRight;			// setBelow; dL == null, unchanged
  				trNewLeft.uR = trNewRight.uL = null;	// setAbove; trNewLeft.uL, trNewRight.uR unchanged
  			} else {
  				//	*** Case: CC_2UN; prev: 1B_1UN_CONT, 2B_NOCON_RIGHT/LEFT, 2B_TOUCH_RIGHT/LEFT, 2B_COLIN_RIGHT/LEFT
  				// console.log( "continue_chain_from_above: simple case, 2 upper neighbors (no usave, not fresh seg)" );
  				// !! trNewLeft XOR trNewRight will have been extended from above !!
  				//	  C.uL	 +  C.uR
  				//   -------+---------
  				//	   NL  +	NR
  				if ( trNewRight == trCurrent ) {		// trNewLeft has been extended from above
  					// setAbove
  					trNewRight.uL = trNewRight.uR;
  					trNewRight.uR = null;
  					// setBelow; dR: unchanged, is NOT always null (prev: 2B_NOCON_LEFT, 2B_TOUCH_LEFT, 2B_COLIN_LEFT)
  					trNewRight.uL.dL = trNewRight;
  				} else {								// trNewRight has been extended from above
  					trNewLeft.uR = trNewLeft.uL;	// setAbove; first uR !!!
  					trNewLeft.uL = null;
  				}
  			}
  		}

  		// functions handling the relationship to the lower neighbors (dL, dR)
  		//	of trNewLeft and trNewRight
  		// trNewLeft or trNewRight MIGHT have been extended from above
  		//  !! in that case dL and dR are different from trCurrent and MUST be set here !!

  		function only_one_trap_below( inTrNext ) {

  			if ( trCurrent.vLow == trLast.vLow ) {
  				// final part of segment

  				if ( meetsLowAdjSeg ) {
  					// downward cusp: bottom forms a triangle

  					// ATTENTION: the decision whether trNewLeft and trNewRight are to the
  					//	left or right of the already inserted segment the new one meets here
  					//	has already been taken when selecting trLast to the left or right
  					//	of that already inserted segment !!

  					if ( trCurrent.dL ) {
  						//	*** Case: 1B_DC_LEFT; next: ----
  						// console.log( "only_one_trap_below: downward cusp, new seg from the left!" );
  						//		+		/
  						//		 +  NR /
  						//	  NL  +	  /
  						//		   + /
  						//   -------*-------
  						//	   C.dL = next

  						// setAbove
  						inTrNext.uL = trNewLeft;	// uR: unchanged, NEVER null
  						// setBelow part 1
  						trNewLeft.dL = inTrNext;
  						trNewRight.dR = null;
  					} else {
  						//	*** Case: 1B_DC_RIGHT; next: ----
  						// console.log( "only_one_trap_below: downward cusp, new seg to the right!" );
  						//		\		+
  						//		 \  NL +
  						//		  \	  +  NR
  						//		   \ +
  						//   -------*-------
  						//	   C.dR = next

  						// setAbove
  						inTrNext.uR = trNewRight;	// uL: unchanged, NEVER null
  						// setBelow part 1
  						trNewLeft.dL = null;
  						trNewRight.dR = inTrNext;
  					}
  				} else {
  					//	*** Case: 1B_1UN_END; next: ----
  					// console.log( "only_one_trap_below: simple case, new seg ends here, low adjacent seg still missing" );
  					//			  +
  					//		NL	 +  NR
  					//			+
  					//   ------*-------
  					//		  next

  					// setAbove
  					inTrNext.uL = trNewLeft;									// trNewLeft must
  					inTrNext.uR = trNewRight;		// must
  					// setBelow part 1
  					trNewLeft.dL = trNewRight.dR = inTrNext;					// Error
  //					trNewRight.dR = inTrNext;
  				}
  				// setBelow part 2
  				trNewLeft.dR = trNewRight.dL = null;
  			} else {
  				// NOT final part of segment

  				if ( inTrNext.uL && inTrNext.uR ) {
  					// inTrNext has two upper neighbors
  					// => a segment ends on the upper Y-line of inTrNext
  					// => inTrNext has temporarily 3 upper neighbors
  					// => marks whether the new segment cuts through
  					//		uL or uR of inTrNext and saves the other in .usave
  					if ( inTrNext.uL == trCurrent ) {
  						//	*** Case: 1B_3UN_LEFT; next: CC_3UN_LEFT
  						// console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): u0a, u0b, uR(usave)" );
  						//		 +		  /
  						//	  NL  +	 NR	 /
  						//		   +	/
  						//   - - - -+--*----
  						//			 +
  						//		  next
  //						if ( inTrNext.uR != trNewRight ) {		// for robustness	TODO: prevent
  							inTrNext.usave = inTrNext.uR;
  							inTrNext.uleft = true;
  							// trNewLeft: L/R undefined, will be extended down and changed anyway
  						// } else {
  							// ERROR: should not happen
  							// console.log( "ERR add_segment: Trapezoid Loop right", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
  //						}
  					} else {
  						//	*** Case: 1B_3UN_RIGHT; next: CC_3UN_RIGHT
  						// console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): uL(usave), u1a, u1b" );
  						//	 \		   +
  						//	  \	  NL  +  NR
  						//	   \	 +
  						//   ---*---+- - - -
  						//		   +
  						//		  next
  //						if ( inTrNext.uL != trNewLeft ) {		// for robustness	TODO: prevent
  							inTrNext.usave = inTrNext.uL;
  							inTrNext.uleft = false;
  							// trNewRight: L/R undefined, will be extended down and changed anyway
  						// } else {
  							// ERROR: should not happen
  							// console.log( "ERR add_segment: Trapezoid Loop left", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
  //						}
  					}
  				//} else {
  					//	*** Case: 1B_1UN_CONT; next: CC_2UN
  					// console.log( "only_one_trap_below: simple case, new seg continues down" );
  					//			  +
  					//		NL	 +  NR
  					//			+
  					//   ------+-------
  					//	 	  +
  					//		next

  					// L/R for one side undefined, which one is not fixed
  					//	but that one will be extended down and changed anyway
  					// for the other side, vLow must lie at the opposite end
  					//	thus both are set accordingly
  				}
  				// setAbove
  				inTrNext.uL = trNewLeft;
  				inTrNext.uR = trNewRight;
  				// setBelow
  				trNewLeft.dR = trNewRight.dL = inTrNext;
  				trNewLeft.dL = trNewRight.dR = null;
  			}
  		}

  		function two_trap_below() {
  			// Find out which one (dL,dR) is intersected by this segment and
  			//	continue down that one
  			var trNext;
  			if ( ( trCurrent.vLow == trLast.vLow ) && meetsLowAdjSeg ) {	// meetsLowAdjSeg necessary? TODO
  				//	*** Case: 2B_CON_END; next: ----
  				// console.log( "two_trap_below: finished, meets low adjacent segment" );
  				//			  +
  				//		NL	 +  NR
  				//			+
  				//   ------*-------
  				//	 		\  C.dR
  				//	  C.dL	 \

  				// setAbove
  				trCurrent.dL.uL = trNewLeft;
  				trCurrent.dR.uR = trNewRight;
  				// setBelow; sequence of assignments essential, just in case: trCurrent == trNewLeft
  				trNewLeft.dL = trCurrent.dL;
  				trNewRight.dR = trCurrent.dR;
  				trNewLeft.dR = trNewRight.dL = null;

  				trNext = null;	      	// segment finished
  			} else {
  				// setAbove part 1
  				trCurrent.dL.uL = trNewLeft;
  				trCurrent.dR.uR = trNewRight;

  				var goDownRight;
  				// passes left or right of an already inserted NOT connected segment
  				//	trCurrent.vLow: high-end of existing segment
  				var compRes = scope.is_left_of( inSegment, trCurrent.vLow, true );
  				if ( compRes > 0 ) {				// trCurrent.vLow is left of inSegment
  					//	*** Case: 2B_NOCON_RIGHT; next: CC_2UN
  					// console.log( "two_trap_below: (intersecting dR)" );
  					//		 +
  					//	  NL  +  NR
  					//		   +
  					//   ---*---+- - - -
  					//		 \	 +
  					//	 C.dL \	C.dR
  					goDownRight = true;
  				} else if ( compRes < 0 ) {			// trCurrent.vLow is right of inSegment
  					//	*** Case: 2B_NOCON_LEFT; next: CC_2UN
  					// console.log( "two_trap_below: (intersecting dL)" );
  					//			  +
  					//		NL	 +  NR
  					//			+
  					//    - - -+---*-------
  					//	 	  +		\  C.dR
  					//	 	 C.dL	 \
  					goDownRight = false;
  				} else {							// trCurrent.vLow lies ON inSegment
  					var vLowSeg = trCurrent.dL.rseg;
  					var directionIsUp = vLowSeg.upward;
  					var otherPt = directionIsUp ? vLowSeg.vFrom : vLowSeg.vTo;
  					compRes = scope.is_left_of( inSegment, otherPt, false );
  					if ( compRes > 0 ) {				// otherPt is left of inSegment
  						//	*** Case: 2B_TOUCH_RIGHT; next: CC_2UN
  						// console.log( "two_trap_below: vLow ON new segment, touching from right" );
  						//		 +
  						//	  NL  +  NR
  						//		   +
  						//   -------*- - - -
  						//		   / +
  						//	 C.dL /	C.dR
  						goDownRight = true;		// like intersecting dR
  					} else if ( compRes < 0 ) {			// otherPt is right of inSegment
  						//	*** Case: 2B_TOUCH_LEFT; next: CC_2UN
  						// console.log( "two_trap_below: vLow ON new segment, touching from left" );
  						//			  +
  						//		NL	 +  NR
  						//			+
  						//    - - -*-------
  						//	 	  +	\  C.dR
  						//	  C.dL	 \
  						goDownRight = false;	// like intersecting dL
  					} else {							// otherPt lies ON inSegment
  						vLowSeg = directionIsUp ? vLowSeg.snext : vLowSeg.sprev;		// other segment with trCurrent.vLow
  						otherPt = directionIsUp ? vLowSeg.vTo : vLowSeg.vFrom;
  						compRes = scope.is_left_of( inSegment, otherPt, false );
  						if ( compRes > 0 ) {				// otherPt is left of inSegment
  							//	*** Case: 2B_COLIN_RIGHT; next: CC_2UN
  							// console.log( "two_trap_below: vLow ON new segment, touching from right" );
  							//		  +
  							//	  NL   +  NR
  							//   -------*- - - -
  							//	  C.dL 	\+  C.dR
  							//			 \+
  							goDownRight = true;		// like intersecting dR
  					//	} else if ( compRes == 0 ) {		//	NOT POSSIBLE, since 3 points on a line is prevented during input of polychains
  					//		goDownRight = true;		// like intersecting dR
  						} else {							// otherPt is right of inSegment
  							//	*** Case: 2B_COLIN_LEFT; next: CC_2UN
  							// console.log( "two_trap_below: vLow ON new segment, touching from left" );
  							//			   +
  							//		NL	  +  NR
  							//    - - - -*-------
  							//	  C.dL	+/  C.dR
  							//		   +/
  							goDownRight = false;		// TODO: for test_add_segment_special_4 -> like intersecting dL
  						}
  					}
  				}
  				if ( goDownRight ) {
  					trNext = trCurrent.dR;
  					// setAbove part 2
  					trCurrent.dR.uL = trNewLeft;
  					// setBelow part 1
  					trNewLeft.dL = trCurrent.dL;
  					trNewRight.dR = null;	// L/R undefined, will be extended down and changed anyway
  				} else {
  					trNext = trCurrent.dL;
  					// setAbove part 2
  					trCurrent.dL.uR = trNewRight;
  					// setBelow part 1
  					trNewRight.dR = trCurrent.dR;
  					trNewLeft.dL = null;	// L/R undefined, will be extended down and changed anyway
  				}
  				// setBelow part 2
  				trNewLeft.dR = trNewRight.dL = trNext;
  			}

   			return	trNext;
  		}

  		//
  		//	main function body
  		//

  /*		if ( ( inSegment.sprev.vTo != inSegment.vFrom ) || ( inSegment.vTo != inSegment.snext.vFrom ) ) {
  			console.log( "add_segment: inconsistent point order of adjacent segments: ",
  						 inSegment.sprev.vTo, inSegment.vFrom, inSegment.vTo, inSegment.snext.vFrom );
  			return;
  		}		*/

  		//	Find the top-most and bottom-most intersecting trapezoids -> rootXXX
  		this.segNodes( inSegment );

  		var segLowVert , segLowNode, meetsLowAdjSeg;		// y-min vertex
  		var segHighVert, segHighNode, meetsHighAdjSeg;		// y-max vertex

  		if ( inSegment.upward ) {
  			segLowVert	= inSegment.vFrom;
  			segHighVert	= inSegment.vTo;
  			segLowNode		= inSegment.rootFrom;
  			segHighNode		= inSegment.rootTo;
  			// was lower point already inserted earlier? => segments meet at their ends
  			meetsLowAdjSeg	= inSegment.sprev.is_inserted;
  			// was higher point already inserted earlier? => segments meet at their ends
  			meetsHighAdjSeg	= inSegment.snext.is_inserted;
  		} else {
  			segLowVert	= inSegment.vTo;
  			segHighVert	= inSegment.vFrom;
  			segLowNode		= inSegment.rootTo;
  			segHighNode		= inSegment.rootFrom;
  			meetsLowAdjSeg	= inSegment.snext.is_inserted;
  			meetsHighAdjSeg	= inSegment.sprev.is_inserted;
  		}

  		//	insert higher vertex into QueryStructure
  		if ( !meetsHighAdjSeg ) {
  			// higher vertex not yet inserted => split trapezoid horizontally
  			var tmpNode = this.splitNodeAtPoint( segHighNode, segHighVert, false );
  			// move segLowNode to new (lower) trapezoid, if it was the one which was just split
  			if ( segHighNode == segLowNode )	segLowNode = tmpNode;
  			segHighNode = tmpNode;
  		}
  		var trFirst = segHighNode.trap;		// top-most trapezoid for this segment

  		// check for robustness		// TODO: prevent
  		if ( !trFirst.uL && !trFirst.uR ) {
  			console.log("ERR add_segment: missing trFirst.uX: ", trFirst );
  			return;
  		}
  		if ( trFirst.vHigh != segHighVert ) {
  			console.log("ERR add_segment: trFirstHigh != segHigh: ", trFirst );
  			return;
  		}

  		//	insert lower vertex into QueryStructure
  		if ( !meetsLowAdjSeg ) {
  			// lower vertex not yet inserted => split trapezoid horizontally
  			segLowNode = this.splitNodeAtPoint( segLowNode, segLowVert, true );
  		}
  		var trLast = segLowNode.trap;			// bottom-most trapezoid for this segment

  		//
  		// Thread the segment into the query "tree" from top to bottom.
  		// All the trapezoids which are intersected by inSegment are "split" into two.
  		// For each the SINK-QsNode is converted into an X-Node and
  		//  new sinks for the new partial trapezoids are added.
  		// In fact a real split only happens at the top and/or bottom end of the segment
  		//	since at every y-line seperating two trapezoids is traverses it
  		//	cuts off the "beam" from the y-vertex on one side, so that at that side
  		//	the trapezoid from above can be extended down.
  		//

  		var trCurrent = trFirst;

  		var trNewLeft, trNewRight, trPrevLeft, trPrevRight;

  		var counter = this.trapArray.length + 2;		// just to prevent infinite loop
  		var trNext;
  		while ( trCurrent ) {
  			if ( --counter < 0 ) {
  				console.log( "ERR add_segment: infinite loop", trCurrent, inSegment, this );
  				return;
  			}
  			if ( !trCurrent.dL && !trCurrent.dR ) {
  				// ERROR: no successors, cannot arise if data is correct
  				console.log( "ERR add_segment: missing successors", trCurrent, inSegment, this );
  				return;
  			}

  			var qs_trCurrent = trCurrent.sink;
  			// SINK-Node -> X-Node
  			qs_trCurrent.seg = inSegment;
  			qs_trCurrent.trap = null;
  			//
  			// successive trapezoids bordered by the same segments are merged
  			//  by extending the trPrevRight or trPrevLeft down
  			//  and redirecting the parent X-Node to the extended sink
  			// !!! destroys tree structure since several nodes now point to the same SINK-Node !!!
  			// TODO: maybe it's not a problem;
  			//  merging of X-Nodes is no option, since they are used as "rootFrom/rootTo" !
  			//
  			if ( trPrevRight && ( trPrevRight.rseg == trCurrent.rseg ) ) {
  				// console.log( "add_segment: extending right predecessor down!", trPrevRight );
  				trNewLeft = trCurrent;
  				trNewRight = trPrevRight;
  				trNewRight.vLow = trCurrent.vLow;
  				// redirect parent X-Node to extended sink
  				qs_trCurrent.left = new PNLTRI.QsNode( trNewLeft );			// trCurrent -> left SINK-Node
  				qs_trCurrent.right = trPrevRight.sink;						// deforms tree by multiple links to trPrevRight.sink
  			} else if ( trPrevLeft && ( trPrevLeft.lseg == trCurrent.lseg ) ) {
  				// console.log( "add_segment: extending left predecessor down!", trPrevLeft );
  				trNewRight = trCurrent;
  				trNewLeft = trPrevLeft;
  				trNewLeft.vLow = trCurrent.vLow;
  				// redirect parent X-Node to extended sink
  				qs_trCurrent.left = trPrevLeft.sink;						// deforms tree by multiple links to trPrevLeft.sink
  				qs_trCurrent.right = new PNLTRI.QsNode( trNewRight );		// trCurrent -> right SINK-Node
  			} else {
  				trNewLeft = trCurrent;
  				trNewRight = this.cloneTrap(trCurrent);
  				qs_trCurrent.left = new PNLTRI.QsNode( trNewLeft );			// trCurrent -> left SINK-Node
  				qs_trCurrent.right = new PNLTRI.QsNode( trNewRight );		// new clone -> right SINK-Node
  			}

  			// handle neighbors above
  			if ( trCurrent.uL && trCurrent.uR )	{
  				continue_chain_from_above();
  			} else {
  				fresh_seg_or_upward_cusp();
  			}

  			// handle neighbors below
  			if ( trCurrent.dL && trCurrent.dR ) {
  				trNext = two_trap_below();
  			} else {
  				if ( trCurrent.dL ) {
  					// console.log( "add_segment: only_one_trap_below! (dL)" );
  					trNext = trCurrent.dL;
  				} else {
  					// console.log( "add_segment: only_one_trap_below! (dR)" );
  					trNext = trCurrent.dR;
  				}
  				only_one_trap_below( trNext );
  			}

  			if ( trNewLeft.rseg )	trNewLeft.rseg.trLeft = trNewRight;
  			if ( trNewRight.lseg )	trNewRight.lseg.trRight = trNewLeft;
  			trNewLeft.rseg = trNewRight.lseg  = inSegment;
  			inSegment.trLeft = trNewLeft;
  			inSegment.trRight = trNewRight;

  			// further loop-step down ?
  			if ( trCurrent.vLow != trLast.vLow ) {
  				trPrevLeft = trNewLeft;
  				trPrevRight = trNewRight;

  				trCurrent = trNext;
  			} else {
  				trCurrent = null;
  			}
  		}	// end while

  		inSegment.is_inserted = true;
  		// console.log( "add_segment: ###### DONE ######" );
  	},

  	// Assigns a depth to all trapezoids;
  	//	0: outside, 1: main polygon, 2: holes, 3:polygons in holes, ...
  	// Checks segment orientation and marks those polygon chains for reversal
  	//	where the polygon inside lies to their right (contour in CW, holes in CCW)
  	assignDepths: function ( inPolyData ) {
  		var thisDepth = [ this.trapArray[0] ];
  		var nextDepth = [];

  		var thisTrap, borderSeg, curDepth = 0;
  		do {
  			// rseg should exactely go upward on trapezoids inside the polygon (odd depth)
  			var expectedRsegUpward = ( ( curDepth % 2 ) == 1 );
  			while ( thisTrap = thisDepth.pop() ) {			// assignment !
  				if ( thisTrap.depth != -1 )	continue;
  				thisTrap.depth = curDepth;
  				//
  				if ( thisTrap.uL )	thisDepth.push( thisTrap.uL );
  				if ( thisTrap.uR )	thisDepth.push( thisTrap.uR );
  				if ( thisTrap.dL )	thisDepth.push( thisTrap.dL );
  				if ( thisTrap.dR )	thisDepth.push( thisTrap.dR );
  				//
  				if ( ( borderSeg = thisTrap.lseg ) && ( borderSeg.trLeft.depth == -1 ) )	// assignment !
  					nextDepth.push( borderSeg.trLeft );
  				if ( borderSeg = thisTrap.rseg ) {											// assignment !
  					if ( borderSeg.trRight.depth == -1 )
  						nextDepth.push( borderSeg.trRight );
  					if ( borderSeg.upward != expectedRsegUpward )
  						inPolyData.set_PolyLeft_wrong( borderSeg.chainId );
  				}
  			}
  			thisDepth = nextDepth; nextDepth = [];
  			curDepth++;
  		} while ( thisDepth.length > 0 );
  	},

  	// creates the visibility map:
  	//	for each vertex the list of all vertices in CW order which are directly
  	//	visible through neighboring trapezoids and thus can be connected by a diagonal

  	create_visibility_map: function ( inPolygonData ) {
  		// positional slots for neighboring trapezoid-diagonals
  		var DIAG_UL = 0, DIAG_UM = 1, DIAG_ULR = 2, DIAG_UR = 3;
  		var DIAG_DR = 4, DIAG_DM = 5, DIAG_DLR = 6, DIAG_DL = 7;

  		var i, j;
  		var nbVertices = inPolygonData.nbVertices();

  		// initialize arrays for neighboring trapezoid-diagonals and vertices
  		var myVisibleDiagonals	= new Array(nbVertices);
  		for ( i = 0; i < nbVertices; i++ ) {
  			myVisibleDiagonals[i] = new Array(DIAG_DL+1);
  		}
  		// create the list of neighboring trapezoid-diagonals
  		//	put into their positional slots
  		var myExternalNeighbors = new Array(nbVertices);
  		for ( i = 0, j = this.trapArray.length; i < j; i++ ) {
  			var curTrap = this.trapArray[i];
  			var highPos = curTrap.uL ?
  						( curTrap.uR ? DIAG_DM : DIAG_DL ) :
  						( curTrap.uR ? DIAG_DR : DIAG_DLR );
  			var lowPos = curTrap.dL ?
  						( curTrap.dR ? DIAG_UM : DIAG_UL ) :
  						( curTrap.dR ? DIAG_UR : DIAG_ULR );

  			if ( ( curTrap.depth % 2 ) == 1 ) {		// inside ?
  				if ( ( highPos == DIAG_DM ) || ( lowPos == DIAG_UM ) ||
  					 ( ( highPos == DIAG_DL ) && ( lowPos == DIAG_UR ) ) ||
  					 ( ( highPos == DIAG_DR ) && ( lowPos == DIAG_UL ) ) ) {
  					var lhDiag = inPolygonData.appendDiagonalsEntry( {
  									vFrom: curTrap.vLow, vTo: curTrap.vHigh,
  									mprev: null, mnext: null, marked: false } );
  					var hlDiag = inPolygonData.appendDiagonalsEntry( {
  									vFrom: curTrap.vHigh, vTo: curTrap.vLow, revDiag: lhDiag,
  									mprev: null, mnext: null, marked: false } );
  					lhDiag.revDiag = hlDiag;
  					myVisibleDiagonals[ curTrap.vLow.id][ lowPos] = lhDiag;
  					myVisibleDiagonals[curTrap.vHigh.id][highPos] = hlDiag;
  				}
  			} else {		// outside, hole
  				if ( curTrap.vHigh.id !== null )	myExternalNeighbors[curTrap.vHigh.id] = highPos;
  				if ( curTrap.vLow.id  !== null )	myExternalNeighbors[ curTrap.vLow.id] = lowPos;
  			}
  		}
  		// create the list of outgoing diagonals in the right order (CW)
  		//	from the ordered list of neighboring trapezoid-diagonals
  		//	- starting from an external one
  		// and connect those incoming to
  		var curDiag, curDiags, firstElem, fromVertex, lastIncoming;
  		for ( i = 0; i < nbVertices; i++ ) {
  			curDiags  = myVisibleDiagonals[i];
  			firstElem = myExternalNeighbors[i];
  			if ( firstElem == null )	continue;		// eg. skipped vertices (zero length, co-linear		// NOT: === !
  			j = firstElem;
  			lastIncoming = null;
  			do {
  				if ( j++ > DIAG_DL )			j = DIAG_UL;	// circular positional list
  				if ( curDiag = curDiags[j] ) {
  					if ( lastIncoming ) {
  						curDiag.mprev = lastIncoming;
  						lastIncoming.mnext = curDiag;
  					} else {
  						fromVertex = curDiag.vFrom;
  						fromVertex.firstOutDiag = curDiag;
  					}
  					lastIncoming = curDiag.revDiag;
  				}
  			} while ( j != firstElem );
  			if ( lastIncoming )		fromVertex.lastInDiag = lastIncoming;
  		}
  	},


  };


  /*==============================================================================
   *
   *============================================================================*/

  /** @constructor */
  PNLTRI.Trapezoider = function ( inPolygonData ) {

  	this.polyData		= inPolygonData;
  	this.queryStructure	= new PNLTRI.QueryStructure( this.polyData );

  };

  PNLTRI.Trapezoider.prototype = {

  	constructor: PNLTRI.Trapezoider,


  	/*
  	 * Mathematics helper methods
  	 */

  	optimise_randomlist: function ( inOutSegListArray ) {
  		// makes sure that the first N segments are one from each of the N polygon chains
  		var mainIdx = 0;
  		var helpIdx = this.polyData.nbPolyChains();
  		if ( helpIdx == 1 )		return;
  		var chainMarker = new Array(helpIdx);
  		var oldSegListArray = inOutSegListArray.concat();
  		for (var i=0; i<oldSegListArray.length; i++) {
  			var chainId = oldSegListArray[i].chainId;
  			if ( chainMarker[chainId] ) {
  				inOutSegListArray[helpIdx++] = oldSegListArray[i];
  			} else {
  				inOutSegListArray[mainIdx++] = oldSegListArray[i];
  				chainMarker[chainId] = true;
  			}
  		}
  	},


  	/*
  	 * main methods
  	 */

  	// Creates the trapezoidation of the polygon
  	//  and assigns a depth to all trapezoids (odd: inside, even: outside).

  	trapezoide_polygon: function () {							// <<<< public
  		var randSegListArray = this.polyData.getSegments().concat();
  //		console.log( "Polygon Chains: ", dumpSegmentList( randSegListArray ) );
  		PNLTRI.Math.array_shuffle( randSegListArray );
  		this.optimise_randomlist( randSegListArray );
  //		console.log( "Random Segment Sequence: ", dumpRandomSequence( randSegListArray ) );

  		var nbSegs = randSegListArray.length;
  		var myQs = this.queryStructure;

  		var i, current = 0, logstar = nbSegs;
  		while ( current < nbSegs ) {
  			// The CENTRAL mechanism for the near-linear performance:
  			//	stratefies the loop through all segments into log* parts
  			//	and computes new root-Nodes for the remaining segments in each
  			//	partition.
  			logstar = Math.log(logstar)/Math.LN2;		// == log2(logstar)
  			var partEnd = ( logstar > 1 ) ? Math.floor( nbSegs / logstar ) : nbSegs;

  			// Core: adds next partition of the segments
  			for (; current < partEnd; current++ ) { myQs.add_segment( randSegListArray[current] ); }
  //			console.log( nbSegs, current );

  			// To speed up the segment insertion into the trapezoidation
  			//	the endponts of those segments not yet inserted
  			//	are repeatedly pre-located,
  			// thus their final location-query can start at the top of the
  			//	appropriate sub-tree instead of the root of the whole
  			//	query structure.
  			//
  			for (i = current; i < nbSegs; i++) { this.queryStructure.segNodes( randSegListArray[i] ); }
  		}

  		myQs.assignDepths( this.polyData );
  		// cleanup to support garbage collection
  		for (i = 0; i < nbSegs; i++) { randSegListArray[i].trLeft = randSegListArray[i].trRight = null; }
  	},

  	// Creates a visibility map:
  	//	for each vertex the list of all vertices in CW order which are directly
  	//	visible through neighboring trapezoids and thus can be connected by a diagonal

  	create_visibility_map: function () {
  		return	this.queryStructure.create_visibility_map( this.polyData );
  	},

  };

  /**
   * @author jahting / http://www.ameco.tv/
   *
   *	Algorithm to split a polygon into uni-y-monotone sub-polygons
   *
   *	1) creates a trapezoidation of the main polygon according to Seidel's
   *	   algorithm [Sei91]
   *	2) uses diagonals of the trapezoids as additional segments
   *		to split the main polygon into uni-y-monotone sub-polygons
   */

  /** @constructor */
  PNLTRI.MonoSplitter = function ( inPolygonData ) {

  	this.polyData = inPolygonData;

  	this.trapezoider = null;

  };


  PNLTRI.MonoSplitter.prototype = {

  	constructor: PNLTRI.MonoSplitter,


  	monotonate_trapezoids: function () {					// <<<<<<<<<< public
  		// Trapezoidation
  		this.trapezoider = new PNLTRI.Trapezoider( this.polyData );
  		//	=> one triangular trapezoid which lies inside the polygon
  		this.trapezoider.trapezoide_polygon();

  		// create segments for diagonals
  		this.trapezoider.create_visibility_map();
  		// create mono chains by inserting diagonals
  		this.polyData.create_mono_chains();

  		// create UNIQUE monotone sub-polygons
  		this.polyData.unique_monotone_chains_max();
  	},

  };

  /**
   * @author jahting / http://www.ameco.tv/
   *
   *	Algorithm to triangulate uni-y-monotone polygons [FoM84]
   *
   *	expects list of doubly linked monoChains, with Y-max as first vertex
   */


  /** @constructor */
  PNLTRI.MonoTriangulator = function ( inPolygonData ) {

  	this.polyData	= inPolygonData;

  };


  PNLTRI.MonoTriangulator.prototype = {

  	constructor: PNLTRI.MonoTriangulator,


  	// Pass each uni-y-monotone polygon with start at Y-max for greedy triangulation.

  	triangulate_all_polygons: function () {					// <<<<<<<<<< public
  		var	normedMonoChains = this.polyData.getMonoSubPolys();
  		this.polyData.clearTriangles();
  		for ( var i=0; i<normedMonoChains.length; i++ ) {
  			// loop through uni-y-monotone chains
  			// => monoPosmin is next to monoPosmax (left or right)
  			var monoPosmax = normedMonoChains[i];
  			var prevMono = monoPosmax.mprev;
  			var nextMono = monoPosmax.mnext;

  			if ( nextMono.mnext == prevMono ) {		// already a triangle
  				this.polyData.addTriangle( monoPosmax.vFrom, nextMono.vFrom, prevMono.vFrom );
  			} else {								// triangulate the polygon
  				this.triangulate_monotone_polygon( monoPosmax );
  			}
  		}
  	},

  	//	algorithm to triangulate an uni-y-monotone polygon in O(n) time.[FoM84]

  	triangulate_monotone_polygon: function ( monoPosmax ) {			// private
  		var scope = this;

  		function error_cleanup() {
  			// Error in algorithm OR polygon is not uni-y-monotone
  			console.log( "ERR uni-y-monotone: only concave angles left", vertBackLog );
  			// push all "wrong" triangles => loop ends
  			while (vertBackLogIdx > 1) {
  				vertBackLogIdx--;
  				scope.polyData.addTriangle(	vertBackLog[vertBackLogIdx-1],
  											vertBackLog[vertBackLogIdx],
  											vertBackLog[vertBackLogIdx+1] );
  			}
  		}

  		//
  		// Decisive for this algorithm to work correctly is to make sure
  		//  the polygon stays uni-y-monotone when cutting off ears, i.e.
  		//  to make sure the top-most and bottom-most vertices are removed last
  		// Usually this is done by handling the LHS-case ("LeftHandSide is a single segment")
  		//	and the RHS-case ("RightHandSide segment is a single segment")
  		//	differently by starting at the bottom for LHS and at the top for RHS.
  		// This is not necessary. It can be seen easily, that starting
  		//	from the vertex next to top handles both cases correctly.
  		//

  		var frontMono = monoPosmax.mnext;		// == LHS: YminPoint; RHS: YmaxPoint.mnext
  		var endVert = monoPosmax.vFrom;

  		var vertBackLog = [ frontMono.vFrom ];
  		var vertBackLogIdx = 0;

  		frontMono = frontMono.mnext;
  		var frontVert = frontMono.vFrom;

  		// check for robustness		// TODO
  		if (frontVert == endVert)	return;		// Error: only 2 vertices

  		while ( (frontVert != endVert) || (vertBackLogIdx > 1) ) {
  			if ( vertBackLogIdx > 0 ) {
  				// vertBackLog is not empty
  				var insideAngleCCW = PNLTRI.Math.ptsCrossProd( vertBackLog[vertBackLogIdx], frontVert, vertBackLog[vertBackLogIdx-1] );
  				if ( Math.abs(insideAngleCCW) <= PNLTRI.Math.EPSILON_P ) {
  					// co-linear
  					if ( (frontVert == endVert) ||		// all remaining triangles are co-linear (180 degree)
  						 ( PNLTRI.Math.compare_pts_yx( vertBackLog[vertBackLogIdx], frontVert ) ==				// co-linear-reversal
  						   PNLTRI.Math.compare_pts_yx( vertBackLog[vertBackLogIdx], vertBackLog[vertBackLogIdx-1] ) ) ) {
  						insideAngleCCW = 1;		// => create triangle
  					}
  				}
  				if ( insideAngleCCW > 0 ) {
  					// convex corner: cut if off
  					this.polyData.addTriangle( vertBackLog[vertBackLogIdx-1], vertBackLog[vertBackLogIdx], frontVert );
  					vertBackLogIdx--;
  				} else {
  					// non-convex: add frontVert to the vertBackLog
  					vertBackLog[++vertBackLogIdx] = frontVert;
  					if (frontVert == endVert)	error_cleanup();	// should never happen !!
  					else {
  						frontMono = frontMono.mnext;
  						frontVert = frontMono.vFrom;
  					}
  				}
  			} else {
  				// vertBackLog contains only start vertex:
  				//	add frontVert to the vertBackLog and advance frontVert
  				vertBackLog[++vertBackLogIdx] = frontVert;
  				frontMono = frontMono.mnext;
  				frontVert = frontMono.vFrom;
  			}
  		}
  		// reached the last vertex. Add in the triangle formed
  		this.polyData.addTriangle( vertBackLog[vertBackLogIdx - 1], vertBackLog[vertBackLogIdx], frontVert );
  	},

  };

  /**
   * @author jahting / http://www.ameco.tv/
   */

  /*******************************************************************************
   *
   *	Triangulator for Simple Polygons with Holes
   *
   *  polygon with holes:
   *	- one closed contour polygon chain
   *  - zero or more closed hole polygon chains
   *
   *	polygon chain (closed):
   *	- Array of vertex Objects with attributes "x" and "y"
   *		- representing the sequence of line segments
   *		- closing line segment (last->first vertex) is implied
   *		- line segments are non-zero length and non-crossing
   *
   *	"global vertex index":
   *	- vertex number resulting from concatenation all polygon chains (starts with 0)
   *
   *
   *	Parameters (will not be changed):
   *		inPolygonChains:
   *		- Array of polygon chains
   *
   *	Results (are a fresh copy):
   *		triangulate_polygon:
   *		- Array of Triangles ( Array of 3 "global vertex index" values )
   *
   ******************************************************************************/

  /** @constructor */
  PNLTRI.Triangulator = function () {

  	this.lastPolyData = null;		// for Debug purposes only

  };


  PNLTRI.Triangulator.prototype = {

  	constructor: PNLTRI.Triangulator,


  	clear_lastData: function () {	// save memory after Debug
  		this.lastPolyData = null;
  	},

  	// for the polygon data AFTER triangulation
  	//	returns an Array of flags, one flag for each polygon chain:
  	//		lies the inside of the polygon to the left?
  	//		"true" implies CCW for contours and CW for holes
  	get_PolyLeftArr: function () {
  		if ( this.lastPolyData )	return this.lastPolyData.get_PolyLeftArr();
  		return	null;
  	},


  	triangulate_polygon: function ( inPolygonChains, inForceTrapezoidation ) {

  		// collected conditions for selecting EarClipTriangulator over Seidel's algorithm
  		function is_basic_polygon() {
  			if (inForceTrapezoidation)	return	false;
  			return	( myPolygonData.nbPolyChains() == 1 );
  		}


  		this.clear_lastData();
  		if ( ( !inPolygonChains ) || ( inPolygonChains.length === 0 ) )		return	[];
  		//
  		// initializes general polygon data structure
  		//
  		var myPolygonData = new PNLTRI.PolygonData( inPolygonChains );
  		//
  		var basicPolygon = is_basic_polygon();
  		var	myTriangulator;
  		if ( basicPolygon ) {
  			//
  			// triangulates single polygon without holes
  			//
  			myTriangulator = new PNLTRI.EarClipTriangulator( myPolygonData );
  			basicPolygon = myTriangulator.triangulate_polygon_no_holes();
  		}
  		if ( !basicPolygon ) {
  			//
  			// splits polygon into uni-y-monotone sub-polygons
  			//
  			var	myMonoSplitter = new PNLTRI.MonoSplitter( myPolygonData );
  			myMonoSplitter.monotonate_trapezoids();
  			//
  			// triangulates all uni-y-monotone sub-polygons
  			//
  			myTriangulator = new PNLTRI.MonoTriangulator( myPolygonData );
  			myTriangulator.triangulate_all_polygons();
  		}
  		//
  		this.lastPolyData = myPolygonData;
  		return	myPolygonData.getTriangles();	// copy of triangle list
  	}


  };

  // Export the PNLTRI object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.

  {
    if ( module.exports) {
      exports = module.exports = PNLTRI;
    }
    exports.PNLTRI = PNLTRI;
  }
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       @name PolygonRenderer
       @class
           Basic renderer for polygon
       @param {AbstractGlobe} globe AbstractGlobe
       @augments VectorRenderer
       @constructor
       */

  var PolygonRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe);
    this.maxTilePerGeometry = 2;
    this.renderContext = globe.renderContext;
    this.defaultVertexShader = "attribute vec3 vertex;\n";
    this.defaultVertexShader += "uniform mat4 mvp;\n";
    this.defaultVertexShader += "void main(void) \n";
    this.defaultVertexShader += "{\n";
    this.defaultVertexShader += "	gl_Position = mvp * vec4(vertex, 1.0);\n";
    this.defaultVertexShader += "}\n";
    this.extrudeVertexShader = "attribute vec3 vertex;\n";
    this.extrudeVertexShader += "attribute vec4 normal;\n";
    this.extrudeVertexShader += "uniform float extrusionScale; \n";
    this.extrudeVertexShader += "uniform mat4 mvp;\n";
    this.extrudeVertexShader += "void main(void) \n";
    this.extrudeVertexShader += "{\n";
    this.extrudeVertexShader += "	vec3 extrudedVertex = vertex + normal.w * vec3(normal.x, normal.y, normal.z) * extrusionScale;";
    this.extrudeVertexShader += "	gl_Position = mvp * vec4(extrudedVertex, 1.0);\n";
    this.extrudeVertexShader += "}\n";
    this.fragmentShader = "precision lowp float; \n";
    this.fragmentShader += "uniform vec4 u_color;\n";
    this.fragmentShader += "void main(void)\n";
    this.fragmentShader += "{\n";
    this.fragmentShader += "	gl_FragColor = u_color;\n";
    this.fragmentShader += "	//if (u_color.a == 0.0) discard;\n";
    this.fragmentShader += "}\n";
    this.program = new Program(globe.renderContext);
    this.program.createFromSource(this.defaultVertexShader, this.fragmentShader);
    this.extrudeProgram = new Program(globe.renderContext);
    this.extrudeProgram.createFromSource(this.extrudeVertexShader, this.fragmentShader);
  };
  /**************************************************************************************************************/


  Utils.inherits(VectorRenderer, PolygonRenderer);
  /**************************************************************************************************************/

  /**
       @name PolygonRenderable
       @class
           Renderable constructor for Polygon
       @param {Bucket} bucket Bucket
       @augments BatchRenderable
       @constructor
       */

  var PolygonRenderable = function (bucket) {
    BatchRenderable.prototype.constructor.call(this, bucket);
    this.origin = null;
    this.vertexSize = bucket.style.extrude ? 7 : 3;
    this.matrix = mat4.create();
  };

  Utils.inherits(BatchRenderable, PolygonRenderable);
  /**************************************************************************************************************/

  /**
   * Create an interpolated for polygon clipping
   */

  var _createInterpolatedVertex$1 = function (t, p1, p2) {
    return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
  };
  /**************************************************************************************************************/

  /**
       Clip polygon to a side
       */


  var clipPolygonToSide = function (coord, sign, value, polygon) {
    var clippedPolygon = [];
    var t, newPoint; // iterate through vertices

    for (var i = 0; i < polygon.length; i++) {
      var p1 = polygon[i];
      var p2 = polygon[(i + 1) % polygon.length];
      var val1 = p1[coord];
      var val2 = p2[coord]; // test containement

      var firstInside = (val1 - value) * sign >= 0.0;
      var secondInside = (val2 - value) * sign >= 0.0; // output vertices for inside polygon

      if (!firstInside && secondInside) {
        t = (value - val1) / (val2 - val1);
        newPoint = _createInterpolatedVertex$1(t, p1, p2);
        clippedPolygon.push(newPoint);
        clippedPolygon.push(p2);
      } else if (firstInside && secondInside) {
        clippedPolygon.push(p2);
      } else if (firstInside && !secondInside) {
        t = (value - val1) / (val2 - val1);
        newPoint = _createInterpolatedVertex$1(t, p1, p2);
        clippedPolygon.push(newPoint);
      }
    }

    return clippedPolygon;
  };
  /**************************************************************************************************************/

  /**
       Clip polygon
       */


  var clipPolygon = function (coordinates, bound) {
    var c;
    c = clipPolygonToSide(0, 1, bound.west, coordinates);
    c = clipPolygonToSide(0, -1, bound.east, c);
    c = clipPolygonToSide(1, 1, bound.south, c);
    c = clipPolygonToSide(1, -1, bound.north, c);
    return c;
  };
  /**************************************************************************************************************/

  /**
       Check if a geometry crosses the date line
       */


  var _fixDateLine = function (coords) {
    //return [coords];
    var crossDateLine = false;

    for (var i = 1; i < coords.length && !crossDateLine; i++) {
      var deltaLon = Math.abs(coords[i][0] - coords[i - 1][0]);

      if (deltaLon > 180 && deltaLon < 360) {
        // DateLine!
        crossDateLine = true;
      }
    }

    var n;

    if (crossDateLine) {
      // Ensure coordinates are always negative
      var negCoords = [];

      for (n = 0; n < coords.length; n++) {
        if (coords[n][0] > 0) {
          negCoords[n] = [coords[n][0] - 360, coords[n][1]];
        } else {
          negCoords[n] = [coords[n][0], coords[n][1]];
        }
      }

      var posCoords = []; // Ensure coordinates are always positive

      for (n = 0; n < coords.length; n++) {
        if (coords[n][0] < 0) {
          posCoords[n] = [coords[n][0] + 360, coords[n][1]];
        } else {
          posCoords[n] = [coords[n][0], coords[n][1]];
        }
      }

      return [posCoords, negCoords];
    } else {
      return [coords];
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to the renderbale
   * Vertex buffer : geometry|extrude
   * Index buffer : geometry triangles|extrude triangles|lines
   * Normal buffer : normals.xyz, extrude value as w
   * @function build
   * @memberof PolygonRenderable.prototype
   * @param geometry
   */


  PolygonRenderable.prototype.build = function (geometry) {
    var renderer = this.bucket.renderer;
    var style = this.bucket.style;
    var coordinateSystem = renderer.globe.getCoordinateSystem();
    var polygons = geometry.type === Constants.GEOMETRY.MultiPolygon ? geometry.coordinates : [geometry.coordinates];
    var geometryBound = new GeoBound();
    var csBound = new GeoBound(coordinateSystem.getGeoBound().getWest(), coordinateSystem.getGeoBound().getSouth(), coordinateSystem.getGeoBound().getEast(), coordinateSystem.getGeoBound().getNorth());
    var crsName = "CRS:84";

    if (typeof geometry.crs !== "undefined") {
      crsName = geometry.crs.properties.name;
    }

    var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(polygons[0][0], crsName, coordinateSystem);

    if (!geometryBound.intersects(csBound)) {
      return;
    }

    var pos3d = vec3.create();
    var i, n;

    if (!this.origin) {
      this.origin = vec3.create();
      coordinateSystem.get3DFromWorld(convertedCoord[0], this.origin); // Correction : add [0]

      mat4.identity(this.matrix);
      mat4.translate(this.matrix, this.origin);
    }

    var lastIndex = this.vertices.length / this.vertexSize;
    var upOffset, lowOffset;
    var contours = [];

    for (n = 0; n < polygons.length; n++) {
      contours = contours.concat(_fixDateLine(polygons[n][0]));
    }

    var offset;

    for (n = 0; n < contours.length; n++) {
      var coords = clipPolygon(contours[n], csBound);
      offset = this.vertices.length; // Build upper polygon vertices

      var clockwise = 0;

      for (i = 0; i < coords.length; i++) {
        // Always use coordinates at zero height on vertex construction, height will be taken into account on extrude
        coordinateSystem.get3DFromWorldInCrs([coords[i][0], coords[i][1], 0.0], crsName, pos3d);
        this.vertices[offset] = pos3d[0] - this.origin[0];
        this.vertices[offset + 1] = pos3d[1] - this.origin[1];
        this.vertices[offset + 2] = pos3d[2] - this.origin[2]; // Find out if its vertices ordered clockwise to build index buffer properly

        if (i < coords.length - 1) {
          clockwise += (coords[i + 1][0] - coords[i][0]) * (coords[i + 1][1] + coords[i][1]);
        }

        if (style.extrude) {
          // Compute normals
          vec3.normalize(pos3d);
          this.vertices[offset + 3] = pos3d[0];
          this.vertices[offset + 4] = pos3d[1];
          this.vertices[offset + 5] = pos3d[2];
          var extrudeValue;

          if (typeof style.extrude === "boolean") {
            // Extrude value extracted from KML, use the height coordinate
            extrudeValue = coords[i][2];
          } else {
            // Extrude value is a float defined by user
            extrudeValue = style.extrude;
          }

          this.vertices[offset + 6] = extrudeValue * coordinateSystem.geoide.heightScale;
        }

        offset += this.vertexSize;
      } // Build bottom polygon vertices on extrude


      if (style.extrude) {
        // Use same vertices as upper polygon but resest the 4-th compoenent
        var prevOffset = lastIndex * this.vertexSize;
        this.vertices = this.vertices.concat(this.vertices.slice(prevOffset, offset)); // Reset the 4-th component for extrusion

        for (i = offset; i < this.vertices.length; i += this.vertexSize) {
          this.vertices[i + 6] = 0.0;
        }
      } // Build triangle indices for upper polygon


      var triangulator = new pnltri.Triangulator();
      var contour = coords.map(function (value) {
        return {
          x: value[0],
          y: value[1]
        };
      });
      var triangList = triangulator.triangulate_polygon([contour]);

      for (i = 0; i < triangList.length; i++) {
        this.triIndices.push(lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][2]); //this.lineIndices.push( lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][1], lastIndex + triangList[i][2], lastIndex + triangList[i][2], lastIndex + triangList[i][0] );
      } // Build side triangle indices


      if (style.extrude) {
        upOffset = lastIndex;
        lowOffset = lastIndex + coords.length;

        for (i = 0; i < coords.length - 1; i++) {
          // Depending on vertice order, push the
          if (clockwise > 0) {
            this.triIndices.push(upOffset, upOffset + 1, lowOffset);
            this.triIndices.push(upOffset + 1, lowOffset + 1, lowOffset);
          } else {
            this.triIndices.push(upOffset, lowOffset, upOffset + 1);
            this.triIndices.push(upOffset + 1, lowOffset, lowOffset + 1);
          }

          upOffset += 1;
          lowOffset += 1;
        }
      } // Build line indices for upper polygon


      for (i = 0; i < coords.length - 1; i++) {
        this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
      } // Build top-to-bottom line indices


      if (style.extrude) {
        upOffset = lastIndex;
        lowOffset = lastIndex + coords.length;

        for (i = 0; i < coords.length - 1; i++) {
          this.lineIndices.push(upOffset + i, lowOffset + i);
        }
      } // Update last index


      lastIndex = this.vertices.length / this.vertexSize;
    } // Geometry is always added contrary to tiled renderables


    return true;
  };
  /**************************************************************************************************************/

  /**
       @name PolygonBucket
       @class
           Bucket constructor for PolygonRenderer
       @param layer
       @param style
       @constructor
       */


  var PolygonBucket = function (layer, style) {
    this.layer = layer;
    this.style = style;
    this.renderer = null;
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof PolygonBucket.prototype
   * @return {PolygonRenderable} Renderable
   */


  PolygonBucket.prototype.createRenderable = function () {
    return new PolygonRenderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Check if a bucket is compatible
   * @function isCompatible
   * @memberof PolygonBucket.prototype
   * @param style
   * @return {Boolean} Is compatible ?
   */


  PolygonBucket.prototype.isCompatible = function (style) {
    return this.style === style;
  };
  /**************************************************************************************************************/

  /**
   *    Render all the polygons
   * @function render
   * @memberof PolygonRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  PolygonRenderer.prototype.render = function (renderables, start, end) {
    var renderContext = this.globe.renderContext;
    var gl = renderContext.gl;
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL); //gl.enable(gl.POLYGON_OFFSET_FILL);
    //gl.polygonOffset(-2.0,-2.0);
    //gl.disable(gl.DEPTH_TEST);

    var currentProgram = null; // Compute the viewProj matrix

    var viewProjMatrix = mat4.create();
    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, viewProjMatrix);
    var modelViewProjMatrix = mat4.create();

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      var style = renderable.bucket.style; // Setup program

      var program = style.extrude ? this.extrudeProgram : this.program;

      if (program !== currentProgram) {
        program.apply();
        currentProgram = program;
      }

      mat4.multiply(viewProjMatrix, renderable.matrix, modelViewProjMatrix);
      gl.uniformMatrix4fv(program.uniforms.mvp, false, modelViewProjMatrix);
      gl.uniform4f(program.uniforms.u_color, style.fillColor[0], style.fillColor[1], style.fillColor[2], style.fillColor[3] * renderable.bucket.layer.getOpacity()); // use fillColor

      renderable.bindBuffers(renderContext);
      gl.lineWidth(style.strokeWidth); // Setup attributes

      gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 4 * renderable.vertexSize, 0);

      if (style.extrude) {
        gl.vertexAttribPointer(program.attributes.normal, 4, gl.FLOAT, false, 4 * renderable.vertexSize, 12);
        gl.uniform1f(program.uniforms.extrusionScale, style.extrusionScale);
      } // Draw


      gl.drawElements(gl.TRIANGLES, renderable.triIndices.length, renderable.indexType, 0);

      if (renderable.lineIndices.length > 0) {
        gl.uniform4f(program.uniforms.u_color, style.strokeColor[0], style.strokeColor[1], style.strokeColor[2], style.strokeColor[3] * renderable.bucket.layer.getOpacity());
        var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
        gl.drawElements(gl.LINES, renderable.lineIndices.length, renderable.indexType, renderable.triIndices.length * size);
      }
    } // Revert line width


    gl.lineWidth(1.0); //gl.enable(gl.DEPTH_TEST);
    //gl.disable(gl.POLYGON_OFFSET_FILL);

    gl.depthFunc(gl.LESS);
    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof PolygonRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Can apply ?
   */


  PolygonRenderer.prototype.canApply = function (type, style) {
    return (type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon) && style.fill;
  };
  /**************************************************************************************************************/

  /**
   * Create a bucket
   * @function createBucket
   * @memberof PolygonRenderer.prototype
   * @param layer
   * @param style
   * @return {PolygonBucket} Bucket
   */


  PolygonRenderer.prototype.createBucket = function (layer, style) {
    return new PolygonBucket(layer, style);
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new PolygonRenderer(globe);
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   	@name LineRenderer
   	@class
   	 Basic renderer to animate lines with gradient color texture
   	@param {AbstractGlobe} globe AbstractGlobe
   	@constructor
   	*/

  var LineRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe);
    this.maxTilePerGeometry = 2;
    this.renderContext = globe.getRenderContext();
    this.defaultVertexShader = "attribute vec4 vertex;\n";
    this.defaultVertexShader += "uniform mat4 mvp;\n";
    this.defaultVertexShader += "varying float s;\n";
    this.defaultVertexShader += "void main(void) \n";
    this.defaultVertexShader += "{\n";
    this.defaultVertexShader += "	s = vertex.w;\n";
    this.defaultVertexShader += "	gl_Position = mvp * vec4(vertex.xyz, 1.0);\n";
    this.defaultVertexShader += "}\n";
    this.fragmentShader = "precision lowp float; \n";
    this.fragmentShader += "uniform vec4 u_color;\n";
    this.fragmentShader += "uniform float speed;\n";
    this.fragmentShader += "uniform float time;\n";
    this.fragmentShader += "uniform float gradientLength;\n";
    this.fragmentShader += "varying float s;\n";
    this.fragmentShader += "uniform sampler2D colorTexture;\n";
    this.fragmentShader += "void main(void)\n";
    this.fragmentShader += "{\n";
    this.fragmentShader += "	// 0.5 is a time scale parameter, parametrize it ?\n";
    this.fragmentShader += "	float m = speed * time * 0.5;\n";
    this.fragmentShader += "	float u = (-s+m)/gradientLength;\n";
    this.fragmentShader += "	gl_FragColor.rgb = texture2D(colorTexture, vec2(u,0.)).rgb;\n";
    this.fragmentShader += "	// TODO: handle appereance of rivers\n";
    this.fragmentShader += "	if ( s < m )\n";
    this.fragmentShader += "	{\n";
    this.fragmentShader += "		gl_FragColor.a = 1.0;\n";
    this.fragmentShader += "	}\n";
    this.fragmentShader += "	else\n";
    this.fragmentShader += "	{\n";
    this.fragmentShader += "		gl_FragColor.a = 0.0;\n";
    this.fragmentShader += "	}\n";
    this.fragmentShader += "}\n";
    this.program = new Program(globe.renderContext);
    this.program.createFromSource(this.defaultVertexShader, this.fragmentShader);
    this.time = Date.now() / 1000; // Store it in seconds

    this.palette = null; // Palette is an array containing two colors(start/end and the middle one)

    this.generateTexture([[0.0, 0.0, 255.0], [0.0, 200.0, 255.0]]);
  };
  /**************************************************************************************************************/


  Utils.inherits(VectorRenderer, LineRenderer);
  /**************************************************************************************************************/

  /**
   * Generate color texture from palette
   * The generated gradient is of type : start color -> middle color -> start color
   * @function generateTexture
   * @memberof LineRenderer.prototype
   * @param palette
   */

  LineRenderer.prototype.generateTexture = function (palette) {
    var startColor = palette[0];
    var middleColor = palette[1];
    var i, r, g, b;
    var pixels = [];
    var gl = this.globe.renderContext.gl;
    this.colorTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

    for (i = 0; i < 128; i++) {
      r = Numeric.coserp(i / 128, startColor[0], middleColor[0]);
      g = Numeric.coserp(i / 128, startColor[1], middleColor[1]);
      b = Numeric.coserp(i / 128, startColor[2], middleColor[2]);
      pixels.push(r);
      pixels.push(g);
      pixels.push(b);
      pixels.push(255);
    }

    for (i = 0; i < 128; i++) {
      r = Numeric.coserp(i / 128, middleColor[0], startColor[0]);
      g = Numeric.coserp(i / 128, middleColor[1], startColor[1]);
      b = Numeric.coserp(i / 128, middleColor[2], startColor[2]);
      pixels.push(r);
      pixels.push(g);
      pixels.push(b);
      pixels.push(255);
    }

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(pixels));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    this.palette = palette;
  };
  /**************************************************************************************************************/

  /**
   	@name LineRenderable
   	@class
   	 Renderable constructor for Line
   	@param {Bucket} bucket Bucket
  	@augments BatchRenderable
   	@constructor
   	*/


  var LineRenderable = function (bucket) {
    BatchRenderable.prototype.constructor.call(this, bucket);
    this.vertexSize = 4; // TODO : remove matrix ??

    this.matrix = mat4.create();
    mat4.identity(this.matrix);
  };
  /**************************************************************************************************************/


  Utils.inherits(BatchRenderable, LineRenderable);
  /**************************************************************************************************************/

  /**
   * Build vertices and indices for the given geometry
   * @function build
   * @memberof LineRenderable.prototype
   * @param geometry
   */

  LineRenderable.prototype.build = function (geometry) {
    var renderer = this.bucket.renderer; //var style = this.bucket.style;

    var i, n;
    var lines = geometry.type === Constants.GEOMETRY.MultiLineString ? geometry.coordinates : [geometry.coordinates];
    var currentPoint = vec3.create();
    var previousPoint = vec3.create();

    for (n = 0; n < lines.length; n++) {
      var coords = lines[n];
      var lastIndex = this.vertices.length / 4;
      var coordinateSystem = renderer.globe.getCoordinateSystem(); // Build line vertices

      var offset = lastIndex * 4;
      var s = 0;

      for (i = 0; i < coords.length; i++) {
        coordinateSystem.get3DFromWorldInCrs(coords[i], geometry.crs.properties.name, currentPoint);
        this.vertices[offset] = currentPoint[0];
        this.vertices[offset + 1] = currentPoint[1];
        this.vertices[offset + 2] = currentPoint[2]; // Compute s(length) between two points

        if (i > 0) {
          s += vec3.dist(currentPoint, previousPoint);
        } // Update previous point(do it by swapping with current cuz it's the same object)


        var tmp = previousPoint;
        previousPoint = currentPoint;
        currentPoint = tmp;
        this.vertices[offset + 3] = s;
        offset += 4;
      } // Build line indices


      for (i = 0; i < coords.length - 1; i++) {
        this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
      }
    } // Geometry is always added contrary to tiled renderables


    return true;
  };
  /**************************************************************************************************************/

  /**
   	@name LineBucket
   	@class
   	 Bucket constructor for LineRenderer
   	@param layer
  	@param style
   	@constructor
   	*/


  var LineBucket = function (layer, style) {
    this.layer = layer;
    this.style = style;
    this.renderer = null;
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof LineBucket.prototype
   */


  LineBucket.prototype.createRenderable = function () {
    return new LineRenderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Check if a bucket is compatible
   * @function is Compatible
   * @memberof LineBucket.prototype
   * @param style
   * @return {Boolean} Is compatible ?
   */


  LineBucket.prototype.isCompatible = function (style) {
    return this.style === style;
  };
  /**************************************************************************************************************/

  /**
   * 	Render all the polygons
   * @function render
   * @memberof LineRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  LineRenderer.prototype.render = function (renderables, start, end) {
    var renderContext = this.globe.renderContext;
    var gl = renderContext.gl;
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL); //gl.enable(gl.POLYGON_OFFSET_FILL);
    //gl.polygonOffset(-2.0,-2.0);
    //gl.disable(gl.DEPTH_TEST);
    // Compute the viewProj matrix

    var viewProjMatrix = mat4.create();
    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, viewProjMatrix);
    var modelViewProjMatrix = mat4.create();
    this.program.apply();
    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(this.program.uniforms.colorTexture, 0);
    gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      var style = renderable.bucket.style;
      mat4.multiply(viewProjMatrix, renderable.matrix, modelViewProjMatrix);
      gl.uniformMatrix4fv(this.program.uniforms.mvp, false, modelViewProjMatrix);

      if (style.palette && style.palette !== this.palette) {
        // Generate new color texture(create an array of color textures per bucket ?)
        gl.deleteTexture(this.colorTexture);
        this.generateTexture(style.palette);
      }

      gl.lineWidth(style.strokeWidth); // Update uniforms

      gl.uniform4f(this.program.uniforms.color, style.strokeColor[0], style.strokeColor[1], style.strokeColor[2], style.strokeColor[3] * renderable.bucket.layer.getOpacity());
      gl.uniform1f(this.program.uniforms.speed, style.hasOwnProperty("speed") ? style.speed : 1.0);
      gl.uniform1f(this.program.uniforms.time, Date.now() / 1000 - this.time);
      gl.uniform1f(this.program.uniforms.gradientLength, style.hasOwnProperty("gradientLength") ? style.gradientLength : 10.0);
      renderable.bindBuffers(renderContext);
      gl.vertexAttribPointer(this.program.attributes.vertex, 4, gl.FLOAT, false, 0, 0); // Draw

      gl.drawElements(gl.LINES, renderable.lineIndices.length, renderable.indexType, 0);
    } // Revert to default


    gl.lineWidth(1); //gl.enable(gl.DEPTH_TEST);
    //gl.disable(gl.POLYGON_OFFSET_FILL);

    gl.depthFunc(gl.LESS);
    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof LineRenderer.prototype
   * @return {Boolean} Can apply ?
   */


  LineRenderer.prototype.canApply = function (type, style) {
    return (type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString) && style.gradientLength;
  };
  /**************************************************************************************************************/

  /**
   * Create a bucket
   * @function createBucket
   * @memberof LineRenderer.prototype
   * @param layer
   * @param style
   * @return {LineBucket} Line bucket
   */


  LineRenderer.prototype.createBucket = function (layer, style) {
    return new LineBucket(layer, style);
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new LineRenderer(globe);
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
       @name PointSpriteRenderer
       @class
           PointSpriteRenderer constructor
       @param {AbstractGlobe} globe AbstractGlobe
       @augments VectorRenderer
       @constructor
       */

  var PointSpriteRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe); // For stats

    this.numberOfRenderPoints = 0;
    var vertexShader = `
        attribute vec3 vertex;
        uniform mat4 viewProjectionMatrix;
        uniform float pointSize;
        void main(void)
        {
            gl_Position = viewProjectionMatrix * vec4(vertex,1.0);
            gl_PointSize = pointSize;
        }`;
    var fragmentShader = `
        precision lowp float;
        uniform sampler2D texture;
        uniform float alpha;
        uniform vec3 color;

        void main(void)
        {
            vec4 textureColor = texture2D(texture, gl_PointCoord);
            gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha);
            if (gl_FragColor.a <= 0.0) discard;
            //gl_FragColor = vec4(1.0);
        }`;

    var shader = _selectShader(globe);

    var meterSizeFragmentShader = `
        precision lowp float;

        uniform sampler2D texture;
        uniform float alpha;
        uniform vec3 color;

        varying vec2 texcoords;

        void main(void)
        {
            vec4 textureColor = texture2D(texture, texcoords);
            gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha);
            if (gl_FragColor.a <= 0.0) discard;
        }`;
    this.program = new Program(globe.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
    this.meterSizeProgram = new Program(globe.renderContext);
    this.meterSizeProgram.createFromSource(shader.metersVertexShader, meterSizeFragmentShader);
    this.defaultTexture = null;
    var gl = globe.tileManager.renderContext.gl;
    this.rectVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.rectVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shader.vertices, gl.STATIC_DRAW);
  };
  /**
   * Select the right shader according to the type (planet or sky.)
   * In the planet case, the image is center on the bottom of the image so that the billboard
   * is on top of the ground
   * In the sky case, the image is center on the center of image.
   * @param {Globe} globe
   */


  function _selectShader(globe) {
    var type = globe.getCoordinateSystem().getType();
    return type === Constants.CONTEXT.Sky ? _useShaderForSky() : _useShaderForPlanet();
  }
  /**
   * Vertex shader center on the image.
   */


  function _useShaderForSky() {
    var meterSizeVertexShader = `
        attribute vec3 vertex;
        uniform mat4 viewMatrix;
        uniform mat4 viewProjectionMatrix;
        uniform vec3 billboardPos;
        uniform vec2 billboardSize;

        varying vec2 texcoords;

        void main() {
            vec3 camRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
            vec3 camUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
            vec3 x = camRight * vertex.x * billboardSize.x;
            vec3 y = camUp * vertex.y * billboardSize.y;
            vec3 pos = billboardPos + x + y;

            gl_Position = viewProjectionMatrix * vec4(pos, 1.0);
            texcoords = vec2(vertex.x + 0.5, 1.0 - vertex.y - 0.5);
        }`;
    const vertices = new Float32Array([-0.5, -0.5, 0.0, 0.5, -0.5, 0.0, 0.5, 0.5, 0.0, -0.5, 0.5, 0.0]);
    return {
      vertices: vertices,
      metersVertexShader: meterSizeVertexShader
    };
  }
  /**
   * Vertex shader center on the image.
   */


  function _useShaderForPlanet() {
    var meterSizeVertexShader = `
        attribute vec3 vertex;
        uniform mat4 viewMatrix;
        uniform mat4 viewProjectionMatrix;
        uniform vec3 billboardPos;
        uniform vec2 billboardSize;

        varying vec2 texcoords;

        void main() {
            vec3 camRight = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);
            vec3 camUp = vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]);
            vec3 x = camRight * vertex.x * billboardSize.x;
            vec3 y = camUp * vertex.y * billboardSize.y;
            vec3 pos = billboardPos + x + y;

            gl_Position = viewProjectionMatrix * vec4(pos, 1.0);
            texcoords = vec2(vertex.x + 0.5, 1.0 - vertex.y);
        }`;
    const vertices = new Float32Array([-0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.5, 1.0, 0.0, -0.5, 1.0, 0.0]);
    return {
      vertices: vertices,
      metersVertexShader: meterSizeVertexShader
    };
  }

  Utils.inherits(VectorRenderer, PointSpriteRenderer);
  /**************************************************************************************************************/

  /**
       @name Renderable
       @class
           Renderable constructor for PointSprite
       @param {Bucket} bucket Bucket
       @constructor
       */

  var Renderable = function (bucket) {
    this.bucket = bucket;
    this.geometry2vb = {};
    this.vertices = [];
    this.geometries = [];
    this.vertexBuffer = null;
    this.vertexBufferDirty = false;
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to the renderable
   * @function add
   * @memberof Renderable.prototype
   * @param geometry
   * @return {Boolean} If the geometry has been successfully added to the renderable
   */


  Renderable.prototype.add = function (geometry, stockGeometry) {
    this.geometry2vb[geometry.gid] = this.vertices.length; // TODO: Find a better way to access to coordinate system

    var globe = this.bucket.renderer.globe;
    var crs = globe.getCoordinateSystem();

    if (this.bucket.style.useMeterSize) {
      const elevation = crs.getElevation(globe, geometry);
      const pt = crs.get3DFromWorldInCrs([geometry.coordinates[0], geometry.coordinates[1], elevation], geometry.crs.properties.name);
      this.vertices.push(pt[0], pt[1], pt[2]);
    } else if (this.bucket.style.useDegreeSize) {
      const pt = crs.get3DFromWorldInCrs(geometry.coordinates, geometry.crs.properties.name);
      this.vertices.push(pt[0], pt[1], pt[2]);
    } else {
      var pt = crs.get3DFromWorldInCrs(geometry.coordinates, geometry.crs.properties.name);
      var realPlanetRadius = crs.getGeoide().getRealPlanetRadius();
      var scale = this.bucket.renderer.globe.isSky() ? 0.95 : 1.0 + crs.getElevation(globe, geometry) / realPlanetRadius; //TODO Instead of 0.95, it should be 0.9995. But with this value, the point is dislayed
      //TODO after order > 5. With order<=5, the image need more control points. Without these
      //TODO control point, the image does not fit perfectly the sphere and the point is behind the image

      this.vertices.push(scale * pt[0], scale * pt[1], scale * pt[2]);
      this.vertexBufferDirty = true;
    }

    if (stockGeometry !== false) {
      this.geometries.push(geometry);
    }

    return true;
  };
  /**************************************************************************************************************/

  /**
   * Update all elevations for each render
   * @function updateElevations
   * @memberof Renderable.prototype
   */


  Renderable.prototype.updateElevations = function () {
    this.vertices = [];

    for (var i = 0; i < this.geometries.length; i++) {
      this.add(this.geometries[i], false);
    }
  };
  /**************************************************************************************************************/

  /**
   * Remove a geometry from the renderable
   * @function remove
   * @memberof Renderable.prototype
   * @param geometry
   */


  Renderable.prototype.remove = function (geometry) {
    if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
      var vbIndex = this.geometry2vb[geometry.gid];
      delete this.geometry2vb[geometry.gid];
      this.vertices.splice(vbIndex, 3);
      this.vertexBufferDirty = true; // Update render data for all other geometries

      for (var g in this.geometry2vb) {
        if (g) {
          if (this.geometry2vb[g] > vbIndex) {
            this.geometry2vb[g] -= 3;
          }
        }
      }
    }

    return this.vertices.length;
  };
  /**************************************************************************************************************/

  /**
   * Dispose the renderable
   * @function dispose
   * @memberof Renderable.prototype
   * @param renderContext
   */


  Renderable.prototype.dispose = function (renderContext) {
    if (this.vertexBuffer) {
      renderContext.gl.deleteBuffer(this.vertexBuffer);
    }
  };
  /**************************************************************************************************************/

  /**
   * Build a default texture
   * @function _buildDefaultTexture
   * @memberof PointSpriteRenderer.prototype
   * @param {Bucket} bucket Bucket
   * @private
   */


  PointSpriteRenderer.prototype._buildDefaultTexture = function (bucket) {
    if (!this.defaultTexture) {
      var gl = this.globe.renderContext.gl;
      this.defaultTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
      var whitePixel = new Uint8Array([255, 255, 255, 255]);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
    }

    bucket.texture = this.defaultTexture;
    bucket.textureWidth = 10;
    bucket.textureHeight = 10;
  };
  /**************************************************************************************************************/

  /**
   * Build a texture from an image and store in a bucket
   * @function _buildTextureFromImage
   * @memberof PointSpriteRenderer.prototype
   * @param {Bucket} bucket Bucket
   * @param image
   * @private
   */


  PointSpriteRenderer.prototype._buildTextureFromImage = function (bucket, image) {
    bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(image);
    bucket.textureWidth = image.width;
    bucket.textureHeight = image.height;
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof PointSpriteRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Is applicable ?
   */


  PointSpriteRenderer.prototype.canApply = function (type, style) {
    return type === Constants.GEOMETRY.Point && !style.label;
  };
  /**************************************************************************************************************/

  /**
       @name Bucket
       @class
           Bucket constructor for PointSpriteRenderer
       @param layer
       @param style
       @constructor
       */


  var Bucket$1 = function (layer, style) {
    this.layer = layer;
    this.style = new FeatureStyle(style);
    this.texture = null;
    this.renderer = null;
  };
  /**************************************************************************************************************/

  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof Bucket.prototype
   * @return {Renderable} Renderable
   */


  Bucket$1.prototype.createRenderable = function () {
    return new Renderable(this);
  };
  /**************************************************************************************************************/

  /**
   * Check if a bucket is compatible
   * @function isCompatible
   * @memberof Bucket.prototype
   * @param style
   * @return {Boolean} Is compatible ?
   */


  Bucket$1.prototype.isCompatible = function (style) {
    if (this.style.iconUrl === style.iconUrl && this.style.icon === style.icon && this.style.fillColor[0] === style.fillColor[0] && this.style.fillColor[1] === style.fillColor[1] && this.style.fillColor[2] === style.fillColor[2]) {
      return true;
    }

    return false;
  };
  /**************************************************************************************************************/

  /**
   * Create bucket to render a point
   * @function createBucket
   * @memberof PointSpriteRenderer.prototype
   * @param layer
   * @param style
   * @return {Bucket} Bucket
   */


  PointSpriteRenderer.prototype.createBucket = function (layer, style) {
    var gl = this.globe.renderContext.gl;
    gl.createBuffer(); // Create a bucket

    var bucket = new Bucket$1(layer, style);
    bucket.renderer = this; // Initialize bucket : create the texture

    if (style.iconUrl) {
      var image = new Image();
      image.crossOrigin = "";
      var self = this;

      image.onload = function () {
        self._buildTextureFromImage(bucket, image);

        self.globe.renderContext.requestFrame();
      };

      image.onerror = function () {
        self._buildDefaultTexture(bucket);
      };

      image.src = Proxy.proxify(style.iconUrl);
    } else if (style.icon) {
      this._buildTextureFromImage(bucket, style.icon);
    } else {
      this._buildDefaultTexture(bucket);
    }

    return bucket;
  };
  /**************************************************************************************************************/

  /**
   * Render
   * @function render
   * @memberof PointSpriteRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  PointSpriteRenderer.prototype.render = function (renderables, start, end) {
    var renderContext = this.globe.renderContext;
    var gl = renderContext.gl; // Setup states
    //gl.disable(gl.DEPTH_TEST);

    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage

    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
    var program; // Render each renderables

    var currentBucket = null;

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      renderable.updateElevations();
      var bucket = renderable.bucket;

      if (currentBucket !== bucket) {
        // Setup program
        program = bucket.style.useMeterSize || bucket.style.useDegreeSize ? this.meterSizeProgram : this.program;
        program.apply();
        gl.uniformMatrix4fv(program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
        gl.uniform1i(program.uniforms.texture, 0);
        gl.uniform1f(program.uniforms.alpha, bucket.layer.getOpacity());
        var color = bucket.style.getFillColor();
        gl.uniform3f(program.uniforms.color, color[0], color[1], color[2]);

        if (bucket.style.useMeterSize) {
          const scaleRadius = this.globe.getCoordinateSystem().getGeoide().getHeightScale();
          const w = bucket.style.meterSize[0] * scaleRadius;
          const h = bucket.style.meterSize[1] * scaleRadius;
          gl.uniform2f(program.uniforms.billboardSize, w, h);
          gl.uniformMatrix4fv(program.uniforms.viewMatrix, false, renderContext.viewMatrix);
        } else if (bucket.style.useDegreeSize) {
          const scaleRadius = this.globe.getCoordinateSystem().getGeoide().getHeightScale();
          const thetaToDist = 2.0 * Math.PI * scaleRadius / 360.0;
          const w = bucket.style.degreeSize[0] * thetaToDist;
          const h = bucket.style.degreeSize[1] * thetaToDist;
          gl.uniform2f(program.uniforms.billboardSize, w, h);
          gl.uniformMatrix4fv(program.uniforms.viewMatrix, false, renderContext.viewMatrix);
        } else {
          gl.uniform1f(program.uniforms.pointSize, bucket.textureWidth);
        } // Bind point texture


        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, bucket.texture);
        currentBucket = bucket;
      }

      if (bucket.style.useMeterSize || bucket.style.useDegreeSize) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.rectVertexBuffer);
        gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

        for (var i = 0; i < renderable.vertices.length; i += 3) {
          const x = renderable.vertices[i];
          const y = renderable.vertices[i + 1];
          const z = renderable.vertices[i + 2];
          gl.uniform3f(program.uniforms.billboardPos, x, y, z);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }
      } else {
        if (!renderable.vertexBuffer) {
          renderable.vertexBuffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
        gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

        if (renderable.vertexBufferDirty) {
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
          renderable.vertexBufferDirty = false;
        }

        gl.drawArrays(gl.POINTS, 0, renderable.vertices.length / 3);
      }
    } //gl.enable(gl.DEPTH_TEST);


    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new PointSpriteRenderer(globe);
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
   Does not manage holes
   Seems to be O(n^3)!
   */
  var EPSILON$1 = 0.0000000001;
  /*
   Compute the signed area of a polygon
   */

  var Area = function (contour) {
    var n = contour.length;
    var A = 0.0;

    for (var p = n - 1, q = 0; q < n; p = q++) {
      A += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
    }

    return A * 0.5;
  };
  /*
   InsideTriangle decides if a point P is Inside of the triangle
   defined by A, B, C.
   */


  var InsideTriangle = function (Ax, Ay, Bx, By, Cx, Cy, Px, Py) {
    var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;
    ax = Cx - Bx;
    ay = Cy - By;
    bx = Ax - Cx;
    by = Ay - Cy;
    cx = Bx - Ax;
    cy = By - Ay;
    apx = Px - Ax;
    apy = Py - Ay;
    bpx = Px - Bx;
    bpy = Py - By;
    cpx = Px - Cx;
    cpy = Py - Cy;
    aCROSSbp = ax * bpy - ay * bpx;
    cCROSSap = cx * apy - cy * apx;
    bCROSScp = bx * cpy - by * cpx;
    return aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0;
  };
  /*
   Check if the giben triangle (u,v,w) is a ear : not other vertex inside
   */


  var Snip = function (contour, u, v, w, n, V) {
    var p;
    var Ax, Ay, Bx, By, Cx, Cy, Px, Py;
    Ax = contour[V[u]][0];
    Ay = contour[V[u]][1];
    Bx = contour[V[v]][0];
    By = contour[V[v]][1];
    Cx = contour[V[w]][0];
    Cy = contour[V[w]][1];

    if (EPSILON$1 > (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax)) {
      return false;
    }

    for (p = 0; p < n; p++) {
      if (p === u || p === v || p === w) {
        continue;
      }

      Px = contour[V[p]][0];
      Py = contour[V[p]][1];

      if (InsideTriangle(Ax, Ay, Bx, By, Cx, Cy, Px, Py)) {
        return false;
      }
    }

    return true;
  };
  /*
   Process triangulation on the given contour
   */


  var Process = function (contour) {
    /* allocate and initialize list of Vertices in polygon */
    var n = contour.length;

    if (contour[0][0] === contour[n - 1][0] && contour[0][1] === contour[n - 1][1]) {
      n--;
    }

    if (n < 3) {
      return null;
    }

    var V = new Array(n);
    var v;
    /* we want a counter-clockwise polygon in V */

    if (0.0 < Area(contour)) {
      for (v = 0; v < n; v++) {
        V[v] = v;
      }
    } else {
      for (v = 0; v < n; v++) {
        V[v] = n - 1 - v;
      }
    }

    var nv = n;
    var results = [];
    /*  remove nv-2 Vertices, creating 1 triangle every time */

    var count = 2 * nv;
    /* error detection */

    for (v = nv - 1; nv > 2;) {
      /* if we loop, it is probably a non-simple polygon */
      if (0 >= count--) {
        //** Triangulate: ERROR - probable bad polygon!
        return null;
      }
      /* three consecutive vertices in current polygon, <u,v,w> */


      var u = v;

      if (nv <= u) {
        u = 0;
      }
      /* previous */


      v = u + 1;

      if (nv <= v) {
        v = 0;
      }
      /* new v    */


      var w = v + 1;

      if (nv <= w) {
        w = 0;
      }
      /* next     */


      if (Snip(contour, u, v, w, nv, V)) {
        var a, b, c, s, t;
        /* true names of the vertices */

        a = V[u];
        b = V[v];
        c = V[w];
        /* output Triangle */

        results.push(a);
        results.push(b);
        results.push(c);
        /* remove v from remaining polygon */

        for (s = v, t = v + 1; t < nv; s++, t++) {
          V[s] = V[t];
        }

        nv--;
        /* resest error detection counter */

        count = 2 * nv;
      }
    }

    return results;
  };

  var Triangulator = {
    process: Process
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
       @name Bucket
       @class
        Bucket constructor for ConvexPolygonRenderer
       @param layer
       @param style
       @constructor
       */

  var Bucket$2 = function (layer, style) {
    this.layer = layer;
    this.style = new FeatureStyle(style);
    this.texture = null;
    this.polygonProgram = null;
    this.renderer = null;
    this.mainRenderable = null;
  };
  /**
   * Check if a bucket is compatible
   * @function isCompatible
   * @memberof Bucket.prototype
   * @param style
   * @return {boolean} Is compatible ?
   */


  Bucket$2.prototype.isCompatible = function (style) {
    if (this.style.strokeColor[0] === style.strokeColor[0] && this.style.strokeColor[1] === style.strokeColor[1] && this.style.strokeColor[2] === style.strokeColor[2] && this.style.fill === style.fill && this.style.fillTexture === style.fillTexture && this.style.fillTextureUrl === style.fillTextureUrl && this.style.fillShader === style.fillShader) {
      return true;
    }

    return false;
  };
  /**************************************************************************************************************/

  /**
        @name Renderable
        @class
          Renderable constructor
          Attach to a bucket
        @param {Bucket} bucket Bucket
        @constructor
       */


  var Renderable$1 = function (bucket) {
    this.bucket = bucket;
    this.geometry2vb = {};
    this.vertices = [];
    this.lineIndices = [];
    this.triangleIndices = [];
    this.vertexBuffer = null;
    this.lineIndexBuffer = null;
    this.triangleIndexBuffer = null;
    this.bufferDirty = false;
    this.triBufferDirty = false;
    this.tcoords = [];
  };
  /**************************************************************************************************************/

  /**
   * Add the geometry to the renderable
   * @function add
   * @memberof Renderable.prototype
   * @return if the geometry has been successfully added to the renderable
   */


  Renderable$1.prototype.add = function (geometry) {
    var rings = [];
    var geometryCrs = "Equatorial"; //geometry.crs.properties.name;

    var i, r, pt;

    if (geometry.type === Constants.GEOMETRY.MultiPolygon) {
      for (i = 0; i < geometry.coordinates.length; i++) {
        rings.push(geometry.coordinates[i][0]);
      }
    } else if (geometry.type === Constants.GEOMETRY.LineString) {
      rings.push(geometry.coordinates);
    } else if (geometry.type === Constants.GEOMETRY.MultiLineString) {
      for (i = 0; i < geometry.coordinates.length; i++) {
        rings.push(geometry.coordinates[i]);
      }
    } else {
      rings.push(geometry.coordinates[0]);
    }

    for (r = 0; r < rings.length; r++) {
      var coords = rings[r]; // var coords = geometry['coordinates'][0];
      //var numPoints = coords.length-1;

      var numPoints = coords.length; // Store information for the geometry in the buffers used for rendering

      var data = {
        vertexStart: this.vertices.length,
        vertexCount: 3 * numPoints,
        lineIndexStart: this.lineIndices.length,
        lineIndexCount: 2 * numPoints,
        triIndexStart: 0,
        triIndexCount: 0
      };
      var coordinateSystem = this.bucket.renderer.globe.getCoordinateSystem(); // Compute texture coordinates if defined

      if (geometry._imageCoordinates) {
        data.tcoordsStart = this.tcoords.length;
        data.tcoordsCount = 2 * numPoints; // Initialize variables used for texture coordinates computation

        var p0 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][0], geometryCrs); // origin

        var p1 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][1], geometryCrs);
        var p3 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][3], geometryCrs);
        var v01 = [];
        vec3.subtract(p1, p0, v01); // U-axis

        var v03 = [];
        vec3.subtract(p3, p0, v03); // V-axis

        var squaredU = vec3.length(v01) * vec3.length(v01);
        var squaredV = vec3.length(v03) * vec3.length(v03);

        for (i = 0; i < numPoints; i++) {
          pt = coordinateSystem.get3DFromWorldInCrs(coords[i], geometryCrs);
          var v0P = [];
          vec3.subtract(pt, p0, v0P);
          var uDotProduct = vec3.dot(v0P, v01);
          var vDotProduct = vec3.dot(v0P, v03);
          var u = uDotProduct / squaredU;
          var v = vDotProduct / squaredV;
          this.tcoords.push(u);
          this.tcoords.push(v);
        }
      } // Compute vertices and indices and store them in the buffers


      var startIndex = this.vertices.length / 3;

      for (i = 0; i < numPoints; i++) {
        pt = coordinateSystem.get3DFromWorldInCrs(coords[i], geometryCrs);
        this.vertices.push(pt[0], pt[1], pt[2]);

        if ((geometry.type === Constants.GEOMETRY.MultiLineString || geometry.type === Constants.GEOMETRY.LineString) && i === numPoints - 1) {
          break;
        }

        this.lineIndices.push(startIndex + i, startIndex + (i + 1) % numPoints);
      } // If fill, build the triangle indices


      if (this.bucket.style.fill) {
        data.triIndexStart = this.triangleIndices.length;
        data.triIndexCount = 3 * (numPoints - 2);
        var triangleIndices = Proxy.process(coords);

        if (triangleIndices !== null) {
          this.triangleIndices = triangleIndices;
        } else {
          // HACK for not trivial polygons
          for (i = 0; i < numPoints - 2; i++) {
            this.triangleIndices.push(startIndex, startIndex + i + 1, startIndex + i + 2);
          }
        }
      }

      if (this.geometry2vb[geometry.gid]) {
        this.geometry2vb[geometry.gid].vertexCount += data.vertexCount;
        this.geometry2vb[geometry.gid].lineIndexCount += data.lineIndexCount;
        this.geometry2vb[geometry.gid].triIndexCount += data.triIndexCount;
      } else {
        this.geometry2vb[geometry.gid] = data;
      }

      this.bufferDirty = true;
      this.triBufferDirty = true;
    }

    return true;
  };
  /**************************************************************************************************************/

  /**
   * Remove the geometry from the renderable
   * @function remove
   * @memberof Renderable.prototype
   * @param geometry
   */


  Renderable$1.prototype.remove = function (geometry) {
    var i;

    if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
      // retreive the render data for the geometry
      var data = this.geometry2vb[geometry.gid];
      delete this.geometry2vb[geometry.gid]; // Remove geometry vertex

      this.vertices.splice(data.vertexStart, data.vertexCount); // Update indices after vertex removal

      for (i = data.lineIndexStart + data.lineIndexCount; i < this.lineIndices.length; i++) {
        this.lineIndices[i] -= data.vertexCount / 3;
      }

      for (i = data.triIndexStart + data.triIndexCount; i < this.triangleIndices.length; i++) {
        this.triangleIndices[i] -= data.vertexCount / 3;
      }

      this.lineIndices.splice(data.lineIndexStart, data.lineIndexCount);
      this.triangleIndices.splice(data.triIndexStart, data.triIndexCount);

      if (data.tcoordsStart >= 0) {
        this.tcoords.splice(data.tcoordsStart, data.tcoordsCount);
      } // Update render data for all other geometries


      for (var g in this.geometry2vb) {
        if (g) {
          var d = this.geometry2vb[g];

          if (d.vertexStart > data.vertexStart) {
            d.vertexStart -= data.vertexCount;
            d.lineIndexStart -= data.lineIndexCount;
            d.triIndexStart -= data.triIndexCount;

            if (d.tcoordsStart >= 0) {
              d.tcoordsStart -= data.tcoordsCount;
            }
          }
        }
      }

      this.bufferDirty = true;
      this.triBufferDirty = true;
    }

    return this.vertices.length;
  };
  /**************************************************************************************************************/

  /**
   * Dispose the renderable : remove all buffers
   * @function dispose
   * @memberof Renderable.prototype
   * @param renderContext
   */


  Renderable$1.prototype.dispose = function (renderContext) {
    if (this.vertexBuffer) {
      renderContext.gl.deleteBuffer(this.vertexBuffer);
    }

    if (this.lineIndexBuffer) {
      renderContext.gl.deleteBuffer(this.lineIndexBuffer);
    }

    if (this.triangleIndexBuffer) {
      renderContext.gl.deleteBuffer(this.triangleIndexBuffer);
    }

    if (this.tcoordBuffer) {
      renderContext.gl.deleteBuffer(this.tcoordBuffer);
    }
  };
  /**
   * Create a renderable for this bucket
   * @function createRenderable
   * @memberof Bucket.prototype
   * @return {Renderable} Renderable
   */


  Bucket$2.prototype.createRenderable = function () {
    return new Renderable$1(this);
  };
  /**************************************************************************************************************/

  /**
        @name ConvexPolygonRenderer
        @class
          ConvexPolygonRenderer  constructor
        @augments VectorRenderer
        @param {AbstractGlobe} globe AbstractGlobe
        @constructor
        */


  var ConvexPolygonRenderer = function (globe) {
    VectorRenderer.prototype.constructor.call(this, globe);
    this.maxTilePerGeometry = 2; // Store object for rendering

    this.renderContext = globe.tileManager.renderContext;
    this.tileConfig = globe.tileManager.tileConfig;
    this.programs = [];
    this.basicVertexShader = "attribute vec3 vertex;\n";
    this.basicVertexShader += "uniform mat4 viewProjectionMatrix;\n";
    this.basicVertexShader += "    \n";
    this.basicVertexShader += "    void main(void)\n";
    this.basicVertexShader += "    {\n";
    this.basicVertexShader += "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
    this.basicVertexShader += "    }\n";
    this.basicFragmentShader = "precision lowp float; \n";
    this.basicFragmentShader += "    uniform vec4 color; \n";
    this.basicFragmentShader += "    \n";
    this.basicFragmentShader += "    void main(void) \n";
    this.basicFragmentShader += "    { \n";
    this.basicFragmentShader += "        gl_FragColor = color; \n";
    this.basicFragmentShader += "    } \n";
    this.texVertexShader = "attribute vec3 vertex;\n";
    this.texVertexShader += "    attribute vec2 tcoord;\n";
    this.texVertexShader += "    uniform mat4 viewProjectionMatrix;\n";
    this.texVertexShader += "    \n";
    this.texVertexShader += "    varying vec2 vTextureCoord;\n";
    this.texVertexShader += "    \n";
    this.texVertexShader += "    void main(void) \n";
    this.texVertexShader += "    {\n";
    this.texVertexShader += "        vTextureCoord = tcoord;\n";
    this.texVertexShader += "        vTextureCoord.y = 1.0 - vTextureCoord.y; \n";
    this.texVertexShader += "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
    this.texVertexShader += "    }\n";
    this.texFragmentShader = "precision lowp float; \n";
    this.texFragmentShader += "    uniform vec4 color;\n";
    this.texFragmentShader += "    varying vec2 vTextureCoord;\n";
    this.texFragmentShader += "    uniform sampler2D texture; \n";
    this.texFragmentShader += "    void main(void)\n";
    this.texFragmentShader += "    {\n";
    this.texFragmentShader += "        gl_FragColor = texture2D(texture, vTextureCoord) * color;\n";
    this.texFragmentShader += "    }\n";
    this.basicFillShader = {
      vertexCode: this.basicVertexShader,
      fragmentCode: this.basicFragmentShader,
      updateUniforms: null
    };
    this.texFillShader = {
      vertexCode: this.texVertexShader,
      fragmentCode: this.texFragmentShader,
      updateUniforms: null
    };
    this.basicProgram = this.createProgram(this.basicFillShader);
    this.texProgram = this.createProgram(this.texFillShader);
    var gl = this.renderContext.gl; // Parameters used to implement ONE shader for color xor texture rendering

    this.whiteTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
    var whitePixel = new Uint8Array([255, 255, 255, 255]);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel); // Shared buffer
    // Create texCoord buffer

    this.tcoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
    var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
    this.tcoordBuffer.itemSize = 2;
    this.tcoordBuffer.numItems = 5;
  };

  Utils.inherits(VectorRenderer, ConvexPolygonRenderer);
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof ConvexPolygonRenderer.prototype
   * @param type
   * @param style
   * @return {boolean} Is applicable ?
   */

  ConvexPolygonRenderer.prototype.canApply = function (type, style) {
    if (!this.globe.isSky()) {
      return false;
    }

    return type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon || type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString;
  };
  /**************************************************************************************************************/

  /**
   * Create program from fillShader object
   * @function createProgram
   * @memberof ConvexPolygonRenderer.prototype
   * @param fillShader
   * @return {Program} Program
   */


  ConvexPolygonRenderer.prototype.createProgram = function (fillShader) {
    var program = new Program(this.renderContext);
    program.createFromSource(fillShader.vertexCode, fillShader.fragmentCode); // Add program

    program.id = this.programs.length;
    this.programs.push({
      fillShader: fillShader,
      program: program
    });
    return program;
  };
  /**************************************************************************************************************/

  /**
   * Get program if known by renderer, create otherwise
   * @function getProgram
   * @memberof ConvexPolygonRenderer.prototype
   * @param fillShader
   * @return {Program} Program
   */


  ConvexPolygonRenderer.prototype.getProgram = function (fillShader) {
    var program;

    for (var id = 0; id < this.programs.length; id++) {
      if (this.programs[id].fillShader === fillShader) {
        program = this.programs[id].program;
      }
    }

    if (!program) {
      program = this.createProgram(fillShader);
    }

    return program;
  };
  /**************************************************************************************************************/

  /**
   * Create bucket to render a polygon
   * @function createBucket
   * @memberof ConvexPolygonRenderer.prototype
   * @param layer
   * @param style
   * @return {Bucket} Bucket
   */


  ConvexPolygonRenderer.prototype.createBucket = function (layer, style) {
    var gl = this.renderContext.gl;
    gl.createBuffer(); // Create a bucket

    var bucket = new Bucket$2(layer, style); // Create texture

    var self = this;

    if (style.fill) {
      var hasTexture = false;

      if (style.fillTextureUrl) {
        var image = new Image();
        image.crossOrigin = "";

        image.onload = function () {
          bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(image, layer.invertY);
        };

        image.onerror = function (event) {
          ErrorDialog.open(Constants.LEVEL.WARNING, "Cannot load " + image.src);
        };

        image.src = Triangulator.proxify(style.fillTextureUrl);
        hasTexture = true;
      } else if (style.fillTexture) {
        bucket.texture = style.fillTexture;
        hasTexture = true;
      }

      if (style.fillShader && style.fillShader.fragmentCode) {
        // User defined texture program
        if (!style.fillShader.vertexCode) {
          style.fillShader.vertexCode = this.texVertexShader;
        }

        if (!style.fillShader.vertexCode) {
          style.fillShader.fragmentCode = this.texFragmentShader;
        }

        bucket.polygonProgram = this.getProgram(style.fillShader);
      } else {
        // Default program
        bucket.polygonProgram = hasTexture ? this.texProgram : this.basicProgram;
      }
    }

    return bucket;
  };
  /**************************************************************************************************************/

  /**
   * Render all the POIs
   * @function render
   * @memberof ConvexPolygonRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  ConvexPolygonRenderer.prototype.render = function (renderables, start, end) {
    var renderContext = this.renderContext;
    var gl = this.renderContext.gl; // Setup states

    gl.disable(gl.DEPTH_TEST);
    gl.depthMask(false);
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Setup the basic program

    this.basicProgram.apply();
    mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
    gl.uniformMatrix4fv(this.basicProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix); // Render each renderables

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      var bucket = renderable.bucket; // Set the color

      var color = bucket.style.getStrokeColor();
      gl.uniform4f(this.basicProgram.uniforms.color, color[0], color[1], color[2], color[3] * bucket.layer.getOpacity()); // Update vertex buffer

      if (!renderable.vertexBuffer) {
        renderable.vertexBuffer = gl.createBuffer();
        renderable.lineIndexBuffer = gl.createBuffer();
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
      gl.vertexAttribPointer(this.basicProgram.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);

      if (renderable.bufferDirty) {
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.lineIndices), gl.STATIC_DRAW);
        renderable.bufferDirty = false;
      }

      gl.drawElements(gl.LINES, renderable.lineIndices.length, gl.UNSIGNED_SHORT, 0);

      if (bucket.polygonProgram) {
        var program = bucket.polygonProgram;
        program.apply();
        gl.uniformMatrix4fv(program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
        gl.uniform1i(program.uniforms.texture, 0);

        if (renderable.tcoords.length > 0) {
          // Use tcoord buffer defined by _imageCoordinates
          if (!renderable.tcoordBuffer) {
            renderable.tcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.tcoords), gl.STATIC_DRAW);
            renderable.tcoordBuffer.itemSize = 2;
            renderable.tcoordBuffer.numItems = renderable.tcoords.length / 2;
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
        } else {
          // Use default tcoord buffer
          gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
        }

        gl.vertexAttribPointer(program.attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
        gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

        if (bucket.style.fillShader && bucket.style.fillShader.updateUniforms) {
          bucket.style.fillShader.updateUniforms(gl, renderable.bucket, program);
        }

        if (!renderable.triangleIndexBuffer) {
          renderable.triangleIndexBuffer = gl.createBuffer();
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.triangleIndexBuffer);

        if (renderable.triBufferDirty) {
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.triangleIndices), gl.STATIC_DRAW);
          renderable.triBufferDirty = false;
        } // Add texture


        gl.activeTexture(gl.TEXTURE0);

        if (renderable.bucket.texture) {
          gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable

          gl.uniform4f(program.uniforms.color, 1.0, 1.0, 1.0, color[3] * bucket.layer.getOpacity()); // use whiteColor
        } else {
          gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture); // use white texture

          color = renderable.bucket.style.fillColor;
          gl.uniform4f(program.uniforms.color, color[0], color[1], color[2], color[3] * bucket.layer.getOpacity());
        }

        gl.drawElements(gl.TRIANGLES, renderable.triangleIndices.length, gl.UNSIGNED_SHORT, 0);
        this.basicProgram.apply();
      }
    }

    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/


  RendererManager.factory.push(function (globe) {
    return new ConvexPolygonRenderer(globe);
  });

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  /**
   @name PolyLineRenderer
   @class
       Basic renderer for polylines
   @param {AbstractGlobe} globe AbstractGlobe
   @augments VectorRenderer
   @constructor
   */

  var PolyLineRenderer = function (globe) {
    this.globe = globe;
    this.buckets = [];
  };
  /**************************************************************************************************************/


  PolyLineRenderer.prototype.generateLevelZero = function (tile) {
    for (var bucket of this.buckets) {
      const layer = bucket.layer;
      const geometry = bucket.geometry;
      const style = bucket.style;
      this.removeGeometry(layer);
      this.addGeometry(layer, geometry, style);
    }
  };
  /**************************************************************************************************************/


  var MainRenderable = function (bucket, rc) {
    this.bucket = bucket;
    this.renderable = new Renderable$2(bucket);
    this.clippedRenderable = new Renderable$2(bucket);
    this.vertexShader = `
        attribute vec3 vertex;
        uniform mat4 uModelViewProjMatrix;
        void main() {
        	gl_Position = uModelViewProjMatrix * vec4(vertex, 1.0);
        }
        `;
    this.fragmentShader = `
        precision lowp float;
        uniform vec4 uColor;
        void main() {
        	gl_FragColor = uColor;
        }
        `;
    this.clippedVertexShader = `
        attribute vec3 aVertex;
        uniform mat4 uModelViewProjMatrix;
        uniform mat4 uModelViewMatrix;

        uniform vec3 uClipPlane;
        uniform vec3 uClipNormal;

        varying float vClipDistance;

        void main() {
            gl_Position = uModelViewProjMatrix * vec4(aVertex, 1.0);

            vec2 a = normalize(aVertex.xy - uClipPlane.xy);
            vec2 n = normalize(uClipNormal.xy);

            vClipDistance = dot(a, n);
        }`;
    this.clippedFragmentShader = `
        precision lowp float;
        uniform vec4 uColor;

        varying float vClipDistance;

        void main() {
            if (vClipDistance < 0.0) discard;
            gl_FragColor = uColor;
        }
        `;
    this.program = new Program(rc);
    this.program.createFromSource(this.vertexShader, this.fragmentShader);
    this.clippedProgram = new Program(rc);
    this.clippedProgram.createFromSource(this.clippedVertexShader, this.clippedFragmentShader);
    this.matrix = mat4.create();
    this.leftClipPlane = vec3.create();
    this.leftClipNormal = vec3.create();
    this.rightClipPlane = vec3.create();
    this.rightClipNormal = vec3.create();
  };
  /**************************************************************************************************************/


  MainRenderable.prototype.dispose = function (rc) {
    this.renderable.dispose(rc);
    this.clippedRenderable.dispose(rc);
  };
  /**************************************************************************************************************/


  MainRenderable.prototype.renderDefault = function (rc, mvpMatrix, color) {
    const gl = rc.gl;
    this.program.apply();
    gl.uniformMatrix4fv(this.program.uniforms.uModelViewProjMatrix, false, mvpMatrix);
    gl.uniform4f(this.program.uniforms.uColor, color[0], color[1], color[2], color[3]);
    this.renderable.bindBuffers(rc); // Setup attributes

    gl.vertexAttribPointer(this.program.attributes.aVertex, 3, gl.FLOAT, false, 12, 0);

    for (var line of this.renderable.lines) {
      // Draw
      gl.drawElements(gl.LINE_STRIP, line.indexCount, gl.UNSIGNED_INT, line.startIndex * 4 // * sizeof(int)
      );
    }
  };
  /**************************************************************************************************************/


  MainRenderable.prototype.renderClipped = function (rc, mvpMatrix, color) {
    const gl = rc.gl;
    this.clippedProgram.apply();
    const modelViewMatrix = mat4.create();
    mat4.multiply(rc.viewMatrix, this.matrix, modelViewMatrix);
    gl.uniformMatrix4fv(this.clippedProgram.uniforms.uModelViewProjMatrix, false, mvpMatrix);
    gl.uniform4f(this.clippedProgram.uniforms.uColor, color[0], color[1], color[2], color[3]);
    this.clippedRenderable.bindBuffers(rc); // Setup attributes

    gl.vertexAttribPointer(this.clippedProgram.attributes.aVertex, 3, gl.FLOAT, false, 12, 0);
    gl.uniform3f(this.clippedProgram.uniforms.uClipPlane, this.rightClipPlane[0], this.rightClipPlane[1], this.rightClipPlane[2]);
    gl.uniform3f(this.clippedProgram.uniforms.uClipNormal, this.rightClipNormal[0], this.rightClipNormal[1], this.rightClipNormal[2]);
    var line;

    for (line of this.clippedRenderable.lines) {
      // Draw
      gl.drawElements(gl.LINE_STRIP, line.indexCount, gl.UNSIGNED_INT, line.startIndex * 4 // * sizeof(int)
      );
    }

    gl.uniform3f(this.clippedProgram.uniforms.uClipPlane, this.leftClipPlane[0], this.leftClipPlane[1], this.leftClipPlane[2]);
    gl.uniform3f(this.clippedProgram.uniforms.uClipNormal, this.leftClipNormal[0], this.leftClipNormal[1], this.leftClipNormal[2]);

    for (line of this.clippedRenderable.clippedLines) {
      // Draw
      gl.drawElements(gl.LINE_STRIP, line.indexCount, gl.UNSIGNED_INT, line.startIndex * 4 // * sizeof(int)
      );
    }
  };
  /**************************************************************************************************************/


  MainRenderable.prototype.render = function (rc, viewProjMatrix) {
    const gl = rc.gl;
    const layer = this.bucket.layer;
    const style = this.bucket.style;
    const modelViewProjMatrix = mat4.create();
    mat4.multiply(viewProjMatrix, this.matrix, modelViewProjMatrix);
    const color = style.strokeColor.slice(0);
    color[3] *= layer.getOpacity();
    gl.lineWidth(style.strokeWidth);
    this.renderDefault(rc, modelViewProjMatrix, color);
    this.renderClipped(rc, modelViewProjMatrix, color);
  };
  /**************************************************************************************************************/


  var Renderable$2 = function (bucket) {
    this.bucket = bucket;
    this.vertices = [];
    this.indices = [];
    this.dirty = false;
    this.ibo = null;
    this.vbo = null;
    this.lines = [];
    this.clippedLines = [];
  };
  /**************************************************************************************************************/


  Renderable$2.prototype._clamp = function (x, a, b) {
    return Math.max(a, Math.min(x, b));
  };
  /**************************************************************************************************************/


  Renderable$2.prototype._subdivideSegment = function (p0, p1) {
    const globe = this.bucket.renderer.globe;
    const cs = new WGS84Crs();
    const scale = cs.getGeoide().getHeightScale();
    const subdivisionLength = globe.getSubdivisionLength() * scale;
    const maxSubdivisionCount = globe.getMaxSubdivisionCount();
    var p0in3d = vec3.create();
    cs.get3DFromWorldInCrs(p0, "CRS:84", p0in3d);
    var p1in3d = vec3.create();
    cs.get3DFromWorldInCrs(p1, "CRS:84", p1in3d);
    const d = vec3.dist(p0in3d, p1in3d);

    const subdivisionCount = this._clamp(Math.floor(d / subdivisionLength), 1, maxSubdivisionCount);

    const alt0 = p0[2];
    const alt1 = p1[2];
    const result = [];
    const step = 1.0 / subdivisionCount;

    for (var i = 0; i <= subdivisionCount; ++i) {
      const t = i * step;
      var p = vec3.create();
      vec3.lerp(p0in3d, p1in3d, t, p);
      var pInGeo = vec3.create();
      cs.getWorldFrom3D(p, pInGeo);
      pInGeo[2] = (1 - t) * alt0 + t * alt1;
      result.push(pInGeo);
    }

    return result;
  };
  /**************************************************************************************************************/

  /**
   * Subdivide a line to follow planet curvature
   */


  Renderable$2.prototype._subdivideLine = function (line) {
    var result = [];

    for (var i = 0; i < line.length - 1; ++i) {
      result = result.concat(this._subdivideSegment(line[i], line[i + 1]));
    } // Remove consecutive duplicates


    for (i = result.length - 1; i >= 1; --i) {
      const curr = result[i];
      const prev = result[i - 1];

      if (curr[0] === prev[0] && curr[1] === prev[1] && curr[2] === prev[2]) {
        result.splice(i, 1);
      }
    }

    return result;
  };
  /**************************************************************************************************************/


  const _fixPoles = function (lines) {
    for (var line of lines) {
      for (var i = 0; i < line.length; ++i) {
        const curr = line[i];

        if (curr[1] === 90.0 || curr[1] === -90) {
          if (i > 0 && i < line.length - 1) {
            // General case
            const prev = line[i - 1];
            const next = line[i + 1];

            if (prev[0] === curr[0]) {
              line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
              ++i;
            } else if (next[0] === curr[0]) {
              line.splice(i, 0, [prev[0], curr[1], curr[2]]);
              ++i;
            } else {
              line.splice(i, 0, [prev[0], curr[1], curr[2]]);
              ++i;
              line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
              ++i;
            }
          } // edges
          else if (i > 0) {
              const prev = line[i - 1];

              if (prev[0] !== curr[0]) {
                line.splice(i, 0, [prev[0], curr[1], curr[2]]);
                ++i;
              }
            } else if (i < line.length - 1) {
              const next = line[i + 1];

              if (next[0] !== curr[0]) {
                line.splice(i + 1, 0, [next[0], curr[1], curr[2]]);
                ++i;
              }
            }
        }
      }
    }
  };
  /**************************************************************************************************************/


  const _detectDiscontinuities = function (lines, normalLines, clippedLines) {
    for (var line of lines) {
      var continuous = true;

      for (var i = 0; continuous && i < line.length - 1; ++i) {
        const x0 = Math.min(line[i][0], line[i + 1][0]);
        const x1 = Math.max(line[i][0], line[i + 1][0]);

        if (x0 < 0 && x1 > 0) {
          const d1 = x1 - x0;
          const d2 = 360 + x0 - x1;

          if (d2 < d1) {
            continuous = false;
          }
        }
      }

      if (continuous) {
        normalLines.push(line);
      } else {
        clippedLines.push(line);
      }
    }
  };
  /**************************************************************************************************************/

  /**
   * Add a geometry to the renderable
   * Vertex buffer : geometry
   * Index buffer : lines
   * @function build
   * @memberof Renderable.prototype
   * @param geometry
   */


  MainRenderable.prototype.build = function (geometry) {
    var renderer = this.bucket.renderer; //var style = this.bucket.style;

    var cs = renderer.globe.getCoordinateSystem();
    var lines;

    if (geometry.type === Constants.GEOMETRY.MultiLineString || Array.isArray(geometry.coordinates[0][0])) {
      lines = geometry.coordinates;
    } else {
      lines = [geometry.coordinates];
    }

    lines = JSON.parse(JSON.stringify(lines));
    var geometryBound = new GeoBound();
    var crsName = "CRS:84";

    if (typeof geometry.crs !== "undefined") {
      crsName = geometry.crs.properties.name;
    }

    var originPoint = lines[0][0].slice(0);
    originPoint[2] = 0.0;
    var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(originPoint, crsName, cs);
    var origin = vec3.create();
    cs.get3DFromWorld(convertedCoord, origin); // Correction : add [0]

    mat4.identity(this.matrix);
    mat4.translate(this.matrix, origin);
    const leftPlane = [-180, 0, 0];
    const leftNormal = [1, 0, 0];
    cs.get3DFromWorldInCrs(leftPlane, crsName, this.leftClipPlane);
    cs.get3DFromWorldInCrs(leftNormal, crsName, this.leftClipNormal);
    vec3.normalize(this.leftClipNormal);
    vec3.subtract(this.leftClipPlane, origin);
    const rightPlane = [180, 0, 0];
    const rightNormal = [-1, 0, 0];
    cs.get3DFromWorldInCrs(rightPlane, crsName, this.rightClipPlane);
    cs.get3DFromWorldInCrs(rightNormal, crsName, this.rightClipNormal);
    vec3.normalize(this.rightClipNormal);
    vec3.subtract(this.rightClipPlane, origin); // Check if some lines are going through the poles
    // In this case, we want to duplicate the points that do not have the same x coordinate.

    _fixPoles(lines);

    var normalLines = [];
    var clippedLines = [];
    var proj = null;

    if (cs.projection && cs.projection.options && cs.projection.options.projectionName) {
      proj = cs.projection.options.projectionName;
    }

    if (cs.flat === true && proj !== Constants.PROJECTION.Azimuth) {
      _detectDiscontinuities(lines, normalLines, clippedLines);
    } else {
      normalLines = lines.slice(0);
    }

    this.renderable.build(normalLines, cs, crsName, origin);
    this.clippedRenderable.buildClipped(clippedLines, cs, crsName, origin);
    return true;
  };
  /**************************************************************************************************************/


  Renderable$2.prototype.build = function (lines, cs, crsName, origin) {
    var lastIndex = 0;
    var pos3d = vec3.create();

    for (var line of lines) {
      var lineInfos = {
        startIndex: lastIndex,
        indexCount: -1
      }; // First, subdivide the line

      const finalLine = this._subdivideLine(line);

      for (var coords of finalLine) {
        cs.get3DFromWorldInCrs(coords, crsName, pos3d);

        for (var i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);

        this.indices.push(lastIndex++);
      }

      lineInfos.indexCount = lastIndex - lineInfos.startIndex;
      this.lines.push(lineInfos);
    }

    this.dirty = true;
  };
  /**************************************************************************************************************/


  Renderable$2.prototype.buildClipped = function (lines, cs, crsName, origin) {
    var lastIndex = 0;
    var pos3d = vec3.create();
    var i;

    for (var line of lines) {
      var lineInfos = {
        startIndex: lastIndex,
        indexCount: -1
      };

      const finalLine = this._subdivideLine(line);

      const finalLine1 = [];
      const finalLine2 = [];

      for (i = 0; i < finalLine.length; ++i) {
        const x = finalLine[i][0];
        const x1 = x >= 0 ? x : x + 360;
        const x2 = x <= 0 ? x : x - 360;
        finalLine1.push([x1, finalLine[i][1], finalLine[i][2]]);
        finalLine2.push([x2, finalLine[i][1], finalLine[i][2]]);
      } // First, subdivide the line


      var lineIdx;

      for (lineIdx = 0; lineIdx < finalLine1.length; ++lineIdx) {
        const coords = finalLine1[lineIdx];
        cs.get3DFromWorldInCrs(coords, crsName, pos3d);

        for (i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);

        var wrapAround = false;

        if (lineIdx > 1) {
          const x0 = finalLine1[lineIdx][0];
          const x1 = finalLine1[lineIdx - 1][0];
          const x2 = finalLine1[lineIdx - 2][0];
          const currDir = x0 - x1;
          const lastDir = x1 - x2; // We changed direction
          // last point is outside the visible range
          // Current point is inside  the visible range

          if (lastDir > 0 && currDir < 0 && x1 > 180 && x0 < 180) {
            const distanceAsIt = x1 - x0;
            const distanceWithWrapAround = x0 + 360 - x1;

            if (distanceWithWrapAround < distanceAsIt) {
              wrapAround = true;
            }
          } else if (lastDir < 0 && currDir > 0 && x1 < 180 && x0 > 180) {
            const distanceAsIt = x0 - x1;
            const distanceWithWrapAround = x1 + 360 - x0;

            if (distanceWithWrapAround < distanceAsIt) {
              wrapAround = true;
            }
          }
        }

        if (wrapAround) {
          lineInfos.indexCount = lastIndex - lineInfos.startIndex;
          this.lines.push(lineInfos);
          lineInfos = {
            startIndex: lastIndex,
            indexCount: -1
          };
        }

        this.indices.push(lastIndex++);
      }

      lineInfos.indexCount = lastIndex - lineInfos.startIndex;
      this.lines.push(lineInfos);
      lineInfos = {
        startIndex: lastIndex,
        indexCount: -1
      };

      for (lineIdx = 0; lineIdx < finalLine2.length; ++lineIdx) {
        const coords = finalLine2[lineIdx];
        cs.get3DFromWorldInCrs(coords, crsName, pos3d);

        for (i = 0; i < 3; ++i) this.vertices.push(pos3d[i] - origin[i]);

        wrapAround = false;

        if (lineIdx > 1) {
          const x0 = finalLine2[lineIdx][0];
          const x1 = finalLine2[lineIdx - 1][0];
          const x2 = finalLine2[lineIdx - 2][0];
          const currDir = x0 - x1;
          const lastDir = x1 - x2; // We were going "to the left", we changed direction
          // last point is outside the visible range
          // Current point is inside  the visible range

          if (lastDir > 0 && currDir < 0 && x1 > -180 && x0 < -180) {
            const distanceAsIt = x1 - x0;
            const distanceWithWrapAround = x0 - (x1 - 360);

            if (distanceWithWrapAround < distanceAsIt) {
              wrapAround = true;
            }
          } else if (lastDir < 0 && currDir > 0 && x1 < -180 && x0 > -180) {
            const distanceAsIt = x0 - x1;
            const distanceWithWrapAround = x1 - (x0 - 360);

            if (distanceWithWrapAround < distanceAsIt) {
              wrapAround = true;
            }
          }
        }

        if (wrapAround) {
          lineInfos.indexCount = lastIndex - lineInfos.startIndex;
          this.clippedLines.push(lineInfos);
          lineInfos = {
            startIndex: lastIndex,
            indexCount: -1
          };
        }

        this.indices.push(lastIndex++);
      }

      lineInfos.indexCount = lastIndex - lineInfos.startIndex;
      this.clippedLines.push(lineInfos);
    }

    this.dirty = true;
  };
  /**************************************************************************************************************/


  Renderable$2.prototype.dispose = function (rc) {
    if (!rc) return;
    const gl = rc.gl;
    if (this.ibo) gl.deleteBuffer(this.ibo);
    if (this.vbo) gl.deleteBuffer(this.vbo);
    this.ibo = null;
    this.vbo = null;
  };
  /**************************************************************************************************************/


  Renderable$2.prototype.bindBuffers = function (rc) {
    if (!rc) return;
    const gl = rc.gl;

    if (this.dirty) {
      this.dispose(rc);
      this.vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
      this.ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(this.indices), gl.STATIC_DRAW);
      this.dirty = false;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibo);
  };
  /**************************************************************************************************************/

  /**
   @name Bucket
   @class
       Bucket constructor for RasterOverlay
   @param layer
   @constructor
  */


  var Bucket$3 = function (layer, style, geometry, rc) {
    this.layer = layer;
    this.renderer = null;
    this.style = new FeatureStyle(style);
    this.geometry = geometry;
    this.mainRenderable = new MainRenderable(this, rc);
    this.id = -1;
  };
  /**************************************************************************************************************/


  PolyLineRenderer.prototype.addGeometry = function (layer, geometry, style) {
    var bucket = new Bucket$3(layer, style, geometry, this.globe.renderContext);
    bucket.renderer = this;
    bucket.id = this.globe.getRendererManager().bucketId++;
    bucket.mainRenderable.build(geometry);
    geometry._bucket = bucket;
    layer._bucket = bucket;
    this.buckets.push(bucket);
  };
  /**************************************************************************************************************/


  PolyLineRenderer.prototype.removeGeometry = function (layer, geometry) {
    var bucket = layer._bucket;

    if (bucket.mainRenderable) {
      // Cleanup opengl resources
      bucket.mainRenderable.dispose(this.globe.renderContext);
      bucket.mainRenderable = null;
    }

    const index = this.buckets.indexOf(bucket);

    if (index !== -1) {
      this.buckets.splice(index, 1);
    }
  };
  /**************************************************************************************************************/

  /**
   *    Render all the lines
   * @function render
   * @memberof PolyLineRenderer.prototype
   * @param renderables
   * @param {Integer} start Start index
   * @param {Integer} end End index
   */


  PolyLineRenderer.prototype.render = function (renderables, start, end) {
    const rc = this.globe.renderContext;
    const gl = rc.gl;
    gl.enable(gl.BLEND);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL); // Compute the viewProj matrix

    var viewProjMatrix = mat4.create();
    mat4.multiply(rc.projectionMatrix, rc.viewMatrix, viewProjMatrix);

    for (var n = start; n < end; n++) {
      var renderable = renderables[n];
      renderable.render(rc, viewProjMatrix);
    } // Revert line width


    gl.lineWidth(1.0); //gl.enable(gl.DEPTH_TEST);
    //gl.disable(gl.POLYGON_OFFSET_FILL);

    gl.depthFunc(gl.LESS);
    gl.disable(gl.BLEND);
  };
  /**************************************************************************************************************/

  /**
   * Check if renderer is applicable
   * @function canApply
   * @memberof PolyLineRenderer.prototype
   * @param type
   * @param style
   * @return {Boolean} Can apply ?
   */


  PolyLineRenderer.prototype.canApply = function (type, style) {
    if (style.onTerrain === undefined || style.onTerrain === true) {
      return false;
    }

    return type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString;
  };
  /**************************************************************************************************************/

  /**
   * Create a bucket
   * @function createBucket
   * @memberof PolyLineRenderer.prototype
   * @param layer
   * @param style
   * @return {PolyLineBucket} Bucket
   */


  PolyLineRenderer.prototype.createBucket = function (layer, style) {
    return new Bucket$3(layer, style);
  };
  /**************************************************************************************************************/
  // Register the renderer


  RendererManager.factory.push(function (globe) {
    return new PolyLineRenderer(globe);
  });

  const DEFAULT_POSITION_TRACKER_ELT = "posTracker";
  const DEFAULT_POSITION_TRACKER_ELT_POS = "bottom";
  const DEFAULT_ELEVATION_TRACKER_ELT = "elevTracker";
  const DEFAULT_ELEVATION_TRACKER_ELT_POS = "bottom";
  const DEFAULT_COMPASS_ELT = "compassDiv";
  const DEFAULT_ATTRIBUTION_ELT = "globeAttributions";
  const DEFAULT_TIMETRAVEL_ELT = "timeTravelDiv";
  const DEFAULT_ZOOM_DURATION = 3000;

  var AbstractContext = function (mizarConfiguration, mode, ctxOptions) {
    Event.prototype.constructor.call(this);
    var self = this;
    this.time = Time.parse(Moment__default['default']().toISOString());
    this.globe = null;
    this.navigation = null;
    this.attributionHandler = null;
    this.components = {};
    this.dataProviders = {};
    this.canvas = mizarConfiguration.canvas;
    this.isMobile = ctxOptions.isMobile;
    this.isEnableCtx = true;
    this.timeTravelService = ctxOptions.timeTravelService;
    this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function (imagery) {
      if (self.getNavigation().getRenderContext().viewMatrix[0] !== "undefined") {
        self.getNavigation().computeViewMatrix();
      }
    });
    this.mizarConfiguration = mizarConfiguration.hasOwnProperty("configuration") ? mizarConfiguration.configuration : {};
    this.ctxOptions = ctxOptions;
    this.mode = mode;
    this.layers = [];
    this.pendingLayers = [];
    this.initCanvas(this.canvas);
    this.positionTracker = _createTrackerPosition.call(this, this.mizarConfiguration);
    this.elevationTracker = _createTrackerElevation.call(this, this.mizarConfiguration, ctxOptions);
    this.compass = _createCompass.call(this, this.mizarConfiguration);
  };

  function _initComponentsVisibility(components) {
    for (var componentId in components) {
      if (_isDivExist(componentId)) {
        if (components[componentId]) {
          $__default['default']("#" + componentId).fadeIn(1000);
        } else {
          $__default['default']("#" + componentId).fadeOut();
        }
      }
    }
  }

  function _isDivExist(divID) {
    return $__default['default']("#" + divID).length;
  }

  function _handleCameraWhenLayerAdded(layer) {
    if (layer.isVisible() && layer.getProperties() && !layer.isBackground() && layer.getProperties().hasOwnProperty("initialRa") && layer.getProperties().hasOwnProperty("initialDec")) {
      var fov = layer.getProperties().initialFov ? layer.getProperties().initialFov : layer.getGlobe().getRenderContext().getFov();
      var navigation = layer.callbackContext.getNavigation();
      var center = navigation.getCenter();
      var globeType = layer.globe.getType();
      var bbox;

      switch (globeType) {
        case Constants.GLOBE.Sky:
          bbox = layer.getProperties().bbox;

          if (bbox != null && UtilsIntersection.isValueBetween(center[0], bbox[0], bbox[2]) && UtilsIntersection.isValueBetween(center[1], bbox[1], bbox[3])) ; else {
            if (layer.getProperties().moc_sky_fraction != null) {
              fov = Math.sqrt(Math.pow(360, 2) / Math.PI * layer.getProperties().moc_sky_fraction);

              if (fov > 180) {
                fov = 180;
              }
            }

            navigation.zoomTo([layer.getProperties().initialRa, layer.getProperties().initialDec], {
              fov: fov * 0.5,
              duration: DEFAULT_ZOOM_DURATION
            });
          }

          break;

        case Constants.GLOBE.Planet:
          bbox = layer.getProperties().bbox;

          if (UtilsIntersection.isValueBetween(center[0], bbox[0], bbox[2]) && UtilsIntersection.isValueBetween(center[1], bbox[1], bbox[3])) ; else {
            var crs = layer.globe.getCoordinateSystem();
            var planetRadius = crs.getGeoide().getRealPlanetRadius();
            var distanceCamera = Utils.computeDistanceCameraFromBbox(bbox, fov, planetRadius, crs.isFlat());
            var elevation = layer.globe.getElevation(layer.getProperties().initialRa, layer.getProperties().initialDec);

            if (elevation > distanceCamera || distanceCamera === 0) {
              distanceCamera = elevation + 100;
            }

            navigation.zoomTo([layer.getProperties().initialRa, layer.getProperties().initialDec], {
              distance: distanceCamera,
              duration: 3000
            });
          }

          break;

        default:
          throw new SyntaxError("AbstractContext.js: type " + globeType + " is not implemented");
      }
    }
  }

  function _createTrackerPosition(mizarConfiguration) {
    try {
      return new PositionTracker({
        element: mizarConfiguration.positionTracker && mizarConfiguration.positionTracker.element ? mizarConfiguration.positionTracker.element : DEFAULT_POSITION_TRACKER_ELT,
        isMobile: mizarConfiguration.isMobile,
        position: mizarConfiguration.positionTracker && mizarConfiguration.positionTracker.position ? mizarConfiguration.positionTracker.position : DEFAULT_POSITION_TRACKER_ELT_POS
      });
    } catch (err) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Cannot create position tracker", err);
    }
  }

  function _createTrackerElevation(mizarConfiguration, ctxOptions) {
    try {
      return new ElevationTracker({
        element: mizarConfiguration.elevationTracker && mizarConfiguration.elevationTracker.element ? mizarConfiguration.elevationTracker.element : DEFAULT_ELEVATION_TRACKER_ELT,
        isMobile: mizarConfiguration.isMobile,
        position: mizarConfiguration.elevationTracker && mizarConfiguration.elevationTracker.elevation ? mizarConfiguration.elevationTracker.position : DEFAULT_ELEVATION_TRACKER_ELT_POS,
        elevationLayer: ctxOptions.planetLayer !== undefined ? ctxOptions.planetLayer.elevationLayer : undefined
      });
    } catch (err) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Cannot create elevation tracker", err);
    }
  }

  function _createCompass(mizarConfiguration) {
    try {
      return new Compass({
        element: mizarConfiguration.compass ? mizarConfiguration.compass : DEFAULT_COMPASS_ELT,
        ctx: this,
        isMobile: this.isMobile
      });
    } catch (err) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Cannot create compass tracker", err);
    }
  }

  function _createTimeTravel(mizarConfiguration) {
    try {
      var crs;

      if (this.mode === Constants.CONTEXT.Sky) {
        crs = Constants.CRS.Equatorial;
      } else {
        crs = this.getCoordinateSystem().getGeoideName();
      }

      return new TimeTravel({
        element: mizarConfiguration.timeTravel && mizarConfiguration.timeTravel.element ? mizarConfiguration.timeTravel.element : DEFAULT_TIMETRAVEL_ELT,
        ctx: this,
        crs: crs
      });
    } catch (err) {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Cannot create time travel", err);
    }
  }

  function _addToGlobe(layer) {
    if (!this._getGlobe().hasDefinedBackground() && layer.isBackground()) {
      this._getGlobe().setBaseImagery(layer);
    } else {
      this._getGlobe().addLayer(layer);
    }
  }

  function _removeRasterOverlay(layer) {
    if (layer.getInformationType() === Constants.INFORMATION_TYPE.RASTER && !layer.isBackground()) {
      this._getGlobe().rasterOverlayRenderer.removeOverlay(layer);

      layer.background = true;
    }
  }

  Utils.inherits(Event, AbstractContext);

  AbstractContext.prototype.getTime = function () {
    return this.time;
  };

  AbstractContext.prototype.setTime = function (time) {
    this.time = Time.parse(time);

    for (var i = 0; i < this.layers.length; i++) {
      var layer = this.layers[i];
      layer.setTime(this.time);
    }
  };

  AbstractContext.prototype._showUpError = function (err) {
    if (document.getElementById("MizarCanvas")) {
      document.getElementById("MizarCanvas").style.display = "none";
    }

    if (document.getElementById("loading")) {
      document.getElementById("loading").style.display = "none";
    }

    if (document.getElementById("webGLNotAvailable")) {
      document.getElementById("webGLNotAvailable").style.display = "block";
    }
  };

  AbstractContext.prototype._fillDataProvider = function (layer, mizarDescription) {
    if (mizarDescription.data && this.dataProviders[mizarDescription.data.type]) {
      var callback = this.dataProviders[mizarDescription.data.type];
      callback(layer, mizarDescription.data);
    }
  };

  AbstractContext.prototype.getDataProviderLayers = function () {
    var dpLayers = [];
    var layers = this.getLayers();
    var i = layers.length;
    var layer = layers[i];

    while (layer) {
      if (layer.hasOwnProperty("options") && layer.options.hasOwnProperty("type") && layer.options.type === Constants.LAYER.GeoJSON) {
        dpLayers.push(layer);
      }

      layer = layers[++i];
    }

    return dpLayers;
  };

  AbstractContext.prototype.getTileManager = function () {
    return this._getGlobe().getTileManager();
  };

  AbstractContext.prototype.registerNoStandardDataProvider = function (type, loadFunc) {
    this.dataProviders[type.toString()] = loadFunc;
  };

  AbstractContext.prototype.getContextConfiguration = function () {
    return this.ctxOptions;
  };

  AbstractContext.prototype.getMizarConfiguration = function () {
    return this.mizarConfiguration;
  };

  AbstractContext.prototype._getGlobe = function () {
    return this.globe;
  };

  AbstractContext.prototype.getLonLatFromPixel = function (x, y) {
    return this._getGlobe().getLonLatFromPixel(x, y);
  };

  AbstractContext.prototype.getPixelFromLonLat = function (longitude, latitude) {
    return this._getGlobe().getPixelFromLonLat(longitude, latitude);
  };

  AbstractContext.prototype.getElevation = function (lon, lat) {
    return this._getGlobe().getElevation(lon, lat);
  };

  AbstractContext.prototype.getPositionTracker = function () {
    return this.positionTracker;
  };

  AbstractContext.prototype.getElevationTracker = function () {
    return this.elevationTracker;
  };

  AbstractContext.prototype.getLayers = function () {
    return this.layers;
  };

  AbstractContext.prototype.getLayerByID = function (layerId) {
    return _$1.find(_$1.union(this.getLayers()), function (layer) {
      return layer.getID() === layerId;
    });
  };

  AbstractContext.prototype.getLayerByName = function (layerName) {
    return _$1.findWhere(this.getLayers(), {
      name: layerName
    });
  };

  AbstractContext.prototype.addLayer = function (layerDescription, callback, fallback) {
    var pendingLayersHandler = new PendingLayersRegistryHandler(this.pendingLayers, this.layers);
    var wmsServerHandler = new WMSServerRegistryHandler(this.pendingLayers);
    var wmtsServerHandler = new WMTSServerRegistryHandler(this.pendingLayers);
    var wcsServerHandler = new WCSServerRegistryHandler(this.layers, this.pendingLayers);
    var openSearchServerHandler = new OpenSearchRegistryHandler(this.pendingLayers);
    var layerHandler = new LayerRegistryHandler(this.pendingLayers);
    pendingLayersHandler.setNext(wmsServerHandler);
    wmsServerHandler.setNext(wmtsServerHandler);
    wmtsServerHandler.setNext(wcsServerHandler);
    wcsServerHandler.setNext(openSearchServerHandler);
    openSearchServerHandler.setNext(layerHandler);
    var self = this;
    pendingLayersHandler.handleRequest(layerDescription, function (layers) {
      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        layer.callbackContext = self;
        self.layers.push(layer);

        if (layer.autoFillTimeTravel === true) {
          if (layer.visible === true && self.timeTravelService) {
            self.timeTravelService.update(layer.timeTravelValues);
          }
        }

        _addToGlobe.call(self, layer);

        self._fillDataProvider(layer, layerDescription);

        if (layer.isVisible()) {
          layer.setTime(self.getTime());
        }

        if (layer.isPickable()) {
          ServiceFactory.create(Constants.SERVICE.PickingManager).addPickableLayer(layer);
        }

        layer.subscribe(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, _handleCameraWhenLayerAdded);

        if (callback) {
          callback(layer.ID);
        }
      }
    }, function (e) {
      if (fallback) {
        fallback(e);
      } else {
        ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot create the layer(s)", e);
      }
    });
  };

  AbstractContext.prototype.getLinkedLayers = function (layerID) {
    var indexes = $__default['default'].map(this.layers, function (obj, index) {
      if (obj.linkedTo === layerID) {
        return index;
      }
    });
    var linkedLayers = [];

    for (var i = 0; i < indexes.length; i++) {
      linkedLayers.push(this.layers[indexes[i]]);
    }

    return linkedLayers;
  };

  AbstractContext.prototype.removeLayer = function (layerID) {
    var removedLayer = null;
    var indexes = $__default['default'].map(this.layers, function (obj, index) {
      if (obj.ID === layerID) {
        return index;
      }
    });

    if (indexes.length > 0) {
      var removedLayers = this.layers.splice(indexes[0], 1);
      removedLayer = removedLayers[0];

      if (removedLayer.autoFillTimeTravel === true) {
        this.timeTravelService.update({
          remove: {
            ID: layerID
          }
        });
      }

      var tileManager = this.getTileManager();
      tileManager.abortLayerRequests(removedLayer);
      removedLayer.unsubscribe(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, _handleCameraWhenLayerAdded);
      ServiceFactory.create(Constants.SERVICE.PickingManager).removePickableLayer(removedLayer);

      this._getGlobe().removeLayer(removedLayer);

      this.getRenderContext().requestFrame();
    }

    return removedLayer;
  };

  AbstractContext.prototype.removeAllLayers = function () {
    var nbLayers = this.layers.length;

    while (nbLayers != 0) {
      var layerIndex = nbLayers - 1;
      var layerID = this.layers[layerIndex].ID;
      if (this.attributionHandler != null) this.attributionHandler.removeAttribution(this.layers[layerIndex]);
      this.removeLayer(layerID);
      nbLayers--;
    }
  };

  AbstractContext.prototype.addDraw = function (layer) {
    Utils.assert(layer.type === Constants.LAYER.Vector, "layer must be a vector layer in addDraw", "AbstractContext.js");
    layer.setDraw(true);

    this._getGlobe().addLayer(layer);
  };

  AbstractContext.prototype.removeDraw = function (layer) {
    this._getGlobe().removeLayer(layer);
  };

  AbstractContext.prototype.refresh = function () {
    if (this._getGlobe()) {
      this._getGlobe().refresh();
    }
  };

  AbstractContext.prototype.initCanvas = function (canvas) {
    var width, height;
    var parentCanvas = $__default['default'](canvas.parentElement);
    $__default['default'](canvas.parentElement).find("#loading").show();

    if ($__default['default'](canvas).attr("width")) {
      width = $__default['default'](canvas).attr("width");
    } else if (parentCanvas.attr("width")) {
      width = parentCanvas.attr("width");
    } else {
      width = window.innerWidth;
    }

    if ($__default['default'](canvas).attr("height")) {
      height = $__default['default'](canvas).attr("height");
    } else if (parentCanvas.attr("height")) {
      height = parentCanvas.attr("height");
    } else {
      height = window.innerHeight;
    }

    canvas.width = width;
    canvas.height = height;
    $__default['default'](canvas).css("background-color", "black");

    if (parentCanvas) {
      parentCanvas.css({
        position: "relative",
        overflow: "hidden"
      });
    }

    var self = this;

    var onResize = function () {
      if (parentCanvas && parentCanvas.attr("height") && parentCanvas.attr("width")) {
        canvas.width = parentCanvas.width();
        canvas.height = parentCanvas.height();
      } else {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      self.refresh();
    };

    var timer;
    $__default['default'](window).resize(function () {
      if (timer) {
        clearTimeout(timer);
      }

      timer = setTimeout(onResize, 500);
    });
    canvas.addEventListener("webglcontextlost", function (event) {
      event.preventDefault();
      document.getElementById("loading").style.display = "none";
      document.getElementById("webGLContextLost").style.display = "block";
    }, false);
  };

  AbstractContext.prototype.initGlobe = function (globeOptions, navigationMode) {
    try {
      this.globe = GlobeFactory.create(this.mode, globeOptions);
      var navigationType = this.getCoordinateSystem().isFlat() ? navigationMode["2D"] : navigationMode["3D"];
      this.navigation = NavigationFactory.create(navigationType, this, this.ctxOptions.navigation ? this.ctxOptions.navigation : this.ctxOptions);
      this.attributionHandler = new AttributionHandler(this.globe, {
        element: this.mizarConfiguration.attributionHandler && this.mizarConfiguration.attributionHandler.element ? this.mizarConfiguration.attributionHandler.element : DEFAULT_ATTRIBUTION_ELT
      });

      if (this.positionTracker != null) {
        this.positionTracker.attachTo(this);
        this.setComponentVisibility("posTrackerInfo", false);
      }

      if (this.elevationTracker != null) {
        this.elevationTracker.attachTo(this);
      }

      if (this.compass != null) {
        this.compass.attachTo(this);
      }

      this.timeTravel = _createTimeTravel.call(this, this.mizarConfiguration);
      ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

      _initComponentsVisibility(this.components);

      var self = this;
      this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_ERROR, function (layer) {
        $__default['default'](self.canvas.parentElement).find("#loading").hide();
        ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot add the layer " + (layer.name ? layer.name : layer.ID) + "from " + layer.getBaseUrl(), layer.message);
      });
    } catch (err) {
      this._showUpError(err);
    }
  };

  AbstractContext.prototype.isEnabled = function () {
    return this.isEnableCtx;
  };

  AbstractContext.prototype.isDisabled = function () {
    return !this.isEnabled();
  };

  AbstractContext.prototype.show = function () {
    this.navigation.start();
    this.showComponents();
  };

  AbstractContext.prototype.showComponents = function () {
    for (var componentId in this.components) {
      if (_isDivExist(componentId) && this.components[componentId]) {
        $__default['default']("#" + componentId).fadeIn(1000);
      }
    }
  };

  AbstractContext.prototype.hideComponents = function (uiArray) {
    for (var componentId in this.components) {
      if (_isDivExist(componentId) && $__default['default'].inArray(componentId, uiArray) === -1) {
        $__default['default']("#" + componentId).fadeOut();
      }
    }
  };

  AbstractContext.prototype.hide = function () {
    this.navigation.stopAnimations();
    this.navigation.stop();

    for (var componentId in this.components) {
      if (_isDivExist(componentId)) {
        $__default['default']("#" + componentId).fadeOut();
      }
    }
  };

  AbstractContext.prototype.setComponentVisibility = function (componentId, isVisible) {
    var component = $__default['default']("#" + componentId);

    if (isVisible) {
      component.show();
    } else {
      component.hide();
    }

    this.components[componentId] = isVisible;
  };

  AbstractContext.prototype.getComponentVisibility = function (componentId) {
    return this.components[componentId];
  };

  AbstractContext.prototype.showAdditionalLayers = function () {
    _$1.each(this.visibleLayers, function (layer) {
      layer.setVisible(true);

      if (layer.isPickable()) {
        ServiceFactory.create(Constants.SERVICE.PickingManager).addPickableLayer(layer);
      }
    });
  };

  AbstractContext.prototype.hideAdditionalLayers = function () {
    var self = this;
    this.visibleLayers = [];
    var gwLayers = this.getAdditionalLayers();

    _$1.each(gwLayers, function (layer) {
      if (layer.isVisible()) {
        layer.setVisible(false);
        self.visibleLayers.push(layer);
      }
    });
  };

  AbstractContext.prototype.setBackgroundLayer = function (survey) {
    var gwLayer = this.getLayerByName(survey);

    if (gwLayer) {
      _removeRasterOverlay.call(this, gwLayer);

      this._getGlobe().setBaseImagery(gwLayer);
    } else {
      this.publish(Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR, survey + " hasn't been found");
    }

    return gwLayer;
  };

  AbstractContext.prototype.setBackgroundLayerByID = function (surveyID) {
    var gwLayer = this.getLayerByID(surveyID);

    if (gwLayer) {
      _removeRasterOverlay.call(this, gwLayer);

      this._getGlobe().setBaseImagery(gwLayer);
    } else {
      this.publish(Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR, surveyID + " hasn't been found");
    }

    return gwLayer;
  };

  AbstractContext.prototype.getAdditionalLayers = function () {
    return _$1.filter(this.layers, function (layer) {
      return layer.category !== "background";
    });
  };

  AbstractContext.prototype.getRenderContext = function () {
    return this._getGlobe().getRenderContext();
  };

  AbstractContext.prototype.disable = function () {
    if (this.positionTracker) {
      this.positionTracker.detach();
    }

    if (this.elevationTracker) {
      this.elevationTracker.detach();
    }

    if (this.compass) {
      this.compass.detach();
    }

    var i = 0;
    var layer = this.layers[i];

    while (layer) {
      if (this.attributionHandler != null) this.attributionHandler.disable(layer);
      layer = this.layers[++i];
    }

    var renderers = this.getRenderContext().renderers;

    for (var j = 0; j < renderers.length; j++) {
      if (renderers[j].getType() === this.getMode()) {
        renderers[j].disable();
      }
    }

    this.isEnableCtx = false;
  };

  AbstractContext.prototype.enable = function () {
    if (this.positionTracker != null) this.positionTracker.attachTo(this);
    if (this.elevationTracker != null) this.elevationTracker.attachTo(this);
    if (this.compass != null) this.compass.attachTo(this);
    var i = 0;
    var layer = this.layers[i];

    while (layer) {
      if (layer.isPickable()) {
        ServiceFactory.create(Constants.SERVICE.PickingManager).addPickableLayer(layer);
      }

      if (this.AttributionHandler != null) this.attributionHandler.enable(layer);
      layer = this.layers[++i];
    }

    var renderers = this.getRenderContext().renderers;

    for (i = 0; i < renderers.length; i++) {
      if (renderers[i].getType() === this.getMode()) {
        renderers[i].enable();
      }
    }

    this.isEnableCtx = true;
  };

  AbstractContext.prototype.getMode = function () {
    return this.mode;
  };

  AbstractContext.prototype.setCoordinateSystem = function (cs) {
    throw new SyntaxError("AbstractContext.js: CRS not implemented");
  };

  AbstractContext.prototype.getNavigation = function () {
    return this.navigation;
  };

  AbstractContext.prototype.getCoordinateSystem = function () {
    return this._getGlobe().getCoordinateSystem();
  };

  AbstractContext.prototype.addAnimation = function (anim) {
    this._getGlobe().addAnimation(anim);
  };

  AbstractContext.prototype.removeAnimation = function (anim) {
    this._getGlobe().removeAnimation(anim);
  };

  AbstractContext.prototype.render = function () {
    this._getGlobe().render();
  };

  AbstractContext.prototype.dispose = function () {
    this._getGlobe().dispose();
  };

  AbstractContext.prototype.trackerDestroy = function () {
    if (this.elevationTracker) {
      this.elevationTracker.destroy();
      this.elevationTracker = null;
    }

    if (this.positionTracker) {
      this.positionTracker.destroy();
      this.positionTracker = null;
    }
  };

  AbstractContext.prototype.compassDestroy = function () {
    if (this.compass) {
      this.compass.destroy();
      this.compass = null;
    }
  };

  AbstractContext.prototype.timeTravelDestroy = function () {
    if (this.timeTravel) {
      this.timeTravel.remove();
    }
  };

  AbstractContext.prototype.navigationDestroy = function () {
    if (this.navigation) {
      this.navigation.destroy();
      this.navigation = null;
    }
  };

  AbstractContext.prototype.globeDestroy = function () {
    if (this._getGlobe()) {
      this._getGlobe().destroy();

      this.globe = null;
    }
  };

  AbstractContext.prototype.destroy = function () {
    this.hide();
    this.trackerDestroy();
    this.compassDestroy();
    this.timeTravelDestroy();
    this.removeAllLayers();
    this.components = null;
    this.attributionHandler = null;
    this.layers = null;
    this.visibleLayers = null;
    this.dataProviders = null;
    this.mizarConfiguration = null;
    this.ctxOptions = null;
    this.mode = null;
    var self = this;
    this.unsubscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function (imagery) {
      if (self.getNavigation().getRenderContext().viewMatrix[0] !== "undefined") {
        self.getNavigation().computeViewMatrix();
      }
    });
    this.navigationDestroy();
    this.globeDestroy();
    this.canvas = null;
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  // import Numeric from "../Utils/Numeric";

  /**
   * Planet context configuration
   * @typedef {Object} AbstractContext.planetContext
   * @property {float} [tileErrorTreshold=3]
   * @property {float} [continuousRendering=false]
   * @property {RenderContext} [renderContext] - Context rendering
   * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
   * @property {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigation - navigation configuration
   */

  /**
   * @name PlanetContext
   * @class
   * Virtual globe where the camera is outside the globe.
   * When an error happens at the initialisation, a message is displayed
   * @augments AbstractContext
   * @param {Mizar.configuration} mizarConfiguration - mizar configuration
   * @param {AbstractContext.planetContext} options - planet context configuration
   * @constructor
   * @memberof module:Context
   */

  var PlanetContext = function (mizarConfiguration, options) {
    AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Planet, options);
    this.components = {
      posTrackerInfo: true,
      posTracker: true,
      elevTracker: true,
      compassDiv: true,
      timeTravelDiv: true
    };

    var planetOptions = _createPlanetConfiguration.call(this, options);

    this.initGlobe(planetOptions, {
      "3D": Constants.NAVIGATION.PlanetNavigation,
      "2D": Constants.NAVIGATION.FlatNavigation
    });
  };
  /**
   * Planet configuration data model
   * @typedef {Object} AbstractGlobe.dm_planet
   * @property {Object} canvas - canvas object
   * @property {int} tileErrorTreshold - tile error treshold
   * @property {boolean} continuousRendering - continuous rendering
   * @property {renderContext|null} renderContext - Rendering context
   * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
   * @property {string} shadersPath = "../../shaders/" - Shaders location
   * @property {boolean} lighting = false - Lighting
   * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
   * @property {int} minFar = 0
   * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
   * @property {boolean} renderTileWithoutTexture = true
   * @property {function} publishEvent - Callback
   */

  /**
   * Creates planet configuration
   * @param {Object} options
   * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
   * @param {boolean} [options.continuousRendering = false] - continuous rendering
   * @param {renderContext} [options.renderContext] - Rendering context
   * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet
   * @returns {AbstractGlobe.dm_planet} Planet data model.
   * @private
   */


  function _createPlanetConfiguration(options) {
    var self = this;
    return {
      tileErrorTreshold: options.tileErrorTreshold || 3,
      continuousRendering: options.continuousRendering || false,
      renderContext: options.renderContext,
      canvas: this.canvas,
      isMobile: options.isMobile || false,
      coordinateSystem: options.coordinateSystem,
      shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
      lighting: false,
      backgroundColor: [0.0, 0.0, 0.0, 1.0],
      minFar: 0,
      defaultColor: [200, 200, 200, 255],
      renderTileWithoutTexture: true,
      //todofl : redondance car params identiques
      publishEvent: function (message, object) {
        self.publish(message, object);
      }
    };
  }
  /**
   * Computes GeoCenter according to the coordinate reference system.
   * @param {Crs} crs - coordinate reference system
   * @returns {float[]} geocenter
   * @private
   */


  function _computeGeoCenter(crs) {
    var geoCenter;

    if (crs.isFlat()) {
      geoCenter = crs.getWorldFrom3D(this.navigation.center);
    } else {
      geoCenter = this.navigation.geoCenter;
    }

    return geoCenter;
  }
  /**
   * Propagates navigation options (inertia and mouse) when the coordinate reference system changes.
   * @param {AbstractNavigation.configuration} options - Navigation configuration
   * @private
   * @returns {Object} navigation options
   */


  function _propagateNavOptions(options) {
    var navOptions = {};
    navOptions.inertia = options.hasOwnProperty("inertia") ? options.inertia : false;

    if (options.hasOwnProperty("mouse")) {
      navOptions.mouse = options.mouse;
    }

    return navOptions;
  }
  /**
   * Updates the navigation according to the new coordinate reference system and the current settings
   * of the previous coordinate reference system
   * @param {Crs} newCrs -  the new coordinate reference system
   * @param {float[]} geoCenter - Current geo center of the camera in the previous coordinate reference system
   * @param {float} geoDistance - Distance from the globe's surface of the camera in the previous coordinate reference system
   * @param {Object} navOptions - Navigation's options
   * @param {boolean} [navOptions.inertia=false] - Inertia
   * @param {Object} [navOptions.mouse] - Mouse's configuration
   * @private
   */


  function _updateNavForNewCrs(newCrs, geoCenter, geoDistance, navOptions) {
    if (newCrs.isFlat()) {
      this.navigation = NavigationFactory.create(Constants.NAVIGATION.FlatNavigation, this, navOptions);
      this.navigation.center = newCrs.get3DFromWorld(geoCenter);
    } else {
      this.navigation = NavigationFactory.create(Constants.NAVIGATION.PlanetNavigation, this, navOptions);
      this.navigation.geoCenter = geoCenter;
    }

    this.navigation.distance = geoDistance * newCrs.getGeoide().getHeightScale();
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractContext, PlanetContext);
  /**************************************************************************************************************/

  /**
   * @function setBaseElevation
   * @memberof PlanetContext#
   * @throws {TypeError} The provided error is not a WCSElevation or a WMSElevation
   */

  PlanetContext.prototype.setBaseElevation = function (layer) {
    if (layer.getType() !== Constants.LAYER.WCSElevation && layer.getType() !== Constants.LAYER.WMSElevation) {
      throw new TypeError("PlanetContext.js: The provided layer ID=" + layer.getID() + " has a type +" + layer.getType() + " instead of WCSElevation or WMSElevation");
    }

    this.globe.setBaseElevation(layer);

    if (this.elevationTracker != null) {
      this.elevationTracker.setScaleLayer(layer);
    }
  };
  /**
   * @function setBaseElevationByID
   * @memberof PlanetContext#
   */


  PlanetContext.prototype.setBaseElevationByID = function (layerID) {
    // Find the layer by name among all the layers
    var layer = this.getLayerByID(layerID);

    if (layer) {
      this.setBaseElevation(layer);
    }

    return layer;
  };
  /**
   * @function getBaseElevation
   * @memberof PlanetContext#
   */


  PlanetContext.prototype.getBaseElevation = function () {
    return this.globe.getBaseElevation();
  };
  /**
   * @function setCoordinateSystem
   * @memberof PlanetContext#
   */


  PlanetContext.prototype.setCoordinateSystem = function (newCrs) {
    if (newCrs.getType() !== this.getMode()) {
      throw new RangeError("PlanetContext.js: incompatible coordinate reference system with Planet context");
    } // Change navigation


    var geoCenter;
    var geoDistance;
    var self = this;
    $__default['default'](self.canvas.parentElement).find("#loading").show(); // Compute current position and distance in order to set them in the new navigation related to the
    // new coordinate reference system

    geoCenter = _computeGeoCenter.call(this, this.globe.getCoordinateSystem());
    geoDistance = this.navigation.distance / this.globe.getCoordinateSystem().getGeoide().getHeightScale(); // Update the coordinate reference system

    this.globe.setCoordinateSystem(newCrs);
    this.navigation.stop(); // Creates the options for the new navigation related to the new coordinate reference system.
    // We only keep the inertia and the options for the mouse

    var navOptions = _propagateNavOptions.call(this, this.navigation.getOptions());

    try {
      // Create a new navigation related to the new coordinate reference system
      _updateNavForNewCrs.call(this, newCrs, geoCenter, geoDistance, navOptions);
    } catch (err) {
      this._showUpError(err);
    }

    if (this.positionTracker) {
      this.positionTracker.detach();
      this.positionTracker.attachTo(this);
    }

    if (this.elevationTracker) {
      this.elevationTracker.detach();
      this.elevationTracker.attachTo(this);
    }

    this.navigation.computeViewMatrix();
    this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * sky context configuration
   * @typedef {Object} AbstractContext.skyContext
   * @property {float} [tileErrorTreshold=1.5]
   * @property {float} [continuousRendering=true]
   * @property {float} [radius = 10.0] - Vector distance of the sky
   * @property {int} [minFar = 15]
   * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
   * @property {RenderContext} [renderContext] - Context rendering
   * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
   * @property {string} [compass="compassDiv"] - div element where compass is displayed
   * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
   */

  /**
   * @name SkyContext
   * @class
   * Virtual globe where the camera is inside the globe.<br/>
   * When an error happens at the initialisation, a message is displayed
   * @augments AbstractContext
   * @param {Mizar.configuration} mizarConfiguration - mizar configuration
   * @param {AbstractContext.skyContext} options - skyContext configuration
   * @constructor
   * @memberof module:Context
   */

  var SkyContext = function (mizarConfiguration, options) {
    AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Sky, options);
    this.components = {
      posTrackerInfo: true,
      posTracker: true,
      elevTracker: false,
      compassDiv: true,
      timeTravelDiv: true
    };

    var skyOptions = _createSkyConfiguration.call(this, options);

    this.initGlobe(skyOptions, {
      "3D": Constants.NAVIGATION.AstroNavigation
    });
  };
  /**
   * Planet configuration data model
   * @typedef {Object} AbstractGlobe.dm_sky
   * @property {Object} canvas - canvas object
   * @property {int} tileErrorTreshold - tile error treshold
   * @property {boolean} continuousRendering - continuous rendering
   * @property {renderContext} [renderContext] - Rendering context
   * @property {Crs} coordinateSystem - Coordinate reference system of the planet
   * @property {boolean} lighting = false - Lighting
   * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
   * @property {int} minFar
   * @property {float} radius
   * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
   * @property {string} shadersPath = "../../shaders/" - Shaders location
   * @property {boolean} renderTileWithoutTexture = false
   * @property {function} publishEvent - Callback
   */

  /**
   * Creates planet configuration
   * @param {Object} options
   * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
   * @param {boolean} [options.continuousRendering = true] - continuous rendering
   * @param {renderContext} [options.renderContext] - Rendering context
   * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet
   * @param {float} [options.radius = 10.0] - Radius object in vector length
   * @returns {AbstractGlobe.dm_sky} Planet data model.
   * @private
   */


  function _createSkyConfiguration(options) {
    var self = this;
    var skyOptions = {
      canvas: this.canvas,
      tileErrorTreshold: options.tileErrorTreshold || 1.5,
      continuousRendering: options.continuousRendering || true,
      renderTileWithoutTexture: false,
      radius: options.radius || 10.0,
      minFar: options.minFar || 15,
      // Fix problem with far buffer, with planet rendering
      coordinateSystem: options.coordinateSystem,
      lighting: false,
      backgroundColor: [0.0, 0.0, 0.0, 1.0],
      defaultColor: [200, 200, 200, 255],
      shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
      publishEvent: function (message, object) {
        self.publish(message, object);
      }
    };

    if (options.renderContext) {
      skyOptions.renderContext = options.renderContext;
    }

    return skyOptions;
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractContext, SkyContext);
  /**************************************************************************************************************/

  /**
   * @function setCoordinateSystem
   * @memberof SkyContext#
   * @throws ReferenceError - incompatible coordinate reference system with Sky context
   */

  SkyContext.prototype.setCoordinateSystem = function (cs) {
    if (cs.getType() !== this.getMode()) {
      throw new ReferenceError("incompatible coordinate reference system with Sky context", "SkyContex.js");
    }

    this.globe.setCoordinateSystem(cs);
    this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /**
   * ground context configuration
   * @typedef {Object} AbstractContext.groundContext
   * @property {float} [tileErrorTreshold=1.5]
   * @property {float} [continuousRendering=true]
   * @property {float} [radius = 10.0] - Vector distance of the sky
   * @property {int} [minFar = 15]
   * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
   * @property {RenderContext} [renderContext] - Context rendering
   * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
   * @property {string} [compass="compassDiv"] - div element where compass is displayed
   * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
   */

  /**
   * @name GroundContext
   * @class
   * Virtual globe where the camera is inside the globe and having the horizontal coordinate as .<br/>
   * When an error happens at the initialisation, a message is displayed
   * @augments AbstractContext
   * @param {Mizar.configuration} mizarConfiguration - mizar configuration
   * @param {AbstractContext.skyContext} options - skyContext configuration
   * @constructor
   * @memberof module:Context
   */

  var GroundContext = function (mizarConfiguration, options) {
    AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Ground, options);
    this.components = {
      posTrackerInfo: false,
      posTracker: false,
      elevTracker: false,
      compassDiv: false,
      timeTravelDiv: false
    };

    var groundOptions = _createGroundConfiguration.call(this, options);

    this.initGlobe(groundOptions, {
      "3D": Constants.NAVIGATION.GroundNavigation
    });
  };
  /**
   * Ground configuration data model
   * @typedef {Object} AbstractGlobe.dm_ground
   * @property {Object} canvas - canvas object
   * @property {int} tileErrorTreshold - tile error treshold
   * @property {boolean} continuousRendering - continuous rendering
   * @property {renderContext} [renderContext] - Rendering context
   * @property {Crs} coordinateSystem - Coordinate reference system of the planet
   * @property {boolean} lighting = false - Lighting
   * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
   * @property {int} minFar
   * @property {float} radius
   * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
   * @property {string} shadersPath = "../../shaders/" - Shaders location
   * @property {boolean} renderTileWithoutTexture = false
   * @property {function} publishEvent - Callback
   */

  /**
   * Creates planet configuration
   * @param {Object} options
   * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
   * @param {boolean} [options.continuousRendering = false] - continuous rendering
   * @param {renderContext} [options.renderContext] - Rendering context
   * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet' ground
   * @param {float} [options.radius = 10.0] - Radius object in vector length
   * @returns {AbstractGlobe.dm_ground} Ground data model.
   * @private
   */


  function _createGroundConfiguration(options) {
    var self = this;
    return {
      tileErrorTreshold: options.tileErrorTreshold || 3,
      continuousRendering: options.continuousRendering || false,
      renderContext: options.renderContext,
      canvas: this.canvas,
      coordinateSystem: options.coordinateSystem,
      shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
      lighting: false,
      backgroundColor: [0.0, 0.0, 0.0, 1.0],
      minFar: 0,
      defaultColor: [200, 200, 200, 255],
      renderTileWithoutTexture: true,
      publishEvent: function (message, object) {
        self.publish(message, object);
      }
    };
  }
  /**************************************************************************************************************/


  Utils.inherits(AbstractContext, GroundContext);
  /**************************************************************************************************************/

  /**
   * @function setCoordinateSystem
   * @memberof GroundContext#
   * @throws RangeError - "incompatible coordinate reference system with Sky context"
   */

  GroundContext.prototype.setCoordinateSystem = function (cs) {
    if (cs.getType() !== this.getMode()) {
      throw new RangeError("GroundContext.js: incompatible coordinate reference system with Sky context");
    }

    this.globe.setCoordinateSystem(cs);
    this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var ContextFactory = {
    /**
     * Factory to create a context.
     *
     * Creates a context based on :
     * <ul>
     *     <li>the context type {@link CONTEXT},</li>
     *     <li>the global Mizar's configuration,</li>
     *     <li>the options for the specific context</li>
     * </ul>
     * @param {CONTEXT} type - Type of animation.
     * @param {Object} configuration - see options.configuration for {@link Mizar}
     * @param {Object} options - See options.planetContext or options.skyContext configuration for {@link Mizar}
     * @return {Context} - the object to handle an animation
     * @throws {RangeError} Type not valid - a valid type is included in the list {@link CONTEXT}
     * @alias module:Context.ContextFactory.create
     *
     */
    create: function (type, configuration, options) {
      var obj;

      switch (type) {
        case Constants.CONTEXT.Planet:
          obj = new PlanetContext(configuration, options);
          break;

        case Constants.CONTEXT.Sky:
          obj = new SkyContext(configuration, options);
          break;

        case Constants.CONTEXT.Ground:
          obj = new GroundContext(configuration, options);
          break;

        default:
          throw new RangeError("ContextFactory.js: The type " + type + " is not allowed, A valid type is included in the list Constants.CONTEXT");
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**************************************************************************************************************/

  var namesFile;
  var catalogueFile;
  var constellations = {};
  var self$9;
  /**
   *    Extract information in "constellation" variables
   */

  function extractDatabase(mizarLayer) {
    var constellationNamesTab = namesFile.split("\n");
    var catalogueTab = catalogueFile.split("\n"); // For each constellation point

    for (var i = 0; i < catalogueTab.length; i++) {
      var word = catalogueTab[i].replace("  ", " ");
      word = word.split(" "); // word = "RA Decl Abbreviation "I"/"O"(Inerpolated/Original(Corner))"

      var RA = parseFloat(word[0]);
      var Decl = parseFloat(word[1]);
      var currentAbb = word[2];
      var IO = word[3]; // Convert hours to degrees

      RA *= 15; // If abbreviation doesn't exist

      if (!constellations[currentAbb]) {
        // Find constellation name
        for (var j = 0; j < constellationNamesTab.length; j++) {
          word = constellationNamesTab[j].split(";"); // word[0] = abbreviation, word[1] = name;

          var abb = word[0];

          if (abb === currentAbb) {
            var name = word[1]; // Add new constellation as a property

            constellations[currentAbb] = {
              coord: [],
              name: name,
              // Values used to calculate the position of the center of constellation
              x: 0.0,
              y: 0.0,
              z: 0.0,
              nbStars: 0
            };
            break;
          }
        }
      } // Convert to default coordinate system


      var posGeo = [RA, Decl]; // Calculate the center of constillation

      var pos3d = []; // Need to convert to 3D because of 0h -> 24h notation

      mizarLayer.globe.getCoordinateSystem().get3DFromWorldInCrs(posGeo, Constants.CRS.Equatorial, pos3d);
      constellations[currentAbb].x += pos3d[0];
      constellations[currentAbb].y += pos3d[1];
      constellations[currentAbb].z += pos3d[2];
      constellations[currentAbb].nbStars++;
      constellations[currentAbb].coord.push(posGeo);
    }
  }
  /*
   * 	Failure function
   */


  function failure() {
    ErrorDialog.open(Constants.LEVEL.ERROR, "Failed to load files");
  }
  /**
   * @name ConstellationProvider
   * @class
   *   ConstellationProvider context constructor
   * @param {object} options
   * @augments AbstractProvider
   * @constructor
   * @memberof module:Provider
   */


  var ConstellationProvider = function (options) {
    AbstractProvider.prototype.constructor.call(this, options);
    self$9 = this;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProvider, ConstellationProvider);
  /**************************************************************************************************************/

  /**
   * Asynchronous request to load constellation data
   * @function loadFiles
   * @memberof ConstellationProvider#
   * @param {Layer} layer - Mizar layer
   * @param {Object} configuration - Configuration options
   * @param {string} configuration.nameUrl - Url providing the constellations name data
   * @param {string} configuration.catalogueUrl - Url providing all information about each constellation
   * @see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
   */

  ConstellationProvider.prototype.loadFiles = function (layer, configuration) {
    var mizarLayer = layer;

    if (configuration.nameUrl && configuration.catalogueUrl) {
      // loadFiles( configuration.nameUrl, configuration.catalogueUrl );
      var nameRequest = {
        type: "GET",
        url: configuration.nameUrl,
        success: function (response) {
          namesFile = response;
        },
        error: function (xhr, ajaxOptions, thrownError) {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Failed to request " + configuration.nameUrl, xhr.responseText);
        }
      };
      var catalogueRequest = {
        type: "GET",
        url: configuration.catalogueUrl,
        success: function (response) {
          catalogueFile = response;
        },
        error: function (xhr, ajaxOptions, thrownError) {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Failed to request " + configuration.catalogueUr, xhr.responseText);
        }
      }; // Synchronizing two asynchronious requests with the same callback

      $__default['default'].when($__default['default'].ajax(nameRequest), $__default['default'].ajax(catalogueRequest)).then(function () {
        extractDatabase(mizarLayer);
        self$9.handleFeatures(mizarLayer);
      }, failure);
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Not valid options for ContellationProvider", "nameUrl and catalogueUrl attributes must be passed");
      return false;
    }
  };
  /**
   * @function handleFeatures
   * @memberof ConstellationProvider#
   */


  ConstellationProvider.prototype.handleFeatures = function (mizarLayer) {
    var constellationNamesFeatures = [];
    var constellationShapesFeatures = []; // Fill constellationShapes & constellationNames

    for (var i in constellations) {
      if (constellations.hasOwnProperty(i)) {
        var current = constellations[i]; // Close the polygon

        current.coord.push(current.coord[0]);
        var constellationShape = {
          geometry: {
            type: Constants.GEOMETRY.Polygon,
            gid: "constellationShape_" + current.name,
            coordinates: [current.coord],
            crs: {
              type: "name",
              properties: {
                name: Constants.CRS.Equatorial
              }
            }
          },
          properties: {
            name: current.name
          }
        };
        constellationShapesFeatures.push(constellationShape); // Compute mean value to show the constellation name in the center of constellation..
        // .. sometimes out of constellation's perimeter because of the awkward constellation's shape(ex. "Hydra" or "Draco" constellations)

        var geoPos = [];
        mizarLayer.globe.getCoordinateSystem().getWorldFrom3D([current.x / current.nbStars, current.y / current.nbStars, current.z / current.nbStars], geoPos);
        var constellationName = {
          geometry: {
            type: Constants.GEOMETRY.Point,
            gid: "constellationName_" + current.name,
            coordinates: [geoPos[0], geoPos[1]],
            crs: {
              type: "name",
              properties: {
                name: Constants.CRS.Equatorial
              }
            }
          },
          properties: {
            name: current.name,
            style: new FeatureStyle({
              textColor: "#083BA8",
              fillColor: [1.0, 1.0, 1.0, 1.0],
              label: current.name
            })
          }
        };
        constellationNamesFeatures.push(constellationName);
      }
    } // Create feature collections


    var constellationShapesFeatureCollection = {
      type: "FeatureCollection",
      features: constellationShapesFeatures
    };
    var constellationNameFeatureCollection = {
      type: "FeatureCollection",
      features: constellationNamesFeatures
    }; // Add shapes&names to the layer

    mizarLayer.addFeatureCollection(constellationShapesFeatureCollection);
    mizarLayer.addFeatureCollection(constellationNameFeatureCollection);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var namesFile$1;
  var catalogueFile$1;
  var self$a;
  /*
   * 	Failure function
   */

  function failure$1() {
    ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot load files in StarProvider");
  }
  /**
   * @name StarProvider
   * @class
   *    Specific star catalogue provider of the Brightest Stars (Ochsenbein+ 1988) from VizieR database
   * @param {object} options
   * @augments AbstractProvider
   * @constructor
   * @memberof module:Provider
   * @see Search Catalogue of the Brightest Stars (Ochsenbein+ 1988) in VizieR database for more details
   */


  var StarProvider = function (options) {
    AbstractProvider.prototype.constructor.call(this, options);
    self$a = this;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProvider, StarProvider);
  /**************************************************************************************************************/

  /**
   * Asynchronous requests to load star database
   * @function loadFiles
   * @memberof StarProvider.prototype
   * @param {Layer} mizarLayer - Mizar layer
   * @param {Object} configuration - Configuration options
   * @param {string} configuration.nameUrl - Url providing the stars name data
   * @param {string} configuration.catalogueUrl - Url providing all information about each star
   */

  StarProvider.prototype.loadFiles = function (mizarLayer, configuration) {
    if (configuration.nameUrl && configuration.catalogueUrl) {
      var nameRequest = {
        type: "GET",
        url: configuration.nameUrl,
        success: function (response) {
          namesFile$1 = response;
        },
        error: function (xhr, ajaxOptions, thrownError) {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + configuration.nameUrl, xhr.responseText);
        }
      };
      var catalogueRequest = {
        type: "GET",
        url: configuration.catalogueUrl,
        success: function (response) {
          catalogueFile$1 = response;
        },
        error: function (xhr, ajaxOptions, thrownError) {
          ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + configuration.catalogueUrl, xhr.responseText);
        }
      }; // Synchronizing two asynchronious requests with the same callback

      $__default['default'].proxy($__default['default'].when($__default['default'].ajax(nameRequest), $__default['default'].ajax(catalogueRequest)).then(function () {
        self$a.handleFeatures(mizarLayer);
      }, failure$1));
    } else {
      ErrorDialog.open(Constants.LEVEL.DEBUG, "Not valid options for StarProvider", "nameUrl and catalogueUrl attributes must be passed");
      return false;
    }
  };
  /**
   * @function handleFeatures
   * @memberof StarProvider#
   */


  StarProvider.prototype.handleFeatures = function (mizarLayer) {
    // Extract the table data
    var tmpTab = namesFile$1.slice(namesFile$1.indexOf("897;Acamar"), namesFile$1.indexOf("1231;Zaurak") + 11);
    var namesTab = tmpTab.split("\n");
    tmpTab = catalogueFile$1.slice(catalogueFile$1.indexOf("001."), catalogueFile$1.indexOf("4.98;K3Ibv") + 10);
    var catalogueTab = tmpTab.split("\n");
    var pois = []; // For each known star

    for (var i = 0; i < namesTab.length; i++) {
      var word = namesTab[i].split(";"); // word[0] = HR, word[1] = name;

      var HR = parseInt(word[0], 10);
      var starName = word[1]; // Search corresponding HR in catalogue

      for (var j = 0; j < catalogueTab.length; j++) {
        word = catalogueTab[j].split(";");

        if (parseInt(word[2], 10) === HR) {
          // Star found in the catalogue
          var raString = word[6]; // right ascension format : "hours minutes seconds"

          var declString = word[7]; // declinaton format : "degrees minutes seconds"

          var geo = [];
          mizarLayer.globe.getCoordinateSystem().getDecimalDegFromSexagesimal([raString, declString], geo); // Add poi layer

          var poi = {
            geometry: {
              type: Constants.GEOMETRY.Point,
              gid: "star_" + starName,
              coordinates: [geo[0], geo[1]],
              crs: {
                type: "name",
                properties: {
                  name: Constants.CRS.Equatorial
                }
              }
            },
            properties: {
              name: starName,
              style: new FeatureStyle({
                label: starName,
                fillColor: [1.0, 1.0, 1.0, 1.0]
              })
            }
          };
          pois.push(poi);
        }
      }
    } // Create feature collection


    var poiFeatureCollection = {
      type: "FeatureCollection",
      features: pois
    };
    mizarLayer.addFeatureCollection(poiFeatureCollection);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  const DEFAULT_STROKE_COLOR = [1.0, 1.0, 1.0, 1.0];
  var self$b;
  var featureCollection;
  /**
   * @name CraterProvider
   * @class
   *   Displays the name of the crater
   * @param {object} options
   * @augments AbstractProvider
   * @constructor
   * @memberof module:Provider
   */

  var CraterProvider = function (options) {
    AbstractProvider.prototype.constructor.call(this, options);
    self$b = this;
  };
  /*******************************************************************************/


  Utils.inherits(AbstractProvider, CraterProvider);
  /*******************************************************************************/

  /**
   * @function loadFiles
   * @param {Layer} layer - mizar Layer
   * @param {Object} configuration - configuration
   * @param {string} configuration.url - URL of the GeoJSON file
   * @memberof CraterProvider#
   */

  CraterProvider.prototype.loadFiles = function (layer, configuration) {
    Utils.requestUrl(configuration.url, "text", "text/plain", null, function (response) {
      if (typeof response === "string") {
        featureCollection = JSON.parse(response);
      } else {
        featureCollection = response;
      }

      self$b.handleFeatures(layer);
    }, function (err) {
      ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + configuration.url, err);
    });
  };
  /**
   * @function handleFeatures
   * @memberof CraterProvider#
   */


  CraterProvider.prototype.handleFeatures = function (layer) {
    var crs = featureCollection.crs;
    var features = featureCollection.features;
    var ptMaxSize = layer.options.pointMaxSize ? layer.options.pointMaxSize : 20;
    var strokeColor = layer.getStyle().getStrokeColor() ? layer.getStyle().getStrokeColor() : DEFAULT_STROKE_COLOR;

    for (var i = 0; i < features.length; i++) {
      var currentFeature = features[i];
      currentFeature.geometry.crs = crs;
      var craterName = currentFeature.properties.name;
      currentFeature.properties.style = new FeatureStyle({
        label: craterName,
        strokeColor: strokeColor,
        pointMaxSize: ptMaxSize
      });
    }

    layer.addFeatureCollection(featureCollection);
  };

  /*******************************************************************************
   * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var self$c;
  var interval$1;
  var poiFeatureCollection$1;
  var url;
  var data;
  /**
   * Parses the files
   * @param {string} response  response
   * @returns {Object} the points of the trafectory
   */

  function _parseFile(response) {
    var pois = [];
    var lines = response.split("\n");

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i]; // skip comments

      if (line.startsWith("#")) {
        continue;
      }

      var data = line.split(",");

      if (data.length > 1) {
        var long = parseFloat(data[0]);
        var lat = parseFloat(data[1]);
        var date = data[2];
        pois.push([long, lat, date]);
      }
    }

    return pois;
  }
  /**
   * Ceates lines from the set of points
   * @param {Object} pois pois
   * @returns {string} the geometry
   */


  function _createLines(pois) {
    var geom = [];

    for (var j = 1; j < pois.length; j++) {
      var line = [];
      line.push(pois[j - 1]);
      line.push(pois[j]);
      geom.push(line);
    }

    return geom;
  }
  /**
   * ExtractDates from the set of points
   * @param {Object} Set of points
   * @returns Object range date as [date min, date max]
   */


  function _extractDates(pois) {
    var dateMin = pois[0][2];
    var dateMax = pois[pois.length - 1][2];
    return [dateMin, dateMax];
  }
  /**
   * Computes the trajectory.
   * @param {Layer} mizarLayer
   */


  var computePositions$1 = function (mizarLayer) {
    Utils.requestUrl(url, "text", "plain/text", null, function (response) {
      var pois = _parseFile(response);

      var geom = _createLines(pois);

      var dates = _extractDates(pois);

      var style = new FeatureStyle({
        iconUrl: "css/images/lander.png",
        strokeColor: FeatureStyle.fromStringToColor("white"),
        fillColor: FeatureStyle.fromStringToColor("white")
      });
      var trajectory = createTrajectory(mizarLayer, Constants.GEOMETRY.MultiLineString, mizarLayer.name, {
        trajectory: geom,
        color: "white",
        dates: dates
      }); // Create feature collection

      poiFeatureCollection$1 = {
        type: "FeatureCollection",
        crs: {
          type: "name",
          properties: {
            name: "IAU2000:30101"
          }
        },
        features: [trajectory, {
          type: "Feature",
          properties: {
            title: "Landing site",
            style: style,
            thumbnail: "http://space.skyrocket.de/img_sat/team-indus__1.jpg",
            abstract: 'The <a href="http://www.teamindus.in/mission/" class="selectValue">Team Indus Lunar Lander</a> is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).<p>The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP. <p>The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters. <p>Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earth’s orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/s—almost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecraft’s fuel.The landing phase of the mission will be initiated at a 100 km × 100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on Mare Imbrium, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown.The Team Indus Lunar Lander is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP.The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters.Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earth’s orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/s—almost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecraft’s fuel.The landing phase of the mission will be initiated at a 100 km × 100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on <a href="https://en.wikipedia.org/wiki/Mare_Imbrium" class="selectValue">Mare Imbrium</a>, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown.'
          },
          geometry: {
            type: "Point",
            coordinates: [-25.680079147, 29.5212266285]
          }
        }]
      };
      mizarLayer.addFeatureCollection(poiFeatureCollection$1);
    }, function (err) {
      ErrorDialog.open(Constants.LEVEL.ERROR, "Failed ot request " + url, err);
    });
  };
  /*
   * Json template for a point
   * @param
   */


  function createTrajectory(mizarLayer, type, name, obj) {
    function _computeDistance(trajectory) {
      var distance = 0;
      var line = trajectory[0];

      for (var i = 1; i < trajectory.length; i++) {
        var lineNext = trajectory[i];
        distance += MeasureToolPlanetCore.calculateDistanceElevation(line[0], lineNext[0]);
        line = lineNext;
      }

      return distance * 1000;
    }

    return {
      type: "Feature",
      geometry: {
        type: Constants.GEOMETRY.MultiLineString,
        gid: "trajectory" + type + "_" + name,
        coordinates: obj.trajectory
      },
      properties: {
        title: name,
        thumbnail: data.thumbnailPath,
        abstract: data.abstractPath,
        startDate: obj.dates[0],
        endDate: obj.dates[1],
        distance: _computeDistance(obj.trajectory).toFixed() + " meters"
      }
    };
  }
  /**
   * @name TrajectoryProvider
   * @class
   *    Create a trajectory, which can be refreshed
   * @param {object} options
   * @augments AbstractProvider
   * @constructor
   * @memberof module:Provider
   */


  var TrajectoryProvider = function (options) {
    AbstractProvider.prototype.constructor.call(this, options);
    self$c = this;
  };
  /**************************************************************************************************************/


  Utils.inherits(AbstractProvider, TrajectoryProvider);
  /**************************************************************************************************************/

  /**
   * Asynchronous requests to reload trajectory at some time interval
   * @function loadFiles
   * @memberof TrajectoryProvider#
   * @param {Layer} mizarLayer - Mizar layer
   * @param {Object} configuration - Configuration options
   * @param {string} configuration.url - Url providing the trajectory
   * @param {string} configuration.interval - time in ms where the trajectory is reloaded
   */

  TrajectoryProvider.prototype.loadFiles = function (layer, configuration) {
    data = configuration;
    interval$1 = configuration.interval ? configuration.interval : 60000;
    url = configuration.url;
    self$c.handleFeatures(layer);
  };
  /**
   * @function handleFeatures
   * @memberof TrajectoryProvider#
   */


  TrajectoryProvider.prototype.handleFeatures = function (layer) {
    computePositions$1(layer);
    setInterval(function () {
      layer.removeFeatureCollection(poiFeatureCollection$1);
      computePositions$1(layer);
    }, interval$1);
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  var ProviderFactory = {
    /**
     * Factory to create a provider.
     *
     * Creates a provider based on :
     * <ul>
     *     <li>the provider type {@link PROVIDER},</li>
     *     <li>the options for the specific provider</li>
     * </ul>
     *
     * Severals providers can be created :
     * <ul>
     *     <li>{@link module:Provider.ConstellationProvider ConstellationProvider}</li>
     *     <li>{@link module:Provider.CraterProvider CraterProvider}</li>
     *     <li>{@link module:Provider.PlanetProvider PlanetProvider}</li>
     *     <li>{@link module:Provider.StarProvider StarProvider}</li>
     *     <li>{@link module:Provider.TrajectoryProvider TrajectoryProvider}</li>
     * </ul>
     * @param {PROVIDER} type - Type of provider.
     * @param {Object} options - See the options for each animation for further information
     * @return {Provider} - the interface to handle an animation
     * @throws {RangeError} Type not valid - a valid type is included in the list {@link PROVIDER}
     * @alias module:Provider.ProviderFactory.create
     * @see {@link module:Provider.ConstellationProvider ConstellationProvider} Loads constellations
     * @see {@link module:Provider.CraterProvider CraterProvider} Loads Craters
     * @see {@link module:Provider.PlanetProvider PlanetProvider} Loads planets position
     * @see {@link module:Provider.TrajectoryProvider TrajectoryProvider} Loads trajectory
     *
     */
    create: function (type, options) {
      var obj;

      switch (type) {
        case Constants.PROVIDER.Constellation:
          obj = new ConstellationProvider(options);
          break;

        case Constants.PROVIDER.Crater:
          obj = new CraterProvider(options);
          break;

        case Constants.PROVIDER.Planet:
          obj = new PlanetProvider(options);
          break;

        case Constants.PROVIDER.Star:
          obj = new StarProvider(options);
          break;

        case Constants.PROVIDER.Trajectory:
          obj = new TrajectoryProvider(options);
          break;

        default:
          throw new RangeError("ProviderFactory.js: unable to create the provider " + type);
      }

      return obj;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/

  /***************************************
   * Copyright 2011, 2012 GlobWeb contributors.
   *
   * This file is part of GlobWeb.
   *
   * GlobWeb is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License as published by
   * the Free Software Foundation, version 3 of the License, or
   * (at your option) any later version.
   *
   * GlobWeb is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
   ***************************************/

  /**
   @name Stats
   @class
       Display some rendering statistics in a HTML element
   @param {Context} Context
   @param {Object} options - Configuration properties for Stats.
   @param {Object} [options.element] - the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself
   @param {boolean] {[options.verbose=false] - the verbosity of the stats, default is false
   @constructor
  */
  var Stats = function (context, options) {
    this.type = null;
    context.getRenderContext().stats = this; //context.globe.renderContext.stats = this;

    this.context = context;
    var elt = options ? options.element : undefined;

    if (elt) {
      if (typeof elt === "string") {
        this.element = document.getElementById(elt);
        this.type = "dom";
      } else {
        this.element = elt;
        this.type = "jquery";
      }
    }

    this.showFPS = this.context.globe.continuousRendering;
    this.verbose = options && options.verbose ? options.verbose : false;
    this.numFrames = 0;
    var self = this;
    window.setInterval(function () {
      self.print();
    }, 1000);
  };
  /**************************************************************************************************************/

  /**
   Start measuring time
   */


  Stats.prototype.start = function (name) {
    this[name] = Date.now();
  };
  /**************************************************************************************************************/

  /**
   End measuring time
   */


  Stats.prototype.end = function (name) {
    var time = Date.now() - this[name];
    var max = this["max_" + name] || -1;

    if (max < time) {
      max = time;
    }

    var sum = this["sum_" + name] || 0;
    sum += time;
    this[name] = time;
    this["max_" + name] = max;
    this["sum_" + name] = sum;

    if (name === "globalRenderTime") {
      this.numFrames++;
    }
  };
  /**************************************************************************************************************/

  /**
   Print stats in an HTML element
   */


  Stats.prototype.print = function () {
    if (this.numFrames > 0) {
      var content = "";

      if (this.showFPS) {
        content += "FPS : " + this.numFrames + "<br>";
      }

      content += "Average render time : " + (this.sum_globalRenderTime / this.numFrames).toFixed(2) + " ms"; // FIXME: currently count stats for the first renderer in render context

      /*if (this.context.globe.renderContext.renderers[0].getRenderStats) {
              content += "<br>" + this.renderContext.renderers[0].getRenderStats();
          }
          */

      if (this.verbose) {
        content += "<br>Average traverse tiles time : " + (this.sum_traverseTime / this.numFrames).toFixed(2) + " ms";
        content += "<br>Average render tiles time : " + (this.sum_renderTime / this.numFrames).toFixed(2) + " ms";
        content += "<br>Average generate tiles time : " + (this.sum_generateTime / this.numFrames).toFixed(2) + " ms";
        content += "<br>Average request tiles time : " + (this.sum_requestTime / this.numFrames).toFixed(2) + " ms";
        content += "<br>Max render time : " + this.max_globalRenderTime + " ms";
        content += "<br>Max traverse tiles time : " + this.max_traverseTime + " ms";
        content += "<br>Max render tiles time : " + this.max_renderTime + " ms";
        content += "<br>Max generate tiles time : " + this.max_generateTime + " ms";
        content += "<br>Max request tiles time : " + this.max_requestTime + " ms";
      }

      if (this.element) {
        if (this.type === "dom") {
          this.element.innerHTML = content;
        } else if (this.type === "jquery") {
          this.element.html(content);
        }
      }

      this.sum_globalRenderTime = 0;
      this.sum_traverseTime = 0;
      this.sum_renderTime = 0;
      this.sum_generateTime = 0;
      this.sum_requestTime = 0;
      this.max_globalRenderTime = 0;
      this.max_traverseTime = 0;
      this.max_renderTime = 0;
      this.max_generateTime = 0;
      this.max_requestTime = 0;
      this.numFrames = 0;
    }
  };

  /*******************************************************************************
   * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
   *
   * This file is part of MIZAR.
   *
   * MIZAR is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MIZAR is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
   ******************************************************************************/
  /**
   * mizarMode:toggle.<br/>
   * Called when Mizar switches from a context to another context
   * @event Mizar#mizarMode:toggle
   * @type {Context}
   */

  /**
   * API version
   * @constant
   * @type {string}
   */

  const API_VERSION = Constants.API.version;
  /**
   * Angle from pole to camera
   * @constant
   * @type {number}
   */

  const ANGLE_CAMERA_POLE = 30.0;
  /**
   * @constant
   * @type {string}
   */

  const MIZAR_NAME_PROD = "mizar.min";
  /**
   * @constant
   * @type {string}
   */

  const MIZAR_NAME_DEV = "mizar.";
  /**
   *  Mizar input parameters
   * @typedef {Object} Mizar_inputParameters
   * @property {Object|string} canvas - canvas ID or canvas element in which Mizar is running
   * @property {Mizar_inputConfiguration} [configuration] - Mizar global configuration
   * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
   * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
   * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
   */

  /**
   * Mizar configuration
   * @typedef {Object} Mizar_inputConfiguration
   * @property {string} [mizarBaseUrl] - Used to access to MizarWidget resources
   * @property {boolean} [debug = false] - Debug mode
   * @property {boolean} [isMobile = false] - Mobile support
   * @property {AbstractTracker_position_configuration} [positionTracker] - Position tracker configuration
   * @property {AbstractTracker_elevation_configuration} [elevationTracker] - Elevation tracker configuration
   * @property {TimeTravel_position_configuration} [timeTravel] - Time travel GUI
   * @property {Object} [registry] - Hips service registry
   * @property {string} registry.hips - Hips Registry
   * @property {boolean} [proxyUse=false] - Uses a proxy to send request
   * @property {string} [proxyUrl] - Proxy URL to use when proxyUse is true. This is used to avoid CORS errors.
   */

  /**
   * Time travel configuration
   * @typedef {Object} TimeTravel_position_configuration
   * @property {string} [element = timeTravelDiv] - tracker div element
   */

  /**
   * Position tracker configuration
   * @typedef {Object} AbstractTracker_position_configuration
   * @property {string} [element = posTracker] - tracker div element
   * @property {string}  [position = bottom] - tracker position in the GUI
   */

  /**
   * Elevation tracker configuration
   * @typedef {Object} AbstractTracker_elevation_configuration
   * @property {string} [element = elevTracker] - tracker div element
   * @property {string}  [position = bottom] - tracker position in the GUI
   * @property {Layer} [elevationLayer] - elevationLayer
   */

  /**
   * Mizar configuration
   * @typedef {Mizar_inputConfiguration} Mizar.configuration
   * @property {string} mizarAPIUrl - URL of this script, used to reference shaders and CSS of Mizar API
   */

  /**
   * Mizar parameters
   * @typedef {Object} Mizar_parameters
   * @property {Object|string} canvas - canvas ID or canvas element
   * @property {Mizar.configuration} [configuration] - Mizar global configuration
   * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
   * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
   * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
   */

  /**
   * @name Mizar
   * @class
   * Creates an instance of the Mizar API.
   * @param {Mizar_inputParameters} options - Configuration for Mizar
   * @throws {ReferenceError} No option found
   * @throws {TypeError} Canvas not defined
   * @constructor
   */

  var Mizar = function (options) {
    Event.prototype.constructor.call(this);

    _checkConfiguration(options);

    this.options = _createConfiguration(options);
    ErrorDialog.setDebug(this.options.configuration.debug ? this.options.configuration.debug : false); // Init all factories

    /**
     * Creates a {@link module:Context.ContextFactory Context}
     * @name ContextFactory
     * @memberof Mizar#
     */

    this.ContextFactory = ContextFactory;
    /**
     * Creates a {@link module:Layer.LayerFactory Layer}
     * @name LayerFactory
     * @memberof Mizar#
     */

    this.LayerFactory = LayerFactory; // Proxy settings

    const proxyUse = this.options.configuration.proxyUse || false;
    Proxy.setProxyUse(proxyUse);

    if (proxyUse) {
      Proxy.setProxyUrl(this.options.configuration.proxyUrl);
    }
    /**
     * Creates an {@link module:Animation.AnimationFactory animation}
     * @name AnimationFactory
     */


    this.AnimationFactory = AnimationFactory;
    /**
     * Creates a {@link module:Services.ServiceFactory service}
     * @name ServiceFactory
     */

    this.ServiceFactory = ServiceFactory;
    /**
     * Creates an {@link module:Utils.UtilityFactory utility}
     * @name UtilityFactory
     * @memberof Mizar#
     */

    this.UtilityFactory = UtilityFactory;
    /**
     * Creates a {@link module:Provider.ProviderFactory provider}
     * @name ProviderFactory
     * @memberof Mizar#
     */

    this.ProviderFactory = ProviderFactory;
    /**
     * Access to time.
     * @name TimeUtility
     * @memberof Mizar#
     */

    this.TimeUtility = Time;
    this.errorDialog = ErrorDialog;
    this.skyContext = null;
    this.planetContext = null;
    this.groundContext = null;
    this.activatedContext = null;
    this.renderContext = null;
    this.dataProviders = {};

    if (options.skyContext) {
      options.skyContext.isMobile = options.isMobile;
      this.createContext(Mizar.CONTEXT.Sky, options.skyContext);
      this.setActivatedContext(Mizar.CONTEXT.Sky);
    }

    if (options.planetContext) {
      options.planetContext.isMobile = options.isMobile;
      this.createContext(Mizar.CONTEXT.Planet, options.planetContext);
      this.setActivatedContext(Mizar.CONTEXT.Planet);
    }

    if (options.groundContext) {
      options.groundContext.isMobile = options.isMobile;
      this.createContext(Mizar.CONTEXT.Ground, options.groundContext);
      this.setActivatedContext(Mizar.CONTEXT.Ground);
    }
  };
  /**********************************************************************************************************
   *                                      Static variables
   **********************************************************************************************************/

  /**
   * API {@link VERSION version}
   * [SemVer]{@link http://semver.org/} concept is used for versioning
   * @name VERSION
   * @memberof Mizar#
   */


  Mizar.VERSION = API_VERSION;
  /**
   * List of supported values for {@link ANIMATION animation}*
   * @name ANIMATION
   * @memberof Mizar#
   * @see {@link module:Animation animation package} for further information.
   */

  Mizar.ANIMATION = Constants.ANIMATION;
  /**
   * List of supported values for {@link LAYER layer}
   * @name LAYER
   * @memberof Mizar#
   * @see {@link module:Layer layer package} for further information.
   */

  Mizar.LAYER = Constants.LAYER;
  /**
   * List of supported values for {@link INFORMATION_TYPE information}
   * @name INFORMATION_TYPE
   * @memberof Mizar#
   */

  Mizar.INFORMATION_TYPE = Constants.INFORMATION_TYPE;
  /**
   * List of supported values for {@link GEOMETRY geometry}
   * @name GEOMETRY
   * @memberof Mizar#
   */

  Mizar.GEOMETRY = Constants.GEOMETRY;
  /**
   * List of supported values for {@link NAVIGATION navigation}
   * @name NAVIGATION
   * @memberof Mizar#
   * @see {@link module:Navigation navigation package} for further information.
   */

  Mizar.NAVIGATION = Constants.NAVIGATION;
  /**
   * List of supported values for {@link CONTEXT context}
   * @name CONTEXT
   * @memberof Mizar#
   * @see {@link module:Context context package} for further information.
   */

  Mizar.CONTEXT = Constants.CONTEXT;
  /**
   * List of supported values for {@link PROJECTION projection}
   * @name PROJECTION
   * @memberof Mizar#
   * @see {@link module:Projection projection package} for further information.
   */

  Mizar.PROJECTION = Constants.PROJECTION;
  /**
   * List of supported values for {@link CRS coordinate reference system}
   * @name CRS
   * @memberof Mizar#
   * @see {@link module:Crs coordinate system package} for further information.
   */

  Mizar.CRS = Constants.CRS;
  /**
   * List of supported values for {@link CRS_TO_CONTEXT crs/context mapping}
   * @name CRS_TO_CONTEXT
   * @memberof Mizar#
   */

  Mizar.CRS_TO_CONTEXT = Constants.CRS_TO_CONTEXT;
  /**
   * List of supported values {@link DISPLAY display}
   * @name DISPLAY
   * @memberof Mizar#
   */

  Mizar.DISPLAY = Constants.DISPLAY;
  /**
   * List of supported values for {@link SERVICE service}
   * @name SERVICE
   * @memberof Mizar#
   */

  Mizar.SERVICE = Constants.SERVICE;
  /**
   * List of supported values for {@link UTILITY utility}
   * @name UTILITY
   * @memberof Mizar#
   */

  Mizar.UTILITY = Constants.UTILITY;
  /**
   * List of supported values for {@link PROVIDER provider}
   * @name PROVIDER
   * @memberof Mizar#
   * @see {@link module:Provider provider package} for further information.
   */

  Mizar.PROVIDER = Constants.PROVIDER;
  /**
   * List of supported values for {@link EVENT_MSG event}
   * @name EVENT_MSG
   * @memberof Mizar#
   */

  Mizar.EVENT_MSG = Constants.EVENT_MSG;
  /**
   * List of supported valaues for {@link TIME_STEP time step}
   * @name TIME_STEP
   * @memberof Mizar#
   */

  Mizar.TIME_STEP = Constants.TIME_STEP;
  /**
   * List of supported valaues for {@link LEVEL level}
   * @name LEVEL
   * @memberof Mizar#
   */

  Mizar.LEVEL = Constants.LEVEL;
  /**********************************************************************************************************
   *                                      Private methods
   **********************************************************************************************************/

  /**
   * Returns the script object that contains the URL of this script
   * @param {Object[]} scripts - All the scripts from the document where Mizar is imported
   * @param {MIZAR_NAME_PROD|MIZAR_NAME_DEV} scriptName - production or dev script name
   * @param {int} index - Number of range '/' to remove from the end of the URL
   * @private
   */

  function _extractURLFrom(scripts, scriptName, index) {
    let mizarSrc = _$1.find(scripts, function (script) {
      return script.src.indexOf(scriptName) !== -1;
    });

    if (mizarSrc) {
      mizarSrc = mizarSrc.src.split("/").slice(0, index).join("/") + "/";
    }

    return mizarSrc;
  }
  /**
   * Return the base URL of this script.
   * @returns {string} the base URL or an empty string
   * @private
   */


  function _getMizarAPIBaseURL() {
    const scripts = document.getElementsByTagName("script");
    return _extractURLFrom.call(this, scripts, MIZAR_NAME_PROD, -1) || _extractURLFrom.call(this, scripts, MIZAR_NAME_DEV, -2) || "";
  }
  /**
   * Checks inputs
   * @param {Object} options - Mizar configuration
   * @throws {ReferenceError} No option found
   * @throws {TypeError} Canvas not defined
   * @function _checkConfiguration
   * @memberof Mizar#
   * @private
   */


  function _checkConfiguration(options) {
    if (typeof options === "undefined") {
      throw new ReferenceError("No option found", "Mizar.js");
    } else if (typeof options.canvas === "undefined") {
      throw new TypeError("main.js: Canvas not defined");
    } else ;
  }
  /**
   * Checks inputs from user and creates the mizar configuration
   * @param {Mizar.inputParameters} options inputs from user
   * @returns {Mizar_parameters} mizar configuration.
   * @function _createConfiguration
   * @memberof Mizar#
   * @private
   */


  function _createConfiguration(options) {
    const mizarAPIUrl = _getMizarAPIBaseURL();

    console.info("Mizar base URL:", mizarAPIUrl);
    const mizarOptions = {
      canvas: typeof options.canvas === "string" ? document.getElementById(options.canvas) : options.canvas
    };

    if (options.hasOwnProperty("configuration")) {
      mizarOptions.configuration = options.configuration;
    } else {
      mizarOptions.configuration = {};
    }

    mizarOptions.configuration.mizarAPIUrl = mizarAPIUrl;

    if (options.hasOwnProperty("skyContext")) {
      mizarOptions.skyContext = options.skyContext;
    }

    if (options.hasOwnProperty("planetContext")) {
      mizarOptions.planetContext = options.planetContext;
    }

    if (options.hasOwnProperty("groundContext")) {
      mizarOptions.groundContext = options.groundContext;
    }

    return mizarOptions;
  }
  /**
   * Switch to a context
   * @param {AbstractContext} context - Target context
   * @param {Object} [options] - options management for the source context
   * @param {boolean} [options.mustBeDestroyed=false] - options management for the source context : destroy it
   * @param {boolean} [options.mustBeHidden=false] - options management for the source context : hidden it
   * @function _switchToContext
   * @memberof Mizar#
   * @private
   * @fires Mizar#mizarMode:toggle
   */


  function _switchToContext(context, options) {
    if (context.globe) {
      context.globe.isEnable = false;
    }

    const self = this;
    const mustBeDestroyed = options.hasOwnProperty("mustBeDestroyed") ? options.mustBeDestroyed : false;
    const mustBeHidden = options.hasOwnProperty("mustBeHidden") ? options.mustBeHidden : false; // Hide sky

    this.getActivatedContext().hide(); // Hide all additional layers

    this.getActivatedContext().hideAdditionalLayers();
    let viewMatrix;
    let fov;

    if (context.hasOwnProperty("_oldVM") && context.hasOwnProperty("_oldFov")) {
      viewMatrix = context._oldVM;
      fov = context._oldFov;
    } else if (context.getNavigation().inverseViewMatrix === undefined) {
      this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
      this.getActivatedContext()._oldFov = this.renderContext.getFov();
      viewMatrix = context.getNavigation().getRenderContext().getViewMatrix();
      fov = 90;
    } else {
      this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
      this.getActivatedContext()._oldFov = this.renderContext.getFov();
      viewMatrix = mat4.create();
      context.getNavigation().computeInverseViewMatrix();
      mat4.inverse(context.getNavigation().inverseViewMatrix, viewMatrix);
      fov = 90;
    }

    if (mustBeDestroyed) {
      this.getActivatedContext().destroy();
    } else if (mustBeHidden) {
      this.getActivatedContext().disable();
    } else ;

    this.activatedContext = context;

    if (!context.getNavigation().getRenderContext().cameraUpdateFunction) {
      context.getNavigation().getRenderContext().cameraUpdateFunction = context.getNavigation().update.bind(context.getNavigation());
    }

    context.getNavigation().toViewMatrix(viewMatrix, fov, 2000, function () {
      context.enable();

      if (context.globe) {
        context.globe.isEnable = true;
      }

      if (options && options.callback) {
        options.callback.call(self);
      }

      context.showAdditionalLayers();
      self.getActivatedContext().show();
      self.publish(Constants.EVENT_MSG.MIZAR_MODE_TOGGLE, context);
      self.getActivatedContext().refresh();

      if (self.getRenderContext().viewMatrix[0] !== "undefined") {
        self.getActivatedContext().getNavigation().computeViewMatrix();
      }
    });
  }
  /**
   * Saves the atmosphere state and disable it when 2D is used
   * @function _disableAtmosphere
   * @memberof Mizar#
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   * @private
   */


  function _disableAtmosphere() {
    if (this.getActivatedContext()._atmosphereLayer !== undefined) {
      if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
        this.getActivatedContext()._saveAtmosphereVisible = this.getActivatedContext()._atmosphereLayer.visible;

        this.getActivatedContext()._atmosphereLayer.setVisible(false);

        this.render();
      }
    }
  }
  /**
   * Retrieves the atmosphere and enable it when 3D is used
   * @function _enableAtmosphere
   * @memberof Mizar#
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   * @private
   */


  function _enableAtmosphere() {
    if (this.getActivatedContext()._atmosphereLayer !== undefined) {
      if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
        this.getActivatedContext()._atmosphereLayer.setVisible(this.getActivatedContext()._saveAtmosphereVisible);

        this.render();
      }
    }
  }
  /**
   * Switch 2D to 3D.
   * @function _switch2Dto3D
   * @memberof Mizar#
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   * @private
   */


  function _switch2Dto3D() {
    _enableAtmosphere.call(this); // Enable skyContext behind the planet


    if (this.skyContext) {
      this.skyContext.enable();
    }

    this.setCrs({
      geoideName: this.getCrs().getGeoideName()
    }); // Check zoom level

    this.planetContext.navigation.zoom(0);
  }
  /**
   * Switch 3D to 2D.
   * @function _switch3Dto2D
   * @memberof Mizar#
   * @private
   */


  function _switch3Dto2D() {
    _disableAtmosphere.call(this); // Disable skyContext


    if (this.skyContext) {
      this.skyContext.disable();
    } // If a pole is closed to the center of the canvas, this should mean that
    // the user is interested to the pole, so we switch to azimuth projection
    // instead of plate carrée projection


    _project2AzimuthOrPlate.call(this, this.getActivatedContext().navigation.getCenter());
  }
  /**
   * Selects the right projection according to the target of the camera.<br/>
   * When the angle of the target of the camera with a pole (north or south)
   * is inferior to ANGLE_CAMERA_POLE, then the azimuthal projection is selected
   * otherwise plate carrée is selected
   * @param {float[]} lookAt - target of the camera [longitude, latitude] in decimal degree
   * @function _project2AzimuthOrPlate
   * @memberof Mizar#
   * @private
   */


  function _project2AzimuthOrPlate(lookAt) {
    if (lookAt !== null && 90 - Math.abs(lookAt[1]) <= ANGLE_CAMERA_POLE) {
      this.setCrs({
        geoideName: this.getCrs().getGeoideName(),
        projectionName: Mizar.PROJECTION.Azimuth,
        pole: Math.sign(lookAt[1]) > 0 ? "north" : "south"
      });
    } else {
      this.setCrs({
        geoideName: this.getCrs().getGeoideName(),
        projectionName: Mizar.PROJECTION.Plate
      });
    }
  }
  /**
   * Skip if sky mode
   * @function _skipIfSkyMode
   * @memberof Mizar#
   * @throws {RangeError} Toggle Dimension is not implemented for Sky
   * @private
   */


  function _skipIfSkyMode() {
    if (this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky) {
      throw new RangeError("main.js: Toggle Dimension is not implemented for Sky");
    }
  }
  /**
   * Get service url from HIPS Layer
   * @function _getHipsServiceUrlArray
   * @memberof Mizar#
   * @param hipsLayer
   * @returns {Array}
   * @private
   */


  function _getHipsServiceUrlArray(hipsLayer) {
    const hipsServiceUrlArray = [];

    if (hipsLayer.hips_service_url) {
      hipsServiceUrlArray.push(hipsLayer.hips_service_url);
    }

    if (hipsLayer.hips_service_url_1) {
      hipsServiceUrlArray.push(hipsLayer.hips_service_url_1);
    }

    if (hipsLayer.hips_service_url_2) {
      hipsServiceUrlArray.push(hipsLayer.hips_service_url_2);
    }

    return hipsServiceUrlArray;
  }
  /**
   * Loads HIPS layers from passed service url
   * @function _checkHipsServiceIsAvailable
   * @memberof Mizar#
   * @param {Array} hipsServiceUrlArray - HIPS service URL
   * @param {serviceRegistryCallback} callback - The callback that handles the response
   * @private
   */


  function _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback) {
    if (hipsServiceUrlArray.length === 0) {
      return callback(undefined);
    }

    const url = hipsServiceUrlArray.shift();
    Utils.requestUrl(url + "/properties", "text", "text/plain", null, function (data) {
      callback(url);
    }, function (err) {
      _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback);
    });
  }
  /**
   * Loads HIPS layers from passed service url
   * @function _loadHIPSLayers
   * @memberof Mizar#
   * @param {Mizar} Mizar - Mizar API
   * @param {Options} [options] - Options
   * @param {string} [options.registry] - Registry
   * @param {string} [options.registry.hips] - Hips Registry
   * @private
   */


  function _loadHIPSLayers(Mizar, options) {
    if (typeof options !== "undefined" && options.hasOwnProperty("registry") && options.registry.hasOwnProperty("hips")) {
      Utils.requestUrl(options.registry.hips, "json", "application/json", null, function (hipsLayersJSON) {
        _$1.each(hipsLayersJSON, function (hipsLayer) {
          const hipsServiceUrlArray = _getHipsServiceUrlArray(hipsLayer);

          _checkHipsServiceIsAvailable(hipsServiceUrlArray, function (hipsServiceUrl) {
            if (typeof hipsServiceUrl === "undefined") {
              let text = "";

              if (typeof hipsLayer.obs_title === "undefined") {
                text = "with ID <b>" + hipsLayer.ID + "</b>";
              } else {
                text = "with title <b>" + hipsLayer.obs_title + "</b>";
              }

              ErrorDialog.open(Constants.LEVEL.ERROR, " Cannot add layer " + text, "no mirror available");
              return;
            }

            $__default['default'].proxy(_createHips, Mizar)(hipsLayer, hipsServiceUrl);
          });
        }, Mizar);
      }, function (err) {
        ErrorDialog.open(Constants.LEVEL.WARNING, "Cannot connect to " + options.registry.hips, err.message);
      });
    }
  }
  /**
   * Creates a HIPS layer from registry
   * @function _createHips
   * @memberof Mizar#
   * @param hipsLayer
   * @param hipsServiceUrl
   * @private
   */


  function _createHips(hipsLayer, hipsServiceUrl) {
    try {
      if (hipsLayer.hasOwnProperty("hips_status") && hipsLayer.hips_status.match("public") === null) {
        return;
      }

      hipsLayer.hips_service_url = hipsServiceUrl;
      this.addLayer({
        type: Mizar.LAYER.Hips,
        hipsMetadata: new HipsMetadata(hipsLayer)
      });
    } catch (e) {
      const name = hipsLayer.obs_title ? hipsLayer.obs_title : hipsLayer.obs_collection;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Hips layer " + name + " not valid for " + hipsLayer.hips_service_url, e.message);
    }
  }
  /**************************************************************************************************************/


  Utils.inherits(Event, Mizar);
  /**************************************************************************************************************/

  /**************************************************************************************************************
   *                                          Public methods
   **************************************************************************************************************/

  /**
   * Returns the sky context.
   * @returns {SkyContext|null}
   * @function getSkyContext
   * @memberof Mizar#
   */

  Mizar.prototype.getSkyContext = function () {
    return this.skyContext;
  };
  /**
   * Returns the planet context.
   * @returns {PlanetContext|null}
   * @function getPlanetContext
   * @memberof Mizar#
   */


  Mizar.prototype.getPlanetContext = function () {
    return this.planetContext;
  };
  /**
   * Returns the ground context.
   * @returns {GroundContext|null}
   * @function getGroundContext
   * @memberof Mizar#
   */


  Mizar.prototype.getGroundContext = function () {
    return this.groundContext;
  };
  /**
   * Returns the context according to the mode.
   * @function _getContext
   * @param {CONTEXT|undefined} mode - the selected mode
   * @memberof Mizar#
   * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
   * @returns {Context} the context
   * @private
   */


  function _getContext(mode) {
    let context;

    switch (mode) {
      case undefined:
        context = this.getActivatedContext();
        break;

      case Mizar.CONTEXT.Sky:
        context = this.getSkyContext();
        break;

      case Mizar.CONTEXT.Planet:
        context = this.getPlanetContext();
        break;

      case Mizar.CONTEXT.Ground:
        context = this.getGroundContext();
        break;

      default:
        throw new RangeError("main.js: The mode " + mode + " is not allowed, A valid mode is included in the list CONTEXT");
    }

    return context;
  }
  /**
   * Returns the selected context.
   * When activatedContext is not set, it is set automatically to the created context
   * (in the following order : sky, planet, ground). When no context is created,
   * an  exception "No created context" is send.
   * @returns {PlanetContext|SkyContext|GroundContext|null}
   * @function getActivatedContext
   * @memberof Mizar#
   */


  Mizar.prototype.getActivatedContext = function () {
    try {
      if (this.activatedContext == null) {
        if (this.skyContext != null) {
          this.activatedContext = this.skyContext;
        } else if (this.planetContext != null) {
          this.activatedContext = this.planetContext;
        } else if (this.groundContext != null) {
          this.activatedContext = this.groundContext;
        } else {
          throw new ReferenceError("No created context", "Mizar.js");
        }
      }
    } catch (e) {
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot get the context", e.message);
    }

    return this.activatedContext;
  };
  /**
   * Selects the context as default context according to the {@link CONTEXT context mode}.<br/>
   * Once a context is selected, methods can be applied to it.
   * @param {CONTEXT} contextMode - select one context among {@link CONTEXT context}
   * @returns {boolean} true when the contextMode is known otherwise false
   * @function setActivatedContext
   * @memberof Mizar#
   * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
   */


  Mizar.prototype.setActivatedContext = function (contextMode) {

    switch (contextMode) {
      case Mizar.CONTEXT.Planet:
        this.activatedContext = this.planetContext;
        break;

      case Mizar.CONTEXT.Sky:
        this.activatedContext = this.skyContext;
        break;

      case Mizar.CONTEXT.Ground:
        this.activatedContext = this.groundContext;
        break;

      default:
        ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the context to " + contextMode);
    }
  };
  /**
   * Returns the mode in which the active context is set.
   * @function getMode
   * @memberof Mizar#
   * @returns {CONTEXT|null} Returns the mode otherwise null when no created context
   */


  Mizar.prototype.getMode = function () {
    let result;
    const context = this.getActivatedContext();

    if (context) {
      result = context.getMode();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Returns the rendering context.
   * @returns {RenderContext|null} the rendering context
   * @function getRenderContext
   * @memberof Mizar#
   */


  Mizar.prototype.getRenderContext = function () {
    let result;
    const context = this.getActivatedContext();

    if (context) {
      result = context.getRenderContext();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Returns the options
   * @function getOptions
   * @memberof Mizar#
   * @returns {Mizar_parameters} - Mizar's options
   */


  Mizar.prototype.getOptions = function () {
    return this.options;
  }; //               ***************************** coordinate reference *****************************

  /**
   * Returns the coordinate reference system related to the selected {@link CONTEXT context}
   * @returns {Crs|null} the coordinate reference system or null when no created context
   * @function getCrs
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.getCrs = function () {
    let result;
    const context = this.getActivatedContext();

    if (context) {
      result = context.getCoordinateSystem();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Sets the coordinate reference system related to the selected {@link CONTEXT context}
   * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - coordinate system description
   * @returns {boolean} true when the coordinate system is set otherwise false when an error occurs
   * @function setCrs
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.setCrs = function (coordinateSystem) {
    let result;
    const context = this.getActivatedContext();

    if (context) {
      const crs = CoordinateSystemFactory.create(coordinateSystem);
      context.setCoordinateSystem(crs);
      result = true;
    } else {
      result = false;
    }

    return result;
  };
  /**
   * Update the time travel navigation range
   * @param {JSON} parameters Parameters
   * @function setTime
   * @memberof Mizar#
   */


  Mizar.prototype.updateTimeTravel = function (parameters) {
    this.getServiceByName(Mizar.SERVICE.TimeTravel).update(parameters);
  };
  /**
   * Sets the current or integrated time of the application
   * @param {Time.configuration} time single, multiple or range of values
   * @function setTime
   * @memberof Mizar#
   */


  Mizar.prototype.setTime = function (time) {
    this.activatedContext.setTime(time);
  };
  /**
   * Returns the current or integrated time.
   * @returns {Time.configuration} the simple, multiple or range of values
   * @function getTime
   * @memberof Mizar#
   */


  Mizar.prototype.getTime = function () {
    return this.activatedContext.getTime();
  }; //               ***************************** context management *****************************

  /**
   * Creates a context according to the {@link CONTEXT context mode}.<br/>
   * @param {CONTEXT} contextMode - Select on context among {@link CONTEXT context}
   * @param {AbstractContext.skyContext|AbstractContext.planetContext|AbstractContext.groundContext} options - Options for the context, See options.planetContext or options.skycontext configuration for {@link Mizar}
   * @retuns {boolean} true when the context is created otherwise false when the contextMode is unknown
   * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
   * @function createContext
   * @memberof Mizar#
   */


  Mizar.prototype.createContext = function (contextMode, options) {
    let result;

    try {
      options.renderContext = this.renderContext;
      options.timeTravelService = this.getServiceByName(Mizar.SERVICE.TimeTravel);
      options.isMobile = this.getOptions().configuration.isMobile;
      const ctx = this.ContextFactory.create(contextMode, this.getOptions(), options);

      switch (contextMode) {
        case Mizar.CONTEXT.Sky:
          this.skyContext = ctx;

          _loadHIPSLayers(this, this.getOptions().configuration);

          break;

        case Mizar.CONTEXT.Planet:
          this.planetContext = ctx;
          break;

        case Mizar.CONTEXT.Ground:
          this.groundContext = ctx;
          break;

        default:
          throw new RangeError("main.js: Unknown contextMode '" + contextMode + "'");
      }

      this.renderContext = ctx.getRenderContext();
      result = true;
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot create the context", e.message);
    }

    return result;
  };
  /**
   * Switches 2D <--> 3D, only for planetary context. <br/>
   * When this method is used in a sky context, and exception is thrown
   * @returns {boolean} true when toggle works otherwise false
   * @function toggleDimension
   * @memberof Mizar#
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   */


  Mizar.prototype.toggleDimension = function () {
    let result;

    try {
      _skipIfSkyMode.call(this);

      if (this.getCrs().isFlat()) {
        // we are in 2D and we are going to 3D
        _switch2Dto3D.call(this);
      } else {
        // we are in 3D and we are goint to 2D
        _switch3Dto2D.call(this);
      }

      this.render();
      result = true;
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot toggle the dimension", e.message);
    }

    return result;
  };
  /**
   * Switches to a context.
   * @param {AbstractContext} context - target context
   * @param {Object} [options] - options management for the source context
   * @param {boolean} [options.mustBeDestroyed=false] - options management for the source context
   * @param {boolean} [options.mustBeHidden=false] - options management for the source context
   * @param {Function} callback - Call at the end of the toggle
   * @fires Mizar#mizarMode:toggle
   * @function toggleToContext
   * @memberof Mizar#
   */


  Mizar.prototype.toggleToContext = function (context, options) {
    let result;

    try {
      const opts = options || {};

      _switchToContext.call(this, context, opts);

      result = true;
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot toggle the context", e.message);
    }

    return result;
  }; //               ***************************** layer management *****************************

  /**
   * Returns the sky layers, which have been added by {@link Mizar#addLayer}.
   * @function getSkyLayers
   * @returns {Layer[]|null} the layers
   * @memberof Mizar#
   */


  Mizar.prototype.getSkyLayers = function () {
    let result;
    const context = this.getSkyContext();

    if (context) {
      result = context.getLayers();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Returns the planet layers, which have been added by {@link Mizar#addLayer}
   * @function getPlanetLayers
   * @returns {Layer[]|null} the layers
   * @memberof Mizar#
   */


  Mizar.prototype.getPlanetLayers = function () {
    let result;
    const context = this.getPlanetContext();

    if (context) {
      result = context.getLayers();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Returns the grounds layers, which have been added by {@link Mizar#addLayer}
   * @function getGroundLayers
   * @returns {Layer[]|null} the layers
   * @memberof Mizar#
   */


  Mizar.prototype.getGroundLayers = function () {
    let result;
    const context = this.getGroundContext();

    if (context) {
      result = context.getLayers();
    } else {
      result = null;
    }

    return result;
  };
  /**
   * Returns the layers for a specific context.<br/>
   * When no context is specified, the layers from the selected context are returned.
   * @function getLayers
   * @param {CONTEXT|null} mode - Context on which the function is applied
   * @returns {Layer[]} the layers
   * @memberof Mizar#
   * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.getLayers = function (mode) {
    let result;

    try {
      result = _getContext.call(this, mode).getLayers();
    } catch (e) {
      result = null;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot get the layers", e.message);
    }

    return result;
  };
  /**
   * Draws the layer on the top.
   * @function setLayerOnTheTop
   * @param {string} layerID Layer ID
   * @return {boolean} Returns true when the layer is drawn on the top otherwise false.
   * @memberof Mizar#
   */


  Mizar.prototype.setLayerOnTheTop = function (layerID) {
    let result;
    const layer = this.getLayerByID(layerID);

    if (layer != null) {
      layer.setOnTheTop();
      result = true;
    } else {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the layer on the top", layerID + " does not exist");
    }

    return result;
  };
  /**
   * Returns all the layers regardless of the {@link CONTEXT context}.
   * @function getAllLayers
   * @return {Layer[]} the layers
   * @memberof Mizar#
   */


  Mizar.prototype.getAllLayers = function () {
    return _$1.union(this.getSkyLayers(), this.getPlanetLayers());
  };
  /**
   * Returns the layer by its ID according to the {@link CONTEXT context}.<br/>
   * When no context is specified, the layer from the selected context is returned.<br/>
   * The ID is a unique layer identifier, which is returned when the layer description is {@link Mizar#addLayer added}
   * to Mizar
   * @function getLayerByID
   * @param {string} layerID - Layer's ID
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {Layer|undefined|null} The layer or undefined when the layer is not found
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.getLayerByID = function (layerID, mode) {
    let result;

    try {
      result = _getContext.call(this, mode).getLayerByID(layerID);
    } catch (e) {
      result = null;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot get the layer by ID", e.message);
    }

    return result;
  };
  /**
   * Returns the layer by its name according to the {@link CONTEXT context}.<br/>
   * When no context is specified, the layer from the selected context is returned.<br/>
   * <b>Note:</b> The name may not be unique. In this case, the first layer having this name is returned
   * @function getLayerByName
   * @param {string} layerName - Layer's name, provided in the layer description when the layer is {@link Mizar#addLayer added}
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {Layer|undefined|null} the layer or undefined when the layer is not found
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.getLayerByName = function (layerName, mode) {
    let result;

    try {
      result = _getContext.call(this, mode).getLayerByName(layerName);
    } catch (e) {
      result = null;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot get the layer by name", e.message);
    }

    return result;
  };
  /**
   * Adds a layer according to the selected {@link CONTEXT context}.<br/>
   * When layerPlanet is not provided, then the layer is added to the selected context otherwise the layer
   * is added to the layerPlanet.
   *
   * @function addLayer
   * @param {Object} layerDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
   * @returns {string|null} a unique identifier or null when a problem happens
   * @memberof Mizar#
   * @listens AbstractLayer#visibility:changed
   * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
   * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
   * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
   * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
   * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
   * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
   * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
   * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
   * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
   * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
   * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
   * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
   * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
   * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
   * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
   * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
   * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.addLayer = function (layerDescription, callback, fallback) {
    this.getActivatedContext().addLayer(layerDescription, callback, fallback);
  };
  /**
   * Removes a layer by its ID according to the {@link CONTEXT context}.<br/>
   * When no context is specified, then the function is applied on the selected context.
   * @function removeLayer
   * @param {string} layerID - Layer's ID
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {boolean} true when the layer is added otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.removeLayer = function (layerID, mode) {
    let result;

    try {
      const removedLayer = _getContext.call(this, mode).removeLayer(layerID);

      result = typeof removedLayer !== "undefined";
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot remove the layer", e.message);
    }

    return result;
  };
  /**
   * Sets the background layer according to the selected context.<br/>
   * When no context is specified, then the function is applied on the selected context.<br/>
   * <b>Note 1:</b> The name is not a unique identifier. The first layer matching at this name is returned<br/>
   * <b>Note 2:</b> The layer must be {@link Mizar#addLayer added} before
   * @function setBackgroundLayer
   * @param {string} layerName - Layer's name, which has been provided in the layer description
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {boolean} true when the layer is set as background otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.setBackgroundLayer = function (layerName, mode) {
    let result;

    try {
      const gwLayer = _getContext.call(this, mode).setBackgroundLayer(layerName);

      result = typeof gwLayer !== "undefined";
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the background", e.message);
    }

    return result;
  };
  /**
   * Sets the background layer by ID according to the {@link CONTEXT context}.<br/>
   * When no context is specified, then the function is applied on the selected context.
   * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
   * @function setBackgroundLayerByID
   * @param {string} layerID - Unique layer identifier.
   * @param {CONTEXT|undefined} mode - Context on which the function is applied.
   * @returns {boolean} true when the layer is set as background otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext} to select a context
   * @see {@link Mizar#createContext} to create a context
   */


  Mizar.prototype.setBackgroundLayerByID = function (layerID, mode) {
    let result;

    try {
      const gwLayer = _getContext.call(this, mode).setBackgroundLayerByID(layerID);

      result = typeof gwLayer !== "undefined";
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the backgorund by ID", e.message);
    }

    return result;
  };
  /**
   * Sets the base elevation by its layer's name according to the {@link CONTEXT context}.<br/>
   * When no context is specified, then the function is applied on the selected context.
   * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
   * @function setBaseElevation
   * @param {string} layerName - Name of the layer
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {boolean} true when the base elevation is set otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.setBaseElevation = function (layerName, mode) {
    let result;

    try {
      const layer = this.getLayerByName(layerName, mode);

      const gwLayer = _getContext.call(this, mode).setBaseElevation(layer);

      result = typeof gwLayer !== "undefined";
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the base elevation", e.message);
    }

    return result;
  };
  /**
   * Gets the base elevation to the {@link CONTEXT context}.<br/>
   * When no context is specified, then the function is applied on the selected context.
   * @function getBaseElevation
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {WCSElevationLayer|null} true when the base elevation is set otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.getBaseElevation = function (mode) {
    return _getContext.call(this, mode).getBaseElevation();
  };
  /**
   * Sets the base elevation by its layer's ID according to the {@link CONTEXT context}.<br/>
   * When no context is specified, then the function is applied on the selected context.
   * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
   * @function setBaseElevation
   * @param {string} layerID - ID of the layer
   * @param {CONTEXT|undefined} mode - Context on which the function is applied
   * @returns {boolean} true when the base elevation is set otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.setBaseElevationByID = function (layerID, mode) {
    let result;

    try {
      const gwLayer = _getContext.call(this, mode).setBaseElevationByID(layerID);

      result = typeof gwLayer !== "undefined";
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot set the base elevation by ID", e.message);
    }

    return result;
  };
  /**
   * Looks through each value in the list according to the context, returning an array of all the values that match the query.<br/>
   * The query is performed on the name and the description of each layer.<br/>
   * When no context is specified, the function is applied on the selected context.
   * @function searchOnLayerDescription
   * @param {string} query - query on the layer'name or description
   * @param {CONTEXT|undefined} mode - Context on which the query is run.
   * @returns {Layer[]}
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   */


  Mizar.prototype.searchOnLayerDescription = function (query, mode) {
    const layers = this.getLayers(mode);
    return _$1.filter(layers, function (layer) {
      return String(layer.getName()).indexOf(query) >= 0 || String(layer.getDescription() || "").indexOf(query) >= 0;
    });
  };
  /**
   * Looks through each value in the sky layers, returning an array of all the values that match the query.<br/>
   * The query is performed on the name and the description of each layer
   * @function searchSkyLayer
   * @param {string} query - query on the layer's name or description
   * @returns {Layer[]} An array of layers matching the constraint
   * @memberof Mizar#
   */


  Mizar.prototype.searchSkyLayer = function (query) {
    const layers = this.getSkyLayers();
    return _$1.filter(layers, function (layer) {
      return String(layer.getName()).indexOf(query) >= 0 || String(layer.getDescription() || "").indexOf(query) >= 0;
    });
  };
  /**
   * Looks through each value in the planets layers, returning an array of all the values that match the query.<br/>
   * The query is performed on the name and the description of each layer
   * @function searchPlanetLayer
   * @param {string} query - query on the layer'name or description
   * @returns {Layer[]} An array of layers matching the constraint
   * @memberof Mizar#
   */


  Mizar.prototype.searchPlanetLayer = function (query) {
    const layers = this.getPlanetLayers(); //Search by name

    return _$1.filter(layers, function (layer) {
      return String(layer.getName()).indexOf(query) >= 0 || String(layer.getDescription() || "").indexOf(query) >= 0;
    });
  }; //               ***************************** Utility management *****************************

  /**
   * Registers no standard data provider in a predefined context.<br/>
   * When no context is specified, the function is applied to the selected context.
   * @function registerNoStandardDataProvider
   * @param {string} type - data provider key
   * @param {Function} loadFunc - Function to convert the data
   * @param {CONTEXT|undefined} mode - Context
   * @returns {boolean} true when data provider is registered otherwise false
   * @memberof Mizar#
   * @see {@link Mizar#setActivatedContext}
   * @see {@link Mizar#createContext}
   * @example <caption>Registers planets on the sky</caption>
   *   var planetProvider = ProviderFactory.create(Mizar.PROVIDER.Planet);
   *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
   */


  Mizar.prototype.registerNoStandardDataProvider = function (type, loadFunc, mode) {
    let result;

    try {
      _getContext.call(this, mode).registerNoStandardDataProvider(type, loadFunc);

      result = true;
    } catch (e) {
      result = false;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot register the data provider", e.message);
    }

    return result;
  };
  /**
   * Returns the service based on its name
   * @param {SERVICE} serviceName
   * @param {Object} options - options for the service
   * @memberof Mizar#
   * @returns {Object|null} - the service
   */


  Mizar.prototype.getServiceByName = function (serviceName, options) {
    let result;

    try {
      result = ServiceFactory.create(serviceName, options);
    } catch (e) {
      result = null;
      ErrorDialog.open(Constants.LEVEL.ERROR, "Cannot get the service by name", e.message);
    }

    return result;
  };
  /**
   * Creates and get Stats Object
   * @function createStats
   * @param {Object} options - Configuration properties for stats.
   * @param {string|object} options.element div ID ou jquery element in wich the stats are written
   * @param {boolean} [options.verbose=false] detailled display when verbose=true
   * @return {Stats}
   * @memberof Mizar#
   * @see {@link Stats}
   */


  Mizar.prototype.createStats = function (options) {
    let result;

    if (this.skyContext) {
      this.Stats = new Stats(this.skyContext, options);
      result = true;
    } else if (this.planetContext) {
      this.Stats = new Stats(this.planetContext, options);
      result = true;
    } else if (this.groundContext) {
      this.Stats = new Stats(this.groundContext, options);
      result = true;
    } else {
      result = false;
      ErrorDialog.open("Cannot create the stats", true);
    }

    return result;
  }; //               ***************************** Rendering management *****************************

  /**
   * Renders the canvas.
   * @returns {boolean} true when the canvas is rendered otherwise false
   * @function render
   * @memberof Mizar#
   * @fires Context#startLoad
   * @fires Context#endLoad
   * @fires Context#baseLayersReady
   * @fires Context#baseLayersError
   * @fires Context#startBackgroundLoad
   * @fires Context#endBackgroundLoad
   * @fires Context#features:added
   */


  Mizar.prototype.render = function () {
    let result;
    const renderContext = this.getRenderContext();

    if (renderContext) {
      this.getRenderContext().frame();
      result = true;
    } else {
      result = false;
    }

    return result;
  }; //               ***************************** Memory management *****************************

  /**
   * Disposes the Mizar's contexts (planet, sky and ground).
   *
   * Reset the {@link TileManager} and delete texture for each defined context.
   * @function dispose
   * @memberof Mizar#
   */


  Mizar.prototype.dispose = function () {
    if (this.planetContext) {
      this.planetContext.dispose();
    }

    if (this.skyContext) {
      this.skyContext.dispose();
    }

    if (this.groundContext) {
      this.groundContext.dispose();
    }
  };
  /**
   * Reload a layer (keep id and ID)
   * @function reloadLayer
   * @memberof Mizar#
   */


  Mizar.prototype.reloadLayer = function (layer) {
    const ctx = this.getActivatedContext();

    if (ctx) {
      const tileManager = ctx.getTileManager();
      tileManager.abortLayerRequests(layer);

      layer._detach(ctx.globe);

      layer._attach(ctx.globe);
    } else {
      ErrorDialog.open(Constants.LEVEL.WARNING, "Context not yet available");
    }
  };
  /**
   * Destroys Mizar
   *
   * @function destroy
   * @memberof Mizar#
   */


  Mizar.prototype.destroy = function () {
    if (this.planetContext) {
      this.planetContext.destroy();
    }

    if (this.skyContext) {
      this.skyContext.destroy();
    }

    if (this.groundContext) {
      this.groundContext.destroy();
    }

    this.activatedContext = null;
    this.renderContext = null;
    this.ContextFactory = null;
    this.LayerFactory = null;
    this.AnimationFactory = null;
    this.ServiceFactory = null;
    this.UtilityFactory = null;
  }; // Make object MIZAR available in caller web page


  window.Mizar = Mizar;

  return Mizar;

})));
