(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.libGlobalName = factory();
    }
}(this, function () {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../build/almond", function(){});

/*! jQuery v3.3.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function e(t){return"function"==typeof t&&"number"!=typeof t.nodeType},y=function e(t){return null!=t&&t===t.window},v={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement("script");if(o.text=e,n)for(i in v)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[c.call(e)]||"object":typeof e}var b="3.3.1",w=function(e,t){return new w.fn.init(e,t)},T=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;w.fn=w.prototype={jquery:"3.3.1",constructor:w,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=w.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return w.each(this,e)},map:function(e){return this.pushStack(w.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(o.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:n.sort,splice:n.splice},w.extend=w.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||g(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],a!==(r=e[t])&&(l&&r&&(w.isPlainObject(r)||(i=Array.isArray(r)))?(i?(i=!1,o=n&&Array.isArray(n)?n:[]):o=n&&w.isPlainObject(n)?n:{},a[t]=w.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},w.extend({expando:"jQuery"+("3.3.1"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==c.call(e))&&(!(t=i(e))||"function"==typeof(n=f.call(t,"constructor")&&t.constructor)&&p.call(n)===d)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e){m(e)},each:function(e,t){var n,r=0;if(C(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(C(Object(e))?w.merge(n,"string"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:u.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,a=e.length,s=!n;o<a;o++)(r=!t(e[o],o))!==s&&i.push(e[o]);return i},map:function(e,t,n){var r,i,o=0,s=[];if(C(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&s.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&s.push(i);return a.apply([],s)},guid:1,support:h}),"function"==typeof Symbol&&(w.fn[Symbol.iterator]=n[Symbol.iterator]),w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function C(e){var t=!!e&&"length"in e&&e.length,n=x(e);return!g(e)&&!y(e)&&("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e)}var E=function(e){var t,n,r,i,o,a,s,u,l,c,f,p,d,h,g,y,v,m,x,b="sizzle"+1*new Date,w=e.document,T=0,C=0,E=ae(),k=ae(),S=ae(),D=function(e,t){return e===t&&(f=!0),0},N={}.hasOwnProperty,A=[],j=A.pop,q=A.push,L=A.push,H=A.slice,O=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},P="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",I="\\["+M+"*("+R+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+R+"))|)"+M+"*\\]",W=":("+R+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+I+")*)|.*)\\)|)",$=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),F=new RegExp("^"+M+"*,"+M+"*"),_=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),z=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),X=new RegExp(W),U=new RegExp("^"+R+"$"),V={ID:new RegExp("^#("+R+")"),CLASS:new RegExp("^\\.("+R+")"),TAG:new RegExp("^("+R+"|[*])"),ATTR:new RegExp("^"+I),PSEUDO:new RegExp("^"+W),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+P+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},G=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Q=/^[^{]+\{\s*\[native \w/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,K=/[+~]/,Z=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ee=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},te=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ne=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},re=function(){p()},ie=me(function(e){return!0===e.disabled&&("form"in e||"label"in e)},{dir:"parentNode",next:"legend"});try{L.apply(A=H.call(w.childNodes),w.childNodes),A[w.childNodes.length].nodeType}catch(e){L={apply:A.length?function(e,t){q.apply(e,H.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function oe(e,t,r,i){var o,s,l,c,f,h,v,m=t&&t.ownerDocument,T=t?t.nodeType:9;if(r=r||[],"string"!=typeof e||!e||1!==T&&9!==T&&11!==T)return r;if(!i&&((t?t.ownerDocument||t:w)!==d&&p(t),t=t||d,g)){if(11!==T&&(f=J.exec(e)))if(o=f[1]){if(9===T){if(!(l=t.getElementById(o)))return r;if(l.id===o)return r.push(l),r}else if(m&&(l=m.getElementById(o))&&x(t,l)&&l.id===o)return r.push(l),r}else{if(f[2])return L.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return L.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!S[e+" "]&&(!y||!y.test(e))){if(1!==T)m=t,v=e;else if("object"!==t.nodeName.toLowerCase()){(c=t.getAttribute("id"))?c=c.replace(te,ne):t.setAttribute("id",c=b),s=(h=a(e)).length;while(s--)h[s]="#"+c+" "+ve(h[s]);v=h.join(","),m=K.test(e)&&ge(t.parentNode)||t}if(v)try{return L.apply(r,m.querySelectorAll(v)),r}catch(e){}finally{c===b&&t.removeAttribute("id")}}}return u(e.replace(B,"$1"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+" ")>r.cacheLength&&delete t[e.shift()],t[n+" "]=i}return t}function se(e){return e[b]=!0,e}function ue(e){var t=d.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function le(e,t){var n=e.split("|"),i=n.length;while(i--)r.attrHandle[n[i]]=t}function ce(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function fe(e){return function(t){return"input"===t.nodeName.toLowerCase()&&t.type===e}}function pe(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function de(e){return function(t){return"form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ie(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function ge(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}n=oe.support={},o=oe.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},p=oe.setDocument=function(e){var t,i,a=e?e.ownerDocument||e:w;return a!==d&&9===a.nodeType&&a.documentElement?(d=a,h=d.documentElement,g=!o(d),w!==d&&(i=d.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",re,!1):i.attachEvent&&i.attachEvent("onunload",re)),n.attributes=ue(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=ue(function(e){return e.appendChild(d.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=Q.test(d.getElementsByClassName),n.getById=ue(function(e){return h.appendChild(e).id=b,!d.getElementsByName||!d.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){return e.getAttribute("id")===t}},r.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){var n="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},r.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),r.find.TAG=n.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&g)return t.getElementsByClassName(e)},v=[],y=[],(n.qsa=Q.test(d.querySelectorAll))&&(ue(function(e){h.appendChild(e).innerHTML="<a id='"+b+"'></a><select id='"+b+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&y.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||y.push("\\["+M+"*(?:value|"+P+")"),e.querySelectorAll("[id~="+b+"-]").length||y.push("~="),e.querySelectorAll(":checked").length||y.push(":checked"),e.querySelectorAll("a#"+b+"+*").length||y.push(".#.+[+~]")}),ue(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=d.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&y.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&y.push(":enabled",":disabled"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&y.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),y.push(",.*:")})),(n.matchesSelector=Q.test(m=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ue(function(e){n.disconnectedMatch=m.call(e,"*"),m.call(e,"[s!='']:x"),v.push("!=",W)}),y=y.length&&new RegExp(y.join("|")),v=v.length&&new RegExp(v.join("|")),t=Q.test(h.compareDocumentPosition),x=t||Q.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e===d||e.ownerDocument===w&&x(w,e)?-1:t===d||t.ownerDocument===w&&x(w,t)?1:c?O(c,e)-O(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===d?-1:t===d?1:i?-1:o?1:c?O(c,e)-O(c,t):0;if(i===o)return ce(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?ce(a[r],s[r]):a[r]===w?-1:s[r]===w?1:0},d):d},oe.matches=function(e,t){return oe(e,null,null,t)},oe.matchesSelector=function(e,t){if((e.ownerDocument||e)!==d&&p(e),t=t.replace(z,"='$1']"),n.matchesSelector&&g&&!S[t+" "]&&(!v||!v.test(t))&&(!y||!y.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return oe(t,d,null,[e]).length>0},oe.contains=function(e,t){return(e.ownerDocument||e)!==d&&p(e),x(e,t)},oe.attr=function(e,t){(e.ownerDocument||e)!==d&&p(e);var i=r.attrHandle[t.toLowerCase()],o=i&&N.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},oe.escape=function(e){return(e+"").replace(te,ne)},oe.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},oe.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(D),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1)}return c=null,e},i=oe.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=oe.selectors={cacheLength:50,createPseudo:se,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(Z,ee),e[3]=(e[3]||e[4]||e[5]||"").replace(Z,ee),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||oe.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&oe.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return V.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=a(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(Z,ee).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&E(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=oe.attr(r,e);return null==i?"!="===t:!t||(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i.replace($," ")+" ").indexOf(n)>-1:"|="===t&&(i===n||i.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",y=t.parentNode,v=s&&t.nodeName.toLowerCase(),m=!u&&!s,x=!1;if(y){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?y.firstChild:y.lastChild],a&&m){x=(d=(l=(c=(f=(p=y)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1])&&l[2],p=d&&y.childNodes[d];while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if(1===p.nodeType&&++x&&p===t){c[e]=[T,d,x];break}}else if(m&&(x=d=(l=(c=(f=(p=t)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1]),!1===x)while(p=++d&&p&&p[g]||(x=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===v:1===p.nodeType)&&++x&&(m&&((c=(f=p[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]=[T,x]),p===t))break;return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||oe.error("unsupported pseudo: "+e);return i[b]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),a=o.length;while(a--)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,"$1"));return r[b]?se(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||"")||oe.error("unsupported lang: "+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return(n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:he(function(){return[0]}),last:he(function(e,t){return[t-1]}),eq:he(function(e,t,n){return[n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq;for(t in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=fe(t);for(t in{submit:!0,reset:!0})r.pseudos[t]=pe(t);function ye(){}ye.prototype=r.filters=r.pseudos,r.setFilters=new ye,a=oe.tokenize=function(e,t){var n,i,o,a,s,u,l,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=r.preFilter;while(s){n&&!(i=F.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),n=!1,(i=_.exec(s))&&(n=i.shift(),o.push({value:n,type:i[0].replace(B," ")}),s=s.slice(n.length));for(a in r.filter)!(i=V[a].exec(s))||l[a]&&!(i=l[a](i))||(n=i.shift(),o.push({value:n,type:a,matches:i}),s=s.slice(n.length));if(!n)break}return t?s.length:s?oe.error(e):k(e,u).slice(0)};function ve(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function me(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&"parentNode"===o,s=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||a)return e(t,n,i);return!1}:function(t,n,u){var l,c,f,p=[T,s];if(u){while(t=t[r])if((1===t.nodeType||a)&&e(t,n,u))return!0}else while(t=t[r])if(1===t.nodeType||a)if(f=t[b]||(t[b]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===T&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}return!1}}function xe(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function be(e,t,n){for(var r=0,i=t.length;r<i;r++)oe(e,t[r],n);return n}function we(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Te(e,t,n,r,i,o){return r&&!r[b]&&(r=Te(r)),i&&!i[b]&&(i=Te(i,o)),se(function(o,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=o||be(t||"*",s.nodeType?[s]:s,[]),y=!e||!o&&t?g:we(g,p,e,s,u),v=n?i||(o?e:h||r)?[]:a:y;if(n&&n(y,v,s,u),r){l=we(v,d),r(l,[],s,u),c=l.length;while(c--)(f=l[c])&&(v[d[c]]=!(y[d[c]]=f))}if(o){if(i||e){if(i){l=[],c=v.length;while(c--)(f=v[c])&&l.push(y[c]=f);i(null,v=[],l,u)}c=v.length;while(c--)(f=v[c])&&(l=i?O(o,f):p[c])>-1&&(o[l]=!(a[l]=f))}}else v=we(v===a?v.splice(h,v.length):v),i?i(null,a,v,u):L.apply(a,v)})}function Ce(e){for(var t,n,i,o=e.length,a=r.relative[e[0].type],s=a||r.relative[" "],u=a?1:0,c=me(function(e){return e===t},s,!0),f=me(function(e){return O(t,e)>-1},s,!0),p=[function(e,n,r){var i=!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):f(e,n,r));return t=null,i}];u<o;u++)if(n=r.relative[e[u].type])p=[me(xe(p),n)];else{if((n=r.filter[e[u].type].apply(null,e[u].matches))[b]){for(i=++u;i<o;i++)if(r.relative[e[i].type])break;return Te(u>1&&xe(p),u>1&&ve(e.slice(0,u-1).concat({value:" "===e[u-2].type?"*":""})).replace(B,"$1"),n,u<i&&Ce(e.slice(u,i)),i<o&&Ce(e=e.slice(i)),i<o&&ve(e))}p.push(n)}return xe(p)}function Ee(e,t){var n=t.length>0,i=e.length>0,o=function(o,a,s,u,c){var f,h,y,v=0,m="0",x=o&&[],b=[],w=l,C=o||i&&r.find.TAG("*",c),E=T+=null==w?1:Math.random()||.1,k=C.length;for(c&&(l=a===d||a||c);m!==k&&null!=(f=C[m]);m++){if(i&&f){h=0,a||f.ownerDocument===d||(p(f),s=!g);while(y=e[h++])if(y(f,a||d,s)){u.push(f);break}c&&(T=E)}n&&((f=!y&&f)&&v--,o&&x.push(f))}if(v+=m,n&&m!==v){h=0;while(y=t[h++])y(x,b,a,s);if(o){if(v>0)while(m--)x[m]||b[m]||(b[m]=j.call(u));b=we(b)}L.apply(u,b),c&&!o&&b.length>0&&v+t.length>1&&oe.uniqueSort(u)}return c&&(T=E,l=w),x};return n?se(o):o}return s=oe.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=a(e)),n=t.length;while(n--)(o=Ce(t[n]))[b]?r.push(o):i.push(o);(o=S(e,Ee(i,r))).selector=e}return o},u=oe.select=function(e,t,n,i){var o,u,l,c,f,p="function"==typeof e&&e,d=!i&&a(e=p.selector||e);if(n=n||[],1===d.length){if((u=d[0]=d[0].slice(0)).length>2&&"ID"===(l=u[0]).type&&9===t.nodeType&&g&&r.relative[u[1].type]){if(!(t=(r.find.ID(l.matches[0].replace(Z,ee),t)||[])[0]))return n;p&&(t=t.parentNode),e=e.slice(u.shift().value.length)}o=V.needsContext.test(e)?0:u.length;while(o--){if(l=u[o],r.relative[c=l.type])break;if((f=r.find[c])&&(i=f(l.matches[0].replace(Z,ee),K.test(u[0].type)&&ge(t.parentNode)||t))){if(u.splice(o,1),!(e=i.length&&ve(u)))return L.apply(n,i),n;break}}}return(p||s(e,d))(i,t,!g,n,!t||K.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split("").sort(D).join("")===b,n.detectDuplicates=!!f,p(),n.sortDetached=ue(function(e){return 1&e.compareDocumentPosition(d.createElement("fieldset"))}),ue(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||le("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&ue(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||le("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ue(function(e){return null==e.getAttribute("disabled")})||le(P,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),oe}(e);w.find=E,w.expr=E.selectors,w.expr[":"]=w.expr.pseudos,w.uniqueSort=w.unique=E.uniqueSort,w.text=E.getText,w.isXMLDoc=E.isXML,w.contains=E.contains,w.escapeSelector=E.escape;var k=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&w(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},D=w.expr.match.needsContext;function N(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var A=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,t,n){return g(t)?w.grep(e,function(e,r){return!!t.call(e,r,e)!==n}):t.nodeType?w.grep(e,function(e){return e===t!==n}):"string"!=typeof t?w.grep(e,function(e){return u.call(t,e)>-1!==n}):w.filter(t,e,n)}w.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?w.find.matchesSelector(r,e)?[r]:[]:w.find.matches(e,w.grep(t,function(e){return 1===e.nodeType}))},w.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(w(e).filter(function(){for(t=0;t<r;t++)if(w.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)w.find(e,i[t],n);return r>1?w.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&D.test(e)?w(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(w.fn.init=function(e,t,n){var i,o;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(i="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:L.exec(e))||!i[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(i[1]){if(t=t instanceof w?t[0]:t,w.merge(this,w.parseHTML(i[1],t&&t.nodeType?t.ownerDocument||t:r,!0)),A.test(i[1])&&w.isPlainObject(t))for(i in t)g(this[i])?this[i](t[i]):this.attr(i,t[i]);return this}return(o=r.getElementById(i[2]))&&(this[0]=o,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):g(e)?void 0!==n.ready?n.ready(e):e(w):w.makeArray(e,this)}).prototype=w.fn,q=w(r);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};w.fn.extend({has:function(e){var t=w(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(w.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&w(e);if(!D.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&w.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?w.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?u.call(w(e),this[0]):u.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(w.uniqueSort(w.merge(this.get(),w(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}w.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return k(e,"parentNode")},parentsUntil:function(e,t,n){return k(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return k(e,"nextSibling")},prevAll:function(e){return k(e,"previousSibling")},nextUntil:function(e,t,n){return k(e,"nextSibling",n)},prevUntil:function(e,t,n){return k(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return N(e,"iframe")?e.contentDocument:(N(e,"template")&&(e=e.content||e),w.merge([],e.childNodes))}},function(e,t){w.fn[e]=function(n,r){var i=w.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=w.filter(r,i)),this.length>1&&(O[e]||w.uniqueSort(i),H.test(e)&&i.reverse()),this.pushStack(i)}});var M=/[^\x20\t\r\n\f]+/g;function R(e){var t={};return w.each(e.match(M)||[],function(e,n){t[n]=!0}),t}w.Callbacks=function(e){e="string"==typeof e?R(e):w.extend({},e);var t,n,r,i,o=[],a=[],s=-1,u=function(){for(i=i||e.once,r=t=!0;a.length;s=-1){n=a.shift();while(++s<o.length)!1===o[s].apply(n[0],n[1])&&e.stopOnFalse&&(s=o.length,n=!1)}e.memory||(n=!1),t=!1,i&&(o=n?[]:"")},l={add:function(){return o&&(n&&!t&&(s=o.length-1,a.push(n)),function t(n){w.each(n,function(n,r){g(r)?e.unique&&l.has(r)||o.push(r):r&&r.length&&"string"!==x(r)&&t(r)})}(arguments),n&&!t&&u()),this},remove:function(){return w.each(arguments,function(e,t){var n;while((n=w.inArray(t,o,n))>-1)o.splice(n,1),n<=s&&s--}),this},has:function(e){return e?w.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=a=[],o=n="",this},disabled:function(){return!o},lock:function(){return i=a=[],n||t||(o=n=""),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=[e,(n=n||[]).slice?n.slice():n],a.push(n),t||u()),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!r}};return l};function I(e){return e}function W(e){throw e}function $(e,t,n,r){var i;try{e&&g(i=e.promise)?i.call(e).done(t).fail(n):e&&g(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}w.extend({Deferred:function(t){var n=[["notify","progress",w.Callbacks("memory"),w.Callbacks("memory"),2],["resolve","done",w.Callbacks("once memory"),w.Callbacks("once memory"),0,"resolved"],["reject","fail",w.Callbacks("once memory"),w.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},"catch":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return w.Deferred(function(t){w.each(n,function(n,r){var i=g(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&g(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){var o=0;function a(t,n,r,i){return function(){var s=this,u=arguments,l=function(){var e,l;if(!(t<o)){if((e=r.apply(s,u))===n.promise())throw new TypeError("Thenable self-resolution");l=e&&("object"==typeof e||"function"==typeof e)&&e.then,g(l)?i?l.call(e,a(o,n,I,i),a(o,n,W,i)):(o++,l.call(e,a(o,n,I,i),a(o,n,W,i),a(o,n,I,n.notifyWith))):(r!==I&&(s=void 0,u=[e]),(i||n.resolveWith)(s,u))}},c=i?l:function(){try{l()}catch(e){w.Deferred.exceptionHook&&w.Deferred.exceptionHook(e,c.stackTrace),t+1>=o&&(r!==W&&(s=void 0,u=[e]),n.rejectWith(s,u))}};t?c():(w.Deferred.getStackHook&&(c.stackTrace=w.Deferred.getStackHook()),e.setTimeout(c))}}return w.Deferred(function(e){n[0][3].add(a(0,e,g(i)?i:I,e.notifyWith)),n[1][3].add(a(0,e,g(t)?t:I)),n[2][3].add(a(0,e,g(r)?r:W))}).promise()},promise:function(e){return null!=e?w.extend(e,i):i}},o={};return w.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=o.call(arguments),a=w.Deferred(),s=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?o.call(arguments):n,--t||a.resolveWith(r,i)}};if(t<=1&&($(e,a.done(s(n)).resolve,a.reject,!t),"pending"===a.state()||g(i[n]&&i[n].then)))return a.then();while(n--)$(i[n],s(n),a.reject);return a.promise()}});var B=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;w.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&B.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,n)},w.readyException=function(t){e.setTimeout(function(){throw t})};var F=w.Deferred();w.fn.ready=function(e){return F.then(e)["catch"](function(e){w.readyException(e)}),this},w.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--w.readyWait:w.isReady)||(w.isReady=!0,!0!==e&&--w.readyWait>0||F.resolveWith(r,[w]))}}),w.ready.then=F.then;function _(){r.removeEventListener("DOMContentLoaded",_),e.removeEventListener("load",_),w.ready()}"complete"===r.readyState||"loading"!==r.readyState&&!r.documentElement.doScroll?e.setTimeout(w.ready):(r.addEventListener("DOMContentLoaded",_),e.addEventListener("load",_));var z=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===x(n)){i=!0;for(s in n)z(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,g(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(w(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},X=/^-ms-/,U=/-([a-z])/g;function V(e,t){return t.toUpperCase()}function G(e){return e.replace(X,"ms-").replace(U,V)}var Y=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Q(){this.expando=w.expando+Q.uid++}Q.uid=1,Q.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Y(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[G(t)]=n;else for(r in t)i[G(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][G(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(G):(t=G(t))in r?[t]:t.match(M)||[]).length;while(n--)delete r[t[n]]}(void 0===t||w.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!w.isEmptyObject(t)}};var J=new Q,K=new Q,Z=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,ee=/[A-Z]/g;function te(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:Z.test(e)?JSON.parse(e):e)}function ne(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(ee,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n=te(n)}catch(e){}K.set(e,t,n)}else n=void 0;return n}w.extend({hasData:function(e){return K.hasData(e)||J.hasData(e)},data:function(e,t,n){return K.access(e,t,n)},removeData:function(e,t){K.remove(e,t)},_data:function(e,t,n){return J.access(e,t,n)},_removeData:function(e,t){J.remove(e,t)}}),w.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=K.get(o),1===o.nodeType&&!J.get(o,"hasDataAttrs"))){n=a.length;while(n--)a[n]&&0===(r=a[n].name).indexOf("data-")&&(r=G(r.slice(5)),ne(o,r,i[r]));J.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){K.set(this,e)}):z(this,function(t){var n;if(o&&void 0===t){if(void 0!==(n=K.get(o,e)))return n;if(void 0!==(n=ne(o,e)))return n}else this.each(function(){K.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){K.remove(this,e)})}}),w.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=J.get(e,t),n&&(!r||Array.isArray(n)?r=J.access(e,t,w.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=w.queue(e,t),r=n.length,i=n.shift(),o=w._queueHooks(e,t),a=function(){w.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return J.get(e,n)||J.access(e,n,{empty:w.Callbacks("once memory").add(function(){J.remove(e,[t+"queue",n])})})}}),w.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?w.queue(this[0],e):void 0===t?this:this.each(function(){var n=w.queue(this,e,t);w._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&w.dequeue(this,e)})},dequeue:function(e){return this.each(function(){w.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=w.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=J.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var re=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ie=new RegExp("^(?:([+-])=|)("+re+")([a-z%]*)$","i"),oe=["Top","Right","Bottom","Left"],ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&w.contains(e.ownerDocument,e)&&"none"===w.css(e,"display")},se=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i};function ue(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return w.css(e,t,"")},u=s(),l=n&&n[3]||(w.cssNumber[t]?"":"px"),c=(w.cssNumber[t]||"px"!==l&&+u)&&ie.exec(w.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)w.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,w.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var le={};function ce(e){var t,n=e.ownerDocument,r=e.nodeName,i=le[r];return i||(t=n.body.appendChild(n.createElement(r)),i=w.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),le[r]=i,i)}function fe(e,t){for(var n,r,i=[],o=0,a=e.length;o<a;o++)(r=e[o]).style&&(n=r.style.display,t?("none"===n&&(i[o]=J.get(r,"display")||null,i[o]||(r.style.display="")),""===r.style.display&&ae(r)&&(i[o]=ce(r))):"none"!==n&&(i[o]="none",J.set(r,"display",n)));for(o=0;o<a;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}w.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?w(this).show():w(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;function ye(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&N(e,t)?w.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)J.set(e[n],"globalEval",!t||J.get(t[n],"globalEval"))}var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===x(o))w.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+w.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;w.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&w.inArray(o,r)>-1)i&&i.push(o);else if(l=w.contains(o.ownerDocument,o),a=ye(f.appendChild(o),"script"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}!function(){var e=r.createDocumentFragment().appendChild(r.createElement("div")),t=r.createElement("input");t.setAttribute("type","radio"),t.setAttribute("checked","checked"),t.setAttribute("name","t"),e.appendChild(t),h.checkClone=e.cloneNode(!0).cloneNode(!0).lastChild.checked,e.innerHTML="<textarea>x</textarea>",h.noCloneChecked=!!e.cloneNode(!0).lastChild.defaultValue}();var be=r.documentElement,we=/^key/,Te=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ce=/^([^.]*)(?:\.(.+)|)/;function Ee(){return!0}function ke(){return!1}function Se(){try{return r.activeElement}catch(e){}}function De(e,t,n,r,i,o){var a,s;if("object"==typeof t){"string"!=typeof n&&(r=r||n,n=void 0);for(s in t)De(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=ke;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return w().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=w.guid++)),e.each(function(){w.event.add(this,t,i,r,n)})}w.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=J.get(e);if(y){n.handler&&(n=(o=n).handler,i=o.selector),i&&w.find.matchesSelector(be,i),n.guid||(n.guid=w.guid++),(u=y.events)||(u=y.events={}),(a=y.handle)||(a=y.handle=function(t){return"undefined"!=typeof w&&w.event.triggered!==t.type?w.event.dispatch.apply(e,arguments):void 0}),l=(t=(t||"").match(M)||[""]).length;while(l--)d=g=(s=Ce.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=w.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=w.event.special[d]||{},c=w.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&w.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(e,r,h,a)||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),w.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=J.hasData(e)&&J.get(e);if(y&&(u=y.events)){l=(t=(t||"").match(M)||[""]).length;while(l--)if(s=Ce.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){f=w.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||w.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)w.event.remove(e,d+t[l],n,r,!0);w.isEmptyObject(u)&&J.remove(e,"handle events")}},dispatch:function(e){var t=w.event.fix(e),n,r,i,o,a,s,u=new Array(arguments.length),l=(J.get(this,"events")||{})[t.type]||[],c=w.event.special[t.type]||{};for(u[0]=t,n=1;n<arguments.length;n++)u[n]=arguments[n];if(t.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,t)){s=w.event.handlers.call(this,t,l),n=0;while((o=s[n++])&&!t.isPropagationStopped()){t.currentTarget=o.elem,r=0;while((a=o.handlers[r++])&&!t.isImmediatePropagationStopped())t.rnamespace&&!t.rnamespace.test(a.namespace)||(t.handleObj=a,t.data=a.data,void 0!==(i=((w.event.special[a.origType]||{}).handle||a.handler).apply(o.elem,u))&&!1===(t.result=i)&&(t.preventDefault(),t.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,t),t.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&e.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?w(i,this).index(l)>-1:w.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(e,t){Object.defineProperty(w.Event.prototype,e,{enumerable:!0,configurable:!0,get:g(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[w.expando]?e:new w.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==Se()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===Se()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&N(this,"input"))return this.click(),!1},_default:function(e){return N(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},w.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},w.Event=function(e,t){if(!(this instanceof w.Event))return new w.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ee:ke,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&w.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[w.expando]=!0},w.Event.prototype={constructor:w.Event,isDefaultPrevented:ke,isPropagationStopped:ke,isImmediatePropagationStopped:ke,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ee,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ee,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ee,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},w.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&we.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Te.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},w.event.addProp),w.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){w.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||w.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),w.fn.extend({on:function(e,t,n,r){return De(this,e,t,n,r)},one:function(e,t,n,r){return De(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,w(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=ke),this.each(function(){w.event.remove(this,e,n,t)})}});var Ne=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Ae=/<script|<style|<link/i,je=/checked\s*(?:[^=]|=\s*.checked.)/i,qe=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Le(e,t){return N(e,"table")&&N(11!==t.nodeType?t:t.firstChild,"tr")?w(e).children("tbody")[0]||e:e}function He(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Oe(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Pe(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(J.hasData(e)&&(o=J.access(e),a=J.set(t,o),l=o.events)){delete a.handle,a.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)w.event.add(t,i,l[i][n])}K.hasData(e)&&(s=K.access(e),u=w.extend({},s),K.set(t,u))}}function Me(e,t){var n=t.nodeName.toLowerCase();"input"===n&&pe.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function Re(e,t,n,r){t=a.apply([],t);var i,o,s,u,l,c,f=0,p=e.length,d=p-1,y=t[0],v=g(y);if(v||p>1&&"string"==typeof y&&!h.checkClone&&je.test(y))return e.each(function(i){var o=e.eq(i);v&&(t[0]=y.call(this,i,o.html())),Re(o,t,n,r)});if(p&&(i=xe(t,e[0].ownerDocument,!1,e,r),o=i.firstChild,1===i.childNodes.length&&(i=o),o||r)){for(u=(s=w.map(ye(i,"script"),He)).length;f<p;f++)l=i,f!==d&&(l=w.clone(l,!0,!0),u&&w.merge(s,ye(l,"script"))),n.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,w.map(s,Oe),f=0;f<u;f++)l=s[f],he.test(l.type||"")&&!J.access(l,"globalEval")&&w.contains(c,l)&&(l.src&&"module"!==(l.type||"").toLowerCase()?w._evalUrl&&w._evalUrl(l.src):m(l.textContent.replace(qe,""),c,l))}return e}function Ie(e,t,n){for(var r,i=t?w.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||w.cleanData(ye(r)),r.parentNode&&(n&&w.contains(r.ownerDocument,r)&&ve(ye(r,"script")),r.parentNode.removeChild(r));return e}w.extend({htmlPrefilter:function(e){return e.replace(Ne,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s=e.cloneNode(!0),u=w.contains(e.ownerDocument,e);if(!(h.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||w.isXMLDoc(e)))for(a=ye(s),r=0,i=(o=ye(e)).length;r<i;r++)Me(o[r],a[r]);if(t)if(n)for(o=o||ye(e),a=a||ye(s),r=0,i=o.length;r<i;r++)Pe(o[r],a[r]);else Pe(e,s);return(a=ye(s,"script")).length>0&&ve(a,!u&&ye(e,"script")),s},cleanData:function(e){for(var t,n,r,i=w.event.special,o=0;void 0!==(n=e[o]);o++)if(Y(n)){if(t=n[J.expando]){if(t.events)for(r in t.events)i[r]?w.event.remove(n,r):w.removeEvent(n,r,t.handle);n[J.expando]=void 0}n[K.expando]&&(n[K.expando]=void 0)}}}),w.fn.extend({detach:function(e){return Ie(this,e,!0)},remove:function(e){return Ie(this,e)},text:function(e){return z(this,function(e){return void 0===e?w.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Re(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Le(this,e).appendChild(e)})},prepend:function(){return Re(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Le(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Re(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Re(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(w.cleanData(ye(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return w.clone(this,e,t)})},html:function(e){return z(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ae.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=w.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(w.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return Re(this,arguments,function(t){var n=this.parentNode;w.inArray(this,e)<0&&(w.cleanData(ye(this)),n&&n.replaceChild(t,this))},e)}}),w.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){w.fn[e]=function(e){for(var n,r=[],i=w(e),o=i.length-1,a=0;a<=o;a++)n=a===o?this:this.clone(!0),w(i[a])[t](n),s.apply(r,n.get());return this.pushStack(r)}});var We=new RegExp("^("+re+")(?!px)[a-z%]+$","i"),$e=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)},Be=new RegExp(oe.join("|"),"i");!function(){function t(){if(c){l.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",c.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",be.appendChild(l).appendChild(c);var t=e.getComputedStyle(c);i="1%"!==t.top,u=12===n(t.marginLeft),c.style.right="60%",s=36===n(t.right),o=36===n(t.width),c.style.position="absolute",a=36===c.offsetWidth||"absolute",be.removeChild(l),c=null}}function n(e){return Math.round(parseFloat(e))}var i,o,a,s,u,l=r.createElement("div"),c=r.createElement("div");c.style&&(c.style.backgroundClip="content-box",c.cloneNode(!0).style.backgroundClip="",h.clearCloneStyle="content-box"===c.style.backgroundClip,w.extend(h,{boxSizingReliable:function(){return t(),o},pixelBoxStyles:function(){return t(),s},pixelPosition:function(){return t(),i},reliableMarginLeft:function(){return t(),u},scrollboxSize:function(){return t(),a}}))}();function Fe(e,t,n){var r,i,o,a,s=e.style;return(n=n||$e(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||w.contains(e.ownerDocument,e)||(a=w.style(e,t)),!h.pixelBoxStyles()&&We.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}var ze=/^(none|table(?!-c[ea]).+)/,Xe=/^--/,Ue={position:"absolute",visibility:"hidden",display:"block"},Ve={letterSpacing:"0",fontWeight:"400"},Ge=["Webkit","Moz","ms"],Ye=r.createElement("div").style;function Qe(e){if(e in Ye)return e;var t=e[0].toUpperCase()+e.slice(1),n=Ge.length;while(n--)if((e=Ge[n]+t)in Ye)return e}function Je(e){var t=w.cssProps[e];return t||(t=w.cssProps[e]=Qe(e)||e),t}function Ke(e,t,n){var r=ie.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ze(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=w.css(e,n+oe[a],!0,i)),r?("content"===n&&(u-=w.css(e,"padding"+oe[a],!0,i)),"margin"!==n&&(u-=w.css(e,"border"+oe[a]+"Width",!0,i))):(u+=w.css(e,"padding"+oe[a],!0,i),"padding"!==n?u+=w.css(e,"border"+oe[a]+"Width",!0,i):s+=w.css(e,"border"+oe[a]+"Width",!0,i));return!r&&o>=0&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))),u}function et(e,t,n){var r=$e(e),i=Fe(e,t,r),o="border-box"===w.css(e,"boxSizing",!1,r),a=o;if(We.test(i)){if(!n)return i;i="auto"}return a=a&&(h.boxSizingReliable()||i===e.style[t]),("auto"===i||!parseFloat(i)&&"inline"===w.css(e,"display",!1,r))&&(i=e["offset"+t[0].toUpperCase()+t.slice(1)],a=!0),(i=parseFloat(i)||0)+Ze(e,t,n||(o?"border":"content"),a,r,i)+"px"}w.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Fe(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=G(t),u=Xe.test(t),l=e.style;if(u||(t=Je(s)),a=w.cssHooks[t]||w.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"==(o=typeof n)&&(i=ie.exec(n))&&i[1]&&(n=ue(e,t,i),o="number"),null!=n&&n===n&&("number"===o&&(n+=i&&i[3]||(w.cssNumber[s]?"":"px")),h.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=G(t);return Xe.test(t)||(t=Je(s)),(a=w.cssHooks[t]||w.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Fe(e,t,r)),"normal"===i&&t in Ve&&(i=Ve[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),w.each(["height","width"],function(e,t){w.cssHooks[t]={get:function(e,n,r){if(n)return!ze.test(w.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?et(e,t,r):se(e,Ue,function(){return et(e,t,r)})},set:function(e,n,r){var i,o=$e(e),a="border-box"===w.css(e,"boxSizing",!1,o),s=r&&Ze(e,t,r,a,o);return a&&h.scrollboxSize()===o.position&&(s-=Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-parseFloat(o[t])-Ze(e,t,"border",!1,o)-.5)),s&&(i=ie.exec(n))&&"px"!==(i[3]||"px")&&(e.style[t]=n,n=w.css(e,t)),Ke(e,n,s)}}}),w.cssHooks.marginLeft=_e(h.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Fe(e,"marginLeft"))||e.getBoundingClientRect().left-se(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),w.each({margin:"",padding:"",border:"Width"},function(e,t){w.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+oe[r]+t]=o[r]||o[r-2]||o[0];return i}},"margin"!==e&&(w.cssHooks[e+t].set=Ke)}),w.fn.extend({css:function(e,t){return z(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=$e(e),i=t.length;a<i;a++)o[t[a]]=w.css(e,t[a],!1,r);return o}return void 0!==n?w.style(e,t,n):w.css(e,t)},e,t,arguments.length>1)}});function tt(e,t,n,r,i){return new tt.prototype.init(e,t,n,r,i)}w.Tween=tt,tt.prototype={constructor:tt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||w.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(w.cssNumber[n]?"":"px")},cur:function(){var e=tt.propHooks[this.prop];return e&&e.get?e.get(this):tt.propHooks._default.get(this)},run:function(e){var t,n=tt.propHooks[this.prop];return this.options.duration?this.pos=t=w.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):tt.propHooks._default.set(this),this}},tt.prototype.init.prototype=tt.prototype,tt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=w.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){w.fx.step[e.prop]?w.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[w.cssProps[e.prop]]&&!w.cssHooks[e.prop]?e.elem[e.prop]=e.now:w.style(e.elem,e.prop,e.now+e.unit)}}},tt.propHooks.scrollTop=tt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},w.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},w.fx=tt.prototype.init,w.fx.step={};var nt,rt,it=/^(?:toggle|show|hide)$/,ot=/queueHooks$/;function at(){rt&&(!1===r.hidden&&e.requestAnimationFrame?e.requestAnimationFrame(at):e.setTimeout(at,w.fx.interval),w.fx.tick())}function st(){return e.setTimeout(function(){nt=void 0}),nt=Date.now()}function ut(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=oe[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function lt(e,t,n){for(var r,i=(pt.tweeners[t]||[]).concat(pt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ct(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=J.get(e,"fxshow");n.queue||(null==(a=w._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,w.queue(e,"fx").length||a.empty.fire()})}));for(r in t)if(i=t[r],it.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||w.style(e,r)}if((u=!w.isEmptyObject(t))||!w.isEmptyObject(d)){f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=J.get(e,"display")),"none"===(c=w.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=w.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===w.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1;for(r in d)u||(y?"hidden"in y&&(g=y.hidden):y=J.access(e,"fxshow",{display:l}),o&&(y.hidden=!g),g&&fe([e],!0),p.done(function(){g||fe([e]),J.remove(e,"fxshow");for(r in d)w.style(e,r,d[r])})),u=lt(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}}function ft(e,t){var n,r,i,o,a;for(n in e)if(r=G(n),i=t[r],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=w.cssHooks[r])&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function pt(e,t,n){var r,i,o=0,a=pt.prefilters.length,s=w.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=nt||st(),n=Math.max(0,l.startTime+l.duration-t),r=1-(n/l.duration||0),o=0,a=l.tweens.length;o<a;o++)l.tweens[o].run(r);return s.notifyWith(e,[l,r,n]),r<1&&a?n:(a||s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:w.extend({},t),opts:w.extend(!0,{specialEasing:{},easing:w.easing._default},n),originalProperties:t,originalOptions:n,startTime:nt||st(),duration:n.duration,tweens:[],createTween:function(t,n){var r=w.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(ft(c,l.opts.specialEasing);o<a;o++)if(r=pt.prefilters[o].call(l,e,c,l.opts))return g(r.stop)&&(w._queueHooks(l.elem,l.opts.queue).stop=r.stop.bind(r)),r;return w.map(c,lt,l),g(l.opts.start)&&l.opts.start.call(e,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),w.fx.timer(w.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l}w.Animation=w.extend(pt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return ue(n.elem,e,ie.exec(t),n),n}]},tweener:function(e,t){g(e)?(t=e,e=["*"]):e=e.match(M);for(var n,r=0,i=e.length;r<i;r++)n=e[r],pt.tweeners[n]=pt.tweeners[n]||[],pt.tweeners[n].unshift(t)},prefilters:[ct],prefilter:function(e,t){t?pt.prefilters.unshift(e):pt.prefilters.push(e)}}),w.speed=function(e,t,n){var r=e&&"object"==typeof e?w.extend({},e):{complete:n||!n&&t||g(e)&&e,duration:e,easing:n&&t||t&&!g(t)&&t};return w.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in w.fx.speeds?r.duration=w.fx.speeds[r.duration]:r.duration=w.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){g(r.old)&&r.old.call(this),r.queue&&w.dequeue(this,r.queue)},r},w.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=w.isEmptyObject(e),o=w.speed(t,n,r),a=function(){var t=pt(this,w.extend({},e),o);(i||J.get(this,"finish"))&&t.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&!1!==e&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=w.timers,a=J.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&ot.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||w.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||"fx"),this.each(function(){var t,n=J.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=w.timers,a=r?r.length:0;for(n.finish=!0,w.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<a;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),w.each(["toggle","show","hide"],function(e,t){var n=w.fn[t];w.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ut(t,!0),e,r,i)}}),w.each({slideDown:ut("show"),slideUp:ut("hide"),slideToggle:ut("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){w.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),w.timers=[],w.fx.tick=function(){var e,t=0,n=w.timers;for(nt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||w.fx.stop(),nt=void 0},w.fx.timer=function(e){w.timers.push(e),w.fx.start()},w.fx.interval=13,w.fx.start=function(){rt||(rt=!0,at())},w.fx.stop=function(){rt=null},w.fx.speeds={slow:600,fast:200,_default:400},w.fn.delay=function(t,n){return t=w.fx?w.fx.speeds[t]||t:t,n=n||"fx",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=r.createElement("input"),t=r.createElement("select").appendChild(r.createElement("option"));e.type="checkbox",h.checkOn=""!==e.value,h.optSelected=t.selected,(e=r.createElement("input")).value="t",e.type="radio",h.radioValue="t"===e.value}();var dt,ht=w.expr.attrHandle;w.fn.extend({attr:function(e,t){return z(this,w.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){w.removeAttr(this,e)})}}),w.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?w.prop(e,t,n):(1===o&&w.isXMLDoc(e)||(i=w.attrHooks[t.toLowerCase()]||(w.expr.match.bool.test(t)?dt:void 0)),void 0!==n?null===n?void w.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=w.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!h.radioValue&&"radio"===t&&N(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(M);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),dt={set:function(e,t,n){return!1===t?w.removeAttr(e,n):e.setAttribute(n,n),n}},w.each(w.expr.match.bool.source.match(/\w+/g),function(e,t){var n=ht[t]||w.find.attr;ht[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=ht[a],ht[a]=i,i=null!=n(e,t,r)?a:null,ht[a]=o),i}});var gt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;w.fn.extend({prop:function(e,t){return z(this,w.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[w.propFix[e]||e]})}}),w.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&w.isXMLDoc(e)||(t=w.propFix[t]||t,i=w.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=w.find.attr(e,"tabindex");return t?parseInt(t,10):gt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),h.optSelected||(w.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),w.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){w.propFix[this.toLowerCase()]=this});function vt(e){return(e.match(M)||[]).join(" ")}function mt(e){return e.getAttribute&&e.getAttribute("class")||""}function xt(e){return Array.isArray(e)?e:"string"==typeof e?e.match(M)||[]:[]}w.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){w(this).addClass(e.call(this,t,mt(this)))});if((t=xt(e)).length)while(n=this[u++])if(i=mt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=t[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){w(this).removeClass(e.call(this,t,mt(this)))});if(!arguments.length)return this.attr("class","");if((t=xt(e)).length)while(n=this[u++])if(i=mt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=t[a++])while(r.indexOf(" "+o+" ")>-1)r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(e,t){var n=typeof e,r="string"===n||Array.isArray(e);return"boolean"==typeof t&&r?t?this.addClass(e):this.removeClass(e):g(e)?this.each(function(n){w(this).toggleClass(e.call(this,n,mt(this),t),t)}):this.each(function(){var t,i,o,a;if(r){i=0,o=w(this),a=xt(e);while(t=a[i++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else void 0!==e&&"boolean"!==n||((t=mt(this))&&J.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||!1===e?"":J.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&(" "+vt(mt(n))+" ").indexOf(t)>-1)return!0;return!1}});var bt=/\r/g;w.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=g(e),this.each(function(n){var i;1===this.nodeType&&(null==(i=r?e.call(this,n,w(this).val()):e)?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=w.map(i,function(e){return null==e?"":e+""})),(t=w.valHooks[this.type]||w.valHooks[this.nodeName.toLowerCase()])&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return(t=w.valHooks[i.type]||w.valHooks[i.nodeName.toLowerCase()])&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:"string"==typeof(n=i.value)?n.replace(bt,""):null==n?"":n}}}),w.extend({valHooks:{option:{get:function(e){var t=w.find.attr(e,"value");return null!=t?t:vt(w.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!N(n.parentNode,"optgroup"))){if(t=w(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=w.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=w.inArray(w.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),w.each(["radio","checkbox"],function(){w.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=w.inArray(w(e).val(),t)>-1}},h.checkOn||(w.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),h.focusin="onfocusin"in e;var wt=/^(?:focusinfocus|focusoutblur)$/,Tt=function(e){e.stopPropagation()};w.extend(w.event,{trigger:function(t,n,i,o){var a,s,u,l,c,p,d,h,v=[i||r],m=f.call(t,"type")?t.type:t,x=f.call(t,"namespace")?t.namespace.split("."):[];if(s=h=u=i=i||r,3!==i.nodeType&&8!==i.nodeType&&!wt.test(m+w.event.triggered)&&(m.indexOf(".")>-1&&(m=(x=m.split(".")).shift(),x.sort()),c=m.indexOf(":")<0&&"on"+m,t=t[w.expando]?t:new w.Event(m,"object"==typeof t&&t),t.isTrigger=o?2:3,t.namespace=x.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+x.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=i),n=null==n?[t]:w.makeArray(n,[t]),d=w.event.special[m]||{},o||!d.trigger||!1!==d.trigger.apply(i,n))){if(!o&&!d.noBubble&&!y(i)){for(l=d.delegateType||m,wt.test(l+m)||(s=s.parentNode);s;s=s.parentNode)v.push(s),u=s;u===(i.ownerDocument||r)&&v.push(u.defaultView||u.parentWindow||e)}a=0;while((s=v[a++])&&!t.isPropagationStopped())h=s,t.type=a>1?l:d.bindType||m,(p=(J.get(s,"events")||{})[t.type]&&J.get(s,"handle"))&&p.apply(s,n),(p=c&&s[c])&&p.apply&&Y(s)&&(t.result=p.apply(s,n),!1===t.result&&t.preventDefault());return t.type=m,o||t.isDefaultPrevented()||d._default&&!1!==d._default.apply(v.pop(),n)||!Y(i)||c&&g(i[m])&&!y(i)&&((u=i[c])&&(i[c]=null),w.event.triggered=m,t.isPropagationStopped()&&h.addEventListener(m,Tt),i[m](),t.isPropagationStopped()&&h.removeEventListener(m,Tt),w.event.triggered=void 0,u&&(i[c]=u)),t.result}},simulate:function(e,t,n){var r=w.extend(new w.Event,n,{type:e,isSimulated:!0});w.event.trigger(r,null,t)}}),w.fn.extend({trigger:function(e,t){return this.each(function(){w.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return w.event.trigger(e,t,n,!0)}}),h.focusin||w.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){w.event.simulate(t,e.target,w.event.fix(e))};w.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=J.access(r,t);i||r.addEventListener(e,n,!0),J.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=J.access(r,t)-1;i?J.access(r,t,i):(r.removeEventListener(e,n,!0),J.remove(r,t))}}});var Ct=e.location,Et=Date.now(),kt=/\?/;w.parseXML=function(t){var n;if(!t||"string"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,"text/xml")}catch(e){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||w.error("Invalid XML: "+t),n};var St=/\[\]$/,Dt=/\r?\n/g,Nt=/^(?:submit|button|image|reset|file)$/i,At=/^(?:input|select|textarea|keygen)/i;function jt(e,t,n,r){var i;if(Array.isArray(t))w.each(t,function(t,i){n||St.test(e)?r(e,i):jt(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,n,r)});else if(n||"object"!==x(t))r(e,t);else for(i in t)jt(e+"["+i+"]",t[i],n,r)}w.param=function(e,t){var n,r=[],i=function(e,t){var n=g(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(Array.isArray(e)||e.jquery&&!w.isPlainObject(e))w.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join("&")},w.fn.extend({serialize:function(){return w.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=w.prop(this,"elements");return e?w.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!w(this).is(":disabled")&&At.test(this.nodeName)&&!Nt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=w(this).val();return null==n?null:Array.isArray(n)?w.map(n,function(e){return{name:t.name,value:e.replace(Dt,"\r\n")}}):{name:t.name,value:n.replace(Dt,"\r\n")}}).get()}});var qt=/%20/g,Lt=/#.*$/,Ht=/([?&])_=[^&]*/,Ot=/^(.*?):[ \t]*([^\r\n]*)$/gm,Pt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Mt=/^(?:GET|HEAD)$/,Rt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Bt=r.createElement("a");Bt.href=Ct.href;function Ft(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(M)||[];if(g(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function _t(e,t,n,r){var i={},o=e===Wt;function a(s){var u;return i[s]=!0,w.each(e[s]||[],function(e,s){var l=s(t,n,r);return"string"!=typeof l||o||i[l]?o?!(u=l):void 0:(t.dataTypes.unshift(l),a(l),!1)}),u}return a(t.dataTypes[0])||!i["*"]&&a("*")}function zt(e,t){var n,r,i=w.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&w.extend(!0,e,r),e}function Xt(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}function Ut(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}w.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ct.href,type:"GET",isLocal:Pt.test(Ct.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":w.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,w.ajaxSettings),t):zt(w.ajaxSettings,e)},ajaxPrefilter:Ft(It),ajaxTransport:Ft(Wt),ajax:function(t,n){"object"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=w.ajaxSetup({},n),g=h.context||h,y=h.context&&(g.nodeType||g.jquery)?w(g):w.event,v=w.Deferred(),m=w.Callbacks("once memory"),x=h.statusCode||{},b={},T={},C="canceled",E={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s){s={};while(t=Ot.exec(a))s[t[1].toLowerCase()]=t[2]}t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=T[e.toLowerCase()]=T[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)E.always(e[E.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||C;return i&&i.abort(t),k(0,t),this}};if(v.promise(E),h.url=((t||h.url||Ct.href)+"").replace(Rt,Ct.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(M)||[""],null==h.crossDomain){l=r.createElement("a");try{l.href=h.url,l.href=l.href,h.crossDomain=Bt.protocol+"//"+Bt.host!=l.protocol+"//"+l.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=w.param(h.data,h.traditional)),_t(It,h,n,E),c)return E;(f=w.event&&h.global)&&0==w.active++&&w.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!Mt.test(h.type),o=h.url.replace(Lt,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(qt,"+")):(d=h.url.slice(o.length),h.data&&(h.processData||"string"==typeof h.data)&&(o+=(kt.test(o)?"&":"?")+h.data,delete h.data),!1===h.cache&&(o=o.replace(Ht,"$1"),d=(kt.test(o)?"&":"?")+"_="+Et+++d),h.url=o+d),h.ifModified&&(w.lastModified[o]&&E.setRequestHeader("If-Modified-Since",w.lastModified[o]),w.etag[o]&&E.setRequestHeader("If-None-Match",w.etag[o])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&E.setRequestHeader("Content-Type",h.contentType),E.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+$t+"; q=0.01":""):h.accepts["*"]);for(p in h.headers)E.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,E,h)||c))return E.abort();if(C="abort",m.add(h.complete),E.done(h.success),E.fail(h.error),i=_t(Wt,h,n,E)){if(E.readyState=1,f&&y.trigger("ajaxSend",[E,h]),c)return E;h.async&&h.timeout>0&&(u=e.setTimeout(function(){E.abort("timeout")},h.timeout));try{c=!1,i.send(b,k)}catch(e){if(c)throw e;k(-1,e)}}else k(-1,"No Transport");function k(t,n,r,s){var l,p,d,b,T,C=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||"",E.readyState=t>0?4:0,l=t>=200&&t<300||304===t,r&&(b=Xt(h,E,r)),b=Ut(h,b,E,l),l?(h.ifModified&&((T=E.getResponseHeader("Last-Modified"))&&(w.lastModified[o]=T),(T=E.getResponseHeader("etag"))&&(w.etag[o]=T)),204===t||"HEAD"===h.type?C="nocontent":304===t?C="notmodified":(C=b.state,p=b.data,l=!(d=b.error))):(d=C,!t&&C||(C="error",t<0&&(t=0))),E.status=t,E.statusText=(n||C)+"",l?v.resolveWith(g,[p,C,E]):v.rejectWith(g,[E,C,d]),E.statusCode(x),x=void 0,f&&y.trigger(l?"ajaxSuccess":"ajaxError",[E,h,l?p:d]),m.fireWith(g,[E,C]),f&&(y.trigger("ajaxComplete",[E,h]),--w.active||w.event.trigger("ajaxStop")))}return E},getJSON:function(e,t,n){return w.get(e,t,n,"json")},getScript:function(e,t){return w.get(e,void 0,t,"script")}}),w.each(["get","post"],function(e,t){w[t]=function(e,n,r,i){return g(n)&&(i=i||r,r=n,n=void 0),w.ajax(w.extend({url:e,type:t,dataType:i,data:n,success:r},w.isPlainObject(e)&&e))}}),w._evalUrl=function(e){return w.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},w.fn.extend({wrapAll:function(e){var t;return this[0]&&(g(e)&&(e=e.call(this[0])),t=w(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return g(e)?this.each(function(t){w(this).wrapInner(e.call(this,t))}):this.each(function(){var t=w(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=g(e);return this.each(function(n){w(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){w(this).replaceWith(this.childNodes)}),this}}),w.expr.pseudos.hidden=function(e){return!w.expr.pseudos.visible(e)},w.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},w.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(e){}};var Vt={0:200,1223:204},Gt=w.ajaxSettings.xhr();h.cors=!!Gt&&"withCredentials"in Gt,h.ajax=Gt=!!Gt,w.ajaxTransport(function(t){var n,r;if(h.cors||Gt&&!t.crossDomain)return{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");for(a in i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.ontimeout=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o(Vt[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=s.ontimeout=n("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n("abort");try{s.send(t.hasContent&&t.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}}),w.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),w.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return w.globalEval(e),e}}}),w.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),w.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(i,o){t=w("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&o("error"===e.type?404:200,e.type)}),r.head.appendChild(t[0])},abort:function(){n&&n()}}}});var Yt=[],Qt=/(=)\?(?=&|$)|\?\?/;w.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Yt.pop()||w.expando+"_"+Et++;return this[e]=!0,e}}),w.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,s=!1!==t.jsonp&&(Qt.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Qt.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=g(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(Qt,"$1"+i):!1!==t.jsonp&&(t.url+=(kt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||w.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?w(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,Yt.push(i)),a&&g(o)&&o(a[0]),a=o=void 0}),"script"}),h.createHTMLDocument=function(){var e=r.implementation.createHTMLDocument("").body;return e.innerHTML="<form></form><form></form>",2===e.childNodes.length}(),w.parseHTML=function(e,t,n){if("string"!=typeof e)return[];"boolean"==typeof t&&(n=t,t=!1);var i,o,a;return t||(h.createHTMLDocument?((i=(t=r.implementation.createHTMLDocument("")).createElement("base")).href=r.location.href,t.head.appendChild(i)):t=r),o=A.exec(e),a=!n&&[],o?[t.createElement(o[1])]:(o=xe([e],t,a),a&&a.length&&w(a).remove(),w.merge([],o.childNodes))},w.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return s>-1&&(r=vt(e.slice(s)),e=e.slice(0,s)),g(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&w.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?w("<div>").append(w.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},w.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){w.fn[t]=function(e){return this.on(t,e)}}),w.expr.pseudos.animated=function(e){return w.grep(w.timers,function(t){return e===t.elem}).length},w.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l,c=w.css(e,"position"),f=w(e),p={};"static"===c&&(e.style.position="relative"),s=f.offset(),o=w.css(e,"top"),u=w.css(e,"left"),(l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1)?(a=(r=f.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),g(t)&&(t=t.call(e,n,w.extend({},s))),null!=t.top&&(p.top=t.top-s.top+a),null!=t.left&&(p.left=t.left-s.left+i),"using"in t?t.using.call(e,p):f.css(p)}},w.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){w.offset.setOffset(this,e,t)});var t,n,r=this[0];if(r)return r.getClientRects().length?(t=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:t.top+n.pageYOffset,left:t.left+n.pageXOffset}):{top:0,left:0}},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===w.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===w.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=w(e).offset()).top+=w.css(e,"borderTopWidth",!0),i.left+=w.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-w.css(r,"marginTop",!0),left:t.left-i.left-w.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===w.css(e,"position"))e=e.offsetParent;return e||be})}}),w.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;w.fn[e]=function(r){return z(this,function(e,r,i){var o;if(y(e)?o=e:9===e.nodeType&&(o=e.defaultView),void 0===i)return o?o[t]:e[r];o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i},e,r,arguments.length)}}),w.each(["top","left"],function(e,t){w.cssHooks[t]=_e(h.pixelPosition,function(e,n){if(n)return n=Fe(e,t),We.test(n)?w(e).position()[t]+"px":n})}),w.each({Height:"height",Width:"width"},function(e,t){w.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){w.fn[r]=function(i,o){var a=arguments.length&&(n||"boolean"!=typeof i),s=n||(!0===i||!0===o?"margin":"border");return z(this,function(t,n,i){var o;return y(t)?0===r.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?w.css(t,n,s):w.style(t,n,i,s)},t,a?i:void 0,a)}})}),w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){w.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),w.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),w.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),w.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),g(e))return r=o.call(arguments,2),i=function(){return e.apply(t||this,r.concat(o.call(arguments)))},i.guid=e.guid=e.guid||w.guid++,i},w.holdReady=function(e){e?w.readyWait++:w.ready(!0)},w.isArray=Array.isArray,w.parseJSON=JSON.parse,w.nodeName=N,w.isFunction=g,w.isWindow=y,w.camelCase=G,w.type=x,w.now=Date.now,w.isNumeric=function(e){var t=w.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return w});var Jt=e.jQuery,Kt=e.$;return w.noConflict=function(t){return e.$===w&&(e.$=Kt),t&&e.jQuery===w&&(e.jQuery=Jt),w},t||(e.jQuery=e.$=w),w});

//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
!function(){var n="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this||{},r=n._,e=Array.prototype,o=Object.prototype,s="undefined"!=typeof Symbol?Symbol.prototype:null,u=e.push,c=e.slice,p=o.toString,i=o.hasOwnProperty,t=Array.isArray,a=Object.keys,l=Object.create,f=function(){},h=function(n){return n instanceof h?n:this instanceof h?void(this._wrapped=n):new h(n)};"undefined"==typeof exports||exports.nodeType?n._=h:("undefined"!=typeof module&&!module.nodeType&&module.exports&&(exports=module.exports=h),exports._=h),h.VERSION="1.9.1";var v,y=function(u,i,n){if(void 0===i)return u;switch(null==n?3:n){case 1:return function(n){return u.call(i,n)};case 3:return function(n,r,t){return u.call(i,n,r,t)};case 4:return function(n,r,t,e){return u.call(i,n,r,t,e)}}return function(){return u.apply(i,arguments)}},d=function(n,r,t){return h.iteratee!==v?h.iteratee(n,r):null==n?h.identity:h.isFunction(n)?y(n,r,t):h.isObject(n)&&!h.isArray(n)?h.matcher(n):h.property(n)};h.iteratee=v=function(n,r){return d(n,r,1/0)};var g=function(u,i){return i=null==i?u.length-1:+i,function(){for(var n=Math.max(arguments.length-i,0),r=Array(n),t=0;t<n;t++)r[t]=arguments[t+i];switch(i){case 0:return u.call(this,r);case 1:return u.call(this,arguments[0],r);case 2:return u.call(this,arguments[0],arguments[1],r)}var e=Array(i+1);for(t=0;t<i;t++)e[t]=arguments[t];return e[i]=r,u.apply(this,e)}},m=function(n){if(!h.isObject(n))return{};if(l)return l(n);f.prototype=n;var r=new f;return f.prototype=null,r},b=function(r){return function(n){return null==n?void 0:n[r]}},j=function(n,r){return null!=n&&i.call(n,r)},x=function(n,r){for(var t=r.length,e=0;e<t;e++){if(null==n)return;n=n[r[e]]}return t?n:void 0},_=Math.pow(2,53)-1,A=b("length"),w=function(n){var r=A(n);return"number"==typeof r&&0<=r&&r<=_};h.each=h.forEach=function(n,r,t){var e,u;if(r=y(r,t),w(n))for(e=0,u=n.length;e<u;e++)r(n[e],e,n);else{var i=h.keys(n);for(e=0,u=i.length;e<u;e++)r(n[i[e]],i[e],n)}return n},h.map=h.collect=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=Array(u),o=0;o<u;o++){var a=e?e[o]:o;i[o]=r(n[a],a,n)}return i};var O=function(c){return function(n,r,t,e){var u=3<=arguments.length;return function(n,r,t,e){var u=!w(n)&&h.keys(n),i=(u||n).length,o=0<c?0:i-1;for(e||(t=n[u?u[o]:o],o+=c);0<=o&&o<i;o+=c){var a=u?u[o]:o;t=r(t,n[a],a,n)}return t}(n,y(r,e,4),t,u)}};h.reduce=h.foldl=h.inject=O(1),h.reduceRight=h.foldr=O(-1),h.find=h.detect=function(n,r,t){var e=(w(n)?h.findIndex:h.findKey)(n,r,t);if(void 0!==e&&-1!==e)return n[e]},h.filter=h.select=function(n,e,r){var u=[];return e=d(e,r),h.each(n,function(n,r,t){e(n,r,t)&&u.push(n)}),u},h.reject=function(n,r,t){return h.filter(n,h.negate(d(r)),t)},h.every=h.all=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(!r(n[o],o,n))return!1}return!0},h.some=h.any=function(n,r,t){r=d(r,t);for(var e=!w(n)&&h.keys(n),u=(e||n).length,i=0;i<u;i++){var o=e?e[i]:i;if(r(n[o],o,n))return!0}return!1},h.contains=h.includes=h.include=function(n,r,t,e){return w(n)||(n=h.values(n)),("number"!=typeof t||e)&&(t=0),0<=h.indexOf(n,r,t)},h.invoke=g(function(n,t,e){var u,i;return h.isFunction(t)?i=t:h.isArray(t)&&(u=t.slice(0,-1),t=t[t.length-1]),h.map(n,function(n){var r=i;if(!r){if(u&&u.length&&(n=x(n,u)),null==n)return;r=n[t]}return null==r?r:r.apply(n,e)})}),h.pluck=function(n,r){return h.map(n,h.property(r))},h.where=function(n,r){return h.filter(n,h.matcher(r))},h.findWhere=function(n,r){return h.find(n,h.matcher(r))},h.max=function(n,e,r){var t,u,i=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&i<t&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){u=e(n,r,t),(o<u||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},h.min=function(n,e,r){var t,u,i=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,c=(n=w(n)?n:h.values(n)).length;a<c;a++)null!=(t=n[a])&&t<i&&(i=t);else e=d(e,r),h.each(n,function(n,r,t){((u=e(n,r,t))<o||u===1/0&&i===1/0)&&(i=n,o=u)});return i},h.shuffle=function(n){return h.sample(n,1/0)},h.sample=function(n,r,t){if(null==r||t)return w(n)||(n=h.values(n)),n[h.random(n.length-1)];var e=w(n)?h.clone(n):h.values(n),u=A(e);r=Math.max(Math.min(r,u),0);for(var i=u-1,o=0;o<r;o++){var a=h.random(o,i),c=e[o];e[o]=e[a],e[a]=c}return e.slice(0,r)},h.sortBy=function(n,e,r){var u=0;return e=d(e,r),h.pluck(h.map(n,function(n,r,t){return{value:n,index:u++,criteria:e(n,r,t)}}).sort(function(n,r){var t=n.criteria,e=r.criteria;if(t!==e){if(e<t||void 0===t)return 1;if(t<e||void 0===e)return-1}return n.index-r.index}),"value")};var k=function(o,r){return function(e,u,n){var i=r?[[],[]]:{};return u=d(u,n),h.each(e,function(n,r){var t=u(n,r,e);o(i,n,t)}),i}};h.groupBy=k(function(n,r,t){j(n,t)?n[t].push(r):n[t]=[r]}),h.indexBy=k(function(n,r,t){n[t]=r}),h.countBy=k(function(n,r,t){j(n,t)?n[t]++:n[t]=1});var S=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;h.toArray=function(n){return n?h.isArray(n)?c.call(n):h.isString(n)?n.match(S):w(n)?h.map(n,h.identity):h.values(n):[]},h.size=function(n){return null==n?0:w(n)?n.length:h.keys(n).length},h.partition=k(function(n,r,t){n[t?0:1].push(r)},!0),h.first=h.head=h.take=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[0]:h.initial(n,n.length-r)},h.initial=function(n,r,t){return c.call(n,0,Math.max(0,n.length-(null==r||t?1:r)))},h.last=function(n,r,t){return null==n||n.length<1?null==r?void 0:[]:null==r||t?n[n.length-1]:h.rest(n,Math.max(0,n.length-r))},h.rest=h.tail=h.drop=function(n,r,t){return c.call(n,null==r||t?1:r)},h.compact=function(n){return h.filter(n,Boolean)};var M=function(n,r,t,e){for(var u=(e=e||[]).length,i=0,o=A(n);i<o;i++){var a=n[i];if(w(a)&&(h.isArray(a)||h.isArguments(a)))if(r)for(var c=0,l=a.length;c<l;)e[u++]=a[c++];else M(a,r,t,e),u=e.length;else t||(e[u++]=a)}return e};h.flatten=function(n,r){return M(n,r,!1)},h.without=g(function(n,r){return h.difference(n,r)}),h.uniq=h.unique=function(n,r,t,e){h.isBoolean(r)||(e=t,t=r,r=!1),null!=t&&(t=d(t,e));for(var u=[],i=[],o=0,a=A(n);o<a;o++){var c=n[o],l=t?t(c,o,n):c;r&&!t?(o&&i===l||u.push(c),i=l):t?h.contains(i,l)||(i.push(l),u.push(c)):h.contains(u,c)||u.push(c)}return u},h.union=g(function(n){return h.uniq(M(n,!0,!0))}),h.intersection=function(n){for(var r=[],t=arguments.length,e=0,u=A(n);e<u;e++){var i=n[e];if(!h.contains(r,i)){var o;for(o=1;o<t&&h.contains(arguments[o],i);o++);o===t&&r.push(i)}}return r},h.difference=g(function(n,r){return r=M(r,!0,!0),h.filter(n,function(n){return!h.contains(r,n)})}),h.unzip=function(n){for(var r=n&&h.max(n,A).length||0,t=Array(r),e=0;e<r;e++)t[e]=h.pluck(n,e);return t},h.zip=g(h.unzip),h.object=function(n,r){for(var t={},e=0,u=A(n);e<u;e++)r?t[n[e]]=r[e]:t[n[e][0]]=n[e][1];return t};var F=function(i){return function(n,r,t){r=d(r,t);for(var e=A(n),u=0<i?0:e-1;0<=u&&u<e;u+=i)if(r(n[u],u,n))return u;return-1}};h.findIndex=F(1),h.findLastIndex=F(-1),h.sortedIndex=function(n,r,t,e){for(var u=(t=d(t,e,1))(r),i=0,o=A(n);i<o;){var a=Math.floor((i+o)/2);t(n[a])<u?i=a+1:o=a}return i};var E=function(i,o,a){return function(n,r,t){var e=0,u=A(n);if("number"==typeof t)0<i?e=0<=t?t:Math.max(t+u,e):u=0<=t?Math.min(t+1,u):t+u+1;else if(a&&t&&u)return n[t=a(n,r)]===r?t:-1;if(r!=r)return 0<=(t=o(c.call(n,e,u),h.isNaN))?t+e:-1;for(t=0<i?e:u-1;0<=t&&t<u;t+=i)if(n[t]===r)return t;return-1}};h.indexOf=E(1,h.findIndex,h.sortedIndex),h.lastIndexOf=E(-1,h.findLastIndex),h.range=function(n,r,t){null==r&&(r=n||0,n=0),t||(t=r<n?-1:1);for(var e=Math.max(Math.ceil((r-n)/t),0),u=Array(e),i=0;i<e;i++,n+=t)u[i]=n;return u},h.chunk=function(n,r){if(null==r||r<1)return[];for(var t=[],e=0,u=n.length;e<u;)t.push(c.call(n,e,e+=r));return t};var N=function(n,r,t,e,u){if(!(e instanceof r))return n.apply(t,u);var i=m(n.prototype),o=n.apply(i,u);return h.isObject(o)?o:i};h.bind=g(function(r,t,e){if(!h.isFunction(r))throw new TypeError("Bind must be called on a function");var u=g(function(n){return N(r,u,t,this,e.concat(n))});return u}),h.partial=g(function(u,i){var o=h.partial.placeholder,a=function(){for(var n=0,r=i.length,t=Array(r),e=0;e<r;e++)t[e]=i[e]===o?arguments[n++]:i[e];for(;n<arguments.length;)t.push(arguments[n++]);return N(u,a,this,this,t)};return a}),(h.partial.placeholder=h).bindAll=g(function(n,r){var t=(r=M(r,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var e=r[t];n[e]=h.bind(n[e],n)}}),h.memoize=function(e,u){var i=function(n){var r=i.cache,t=""+(u?u.apply(this,arguments):n);return j(r,t)||(r[t]=e.apply(this,arguments)),r[t]};return i.cache={},i},h.delay=g(function(n,r,t){return setTimeout(function(){return n.apply(null,t)},r)}),h.defer=h.partial(h.delay,h,1),h.throttle=function(t,e,u){var i,o,a,c,l=0;u||(u={});var f=function(){l=!1===u.leading?0:h.now(),i=null,c=t.apply(o,a),i||(o=a=null)},n=function(){var n=h.now();l||!1!==u.leading||(l=n);var r=e-(n-l);return o=this,a=arguments,r<=0||e<r?(i&&(clearTimeout(i),i=null),l=n,c=t.apply(o,a),i||(o=a=null)):i||!1===u.trailing||(i=setTimeout(f,r)),c};return n.cancel=function(){clearTimeout(i),l=0,i=o=a=null},n},h.debounce=function(t,e,u){var i,o,a=function(n,r){i=null,r&&(o=t.apply(n,r))},n=g(function(n){if(i&&clearTimeout(i),u){var r=!i;i=setTimeout(a,e),r&&(o=t.apply(this,n))}else i=h.delay(a,e,this,n);return o});return n.cancel=function(){clearTimeout(i),i=null},n},h.wrap=function(n,r){return h.partial(r,n)},h.negate=function(n){return function(){return!n.apply(this,arguments)}},h.compose=function(){var t=arguments,e=t.length-1;return function(){for(var n=e,r=t[e].apply(this,arguments);n--;)r=t[n].call(this,r);return r}},h.after=function(n,r){return function(){if(--n<1)return r.apply(this,arguments)}},h.before=function(n,r){var t;return function(){return 0<--n&&(t=r.apply(this,arguments)),n<=1&&(r=null),t}},h.once=h.partial(h.before,2),h.restArguments=g;var I=!{toString:null}.propertyIsEnumerable("toString"),T=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],B=function(n,r){var t=T.length,e=n.constructor,u=h.isFunction(e)&&e.prototype||o,i="constructor";for(j(n,i)&&!h.contains(r,i)&&r.push(i);t--;)(i=T[t])in n&&n[i]!==u[i]&&!h.contains(r,i)&&r.push(i)};h.keys=function(n){if(!h.isObject(n))return[];if(a)return a(n);var r=[];for(var t in n)j(n,t)&&r.push(t);return I&&B(n,r),r},h.allKeys=function(n){if(!h.isObject(n))return[];var r=[];for(var t in n)r.push(t);return I&&B(n,r),r},h.values=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=n[r[u]];return e},h.mapObject=function(n,r,t){r=d(r,t);for(var e=h.keys(n),u=e.length,i={},o=0;o<u;o++){var a=e[o];i[a]=r(n[a],a,n)}return i},h.pairs=function(n){for(var r=h.keys(n),t=r.length,e=Array(t),u=0;u<t;u++)e[u]=[r[u],n[r[u]]];return e},h.invert=function(n){for(var r={},t=h.keys(n),e=0,u=t.length;e<u;e++)r[n[t[e]]]=t[e];return r},h.functions=h.methods=function(n){var r=[];for(var t in n)h.isFunction(n[t])&&r.push(t);return r.sort()};var R=function(c,l){return function(n){var r=arguments.length;if(l&&(n=Object(n)),r<2||null==n)return n;for(var t=1;t<r;t++)for(var e=arguments[t],u=c(e),i=u.length,o=0;o<i;o++){var a=u[o];l&&void 0!==n[a]||(n[a]=e[a])}return n}};h.extend=R(h.allKeys),h.extendOwn=h.assign=R(h.keys),h.findKey=function(n,r,t){r=d(r,t);for(var e,u=h.keys(n),i=0,o=u.length;i<o;i++)if(r(n[e=u[i]],e,n))return e};var q,K,z=function(n,r,t){return r in t};h.pick=g(function(n,r){var t={},e=r[0];if(null==n)return t;h.isFunction(e)?(1<r.length&&(e=y(e,r[1])),r=h.allKeys(n)):(e=z,r=M(r,!1,!1),n=Object(n));for(var u=0,i=r.length;u<i;u++){var o=r[u],a=n[o];e(a,o,n)&&(t[o]=a)}return t}),h.omit=g(function(n,t){var r,e=t[0];return h.isFunction(e)?(e=h.negate(e),1<t.length&&(r=t[1])):(t=h.map(M(t,!1,!1),String),e=function(n,r){return!h.contains(t,r)}),h.pick(n,e,r)}),h.defaults=R(h.allKeys,!0),h.create=function(n,r){var t=m(n);return r&&h.extendOwn(t,r),t},h.clone=function(n){return h.isObject(n)?h.isArray(n)?n.slice():h.extend({},n):n},h.tap=function(n,r){return r(n),n},h.isMatch=function(n,r){var t=h.keys(r),e=t.length;if(null==n)return!e;for(var u=Object(n),i=0;i<e;i++){var o=t[i];if(r[o]!==u[o]||!(o in u))return!1}return!0},q=function(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(null==n||null==r)return!1;if(n!=n)return r!=r;var u=typeof n;return("function"===u||"object"===u||"object"==typeof r)&&K(n,r,t,e)},K=function(n,r,t,e){n instanceof h&&(n=n._wrapped),r instanceof h&&(r=r._wrapped);var u=p.call(n);if(u!==p.call(r))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+r;case"[object Number]":return+n!=+n?+r!=+r:0==+n?1/+n==1/r:+n==+r;case"[object Date]":case"[object Boolean]":return+n==+r;case"[object Symbol]":return s.valueOf.call(n)===s.valueOf.call(r)}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof r)return!1;var o=n.constructor,a=r.constructor;if(o!==a&&!(h.isFunction(o)&&o instanceof o&&h.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in r)return!1}e=e||[];for(var c=(t=t||[]).length;c--;)if(t[c]===n)return e[c]===r;if(t.push(n),e.push(r),i){if((c=n.length)!==r.length)return!1;for(;c--;)if(!q(n[c],r[c],t,e))return!1}else{var l,f=h.keys(n);if(c=f.length,h.keys(r).length!==c)return!1;for(;c--;)if(l=f[c],!j(r,l)||!q(n[l],r[l],t,e))return!1}return t.pop(),e.pop(),!0},h.isEqual=function(n,r){return q(n,r)},h.isEmpty=function(n){return null==n||(w(n)&&(h.isArray(n)||h.isString(n)||h.isArguments(n))?0===n.length:0===h.keys(n).length)},h.isElement=function(n){return!(!n||1!==n.nodeType)},h.isArray=t||function(n){return"[object Array]"===p.call(n)},h.isObject=function(n){var r=typeof n;return"function"===r||"object"===r&&!!n},h.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],function(r){h["is"+r]=function(n){return p.call(n)==="[object "+r+"]"}}),h.isArguments(arguments)||(h.isArguments=function(n){return j(n,"callee")});var D=n.document&&n.document.childNodes;"function"!=typeof/./&&"object"!=typeof Int8Array&&"function"!=typeof D&&(h.isFunction=function(n){return"function"==typeof n||!1}),h.isFinite=function(n){return!h.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},h.isNaN=function(n){return h.isNumber(n)&&isNaN(n)},h.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===p.call(n)},h.isNull=function(n){return null===n},h.isUndefined=function(n){return void 0===n},h.has=function(n,r){if(!h.isArray(r))return j(n,r);for(var t=r.length,e=0;e<t;e++){var u=r[e];if(null==n||!i.call(n,u))return!1;n=n[u]}return!!t},h.noConflict=function(){return n._=r,this},h.identity=function(n){return n},h.constant=function(n){return function(){return n}},h.noop=function(){},h.property=function(r){return h.isArray(r)?function(n){return x(n,r)}:b(r)},h.propertyOf=function(r){return null==r?function(){}:function(n){return h.isArray(n)?x(r,n):r[n]}},h.matcher=h.matches=function(r){return r=h.extendOwn({},r),function(n){return h.isMatch(n,r)}},h.times=function(n,r,t){var e=Array(Math.max(0,n));r=y(r,t,1);for(var u=0;u<n;u++)e[u]=r(u);return e},h.random=function(n,r){return null==r&&(r=n,n=0),n+Math.floor(Math.random()*(r-n+1))},h.now=Date.now||function(){return(new Date).getTime()};var L={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},P=h.invert(L),W=function(r){var t=function(n){return r[n]},n="(?:"+h.keys(r).join("|")+")",e=RegExp(n),u=RegExp(n,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};h.escape=W(L),h.unescape=W(P),h.result=function(n,r,t){h.isArray(r)||(r=[r]);var e=r.length;if(!e)return h.isFunction(t)?t.call(n):t;for(var u=0;u<e;u++){var i=null==n?void 0:n[r[u]];void 0===i&&(i=t,u=e),n=h.isFunction(i)?i.call(n):i}return n};var C=0;h.uniqueId=function(n){var r=++C+"";return n?n+r:r},h.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var J=/(.)^/,U={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},V=/\\|'|\r|\n|\u2028|\u2029/g,$=function(n){return"\\"+U[n]};h.template=function(i,n,r){!n&&r&&(n=r),n=h.defaults({},n,h.templateSettings);var t,e=RegExp([(n.escape||J).source,(n.interpolate||J).source,(n.evaluate||J).source].join("|")+"|$","g"),o=0,a="__p+='";i.replace(e,function(n,r,t,e,u){return a+=i.slice(o,u).replace(V,$),o=u+n.length,r?a+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":t?a+="'+\n((__t=("+t+"))==null?'':__t)+\n'":e&&(a+="';\n"+e+"\n__p+='"),n}),a+="';\n",n.variable||(a="with(obj||{}){\n"+a+"}\n"),a="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+a+"return __p;\n";try{t=new Function(n.variable||"obj","_",a)}catch(n){throw n.source=a,n}var u=function(n){return t.call(this,n,h)},c=n.variable||"obj";return u.source="function("+c+"){\n"+a+"}",u},h.chain=function(n){var r=h(n);return r._chain=!0,r};var G=function(n,r){return n._chain?h(r).chain():r};h.mixin=function(t){return h.each(h.functions(t),function(n){var r=h[n]=t[n];h.prototype[n]=function(){var n=[this._wrapped];return u.apply(n,arguments),G(this,r.apply(h,n))}}),h},h.mixin(h),h.each(["pop","push","reverse","shift","sort","splice","unshift"],function(r){var t=e[r];h.prototype[r]=function(){var n=this._wrapped;return t.apply(n,arguments),"shift"!==r&&"splice"!==r||0!==n.length||delete n[0],G(this,n)}}),h.each(["concat","join","slice"],function(n){var r=e[n];h.prototype[n]=function(){return G(this,r.apply(this._wrapped,arguments))}}),h.prototype.value=function(){return this._wrapped},h.prototype.valueOf=h.prototype.toJSON=h.prototype.value,h.prototype.toString=function(){return String(this._wrapped)},"function"==typeof define&&define.amd&&define("underscore",[],function(){return h})}();
define("underscore-min", (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
                return _.noConflict();
            };
        ret = fn.apply(global, arguments);
        return ret || global._;
    };
}(this)));

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/Constants',[],function() {
    var Constants = function() {};

    /**
     * @namespace
     * ANIMATION
     * @property {String} Inertia - Inertia animation
     * @property {String} Interpolated - Interpolated animation
     * @property {String} Path - Path animation
     * @property {String} Segmented - Segmented animation
     */
    Constants.ANIMATION = {
        Inertia: "Inertia",
        Interpolated: "Interpolated",
        Path: "Path",
        Segmented: "Segmented"
    };

    /**
     * @namespace
     * CONTEXT
     * @property {String} Planet - Planet context
     * @property {String} Sky - Sky context
     * @property {String} Ground - Ground context
     */
    Constants.CONTEXT = {
        Planet: "Planet",
        Sky: "Sky",
        Ground: "Ground"
    };

    /**
     * @namespace
     * GLOBE
     * @property {String} Planet - Planet
     * @property {String} Sky - Sky
     */
    Constants.GLOBE = {
        Planet: "Planet",
        Sky: "Sky"
    };

    /**
     * @namespace
     * LAYER
     * @property {String} WMS - Web Map Service
     * @property {String} WMTS - Web Map Tile Service
     * @property {String} WMSElevation - Web Map Service for elevation
     * @property {String} WCSElevation - Web Map Coverage for elevation
     * @property {String} GeoJSON - GeoJSON
     * @property {String} Vector - Vector
     * @property {String} Atmosphere - Atmosphere
     * @property {String} Bing - Microsoft BING
     * @property {String} GroundOverlay - GroundOverlay
     * @property {String} OSM - Open Street Map
     * @property {String} TileWireframe - TileWireframe
     * @property {String} HipsGrid - HipsGrid
     * @property {String} CoordinateGrid - CoordinateGrid
     * @property {String} Hips - Hierarchical Progressive Survey for images
     * @property {String} HipsCat - Hierarchical Progressive Survey for catalogue
     * @property {String} HipsFits - Hierarchical Progressive Survey for FITS
     * @property {String} Moc - Multiple Order Coverage
     * @property {String} OpenSearch - Open Search
     */
    Constants.LAYER = {
        AsynchroneWMS: "AsynchroneWMS",
        WMS: "WMS",
        WMTS: "WMTS",
        WMSElevation: "WMSElevation",
        WCSElevation: "WCSElevation",
        GeoJSON: "GeoJSON",
        Vector: "Vector",
        Atmosphere: "Atmosphere",
        Bing: "Bing",
        GroundOverlay: "GroundOverlay",
        OSM: "OSM",
        TileWireframe: "TileWireframe",
        HipsGrid: "HipsGrid",
        CoordinateGrid: "CoordinateGrid",
        HipsFits: "HipsFits",
        Hips: "Hips",
        HipsCat: "HipsCat",
        Moc: "Moc",
        OpenSearch: "OpenSearch"
    };

    /**
     * @namespace
     * GEOMETRY
     * @property {String} Point - Point
     * @property {String} MultiPoint - MultiPoint
     * @property {String} LineString - LineString
     * @property {String} MultiLineString - MultiLineString
     * @property {String} Polygon - Polygon
     * @property {String} MultiPolygon - MultiPolygon
     * @property {String} GeometryCollection - GeometryCollection
     */
    Constants.GEOMETRY = {
        Point: "Point",
        MultiPoint: "MultiPoint",
        LineString: "LineString",
        MultiLineString: "MultiLineString",
        Polygon: "Polygon",
        MultiPolygon: "MultiPolygon",
        GeometryCollection: "GeometryCollection"
    };

    /**
     * @namespace
     * PROJECTION
     * @property {String} Aitoff - Aitoff projection
     * @property {String} August - August projection
     * @property {String} Mercator - Mercator projection
     * @property {String} Mollweide - Mollweide projection
     * @property {String} Plate - Plate Carre projection
     * @property {String} Azimuth - Azimuthal projection
     */
    Constants.PROJECTION = {
        Aitoff: "Aitoff",
        August: "August",
        Mercator: "Mercator",
        Mollweide: "Mollweide",
        Plate: "Plate Carre",
        Azimuth: "Azimuth"
    };

    /**
     * @namespace
     * CRS
     * @property {String} Equatorial - Equatorial coordinate reference system
     * @property {String} Galactic - Galactic coordinate reference system
     * @property {String} WGS84 - CRS:84 coordinate reference system
     * @property {String} Mars_2000 - IAU2000:49901 coordinate reference system
     * @property {String} Mars_2000_old - IAU2000:49900 coordinate reference system
     * @property {String} Moon_2000 - IAU2000:30101 coordinate reference system
     * @property {String} Moon_2000_old - IAU2000:30100 coordinate reference system
     * @property {String} HorizontalLocal - Local reference system based on horizontal coordinates
     */
    Constants.CRS = {
        Equatorial: "Equatorial",
        Galactic: "Galactic",
        WGS84: "CRS:84",
        Mars_2000: "IAU2000:49901",
        Mars_2000_old: "IAU2000:49900",
        Moon_2000: "IAU2000:30101",
        Moon_2000_old: "IAU2000:30100",
        HorizontalLocal: "HorizontalLocal",
        Sun: "IAU:Sun"
    };

    /**
     * @namespace
     * NAVIGATION
     * @property {String} AstroNavigation - 3D Navigation for sky
     * @property {String} PlanetNavigation - 3D Navigation for planet
     * @property {String} FlatNavigation - 2D Navigation for planet
     * @property {String} GroundNavigation - 3D Navigation for ground visualization
     */
    Constants.NAVIGATION = {
        AstroNavigation: "AstroNavigation",
        PlanetNavigation: "PlanetNavigation",
        FlatNavigation: "FlatNavigation",
        GroundNavigation: "GroundNavigation"
    };

    /**
     * @namespace
     * SERVICE
     * @property {String} FitsVisu - FITS visualization
     * @property {String} Histogram - Histogram values from a FITS file
     * @property {String} ImageProcessing - Image processing
     * @property {String} MeasureToolSky - Tool to measure the distance between two points on the sky
     * @property {String} MeasureToolPlanet - Tool to measure the distance between two points on a planet
     * @property {String} MocBase - MOC service
     * @property {String} MollweideViewer - Mollweide Viewer
     * @property {String} PickingManager - Picking Manager
     * @property {String} Samp - Samp
     * @property {String} SelectionTool - Selection Tool
     * @property {String} NameResolver - NameResolver
     * @property {String} ReverseNameResolver - ReverseNameResolver
     * @property {String} ExportTool - ExportTool
     */
    Constants.SERVICE = {
        FitsHips: "FitsHips",
        FitsVisu: "FitsVisu",
        Histogram: "Histogram",
        ImageProcessing: "ImageProcessing",
        MeasureToolSky: "MeasureToolSky",
        MeasureToolPlanet: "MeasureToolPlanet",
        MocBase: "MocBase",
        MollweideViewer: "MollweideViewer",
        PickingManager: "PickingManager",
        Samp: "Samp",
        SelectionTool: "SelectionTool",
        NameResolver: "NameResolver",
        ReverseNameResolver: "ReverseNameResolver",
        ExportTool: "ExportTool",
        TimeTravel: "TimeTravel"
    };

    /**
     * @namespace
     * HANDLER
     * @property {String} Touch - Touch device
     * @property {String} Keyboard - Keyboard device
     * @property {String} Mouse - Mouse device
     * @property {String} GoogleMouse - GoogleMouse device
     */
    Constants.HANDLER = {
        Touch: "Touch",
        Keyboard: "Keyboard",
        Mouse: "Mouse",
        GoogleMouse: "GoogleMouse"
    };

    /**
     * @namespace
     * PROVIDER
     * @property {String} Constellation - Constellation
     * @property {String} Json - Json
     * @property {String} Planet - Planet
     * @property {String} Star - Star
     * @property {String} Trajectory - Trajectory
     */
    Constants.PROVIDER = {
        Constellation: "Constellation",
        Planet: "Planet",
        Star: "Star",
        Crater: "Crater",
        Trajectory: "Trajectory"
    };

    /**
     * @namespace
     * MappingCrsHips2Mizar
     * @property {String} equatorial - Equatorial
     * @property {String} galactic - Galactic
     * @property {String} ecliptic - Ecliptic
     * @property {String} horizontalLocal - Equatorial
     */
    Constants.MappingCrsHips2Mizar = {
        equatorial: "Equatorial",
        galactic: "Galactic",
        ecliptic: "Ecliptic",
        "mars-panstimson": "Equatorial",
        horizontalLocal: "Equatorial"
    };

    /**
     * @namespace
     * UTILITY
     * @property {String} Fits - Fits utility
     * @property {String} Intersection - Intersection utility
     * @property {String} CreateStyle - CreateStyle utility
     * @property {String} FeatureStyle - FeatureStyle utility
     */
    Constants.UTILITY = {
        Fits: "Fits",
        Intersection: "Intersection",
        Numeric: "Numeric",
        CreateStyle: "CreateStyle",
        FeatureStyle: "FeatureStyle"
    };

    /**
     * @namespace
     * ANIMATION_STATUS
     * @property {String} STOPPED - animation is stopped
     * @property {String} RUNNING - animation is running
     * @property {String} PAUSED - animation is paused
     */
    Constants.ANIMATION_STATUS = {
        STOPPED: "STOPPED",
        RUNNING: "RUNNING",
        PAUSED: "PAUSED"
    };

    /**
     * @namespace
     * EVENT_MSG
     * @property {String} PLUGIN_NOT_FOUND - Plugin not found
     * @property {String} MIZAR_MODE_TOGGLE - Mizar mode, one value among {Constants.CONTEXT}
     * @property {String} LAYER_BACKGROUND_ADDED - Background Layer added
     * @property {String} LAYER_BACKGROUND_CHANGED - Background Layer changed
     * @property {String} LAYER_ADDED - Layer added
     * @property {String} LAYER_REMOVED - Layer removed
     * @property {String} LAYER_VISIBILITY_CHANGED - Visibility Layer changed
     * @property {String} LAYER_OPACITY_CHANGED - Opacity Layer changed
     * @property {String} LAYER_START_LOAD - Overlay rasters or vectors start to load
     * @property {String} LAYER_END_LOAD - Overlay rasters  or vectors finish to load
     * @property {String} LAYER_START_BACKGROUND_LOAD - Background rasters start to load
     * @property {String} LAYER_END_BACKGROUND_LOAD - Background rasters finish to load
     * @property {String} BASE_LAYERS_ERROR - Error at the initialisation of layer to render
     * @property {String} BASE_LAYERS_READY - Initialisation of the rendering is fine
     * @property {String} CRS_MODIFIED - Coordinate reference system is modified
     * @property {String} NAVIGATION_STARTED - Navigation started
     * @property {String} NAVIGATION_ENDED - Navigation ended
     * @property {String} NAVIGATION_MODIFIED - Navigation modified
     * @property {String} NAVIGATION_CHANGED_DISTANCE - Distance of the camera from the planet has changed
     * @property {String} IMAGE_DOWNLOADED - Image downloaded
     * @property {String} IMAGE_REMOVED - Image removed
     * @property {String} IMAGE_ADDED - Image added
     * @property {String} FEATURED_ADDED - Feature added
     * @property {String} GLOBAL_TIME_REWIND - global time is rewinded
     * @property {String} GLOBAL_TIME_FORWARD - global time is forwarded
     * @property {String} GLOBAL_TIME_SET - global time is set,
     * @property {String} GLOBAL_TIME_CHANGED - global time has changed

     */
    Constants.EVENT_MSG = {
        PLUGIN_NOT_FOUND: "plugin:not_found",
        MIZAR_MODE_TOGGLE: "mizarMode:toggle",
        LAYER_BACKGROUND_ERROR: "backgroundLayer:error",
        LAYER_BACKGROUND_ADDED: "backgroundLayer:add",
        LAYER_BACKGROUND_CHANGED: "backgroundLayer:changed",
        LAYER_ADDED: "layer:added",
        LAYER_REMOVED: "layer:removed",
        LAYER_VISIBILITY_CHANGED: "visibility:changed",
        LAYER_OPACITY_CHANGED: "opacity:changed",
        LAYER_START_LOAD: "startLoad",
        LAYER_END_LOAD: "endLoad",
        LAYER_START_BACKGROUND_LOAD: "startBackgroundLoad",
        LAYER_END_BACKGROUND_LOAD: "endBackgroundLoad",
        LAYER_UPDATE_STATS_ATTRIBUTES: "updateStatsAttribute",
        LAYER_TOGGLE_WMS: "toggleWMS",
        BASE_LAYERS_ERROR: "baseLayersError",
        BASE_LAYERS_READY: "baseLayersReady",
        CRS_MODIFIED: "modifiedCrs",
        NAVIGATION_STARTED: "startNavigation",
        NAVIGATION_ENDED: "endNavigation",
        NAVIGATION_MODIFIED: "modifiedNavigation",
        NAVIGATION_CHANGED_DISTANCE: "navigation:changedDistance",
        IMAGE_DOWNLOADED: "image:downloaded",
        IMAGE_REMOVED: "image:removed",
        IMAGE_ADDED: "image:added",
        FEATURED_ADDED: "features:added",
        GLOBAL_TIME_REWIND: "globalTime:rewind",
        GLOBAL_TIME_FORWARD: "globalTime:forward",
        GLOBAL_TIME_SET: "globalTime:set",
        GLOBAL_TIME_CHANGED: "globalTime:changed" // temporary, need to be link to LAYERS_TIME_CHANGED after dev
    };

    /**
     * @namespace
     * DISPLAY_ORDER
     * @property {String} RENDERING - Special rendering index
     * @property {String} DEFAULT_RASTER - Default layer index (specially images)
     * @property {String} SELECTED_RASTER - Selected layer index (specially images)
     * @property {String} DEFAULT_VECTOR - Default vector index
     * @property {String} SELECTED_VECTOR - Selected vector index
     * @property {String} SERVICE_VECTOR - Service index
     */
    Constants.DISPLAY = {
        RENDERING: -1,
        DEFAULT_RASTER: 0,
        SELECTED_RASTER: 10,
        DEFAULT_VECTOR: 20,
        SELECTED_VECTOR: 30,
        SERVICE_VECTOR: 40
    };

    /**
     * @namespace
     * INFORMATION_TYPE
     * @property {String} ATMOSPHERE - atmosphere data
     * @property {String} RASTER - raster data
     * @property {String} VECTOR - vector data
     */
    Constants.INFORMATION_TYPE = {
        ATMOSPHERE: "ATMOSPHERE",
        RASTER: "RASTER",
        VECTOR: "VECTOR"
    };

    /**
     * @namespace
     * TIME_STEP
     * @property {String} YEAR - years
     * @property {String} QUARTER - quarters
     * @property {String} MONTH - months
     * @property {String} WEEK - weeks
     * @property {String} DAY - days
     * @property {String} HOUR - hours
     * @property {String} MINUTE - minutes
     * @property {String} SECOND - seconds
     * @property {String} MILLISECOND - milliseconds
     * @property {String} ENUMERATED - null                                
     */
    Constants.TIME_STEP = {
        YEAR: "years",
        QUARTER: "quarters",
        MONTH: "months",
        WEEK: "weeks",
        DAY: "days",
        HOUR: "hours",
        MINUTE: "minutes",
        SECOND: "seconds",
        MILLISECOND: "milliseconds",
        ENUMERATED: null
    };

    /**
     * @namespace
     * TIME_MOMENT_STEP
     * @property {String} YEAR - year
     * @property {String} MONTH - month
     * @property {String} DAY - day
     * @property {String} HOUR - hour
     * @property {String} MINUTE - minute
     * @property {String} SECOND - second      
     */    
    Constants.TIME_MOMENT_STEP = {
        YEAR: "year",
        MONTH: "month",
        DAY: "day",
        HOUR: "hour",
        MINUTE: "minute",
        SECOND: "second"
    };

    /**
     * @namespace
     * UNIT_TIME_WMS
     * @property {String} YEAR - Y
     * @property {String} MONTH - M
     * @property {String} DAY - D
     * @property {String} HOUR - H
     * @property {String} MINUTE - M
     * @property {String} SECOND - S      
     */     
    Constants.UNIT_TIME_WMS = {
        YEAR: "Y",
        MONTH: "M",
        DAY: "D",
        HOUR: "H",
        MINUTE: "M",
        SECONDE: "S"
    };

    /**
     * @namespace
     * UNIT_RESOLUTION_WMS
     * @property {String} TIME - PT
     * @property {String} NOT_TIME - P    
     */    
    Constants.UNIT_RESOLUTION_WMS = {
        TIME: "PT",
        NOT_TIME: "P"
    };

    /**
     * @namespace
     * TIME
     * @property {String} DEFAULT_FORMAT - Do MMM Y HH:mm
     */     
    Constants.TIME = {
        DEFAULT_FORMAT: "Do MMM Y HH:mm"
    };

    /**************************************************************************************************************/

    return Constants;
});

!function(e,a){"object"==typeof exports&&"undefined"!=typeof module?module.exports=a():"function"==typeof define&&define.amd?define('moment',a):e.moment=a()}(this,function(){"use strict";var e,n;function l(){return e.apply(null,arguments)}function _(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function i(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function o(e){return void 0===e}function m(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function u(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function M(e,a){var t,s=[];for(t=0;t<e.length;++t)s.push(a(e[t],t));return s}function h(e,a){return Object.prototype.hasOwnProperty.call(e,a)}function L(e,a){for(var t in a)h(a,t)&&(e[t]=a[t]);return h(a,"toString")&&(e.toString=a.toString),h(a,"valueOf")&&(e.valueOf=a.valueOf),e}function c(e,a,t,s){return va(e,a,t,s,!0).utc()}function Y(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function y(e){if(null==e._isValid){var a=Y(e),t=n.call(a.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&a.overflow<0&&!a.empty&&!a.invalidMonth&&!a.invalidWeekday&&!a.weekdayMismatch&&!a.nullInput&&!a.invalidFormat&&!a.userInvalidated&&(!a.meridiem||a.meridiem&&t);if(e._strict&&(s=s&&0===a.charsLeftOver&&0===a.unusedTokens.length&&void 0===a.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function f(e){var a=c(NaN);return null!=e?L(Y(a),e):Y(a).userInvalidated=!0,a}n=Array.prototype.some?Array.prototype.some:function(e){for(var a=Object(this),t=a.length>>>0,s=0;s<t;s++)if(s in a&&e.call(this,a[s],s,a))return!0;return!1};var d=l.momentProperties=[];function k(e,a){var t,s,n;if(o(a._isAMomentObject)||(e._isAMomentObject=a._isAMomentObject),o(a._i)||(e._i=a._i),o(a._f)||(e._f=a._f),o(a._l)||(e._l=a._l),o(a._strict)||(e._strict=a._strict),o(a._tzm)||(e._tzm=a._tzm),o(a._isUTC)||(e._isUTC=a._isUTC),o(a._offset)||(e._offset=a._offset),o(a._pf)||(e._pf=Y(a)),o(a._locale)||(e._locale=a._locale),0<d.length)for(t=0;t<d.length;t++)o(n=a[s=d[t]])||(e[s]=n);return e}var a=!1;function p(e){k(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===a&&(a=!0,l.updateOffset(this),a=!1)}function D(e){return e instanceof p||null!=e&&null!=e._isAMomentObject}function T(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function g(e){var a=+e,t=0;return 0!==a&&isFinite(a)&&(t=T(a)),t}function r(e,a,t){var s,n=Math.min(e.length,a.length),d=Math.abs(e.length-a.length),r=0;for(s=0;s<n;s++)(t&&e[s]!==a[s]||!t&&g(e[s])!==g(a[s]))&&r++;return r+d}function w(e){!1===l.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function t(n,d){var r=!0;return L(function(){if(null!=l.deprecationHandler&&l.deprecationHandler(null,n),r){for(var e,a=[],t=0;t<arguments.length;t++){if(e="","object"==typeof arguments[t]){for(var s in e+="\n["+t+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[t];a.push(e)}w(n+"\nArguments: "+Array.prototype.slice.call(a).join("")+"\n"+(new Error).stack),r=!1}return d.apply(this,arguments)},d)}var s,v={};function S(e,a){null!=l.deprecationHandler&&l.deprecationHandler(e,a),v[e]||(w(a),v[e]=!0)}function H(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function b(e,a){var t,s=L({},e);for(t in a)h(a,t)&&(i(e[t])&&i(a[t])?(s[t]={},L(s[t],e[t]),L(s[t],a[t])):null!=a[t]?s[t]=a[t]:delete s[t]);for(t in e)h(e,t)&&!h(a,t)&&i(e[t])&&(s[t]=L({},s[t]));return s}function j(e){null!=e&&this.set(e)}l.suppressDeprecationWarnings=!1,l.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var a,t=[];for(a in e)h(e,a)&&t.push(a);return t};var x={};function P(e,a){var t=e.toLowerCase();x[t]=x[t+"s"]=x[a]=e}function O(e){return"string"==typeof e?x[e]||x[e.toLowerCase()]:void 0}function W(e){var a,t,s={};for(t in e)h(e,t)&&(a=O(t))&&(s[a]=e[t]);return s}var E={};function A(e,a){E[e]=a}function F(e,a,t){var s=""+Math.abs(e),n=a-s.length;return(0<=e?t?"+":"":"-")+Math.pow(10,Math.max(0,n)).toString().substr(1)+s}var z=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,J=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,N={},R={};function I(e,a,t,s){var n=s;"string"==typeof s&&(n=function(){return this[s]()}),e&&(R[e]=n),a&&(R[a[0]]=function(){return F(n.apply(this,arguments),a[1],a[2])}),t&&(R[t]=function(){return this.localeData().ordinal(n.apply(this,arguments),e)})}function C(e,a){return e.isValid()?(a=G(a,e.localeData()),N[a]=N[a]||function(s){var e,n,a,d=s.match(z);for(e=0,n=d.length;e<n;e++)R[d[e]]?d[e]=R[d[e]]:d[e]=(a=d[e]).match(/\[[\s\S]/)?a.replace(/^\[|\]$/g,""):a.replace(/\\/g,"");return function(e){var a,t="";for(a=0;a<n;a++)t+=H(d[a])?d[a].call(e,s):d[a];return t}}(a),N[a](e)):e.localeData().invalidDate()}function G(e,a){var t=5;function s(e){return a.longDateFormat(e)||e}for(J.lastIndex=0;0<=t&&J.test(e);)e=e.replace(J,s),J.lastIndex=0,t-=1;return e}var U=/\d/,V=/\d\d/,K=/\d{3}/,$=/\d{4}/,Z=/[+-]?\d{6}/,B=/\d\d?/,q=/\d\d\d\d?/,Q=/\d\d\d\d\d\d?/,X=/\d{1,3}/,ee=/\d{1,4}/,ae=/[+-]?\d{1,6}/,te=/\d+/,se=/[+-]?\d+/,ne=/Z|[+-]\d\d:?\d\d/gi,de=/Z|[+-]\d\d(?::?\d\d)?/gi,re=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,_e={};function ie(e,t,s){_e[e]=H(t)?t:function(e,a){return e&&s?s:t}}function oe(e,a){return h(_e,e)?_e[e](a._strict,a._locale):new RegExp(me(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,a,t,s,n){return a||t||s||n})))}function me(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var ue={};function le(e,t){var a,s=t;for("string"==typeof e&&(e=[e]),m(t)&&(s=function(e,a){a[t]=g(e)}),a=0;a<e.length;a++)ue[e[a]]=s}function Me(e,n){le(e,function(e,a,t,s){t._w=t._w||{},n(e,t._w,t,s)})}var he=0,Le=1,ce=2,Ye=3,ye=4,fe=5,ke=6,pe=7,De=8;function Te(e){return ge(e)?366:365}function ge(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),P("year","y"),A("year",1),ie("Y",se),ie("YY",B,V),ie("YYYY",ee,$),ie("YYYYY",ae,Z),ie("YYYYYY",ae,Z),le(["YYYYY","YYYYYY"],he),le("YYYY",function(e,a){a[he]=2===e.length?l.parseTwoDigitYear(e):g(e)}),le("YY",function(e,a){a[he]=l.parseTwoDigitYear(e)}),le("Y",function(e,a){a[he]=parseInt(e,10)}),l.parseTwoDigitYear=function(e){return g(e)+(68<g(e)?1900:2e3)};var we,ve=Se("FullYear",!0);function Se(a,t){return function(e){return null!=e?(be(this,a,e),l.updateOffset(this,t),this):He(this,a)}}function He(e,a){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+a]():NaN}function be(e,a,t){e.isValid()&&!isNaN(t)&&("FullYear"===a&&ge(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+a](t,e.month(),je(t,e.month())):e._d["set"+(e._isUTC?"UTC":"")+a](t))}function je(e,a){if(isNaN(e)||isNaN(a))return NaN;var t,s=(a%(t=12)+t)%t;return e+=(a-s)/12,1===s?ge(e)?29:28:31-s%7%2}we=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var a;for(a=0;a<this.length;++a)if(this[a]===e)return a;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),P("month","M"),A("month",8),ie("M",B),ie("MM",B,V),ie("MMM",function(e,a){return a.monthsShortRegex(e)}),ie("MMMM",function(e,a){return a.monthsRegex(e)}),le(["M","MM"],function(e,a){a[Le]=g(e)-1}),le(["MMM","MMMM"],function(e,a,t,s){var n=t._locale.monthsParse(e,s,t._strict);null!=n?a[Le]=n:Y(t).invalidMonth=e});var xe=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Pe="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var Oe="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function We(e,a){var t;if(!e.isValid())return e;if("string"==typeof a)if(/^\d+$/.test(a))a=g(a);else if(!m(a=e.localeData().monthsParse(a)))return e;return t=Math.min(e.date(),je(e.year(),a)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](a,t),e}function Ee(e){return null!=e?(We(this,e),l.updateOffset(this,!0),this):He(this,"Month")}var Ae=re;var Fe=re;function ze(){function e(e,a){return a.length-e.length}var a,t,s=[],n=[],d=[];for(a=0;a<12;a++)t=c([2e3,a]),s.push(this.monthsShort(t,"")),n.push(this.months(t,"")),d.push(this.months(t,"")),d.push(this.monthsShort(t,""));for(s.sort(e),n.sort(e),d.sort(e),a=0;a<12;a++)s[a]=me(s[a]),n[a]=me(n[a]);for(a=0;a<24;a++)d[a]=me(d[a]);this._monthsRegex=new RegExp("^("+d.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+n.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Je(e){var a=new Date(Date.UTC.apply(null,arguments));return e<100&&0<=e&&isFinite(a.getUTCFullYear())&&a.setUTCFullYear(e),a}function Ne(e,a,t){var s=7+a-t;return-((7+Je(e,0,s).getUTCDay()-a)%7)+s-1}function Re(e,a,t,s,n){var d,r,_=1+7*(a-1)+(7+t-s)%7+Ne(e,s,n);return _<=0?r=Te(d=e-1)+_:_>Te(e)?(d=e+1,r=_-Te(e)):(d=e,r=_),{year:d,dayOfYear:r}}function Ie(e,a,t){var s,n,d=Ne(e.year(),a,t),r=Math.floor((e.dayOfYear()-d-1)/7)+1;return r<1?s=r+Ce(n=e.year()-1,a,t):r>Ce(e.year(),a,t)?(s=r-Ce(e.year(),a,t),n=e.year()+1):(n=e.year(),s=r),{week:s,year:n}}function Ce(e,a,t){var s=Ne(e,a,t),n=Ne(e+1,a,t);return(Te(e)-s+n)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),P("week","w"),P("isoWeek","W"),A("week",5),A("isoWeek",5),ie("w",B),ie("ww",B,V),ie("W",B),ie("WW",B,V),Me(["w","ww","W","WW"],function(e,a,t,s){a[s.substr(0,1)]=g(e)});I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),P("day","d"),P("weekday","e"),P("isoWeekday","E"),A("day",11),A("weekday",11),A("isoWeekday",11),ie("d",B),ie("e",B),ie("E",B),ie("dd",function(e,a){return a.weekdaysMinRegex(e)}),ie("ddd",function(e,a){return a.weekdaysShortRegex(e)}),ie("dddd",function(e,a){return a.weekdaysRegex(e)}),Me(["dd","ddd","dddd"],function(e,a,t,s){var n=t._locale.weekdaysParse(e,s,t._strict);null!=n?a.d=n:Y(t).invalidWeekday=e}),Me(["d","e","E"],function(e,a,t,s){a[s]=g(e)});var Ge="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var Ue="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var Ve="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var Ke=re;var $e=re;var Ze=re;function Be(){function e(e,a){return a.length-e.length}var a,t,s,n,d,r=[],_=[],i=[],o=[];for(a=0;a<7;a++)t=c([2e3,1]).day(a),s=this.weekdaysMin(t,""),n=this.weekdaysShort(t,""),d=this.weekdays(t,""),r.push(s),_.push(n),i.push(d),o.push(s),o.push(n),o.push(d);for(r.sort(e),_.sort(e),i.sort(e),o.sort(e),a=0;a<7;a++)_[a]=me(_[a]),i[a]=me(i[a]),o[a]=me(o[a]);this._weekdaysRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+_.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+r.join("|")+")","i")}function qe(){return this.hours()%12||12}function Qe(e,a){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),a)})}function Xe(e,a){return a._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,qe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+qe.apply(this)+F(this.minutes(),2)}),I("hmmss",0,0,function(){return""+qe.apply(this)+F(this.minutes(),2)+F(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+F(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+F(this.minutes(),2)+F(this.seconds(),2)}),Qe("a",!0),Qe("A",!1),P("hour","h"),A("hour",13),ie("a",Xe),ie("A",Xe),ie("H",B),ie("h",B),ie("k",B),ie("HH",B,V),ie("hh",B,V),ie("kk",B,V),ie("hmm",q),ie("hmmss",Q),ie("Hmm",q),ie("Hmmss",Q),le(["H","HH"],Ye),le(["k","kk"],function(e,a,t){var s=g(e);a[Ye]=24===s?0:s}),le(["a","A"],function(e,a,t){t._isPm=t._locale.isPM(e),t._meridiem=e}),le(["h","hh"],function(e,a,t){a[Ye]=g(e),Y(t).bigHour=!0}),le("hmm",function(e,a,t){var s=e.length-2;a[Ye]=g(e.substr(0,s)),a[ye]=g(e.substr(s)),Y(t).bigHour=!0}),le("hmmss",function(e,a,t){var s=e.length-4,n=e.length-2;a[Ye]=g(e.substr(0,s)),a[ye]=g(e.substr(s,2)),a[fe]=g(e.substr(n)),Y(t).bigHour=!0}),le("Hmm",function(e,a,t){var s=e.length-2;a[Ye]=g(e.substr(0,s)),a[ye]=g(e.substr(s))}),le("Hmmss",function(e,a,t){var s=e.length-4,n=e.length-2;a[Ye]=g(e.substr(0,s)),a[ye]=g(e.substr(s,2)),a[fe]=g(e.substr(n))});var ea,aa=Se("Hours",!0),ta={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Pe,monthsShort:Oe,week:{dow:0,doy:6},weekdays:Ge,weekdaysMin:Ve,weekdaysShort:Ue,meridiemParse:/[ap]\.?m?\.?/i},sa={},na={};function da(e){return e?e.toLowerCase().replace("_","-"):e}function ra(e){var a=null;if(!sa[e]&&"undefined"!=typeof module&&module&&module.exports)try{a=ea._abbr,require("./locale/"+e),_a(a)}catch(e){}return sa[e]}function _a(e,a){var t;return e&&((t=o(a)?oa(e):ia(e,a))?ea=t:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),ea._abbr}function ia(e,a){if(null!==a){var t,s=ta;if(a.abbr=e,null!=sa[e])S("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=sa[e]._config;else if(null!=a.parentLocale)if(null!=sa[a.parentLocale])s=sa[a.parentLocale]._config;else{if(null==(t=ra(a.parentLocale)))return na[a.parentLocale]||(na[a.parentLocale]=[]),na[a.parentLocale].push({name:e,config:a}),null;s=t._config}return sa[e]=new j(b(s,a)),na[e]&&na[e].forEach(function(e){ia(e.name,e.config)}),_a(e),sa[e]}return delete sa[e],null}function oa(e){var a;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return ea;if(!_(e)){if(a=ra(e))return a;e=[e]}return function(e){for(var a,t,s,n,d=0;d<e.length;){for(a=(n=da(e[d]).split("-")).length,t=(t=da(e[d+1]))?t.split("-"):null;0<a;){if(s=ra(n.slice(0,a).join("-")))return s;if(t&&t.length>=a&&r(n,t,!0)>=a-1)break;a--}d++}return ea}(e)}function ma(e){var a,t=e._a;return t&&-2===Y(e).overflow&&(a=t[Le]<0||11<t[Le]?Le:t[ce]<1||t[ce]>je(t[he],t[Le])?ce:t[Ye]<0||24<t[Ye]||24===t[Ye]&&(0!==t[ye]||0!==t[fe]||0!==t[ke])?Ye:t[ye]<0||59<t[ye]?ye:t[fe]<0||59<t[fe]?fe:t[ke]<0||999<t[ke]?ke:-1,Y(e)._overflowDayOfYear&&(a<he||ce<a)&&(a=ce),Y(e)._overflowWeeks&&-1===a&&(a=pe),Y(e)._overflowWeekday&&-1===a&&(a=De),Y(e).overflow=a),e}function ua(e,a,t){return null!=e?e:null!=a?a:t}function la(e){var a,t,s,n,d,r=[];if(!e._d){var _,i;for(_=e,i=new Date(l.now()),s=_._useUTC?[i.getUTCFullYear(),i.getUTCMonth(),i.getUTCDate()]:[i.getFullYear(),i.getMonth(),i.getDate()],e._w&&null==e._a[ce]&&null==e._a[Le]&&function(e){var a,t,s,n,d,r,_,i;if(null!=(a=e._w).GG||null!=a.W||null!=a.E)d=1,r=4,t=ua(a.GG,e._a[he],Ie(Sa(),1,4).year),s=ua(a.W,1),((n=ua(a.E,1))<1||7<n)&&(i=!0);else{d=e._locale._week.dow,r=e._locale._week.doy;var o=Ie(Sa(),d,r);t=ua(a.gg,e._a[he],o.year),s=ua(a.w,o.week),null!=a.d?((n=a.d)<0||6<n)&&(i=!0):null!=a.e?(n=a.e+d,(a.e<0||6<a.e)&&(i=!0)):n=d}s<1||s>Ce(t,d,r)?Y(e)._overflowWeeks=!0:null!=i?Y(e)._overflowWeekday=!0:(_=Re(t,s,n,d,r),e._a[he]=_.year,e._dayOfYear=_.dayOfYear)}(e),null!=e._dayOfYear&&(d=ua(e._a[he],s[he]),(e._dayOfYear>Te(d)||0===e._dayOfYear)&&(Y(e)._overflowDayOfYear=!0),t=Je(d,0,e._dayOfYear),e._a[Le]=t.getUTCMonth(),e._a[ce]=t.getUTCDate()),a=0;a<3&&null==e._a[a];++a)e._a[a]=r[a]=s[a];for(;a<7;a++)e._a[a]=r[a]=null==e._a[a]?2===a?1:0:e._a[a];24===e._a[Ye]&&0===e._a[ye]&&0===e._a[fe]&&0===e._a[ke]&&(e._nextDay=!0,e._a[Ye]=0),e._d=(e._useUTC?Je:function(e,a,t,s,n,d,r){var _=new Date(e,a,t,s,n,d,r);return e<100&&0<=e&&isFinite(_.getFullYear())&&_.setFullYear(e),_}).apply(null,r),n=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[Ye]=24),e._w&&void 0!==e._w.d&&e._w.d!==n&&(Y(e).weekdayMismatch=!0)}}var Ma=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,ha=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,La=/Z|[+-]\d\d(?::?\d\d)?/,ca=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Ya=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],ya=/^\/?Date\((\-?\d+)/i;function fa(e){var a,t,s,n,d,r,_=e._i,i=Ma.exec(_)||ha.exec(_);if(i){for(Y(e).iso=!0,a=0,t=ca.length;a<t;a++)if(ca[a][1].exec(i[1])){n=ca[a][0],s=!1!==ca[a][2];break}if(null==n)return void(e._isValid=!1);if(i[3]){for(a=0,t=Ya.length;a<t;a++)if(Ya[a][1].exec(i[3])){d=(i[2]||" ")+Ya[a][0];break}if(null==d)return void(e._isValid=!1)}if(!s&&null!=d)return void(e._isValid=!1);if(i[4]){if(!La.exec(i[4]))return void(e._isValid=!1);r="Z"}e._f=n+(d||"")+(r||""),ga(e)}else e._isValid=!1}var ka=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function pa(e,a,t,s,n,d){var r=[function(e){var a=parseInt(e,10);{if(a<=49)return 2e3+a;if(a<=999)return 1900+a}return a}(e),Oe.indexOf(a),parseInt(t,10),parseInt(s,10),parseInt(n,10)];return d&&r.push(parseInt(d,10)),r}var Da={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Ta(e){var a,t,s,n=ka.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(n){var d=pa(n[4],n[3],n[2],n[5],n[6],n[7]);if(a=n[1],t=d,s=e,a&&Ue.indexOf(a)!==new Date(t[0],t[1],t[2]).getDay()&&(Y(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=d,e._tzm=function(e,a,t){if(e)return Da[e];if(a)return 0;var s=parseInt(t,10),n=s%100;return(s-n)/100*60+n}(n[8],n[9],n[10]),e._d=Je.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),Y(e).rfc2822=!0}else e._isValid=!1}function ga(e){if(e._f!==l.ISO_8601)if(e._f!==l.RFC_2822){e._a=[],Y(e).empty=!0;var a,t,s,n,d,r,_,i,o=""+e._i,m=o.length,u=0;for(s=G(e._f,e._locale).match(z)||[],a=0;a<s.length;a++)n=s[a],(t=(o.match(oe(n,e))||[])[0])&&(0<(d=o.substr(0,o.indexOf(t))).length&&Y(e).unusedInput.push(d),o=o.slice(o.indexOf(t)+t.length),u+=t.length),R[n]?(t?Y(e).empty=!1:Y(e).unusedTokens.push(n),r=n,i=e,null!=(_=t)&&h(ue,r)&&ue[r](_,i._a,i,r)):e._strict&&!t&&Y(e).unusedTokens.push(n);Y(e).charsLeftOver=m-u,0<o.length&&Y(e).unusedInput.push(o),e._a[Ye]<=12&&!0===Y(e).bigHour&&0<e._a[Ye]&&(Y(e).bigHour=void 0),Y(e).parsedDateParts=e._a.slice(0),Y(e).meridiem=e._meridiem,e._a[Ye]=function(e,a,t){var s;if(null==t)return a;return null!=e.meridiemHour?e.meridiemHour(a,t):(null!=e.isPM&&((s=e.isPM(t))&&a<12&&(a+=12),s||12!==a||(a=0)),a)}(e._locale,e._a[Ye],e._meridiem),la(e),ma(e)}else Ta(e);else fa(e)}function wa(e){var a,t,s,n,d=e._i,r=e._f;return e._locale=e._locale||oa(e._l),null===d||void 0===r&&""===d?f({nullInput:!0}):("string"==typeof d&&(e._i=d=e._locale.preparse(d)),D(d)?new p(ma(d)):(u(d)?e._d=d:_(r)?function(e){var a,t,s,n,d;if(0===e._f.length)return Y(e).invalidFormat=!0,e._d=new Date(NaN);for(n=0;n<e._f.length;n++)d=0,a=k({},e),null!=e._useUTC&&(a._useUTC=e._useUTC),a._f=e._f[n],ga(a),y(a)&&(d+=Y(a).charsLeftOver,d+=10*Y(a).unusedTokens.length,Y(a).score=d,(null==s||d<s)&&(s=d,t=a));L(e,t||a)}(e):r?ga(e):o(t=(a=e)._i)?a._d=new Date(l.now()):u(t)?a._d=new Date(t.valueOf()):"string"==typeof t?(s=a,null===(n=ya.exec(s._i))?(fa(s),!1===s._isValid&&(delete s._isValid,Ta(s),!1===s._isValid&&(delete s._isValid,l.createFromInputFallback(s)))):s._d=new Date(+n[1])):_(t)?(a._a=M(t.slice(0),function(e){return parseInt(e,10)}),la(a)):i(t)?function(e){if(!e._d){var a=W(e._i);e._a=M([a.year,a.month,a.day||a.date,a.hour,a.minute,a.second,a.millisecond],function(e){return e&&parseInt(e,10)}),la(e)}}(a):m(t)?a._d=new Date(t):l.createFromInputFallback(a),y(e)||(e._d=null),e))}function va(e,a,t,s,n){var d,r={};return!0!==t&&!1!==t||(s=t,t=void 0),(i(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var a;for(a in e)if(e.hasOwnProperty(a))return!1;return!0}(e)||_(e)&&0===e.length)&&(e=void 0),r._isAMomentObject=!0,r._useUTC=r._isUTC=n,r._l=t,r._i=e,r._f=a,r._strict=s,(d=new p(ma(wa(r))))._nextDay&&(d.add(1,"d"),d._nextDay=void 0),d}function Sa(e,a,t,s){return va(e,a,t,s,!1)}l.createFromInputFallback=t("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),l.ISO_8601=function(){},l.RFC_2822=function(){};var Ha=t("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Sa.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:f()}),ba=t("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=Sa.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:f()});function ja(e,a){var t,s;if(1===a.length&&_(a[0])&&(a=a[0]),!a.length)return Sa();for(t=a[0],s=1;s<a.length;++s)a[s].isValid()&&!a[s][e](t)||(t=a[s]);return t}var xa=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Pa(e){var a=W(e),t=a.year||0,s=a.quarter||0,n=a.month||0,d=a.week||0,r=a.day||0,_=a.hour||0,i=a.minute||0,o=a.second||0,m=a.millisecond||0;this._isValid=function(e){for(var a in e)if(-1===we.call(xa,a)||null!=e[a]&&isNaN(e[a]))return!1;for(var t=!1,s=0;s<xa.length;++s)if(e[xa[s]]){if(t)return!1;parseFloat(e[xa[s]])!==g(e[xa[s]])&&(t=!0)}return!0}(a),this._milliseconds=+m+1e3*o+6e4*i+1e3*_*60*60,this._days=+r+7*d,this._months=+n+3*s+12*t,this._data={},this._locale=oa(),this._bubble()}function Oa(e){return e instanceof Pa}function Wa(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ea(e,t){I(e,0,0,function(){var e=this.utcOffset(),a="+";return e<0&&(e=-e,a="-"),a+F(~~(e/60),2)+t+F(~~e%60,2)})}Ea("Z",":"),Ea("ZZ",""),ie("Z",de),ie("ZZ",de),le(["Z","ZZ"],function(e,a,t){t._useUTC=!0,t._tzm=Fa(de,e)});var Aa=/([\+\-]|\d\d)/gi;function Fa(e,a){var t=(a||"").match(e);if(null===t)return null;var s=((t[t.length-1]||[])+"").match(Aa)||["-",0,0],n=60*s[1]+g(s[2]);return 0===n?0:"+"===s[0]?n:-n}function za(e,a){var t,s;return a._isUTC?(t=a.clone(),s=(D(e)||u(e)?e.valueOf():Sa(e).valueOf())-t.valueOf(),t._d.setTime(t._d.valueOf()+s),l.updateOffset(t,!1),t):Sa(e).local()}function Ja(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Na(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}l.updateOffset=function(){};var Ra=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Ia=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function Ca(e,a){var t,s,n,d=e,r=null;return Oa(e)?d={ms:e._milliseconds,d:e._days,M:e._months}:m(e)?(d={},a?d[a]=e:d.milliseconds=e):(r=Ra.exec(e))?(t="-"===r[1]?-1:1,d={y:0,d:g(r[ce])*t,h:g(r[Ye])*t,m:g(r[ye])*t,s:g(r[fe])*t,ms:g(Wa(1e3*r[ke]))*t}):(r=Ia.exec(e))?(t="-"===r[1]?-1:(r[1],1),d={y:Ga(r[2],t),M:Ga(r[3],t),w:Ga(r[4],t),d:Ga(r[5],t),h:Ga(r[6],t),m:Ga(r[7],t),s:Ga(r[8],t)}):null==d?d={}:"object"==typeof d&&("from"in d||"to"in d)&&(n=function(e,a){var t;if(!e.isValid()||!a.isValid())return{milliseconds:0,months:0};a=za(a,e),e.isBefore(a)?t=Ua(e,a):((t=Ua(a,e)).milliseconds=-t.milliseconds,t.months=-t.months);return t}(Sa(d.from),Sa(d.to)),(d={}).ms=n.milliseconds,d.M=n.months),s=new Pa(d),Oa(e)&&h(e,"_locale")&&(s._locale=e._locale),s}function Ga(e,a){var t=e&&parseFloat(e.replace(",","."));return(isNaN(t)?0:t)*a}function Ua(e,a){var t={milliseconds:0,months:0};return t.months=a.month()-e.month()+12*(a.year()-e.year()),e.clone().add(t.months,"M").isAfter(a)&&--t.months,t.milliseconds=+a-+e.clone().add(t.months,"M"),t}function Va(s,n){return function(e,a){var t;return null===a||isNaN(+a)||(S(n,"moment()."+n+"(period, number) is deprecated. Please use moment()."+n+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),t=e,e=a,a=t),Ka(this,Ca(e="string"==typeof e?+e:e,a),s),this}}function Ka(e,a,t,s){var n=a._milliseconds,d=Wa(a._days),r=Wa(a._months);e.isValid()&&(s=null==s||s,r&&We(e,He(e,"Month")+r*t),d&&be(e,"Date",He(e,"Date")+d*t),n&&e._d.setTime(e._d.valueOf()+n*t),s&&l.updateOffset(e,d||r))}Ca.fn=Pa.prototype,Ca.invalid=function(){return Ca(NaN)};var $a=Va(1,"add"),Za=Va(-1,"subtract");function Ba(e,a){var t=12*(a.year()-e.year())+(a.month()-e.month()),s=e.clone().add(t,"months");return-(t+(a-s<0?(a-s)/(s-e.clone().add(t-1,"months")):(a-s)/(e.clone().add(t+1,"months")-s)))||0}function qa(e){var a;return void 0===e?this._locale._abbr:(null!=(a=oa(e))&&(this._locale=a),this)}l.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",l.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Qa=t("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function Xa(){return this._locale}function et(e,a){I(0,[e,e.length],0,a)}function at(e,a,t,s,n){var d;return null==e?Ie(this,s,n).year:((d=Ce(e,s,n))<a&&(a=d),function(e,a,t,s,n){var d=Re(e,a,t,s,n),r=Je(d.year,0,d.dayOfYear);return this.year(r.getUTCFullYear()),this.month(r.getUTCMonth()),this.date(r.getUTCDate()),this}.call(this,e,a,t,s,n))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),et("gggg","weekYear"),et("ggggg","weekYear"),et("GGGG","isoWeekYear"),et("GGGGG","isoWeekYear"),P("weekYear","gg"),P("isoWeekYear","GG"),A("weekYear",1),A("isoWeekYear",1),ie("G",se),ie("g",se),ie("GG",B,V),ie("gg",B,V),ie("GGGG",ee,$),ie("gggg",ee,$),ie("GGGGG",ae,Z),ie("ggggg",ae,Z),Me(["gggg","ggggg","GGGG","GGGGG"],function(e,a,t,s){a[s.substr(0,2)]=g(e)}),Me(["gg","GG"],function(e,a,t,s){a[s]=l.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),P("quarter","Q"),A("quarter",7),ie("Q",U),le("Q",function(e,a){a[Le]=3*(g(e)-1)}),I("D",["DD",2],"Do","date"),P("date","D"),A("date",9),ie("D",B),ie("DD",B,V),ie("Do",function(e,a){return e?a._dayOfMonthOrdinalParse||a._ordinalParse:a._dayOfMonthOrdinalParseLenient}),le(["D","DD"],ce),le("Do",function(e,a){a[ce]=g(e.match(B)[0])});var tt=Se("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),P("dayOfYear","DDD"),A("dayOfYear",4),ie("DDD",X),ie("DDDD",K),le(["DDD","DDDD"],function(e,a,t){t._dayOfYear=g(e)}),I("m",["mm",2],0,"minute"),P("minute","m"),A("minute",14),ie("m",B),ie("mm",B,V),le(["m","mm"],ye);var st=Se("Minutes",!1);I("s",["ss",2],0,"second"),P("second","s"),A("second",15),ie("s",B),ie("ss",B,V),le(["s","ss"],fe);var nt,dt=Se("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),P("millisecond","ms"),A("millisecond",16),ie("S",X,U),ie("SS",X,V),ie("SSS",X,K),nt="SSSS";nt.length<=9;nt+="S")ie(nt,te);function rt(e,a){a[ke]=g(1e3*("0."+e))}for(nt="S";nt.length<=9;nt+="S")le(nt,rt);var _t=Se("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var it=p.prototype;function ot(e){return e}it.add=$a,it.calendar=function(e,a){var t=e||Sa(),s=za(t,this).startOf("day"),n=l.calendarFormat(this,s)||"sameElse",d=a&&(H(a[n])?a[n].call(this,t):a[n]);return this.format(d||this.localeData().calendar(n,this,Sa(t)))},it.clone=function(){return new p(this)},it.diff=function(e,a,t){var s,n,d;if(!this.isValid())return NaN;if(!(s=za(e,this)).isValid())return NaN;switch(n=6e4*(s.utcOffset()-this.utcOffset()),a=O(a)){case"year":d=Ba(this,s)/12;break;case"month":d=Ba(this,s);break;case"quarter":d=Ba(this,s)/3;break;case"second":d=(this-s)/1e3;break;case"minute":d=(this-s)/6e4;break;case"hour":d=(this-s)/36e5;break;case"day":d=(this-s-n)/864e5;break;case"week":d=(this-s-n)/6048e5;break;default:d=this-s}return t?d:T(d)},it.endOf=function(e){return void 0===(e=O(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))},it.format=function(e){e||(e=this.isUtc()?l.defaultFormatUtc:l.defaultFormat);var a=C(this,e);return this.localeData().postformat(a)},it.from=function(e,a){return this.isValid()&&(D(e)&&e.isValid()||Sa(e).isValid())?Ca({to:this,from:e}).locale(this.locale()).humanize(!a):this.localeData().invalidDate()},it.fromNow=function(e){return this.from(Sa(),e)},it.to=function(e,a){return this.isValid()&&(D(e)&&e.isValid()||Sa(e).isValid())?Ca({from:this,to:e}).locale(this.locale()).humanize(!a):this.localeData().invalidDate()},it.toNow=function(e){return this.to(Sa(),e)},it.get=function(e){return H(this[e=O(e)])?this[e]():this},it.invalidAt=function(){return Y(this).overflow},it.isAfter=function(e,a){var t=D(e)?e:Sa(e);return!(!this.isValid()||!t.isValid())&&("millisecond"===(a=O(o(a)?"millisecond":a))?this.valueOf()>t.valueOf():t.valueOf()<this.clone().startOf(a).valueOf())},it.isBefore=function(e,a){var t=D(e)?e:Sa(e);return!(!this.isValid()||!t.isValid())&&("millisecond"===(a=O(o(a)?"millisecond":a))?this.valueOf()<t.valueOf():this.clone().endOf(a).valueOf()<t.valueOf())},it.isBetween=function(e,a,t,s){return("("===(s=s||"()")[0]?this.isAfter(e,t):!this.isBefore(e,t))&&(")"===s[1]?this.isBefore(a,t):!this.isAfter(a,t))},it.isSame=function(e,a){var t,s=D(e)?e:Sa(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(a=O(a||"millisecond"))?this.valueOf()===s.valueOf():(t=s.valueOf(),this.clone().startOf(a).valueOf()<=t&&t<=this.clone().endOf(a).valueOf()))},it.isSameOrAfter=function(e,a){return this.isSame(e,a)||this.isAfter(e,a)},it.isSameOrBefore=function(e,a){return this.isSame(e,a)||this.isBefore(e,a)},it.isValid=function(){return y(this)},it.lang=Qa,it.locale=qa,it.localeData=Xa,it.max=ba,it.min=Ha,it.parsingFlags=function(){return L({},Y(this))},it.set=function(e,a){if("object"==typeof e)for(var t=function(e){var a=[];for(var t in e)a.push({unit:t,priority:E[t]});return a.sort(function(e,a){return e.priority-a.priority}),a}(e=W(e)),s=0;s<t.length;s++)this[t[s].unit](e[t[s].unit]);else if(H(this[e=O(e)]))return this[e](a);return this},it.startOf=function(e){switch(e=O(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this},it.subtract=Za,it.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},it.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},it.toDate=function(){return new Date(this.valueOf())},it.toISOString=function(e){if(!this.isValid())return null;var a=!0!==e,t=a?this.clone().utc():this;return t.year()<0||9999<t.year()?C(t,a?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):H(Date.prototype.toISOString)?a?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",C(t,"Z")):C(t,a?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},it.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",a="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",a="Z");var t="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",n=a+'[")]';return this.format(t+s+"-MM-DD[T]HH:mm:ss.SSS"+n)},it.toJSON=function(){return this.isValid()?this.toISOString():null},it.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},it.unix=function(){return Math.floor(this.valueOf()/1e3)},it.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},it.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},it.year=ve,it.isLeapYear=function(){return ge(this.year())},it.weekYear=function(e){return at.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},it.isoWeekYear=function(e){return at.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},it.quarter=it.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},it.month=Ee,it.daysInMonth=function(){return je(this.year(),this.month())},it.week=it.weeks=function(e){var a=this.localeData().week(this);return null==e?a:this.add(7*(e-a),"d")},it.isoWeek=it.isoWeeks=function(e){var a=Ie(this,1,4).week;return null==e?a:this.add(7*(e-a),"d")},it.weeksInYear=function(){var e=this.localeData()._week;return Ce(this.year(),e.dow,e.doy)},it.isoWeeksInYear=function(){return Ce(this.year(),1,4)},it.date=tt,it.day=it.days=function(e){if(!this.isValid())return null!=e?this:NaN;var a,t,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(a=e,t=this.localeData(),e="string"!=typeof a?a:isNaN(a)?"number"==typeof(a=t.weekdaysParse(a))?a:null:parseInt(a,10),this.add(e-s,"d")):s},it.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var a=(this.day()+7-this.localeData()._week.dow)%7;return null==e?a:this.add(e-a,"d")},it.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var a=(t=e,s=this.localeData(),"string"==typeof t?s.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?a:a-7)}return this.day()||7;var t,s},it.dayOfYear=function(e){var a=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?a:this.add(e-a,"d")},it.hour=it.hours=aa,it.minute=it.minutes=st,it.second=it.seconds=dt,it.millisecond=it.milliseconds=_t,it.utcOffset=function(e,a,t){var s,n=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(null===(e=Fa(de,e)))return this}else Math.abs(e)<16&&!t&&(e*=60);return!this._isUTC&&a&&(s=Ja(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),n!==e&&(!a||this._changeInProgress?Ka(this,Ca(e-n,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,l.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?n:Ja(this)},it.utc=function(e){return this.utcOffset(0,e)},it.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Ja(this),"m")),this},it.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Fa(ne,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},it.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?Sa(e).utcOffset():0,(this.utcOffset()-e)%60==0)},it.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},it.isLocal=function(){return!!this.isValid()&&!this._isUTC},it.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},it.isUtc=Na,it.isUTC=Na,it.zoneAbbr=function(){return this._isUTC?"UTC":""},it.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},it.dates=t("dates accessor is deprecated. Use date instead.",tt),it.months=t("months accessor is deprecated. Use month instead",Ee),it.years=t("years accessor is deprecated. Use year instead",ve),it.zone=t("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,a){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,a),this):-this.utcOffset()}),it.isDSTShifted=t("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!o(this._isDSTShifted))return this._isDSTShifted;var e={};if(k(e,this),(e=wa(e))._a){var a=e._isUTC?c(e._a):Sa(e._a);this._isDSTShifted=this.isValid()&&0<r(e._a,a.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var mt=j.prototype;function ut(e,a,t,s){var n=oa(),d=c().set(s,a);return n[t](d,e)}function lt(e,a,t){if(m(e)&&(a=e,e=void 0),e=e||"",null!=a)return ut(e,a,t,"month");var s,n=[];for(s=0;s<12;s++)n[s]=ut(e,s,t,"month");return n}function Mt(e,a,t,s){"boolean"==typeof e?m(a)&&(t=a,a=void 0):(a=e,e=!1,m(t=a)&&(t=a,a=void 0)),a=a||"";var n,d=oa(),r=e?d._week.dow:0;if(null!=t)return ut(a,(t+r)%7,s,"day");var _=[];for(n=0;n<7;n++)_[n]=ut(a,(n+r)%7,s,"day");return _}mt.calendar=function(e,a,t){var s=this._calendar[e]||this._calendar.sameElse;return H(s)?s.call(a,t):s},mt.longDateFormat=function(e){var a=this._longDateFormat[e],t=this._longDateFormat[e.toUpperCase()];return a||!t?a:(this._longDateFormat[e]=t.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},mt.invalidDate=function(){return this._invalidDate},mt.ordinal=function(e){return this._ordinal.replace("%d",e)},mt.preparse=ot,mt.postformat=ot,mt.relativeTime=function(e,a,t,s){var n=this._relativeTime[t];return H(n)?n(e,a,t,s):n.replace(/%d/i,e)},mt.pastFuture=function(e,a){var t=this._relativeTime[0<e?"future":"past"];return H(t)?t(a):t.replace(/%s/i,a)},mt.set=function(e){var a,t;for(t in e)H(a=e[t])?this[t]=a:this["_"+t]=a;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},mt.months=function(e,a){return e?_(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||xe).test(a)?"format":"standalone"][e.month()]:_(this._months)?this._months:this._months.standalone},mt.monthsShort=function(e,a){return e?_(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[xe.test(a)?"format":"standalone"][e.month()]:_(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},mt.monthsParse=function(e,a,t){var s,n,d;if(this._monthsParseExact)return function(e,a,t){var s,n,d,r=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)d=c([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(d,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(d,"").toLocaleLowerCase();return t?"MMM"===a?-1!==(n=we.call(this._shortMonthsParse,r))?n:null:-1!==(n=we.call(this._longMonthsParse,r))?n:null:"MMM"===a?-1!==(n=we.call(this._shortMonthsParse,r))?n:-1!==(n=we.call(this._longMonthsParse,r))?n:null:-1!==(n=we.call(this._longMonthsParse,r))?n:-1!==(n=we.call(this._shortMonthsParse,r))?n:null}.call(this,e,a,t);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(n=c([2e3,s]),t&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(n,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(n,"").replace(".","")+"$","i")),t||this._monthsParse[s]||(d="^"+this.months(n,"")+"|^"+this.monthsShort(n,""),this._monthsParse[s]=new RegExp(d.replace(".",""),"i")),t&&"MMMM"===a&&this._longMonthsParse[s].test(e))return s;if(t&&"MMM"===a&&this._shortMonthsParse[s].test(e))return s;if(!t&&this._monthsParse[s].test(e))return s}},mt.monthsRegex=function(e){return this._monthsParseExact?(h(this,"_monthsRegex")||ze.call(this),e?this._monthsStrictRegex:this._monthsRegex):(h(this,"_monthsRegex")||(this._monthsRegex=Fe),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},mt.monthsShortRegex=function(e){return this._monthsParseExact?(h(this,"_monthsRegex")||ze.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(h(this,"_monthsShortRegex")||(this._monthsShortRegex=Ae),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},mt.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},mt.firstDayOfYear=function(){return this._week.doy},mt.firstDayOfWeek=function(){return this._week.dow},mt.weekdays=function(e,a){return e?_(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(a)?"format":"standalone"][e.day()]:_(this._weekdays)?this._weekdays:this._weekdays.standalone},mt.weekdaysMin=function(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin},mt.weekdaysShort=function(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort},mt.weekdaysParse=function(e,a,t){var s,n,d;if(this._weekdaysParseExact)return function(e,a,t){var s,n,d,r=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)d=c([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(d,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(d,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(d,"").toLocaleLowerCase();return t?"dddd"===a?-1!==(n=we.call(this._weekdaysParse,r))?n:null:"ddd"===a?-1!==(n=we.call(this._shortWeekdaysParse,r))?n:null:-1!==(n=we.call(this._minWeekdaysParse,r))?n:null:"dddd"===a?-1!==(n=we.call(this._weekdaysParse,r))?n:-1!==(n=we.call(this._shortWeekdaysParse,r))?n:-1!==(n=we.call(this._minWeekdaysParse,r))?n:null:"ddd"===a?-1!==(n=we.call(this._shortWeekdaysParse,r))?n:-1!==(n=we.call(this._weekdaysParse,r))?n:-1!==(n=we.call(this._minWeekdaysParse,r))?n:null:-1!==(n=we.call(this._minWeekdaysParse,r))?n:-1!==(n=we.call(this._weekdaysParse,r))?n:-1!==(n=we.call(this._shortWeekdaysParse,r))?n:null}.call(this,e,a,t);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(n=c([2e3,1]).day(s),t&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(n,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(n,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(n,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(d="^"+this.weekdays(n,"")+"|^"+this.weekdaysShort(n,"")+"|^"+this.weekdaysMin(n,""),this._weekdaysParse[s]=new RegExp(d.replace(".",""),"i")),t&&"dddd"===a&&this._fullWeekdaysParse[s].test(e))return s;if(t&&"ddd"===a&&this._shortWeekdaysParse[s].test(e))return s;if(t&&"dd"===a&&this._minWeekdaysParse[s].test(e))return s;if(!t&&this._weekdaysParse[s].test(e))return s}},mt.weekdaysRegex=function(e){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(h(this,"_weekdaysRegex")||(this._weekdaysRegex=Ke),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},mt.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(h(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=$e),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},mt.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(h(this,"_weekdaysRegex")||Be.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(h(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Ze),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},mt.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},mt.meridiem=function(e,a,t){return 11<e?t?"pm":"PM":t?"am":"AM"},_a("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var a=e%10;return e+(1===g(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")}}),l.lang=t("moment.lang is deprecated. Use moment.locale instead.",_a),l.langData=t("moment.langData is deprecated. Use moment.localeData instead.",oa);var ht=Math.abs;function Lt(e,a,t,s){var n=Ca(a,t);return e._milliseconds+=s*n._milliseconds,e._days+=s*n._days,e._months+=s*n._months,e._bubble()}function ct(e){return e<0?Math.floor(e):Math.ceil(e)}function Yt(e){return 4800*e/146097}function yt(e){return 146097*e/4800}function ft(e){return function(){return this.as(e)}}var kt=ft("ms"),pt=ft("s"),Dt=ft("m"),Tt=ft("h"),gt=ft("d"),wt=ft("w"),vt=ft("M"),St=ft("y");function Ht(e){return function(){return this.isValid()?this._data[e]:NaN}}var bt=Ht("milliseconds"),jt=Ht("seconds"),xt=Ht("minutes"),Pt=Ht("hours"),Ot=Ht("days"),Wt=Ht("months"),Et=Ht("years");var At=Math.round,Ft={ss:44,s:45,m:45,h:22,d:26,M:11};var zt=Math.abs;function Jt(e){return(0<e)-(e<0)||+e}function Nt(){if(!this.isValid())return this.localeData().invalidDate();var e,a,t=zt(this._milliseconds)/1e3,s=zt(this._days),n=zt(this._months);a=T((e=T(t/60))/60),t%=60,e%=60;var d=T(n/12),r=n%=12,_=s,i=a,o=e,m=t?t.toFixed(3).replace(/\.?0+$/,""):"",u=this.asSeconds();if(!u)return"P0D";var l=u<0?"-":"",M=Jt(this._months)!==Jt(u)?"-":"",h=Jt(this._days)!==Jt(u)?"-":"",L=Jt(this._milliseconds)!==Jt(u)?"-":"";return l+"P"+(d?M+d+"Y":"")+(r?M+r+"M":"")+(_?h+_+"D":"")+(i||o||m?"T":"")+(i?L+i+"H":"")+(o?L+o+"M":"")+(m?L+m+"S":"")}var Rt=Pa.prototype;Rt.isValid=function(){return this._isValid},Rt.abs=function(){var e=this._data;return this._milliseconds=ht(this._milliseconds),this._days=ht(this._days),this._months=ht(this._months),e.milliseconds=ht(e.milliseconds),e.seconds=ht(e.seconds),e.minutes=ht(e.minutes),e.hours=ht(e.hours),e.months=ht(e.months),e.years=ht(e.years),this},Rt.add=function(e,a){return Lt(this,e,a,1)},Rt.subtract=function(e,a){return Lt(this,e,a,-1)},Rt.as=function(e){if(!this.isValid())return NaN;var a,t,s=this._milliseconds;if("month"===(e=O(e))||"year"===e)return a=this._days+s/864e5,t=this._months+Yt(a),"month"===e?t:t/12;switch(a=this._days+Math.round(yt(this._months)),e){case"week":return a/7+s/6048e5;case"day":return a+s/864e5;case"hour":return 24*a+s/36e5;case"minute":return 1440*a+s/6e4;case"second":return 86400*a+s/1e3;case"millisecond":return Math.floor(864e5*a)+s;default:throw new Error("Unknown unit "+e)}},Rt.asMilliseconds=kt,Rt.asSeconds=pt,Rt.asMinutes=Dt,Rt.asHours=Tt,Rt.asDays=gt,Rt.asWeeks=wt,Rt.asMonths=vt,Rt.asYears=St,Rt.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*g(this._months/12):NaN},Rt._bubble=function(){var e,a,t,s,n,d=this._milliseconds,r=this._days,_=this._months,i=this._data;return 0<=d&&0<=r&&0<=_||d<=0&&r<=0&&_<=0||(d+=864e5*ct(yt(_)+r),_=r=0),i.milliseconds=d%1e3,e=T(d/1e3),i.seconds=e%60,a=T(e/60),i.minutes=a%60,t=T(a/60),i.hours=t%24,_+=n=T(Yt(r+=T(t/24))),r-=ct(yt(n)),s=T(_/12),_%=12,i.days=r,i.months=_,i.years=s,this},Rt.clone=function(){return Ca(this)},Rt.get=function(e){return e=O(e),this.isValid()?this[e+"s"]():NaN},Rt.milliseconds=bt,Rt.seconds=jt,Rt.minutes=xt,Rt.hours=Pt,Rt.days=Ot,Rt.weeks=function(){return T(this.days()/7)},Rt.months=Wt,Rt.years=Et,Rt.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var a,t,s,n,d,r,_,i,o,m,u,l=this.localeData(),M=(t=!e,s=l,n=Ca(a=this).abs(),d=At(n.as("s")),r=At(n.as("m")),_=At(n.as("h")),i=At(n.as("d")),o=At(n.as("M")),m=At(n.as("y")),(u=d<=Ft.ss&&["s",d]||d<Ft.s&&["ss",d]||r<=1&&["m"]||r<Ft.m&&["mm",r]||_<=1&&["h"]||_<Ft.h&&["hh",_]||i<=1&&["d"]||i<Ft.d&&["dd",i]||o<=1&&["M"]||o<Ft.M&&["MM",o]||m<=1&&["y"]||["yy",m])[2]=t,u[3]=0<+a,u[4]=s,function(e,a,t,s,n){return n.relativeTime(a||1,!!t,e,s)}.apply(null,u));return e&&(M=l.pastFuture(+this,M)),l.postformat(M)},Rt.toISOString=Nt,Rt.toString=Nt,Rt.toJSON=Nt,Rt.locale=qa,Rt.localeData=Xa,Rt.toIsoString=t("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Nt),Rt.lang=Qa,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ie("x",se),ie("X",/[+-]?\d+(\.\d{1,3})?/),le("X",function(e,a,t){t._d=new Date(1e3*parseFloat(e,10))}),le("x",function(e,a,t){t._d=new Date(g(e))}),l.version="2.22.2",e=Sa,l.fn=it,l.min=function(){return ja("isBefore",[].slice.call(arguments,0))},l.max=function(){return ja("isAfter",[].slice.call(arguments,0))},l.now=function(){return Date.now?Date.now():+new Date},l.utc=c,l.unix=function(e){return Sa(1e3*e)},l.months=function(e,a){return lt(e,a,"months")},l.isDate=u,l.locale=_a,l.invalid=f,l.duration=Ca,l.isMoment=D,l.weekdays=function(e,a,t){return Mt(e,a,t,"weekdays")},l.parseZone=function(){return Sa.apply(null,arguments).parseZone()},l.localeData=oa,l.isDuration=Oa,l.monthsShort=function(e,a){return lt(e,a,"monthsShort")},l.weekdaysMin=function(e,a,t){return Mt(e,a,t,"weekdaysMin")},l.defineLocale=ia,l.updateLocale=function(e,a){if(null!=a){var t,s,n=ta;null!=(s=ra(e))&&(n=s._config),(t=new j(a=b(n,a))).parentLocale=sa[e],sa[e]=t,_a(e)}else null!=sa[e]&&(null!=sa[e].parentLocale?sa[e]=sa[e].parentLocale:null!=sa[e]&&delete sa[e]);return sa[e]},l.locales=function(){return s(sa)},l.weekdaysShort=function(e,a,t){return Mt(e,a,t,"weekdaysShort")},l.normalizeUnits=O,l.relativeTimeRounding=function(e){return void 0===e?At:"function"==typeof e&&(At=e,!0)},l.relativeTimeThreshold=function(e,a){return void 0!==Ft[e]&&(void 0===a?Ft[e]:(Ft[e]=a,"s"===e&&(Ft.ss=a-1),!0))},l.calendarFormat=function(e,a){var t=e.diff(a,"days",!0);return t<-6?"sameElse":t<-1?"lastWeek":t<0?"lastDay":t<1?"sameDay":t<2?"nextDay":t<7?"nextWeek":"sameElse"},l.prototype=it,l.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},l.defineLocale("af",{months:"Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),weekdays:"Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),weekdaysShort:"Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),weekdaysMin:"So_Ma_Di_Wo_Do_Vr_Sa".split("_"),meridiemParse:/vm|nm/i,isPM:function(e){return/^nm$/i.test(e)},meridiem:function(e,a,t){return e<12?t?"vm":"VM":t?"nm":"NM"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Vandag om] LT",nextDay:"[M\xf4re om] LT",nextWeek:"dddd [om] LT",lastDay:"[Gister om] LT",lastWeek:"[Laas] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oor %s",past:"%s gelede",s:"'n paar sekondes",ss:"%d sekondes",m:"'n minuut",mm:"%d minute",h:"'n uur",hh:"%d ure",d:"'n dag",dd:"%d dae",M:"'n maand",MM:"%d maande",y:"'n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),l.defineLocale("ar-dz",{months:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u0623\u062d_\u0625\u062b_\u062b\u0644\u0627_\u0623\u0631_\u062e\u0645_\u062c\u0645_\u0633\u0628".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:0,doy:4}}),l.defineLocale("ar-kw",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062a\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062a\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:0,doy:12}});var It={1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",7:"7",8:"8",9:"9",0:"0"},Ct=function(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5},Gt={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},Ut=function(r){return function(e,a,t,s){var n=Ct(e),d=Gt[r][Ct(e)];return 2===n&&(d=d[a?0:1]),d.replace(/%d/i,e)}},Vt=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"];l.defineLocale("ar-ly",{months:Vt,monthsShort:Vt,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,t){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:Ut("s"),ss:Ut("s"),m:Ut("m"),mm:Ut("m"),h:Ut("h"),hh:Ut("h"),d:Ut("d"),dd:Ut("d"),M:Ut("M"),MM:Ut("M"),y:Ut("y"),yy:Ut("y")},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return It[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}}),l.defineLocale("ar-ma",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648\u0632_\u063a\u0634\u062a_\u0634\u062a\u0646\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0646\u0628\u0631_\u062f\u062c\u0646\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062a\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0627\u062d\u062f_\u0627\u062a\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:6,doy:12}});var Kt={1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"},$t={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"};l.defineLocale("ar-sa",{months:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u064a\u0646\u0627\u064a\u0631_\u0641\u0628\u0631\u0627\u064a\u0631_\u0645\u0627\u0631\u0633_\u0623\u0628\u0631\u064a\u0644_\u0645\u0627\u064a\u0648_\u064a\u0648\u0646\u064a\u0648_\u064a\u0648\u0644\u064a\u0648_\u0623\u063a\u0633\u0637\u0633_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,t){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return $t[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return Kt[e]}).replace(/,/g,"\u060c")},week:{dow:0,doy:6}}),l.defineLocale("ar-tn",{months:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),monthsShort:"\u062c\u0627\u0646\u0641\u064a_\u0641\u064a\u0641\u0631\u064a_\u0645\u0627\u0631\u0633_\u0623\u0641\u0631\u064a\u0644_\u0645\u0627\u064a_\u062c\u0648\u0627\u0646_\u062c\u0648\u064a\u0644\u064a\u0629_\u0623\u0648\u062a_\u0633\u0628\u062a\u0645\u0628\u0631_\u0623\u0643\u062a\u0648\u0628\u0631_\u0646\u0648\u0641\u0645\u0628\u0631_\u062f\u064a\u0633\u0645\u0628\u0631".split("_"),weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u0627 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0644\u0649 \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0641\u064a %s",past:"\u0645\u0646\u0630 %s",s:"\u062b\u0648\u0627\u0646",ss:"%d \u062b\u0627\u0646\u064a\u0629",m:"\u062f\u0642\u064a\u0642\u0629",mm:"%d \u062f\u0642\u0627\u0626\u0642",h:"\u0633\u0627\u0639\u0629",hh:"%d \u0633\u0627\u0639\u0627\u062a",d:"\u064a\u0648\u0645",dd:"%d \u0623\u064a\u0627\u0645",M:"\u0634\u0647\u0631",MM:"%d \u0623\u0634\u0647\u0631",y:"\u0633\u0646\u0629",yy:"%d \u0633\u0646\u0648\u0627\u062a"},week:{dow:1,doy:4}});var Zt={1:"\u0661",2:"\u0662",3:"\u0663",4:"\u0664",5:"\u0665",6:"\u0666",7:"\u0667",8:"\u0668",9:"\u0669",0:"\u0660"},Bt={"\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u0660":"0"},qt=function(e){return 0===e?0:1===e?1:2===e?2:3<=e%100&&e%100<=10?3:11<=e%100?4:5},Qt={s:["\u0623\u0642\u0644 \u0645\u0646 \u062b\u0627\u0646\u064a\u0629","\u062b\u0627\u0646\u064a\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062b\u0627\u0646\u064a\u062a\u0627\u0646","\u062b\u0627\u0646\u064a\u062a\u064a\u0646"],"%d \u062b\u0648\u0627\u0646","%d \u062b\u0627\u0646\u064a\u0629","%d \u062b\u0627\u0646\u064a\u0629"],m:["\u0623\u0642\u0644 \u0645\u0646 \u062f\u0642\u064a\u0642\u0629","\u062f\u0642\u064a\u0642\u0629 \u0648\u0627\u062d\u062f\u0629",["\u062f\u0642\u064a\u0642\u062a\u0627\u0646","\u062f\u0642\u064a\u0642\u062a\u064a\u0646"],"%d \u062f\u0642\u0627\u0626\u0642","%d \u062f\u0642\u064a\u0642\u0629","%d \u062f\u0642\u064a\u0642\u0629"],h:["\u0623\u0642\u0644 \u0645\u0646 \u0633\u0627\u0639\u0629","\u0633\u0627\u0639\u0629 \u0648\u0627\u062d\u062f\u0629",["\u0633\u0627\u0639\u062a\u0627\u0646","\u0633\u0627\u0639\u062a\u064a\u0646"],"%d \u0633\u0627\u0639\u0627\u062a","%d \u0633\u0627\u0639\u0629","%d \u0633\u0627\u0639\u0629"],d:["\u0623\u0642\u0644 \u0645\u0646 \u064a\u0648\u0645","\u064a\u0648\u0645 \u0648\u0627\u062d\u062f",["\u064a\u0648\u0645\u0627\u0646","\u064a\u0648\u0645\u064a\u0646"],"%d \u0623\u064a\u0627\u0645","%d \u064a\u0648\u0645\u064b\u0627","%d \u064a\u0648\u0645"],M:["\u0623\u0642\u0644 \u0645\u0646 \u0634\u0647\u0631","\u0634\u0647\u0631 \u0648\u0627\u062d\u062f",["\u0634\u0647\u0631\u0627\u0646","\u0634\u0647\u0631\u064a\u0646"],"%d \u0623\u0634\u0647\u0631","%d \u0634\u0647\u0631\u0627","%d \u0634\u0647\u0631"],y:["\u0623\u0642\u0644 \u0645\u0646 \u0639\u0627\u0645","\u0639\u0627\u0645 \u0648\u0627\u062d\u062f",["\u0639\u0627\u0645\u0627\u0646","\u0639\u0627\u0645\u064a\u0646"],"%d \u0623\u0639\u0648\u0627\u0645","%d \u0639\u0627\u0645\u064b\u0627","%d \u0639\u0627\u0645"]},Xt=function(r){return function(e,a,t,s){var n=qt(e),d=Qt[r][qt(e)];return 2===n&&(d=d[a?0:1]),d.replace(/%d/i,e)}},es=["\u064a\u0646\u0627\u064a\u0631","\u0641\u0628\u0631\u0627\u064a\u0631","\u0645\u0627\u0631\u0633","\u0623\u0628\u0631\u064a\u0644","\u0645\u0627\u064a\u0648","\u064a\u0648\u0646\u064a\u0648","\u064a\u0648\u0644\u064a\u0648","\u0623\u063a\u0633\u0637\u0633","\u0633\u0628\u062a\u0645\u0628\u0631","\u0623\u0643\u062a\u0648\u0628\u0631","\u0646\u0648\u0641\u0645\u0628\u0631","\u062f\u064a\u0633\u0645\u0628\u0631"];l.defineLocale("ar",{months:es,monthsShort:es,weekdays:"\u0627\u0644\u0623\u062d\u062f_\u0627\u0644\u0625\u062b\u0646\u064a\u0646_\u0627\u0644\u062b\u0644\u0627\u062b\u0627\u0621_\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621_\u0627\u0644\u062e\u0645\u064a\u0633_\u0627\u0644\u062c\u0645\u0639\u0629_\u0627\u0644\u0633\u0628\u062a".split("_"),weekdaysShort:"\u0623\u062d\u062f_\u0625\u062b\u0646\u064a\u0646_\u062b\u0644\u0627\u062b\u0627\u0621_\u0623\u0631\u0628\u0639\u0627\u0621_\u062e\u0645\u064a\u0633_\u062c\u0645\u0639\u0629_\u0633\u0628\u062a".split("_"),weekdaysMin:"\u062d_\u0646_\u062b_\u0631_\u062e_\u062c_\u0633".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/\u200fM/\u200fYYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0635|\u0645/,isPM:function(e){return"\u0645"===e},meridiem:function(e,a,t){return e<12?"\u0635":"\u0645"},calendar:{sameDay:"[\u0627\u0644\u064a\u0648\u0645 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextDay:"[\u063a\u062f\u064b\u0627 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",nextWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastDay:"[\u0623\u0645\u0633 \u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",lastWeek:"dddd [\u0639\u0646\u062f \u0627\u0644\u0633\u0627\u0639\u0629] LT",sameElse:"L"},relativeTime:{future:"\u0628\u0639\u062f %s",past:"\u0645\u0646\u0630 %s",s:Xt("s"),ss:Xt("s"),m:Xt("m"),mm:Xt("m"),h:Xt("h"),hh:Xt("h"),d:Xt("d"),dd:Xt("d"),M:Xt("M"),MM:Xt("M"),y:Xt("y"),yy:Xt("y")},preparse:function(e){return e.replace(/[\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660]/g,function(e){return Bt[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return Zt[e]}).replace(/,/g,"\u060c")},week:{dow:6,doy:12}});var as={1:"-inci",5:"-inci",8:"-inci",70:"-inci",80:"-inci",2:"-nci",7:"-nci",20:"-nci",50:"-nci",3:"-\xfcnc\xfc",4:"-\xfcnc\xfc",100:"-\xfcnc\xfc",6:"-nc\u0131",9:"-uncu",10:"-uncu",30:"-uncu",60:"-\u0131nc\u0131",90:"-\u0131nc\u0131"};function ts(e,a,t){var s,n;return"m"===t?a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443":"h"===t?a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443":e+" "+(s=+e,n={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0456\u043b\u0456\u043d\u0430_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d":"\u0445\u0432\u0456\u043b\u0456\u043d\u0443_\u0445\u0432\u0456\u043b\u0456\u043d\u044b_\u0445\u0432\u0456\u043b\u0456\u043d",hh:a?"\u0433\u0430\u0434\u0437\u0456\u043d\u0430_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d":"\u0433\u0430\u0434\u0437\u0456\u043d\u0443_\u0433\u0430\u0434\u0437\u0456\u043d\u044b_\u0433\u0430\u0434\u0437\u0456\u043d",dd:"\u0434\u0437\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u0437\u0451\u043d",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u044b_\u043c\u0435\u0441\u044f\u0446\u0430\u045e",yy:"\u0433\u043e\u0434_\u0433\u0430\u0434\u044b_\u0433\u0430\u0434\u043e\u045e"}[t].split("_"),s%10==1&&s%100!=11?n[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?n[1]:n[2])}l.defineLocale("az",{months:"yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),monthsShort:"yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),weekdays:"Bazar_Bazar ert\u0259si_\xc7\u0259r\u015f\u0259nb\u0259 ax\u015fam\u0131_\xc7\u0259r\u015f\u0259nb\u0259_C\xfcm\u0259 ax\u015fam\u0131_C\xfcm\u0259_\u015e\u0259nb\u0259".split("_"),weekdaysShort:"Baz_BzE_\xc7Ax_\xc7\u0259r_CAx_C\xfcm_\u015e\u0259n".split("_"),weekdaysMin:"Bz_BE_\xc7A_\xc7\u0259_CA_C\xfc_\u015e\u0259".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[sabah saat] LT",nextWeek:"[g\u0259l\u0259n h\u0259ft\u0259] dddd [saat] LT",lastDay:"[d\xfcn\u0259n] LT",lastWeek:"[ke\xe7\u0259n h\u0259ft\u0259] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \u0259vv\u0259l",s:"birne\xe7\u0259 saniy\u0259",ss:"%d saniy\u0259",m:"bir d\u0259qiq\u0259",mm:"%d d\u0259qiq\u0259",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir ay",MM:"%d ay",y:"bir il",yy:"%d il"},meridiemParse:/gec\u0259|s\u0259h\u0259r|g\xfcnd\xfcz|ax\u015fam/,isPM:function(e){return/^(g\xfcnd\xfcz|ax\u015fam)$/.test(e)},meridiem:function(e,a,t){return e<4?"gec\u0259":e<12?"s\u0259h\u0259r":e<17?"g\xfcnd\xfcz":"ax\u015fam"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0131nc\u0131|inci|nci|\xfcnc\xfc|nc\u0131|uncu)/,ordinal:function(e){if(0===e)return e+"-\u0131nc\u0131";var a=e%10;return e+(as[a]||as[e%100-a]||as[100<=e?100:null])},week:{dow:1,doy:7}}),l.defineLocale("be",{months:{format:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044f_\u043b\u044e\u0442\u0430\u0433\u0430_\u0441\u0430\u043a\u0430\u0432\u0456\u043a\u0430_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a\u0430_\u0442\u0440\u0430\u045e\u043d\u044f_\u0447\u044d\u0440\u0432\u0435\u043d\u044f_\u043b\u0456\u043f\u0435\u043d\u044f_\u0436\u043d\u0456\u045e\u043d\u044f_\u0432\u0435\u0440\u0430\u0441\u043d\u044f_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a\u0430_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434\u0430_\u0441\u043d\u0435\u0436\u043d\u044f".split("_"),standalone:"\u0441\u0442\u0443\u0434\u0437\u0435\u043d\u044c_\u043b\u044e\u0442\u044b_\u0441\u0430\u043a\u0430\u0432\u0456\u043a_\u043a\u0440\u0430\u0441\u0430\u0432\u0456\u043a_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u044d\u0440\u0432\u0435\u043d\u044c_\u043b\u0456\u043f\u0435\u043d\u044c_\u0436\u043d\u0456\u0432\u0435\u043d\u044c_\u0432\u0435\u0440\u0430\u0441\u0435\u043d\u044c_\u043a\u0430\u0441\u0442\u0440\u044b\u0447\u043d\u0456\u043a_\u043b\u0456\u0441\u0442\u0430\u043f\u0430\u0434_\u0441\u043d\u0435\u0436\u0430\u043d\u044c".split("_")},monthsShort:"\u0441\u0442\u0443\u0434_\u043b\u044e\u0442_\u0441\u0430\u043a_\u043a\u0440\u0430\u0441_\u0442\u0440\u0430\u0432_\u0447\u044d\u0440\u0432_\u043b\u0456\u043f_\u0436\u043d\u0456\u0432_\u0432\u0435\u0440_\u043a\u0430\u0441\u0442_\u043b\u0456\u0441\u0442_\u0441\u043d\u0435\u0436".split("_"),weekdays:{format:"\u043d\u044f\u0434\u0437\u0435\u043b\u044e_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0443_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0443_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),standalone:"\u043d\u044f\u0434\u0437\u0435\u043b\u044f_\u043f\u0430\u043d\u044f\u0434\u0437\u0435\u043b\u0430\u043a_\u0430\u045e\u0442\u043e\u0440\u0430\u043a_\u0441\u0435\u0440\u0430\u0434\u0430_\u0447\u0430\u0446\u0432\u0435\u0440_\u043f\u044f\u0442\u043d\u0456\u0446\u0430_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),isFormat:/\[ ?[\u0423\u0443\u045e] ?(?:\u043c\u0456\u043d\u0443\u043b\u0443\u044e|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u0443\u044e)? ?\] ?dddd/},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0430\u0442_\u0441\u0440_\u0447\u0446_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., HH:mm",LLLL:"dddd, D MMMM YYYY \u0433., HH:mm"},calendar:{sameDay:"[\u0421\u0451\u043d\u043d\u044f \u045e] LT",nextDay:"[\u0417\u0430\u045e\u0442\u0440\u0430 \u045e] LT",lastDay:"[\u0423\u0447\u043e\u0440\u0430 \u045e] LT",nextWeek:function(){return"[\u0423] dddd [\u045e] LT"},lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return"[\u0423 \u043c\u0456\u043d\u0443\u043b\u0443\u044e] dddd [\u045e] LT";case 1:case 2:case 4:return"[\u0423 \u043c\u0456\u043d\u0443\u043b\u044b] dddd [\u045e] LT"}},sameElse:"L"},relativeTime:{future:"\u043f\u0440\u0430\u0437 %s",past:"%s \u0442\u0430\u043c\u0443",s:"\u043d\u0435\u043a\u0430\u043b\u044c\u043a\u0456 \u0441\u0435\u043a\u0443\u043d\u0434",m:ts,mm:ts,h:ts,hh:ts,d:"\u0434\u0437\u0435\u043d\u044c",dd:ts,M:"\u043c\u0435\u0441\u044f\u0446",MM:ts,y:"\u0433\u043e\u0434",yy:ts},meridiemParse:/\u043d\u043e\u0447\u044b|\u0440\u0430\u043d\u0456\u0446\u044b|\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430/,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0430\u0440\u0430)$/.test(e)},meridiem:function(e,a,t){return e<4?"\u043d\u043e\u0447\u044b":e<12?"\u0440\u0430\u043d\u0456\u0446\u044b":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0430\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0456|\u044b|\u0433\u0430)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e%10!=2&&e%10!=3||e%100==12||e%100==13?e+"-\u044b":e+"-\u0456";case"D":return e+"-\u0433\u0430";default:return e}},week:{dow:1,doy:7}}),l.defineLocale("bg",{months:"\u044f\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u044f\u043d\u0440_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u044e\u043d\u0438_\u044e\u043b\u0438_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u044f\u0434\u0430_\u0447\u0435\u0442\u0432\u044a\u0440\u0442\u044a\u043a_\u043f\u0435\u0442\u044a\u043a_\u0441\u044a\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u044f_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u044a\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u043d\u0435\u0441 \u0432] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432] LT",nextWeek:"dddd [\u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return"[\u0412 \u0438\u0437\u043c\u0438\u043d\u0430\u043b\u0430\u0442\u0430] dddd [\u0432] LT";case 1:case 2:case 4:case 5:return"[\u0412 \u0438\u0437\u043c\u0438\u043d\u0430\u043b\u0438\u044f] dddd [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0441\u043b\u0435\u0434 %s",past:"\u043f\u0440\u0435\u0434\u0438 %s",s:"\u043d\u044f\u043a\u043e\u043b\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0434\u0435\u043d",dd:"%d \u0434\u043d\u0438",M:"\u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0430",y:"\u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,t=e%100;return 0===e?e+"-\u0435\u0432":0===t?e+"-\u0435\u043d":10<t&&t<20?e+"-\u0442\u0438":1===a?e+"-\u0432\u0438":2===a?e+"-\u0440\u0438":7===a||8===a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),l.defineLocale("bm",{months:"Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_M\u025bkalo_Zuw\u025bnkalo_Zuluyekalo_Utikalo_S\u025btanburukalo_\u0254kut\u0254burukalo_Nowanburukalo_Desanburukalo".split("_"),monthsShort:"Zan_Few_Mar_Awi_M\u025b_Zuw_Zul_Uti_S\u025bt_\u0254ku_Now_Des".split("_"),weekdays:"Kari_Nt\u025bn\u025bn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),weekdaysShort:"Kar_Nt\u025b_Tar_Ara_Ala_Jum_Sib".split("_"),weekdaysMin:"Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"MMMM [tile] D [san] YYYY",LLL:"MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm",LLLL:"dddd MMMM [tile] D [san] YYYY [l\u025br\u025b] HH:mm"},calendar:{sameDay:"[Bi l\u025br\u025b] LT",nextDay:"[Sini l\u025br\u025b] LT",nextWeek:"dddd [don l\u025br\u025b] LT",lastDay:"[Kunu l\u025br\u025b] LT",lastWeek:"dddd [t\u025bm\u025bnen l\u025br\u025b] LT",sameElse:"L"},relativeTime:{future:"%s k\u0254n\u0254",past:"a b\u025b %s b\u0254",s:"sanga dama dama",ss:"sekondi %d",m:"miniti kelen",mm:"miniti %d",h:"l\u025br\u025b kelen",hh:"l\u025br\u025b %d",d:"tile kelen",dd:"tile %d",M:"kalo kelen",MM:"kalo %d",y:"san kelen",yy:"san %d"},week:{dow:1,doy:4}});var ss={1:"\u09e7",2:"\u09e8",3:"\u09e9",4:"\u09ea",5:"\u09eb",6:"\u09ec",7:"\u09ed",8:"\u09ee",9:"\u09ef",0:"\u09e6"},ns={"\u09e7":"1","\u09e8":"2","\u09e9":"3","\u09ea":"4","\u09eb":"5","\u09ec":"6","\u09ed":"7","\u09ee":"8","\u09ef":"9","\u09e6":"0"};l.defineLocale("bn",{months:"\u099c\u09be\u09a8\u09c1\u09df\u09be\u09b0\u09c0_\u09ab\u09c7\u09ac\u09cd\u09b0\u09c1\u09df\u09be\u09b0\u09bf_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0\u09bf\u09b2_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2\u09be\u0987_\u0986\u0997\u09b8\u09cd\u099f_\u09b8\u09c7\u09aa\u09cd\u099f\u09c7\u09ae\u09cd\u09ac\u09b0_\u0985\u0995\u09cd\u099f\u09cb\u09ac\u09b0_\u09a8\u09ad\u09c7\u09ae\u09cd\u09ac\u09b0_\u09a1\u09bf\u09b8\u09c7\u09ae\u09cd\u09ac\u09b0".split("_"),monthsShort:"\u099c\u09be\u09a8\u09c1_\u09ab\u09c7\u09ac_\u09ae\u09be\u09b0\u09cd\u099a_\u098f\u09aa\u09cd\u09b0_\u09ae\u09c7_\u099c\u09c1\u09a8_\u099c\u09c1\u09b2_\u0986\u0997_\u09b8\u09c7\u09aa\u09cd\u099f_\u0985\u0995\u09cd\u099f\u09cb_\u09a8\u09ad\u09c7_\u09a1\u09bf\u09b8\u09c7".split("_"),weekdays:"\u09b0\u09ac\u09bf\u09ac\u09be\u09b0_\u09b8\u09cb\u09ae\u09ac\u09be\u09b0_\u09ae\u0999\u09cd\u0997\u09b2\u09ac\u09be\u09b0_\u09ac\u09c1\u09a7\u09ac\u09be\u09b0_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf\u09ac\u09be\u09b0_\u09b6\u09c1\u0995\u09cd\u09b0\u09ac\u09be\u09b0_\u09b6\u09a8\u09bf\u09ac\u09be\u09b0".split("_"),weekdaysShort:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997\u09b2_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u09b8\u09cd\u09aa\u09a4\u09bf_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),weekdaysMin:"\u09b0\u09ac\u09bf_\u09b8\u09cb\u09ae_\u09ae\u0999\u09cd\u0997_\u09ac\u09c1\u09a7_\u09ac\u09c3\u09b9\u0983_\u09b6\u09c1\u0995\u09cd\u09b0_\u09b6\u09a8\u09bf".split("_"),longDateFormat:{LT:"A h:mm \u09b8\u09ae\u09df",LTS:"A h:mm:ss \u09b8\u09ae\u09df",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u09b8\u09ae\u09df",LLLL:"dddd, D MMMM YYYY, A h:mm \u09b8\u09ae\u09df"},calendar:{sameDay:"[\u0986\u099c] LT",nextDay:"[\u0986\u0997\u09be\u09ae\u09c0\u0995\u09be\u09b2] LT",nextWeek:"dddd, LT",lastDay:"[\u0997\u09a4\u0995\u09be\u09b2] LT",lastWeek:"[\u0997\u09a4] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u09aa\u09b0\u09c7",past:"%s \u0986\u0997\u09c7",s:"\u0995\u09df\u09c7\u0995 \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",ss:"%d \u09b8\u09c7\u0995\u09c7\u09a8\u09cd\u09a1",m:"\u098f\u0995 \u09ae\u09bf\u09a8\u09bf\u099f",mm:"%d \u09ae\u09bf\u09a8\u09bf\u099f",h:"\u098f\u0995 \u0998\u09a8\u09cd\u099f\u09be",hh:"%d \u0998\u09a8\u09cd\u099f\u09be",d:"\u098f\u0995 \u09a6\u09bf\u09a8",dd:"%d \u09a6\u09bf\u09a8",M:"\u098f\u0995 \u09ae\u09be\u09b8",MM:"%d \u09ae\u09be\u09b8",y:"\u098f\u0995 \u09ac\u099b\u09b0",yy:"%d \u09ac\u099b\u09b0"},preparse:function(e){return e.replace(/[\u09e7\u09e8\u09e9\u09ea\u09eb\u09ec\u09ed\u09ee\u09ef\u09e6]/g,function(e){return ns[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ss[e]})},meridiemParse:/\u09b0\u09be\u09a4|\u09b8\u0995\u09be\u09b2|\u09a6\u09c1\u09aa\u09c1\u09b0|\u09ac\u09bf\u0995\u09be\u09b2|\u09b0\u09be\u09a4/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u09b0\u09be\u09a4"===a&&4<=e||"\u09a6\u09c1\u09aa\u09c1\u09b0"===a&&e<5||"\u09ac\u09bf\u0995\u09be\u09b2"===a?e+12:e},meridiem:function(e,a,t){return e<4?"\u09b0\u09be\u09a4":e<10?"\u09b8\u0995\u09be\u09b2":e<17?"\u09a6\u09c1\u09aa\u09c1\u09b0":e<20?"\u09ac\u09bf\u0995\u09be\u09b2":"\u09b0\u09be\u09a4"},week:{dow:0,doy:6}});var ds={1:"\u0f21",2:"\u0f22",3:"\u0f23",4:"\u0f24",5:"\u0f25",6:"\u0f26",7:"\u0f27",8:"\u0f28",9:"\u0f29",0:"\u0f20"},rs={"\u0f21":"1","\u0f22":"2","\u0f23":"3","\u0f24":"4","\u0f25":"5","\u0f26":"6","\u0f27":"7","\u0f28":"8","\u0f29":"9","\u0f20":"0"};function _s(e,a,t){return e+" "+function(e,a){if(2===a)return function(e){var a={m:"v",b:"v",d:"z"};if(void 0===a[e.charAt(0)])return e;return a[e.charAt(0)]+e.substring(1)}(e);return e}({mm:"munutenn",MM:"miz",dd:"devezh"}[t],e)}function is(e,a,t){var s=e+" ";switch(t){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1===e?"minuta":2===e||3===e||4===e?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1===e?"godina":2===e||3===e||4===e?"godine":"godina"}}l.defineLocale("bo",{months:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f7c_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f5e\u0f72\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f63\u0f94\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0fb2\u0f74\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f62\u0f92\u0fb1\u0f51\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f42\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54".split("_"),monthsShort:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f44\u0f0b\u0f54\u0f7c_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f66\u0f74\u0f58\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f5e\u0f72\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f63\u0f94\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0fb2\u0f74\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f62\u0f92\u0fb1\u0f51\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f51\u0f42\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f45\u0f72\u0f42\u0f0b\u0f54_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f56\u0f45\u0f74\u0f0b\u0f42\u0f49\u0f72\u0f66\u0f0b\u0f54".split("_"),weekdays:"\u0f42\u0f5f\u0f60\u0f0b\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f42\u0f5f\u0f60\u0f0b\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f42\u0f5f\u0f60\u0f0b\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysShort:"\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),weekdaysMin:"\u0f49\u0f72\u0f0b\u0f58\u0f0b_\u0f5f\u0fb3\u0f0b\u0f56\u0f0b_\u0f58\u0f72\u0f42\u0f0b\u0f51\u0f58\u0f62\u0f0b_\u0f63\u0fb7\u0f42\u0f0b\u0f54\u0f0b_\u0f55\u0f74\u0f62\u0f0b\u0f56\u0f74_\u0f54\u0f0b\u0f66\u0f44\u0f66\u0f0b_\u0f66\u0fa4\u0f7a\u0f53\u0f0b\u0f54\u0f0b".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0f51\u0f72\u0f0b\u0f62\u0f72\u0f44] LT",nextDay:"[\u0f66\u0f44\u0f0b\u0f49\u0f72\u0f53] LT",nextWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f62\u0f97\u0f7a\u0f66\u0f0b\u0f58], LT",lastDay:"[\u0f41\u0f0b\u0f66\u0f44] LT",lastWeek:"[\u0f56\u0f51\u0f74\u0f53\u0f0b\u0f55\u0fb2\u0f42\u0f0b\u0f58\u0f50\u0f60\u0f0b\u0f58] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0f63\u0f0b",past:"%s \u0f66\u0f94\u0f53\u0f0b\u0f63",s:"\u0f63\u0f58\u0f0b\u0f66\u0f44",ss:"%d \u0f66\u0f90\u0f62\u0f0b\u0f46\u0f0d",m:"\u0f66\u0f90\u0f62\u0f0b\u0f58\u0f0b\u0f42\u0f45\u0f72\u0f42",mm:"%d \u0f66\u0f90\u0f62\u0f0b\u0f58",h:"\u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51\u0f0b\u0f42\u0f45\u0f72\u0f42",hh:"%d \u0f46\u0f74\u0f0b\u0f5a\u0f7c\u0f51",d:"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f45\u0f72\u0f42",dd:"%d \u0f49\u0f72\u0f53\u0f0b",M:"\u0f5f\u0fb3\u0f0b\u0f56\u0f0b\u0f42\u0f45\u0f72\u0f42",MM:"%d \u0f5f\u0fb3\u0f0b\u0f56",y:"\u0f63\u0f7c\u0f0b\u0f42\u0f45\u0f72\u0f42",yy:"%d \u0f63\u0f7c"},preparse:function(e){return e.replace(/[\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f20]/g,function(e){return rs[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return ds[e]})},meridiemParse:/\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c|\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66|\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44|\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42|\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"===a&&4<=e||"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44"===a&&e<5||"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42"===a?e+12:e},meridiem:function(e,a,t){return e<4?"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c":e<10?"\u0f5e\u0f7c\u0f42\u0f66\u0f0b\u0f40\u0f66":e<17?"\u0f49\u0f72\u0f53\u0f0b\u0f42\u0f74\u0f44":e<20?"\u0f51\u0f42\u0f7c\u0f44\u0f0b\u0f51\u0f42":"\u0f58\u0f5a\u0f53\u0f0b\u0f58\u0f7c"},week:{dow:0,doy:6}}),l.defineLocale("br",{months:"Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),monthsShort:"Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),weekdays:"Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split("_"),weekdaysShort:"Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),weekdaysMin:"Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h[e]mm A",LTS:"h[e]mm:ss A",L:"DD/MM/YYYY",LL:"D [a viz] MMMM YYYY",LLL:"D [a viz] MMMM YYYY h[e]mm A",LLLL:"dddd, D [a viz] MMMM YYYY h[e]mm A"},calendar:{sameDay:"[Hiziv da] LT",nextDay:"[Warc'hoazh da] LT",nextWeek:"dddd [da] LT",lastDay:"[Dec'h da] LT",lastWeek:"dddd [paset da] LT",sameElse:"L"},relativeTime:{future:"a-benn %s",past:"%s 'zo",s:"un nebeud segondenno\xf9",ss:"%d eilenn",m:"ur vunutenn",mm:_s,h:"un eur",hh:"%d eur",d:"un devezh",dd:_s,M:"ur miz",MM:_s,y:"ur bloaz",yy:function(e){switch(function e(a){return 9<a?e(a%10):a}(e)){case 1:case 3:case 4:case 5:case 9:return e+" bloaz";default:return e+" vloaz"}}},dayOfMonthOrdinalParse:/\d{1,2}(a\xf1|vet)/,ordinal:function(e){return e+(1===e?"a\xf1":"vet")},week:{dow:1,doy:4}}),l.defineLocale("bs",{months:"januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:case 3:return"[pro\u0161lu] dddd [u] LT";case 6:return"[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return"[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:is,m:is,mm:is,h:is,hh:is,d:"dan",dd:is,M:"mjesec",MM:is,y:"godinu",yy:is},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),l.defineLocale("ca",{months:{standalone:"gener_febrer_mar\xe7_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),format:"de gener_de febrer_de mar\xe7_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),isFormat:/D[oD]?(\s)+MMMM/},monthsShort:"gen._febr._mar\xe7_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),monthsParseExact:!0,weekdays:"diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),weekdaysShort:"dg._dl._dt._dc._dj._dv._ds.".split("_"),weekdaysMin:"dg_dl_dt_dc_dj_dv_ds".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [de] YYYY",ll:"D MMM YYYY",LLL:"D MMMM [de] YYYY [a les] H:mm",lll:"D MMM YYYY, H:mm",LLLL:"dddd D MMMM [de] YYYY [a les] H:mm",llll:"ddd D MMM YYYY, H:mm"},calendar:{sameDay:function(){return"[avui a "+(1!==this.hours()?"les":"la")+"] LT"},nextDay:function(){return"[dem\xe0 a "+(1!==this.hours()?"les":"la")+"] LT"},nextWeek:function(){return"dddd [a "+(1!==this.hours()?"les":"la")+"] LT"},lastDay:function(){return"[ahir a "+(1!==this.hours()?"les":"la")+"] LT"},lastWeek:function(){return"[el] dddd [passat a "+(1!==this.hours()?"les":"la")+"] LT"},sameElse:"L"},relativeTime:{future:"d'aqu\xed %s",past:"fa %s",s:"uns segons",ss:"%d segons",m:"un minut",mm:"%d minuts",h:"una hora",hh:"%d hores",d:"un dia",dd:"%d dies",M:"un mes",MM:"%d mesos",y:"un any",yy:"%d anys"},dayOfMonthOrdinalParse:/\d{1,2}(r|n|t|\xe8|a)/,ordinal:function(e,a){var t=1===e?"r":2===e?"n":3===e?"r":4===e?"t":"\xe8";return"w"!==a&&"W"!==a||(t="a"),e+t},week:{dow:1,doy:4}});var os="leden_\xfanor_b\u0159ezen_duben_kv\u011bten_\u010derven_\u010dervenec_srpen_z\xe1\u0159\xed_\u0159\xedjen_listopad_prosinec".split("_"),ms="led_\xfano_b\u0159e_dub_kv\u011b_\u010dvn_\u010dvc_srp_z\xe1\u0159_\u0159\xedj_lis_pro".split("_");function us(e){return 1<e&&e<5&&1!=~~(e/10)}function ls(e,a,t,s){var n=e+" ";switch(t){case"s":return a||s?"p\xe1r sekund":"p\xe1r sekundami";case"ss":return a||s?n+(us(e)?"sekundy":"sekund"):n+"sekundami";break;case"m":return a?"minuta":s?"minutu":"minutou";case"mm":return a||s?n+(us(e)?"minuty":"minut"):n+"minutami";break;case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?n+(us(e)?"hodiny":"hodin"):n+"hodinami";break;case"d":return a||s?"den":"dnem";case"dd":return a||s?n+(us(e)?"dny":"dn\xed"):n+"dny";break;case"M":return a||s?"m\u011bs\xedc":"m\u011bs\xedcem";case"MM":return a||s?n+(us(e)?"m\u011bs\xedce":"m\u011bs\xedc\u016f"):n+"m\u011bs\xedci";break;case"y":return a||s?"rok":"rokem";case"yy":return a||s?n+(us(e)?"roky":"let"):n+"lety";break}}function Ms(e,a,t,s){var n={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?n[t][0]:n[t][1]}function hs(e,a,t,s){var n={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?n[t][0]:n[t][1]}function Ls(e,a,t,s){var n={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return a?n[t][0]:n[t][1]}l.defineLocale("cs",{months:os,monthsShort:ms,monthsParse:function(e,a){var t,s=[];for(t=0;t<12;t++)s[t]=new RegExp("^"+e[t]+"$|^"+a[t]+"$","i");return s}(os,ms),shortMonthsParse:function(e){var a,t=[];for(a=0;a<12;a++)t[a]=new RegExp("^"+e[a]+"$","i");return t}(ms),longMonthsParse:function(e){var a,t=[];for(a=0;a<12;a++)t[a]=new RegExp("^"+e[a]+"$","i");return t}(os),weekdays:"ned\u011ble_pond\u011bl\xed_\xfater\xfd_st\u0159eda_\u010dtvrtek_p\xe1tek_sobota".split("_"),weekdaysShort:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),weekdaysMin:"ne_po_\xfat_st_\u010dt_p\xe1_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm",l:"D. M. YYYY"},calendar:{sameDay:"[dnes v] LT",nextDay:"[z\xedtra v] LT",nextWeek:function(){switch(this.day()){case 0:return"[v ned\u011bli v] LT";case 1:case 2:return"[v] dddd [v] LT";case 3:return"[ve st\u0159edu v] LT";case 4:return"[ve \u010dtvrtek v] LT";case 5:return"[v p\xe1tek v] LT";case 6:return"[v sobotu v] LT"}},lastDay:"[v\u010dera v] LT",lastWeek:function(){switch(this.day()){case 0:return"[minulou ned\u011bli v] LT";case 1:case 2:return"[minul\xe9] dddd [v] LT";case 3:return"[minulou st\u0159edu v] LT";case 4:case 5:return"[minul\xfd] dddd [v] LT";case 6:return"[minulou sobotu v] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"p\u0159ed %s",s:ls,ss:ls,m:ls,mm:ls,h:ls,hh:ls,d:ls,dd:ls,M:ls,MM:ls,y:ls,yy:ls},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("cv",{months:"\u043a\u04d1\u0440\u043b\u0430\u0447_\u043d\u0430\u0440\u04d1\u0441_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440\u0442\u043c\u0435_\u0443\u0442\u04d1_\u04ab\u0443\u0440\u043b\u0430_\u0430\u0432\u04d1\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448\u0442\u0430\u0432".split("_"),monthsShort:"\u043a\u04d1\u0440_\u043d\u0430\u0440_\u043f\u0443\u0448_\u0430\u043a\u0430_\u043c\u0430\u0439_\u04ab\u04d7\u0440_\u0443\u0442\u04d1_\u04ab\u0443\u0440_\u0430\u0432\u043d_\u044e\u043f\u0430_\u0447\u04f3\u043a_\u0440\u0430\u0448".split("_"),weekdays:"\u0432\u044b\u0440\u0441\u0430\u0440\u043d\u0438\u043a\u0443\u043d_\u0442\u0443\u043d\u0442\u0438\u043a\u0443\u043d_\u044b\u0442\u043b\u0430\u0440\u0438\u043a\u0443\u043d_\u044e\u043d\u043a\u0443\u043d_\u043a\u04d7\u04ab\u043d\u0435\u0440\u043d\u0438\u043a\u0443\u043d_\u044d\u0440\u043d\u0435\u043a\u0443\u043d_\u0448\u04d1\u043c\u0430\u0442\u043a\u0443\u043d".split("_"),weekdaysShort:"\u0432\u044b\u0440_\u0442\u0443\u043d_\u044b\u0442\u043b_\u044e\u043d_\u043a\u04d7\u04ab_\u044d\u0440\u043d_\u0448\u04d1\u043c".split("_"),weekdaysMin:"\u0432\u0440_\u0442\u043d_\u044b\u0442_\u044e\u043d_\u043a\u04ab_\u044d\u0440_\u0448\u043c".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7]",LLL:"YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm",LLLL:"dddd, YYYY [\u04ab\u0443\u043b\u0445\u0438] MMMM [\u0443\u0439\u04d1\u0445\u04d7\u043d] D[-\u043c\u04d7\u0448\u04d7], HH:mm"},calendar:{sameDay:"[\u041f\u0430\u044f\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextDay:"[\u042b\u0440\u0430\u043d] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastDay:"[\u04d6\u043d\u0435\u0440] LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",nextWeek:"[\u04aa\u0438\u0442\u0435\u0441] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",lastWeek:"[\u0418\u0440\u0442\u043d\u04d7] dddd LT [\u0441\u0435\u0445\u0435\u0442\u0440\u0435]",sameElse:"L"},relativeTime:{future:function(e){return e+(/\u0441\u0435\u0445\u0435\u0442$/i.exec(e)?"\u0440\u0435\u043d":/\u04ab\u0443\u043b$/i.exec(e)?"\u0442\u0430\u043d":"\u0440\u0430\u043d")},past:"%s \u043a\u0430\u044f\u043b\u043b\u0430",s:"\u043f\u04d7\u0440-\u0438\u043a \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",ss:"%d \u04ab\u0435\u043a\u043a\u0443\u043d\u0442",m:"\u043f\u04d7\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u043f\u04d7\u0440 \u0441\u0435\u0445\u0435\u0442",hh:"%d \u0441\u0435\u0445\u0435\u0442",d:"\u043f\u04d7\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u043f\u04d7\u0440 \u0443\u0439\u04d1\u0445",MM:"%d \u0443\u0439\u04d1\u0445",y:"\u043f\u04d7\u0440 \u04ab\u0443\u043b",yy:"%d \u04ab\u0443\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-\u043c\u04d7\u0448/,ordinal:"%d-\u043c\u04d7\u0448",week:{dow:1,doy:7}}),l.defineLocale("cy",{months:"Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),monthsShort:"Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),weekdays:"Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),weekdaysShort:"Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),weekdaysMin:"Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Heddiw am] LT",nextDay:"[Yfory am] LT",nextWeek:"dddd [am] LT",lastDay:"[Ddoe am] LT",lastWeek:"dddd [diwethaf am] LT",sameElse:"L"},relativeTime:{future:"mewn %s",past:"%s yn \xf4l",s:"ychydig eiliadau",ss:"%d eiliad",m:"munud",mm:"%d munud",h:"awr",hh:"%d awr",d:"diwrnod",dd:"%d diwrnod",M:"mis",MM:"%d mis",y:"blwyddyn",yy:"%d flynedd"},dayOfMonthOrdinalParse:/\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,ordinal:function(e){var a="";return 20<e?a=40===e||50===e||60===e||80===e||100===e?"fed":"ain":0<e&&(a=["","af","il","ydd","ydd","ed","ed","ed","fed","fed","fed","eg","fed","eg","eg","fed","eg","eg","fed","eg","fed"][e]),e+a},week:{dow:1,doy:4}}),l.defineLocale("da",{months:"januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8n_man_tir_ons_tor_fre_l\xf8r".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd [d.] D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"p\xe5 dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[i] dddd[s kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"f\xe5 sekunder",ss:"%d sekunder",m:"et minut",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dage",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"et \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("de-at",{months:"J\xe4nner_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"J\xe4n._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:Ms,mm:"%d Minuten",h:Ms,hh:"%d Stunden",d:Ms,dd:Ms,M:Ms,MM:Ms,y:Ms,yy:Ms},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("de-ch",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:hs,mm:"%d Minuten",h:hs,hh:"%d Stunden",d:hs,dd:hs,M:hs,MM:hs,y:hs,yy:hs},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("de",{months:"Januar_Februar_M\xe4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._M\xe4rz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:Ls,mm:"%d Minuten",h:Ls,hh:"%d Stunden",d:Ls,dd:Ls,M:Ls,MM:Ls,y:Ls,yy:Ls},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var cs=["\u0796\u07ac\u0782\u07aa\u0787\u07a6\u0783\u07a9","\u078a\u07ac\u0784\u07b0\u0783\u07aa\u0787\u07a6\u0783\u07a9","\u0789\u07a7\u0783\u07a8\u0797\u07aa","\u0787\u07ad\u0795\u07b0\u0783\u07a9\u078d\u07aa","\u0789\u07ad","\u0796\u07ab\u0782\u07b0","\u0796\u07aa\u078d\u07a6\u0787\u07a8","\u0787\u07af\u078e\u07a6\u0790\u07b0\u0793\u07aa","\u0790\u07ac\u0795\u07b0\u0793\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0787\u07ae\u0786\u07b0\u0793\u07af\u0784\u07a6\u0783\u07aa","\u0782\u07ae\u0788\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa","\u0791\u07a8\u0790\u07ac\u0789\u07b0\u0784\u07a6\u0783\u07aa"],Ys=["\u0787\u07a7\u078b\u07a8\u0787\u07b0\u078c\u07a6","\u0780\u07af\u0789\u07a6","\u0787\u07a6\u0782\u07b0\u078e\u07a7\u0783\u07a6","\u0784\u07aa\u078b\u07a6","\u0784\u07aa\u0783\u07a7\u0790\u07b0\u078a\u07a6\u078c\u07a8","\u0780\u07aa\u0786\u07aa\u0783\u07aa","\u0780\u07ae\u0782\u07a8\u0780\u07a8\u0783\u07aa"];l.defineLocale("dv",{months:cs,monthsShort:cs,weekdays:Ys,weekdaysShort:Ys,weekdaysMin:"\u0787\u07a7\u078b\u07a8_\u0780\u07af\u0789\u07a6_\u0787\u07a6\u0782\u07b0_\u0784\u07aa\u078b\u07a6_\u0784\u07aa\u0783\u07a7_\u0780\u07aa\u0786\u07aa_\u0780\u07ae\u0782\u07a8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/M/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0789\u0786|\u0789\u078a/,isPM:function(e){return"\u0789\u078a"===e},meridiem:function(e,a,t){return e<12?"\u0789\u0786":"\u0789\u078a"},calendar:{sameDay:"[\u0789\u07a8\u0787\u07a6\u078b\u07aa] LT",nextDay:"[\u0789\u07a7\u078b\u07a6\u0789\u07a7] LT",nextWeek:"dddd LT",lastDay:"[\u0787\u07a8\u0787\u07b0\u0794\u07ac] LT",lastWeek:"[\u078a\u07a7\u0787\u07a8\u078c\u07aa\u0788\u07a8] dddd LT",sameElse:"L"},relativeTime:{future:"\u078c\u07ac\u0783\u07ad\u078e\u07a6\u0787\u07a8 %s",past:"\u0786\u07aa\u0783\u07a8\u0782\u07b0 %s",s:"\u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa\u0786\u07ae\u0785\u07ac\u0787\u07b0",ss:"d% \u0790\u07a8\u0786\u07aa\u0782\u07b0\u078c\u07aa",m:"\u0789\u07a8\u0782\u07a8\u0793\u07ac\u0787\u07b0",mm:"\u0789\u07a8\u0782\u07a8\u0793\u07aa %d",h:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07ac\u0787\u07b0",hh:"\u078e\u07a6\u0791\u07a8\u0787\u07a8\u0783\u07aa %d",d:"\u078b\u07aa\u0788\u07a6\u0780\u07ac\u0787\u07b0",dd:"\u078b\u07aa\u0788\u07a6\u0790\u07b0 %d",M:"\u0789\u07a6\u0780\u07ac\u0787\u07b0",MM:"\u0789\u07a6\u0790\u07b0 %d",y:"\u0787\u07a6\u0780\u07a6\u0783\u07ac\u0787\u07b0",yy:"\u0787\u07a6\u0780\u07a6\u0783\u07aa %d"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:7,doy:12}}),l.defineLocale("el",{monthsNominativeEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03ac\u03c1\u03b9\u03bf\u03c2_\u039c\u03ac\u03c1\u03c4\u03b9\u03bf\u03c2_\u0391\u03c0\u03c1\u03af\u03bb\u03b9\u03bf\u03c2_\u039c\u03ac\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bd\u03b9\u03bf\u03c2_\u0399\u03bf\u03cd\u03bb\u03b9\u03bf\u03c2_\u0391\u03cd\u03b3\u03bf\u03c5\u03c3\u03c4\u03bf\u03c2_\u03a3\u03b5\u03c0\u03c4\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u039f\u03ba\u03c4\u03ce\u03b2\u03c1\u03b9\u03bf\u03c2_\u039d\u03bf\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2_\u0394\u03b5\u03ba\u03ad\u03bc\u03b2\u03c1\u03b9\u03bf\u03c2".split("_"),monthsGenitiveEl:"\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5_\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5_\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5_\u039c\u03b1\u0390\u03bf\u03c5_\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5_\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5_\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5_\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5_\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5_\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5".split("_"),months:function(e,a){return e?"string"==typeof a&&/D/.test(a.substring(0,a.indexOf("MMMM")))?this._monthsGenitiveEl[e.month()]:this._monthsNominativeEl[e.month()]:this._monthsNominativeEl},monthsShort:"\u0399\u03b1\u03bd_\u03a6\u03b5\u03b2_\u039c\u03b1\u03c1_\u0391\u03c0\u03c1_\u039c\u03b1\u03ca_\u0399\u03bf\u03c5\u03bd_\u0399\u03bf\u03c5\u03bb_\u0391\u03c5\u03b3_\u03a3\u03b5\u03c0_\u039f\u03ba\u03c4_\u039d\u03bf\u03b5_\u0394\u03b5\u03ba".split("_"),weekdays:"\u039a\u03c5\u03c1\u03b9\u03b1\u03ba\u03ae_\u0394\u03b5\u03c5\u03c4\u03ad\u03c1\u03b1_\u03a4\u03c1\u03af\u03c4\u03b7_\u03a4\u03b5\u03c4\u03ac\u03c1\u03c4\u03b7_\u03a0\u03ad\u03bc\u03c0\u03c4\u03b7_\u03a0\u03b1\u03c1\u03b1\u03c3\u03ba\u03b5\u03c5\u03ae_\u03a3\u03ac\u03b2\u03b2\u03b1\u03c4\u03bf".split("_"),weekdaysShort:"\u039a\u03c5\u03c1_\u0394\u03b5\u03c5_\u03a4\u03c1\u03b9_\u03a4\u03b5\u03c4_\u03a0\u03b5\u03bc_\u03a0\u03b1\u03c1_\u03a3\u03b1\u03b2".split("_"),weekdaysMin:"\u039a\u03c5_\u0394\u03b5_\u03a4\u03c1_\u03a4\u03b5_\u03a0\u03b5_\u03a0\u03b1_\u03a3\u03b1".split("_"),meridiem:function(e,a,t){return 11<e?t?"\u03bc\u03bc":"\u039c\u039c":t?"\u03c0\u03bc":"\u03a0\u039c"},isPM:function(e){return"\u03bc"===(e+"").toLowerCase()[0]},meridiemParse:/[\u03a0\u039c]\.?\u039c?\.?/i,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendarEl:{sameDay:"[\u03a3\u03ae\u03bc\u03b5\u03c1\u03b1 {}] LT",nextDay:"[\u0391\u03cd\u03c1\u03b9\u03bf {}] LT",nextWeek:"dddd [{}] LT",lastDay:"[\u03a7\u03b8\u03b5\u03c2 {}] LT",lastWeek:function(){switch(this.day()){case 6:return"[\u03c4\u03bf \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03bf] dddd [{}] LT";default:return"[\u03c4\u03b7\u03bd \u03c0\u03c1\u03bf\u03b7\u03b3\u03bf\u03cd\u03bc\u03b5\u03bd\u03b7] dddd [{}] LT"}},sameElse:"L"},calendar:function(e,a){var t=this._calendarEl[e],s=a&&a.hours();return H(t)&&(t=t.apply(a)),t.replace("{}",s%12==1?"\u03c3\u03c4\u03b7":"\u03c3\u03c4\u03b9\u03c2")},relativeTime:{future:"\u03c3\u03b5 %s",past:"%s \u03c0\u03c1\u03b9\u03bd",s:"\u03bb\u03af\u03b3\u03b1 \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",ss:"%d \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1",m:"\u03ad\u03bd\u03b1 \u03bb\u03b5\u03c0\u03c4\u03cc",mm:"%d \u03bb\u03b5\u03c0\u03c4\u03ac",h:"\u03bc\u03af\u03b1 \u03ce\u03c1\u03b1",hh:"%d \u03ce\u03c1\u03b5\u03c2",d:"\u03bc\u03af\u03b1 \u03bc\u03ad\u03c1\u03b1",dd:"%d \u03bc\u03ad\u03c1\u03b5\u03c2",M:"\u03ad\u03bd\u03b1\u03c2 \u03bc\u03ae\u03bd\u03b1\u03c2",MM:"%d \u03bc\u03ae\u03bd\u03b5\u03c2",y:"\u03ad\u03bd\u03b1\u03c2 \u03c7\u03c1\u03cc\u03bd\u03bf\u03c2",yy:"%d \u03c7\u03c1\u03cc\u03bd\u03b9\u03b1"},dayOfMonthOrdinalParse:/\d{1,2}\u03b7/,ordinal:"%d\u03b7",week:{dow:1,doy:4}}),l.defineLocale("en-au",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),l.defineLocale("en-ca",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"YYYY-MM-DD",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")}}),l.defineLocale("en-gb",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),l.defineLocale("en-ie",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),l.defineLocale("en-il",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")}}),l.defineLocale("en-nz",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),l.defineLocale("eo",{months:"januaro_februaro_marto_aprilo_majo_junio_julio_a\u016dgusto_septembro_oktobro_novembro_decembro".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_a\u016dg_sep_okt_nov_dec".split("_"),weekdays:"diman\u0109o_lundo_mardo_merkredo_\u0135a\u016ddo_vendredo_sabato".split("_"),weekdaysShort:"dim_lun_mard_merk_\u0135a\u016d_ven_sab".split("_"),weekdaysMin:"di_lu_ma_me_\u0135a_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D[-a de] MMMM, YYYY",LLL:"D[-a de] MMMM, YYYY HH:mm",LLLL:"dddd, [la] D[-a de] MMMM, YYYY HH:mm"},meridiemParse:/[ap]\.t\.m/i,isPM:function(e){return"p"===e.charAt(0).toLowerCase()},meridiem:function(e,a,t){return 11<e?t?"p.t.m.":"P.T.M.":t?"a.t.m.":"A.T.M."},calendar:{sameDay:"[Hodia\u016d je] LT",nextDay:"[Morga\u016d je] LT",nextWeek:"dddd [je] LT",lastDay:"[Hiera\u016d je] LT",lastWeek:"[pasinta] dddd [je] LT",sameElse:"L"},relativeTime:{future:"post %s",past:"anta\u016d %s",s:"sekundoj",ss:"%d sekundoj",m:"minuto",mm:"%d minutoj",h:"horo",hh:"%d horoj",d:"tago",dd:"%d tagoj",M:"monato",MM:"%d monatoj",y:"jaro",yy:"%d jaroj"},dayOfMonthOrdinalParse:/\d{1,2}a/,ordinal:"%da",week:{dow:1,doy:7}});var ys="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),fs="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),ks=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],ps=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;l.defineLocale("es-do",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?fs[e.month()]:ys[e.month()]:ys},monthsRegex:ps,monthsShortRegex:ps,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:ks,longMonthsParse:ks,shortMonthsParse:ks,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY h:mm A",LLLL:"dddd, D [de] MMMM [de] YYYY h:mm A"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}});var Ds="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),Ts="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_");l.defineLocale("es-us",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?Ts[e.month()]:Ds[e.month()]:Ds},monthsParseExact:!0,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"MM/DD/YYYY",LL:"MMMM [de] D [de] YYYY",LLL:"MMMM [de] D [de] YYYY h:mm A",LLLL:"dddd, MMMM [de] D [de] YYYY h:mm A"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:0,doy:6}});var gs="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),ws="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),vs=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],Ss=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;function Hs(e,a,t,s){var n={s:["m\xf5ne sekundi","m\xf5ni sekund","paar sekundit"],ss:[e+"sekundi",e+"sekundit"],m:["\xfche minuti","\xfcks minut"],mm:[e+" minuti",e+" minutit"],h:["\xfche tunni","tund aega","\xfcks tund"],hh:[e+" tunni",e+" tundi"],d:["\xfche p\xe4eva","\xfcks p\xe4ev"],M:["kuu aja","kuu aega","\xfcks kuu"],MM:[e+" kuu",e+" kuud"],y:["\xfche aasta","aasta","\xfcks aasta"],yy:[e+" aasta",e+" aastat"]};return a?n[t][2]?n[t][2]:n[t][1]:s?n[t][0]:n[t][1]}l.defineLocale("es",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?ws[e.month()]:gs[e.month()]:gs},monthsRegex:Ss,monthsShortRegex:Ss,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:vs,longMonthsParse:vs,shortMonthsParse:vs,weekdays:"domingo_lunes_martes_mi\xe9rcoles_jueves_viernes_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._mi\xe9._jue._vie._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[ma\xf1ana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un a\xf1o",yy:"%d a\xf1os"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),l.defineLocale("et",{months:"jaanuar_veebruar_m\xe4rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),monthsShort:"jaan_veebr_m\xe4rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),weekdays:"p\xfchap\xe4ev_esmasp\xe4ev_teisip\xe4ev_kolmap\xe4ev_neljap\xe4ev_reede_laup\xe4ev".split("_"),weekdaysShort:"P_E_T_K_N_R_L".split("_"),weekdaysMin:"P_E_T_K_N_R_L".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[T\xe4na,] LT",nextDay:"[Homme,] LT",nextWeek:"[J\xe4rgmine] dddd LT",lastDay:"[Eile,] LT",lastWeek:"[Eelmine] dddd LT",sameElse:"L"},relativeTime:{future:"%s p\xe4rast",past:"%s tagasi",s:Hs,ss:Hs,m:Hs,mm:Hs,h:Hs,hh:Hs,d:Hs,dd:"%d p\xe4eva",M:Hs,MM:Hs,y:Hs,yy:Hs},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("eu",{months:"urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),monthsShort:"urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),monthsParseExact:!0,weekdays:"igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),weekdaysShort:"ig._al._ar._az._og._ol._lr.".split("_"),weekdaysMin:"ig_al_ar_az_og_ol_lr".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY[ko] MMMM[ren] D[a]",LLL:"YYYY[ko] MMMM[ren] D[a] HH:mm",LLLL:"dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",l:"YYYY-M-D",ll:"YYYY[ko] MMM D[a]",lll:"YYYY[ko] MMM D[a] HH:mm",llll:"ddd, YYYY[ko] MMM D[a] HH:mm"},calendar:{sameDay:"[gaur] LT[etan]",nextDay:"[bihar] LT[etan]",nextWeek:"dddd LT[etan]",lastDay:"[atzo] LT[etan]",lastWeek:"[aurreko] dddd LT[etan]",sameElse:"L"},relativeTime:{future:"%s barru",past:"duela %s",s:"segundo batzuk",ss:"%d segundo",m:"minutu bat",mm:"%d minutu",h:"ordu bat",hh:"%d ordu",d:"egun bat",dd:"%d egun",M:"hilabete bat",MM:"%d hilabete",y:"urte bat",yy:"%d urte"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var bs={1:"\u06f1",2:"\u06f2",3:"\u06f3",4:"\u06f4",5:"\u06f5",6:"\u06f6",7:"\u06f7",8:"\u06f8",9:"\u06f9",0:"\u06f0"},js={"\u06f1":"1","\u06f2":"2","\u06f3":"3","\u06f4":"4","\u06f5":"5","\u06f6":"6","\u06f7":"7","\u06f8":"8","\u06f9":"9","\u06f0":"0"};l.defineLocale("fa",{months:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),monthsShort:"\u0698\u0627\u0646\u0648\u06cc\u0647_\u0641\u0648\u0631\u06cc\u0647_\u0645\u0627\u0631\u0633_\u0622\u0648\u0631\u06cc\u0644_\u0645\u0647_\u0698\u0648\u0626\u0646_\u0698\u0648\u0626\u06cc\u0647_\u0627\u0648\u062a_\u0633\u067e\u062a\u0627\u0645\u0628\u0631_\u0627\u06a9\u062a\u0628\u0631_\u0646\u0648\u0627\u0645\u0628\u0631_\u062f\u0633\u0627\u0645\u0628\u0631".split("_"),weekdays:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysShort:"\u06cc\u06a9\u200c\u0634\u0646\u0628\u0647_\u062f\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200c\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067e\u0646\u062c\u200c\u0634\u0646\u0628\u0647_\u062c\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split("_"),weekdaysMin:"\u06cc_\u062f_\u0633_\u0686_\u067e_\u062c_\u0634".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631|\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/,isPM:function(e){return/\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631/.test(e)},meridiem:function(e,a,t){return e<12?"\u0642\u0628\u0644 \u0627\u0632 \u0638\u0647\u0631":"\u0628\u0639\u062f \u0627\u0632 \u0638\u0647\u0631"},calendar:{sameDay:"[\u0627\u0645\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",nextDay:"[\u0641\u0631\u062f\u0627 \u0633\u0627\u0639\u062a] LT",nextWeek:"dddd [\u0633\u0627\u0639\u062a] LT",lastDay:"[\u062f\u06cc\u0631\u0648\u0632 \u0633\u0627\u0639\u062a] LT",lastWeek:"dddd [\u067e\u06cc\u0634] [\u0633\u0627\u0639\u062a] LT",sameElse:"L"},relativeTime:{future:"\u062f\u0631 %s",past:"%s \u067e\u06cc\u0634",s:"\u0686\u0646\u062f \u062b\u0627\u0646\u06cc\u0647",ss:"\u062b\u0627\u0646\u06cc\u0647 d%",m:"\u06cc\u06a9 \u062f\u0642\u06cc\u0642\u0647",mm:"%d \u062f\u0642\u06cc\u0642\u0647",h:"\u06cc\u06a9 \u0633\u0627\u0639\u062a",hh:"%d \u0633\u0627\u0639\u062a",d:"\u06cc\u06a9 \u0631\u0648\u0632",dd:"%d \u0631\u0648\u0632",M:"\u06cc\u06a9 \u0645\u0627\u0647",MM:"%d \u0645\u0627\u0647",y:"\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/[\u06f0-\u06f9]/g,function(e){return js[e]}).replace(/\u060c/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return bs[e]}).replace(/,/g,"\u060c")},dayOfMonthOrdinalParse:/\d{1,2}\u0645/,ordinal:"%d\u0645",week:{dow:6,doy:12}});var xs="nolla yksi kaksi kolme nelj\xe4 viisi kuusi seitsem\xe4n kahdeksan yhdeks\xe4n".split(" "),Ps=["nolla","yhden","kahden","kolmen","nelj\xe4n","viiden","kuuden",xs[7],xs[8],xs[9]];function Os(e,a,t,s){var n,d,r="";switch(t){case"s":return s?"muutaman sekunnin":"muutama sekunti";case"ss":return s?"sekunnin":"sekuntia";case"m":return s?"minuutin":"minuutti";case"mm":r=s?"minuutin":"minuuttia";break;case"h":return s?"tunnin":"tunti";case"hh":r=s?"tunnin":"tuntia";break;case"d":return s?"p\xe4iv\xe4n":"p\xe4iv\xe4";case"dd":r=s?"p\xe4iv\xe4n":"p\xe4iv\xe4\xe4";break;case"M":return s?"kuukauden":"kuukausi";case"MM":r=s?"kuukauden":"kuukautta";break;case"y":return s?"vuoden":"vuosi";case"yy":r=s?"vuoden":"vuotta";break}return d=s,r=((n=e)<10?d?Ps[n]:xs[n]:n)+" "+r}l.defineLocale("fi",{months:"tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kes\xe4kuu_hein\xe4kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),monthsShort:"tammi_helmi_maalis_huhti_touko_kes\xe4_hein\xe4_elo_syys_loka_marras_joulu".split("_"),weekdays:"sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),weekdaysShort:"su_ma_ti_ke_to_pe_la".split("_"),weekdaysMin:"su_ma_ti_ke_to_pe_la".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"Do MMMM[ta] YYYY",LLL:"Do MMMM[ta] YYYY, [klo] HH.mm",LLLL:"dddd, Do MMMM[ta] YYYY, [klo] HH.mm",l:"D.M.YYYY",ll:"Do MMM YYYY",lll:"Do MMM YYYY, [klo] HH.mm",llll:"ddd, Do MMM YYYY, [klo] HH.mm"},calendar:{sameDay:"[t\xe4n\xe4\xe4n] [klo] LT",nextDay:"[huomenna] [klo] LT",nextWeek:"dddd [klo] LT",lastDay:"[eilen] [klo] LT",lastWeek:"[viime] dddd[na] [klo] LT",sameElse:"L"},relativeTime:{future:"%s p\xe4\xe4st\xe4",past:"%s sitten",s:Os,ss:Os,m:Os,mm:Os,h:Os,hh:Os,d:Os,dd:Os,M:Os,MM:Os,y:Os,yy:Os},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("fo",{months:"januar_februar_mars_apr\xedl_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),weekdays:"sunnudagur_m\xe1nadagur_t\xfdsdagur_mikudagur_h\xf3sdagur_fr\xedggjadagur_leygardagur".split("_"),weekdaysShort:"sun_m\xe1n_t\xfds_mik_h\xf3s_fr\xed_ley".split("_"),weekdaysMin:"su_m\xe1_t\xfd_mi_h\xf3_fr_le".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D. MMMM, YYYY HH:mm"},calendar:{sameDay:"[\xcd dag kl.] LT",nextDay:"[\xcd morgin kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xcd gj\xe1r kl.] LT",lastWeek:"[s\xed\xf0stu] dddd [kl] LT",sameElse:"L"},relativeTime:{future:"um %s",past:"%s s\xed\xf0ani",s:"f\xe1 sekund",ss:"%d sekundir",m:"ein minutt",mm:"%d minuttir",h:"ein t\xedmi",hh:"%d t\xedmar",d:"ein dagur",dd:"%d dagar",M:"ein m\xe1na\xf0i",MM:"%d m\xe1na\xf0ir",y:"eitt \xe1r",yy:"%d \xe1r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("fr-ca",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}}}),l.defineLocale("fr-ch",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|e)/,ordinal:function(e,a){switch(a){default:case"M":case"Q":case"D":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}}),l.defineLocale("fr",{months:"janvier_f\xe9vrier_mars_avril_mai_juin_juillet_ao\xfbt_septembre_octobre_novembre_d\xe9cembre".split("_"),monthsShort:"janv._f\xe9vr._mars_avr._mai_juin_juil._ao\xfbt_sept._oct._nov._d\xe9c.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd\u2019hui \xe0] LT",nextDay:"[Demain \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[Hier \xe0] LT",lastWeek:"dddd [dernier \xe0] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|)/,ordinal:function(e,a){switch(a){case"D":return e+(1===e?"er":"");default:case"M":case"Q":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}});var Ws="jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"),Es="jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");l.defineLocale("fy",{months:"jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?Es[e.month()]:Ws[e.month()]:Ws},monthsParseExact:!0,weekdays:"snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),weekdaysShort:"si._mo._ti._wo._to._fr._so.".split("_"),weekdaysMin:"Si_Mo_Ti_Wo_To_Fr_So".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[hjoed om] LT",nextDay:"[moarn om] LT",nextWeek:"dddd [om] LT",lastDay:"[juster om] LT",lastWeek:"[\xf4fr\xfbne] dddd [om] LT",sameElse:"L"},relativeTime:{future:"oer %s",past:"%s lyn",s:"in pear sekonden",ss:"%d sekonden",m:"ien min\xfat",mm:"%d minuten",h:"ien oere",hh:"%d oeren",d:"ien dei",dd:"%d dagen",M:"ien moanne",MM:"%d moannen",y:"ien jier",yy:"%d jierren"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}});function As(e,a,t,s){var n={s:["thodde secondanim","thodde second"],ss:[e+" secondanim",e+" second"],m:["eka mintan","ek minute"],mm:[e+" mintanim",e+" mintam"],h:["eka horan","ek hor"],hh:[e+" horanim",e+" horam"],d:["eka disan","ek dis"],dd:[e+" disanim",e+" dis"],M:["eka mhoinean","ek mhoino"],MM:[e+" mhoineanim",e+" mhoine"],y:["eka vorsan","ek voros"],yy:[e+" vorsanim",e+" vorsam"]};return a?n[t][0]:n[t][1]}l.defineLocale("gd",{months:["Am Faoilleach","An Gearran","Am M\xe0rt","An Giblean","An C\xe8itean","An t-\xd2gmhios","An t-Iuchar","An L\xf9nastal","An t-Sultain","An D\xe0mhair","An t-Samhain","An D\xf9bhlachd"],monthsShort:["Faoi","Gear","M\xe0rt","Gibl","C\xe8it","\xd2gmh","Iuch","L\xf9n","Sult","D\xe0mh","Samh","D\xf9bh"],monthsParseExact:!0,weekdays:["Did\xf2mhnaich","Diluain","Dim\xe0irt","Diciadain","Diardaoin","Dihaoine","Disathairne"],weekdaysShort:["Did","Dil","Dim","Dic","Dia","Dih","Dis"],weekdaysMin:["D\xf2","Lu","M\xe0","Ci","Ar","Ha","Sa"],longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[An-diugh aig] LT",nextDay:"[A-m\xe0ireach aig] LT",nextWeek:"dddd [aig] LT",lastDay:"[An-d\xe8 aig] LT",lastWeek:"dddd [seo chaidh] [aig] LT",sameElse:"L"},relativeTime:{future:"ann an %s",past:"bho chionn %s",s:"beagan diogan",ss:"%d diogan",m:"mionaid",mm:"%d mionaidean",h:"uair",hh:"%d uairean",d:"latha",dd:"%d latha",M:"m\xecos",MM:"%d m\xecosan",y:"bliadhna",yy:"%d bliadhna"},dayOfMonthOrdinalParse:/\d{1,2}(d|na|mh)/,ordinal:function(e){return e+(1===e?"d":e%10==2?"na":"mh")},week:{dow:1,doy:4}}),l.defineLocale("gl",{months:"xaneiro_febreiro_marzo_abril_maio_xu\xf1o_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),monthsShort:"xan._feb._mar._abr._mai._xu\xf1._xul._ago._set._out._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"domingo_luns_martes_m\xe9rcores_xoves_venres_s\xe1bado".split("_"),weekdaysShort:"dom._lun._mar._m\xe9r._xov._ven._s\xe1b.".split("_"),weekdaysMin:"do_lu_ma_m\xe9_xo_ve_s\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return"[hoxe "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextDay:function(){return"[ma\xf1\xe1 "+(1!==this.hours()?"\xe1s":"\xe1")+"] LT"},nextWeek:function(){return"dddd ["+(1!==this.hours()?"\xe1s":"a")+"] LT"},lastDay:function(){return"[onte "+(1!==this.hours()?"\xe1":"a")+"] LT"},lastWeek:function(){return"[o] dddd [pasado "+(1!==this.hours()?"\xe1s":"a")+"] LT"},sameElse:"L"},relativeTime:{future:function(e){return 0===e.indexOf("un")?"n"+e:"en "+e},past:"hai %s",s:"uns segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"unha hora",hh:"%d horas",d:"un d\xeda",dd:"%d d\xedas",M:"un mes",MM:"%d meses",y:"un ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),l.defineLocale("gom-latn",{months:"Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),monthsShort:"Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son'var".split("_"),weekdaysShort:"Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),weekdaysMin:"Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A h:mm [vazta]",LTS:"A h:mm:ss [vazta]",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY A h:mm [vazta]",LLLL:"dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]",llll:"ddd, D MMM YYYY, A h:mm [vazta]"},calendar:{sameDay:"[Aiz] LT",nextDay:"[Faleam] LT",nextWeek:"[Ieta to] dddd[,] LT",lastDay:"[Kal] LT",lastWeek:"[Fatlo] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s",past:"%s adim",s:As,ss:As,m:As,mm:As,h:As,hh:As,d:As,dd:As,M:As,MM:As,y:As,yy:As},dayOfMonthOrdinalParse:/\d{1,2}(er)/,ordinal:function(e,a){switch(a){case"D":return e+"er";default:case"M":case"Q":case"DDD":case"d":case"w":case"W":return e}},week:{dow:1,doy:4},meridiemParse:/rati|sokalli|donparam|sanje/,meridiemHour:function(e,a){return 12===e&&(e=0),"rati"===a?e<4?e:e+12:"sokalli"===a?e:"donparam"===a?12<e?e:e+12:"sanje"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"rati":e<12?"sokalli":e<16?"donparam":e<20?"sanje":"rati"}});var Fs={1:"\u0ae7",2:"\u0ae8",3:"\u0ae9",4:"\u0aea",5:"\u0aeb",6:"\u0aec",7:"\u0aed",8:"\u0aee",9:"\u0aef",0:"\u0ae6"},zs={"\u0ae7":"1","\u0ae8":"2","\u0ae9":"3","\u0aea":"4","\u0aeb":"5","\u0aec":"6","\u0aed":"7","\u0aee":"8","\u0aef":"9","\u0ae6":"0"};l.defineLocale("gu",{months:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1\u0a86\u0ab0\u0ac0_\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1\u0a86\u0ab0\u0ac0_\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf\u0ab2_\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe\u0a88_\u0a91\u0a97\u0ab8\u0acd\u0a9f_\u0ab8\u0aaa\u0acd\u0a9f\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0a91\u0a95\u0acd\u0a9f\u0acd\u0aac\u0ab0_\u0aa8\u0ab5\u0ac7\u0aae\u0acd\u0aac\u0ab0_\u0aa1\u0abf\u0ab8\u0ac7\u0aae\u0acd\u0aac\u0ab0".split("_"),monthsShort:"\u0a9c\u0abe\u0aa8\u0acd\u0aaf\u0ac1._\u0aab\u0ac7\u0aac\u0acd\u0ab0\u0ac1._\u0aae\u0abe\u0ab0\u0acd\u0a9a_\u0a8f\u0aaa\u0acd\u0ab0\u0abf._\u0aae\u0ac7_\u0a9c\u0ac2\u0aa8_\u0a9c\u0ac1\u0ab2\u0abe._\u0a91\u0a97._\u0ab8\u0aaa\u0acd\u0a9f\u0ac7._\u0a91\u0a95\u0acd\u0a9f\u0acd._\u0aa8\u0ab5\u0ac7._\u0aa1\u0abf\u0ab8\u0ac7.".split("_"),monthsParseExact:!0,weekdays:"\u0ab0\u0ab5\u0abf\u0ab5\u0abe\u0ab0_\u0ab8\u0acb\u0aae\u0ab5\u0abe\u0ab0_\u0aae\u0a82\u0a97\u0ab3\u0ab5\u0abe\u0ab0_\u0aac\u0ac1\u0aa7\u0acd\u0ab5\u0abe\u0ab0_\u0a97\u0ac1\u0ab0\u0ac1\u0ab5\u0abe\u0ab0_\u0ab6\u0ac1\u0a95\u0acd\u0ab0\u0ab5\u0abe\u0ab0_\u0ab6\u0aa8\u0abf\u0ab5\u0abe\u0ab0".split("_"),weekdaysShort:"\u0ab0\u0ab5\u0abf_\u0ab8\u0acb\u0aae_\u0aae\u0a82\u0a97\u0ab3_\u0aac\u0ac1\u0aa7\u0acd_\u0a97\u0ac1\u0ab0\u0ac1_\u0ab6\u0ac1\u0a95\u0acd\u0ab0_\u0ab6\u0aa8\u0abf".split("_"),weekdaysMin:"\u0ab0_\u0ab8\u0acb_\u0aae\u0a82_\u0aac\u0ac1_\u0a97\u0ac1_\u0ab6\u0ac1_\u0ab6".split("_"),longDateFormat:{LT:"A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LTS:"A h:mm:ss \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7",LLLL:"dddd, D MMMM YYYY, A h:mm \u0ab5\u0abe\u0a97\u0acd\u0aaf\u0ac7"},calendar:{sameDay:"[\u0a86\u0a9c] LT",nextDay:"[\u0a95\u0abe\u0ab2\u0ac7] LT",nextWeek:"dddd, LT",lastDay:"[\u0a97\u0a87\u0a95\u0abe\u0ab2\u0ac7] LT",lastWeek:"[\u0aaa\u0abe\u0a9b\u0ab2\u0abe] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0aae\u0abe",past:"%s \u0aaa\u0ac7\u0ab9\u0ab2\u0abe",s:"\u0a85\u0aae\u0ac1\u0a95 \u0aaa\u0ab3\u0acb",ss:"%d \u0ab8\u0ac7\u0a95\u0a82\u0aa1",m:"\u0a8f\u0a95 \u0aae\u0abf\u0aa8\u0abf\u0a9f",mm:"%d \u0aae\u0abf\u0aa8\u0abf\u0a9f",h:"\u0a8f\u0a95 \u0a95\u0ab2\u0abe\u0a95",hh:"%d \u0a95\u0ab2\u0abe\u0a95",d:"\u0a8f\u0a95 \u0aa6\u0abf\u0ab5\u0ab8",dd:"%d \u0aa6\u0abf\u0ab5\u0ab8",M:"\u0a8f\u0a95 \u0aae\u0ab9\u0abf\u0aa8\u0acb",MM:"%d \u0aae\u0ab9\u0abf\u0aa8\u0acb",y:"\u0a8f\u0a95 \u0ab5\u0ab0\u0acd\u0ab7",yy:"%d \u0ab5\u0ab0\u0acd\u0ab7"},preparse:function(e){return e.replace(/[\u0ae7\u0ae8\u0ae9\u0aea\u0aeb\u0aec\u0aed\u0aee\u0aef\u0ae6]/g,function(e){return zs[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Fs[e]})},meridiemParse:/\u0ab0\u0abe\u0aa4|\u0aac\u0aaa\u0acb\u0ab0|\u0ab8\u0ab5\u0abe\u0ab0|\u0ab8\u0abe\u0a82\u0a9c/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0ab0\u0abe\u0aa4"===a?e<4?e:e+12:"\u0ab8\u0ab5\u0abe\u0ab0"===a?e:"\u0aac\u0aaa\u0acb\u0ab0"===a?10<=e?e:e+12:"\u0ab8\u0abe\u0a82\u0a9c"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0ab0\u0abe\u0aa4":e<10?"\u0ab8\u0ab5\u0abe\u0ab0":e<17?"\u0aac\u0aaa\u0acb\u0ab0":e<20?"\u0ab8\u0abe\u0a82\u0a9c":"\u0ab0\u0abe\u0aa4"},week:{dow:0,doy:6}}),l.defineLocale("he",{months:"\u05d9\u05e0\u05d5\u05d0\u05e8_\u05e4\u05d1\u05e8\u05d5\u05d0\u05e8_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05d9\u05dc_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05d5\u05e1\u05d8_\u05e1\u05e4\u05d8\u05de\u05d1\u05e8_\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8_\u05e0\u05d5\u05d1\u05de\u05d1\u05e8_\u05d3\u05e6\u05de\u05d1\u05e8".split("_"),monthsShort:"\u05d9\u05e0\u05d5\u05f3_\u05e4\u05d1\u05e8\u05f3_\u05de\u05e8\u05e5_\u05d0\u05e4\u05e8\u05f3_\u05de\u05d0\u05d9_\u05d9\u05d5\u05e0\u05d9_\u05d9\u05d5\u05dc\u05d9_\u05d0\u05d5\u05d2\u05f3_\u05e1\u05e4\u05d8\u05f3_\u05d0\u05d5\u05e7\u05f3_\u05e0\u05d5\u05d1\u05f3_\u05d3\u05e6\u05de\u05f3".split("_"),weekdays:"\u05e8\u05d0\u05e9\u05d5\u05df_\u05e9\u05e0\u05d9_\u05e9\u05dc\u05d9\u05e9\u05d9_\u05e8\u05d1\u05d9\u05e2\u05d9_\u05d7\u05de\u05d9\u05e9\u05d9_\u05e9\u05d9\u05e9\u05d9_\u05e9\u05d1\u05ea".split("_"),weekdaysShort:"\u05d0\u05f3_\u05d1\u05f3_\u05d2\u05f3_\u05d3\u05f3_\u05d4\u05f3_\u05d5\u05f3_\u05e9\u05f3".split("_"),weekdaysMin:"\u05d0_\u05d1_\u05d2_\u05d3_\u05d4_\u05d5_\u05e9".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [\u05d1]MMMM YYYY",LLL:"D [\u05d1]MMMM YYYY HH:mm",LLLL:"dddd, D [\u05d1]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[\u05d4\u05d9\u05d5\u05dd \u05d1\u05be]LT",nextDay:"[\u05de\u05d7\u05e8 \u05d1\u05be]LT",nextWeek:"dddd [\u05d1\u05e9\u05e2\u05d4] LT",lastDay:"[\u05d0\u05ea\u05de\u05d5\u05dc \u05d1\u05be]LT",lastWeek:"[\u05d1\u05d9\u05d5\u05dd] dddd [\u05d4\u05d0\u05d7\u05e8\u05d5\u05df \u05d1\u05e9\u05e2\u05d4] LT",sameElse:"L"},relativeTime:{future:"\u05d1\u05e2\u05d5\u05d3 %s",past:"\u05dc\u05e4\u05e0\u05d9 %s",s:"\u05de\u05e1\u05e4\u05e8 \u05e9\u05e0\u05d9\u05d5\u05ea",ss:"%d \u05e9\u05e0\u05d9\u05d5\u05ea",m:"\u05d3\u05e7\u05d4",mm:"%d \u05d3\u05e7\u05d5\u05ea",h:"\u05e9\u05e2\u05d4",hh:function(e){return 2===e?"\u05e9\u05e2\u05ea\u05d9\u05d9\u05dd":e+" \u05e9\u05e2\u05d5\u05ea"},d:"\u05d9\u05d5\u05dd",dd:function(e){return 2===e?"\u05d9\u05d5\u05de\u05d9\u05d9\u05dd":e+" \u05d9\u05de\u05d9\u05dd"},M:"\u05d7\u05d5\u05d3\u05e9",MM:function(e){return 2===e?"\u05d7\u05d5\u05d3\u05e9\u05d9\u05d9\u05dd":e+" \u05d7\u05d5\u05d3\u05e9\u05d9\u05dd"},y:"\u05e9\u05e0\u05d4",yy:function(e){return 2===e?"\u05e9\u05e0\u05ea\u05d9\u05d9\u05dd":e%10==0&&10!==e?e+" \u05e9\u05e0\u05d4":e+" \u05e9\u05e0\u05d9\u05dd"}},meridiemParse:/\u05d0\u05d7\u05d4"\u05e6|\u05dc\u05e4\u05e0\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8|\u05d1\u05d1\u05d5\u05e7\u05e8|\u05d1\u05e2\u05e8\u05d1/i,isPM:function(e){return/^(\u05d0\u05d7\u05d4"\u05e6|\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd|\u05d1\u05e2\u05e8\u05d1)$/.test(e)},meridiem:function(e,a,t){return e<5?"\u05dc\u05e4\u05e0\u05d5\u05ea \u05d1\u05d5\u05e7\u05e8":e<10?"\u05d1\u05d1\u05d5\u05e7\u05e8":e<12?t?'\u05dc\u05e4\u05e0\u05d4"\u05e6':"\u05dc\u05e4\u05e0\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":e<18?t?'\u05d0\u05d7\u05d4"\u05e6':"\u05d0\u05d7\u05e8\u05d9 \u05d4\u05e6\u05d4\u05e8\u05d9\u05d9\u05dd":"\u05d1\u05e2\u05e8\u05d1"}});var Js={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},Ns={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};function Rs(e,a,t){var s=e+" ";switch(t){case"ss":return s+=1===e?"sekunda":2===e||3===e||4===e?"sekunde":"sekundi";case"m":return a?"jedna minuta":"jedne minute";case"mm":return s+=1===e?"minuta":2===e||3===e||4===e?"minute":"minuta";case"h":return a?"jedan sat":"jednog sata";case"hh":return s+=1===e?"sat":2===e||3===e||4===e?"sata":"sati";case"dd":return s+=1===e?"dan":"dana";case"MM":return s+=1===e?"mjesec":2===e||3===e||4===e?"mjeseca":"mjeseci";case"yy":return s+=1===e?"godina":2===e||3===e||4===e?"godine":"godina"}}l.defineLocale("hi",{months:"\u091c\u0928\u0935\u0930\u0940_\u092b\u093c\u0930\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948\u0932_\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0938\u094d\u0924_\u0938\u093f\u0924\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u0942\u092c\u0930_\u0928\u0935\u092e\u094d\u092c\u0930_\u0926\u093f\u0938\u092e\u094d\u092c\u0930".split("_"),monthsShort:"\u091c\u0928._\u092b\u093c\u0930._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u0948._\u092e\u0908_\u091c\u0942\u0928_\u091c\u0941\u0932._\u0905\u0917._\u0938\u093f\u0924._\u0905\u0915\u094d\u091f\u0942._\u0928\u0935._\u0926\u093f\u0938.".split("_"),monthsParseExact:!0,weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0932\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0932_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u092c\u091c\u0947",LTS:"A h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A h:mm \u092c\u091c\u0947"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0915\u0932] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u0932] LT",lastWeek:"[\u092a\u093f\u091b\u0932\u0947] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u092e\u0947\u0902",past:"%s \u092a\u0939\u0932\u0947",s:"\u0915\u0941\u091b \u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0902\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u091f",mm:"%d \u092e\u093f\u0928\u091f",h:"\u090f\u0915 \u0918\u0902\u091f\u093e",hh:"%d \u0918\u0902\u091f\u0947",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u0940\u0928\u0947",MM:"%d \u092e\u0939\u0940\u0928\u0947",y:"\u090f\u0915 \u0935\u0930\u094d\u0937",yy:"%d \u0935\u0930\u094d\u0937"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return Ns[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Js[e]})},meridiemParse:/\u0930\u093e\u0924|\u0938\u0941\u092c\u0939|\u0926\u094b\u092a\u0939\u0930|\u0936\u093e\u092e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924"===a?e<4?e:e+12:"\u0938\u0941\u092c\u0939"===a?e:"\u0926\u094b\u092a\u0939\u0930"===a?10<=e?e:e+12:"\u0936\u093e\u092e"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0930\u093e\u0924":e<10?"\u0938\u0941\u092c\u0939":e<17?"\u0926\u094b\u092a\u0939\u0930":e<20?"\u0936\u093e\u092e":"\u0930\u093e\u0924"},week:{dow:0,doy:6}}),l.defineLocale("hr",{months:{format:"sije\u010dnja_velja\u010de_o\u017eujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),standalone:"sije\u010danj_velja\u010da_o\u017eujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")},monthsShort:"sij._velj._o\u017eu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010der u] LT",lastWeek:function(){switch(this.day()){case 0:case 3:return"[pro\u0161lu] dddd [u] LT";case 6:return"[pro\u0161le] [subote] [u] LT";case 1:case 2:case 4:case 5:return"[pro\u0161li] dddd [u] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"par sekundi",ss:Rs,m:Rs,mm:Rs,h:Rs,hh:Rs,d:"dan",dd:Rs,M:"mjesec",MM:Rs,y:"godinu",yy:Rs},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var Is="vas\xe1rnap h\xe9tf\u0151n kedden szerd\xe1n cs\xfct\xf6rt\xf6k\xf6n p\xe9nteken szombaton".split(" ");function Cs(e,a,t,s){var n=e;switch(t){case"s":return s||a?"n\xe9h\xe1ny m\xe1sodperc":"n\xe9h\xe1ny m\xe1sodperce";case"ss":return n+(s||a)?" m\xe1sodperc":" m\xe1sodperce";case"m":return"egy"+(s||a?" perc":" perce");case"mm":return n+(s||a?" perc":" perce");case"h":return"egy"+(s||a?" \xf3ra":" \xf3r\xe1ja");case"hh":return n+(s||a?" \xf3ra":" \xf3r\xe1ja");case"d":return"egy"+(s||a?" nap":" napja");case"dd":return n+(s||a?" nap":" napja");case"M":return"egy"+(s||a?" h\xf3nap":" h\xf3napja");case"MM":return n+(s||a?" h\xf3nap":" h\xf3napja");case"y":return"egy"+(s||a?" \xe9v":" \xe9ve");case"yy":return n+(s||a?" \xe9v":" \xe9ve")}return""}function Gs(e){return(e?"":"[m\xfalt] ")+"["+Is[this.day()]+"] LT[-kor]"}function Us(e){return e%100==11||e%10!=1}function Vs(e,a,t,s){var n=e+" ";switch(t){case"s":return a||s?"nokkrar sek\xfandur":"nokkrum sek\xfandum";case"ss":return Us(e)?n+(a||s?"sek\xfandur":"sek\xfandum"):n+"sek\xfanda";case"m":return a?"m\xedn\xfata":"m\xedn\xfatu";case"mm":return Us(e)?n+(a||s?"m\xedn\xfatur":"m\xedn\xfatum"):a?n+"m\xedn\xfata":n+"m\xedn\xfatu";case"hh":return Us(e)?n+(a||s?"klukkustundir":"klukkustundum"):n+"klukkustund";case"d":return a?"dagur":s?"dag":"degi";case"dd":return Us(e)?a?n+"dagar":n+(s?"daga":"d\xf6gum"):a?n+"dagur":n+(s?"dag":"degi");case"M":return a?"m\xe1nu\xf0ur":s?"m\xe1nu\xf0":"m\xe1nu\xf0i";case"MM":return Us(e)?a?n+"m\xe1nu\xf0ir":n+(s?"m\xe1nu\xf0i":"m\xe1nu\xf0um"):a?n+"m\xe1nu\xf0ur":n+(s?"m\xe1nu\xf0":"m\xe1nu\xf0i");case"y":return a||s?"\xe1r":"\xe1ri";case"yy":return Us(e)?n+(a||s?"\xe1r":"\xe1rum"):n+(a||s?"\xe1r":"\xe1ri")}}l.defineLocale("hu",{months:"janu\xe1r_febru\xe1r_m\xe1rcius_\xe1prilis_m\xe1jus_j\xfanius_j\xfalius_augusztus_szeptember_okt\xf3ber_november_december".split("_"),monthsShort:"jan_feb_m\xe1rc_\xe1pr_m\xe1j_j\xfan_j\xfal_aug_szept_okt_nov_dec".split("_"),weekdays:"vas\xe1rnap_h\xe9tf\u0151_kedd_szerda_cs\xfct\xf6rt\xf6k_p\xe9ntek_szombat".split("_"),weekdaysShort:"vas_h\xe9t_kedd_sze_cs\xfct_p\xe9n_szo".split("_"),weekdaysMin:"v_h_k_sze_cs_p_szo".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY. MMMM D.",LLL:"YYYY. MMMM D. H:mm",LLLL:"YYYY. MMMM D., dddd H:mm"},meridiemParse:/de|du/i,isPM:function(e){return"u"===e.charAt(1).toLowerCase()},meridiem:function(e,a,t){return e<12?!0===t?"de":"DE":!0===t?"du":"DU"},calendar:{sameDay:"[ma] LT[-kor]",nextDay:"[holnap] LT[-kor]",nextWeek:function(){return Gs.call(this,!0)},lastDay:"[tegnap] LT[-kor]",lastWeek:function(){return Gs.call(this,!1)},sameElse:"L"},relativeTime:{future:"%s m\xfalva",past:"%s",s:Cs,ss:Cs,m:Cs,mm:Cs,h:Cs,hh:Cs,d:Cs,dd:Cs,M:Cs,MM:Cs,y:Cs,yy:Cs},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("hy-am",{months:{format:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580\u056b_\u0583\u0565\u057f\u0580\u057e\u0561\u0580\u056b_\u0574\u0561\u0580\u057f\u056b_\u0561\u057a\u0580\u056b\u056c\u056b_\u0574\u0561\u0575\u056b\u057d\u056b_\u0570\u0578\u0582\u0576\u056b\u057d\u056b_\u0570\u0578\u0582\u056c\u056b\u057d\u056b_\u0585\u0563\u0578\u057d\u057f\u0578\u057d\u056b_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580\u056b_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580\u056b".split("_"),standalone:"\u0570\u0578\u0582\u0576\u057e\u0561\u0580_\u0583\u0565\u057f\u0580\u057e\u0561\u0580_\u0574\u0561\u0580\u057f_\u0561\u057a\u0580\u056b\u056c_\u0574\u0561\u0575\u056b\u057d_\u0570\u0578\u0582\u0576\u056b\u057d_\u0570\u0578\u0582\u056c\u056b\u057d_\u0585\u0563\u0578\u057d\u057f\u0578\u057d_\u057d\u0565\u057a\u057f\u0565\u0574\u0562\u0565\u0580_\u0570\u0578\u056f\u057f\u0565\u0574\u0562\u0565\u0580_\u0576\u0578\u0575\u0565\u0574\u0562\u0565\u0580_\u0564\u0565\u056f\u057f\u0565\u0574\u0562\u0565\u0580".split("_")},monthsShort:"\u0570\u0576\u057e_\u0583\u057f\u0580_\u0574\u0580\u057f_\u0561\u057a\u0580_\u0574\u0575\u057d_\u0570\u0576\u057d_\u0570\u056c\u057d_\u0585\u0563\u057d_\u057d\u057a\u057f_\u0570\u056f\u057f_\u0576\u0574\u0562_\u0564\u056f\u057f".split("_"),weekdays:"\u056f\u056b\u0580\u0561\u056f\u056b_\u0565\u0580\u056f\u0578\u0582\u0577\u0561\u0562\u0569\u056b_\u0565\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0579\u0578\u0580\u0565\u0584\u0577\u0561\u0562\u0569\u056b_\u0570\u056b\u0576\u0563\u0577\u0561\u0562\u0569\u056b_\u0578\u0582\u0580\u0562\u0561\u0569_\u0577\u0561\u0562\u0561\u0569".split("_"),weekdaysShort:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),weekdaysMin:"\u056f\u0580\u056f_\u0565\u0580\u056f_\u0565\u0580\u0584_\u0579\u0580\u0584_\u0570\u0576\u0563_\u0578\u0582\u0580\u0562_\u0577\u0562\u0569".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0569.",LLL:"D MMMM YYYY \u0569., HH:mm",LLLL:"dddd, D MMMM YYYY \u0569., HH:mm"},calendar:{sameDay:"[\u0561\u0575\u057d\u0585\u0580] LT",nextDay:"[\u057e\u0561\u0572\u0568] LT",lastDay:"[\u0565\u0580\u0565\u056f] LT",nextWeek:function(){return"dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},lastWeek:function(){return"[\u0561\u0576\u0581\u0561\u056e] dddd [\u0585\u0580\u0568 \u056a\u0561\u0574\u0568] LT"},sameElse:"L"},relativeTime:{future:"%s \u0570\u0565\u057f\u0578",past:"%s \u0561\u057c\u0561\u057b",s:"\u0574\u056b \u0584\u0561\u0576\u056b \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",ss:"%d \u057e\u0561\u0575\u0580\u056f\u0575\u0561\u0576",m:"\u0580\u0578\u057a\u0565",mm:"%d \u0580\u0578\u057a\u0565",h:"\u056a\u0561\u0574",hh:"%d \u056a\u0561\u0574",d:"\u0585\u0580",dd:"%d \u0585\u0580",M:"\u0561\u0574\u056b\u057d",MM:"%d \u0561\u0574\u056b\u057d",y:"\u057f\u0561\u0580\u056b",yy:"%d \u057f\u0561\u0580\u056b"},meridiemParse:/\u0563\u056b\u0577\u0565\u0580\u057e\u0561|\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561|\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576/,isPM:function(e){return/^(\u0581\u0565\u0580\u0565\u056f\u057e\u0561|\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576)$/.test(e)},meridiem:function(e){return e<4?"\u0563\u056b\u0577\u0565\u0580\u057e\u0561":e<12?"\u0561\u057c\u0561\u057e\u0578\u057f\u057e\u0561":e<17?"\u0581\u0565\u0580\u0565\u056f\u057e\u0561":"\u0565\u0580\u0565\u056f\u0578\u0575\u0561\u0576"},dayOfMonthOrdinalParse:/\d{1,2}|\d{1,2}-(\u056b\u0576|\u0580\u0564)/,ordinal:function(e,a){switch(a){case"DDD":case"w":case"W":case"DDDo":return 1===e?e+"-\u056b\u0576":e+"-\u0580\u0564";default:return e}},week:{dow:1,doy:7}}),l.defineLocale("id",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),weekdays:"Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),weekdaysShort:"Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|siang|sore|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"siang"===a?11<=e?e:e+12:"sore"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,t){return e<11?"pagi":e<15?"siang":e<19?"sore":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Besok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kemarin pukul] LT",lastWeek:"dddd [lalu pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lalu",s:"beberapa detik",ss:"%d detik",m:"semenit",mm:"%d menit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),l.defineLocale("is",{months:"jan\xfaar_febr\xfaar_mars_apr\xedl_ma\xed_j\xfan\xed_j\xfal\xed_\xe1g\xfast_september_okt\xf3ber_n\xf3vember_desember".split("_"),monthsShort:"jan_feb_mar_apr_ma\xed_j\xfan_j\xfal_\xe1g\xfa_sep_okt_n\xf3v_des".split("_"),weekdays:"sunnudagur_m\xe1nudagur_\xferi\xf0judagur_mi\xf0vikudagur_fimmtudagur_f\xf6studagur_laugardagur".split("_"),weekdaysShort:"sun_m\xe1n_\xferi_mi\xf0_fim_f\xf6s_lau".split("_"),weekdaysMin:"Su_M\xe1_\xder_Mi_Fi_F\xf6_La".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd, D. MMMM YYYY [kl.] H:mm"},calendar:{sameDay:"[\xed dag kl.] LT",nextDay:"[\xe1 morgun kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[\xed g\xe6r kl.] LT",lastWeek:"[s\xed\xf0asta] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"eftir %s",past:"fyrir %s s\xed\xf0an",s:Vs,ss:Vs,m:Vs,mm:Vs,h:"klukkustund",hh:Vs,d:Vs,dd:Vs,M:Vs,MM:Vs,y:Vs,yy:Vs},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("it",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_luned\xec_marted\xec_mercoled\xec_gioved\xec_venerd\xec_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Oggi alle] LT",nextDay:"[Domani alle] LT",nextWeek:"dddd [alle] LT",lastDay:"[Ieri alle] LT",lastWeek:function(){switch(this.day()){case 0:return"[la scorsa] dddd [alle] LT";default:return"[lo scorso] dddd [alle] LT"}},sameElse:"L"},relativeTime:{future:function(e){return(/^[0-9].+$/.test(e)?"tra":"in")+" "+e},past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),l.defineLocale("ja",{months:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u65e5\u66dc\u65e5_\u6708\u66dc\u65e5_\u706b\u66dc\u65e5_\u6c34\u66dc\u65e5_\u6728\u66dc\u65e5_\u91d1\u66dc\u65e5_\u571f\u66dc\u65e5".split("_"),weekdaysShort:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),weekdaysMin:"\u65e5_\u6708_\u706b_\u6c34_\u6728_\u91d1_\u571f".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5 dddd HH:mm",l:"YYYY/MM/DD",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5(ddd) HH:mm"},meridiemParse:/\u5348\u524d|\u5348\u5f8c/i,isPM:function(e){return"\u5348\u5f8c"===e},meridiem:function(e,a,t){return e<12?"\u5348\u524d":"\u5348\u5f8c"},calendar:{sameDay:"[\u4eca\u65e5] LT",nextDay:"[\u660e\u65e5] LT",nextWeek:function(e){return e.week()<this.week()?"[\u6765\u9031]dddd LT":"dddd LT"},lastDay:"[\u6628\u65e5] LT",lastWeek:function(e){return this.week()<e.week()?"[\u5148\u9031]dddd LT":"dddd LT"},sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}\u65e5/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";default:return e}},relativeTime:{future:"%s\u5f8c",past:"%s\u524d",s:"\u6570\u79d2",ss:"%d\u79d2",m:"1\u5206",mm:"%d\u5206",h:"1\u6642\u9593",hh:"%d\u6642\u9593",d:"1\u65e5",dd:"%d\u65e5",M:"1\u30f6\u6708",MM:"%d\u30f6\u6708",y:"1\u5e74",yy:"%d\u5e74"}}),l.defineLocale("jv",{months:"Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),monthsShort:"Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),weekdays:"Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),weekdaysShort:"Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),weekdaysMin:"Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/enjing|siyang|sonten|ndalu/,meridiemHour:function(e,a){return 12===e&&(e=0),"enjing"===a?e:"siyang"===a?11<=e?e:e+12:"sonten"===a||"ndalu"===a?e+12:void 0},meridiem:function(e,a,t){return e<11?"enjing":e<15?"siyang":e<19?"sonten":"ndalu"},calendar:{sameDay:"[Dinten puniko pukul] LT",nextDay:"[Mbenjang pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kala wingi pukul] LT",lastWeek:"dddd [kepengker pukul] LT",sameElse:"L"},relativeTime:{future:"wonten ing %s",past:"%s ingkang kepengker",s:"sawetawis detik",ss:"%d detik",m:"setunggal menit",mm:"%d menit",h:"setunggal jam",hh:"%d jam",d:"sedinten",dd:"%d dinten",M:"sewulan",MM:"%d wulan",y:"setaun",yy:"%d taun"},week:{dow:1,doy:7}}),l.defineLocale("ka",{months:{standalone:"\u10d8\u10d0\u10dc\u10d5\u10d0\u10e0\u10d8_\u10d7\u10d4\u10d1\u10d4\u10e0\u10d5\u10d0\u10da\u10d8_\u10db\u10d0\u10e0\u10e2\u10d8_\u10d0\u10de\u10e0\u10d8\u10da\u10d8_\u10db\u10d0\u10d8\u10e1\u10d8_\u10d8\u10d5\u10dc\u10d8\u10e1\u10d8_\u10d8\u10d5\u10da\u10d8\u10e1\u10d8_\u10d0\u10d2\u10d5\u10d8\u10e1\u10e2\u10dd_\u10e1\u10d4\u10e5\u10e2\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10dd\u10e5\u10e2\u10dd\u10db\u10d1\u10d4\u10e0\u10d8_\u10dc\u10dd\u10d4\u10db\u10d1\u10d4\u10e0\u10d8_\u10d3\u10d4\u10d9\u10d4\u10db\u10d1\u10d4\u10e0\u10d8".split("_"),format:"\u10d8\u10d0\u10dc\u10d5\u10d0\u10e0\u10e1_\u10d7\u10d4\u10d1\u10d4\u10e0\u10d5\u10d0\u10da\u10e1_\u10db\u10d0\u10e0\u10e2\u10e1_\u10d0\u10de\u10e0\u10d8\u10da\u10d8\u10e1_\u10db\u10d0\u10d8\u10e1\u10e1_\u10d8\u10d5\u10dc\u10d8\u10e1\u10e1_\u10d8\u10d5\u10da\u10d8\u10e1\u10e1_\u10d0\u10d2\u10d5\u10d8\u10e1\u10e2\u10e1_\u10e1\u10d4\u10e5\u10e2\u10d4\u10db\u10d1\u10d4\u10e0\u10e1_\u10dd\u10e5\u10e2\u10dd\u10db\u10d1\u10d4\u10e0\u10e1_\u10dc\u10dd\u10d4\u10db\u10d1\u10d4\u10e0\u10e1_\u10d3\u10d4\u10d9\u10d4\u10db\u10d1\u10d4\u10e0\u10e1".split("_")},monthsShort:"\u10d8\u10d0\u10dc_\u10d7\u10d4\u10d1_\u10db\u10d0\u10e0_\u10d0\u10de\u10e0_\u10db\u10d0\u10d8_\u10d8\u10d5\u10dc_\u10d8\u10d5\u10da_\u10d0\u10d2\u10d5_\u10e1\u10d4\u10e5_\u10dd\u10e5\u10e2_\u10dc\u10dd\u10d4_\u10d3\u10d4\u10d9".split("_"),weekdays:{standalone:"\u10d9\u10d5\u10d8\u10e0\u10d0_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10d8_\u10e8\u10d0\u10d1\u10d0\u10d7\u10d8".split("_"),format:"\u10d9\u10d5\u10d8\u10e0\u10d0\u10e1_\u10dd\u10e0\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10e1\u10d0\u10db\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10dd\u10d7\u10ee\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10ee\u10e3\u10d7\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1_\u10de\u10d0\u10e0\u10d0\u10e1\u10d9\u10d4\u10d5\u10e1_\u10e8\u10d0\u10d1\u10d0\u10d7\u10e1".split("_"),isFormat:/(\u10ec\u10d8\u10dc\u10d0|\u10e8\u10d4\u10db\u10d3\u10d4\u10d2)/},weekdaysShort:"\u10d9\u10d5\u10d8_\u10dd\u10e0\u10e8_\u10e1\u10d0\u10db_\u10dd\u10d7\u10ee_\u10ee\u10e3\u10d7_\u10de\u10d0\u10e0_\u10e8\u10d0\u10d1".split("_"),weekdaysMin:"\u10d9\u10d5_\u10dd\u10e0_\u10e1\u10d0_\u10dd\u10d7_\u10ee\u10e3_\u10de\u10d0_\u10e8\u10d0".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[\u10d3\u10e6\u10d4\u10e1] LT[-\u10d6\u10d4]",nextDay:"[\u10ee\u10d5\u10d0\u10da] LT[-\u10d6\u10d4]",lastDay:"[\u10d2\u10e3\u10e8\u10d8\u10dc] LT[-\u10d6\u10d4]",nextWeek:"[\u10e8\u10d4\u10db\u10d3\u10d4\u10d2] dddd LT[-\u10d6\u10d4]",lastWeek:"[\u10ec\u10d8\u10dc\u10d0] dddd LT-\u10d6\u10d4",sameElse:"L"},relativeTime:{future:function(e){return/(\u10ec\u10d0\u10db\u10d8|\u10ec\u10e3\u10d7\u10d8|\u10e1\u10d0\u10d0\u10d7\u10d8|\u10ec\u10d4\u10da\u10d8)/.test(e)?e.replace(/\u10d8$/,"\u10e8\u10d8"):e+"\u10e8\u10d8"},past:function(e){return/(\u10ec\u10d0\u10db\u10d8|\u10ec\u10e3\u10d7\u10d8|\u10e1\u10d0\u10d0\u10d7\u10d8|\u10d3\u10e6\u10d4|\u10d7\u10d5\u10d4)/.test(e)?e.replace(/(\u10d8|\u10d4)$/,"\u10d8\u10e1 \u10ec\u10d8\u10dc"):/\u10ec\u10d4\u10da\u10d8/.test(e)?e.replace(/\u10ec\u10d4\u10da\u10d8$/,"\u10ec\u10da\u10d8\u10e1 \u10ec\u10d8\u10dc"):void 0},s:"\u10e0\u10d0\u10db\u10d3\u10d4\u10dc\u10d8\u10db\u10d4 \u10ec\u10d0\u10db\u10d8",ss:"%d \u10ec\u10d0\u10db\u10d8",m:"\u10ec\u10e3\u10d7\u10d8",mm:"%d \u10ec\u10e3\u10d7\u10d8",h:"\u10e1\u10d0\u10d0\u10d7\u10d8",hh:"%d \u10e1\u10d0\u10d0\u10d7\u10d8",d:"\u10d3\u10e6\u10d4",dd:"%d \u10d3\u10e6\u10d4",M:"\u10d7\u10d5\u10d4",MM:"%d \u10d7\u10d5\u10d4",y:"\u10ec\u10d4\u10da\u10d8",yy:"%d \u10ec\u10d4\u10da\u10d8"},dayOfMonthOrdinalParse:/0|1-\u10da\u10d8|\u10db\u10d4-\d{1,2}|\d{1,2}-\u10d4/,ordinal:function(e){return 0===e?e:1===e?e+"-\u10da\u10d8":e<20||e<=100&&e%20==0||e%100==0?"\u10db\u10d4-"+e:e+"-\u10d4"},week:{dow:1,doy:7}});var Ks={0:"-\u0448\u0456",1:"-\u0448\u0456",2:"-\u0448\u0456",3:"-\u0448\u0456",4:"-\u0448\u0456",5:"-\u0448\u0456",6:"-\u0448\u044b",7:"-\u0448\u0456",8:"-\u0448\u0456",9:"-\u0448\u044b",10:"-\u0448\u044b",20:"-\u0448\u044b",30:"-\u0448\u044b",40:"-\u0448\u044b",50:"-\u0448\u0456",60:"-\u0448\u044b",70:"-\u0448\u0456",80:"-\u0448\u0456",90:"-\u0448\u044b",100:"-\u0448\u0456"};l.defineLocale("kk",{months:"\u049b\u0430\u04a3\u0442\u0430\u0440_\u0430\u049b\u043f\u0430\u043d_\u043d\u0430\u0443\u0440\u044b\u0437_\u0441\u04d9\u0443\u0456\u0440_\u043c\u0430\u043c\u044b\u0440_\u043c\u0430\u0443\u0441\u044b\u043c_\u0448\u0456\u043b\u0434\u0435_\u0442\u0430\u043c\u044b\u0437_\u049b\u044b\u0440\u043a\u04af\u0439\u0435\u043a_\u049b\u0430\u0437\u0430\u043d_\u049b\u0430\u0440\u0430\u0448\u0430_\u0436\u0435\u043b\u0442\u043e\u049b\u0441\u0430\u043d".split("_"),monthsShort:"\u049b\u0430\u04a3_\u0430\u049b\u043f_\u043d\u0430\u0443_\u0441\u04d9\u0443_\u043c\u0430\u043c_\u043c\u0430\u0443_\u0448\u0456\u043b_\u0442\u0430\u043c_\u049b\u044b\u0440_\u049b\u0430\u0437_\u049b\u0430\u0440_\u0436\u0435\u043b".split("_"),weekdays:"\u0436\u0435\u043a\u0441\u0435\u043d\u0431\u0456_\u0434\u04af\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0441\u04d9\u0440\u0441\u0435\u043d\u0431\u0456_\u0431\u0435\u0439\u0441\u0435\u043d\u0431\u0456_\u0436\u04b1\u043c\u0430_\u0441\u0435\u043d\u0431\u0456".split("_"),weekdaysShort:"\u0436\u0435\u043a_\u0434\u04af\u0439_\u0441\u0435\u0439_\u0441\u04d9\u0440_\u0431\u0435\u0439_\u0436\u04b1\u043c_\u0441\u0435\u043d".split("_"),weekdaysMin:"\u0436\u043a_\u0434\u0439_\u0441\u0439_\u0441\u0440_\u0431\u0439_\u0436\u043c_\u0441\u043d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u0456\u043d \u0441\u0430\u0493\u0430\u0442] LT",nextDay:"[\u0415\u0440\u0442\u0435\u04a3 \u0441\u0430\u0493\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0493\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0448\u0435 \u0441\u0430\u0493\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u0435\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u04a3] dddd [\u0441\u0430\u0493\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0456\u0448\u0456\u043d\u0434\u0435",past:"%s \u0431\u04b1\u0440\u044b\u043d",s:"\u0431\u0456\u0440\u043d\u0435\u0448\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0456\u0440 \u043c\u0438\u043d\u0443\u0442",mm:"%d \u043c\u0438\u043d\u0443\u0442",h:"\u0431\u0456\u0440 \u0441\u0430\u0493\u0430\u0442",hh:"%d \u0441\u0430\u0493\u0430\u0442",d:"\u0431\u0456\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0456\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0456\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0448\u0456|\u0448\u044b)/,ordinal:function(e){return e+(Ks[e]||Ks[e%10]||Ks[100<=e?100:null])},week:{dow:1,doy:7}});var $s={1:"\u17e1",2:"\u17e2",3:"\u17e3",4:"\u17e4",5:"\u17e5",6:"\u17e6",7:"\u17e7",8:"\u17e8",9:"\u17e9",0:"\u17e0"},Zs={"\u17e1":"1","\u17e2":"2","\u17e3":"3","\u17e4":"4","\u17e5":"5","\u17e6":"6","\u17e7":"7","\u17e8":"8","\u17e9":"9","\u17e0":"0"};l.defineLocale("km",{months:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),monthsShort:"\u1798\u1780\u179a\u17b6_\u1780\u17bb\u1798\u17d2\u1797\u17c8_\u1798\u17b8\u1793\u17b6_\u1798\u17c1\u179f\u17b6_\u17a7\u179f\u1797\u17b6_\u1798\u17b7\u1790\u17bb\u1793\u17b6_\u1780\u1780\u17d2\u1780\u178a\u17b6_\u179f\u17b8\u17a0\u17b6_\u1780\u1789\u17d2\u1789\u17b6_\u178f\u17bb\u179b\u17b6_\u179c\u17b7\u1785\u17d2\u1786\u17b7\u1780\u17b6_\u1792\u17d2\u1793\u17bc".split("_"),weekdays:"\u17a2\u17b6\u1791\u17b7\u178f\u17d2\u1799_\u1785\u17d0\u1793\u17d2\u1791_\u17a2\u1784\u17d2\u1782\u17b6\u179a_\u1796\u17bb\u1792_\u1796\u17d2\u179a\u17a0\u179f\u17d2\u1794\u178f\u17b7\u17cd_\u179f\u17bb\u1780\u17d2\u179a_\u179f\u17c5\u179a\u17cd".split("_"),weekdaysShort:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysMin:"\u17a2\u17b6_\u1785_\u17a2_\u1796_\u1796\u17d2\u179a_\u179f\u17bb_\u179f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},meridiemParse:/\u1796\u17d2\u179a\u17b9\u1780|\u179b\u17d2\u1784\u17b6\u1785/,isPM:function(e){return"\u179b\u17d2\u1784\u17b6\u1785"===e},meridiem:function(e,a,t){return e<12?"\u1796\u17d2\u179a\u17b9\u1780":"\u179b\u17d2\u1784\u17b6\u1785"},calendar:{sameDay:"[\u1790\u17d2\u1784\u17c3\u1793\u17c1\u17c7 \u1798\u17c9\u17c4\u1784] LT",nextDay:"[\u179f\u17d2\u17a2\u17c2\u1780 \u1798\u17c9\u17c4\u1784] LT",nextWeek:"dddd [\u1798\u17c9\u17c4\u1784] LT",lastDay:"[\u1798\u17d2\u179f\u17b7\u179b\u1798\u17b7\u1789 \u1798\u17c9\u17c4\u1784] LT",lastWeek:"dddd [\u179f\u1794\u17d2\u178f\u17b6\u17a0\u17cd\u1798\u17bb\u1793] [\u1798\u17c9\u17c4\u1784] LT",sameElse:"L"},relativeTime:{future:"%s\u1791\u17c0\u178f",past:"%s\u1798\u17bb\u1793",s:"\u1794\u17c9\u17bb\u1793\u17d2\u1798\u17b6\u1793\u179c\u17b7\u1793\u17b6\u1791\u17b8",ss:"%d \u179c\u17b7\u1793\u17b6\u1791\u17b8",m:"\u1798\u17bd\u1799\u1793\u17b6\u1791\u17b8",mm:"%d \u1793\u17b6\u1791\u17b8",h:"\u1798\u17bd\u1799\u1798\u17c9\u17c4\u1784",hh:"%d \u1798\u17c9\u17c4\u1784",d:"\u1798\u17bd\u1799\u1790\u17d2\u1784\u17c3",dd:"%d \u1790\u17d2\u1784\u17c3",M:"\u1798\u17bd\u1799\u1781\u17c2",MM:"%d \u1781\u17c2",y:"\u1798\u17bd\u1799\u1786\u17d2\u1793\u17b6\u17c6",yy:"%d \u1786\u17d2\u1793\u17b6\u17c6"},dayOfMonthOrdinalParse:/\u1791\u17b8\d{1,2}/,ordinal:"\u1791\u17b8%d",preparse:function(e){return e.replace(/[\u17e1\u17e2\u17e3\u17e4\u17e5\u17e6\u17e7\u17e8\u17e9\u17e0]/g,function(e){return Zs[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return $s[e]})},week:{dow:1,doy:4}});var Bs={1:"\u0ce7",2:"\u0ce8",3:"\u0ce9",4:"\u0cea",5:"\u0ceb",6:"\u0cec",7:"\u0ced",8:"\u0cee",9:"\u0cef",0:"\u0ce6"},qs={"\u0ce7":"1","\u0ce8":"2","\u0ce9":"3","\u0cea":"4","\u0ceb":"5","\u0cec":"6","\u0ced":"7","\u0cee":"8","\u0cef":"9","\u0ce6":"0"};l.defineLocale("kn",{months:"\u0c9c\u0ca8\u0cb5\u0cb0\u0cbf_\u0cab\u0cc6\u0cac\u0ccd\u0cb0\u0cb5\u0cb0\u0cbf_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5\u0cac\u0cb0\u0ccd_\u0ca8\u0cb5\u0cc6\u0c82\u0cac\u0cb0\u0ccd_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82\u0cac\u0cb0\u0ccd".split("_"),monthsShort:"\u0c9c\u0ca8_\u0cab\u0cc6\u0cac\u0ccd\u0cb0_\u0cae\u0cbe\u0cb0\u0ccd\u0c9a\u0ccd_\u0c8f\u0caa\u0ccd\u0cb0\u0cbf\u0cb2\u0ccd_\u0cae\u0cc6\u0cd5_\u0c9c\u0cc2\u0ca8\u0ccd_\u0c9c\u0cc1\u0cb2\u0cc6\u0cd6_\u0c86\u0c97\u0cb8\u0ccd\u0c9f\u0ccd_\u0cb8\u0cc6\u0caa\u0ccd\u0c9f\u0cc6\u0c82_\u0c85\u0c95\u0ccd\u0c9f\u0cc6\u0cc2\u0cd5_\u0ca8\u0cb5\u0cc6\u0c82_\u0ca1\u0cbf\u0cb8\u0cc6\u0c82".split("_"),monthsParseExact:!0,weekdays:"\u0cad\u0cbe\u0ca8\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae\u0cb5\u0cbe\u0cb0_\u0cae\u0c82\u0c97\u0cb3\u0cb5\u0cbe\u0cb0_\u0cac\u0cc1\u0ca7\u0cb5\u0cbe\u0cb0_\u0c97\u0cc1\u0cb0\u0cc1\u0cb5\u0cbe\u0cb0_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0\u0cb5\u0cbe\u0cb0_\u0cb6\u0ca8\u0cbf\u0cb5\u0cbe\u0cb0".split("_"),weekdaysShort:"\u0cad\u0cbe\u0ca8\u0cc1_\u0cb8\u0cc6\u0cc2\u0cd5\u0cae_\u0cae\u0c82\u0c97\u0cb3_\u0cac\u0cc1\u0ca7_\u0c97\u0cc1\u0cb0\u0cc1_\u0cb6\u0cc1\u0c95\u0ccd\u0cb0_\u0cb6\u0ca8\u0cbf".split("_"),weekdaysMin:"\u0cad\u0cbe_\u0cb8\u0cc6\u0cc2\u0cd5_\u0cae\u0c82_\u0cac\u0cc1_\u0c97\u0cc1_\u0cb6\u0cc1_\u0cb6".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c87\u0c82\u0ca6\u0cc1] LT",nextDay:"[\u0ca8\u0cbe\u0cb3\u0cc6] LT",nextWeek:"dddd, LT",lastDay:"[\u0ca8\u0cbf\u0ca8\u0ccd\u0ca8\u0cc6] LT",lastWeek:"[\u0c95\u0cc6\u0cc2\u0ca8\u0cc6\u0caf] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0ca8\u0c82\u0ca4\u0cb0",past:"%s \u0cb9\u0cbf\u0c82\u0ca6\u0cc6",s:"\u0c95\u0cc6\u0cb2\u0cb5\u0cc1 \u0c95\u0ccd\u0cb7\u0ca3\u0c97\u0cb3\u0cc1",ss:"%d \u0cb8\u0cc6\u0c95\u0cc6\u0c82\u0ca1\u0cc1\u0c97\u0cb3\u0cc1",m:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",mm:"%d \u0ca8\u0cbf\u0cae\u0cbf\u0cb7",h:"\u0c92\u0c82\u0ca6\u0cc1 \u0c97\u0c82\u0c9f\u0cc6",hh:"%d \u0c97\u0c82\u0c9f\u0cc6",d:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca6\u0cbf\u0ca8",dd:"%d \u0ca6\u0cbf\u0ca8",M:"\u0c92\u0c82\u0ca6\u0cc1 \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",MM:"%d \u0ca4\u0cbf\u0c82\u0c97\u0cb3\u0cc1",y:"\u0c92\u0c82\u0ca6\u0cc1 \u0cb5\u0cb0\u0ccd\u0cb7",yy:"%d \u0cb5\u0cb0\u0ccd\u0cb7"},preparse:function(e){return e.replace(/[\u0ce7\u0ce8\u0ce9\u0cea\u0ceb\u0cec\u0ced\u0cee\u0cef\u0ce6]/g,function(e){return qs[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Bs[e]})},meridiemParse:/\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf|\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6|\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8|\u0cb8\u0c82\u0c9c\u0cc6/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"===a?e<4?e:e+12:"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6"===a?e:"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8"===a?10<=e?e:e+12:"\u0cb8\u0c82\u0c9c\u0cc6"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf":e<10?"\u0cac\u0cc6\u0cb3\u0cbf\u0c97\u0ccd\u0c97\u0cc6":e<17?"\u0cae\u0ca7\u0ccd\u0caf\u0cbe\u0cb9\u0ccd\u0ca8":e<20?"\u0cb8\u0c82\u0c9c\u0cc6":"\u0cb0\u0cbe\u0ca4\u0ccd\u0cb0\u0cbf"},dayOfMonthOrdinalParse:/\d{1,2}(\u0ca8\u0cc6\u0cd5)/,ordinal:function(e){return e+"\u0ca8\u0cc6\u0cd5"},week:{dow:0,doy:6}}),l.defineLocale("ko",{months:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),monthsShort:"1\uc6d4_2\uc6d4_3\uc6d4_4\uc6d4_5\uc6d4_6\uc6d4_7\uc6d4_8\uc6d4_9\uc6d4_10\uc6d4_11\uc6d4_12\uc6d4".split("_"),weekdays:"\uc77c\uc694\uc77c_\uc6d4\uc694\uc77c_\ud654\uc694\uc77c_\uc218\uc694\uc77c_\ubaa9\uc694\uc77c_\uae08\uc694\uc77c_\ud1a0\uc694\uc77c".split("_"),weekdaysShort:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),weekdaysMin:"\uc77c_\uc6d4_\ud654_\uc218_\ubaa9_\uae08_\ud1a0".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY\ub144 MMMM D\uc77c",LLL:"YYYY\ub144 MMMM D\uc77c A h:mm",LLLL:"YYYY\ub144 MMMM D\uc77c dddd A h:mm",l:"YYYY.MM.DD.",ll:"YYYY\ub144 MMMM D\uc77c",lll:"YYYY\ub144 MMMM D\uc77c A h:mm",llll:"YYYY\ub144 MMMM D\uc77c dddd A h:mm"},calendar:{sameDay:"\uc624\ub298 LT",nextDay:"\ub0b4\uc77c LT",nextWeek:"dddd LT",lastDay:"\uc5b4\uc81c LT",lastWeek:"\uc9c0\ub09c\uc8fc dddd LT",sameElse:"L"},relativeTime:{future:"%s \ud6c4",past:"%s \uc804",s:"\uba87 \ucd08",ss:"%d\ucd08",m:"1\ubd84",mm:"%d\ubd84",h:"\ud55c \uc2dc\uac04",hh:"%d\uc2dc\uac04",d:"\ud558\ub8e8",dd:"%d\uc77c",M:"\ud55c \ub2ec",MM:"%d\ub2ec",y:"\uc77c \ub144",yy:"%d\ub144"},dayOfMonthOrdinalParse:/\d{1,2}(\uc77c|\uc6d4|\uc8fc)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\uc77c";case"M":return e+"\uc6d4";case"w":case"W":return e+"\uc8fc";default:return e}},meridiemParse:/\uc624\uc804|\uc624\ud6c4/,isPM:function(e){return"\uc624\ud6c4"===e},meridiem:function(e,a,t){return e<12?"\uc624\uc804":"\uc624\ud6c4"}});var Qs={0:"-\u0447\u04af",1:"-\u0447\u0438",2:"-\u0447\u0438",3:"-\u0447\u04af",4:"-\u0447\u04af",5:"-\u0447\u0438",6:"-\u0447\u044b",7:"-\u0447\u0438",8:"-\u0447\u0438",9:"-\u0447\u0443",10:"-\u0447\u0443",20:"-\u0447\u044b",30:"-\u0447\u0443",40:"-\u0447\u044b",50:"-\u0447\u04af",60:"-\u0447\u044b",70:"-\u0447\u0438",80:"-\u0447\u0438",90:"-\u0447\u0443",100:"-\u0447\u04af"};function Xs(e,a,t,s){var n={m:["eng Minutt","enger Minutt"],h:["eng Stonn","enger Stonn"],d:["een Dag","engem Dag"],M:["ee Mount","engem Mount"],y:["ee Joer","engem Joer"]};return a?n[t][0]:n[t][1]}function en(e){if(e=parseInt(e,10),isNaN(e))return!1;if(e<0)return!0;if(e<10)return 4<=e&&e<=7;if(e<100){var a=e%10;return en(0===a?e/10:a)}if(e<1e4){for(;10<=e;)e/=10;return en(e)}return en(e/=1e3)}l.defineLocale("ky",{months:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u0416\u0435\u043a\u0448\u0435\u043c\u0431\u0438_\u0414\u04af\u0439\u0448\u04e9\u043c\u0431\u04af_\u0428\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0428\u0430\u0440\u0448\u0435\u043c\u0431\u0438_\u0411\u0435\u0439\u0448\u0435\u043c\u0431\u0438_\u0416\u0443\u043c\u0430_\u0418\u0448\u0435\u043c\u0431\u0438".split("_"),weekdaysShort:"\u0416\u0435\u043a_\u0414\u04af\u0439_\u0428\u0435\u0439_\u0428\u0430\u0440_\u0411\u0435\u0439_\u0416\u0443\u043c_\u0418\u0448\u0435".split("_"),weekdaysMin:"\u0416\u043a_\u0414\u0439_\u0428\u0439_\u0428\u0440_\u0411\u0439_\u0416\u043c_\u0418\u0448".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0411\u04af\u0433\u04af\u043d \u0441\u0430\u0430\u0442] LT",nextDay:"[\u042d\u0440\u0442\u0435\u04a3 \u0441\u0430\u0430\u0442] LT",nextWeek:"dddd [\u0441\u0430\u0430\u0442] LT",lastDay:"[\u041a\u0435\u0447\u0435 \u0441\u0430\u0430\u0442] LT",lastWeek:"[\u04e8\u0442\u043a\u0435\u043d \u0430\u043f\u0442\u0430\u043d\u044b\u043d] dddd [\u043a\u04af\u043d\u04af] [\u0441\u0430\u0430\u0442] LT",sameElse:"L"},relativeTime:{future:"%s \u0438\u0447\u0438\u043d\u0434\u0435",past:"%s \u043c\u0443\u0440\u0443\u043d",s:"\u0431\u0438\u0440\u043d\u0435\u0447\u0435 \u0441\u0435\u043a\u0443\u043d\u0434",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434",m:"\u0431\u0438\u0440 \u043c\u04af\u043d\u04e9\u0442",mm:"%d \u043c\u04af\u043d\u04e9\u0442",h:"\u0431\u0438\u0440 \u0441\u0430\u0430\u0442",hh:"%d \u0441\u0430\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u04af\u043d",dd:"%d \u043a\u04af\u043d",M:"\u0431\u0438\u0440 \u0430\u0439",MM:"%d \u0430\u0439",y:"\u0431\u0438\u0440 \u0436\u044b\u043b",yy:"%d \u0436\u044b\u043b"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0447\u0438|\u0447\u044b|\u0447\u04af|\u0447\u0443)/,ordinal:function(e){return e+(Qs[e]||Qs[e%10]||Qs[100<=e?100:null])},week:{dow:1,doy:7}}),l.defineLocale("lb",{months:"Januar_Februar_M\xe4erz_Abr\xebll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonndeg_M\xe9indeg_D\xebnschdeg_M\xebttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),weekdaysShort:"So._M\xe9._D\xeb._M\xeb._Do._Fr._Sa.".split("_"),weekdaysMin:"So_M\xe9_D\xeb_M\xeb_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm [Auer]",LTS:"H:mm:ss [Auer]",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm [Auer]",LLLL:"dddd, D. MMMM YYYY H:mm [Auer]"},calendar:{sameDay:"[Haut um] LT",sameElse:"L",nextDay:"[Muer um] LT",nextWeek:"dddd [um] LT",lastDay:"[G\xebschter um] LT",lastWeek:function(){switch(this.day()){case 2:case 4:return"[Leschten] dddd [um] LT";default:return"[Leschte] dddd [um] LT"}}},relativeTime:{future:function(e){return en(e.substr(0,e.indexOf(" ")))?"a "+e:"an "+e},past:function(e){return en(e.substr(0,e.indexOf(" ")))?"viru "+e:"virun "+e},s:"e puer Sekonnen",ss:"%d Sekonnen",m:Xs,mm:"%d Minutten",h:Xs,hh:"%d Stonnen",d:Xs,dd:"%d Deeg",M:Xs,MM:"%d M\xe9int",y:Xs,yy:"%d Joer"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("lo",{months:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),monthsShort:"\u0ea1\u0eb1\u0e87\u0e81\u0ead\u0e99_\u0e81\u0eb8\u0ea1\u0e9e\u0eb2_\u0ea1\u0eb5\u0e99\u0eb2_\u0ec0\u0ea1\u0eaa\u0eb2_\u0e9e\u0eb6\u0e94\u0eaa\u0eb0\u0e9e\u0eb2_\u0ea1\u0eb4\u0e96\u0eb8\u0e99\u0eb2_\u0e81\u0ecd\u0ea5\u0eb0\u0e81\u0ebb\u0e94_\u0eaa\u0eb4\u0e87\u0eab\u0eb2_\u0e81\u0eb1\u0e99\u0e8d\u0eb2_\u0e95\u0eb8\u0ea5\u0eb2_\u0e9e\u0eb0\u0e88\u0eb4\u0e81_\u0e97\u0eb1\u0e99\u0ea7\u0eb2".split("_"),weekdays:"\u0ead\u0eb2\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysShort:"\u0e97\u0eb4\u0e94_\u0e88\u0eb1\u0e99_\u0ead\u0eb1\u0e87\u0e84\u0eb2\u0e99_\u0e9e\u0eb8\u0e94_\u0e9e\u0eb0\u0eab\u0eb1\u0e94_\u0eaa\u0eb8\u0e81_\u0ec0\u0eaa\u0ebb\u0eb2".split("_"),weekdaysMin:"\u0e97_\u0e88_\u0ead\u0e84_\u0e9e_\u0e9e\u0eab_\u0eaa\u0e81_\u0eaa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"\u0ea7\u0eb1\u0e99dddd D MMMM YYYY HH:mm"},meridiemParse:/\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2|\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87/,isPM:function(e){return"\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"===e},meridiem:function(e,a,t){return e<12?"\u0e95\u0ead\u0e99\u0ec0\u0e8a\u0ebb\u0ec9\u0eb2":"\u0e95\u0ead\u0e99\u0ec1\u0ea5\u0e87"},calendar:{sameDay:"[\u0ea1\u0eb7\u0ec9\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextDay:"[\u0ea1\u0eb7\u0ec9\u0ead\u0eb7\u0ec8\u0e99\u0ec0\u0ea7\u0ea5\u0eb2] LT",nextWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0edc\u0ec9\u0eb2\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastDay:"[\u0ea1\u0eb7\u0ec9\u0ea7\u0eb2\u0e99\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",lastWeek:"[\u0ea7\u0eb1\u0e99]dddd[\u0ec1\u0ea5\u0ec9\u0ea7\u0e99\u0eb5\u0ec9\u0ec0\u0ea7\u0ea5\u0eb2] LT",sameElse:"L"},relativeTime:{future:"\u0ead\u0eb5\u0e81 %s",past:"%s\u0e9c\u0ec8\u0eb2\u0e99\u0ea1\u0eb2",s:"\u0e9a\u0ecd\u0ec8\u0ec0\u0e97\u0ebb\u0ec8\u0eb2\u0ec3\u0e94\u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",ss:"%d \u0ea7\u0eb4\u0e99\u0eb2\u0e97\u0eb5",m:"1 \u0e99\u0eb2\u0e97\u0eb5",mm:"%d \u0e99\u0eb2\u0e97\u0eb5",h:"1 \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",hh:"%d \u0e8a\u0ebb\u0ec8\u0ea7\u0ec2\u0ea1\u0e87",d:"1 \u0ea1\u0eb7\u0ec9",dd:"%d \u0ea1\u0eb7\u0ec9",M:"1 \u0ec0\u0e94\u0eb7\u0ead\u0e99",MM:"%d \u0ec0\u0e94\u0eb7\u0ead\u0e99",y:"1 \u0e9b\u0eb5",yy:"%d \u0e9b\u0eb5"},dayOfMonthOrdinalParse:/(\u0e97\u0eb5\u0ec8)\d{1,2}/,ordinal:function(e){return"\u0e97\u0eb5\u0ec8"+e}});var an={ss:"sekund\u0117_sekund\u017ei\u0173_sekundes",m:"minut\u0117_minut\u0117s_minut\u0119",mm:"minut\u0117s_minu\u010di\u0173_minutes",h:"valanda_valandos_valand\u0105",hh:"valandos_valand\u0173_valandas",d:"diena_dienos_dien\u0105",dd:"dienos_dien\u0173_dienas",M:"m\u0117nuo_m\u0117nesio_m\u0117nes\u012f",MM:"m\u0117nesiai_m\u0117nesi\u0173_m\u0117nesius",y:"metai_met\u0173_metus",yy:"metai_met\u0173_metus"};function tn(e,a,t,s){return a?nn(t)[0]:s?nn(t)[1]:nn(t)[2]}function sn(e){return e%10==0||10<e&&e<20}function nn(e){return an[e].split("_")}function dn(e,a,t,s){var n=e+" ";return 1===e?n+tn(0,a,t[0],s):a?n+(sn(e)?nn(t)[1]:nn(t)[0]):s?n+nn(t)[1]:n+(sn(e)?nn(t)[1]:nn(t)[2])}l.defineLocale("lt",{months:{format:"sausio_vasario_kovo_baland\u017eio_gegu\u017e\u0117s_bir\u017eelio_liepos_rugpj\u016b\u010dio_rugs\u0117jo_spalio_lapkri\u010dio_gruod\u017eio".split("_"),standalone:"sausis_vasaris_kovas_balandis_gegu\u017e\u0117_bir\u017eelis_liepa_rugpj\u016btis_rugs\u0117jis_spalis_lapkritis_gruodis".split("_"),isFormat:/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/},monthsShort:"sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),weekdays:{format:"sekmadien\u012f_pirmadien\u012f_antradien\u012f_tre\u010diadien\u012f_ketvirtadien\u012f_penktadien\u012f_\u0161e\u0161tadien\u012f".split("_"),standalone:"sekmadienis_pirmadienis_antradienis_tre\u010diadienis_ketvirtadienis_penktadienis_\u0161e\u0161tadienis".split("_"),isFormat:/dddd HH:mm/},weekdaysShort:"Sek_Pir_Ant_Tre_Ket_Pen_\u0160e\u0161".split("_"),weekdaysMin:"S_P_A_T_K_Pn_\u0160".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY [m.] MMMM D [d.]",LLL:"YYYY [m.] MMMM D [d.], HH:mm [val.]",LLLL:"YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",l:"YYYY-MM-DD",ll:"YYYY [m.] MMMM D [d.]",lll:"YYYY [m.] MMMM D [d.], HH:mm [val.]",llll:"YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"},calendar:{sameDay:"[\u0160iandien] LT",nextDay:"[Rytoj] LT",nextWeek:"dddd LT",lastDay:"[Vakar] LT",lastWeek:"[Pra\u0117jus\u012f] dddd LT",sameElse:"L"},relativeTime:{future:"po %s",past:"prie\u0161 %s",s:function(e,a,t,s){return a?"kelios sekund\u0117s":s?"keli\u0173 sekund\u017ei\u0173":"kelias sekundes"},ss:dn,m:tn,mm:dn,h:tn,hh:dn,d:tn,dd:dn,M:tn,MM:dn,y:tn,yy:dn},dayOfMonthOrdinalParse:/\d{1,2}-oji/,ordinal:function(e){return e+"-oji"},week:{dow:1,doy:4}});var rn={ss:"sekundes_sekund\u0113m_sekunde_sekundes".split("_"),m:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),mm:"min\u016btes_min\u016bt\u0113m_min\u016bte_min\u016btes".split("_"),h:"stundas_stund\u0101m_stunda_stundas".split("_"),hh:"stundas_stund\u0101m_stunda_stundas".split("_"),d:"dienas_dien\u0101m_diena_dienas".split("_"),dd:"dienas_dien\u0101m_diena_dienas".split("_"),M:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),MM:"m\u0113ne\u0161a_m\u0113ne\u0161iem_m\u0113nesis_m\u0113ne\u0161i".split("_"),y:"gada_gadiem_gads_gadi".split("_"),yy:"gada_gadiem_gads_gadi".split("_")};function _n(e,a,t){return t?a%10==1&&a%100!=11?e[2]:e[3]:a%10==1&&a%100!=11?e[0]:e[1]}function on(e,a,t){return e+" "+_n(rn[t],e,a)}function mn(e,a,t){return _n(rn[t],e,a)}l.defineLocale("lv",{months:"janv\u0101ris_febru\u0101ris_marts_apr\u012blis_maijs_j\u016bnijs_j\u016blijs_augusts_septembris_oktobris_novembris_decembris".split("_"),monthsShort:"jan_feb_mar_apr_mai_j\u016bn_j\u016bl_aug_sep_okt_nov_dec".split("_"),weekdays:"sv\u0113tdiena_pirmdiena_otrdiena_tre\u0161diena_ceturtdiena_piektdiena_sestdiena".split("_"),weekdaysShort:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysMin:"Sv_P_O_T_C_Pk_S".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY.",LL:"YYYY. [gada] D. MMMM",LLL:"YYYY. [gada] D. MMMM, HH:mm",LLLL:"YYYY. [gada] D. MMMM, dddd, HH:mm"},calendar:{sameDay:"[\u0160odien pulksten] LT",nextDay:"[R\u012bt pulksten] LT",nextWeek:"dddd [pulksten] LT",lastDay:"[Vakar pulksten] LT",lastWeek:"[Pag\u0101ju\u0161\u0101] dddd [pulksten] LT",sameElse:"L"},relativeTime:{future:"p\u0113c %s",past:"pirms %s",s:function(e,a){return a?"da\u017eas sekundes":"da\u017e\u0101m sekund\u0113m"},ss:on,m:mn,mm:on,h:mn,hh:on,d:mn,dd:on,M:mn,MM:on,y:mn,yy:on},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var un={words:{ss:["sekund","sekunda","sekundi"],m:["jedan minut","jednog minuta"],mm:["minut","minuta","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],dd:["dan","dana","dana"],MM:["mjesec","mjeseca","mjeseci"],yy:["godina","godine","godina"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,t){var s=un.words[t];return 1===t.length?a?s[0]:s[1]:e+" "+un.correctGrammaticalCase(e,s)}};function ln(e,a,t,s){switch(t){case"s":return a?"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434":"\u0445\u044d\u0434\u0445\u044d\u043d \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d";case"ss":return e+(a?" \u0441\u0435\u043a\u0443\u043d\u0434":" \u0441\u0435\u043a\u0443\u043d\u0434\u044b\u043d");case"m":case"mm":return e+(a?" \u043c\u0438\u043d\u0443\u0442":" \u043c\u0438\u043d\u0443\u0442\u044b\u043d");case"h":case"hh":return e+(a?" \u0446\u0430\u0433":" \u0446\u0430\u0433\u0438\u0439\u043d");case"d":case"dd":return e+(a?" \u04e9\u0434\u04e9\u0440":" \u04e9\u0434\u0440\u0438\u0439\u043d");case"M":case"MM":return e+(a?" \u0441\u0430\u0440":" \u0441\u0430\u0440\u044b\u043d");case"y":case"yy":return e+(a?" \u0436\u0438\u043b":" \u0436\u0438\u043b\u0438\u0439\u043d");default:return e}}l.defineLocale("me",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedjelja_ponedjeljak_utorak_srijeda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sri._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sjutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedjelju] [u] LT";case 3:return"[u] [srijedu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return["[pro\u0161le] [nedjelje] [u] LT","[pro\u0161log] [ponedjeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srijede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"prije %s",s:"nekoliko sekundi",ss:un.translate,m:un.translate,mm:un.translate,h:un.translate,hh:un.translate,d:"dan",dd:un.translate,M:"mjesec",MM:un.translate,y:"godinu",yy:un.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),l.defineLocale("mi",{months:"Kohi-t\u0101te_Hui-tanguru_Pout\u016b-te-rangi_Paenga-wh\u0101wh\u0101_Haratua_Pipiri_H\u014dngoingoi_Here-turi-k\u014dk\u0101_Mahuru_Whiringa-\u0101-nuku_Whiringa-\u0101-rangi_Hakihea".split("_"),monthsShort:"Kohi_Hui_Pou_Pae_Hara_Pipi_H\u014dngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),monthsRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,monthsShortStrictRegex:/(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,weekdays:"R\u0101tapu_Mane_T\u016brei_Wenerei_T\u0101ite_Paraire_H\u0101tarei".split("_"),weekdaysShort:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),weekdaysMin:"Ta_Ma_T\u016b_We_T\u0101i_Pa_H\u0101".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [i] HH:mm",LLLL:"dddd, D MMMM YYYY [i] HH:mm"},calendar:{sameDay:"[i teie mahana, i] LT",nextDay:"[apopo i] LT",nextWeek:"dddd [i] LT",lastDay:"[inanahi i] LT",lastWeek:"dddd [whakamutunga i] LT",sameElse:"L"},relativeTime:{future:"i roto i %s",past:"%s i mua",s:"te h\u0113kona ruarua",ss:"%d h\u0113kona",m:"he meneti",mm:"%d meneti",h:"te haora",hh:"%d haora",d:"he ra",dd:"%d ra",M:"he marama",MM:"%d marama",y:"he tau",yy:"%d tau"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),l.defineLocale("mk",{months:"\u0458\u0430\u043d\u0443\u0430\u0440\u0438_\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d\u0438_\u0458\u0443\u043b\u0438_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438_\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438_\u043d\u043e\u0435\u043c\u0432\u0440\u0438_\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438".split("_"),monthsShort:"\u0458\u0430\u043d_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433_\u0441\u0435\u043f_\u043e\u043a\u0442_\u043d\u043e\u0435_\u0434\u0435\u043a".split("_"),weekdays:"\u043d\u0435\u0434\u0435\u043b\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u043e\u043a_\u043f\u0435\u0442\u043e\u043a_\u0441\u0430\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434_\u043f\u043e\u043d_\u0432\u0442\u043e_\u0441\u0440\u0435_\u0447\u0435\u0442_\u043f\u0435\u0442_\u0441\u0430\u0431".split("_"),weekdaysMin:"\u043de_\u043fo_\u0432\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441a".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"D.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[\u0414\u0435\u043d\u0435\u0441 \u0432\u043e] LT",nextDay:"[\u0423\u0442\u0440\u0435 \u0432\u043e] LT",nextWeek:"[\u0412\u043e] dddd [\u0432\u043e] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430 \u0432\u043e] LT",lastWeek:function(){switch(this.day()){case 0:case 3:case 6:return"[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0430\u0442\u0430] dddd [\u0432\u043e] LT";case 1:case 2:case 4:case 5:return"[\u0418\u0437\u043c\u0438\u043d\u0430\u0442\u0438\u043e\u0442] dddd [\u0432\u043e] LT"}},sameElse:"L"},relativeTime:{future:"\u043f\u043e\u0441\u043b\u0435 %s",past:"\u043f\u0440\u0435\u0434 %s",s:"\u043d\u0435\u043a\u043e\u043b\u043a\u0443 \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:"%d \u0441\u0435\u043a\u0443\u043d\u0434\u0438",m:"\u043c\u0438\u043d\u0443\u0442\u0430",mm:"%d \u043c\u0438\u043d\u0443\u0442\u0438",h:"\u0447\u0430\u0441",hh:"%d \u0447\u0430\u0441\u0430",d:"\u0434\u0435\u043d",dd:"%d \u0434\u0435\u043d\u0430",M:"\u043c\u0435\u0441\u0435\u0446",MM:"%d \u043c\u0435\u0441\u0435\u0446\u0438",y:"\u0433\u043e\u0434\u0438\u043d\u0430",yy:"%d \u0433\u043e\u0434\u0438\u043d\u0438"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0435\u0432|\u0435\u043d|\u0442\u0438|\u0432\u0438|\u0440\u0438|\u043c\u0438)/,ordinal:function(e){var a=e%10,t=e%100;return 0===e?e+"-\u0435\u0432":0===t?e+"-\u0435\u043d":10<t&&t<20?e+"-\u0442\u0438":1===a?e+"-\u0432\u0438":2===a?e+"-\u0440\u0438":7===a||8===a?e+"-\u043c\u0438":e+"-\u0442\u0438"},week:{dow:1,doy:7}}),l.defineLocale("ml",{months:"\u0d1c\u0d28\u0d41\u0d35\u0d30\u0d3f_\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41\u0d35\u0d30\u0d3f_\u0d2e\u0d3e\u0d7c\u0d1a\u0d4d\u0d1a\u0d4d_\u0d0f\u0d2a\u0d4d\u0d30\u0d3f\u0d7d_\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48_\u0d13\u0d17\u0d38\u0d4d\u0d31\u0d4d\u0d31\u0d4d_\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31\u0d02\u0d2c\u0d7c_\u0d12\u0d15\u0d4d\u0d1f\u0d4b\u0d2c\u0d7c_\u0d28\u0d35\u0d02\u0d2c\u0d7c_\u0d21\u0d3f\u0d38\u0d02\u0d2c\u0d7c".split("_"),monthsShort:"\u0d1c\u0d28\u0d41._\u0d2b\u0d46\u0d2c\u0d4d\u0d30\u0d41._\u0d2e\u0d3e\u0d7c._\u0d0f\u0d2a\u0d4d\u0d30\u0d3f._\u0d2e\u0d47\u0d2f\u0d4d_\u0d1c\u0d42\u0d7a_\u0d1c\u0d42\u0d32\u0d48._\u0d13\u0d17._\u0d38\u0d46\u0d2a\u0d4d\u0d31\u0d4d\u0d31._\u0d12\u0d15\u0d4d\u0d1f\u0d4b._\u0d28\u0d35\u0d02._\u0d21\u0d3f\u0d38\u0d02.".split("_"),monthsParseExact:!0,weekdays:"\u0d1e\u0d3e\u0d2f\u0d31\u0d3e\u0d34\u0d4d\u0d1a_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d33\u0d3e\u0d34\u0d4d\u0d1a_\u0d1a\u0d4a\u0d35\u0d4d\u0d35\u0d3e\u0d34\u0d4d\u0d1a_\u0d2c\u0d41\u0d27\u0d28\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d3e\u0d34\u0d4d\u0d1a_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a_\u0d36\u0d28\u0d3f\u0d2f\u0d3e\u0d34\u0d4d\u0d1a".split("_"),weekdaysShort:"\u0d1e\u0d3e\u0d2f\u0d7c_\u0d24\u0d3f\u0d19\u0d4d\u0d15\u0d7e_\u0d1a\u0d4a\u0d35\u0d4d\u0d35_\u0d2c\u0d41\u0d27\u0d7b_\u0d35\u0d4d\u0d2f\u0d3e\u0d34\u0d02_\u0d35\u0d46\u0d33\u0d4d\u0d33\u0d3f_\u0d36\u0d28\u0d3f".split("_"),weekdaysMin:"\u0d1e\u0d3e_\u0d24\u0d3f_\u0d1a\u0d4a_\u0d2c\u0d41_\u0d35\u0d4d\u0d2f\u0d3e_\u0d35\u0d46_\u0d36".split("_"),longDateFormat:{LT:"A h:mm -\u0d28\u0d41",LTS:"A h:mm:ss -\u0d28\u0d41",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm -\u0d28\u0d41",LLLL:"dddd, D MMMM YYYY, A h:mm -\u0d28\u0d41"},calendar:{sameDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d4d] LT",nextDay:"[\u0d28\u0d3e\u0d33\u0d46] LT",nextWeek:"dddd, LT",lastDay:"[\u0d07\u0d28\u0d4d\u0d28\u0d32\u0d46] LT",lastWeek:"[\u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d",past:"%s \u0d2e\u0d41\u0d7b\u0d2a\u0d4d",s:"\u0d05\u0d7d\u0d2a \u0d28\u0d3f\u0d2e\u0d3f\u0d37\u0d19\u0d4d\u0d19\u0d7e",ss:"%d \u0d38\u0d46\u0d15\u0d4d\u0d15\u0d7b\u0d21\u0d4d",m:"\u0d12\u0d30\u0d41 \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",mm:"%d \u0d2e\u0d3f\u0d28\u0d3f\u0d31\u0d4d\u0d31\u0d4d",h:"\u0d12\u0d30\u0d41 \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",hh:"%d \u0d2e\u0d23\u0d3f\u0d15\u0d4d\u0d15\u0d42\u0d7c",d:"\u0d12\u0d30\u0d41 \u0d26\u0d3f\u0d35\u0d38\u0d02",dd:"%d \u0d26\u0d3f\u0d35\u0d38\u0d02",M:"\u0d12\u0d30\u0d41 \u0d2e\u0d3e\u0d38\u0d02",MM:"%d \u0d2e\u0d3e\u0d38\u0d02",y:"\u0d12\u0d30\u0d41 \u0d35\u0d7c\u0d37\u0d02",yy:"%d \u0d35\u0d7c\u0d37\u0d02"},meridiemParse:/\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f|\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46|\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d|\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02|\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f/i,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"===a&&4<=e||"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d"===a||"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02"===a?e+12:e},meridiem:function(e,a,t){return e<4?"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f":e<12?"\u0d30\u0d3e\u0d35\u0d3f\u0d32\u0d46":e<17?"\u0d09\u0d1a\u0d4d\u0d1a \u0d15\u0d34\u0d3f\u0d1e\u0d4d\u0d1e\u0d4d":e<20?"\u0d35\u0d48\u0d15\u0d41\u0d28\u0d4d\u0d28\u0d47\u0d30\u0d02":"\u0d30\u0d3e\u0d24\u0d4d\u0d30\u0d3f"}}),l.defineLocale("mn",{months:"\u041d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0425\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0413\u0443\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u04e9\u0440\u04e9\u0432\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0422\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0417\u0443\u0440\u0433\u0430\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0414\u043e\u043b\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u041d\u0430\u0439\u043c\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0415\u0441\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0430\u0432\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u043d\u044d\u0433\u0434\u04af\u0433\u044d\u044d\u0440 \u0441\u0430\u0440_\u0410\u0440\u0432\u0430\u043d \u0445\u043e\u0451\u0440\u0434\u0443\u0433\u0430\u0430\u0440 \u0441\u0430\u0440".split("_"),monthsShort:"1 \u0441\u0430\u0440_2 \u0441\u0430\u0440_3 \u0441\u0430\u0440_4 \u0441\u0430\u0440_5 \u0441\u0430\u0440_6 \u0441\u0430\u0440_7 \u0441\u0430\u0440_8 \u0441\u0430\u0440_9 \u0441\u0430\u0440_10 \u0441\u0430\u0440_11 \u0441\u0430\u0440_12 \u0441\u0430\u0440".split("_"),monthsParseExact:!0,weekdays:"\u041d\u044f\u043c_\u0414\u0430\u0432\u0430\u0430_\u041c\u044f\u0433\u043c\u0430\u0440_\u041b\u0445\u0430\u0433\u0432\u0430_\u041f\u04af\u0440\u044d\u0432_\u0411\u0430\u0430\u0441\u0430\u043d_\u0411\u044f\u043c\u0431\u0430".split("_"),weekdaysShort:"\u041d\u044f\u043c_\u0414\u0430\u0432_\u041c\u044f\u0433_\u041b\u0445\u0430_\u041f\u04af\u0440_\u0411\u0430\u0430_\u0411\u044f\u043c".split("_"),weekdaysMin:"\u041d\u044f_\u0414\u0430_\u041c\u044f_\u041b\u0445_\u041f\u04af_\u0411\u0430_\u0411\u044f".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D",LLL:"YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm",LLLL:"dddd, YYYY \u043e\u043d\u044b MMMM\u044b\u043d D HH:mm"},meridiemParse:/\u04ae\u04e8|\u04ae\u0425/i,isPM:function(e){return"\u04ae\u0425"===e},meridiem:function(e,a,t){return e<12?"\u04ae\u04e8":"\u04ae\u0425"},calendar:{sameDay:"[\u04e8\u043d\u04e9\u04e9\u0434\u04e9\u0440] LT",nextDay:"[\u041c\u0430\u0440\u0433\u0430\u0430\u0448] LT",nextWeek:"[\u0418\u0440\u044d\u0445] dddd LT",lastDay:"[\u04e8\u0447\u0438\u0433\u0434\u04e9\u0440] LT",lastWeek:"[\u04e8\u043d\u0433\u04e9\u0440\u0441\u04e9\u043d] dddd LT",sameElse:"L"},relativeTime:{future:"%s \u0434\u0430\u0440\u0430\u0430",past:"%s \u04e9\u043c\u043d\u04e9",s:ln,ss:ln,m:ln,mm:ln,h:ln,hh:ln,d:ln,dd:ln,M:ln,MM:ln,y:ln,yy:ln},dayOfMonthOrdinalParse:/\d{1,2} \u04e9\u0434\u04e9\u0440/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+" \u04e9\u0434\u04e9\u0440";default:return e}}});var Mn={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},hn={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};function Ln(e,a,t,s){var n="";if(a)switch(t){case"s":n="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926";break;case"ss":n="%d \u0938\u0947\u0915\u0902\u0926";break;case"m":n="\u090f\u0915 \u092e\u093f\u0928\u093f\u091f";break;case"mm":n="%d \u092e\u093f\u0928\u093f\u091f\u0947";break;case"h":n="\u090f\u0915 \u0924\u093e\u0938";break;case"hh":n="%d \u0924\u093e\u0938";break;case"d":n="\u090f\u0915 \u0926\u093f\u0935\u0938";break;case"dd":n="%d \u0926\u093f\u0935\u0938";break;case"M":n="\u090f\u0915 \u092e\u0939\u093f\u0928\u093e";break;case"MM":n="%d \u092e\u0939\u093f\u0928\u0947";break;case"y":n="\u090f\u0915 \u0935\u0930\u094d\u0937";break;case"yy":n="%d \u0935\u0930\u094d\u0937\u0947";break}else switch(t){case"s":n="\u0915\u093e\u0939\u0940 \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"ss":n="%d \u0938\u0947\u0915\u0902\u0926\u093e\u0902";break;case"m":n="\u090f\u0915\u093e \u092e\u093f\u0928\u093f\u091f\u093e";break;case"mm":n="%d \u092e\u093f\u0928\u093f\u091f\u093e\u0902";break;case"h":n="\u090f\u0915\u093e \u0924\u093e\u0938\u093e";break;case"hh":n="%d \u0924\u093e\u0938\u093e\u0902";break;case"d":n="\u090f\u0915\u093e \u0926\u093f\u0935\u0938\u093e";break;case"dd":n="%d \u0926\u093f\u0935\u0938\u093e\u0902";break;case"M":n="\u090f\u0915\u093e \u092e\u0939\u093f\u0928\u094d\u092f\u093e";break;case"MM":n="%d \u092e\u0939\u093f\u0928\u094d\u092f\u093e\u0902";break;case"y":n="\u090f\u0915\u093e \u0935\u0930\u094d\u0937\u093e";break;case"yy":n="%d \u0935\u0930\u094d\u0937\u093e\u0902";break}return n.replace(/%d/i,e)}l.defineLocale("mr",{months:"\u091c\u093e\u0928\u0947\u0935\u093e\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u093e\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u090f\u092a\u094d\u0930\u093f\u0932_\u092e\u0947_\u091c\u0942\u0928_\u091c\u0941\u0932\u0948_\u0911\u0917\u0938\u094d\u091f_\u0938\u092a\u094d\u091f\u0947\u0902\u092c\u0930_\u0911\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u0935\u094d\u0939\u0947\u0902\u092c\u0930_\u0921\u093f\u0938\u0947\u0902\u092c\u0930".split("_"),monthsShort:"\u091c\u093e\u0928\u0947._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a._\u090f\u092a\u094d\u0930\u093f._\u092e\u0947._\u091c\u0942\u0928._\u091c\u0941\u0932\u0948._\u0911\u0917._\u0938\u092a\u094d\u091f\u0947\u0902._\u0911\u0915\u094d\u091f\u094b._\u0928\u094b\u0935\u094d\u0939\u0947\u0902._\u0921\u093f\u0938\u0947\u0902.".split("_"),monthsParseExact:!0,weekdays:"\u0930\u0935\u093f\u0935\u093e\u0930_\u0938\u094b\u092e\u0935\u093e\u0930_\u092e\u0902\u0917\u0933\u0935\u093e\u0930_\u092c\u0941\u0927\u0935\u093e\u0930_\u0917\u0941\u0930\u0942\u0935\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u0935\u093e\u0930_\u0936\u0928\u093f\u0935\u093e\u0930".split("_"),weekdaysShort:"\u0930\u0935\u093f_\u0938\u094b\u092e_\u092e\u0902\u0917\u0933_\u092c\u0941\u0927_\u0917\u0941\u0930\u0942_\u0936\u0941\u0915\u094d\u0930_\u0936\u0928\u093f".split("_"),weekdaysMin:"\u0930_\u0938\u094b_\u092e\u0902_\u092c\u0941_\u0917\u0941_\u0936\u0941_\u0936".split("_"),longDateFormat:{LT:"A h:mm \u0935\u093e\u091c\u0924\u093e",LTS:"A h:mm:ss \u0935\u093e\u091c\u0924\u093e",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e",LLLL:"dddd, D MMMM YYYY, A h:mm \u0935\u093e\u091c\u0924\u093e"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u0909\u0926\u094d\u092f\u093e] LT",nextWeek:"dddd, LT",lastDay:"[\u0915\u093e\u0932] LT",lastWeek:"[\u092e\u093e\u0917\u0940\u0932] dddd, LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u0927\u094d\u092f\u0947",past:"%s\u092a\u0942\u0930\u094d\u0935\u0940",s:Ln,ss:Ln,m:Ln,mm:Ln,h:Ln,hh:Ln,d:Ln,dd:Ln,M:Ln,MM:Ln,y:Ln,yy:Ln},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return hn[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Mn[e]})},meridiemParse:/\u0930\u093e\u0924\u094d\u0930\u0940|\u0938\u0915\u093e\u0933\u0940|\u0926\u0941\u092a\u093e\u0930\u0940|\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u094d\u0930\u0940"===a?e<4?e:e+12:"\u0938\u0915\u093e\u0933\u0940"===a?e:"\u0926\u0941\u092a\u093e\u0930\u0940"===a?10<=e?e:e+12:"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0930\u093e\u0924\u094d\u0930\u0940":e<10?"\u0938\u0915\u093e\u0933\u0940":e<17?"\u0926\u0941\u092a\u093e\u0930\u0940":e<20?"\u0938\u093e\u092f\u0902\u0915\u093e\u0933\u0940":"\u0930\u093e\u0924\u094d\u0930\u0940"},week:{dow:0,doy:6}}),l.defineLocale("ms-my",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,t){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),l.defineLocale("ms",{months:"Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),weekdays:"Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),weekdaysShort:"Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),weekdaysMin:"Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [pukul] HH.mm",LLLL:"dddd, D MMMM YYYY [pukul] HH.mm"},meridiemParse:/pagi|tengahari|petang|malam/,meridiemHour:function(e,a){return 12===e&&(e=0),"pagi"===a?e:"tengahari"===a?11<=e?e:e+12:"petang"===a||"malam"===a?e+12:void 0},meridiem:function(e,a,t){return e<11?"pagi":e<15?"tengahari":e<19?"petang":"malam"},calendar:{sameDay:"[Hari ini pukul] LT",nextDay:"[Esok pukul] LT",nextWeek:"dddd [pukul] LT",lastDay:"[Kelmarin pukul] LT",lastWeek:"dddd [lepas pukul] LT",sameElse:"L"},relativeTime:{future:"dalam %s",past:"%s yang lepas",s:"beberapa saat",ss:"%d saat",m:"seminit",mm:"%d minit",h:"sejam",hh:"%d jam",d:"sehari",dd:"%d hari",M:"sebulan",MM:"%d bulan",y:"setahun",yy:"%d tahun"},week:{dow:1,doy:7}}),l.defineLocale("mt",{months:"Jannar_Frar_Marzu_April_Mejju_\u0120unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Di\u010bembru".split("_"),monthsShort:"Jan_Fra_Mar_Apr_Mej_\u0120un_Lul_Aww_Set_Ott_Nov_Di\u010b".split("_"),weekdays:"Il-\u0126add_It-Tnejn_It-Tlieta_L-Erbg\u0127a_Il-\u0126amis_Il-\u0120img\u0127a_Is-Sibt".split("_"),weekdaysShort:"\u0126ad_Tne_Tli_Erb_\u0126am_\u0120im_Sib".split("_"),weekdaysMin:"\u0126a_Tn_Tl_Er_\u0126a_\u0120i_Si".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Illum fil-]LT",nextDay:"[G\u0127ada fil-]LT",nextWeek:"dddd [fil-]LT",lastDay:"[Il-biera\u0127 fil-]LT",lastWeek:"dddd [li g\u0127adda] [fil-]LT",sameElse:"L"},relativeTime:{future:"f\u2019 %s",past:"%s ilu",s:"ftit sekondi",ss:"%d sekondi",m:"minuta",mm:"%d minuti",h:"sieg\u0127a",hh:"%d sieg\u0127at",d:"\u0121urnata",dd:"%d \u0121ranet",M:"xahar",MM:"%d xhur",y:"sena",yy:"%d sni"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}});var cn={1:"\u1041",2:"\u1042",3:"\u1043",4:"\u1044",5:"\u1045",6:"\u1046",7:"\u1047",8:"\u1048",9:"\u1049",0:"\u1040"},Yn={"\u1041":"1","\u1042":"2","\u1043":"3","\u1044":"4","\u1045":"5","\u1046":"6","\u1047":"7","\u1048":"8","\u1049":"9","\u1040":"0"};l.defineLocale("my",{months:"\u1007\u1014\u103a\u1014\u101d\u102b\u101b\u102e_\u1016\u1031\u1016\u1031\u102c\u103a\u101d\u102b\u101b\u102e_\u1019\u1010\u103a_\u1027\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u1007\u1030\u101c\u102d\u102f\u1004\u103a_\u101e\u103c\u1002\u102f\u1010\u103a_\u1005\u1000\u103a\u1010\u1004\u103a\u1018\u102c_\u1021\u1031\u102c\u1000\u103a\u1010\u102d\u102f\u1018\u102c_\u1014\u102d\u102f\u101d\u1004\u103a\u1018\u102c_\u1012\u102e\u1007\u1004\u103a\u1018\u102c".split("_"),monthsShort:"\u1007\u1014\u103a_\u1016\u1031_\u1019\u1010\u103a_\u1015\u103c\u102e_\u1019\u1031_\u1007\u103d\u1014\u103a_\u101c\u102d\u102f\u1004\u103a_\u101e\u103c_\u1005\u1000\u103a_\u1021\u1031\u102c\u1000\u103a_\u1014\u102d\u102f_\u1012\u102e".split("_"),weekdays:"\u1010\u1014\u1004\u103a\u1039\u1002\u1014\u103d\u1031_\u1010\u1014\u1004\u103a\u1039\u101c\u102c_\u1021\u1004\u103a\u1039\u1002\u102b_\u1017\u102f\u1012\u1039\u1013\u101f\u1030\u1038_\u1000\u103c\u102c\u101e\u1015\u1010\u1031\u1038_\u101e\u1031\u102c\u1000\u103c\u102c_\u1005\u1014\u1031".split("_"),weekdaysShort:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),weekdaysMin:"\u1014\u103d\u1031_\u101c\u102c_\u1002\u102b_\u101f\u1030\u1038_\u1000\u103c\u102c_\u101e\u1031\u102c_\u1014\u1031".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u101a\u1014\u1031.] LT [\u1019\u103e\u102c]",nextDay:"[\u1019\u1014\u1000\u103a\u1016\u103c\u1014\u103a] LT [\u1019\u103e\u102c]",nextWeek:"dddd LT [\u1019\u103e\u102c]",lastDay:"[\u1019\u1014\u1031.\u1000] LT [\u1019\u103e\u102c]",lastWeek:"[\u1015\u103c\u102e\u1038\u1001\u1032\u1037\u101e\u1031\u102c] dddd LT [\u1019\u103e\u102c]",sameElse:"L"},relativeTime:{future:"\u101c\u102c\u1019\u100a\u103a\u1037 %s \u1019\u103e\u102c",past:"\u101c\u103d\u1014\u103a\u1001\u1032\u1037\u101e\u1031\u102c %s \u1000",s:"\u1005\u1000\u1039\u1000\u1014\u103a.\u1021\u1014\u100a\u103a\u1038\u1004\u101a\u103a",ss:"%d \u1005\u1000\u1039\u1000\u1014\u1037\u103a",m:"\u1010\u1005\u103a\u1019\u102d\u1014\u1005\u103a",mm:"%d \u1019\u102d\u1014\u1005\u103a",h:"\u1010\u1005\u103a\u1014\u102c\u101b\u102e",hh:"%d \u1014\u102c\u101b\u102e",d:"\u1010\u1005\u103a\u101b\u1000\u103a",dd:"%d \u101b\u1000\u103a",M:"\u1010\u1005\u103a\u101c",MM:"%d \u101c",y:"\u1010\u1005\u103a\u1014\u103e\u1005\u103a",yy:"%d \u1014\u103e\u1005\u103a"},preparse:function(e){return e.replace(/[\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049\u1040]/g,function(e){return Yn[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return cn[e]})},week:{dow:1,doy:4}}),l.defineLocale("nb",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.".split("_"),monthsParseExact:!0,weekdays:"s\xf8ndag_mandag_tirsdag_onsdag_torsdag_fredag_l\xf8rdag".split("_"),weekdaysShort:"s\xf8._ma._ti._on._to._fr._l\xf8.".split("_"),weekdaysMin:"s\xf8_ma_ti_on_to_fr_l\xf8".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] HH:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"dddd [kl.] LT",lastDay:"[i g\xe5r kl.] LT",lastWeek:"[forrige] dddd [kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"noen sekunder",ss:"%d sekunder",m:"ett minutt",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dager",M:"en m\xe5ned",MM:"%d m\xe5neder",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var yn={1:"\u0967",2:"\u0968",3:"\u0969",4:"\u096a",5:"\u096b",6:"\u096c",7:"\u096d",8:"\u096e",9:"\u096f",0:"\u0966"},fn={"\u0967":"1","\u0968":"2","\u0969":"3","\u096a":"4","\u096b":"5","\u096c":"6","\u096d":"7","\u096e":"8","\u096f":"9","\u0966":"0"};l.defineLocale("ne",{months:"\u091c\u0928\u0935\u0930\u0940_\u092b\u0947\u092c\u094d\u0930\u0941\u0935\u0930\u0940_\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f\u0932_\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908_\u0905\u0917\u0937\u094d\u091f_\u0938\u0947\u092a\u094d\u091f\u0947\u092e\u094d\u092c\u0930_\u0905\u0915\u094d\u091f\u094b\u092c\u0930_\u0928\u094b\u092d\u0947\u092e\u094d\u092c\u0930_\u0921\u093f\u0938\u0947\u092e\u094d\u092c\u0930".split("_"),monthsShort:"\u091c\u0928._\u092b\u0947\u092c\u094d\u0930\u0941._\u092e\u093e\u0930\u094d\u091a_\u0905\u092a\u094d\u0930\u093f._\u092e\u0908_\u091c\u0941\u0928_\u091c\u0941\u0932\u093e\u0908._\u0905\u0917._\u0938\u0947\u092a\u094d\u091f._\u0905\u0915\u094d\u091f\u094b._\u0928\u094b\u092d\u0947._\u0921\u093f\u0938\u0947.".split("_"),monthsParseExact:!0,weekdays:"\u0906\u0907\u0924\u092c\u093e\u0930_\u0938\u094b\u092e\u092c\u093e\u0930_\u092e\u0919\u094d\u0917\u0932\u092c\u093e\u0930_\u092c\u0941\u0927\u092c\u093e\u0930_\u092c\u093f\u0939\u093f\u092c\u093e\u0930_\u0936\u0941\u0915\u094d\u0930\u092c\u093e\u0930_\u0936\u0928\u093f\u092c\u093e\u0930".split("_"),weekdaysShort:"\u0906\u0907\u0924._\u0938\u094b\u092e._\u092e\u0919\u094d\u0917\u0932._\u092c\u0941\u0927._\u092c\u093f\u0939\u093f._\u0936\u0941\u0915\u094d\u0930._\u0936\u0928\u093f.".split("_"),weekdaysMin:"\u0906._\u0938\u094b._\u092e\u0902._\u092c\u0941._\u092c\u093f._\u0936\u0941._\u0936.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"A\u0915\u094b h:mm \u092c\u091c\u0947",LTS:"A\u0915\u094b h:mm:ss \u092c\u091c\u0947",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947",LLLL:"dddd, D MMMM YYYY, A\u0915\u094b h:mm \u092c\u091c\u0947"},preparse:function(e){return e.replace(/[\u0967\u0968\u0969\u096a\u096b\u096c\u096d\u096e\u096f\u0966]/g,function(e){return fn[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return yn[e]})},meridiemParse:/\u0930\u093e\u0924\u093f|\u092c\u093f\u0939\u093e\u0928|\u0926\u093f\u0909\u0901\u0938\u094b|\u0938\u093e\u0901\u091d/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0930\u093e\u0924\u093f"===a?e<4?e:e+12:"\u092c\u093f\u0939\u093e\u0928"===a?e:"\u0926\u093f\u0909\u0901\u0938\u094b"===a?10<=e?e:e+12:"\u0938\u093e\u0901\u091d"===a?e+12:void 0},meridiem:function(e,a,t){return e<3?"\u0930\u093e\u0924\u093f":e<12?"\u092c\u093f\u0939\u093e\u0928":e<16?"\u0926\u093f\u0909\u0901\u0938\u094b":e<20?"\u0938\u093e\u0901\u091d":"\u0930\u093e\u0924\u093f"},calendar:{sameDay:"[\u0906\u091c] LT",nextDay:"[\u092d\u094b\u0932\u093f] LT",nextWeek:"[\u0906\u0909\u0901\u0926\u094b] dddd[,] LT",lastDay:"[\u0939\u093f\u091c\u094b] LT",lastWeek:"[\u0917\u090f\u0915\u094b] dddd[,] LT",sameElse:"L"},relativeTime:{future:"%s\u092e\u093e",past:"%s \u0905\u0917\u093e\u0921\u093f",s:"\u0915\u0947\u0939\u0940 \u0915\u094d\u0937\u0923",ss:"%d \u0938\u0947\u0915\u0947\u0923\u094d\u0921",m:"\u090f\u0915 \u092e\u093f\u0928\u0947\u091f",mm:"%d \u092e\u093f\u0928\u0947\u091f",h:"\u090f\u0915 \u0918\u0923\u094d\u091f\u093e",hh:"%d \u0918\u0923\u094d\u091f\u093e",d:"\u090f\u0915 \u0926\u093f\u0928",dd:"%d \u0926\u093f\u0928",M:"\u090f\u0915 \u092e\u0939\u093f\u0928\u093e",MM:"%d \u092e\u0939\u093f\u0928\u093e",y:"\u090f\u0915 \u092c\u0930\u094d\u0937",yy:"%d \u092c\u0930\u094d\u0937"},week:{dow:0,doy:6}});var kn="jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),pn="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),Dn=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],Tn=/^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;l.defineLocale("nl-be",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?pn[e.month()]:kn[e.month()]:kn},monthsRegex:Tn,monthsShortRegex:Tn,monthsStrictRegex:/^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:Dn,longMonthsParse:Dn,shortMonthsParse:Dn,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}});var gn="jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),wn="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),vn=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],Sn=/^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;l.defineLocale("nl",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,a){return e?/-MMM-/.test(a)?wn[e.month()]:gn[e.month()]:gn},monthsRegex:Sn,monthsShortRegex:Sn,monthsStrictRegex:/^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:vn,longMonthsParse:vn,shortMonthsParse:vn,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"\xe9\xe9n minuut",mm:"%d minuten",h:"\xe9\xe9n uur",hh:"%d uur",d:"\xe9\xe9n dag",dd:"%d dagen",M:"\xe9\xe9n maand",MM:"%d maanden",y:"\xe9\xe9n jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||20<=e?"ste":"de")},week:{dow:1,doy:4}}),l.defineLocale("nn",{months:"januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),monthsShort:"jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),weekdays:"sundag_m\xe5ndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),weekdaysShort:"sun_m\xe5n_tys_ons_tor_fre_lau".split("_"),weekdaysMin:"su_m\xe5_ty_on_to_fr_l\xf8".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY [kl.] H:mm",LLLL:"dddd D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[I dag klokka] LT",nextDay:"[I morgon klokka] LT",nextWeek:"dddd [klokka] LT",lastDay:"[I g\xe5r klokka] LT",lastWeek:"[F\xf8reg\xe5ande] dddd [klokka] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s sidan",s:"nokre sekund",ss:"%d sekund",m:"eit minutt",mm:"%d minutt",h:"ein time",hh:"%d timar",d:"ein dag",dd:"%d dagar",M:"ein m\xe5nad",MM:"%d m\xe5nader",y:"eit \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var Hn={1:"\u0a67",2:"\u0a68",3:"\u0a69",4:"\u0a6a",5:"\u0a6b",6:"\u0a6c",7:"\u0a6d",8:"\u0a6e",9:"\u0a6f",0:"\u0a66"},bn={"\u0a67":"1","\u0a68":"2","\u0a69":"3","\u0a6a":"4","\u0a6b":"5","\u0a6c":"6","\u0a6d":"7","\u0a6e":"8","\u0a6f":"9","\u0a66":"0"};l.defineLocale("pa-in",{months:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),monthsShort:"\u0a1c\u0a28\u0a35\u0a30\u0a40_\u0a2b\u0a3c\u0a30\u0a35\u0a30\u0a40_\u0a2e\u0a3e\u0a30\u0a1a_\u0a05\u0a2a\u0a4d\u0a30\u0a48\u0a32_\u0a2e\u0a08_\u0a1c\u0a42\u0a28_\u0a1c\u0a41\u0a32\u0a3e\u0a08_\u0a05\u0a17\u0a38\u0a24_\u0a38\u0a24\u0a70\u0a2c\u0a30_\u0a05\u0a15\u0a24\u0a42\u0a2c\u0a30_\u0a28\u0a35\u0a70\u0a2c\u0a30_\u0a26\u0a38\u0a70\u0a2c\u0a30".split("_"),weekdays:"\u0a10\u0a24\u0a35\u0a3e\u0a30_\u0a38\u0a4b\u0a2e\u0a35\u0a3e\u0a30_\u0a2e\u0a70\u0a17\u0a32\u0a35\u0a3e\u0a30_\u0a2c\u0a41\u0a27\u0a35\u0a3e\u0a30_\u0a35\u0a40\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a41\u0a71\u0a15\u0a30\u0a35\u0a3e\u0a30_\u0a38\u0a3c\u0a28\u0a40\u0a1a\u0a30\u0a35\u0a3e\u0a30".split("_"),weekdaysShort:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),weekdaysMin:"\u0a10\u0a24_\u0a38\u0a4b\u0a2e_\u0a2e\u0a70\u0a17\u0a32_\u0a2c\u0a41\u0a27_\u0a35\u0a40\u0a30_\u0a38\u0a3c\u0a41\u0a15\u0a30_\u0a38\u0a3c\u0a28\u0a40".split("_"),longDateFormat:{LT:"A h:mm \u0a35\u0a1c\u0a47",LTS:"A h:mm:ss \u0a35\u0a1c\u0a47",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47",LLLL:"dddd, D MMMM YYYY, A h:mm \u0a35\u0a1c\u0a47"},calendar:{sameDay:"[\u0a05\u0a1c] LT",nextDay:"[\u0a15\u0a32] LT",nextWeek:"[\u0a05\u0a17\u0a32\u0a3e] dddd, LT",lastDay:"[\u0a15\u0a32] LT",lastWeek:"[\u0a2a\u0a3f\u0a1b\u0a32\u0a47] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0a35\u0a3f\u0a71\u0a1a",past:"%s \u0a2a\u0a3f\u0a1b\u0a32\u0a47",s:"\u0a15\u0a41\u0a1d \u0a38\u0a15\u0a3f\u0a70\u0a1f",ss:"%d \u0a38\u0a15\u0a3f\u0a70\u0a1f",m:"\u0a07\u0a15 \u0a2e\u0a3f\u0a70\u0a1f",mm:"%d \u0a2e\u0a3f\u0a70\u0a1f",h:"\u0a07\u0a71\u0a15 \u0a18\u0a70\u0a1f\u0a3e",hh:"%d \u0a18\u0a70\u0a1f\u0a47",d:"\u0a07\u0a71\u0a15 \u0a26\u0a3f\u0a28",dd:"%d \u0a26\u0a3f\u0a28",M:"\u0a07\u0a71\u0a15 \u0a2e\u0a39\u0a40\u0a28\u0a3e",MM:"%d \u0a2e\u0a39\u0a40\u0a28\u0a47",y:"\u0a07\u0a71\u0a15 \u0a38\u0a3e\u0a32",yy:"%d \u0a38\u0a3e\u0a32"},preparse:function(e){return e.replace(/[\u0a67\u0a68\u0a69\u0a6a\u0a6b\u0a6c\u0a6d\u0a6e\u0a6f\u0a66]/g,function(e){return bn[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Hn[e]})},meridiemParse:/\u0a30\u0a3e\u0a24|\u0a38\u0a35\u0a47\u0a30|\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30|\u0a38\u0a3c\u0a3e\u0a2e/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0a30\u0a3e\u0a24"===a?e<4?e:e+12:"\u0a38\u0a35\u0a47\u0a30"===a?e:"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30"===a?10<=e?e:e+12:"\u0a38\u0a3c\u0a3e\u0a2e"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0a30\u0a3e\u0a24":e<10?"\u0a38\u0a35\u0a47\u0a30":e<17?"\u0a26\u0a41\u0a2a\u0a39\u0a3f\u0a30":e<20?"\u0a38\u0a3c\u0a3e\u0a2e":"\u0a30\u0a3e\u0a24"},week:{dow:0,doy:6}});var jn="stycze\u0144_luty_marzec_kwiecie\u0144_maj_czerwiec_lipiec_sierpie\u0144_wrzesie\u0144_pa\u017adziernik_listopad_grudzie\u0144".split("_"),xn="stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze\u015bnia_pa\u017adziernika_listopada_grudnia".split("_");function Pn(e){return e%10<5&&1<e%10&&~~(e/10)%10!=1}function On(e,a,t){var s=e+" ";switch(t){case"ss":return s+(Pn(e)?"sekundy":"sekund");case"m":return a?"minuta":"minut\u0119";case"mm":return s+(Pn(e)?"minuty":"minut");case"h":return a?"godzina":"godzin\u0119";case"hh":return s+(Pn(e)?"godziny":"godzin");case"MM":return s+(Pn(e)?"miesi\u0105ce":"miesi\u0119cy");case"yy":return s+(Pn(e)?"lata":"lat")}}function Wn(e,a,t){var s=" ";return(20<=e%100||100<=e&&e%100==0)&&(s=" de "),e+s+{ss:"secunde",mm:"minute",hh:"ore",dd:"zile",MM:"luni",yy:"ani"}[t]}function En(e,a,t){var s,n;return"m"===t?a?"\u043c\u0438\u043d\u0443\u0442\u0430":"\u043c\u0438\u043d\u0443\u0442\u0443":e+" "+(s=+e,n={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u044b_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u043c\u0438\u043d\u0443\u0442\u0430_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442":"\u043c\u0438\u043d\u0443\u0442\u0443_\u043c\u0438\u043d\u0443\u0442\u044b_\u043c\u0438\u043d\u0443\u0442",hh:"\u0447\u0430\u0441_\u0447\u0430\u0441\u0430_\u0447\u0430\u0441\u043e\u0432",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u044f_\u0434\u043d\u0435\u0439",MM:"\u043c\u0435\u0441\u044f\u0446_\u043c\u0435\u0441\u044f\u0446\u0430_\u043c\u0435\u0441\u044f\u0446\u0435\u0432",yy:"\u0433\u043e\u0434_\u0433\u043e\u0434\u0430_\u043b\u0435\u0442"}[t].split("_"),s%10==1&&s%100!=11?n[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?n[1]:n[2])}l.defineLocale("pl",{months:function(e,a){return e?""===a?"("+xn[e.month()]+"|"+jn[e.month()]+")":/D MMMM/.test(a)?xn[e.month()]:jn[e.month()]:jn},monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa\u017a_lis_gru".split("_"),weekdays:"niedziela_poniedzia\u0142ek_wtorek_\u015broda_czwartek_pi\u0105tek_sobota".split("_"),weekdaysShort:"ndz_pon_wt_\u015br_czw_pt_sob".split("_"),weekdaysMin:"Nd_Pn_Wt_\u015ar_Cz_Pt_So".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Dzi\u015b o] LT",nextDay:"[Jutro o] LT",nextWeek:function(){switch(this.day()){case 0:return"[W niedziel\u0119 o] LT";case 2:return"[We wtorek o] LT";case 3:return"[W \u015brod\u0119 o] LT";case 6:return"[W sobot\u0119 o] LT";default:return"[W] dddd [o] LT"}},lastDay:"[Wczoraj o] LT",lastWeek:function(){switch(this.day()){case 0:return"[W zesz\u0142\u0105 niedziel\u0119 o] LT";case 3:return"[W zesz\u0142\u0105 \u015brod\u0119 o] LT";case 6:return"[W zesz\u0142\u0105 sobot\u0119 o] LT";default:return"[W zesz\u0142y] dddd [o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"%s temu",s:"kilka sekund",ss:On,m:On,mm:On,h:On,hh:On,d:"1 dzie\u0144",dd:"%d dni",M:"miesi\u0105c",MM:On,y:"rok",yy:On},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("pt-br",{months:"janeiro_fevereiro_mar\xe7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"Domingo_Segunda-feira_Ter\xe7a-feira_Quarta-feira_Quinta-feira_Sexta-feira_S\xe1bado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_S\xe1b".split("_"),weekdaysMin:"Do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [\xe0s] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [\xe0s] HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"poucos segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba"}),l.defineLocale("pt",{months:"janeiro_fevereiro_mar\xe7o_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"Domingo_Segunda-feira_Ter\xe7a-feira_Quarta-feira_Quinta-feira_Sexta-feira_S\xe1bado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_S\xe1b".split("_"),weekdaysMin:"Do_2\xaa_3\xaa_4\xaa_5\xaa_6\xaa_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY HH:mm"},calendar:{sameDay:"[Hoje \xe0s] LT",nextDay:"[Amanh\xe3 \xe0s] LT",nextWeek:"dddd [\xe0s] LT",lastDay:"[Ontem \xe0s] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[\xdaltimo] dddd [\xe0s] LT":"[\xdaltima] dddd [\xe0s] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"h\xe1 %s",s:"segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um m\xeas",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}\xba/,ordinal:"%d\xba",week:{dow:1,doy:4}}),l.defineLocale("ro",{months:"ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),monthsShort:"ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"duminic\u0103_luni_mar\u021bi_miercuri_joi_vineri_s\xe2mb\u0103t\u0103".split("_"),weekdaysShort:"Dum_Lun_Mar_Mie_Joi_Vin_S\xe2m".split("_"),weekdaysMin:"Du_Lu_Ma_Mi_Jo_Vi_S\xe2".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[azi la] LT",nextDay:"[m\xe2ine la] LT",nextWeek:"dddd [la] LT",lastDay:"[ieri la] LT",lastWeek:"[fosta] dddd [la] LT",sameElse:"L"},relativeTime:{future:"peste %s",past:"%s \xeen urm\u0103",s:"c\xe2teva secunde",ss:Wn,m:"un minut",mm:Wn,h:"o or\u0103",hh:Wn,d:"o zi",dd:Wn,M:"o lun\u0103",MM:Wn,y:"un an",yy:Wn},week:{dow:1,doy:7}});var An=[/^\u044f\u043d\u0432/i,/^\u0444\u0435\u0432/i,/^\u043c\u0430\u0440/i,/^\u0430\u043f\u0440/i,/^\u043c\u0430[\u0439\u044f]/i,/^\u0438\u044e\u043d/i,/^\u0438\u044e\u043b/i,/^\u0430\u0432\u0433/i,/^\u0441\u0435\u043d/i,/^\u043e\u043a\u0442/i,/^\u043d\u043e\u044f/i,/^\u0434\u0435\u043a/i];l.defineLocale("ru",{months:{format:"\u044f\u043d\u0432\u0430\u0440\u044f_\u0444\u0435\u0432\u0440\u0430\u043b\u044f_\u043c\u0430\u0440\u0442\u0430_\u0430\u043f\u0440\u0435\u043b\u044f_\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433\u0443\u0441\u0442\u0430_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044f_\u043e\u043a\u0442\u044f\u0431\u0440\u044f_\u043d\u043e\u044f\u0431\u0440\u044f_\u0434\u0435\u043a\u0430\u0431\u0440\u044f".split("_"),standalone:"\u044f\u043d\u0432\u0430\u0440\u044c_\u0444\u0435\u0432\u0440\u0430\u043b\u044c_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b\u044c_\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044c_\u043e\u043a\u0442\u044f\u0431\u0440\u044c_\u043d\u043e\u044f\u0431\u0440\u044c_\u0434\u0435\u043a\u0430\u0431\u0440\u044c".split("_")},monthsShort:{format:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u044f_\u0438\u044e\u043d\u044f_\u0438\u044e\u043b\u044f_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_"),standalone:"\u044f\u043d\u0432._\u0444\u0435\u0432\u0440._\u043c\u0430\u0440\u0442_\u0430\u043f\u0440._\u043c\u0430\u0439_\u0438\u044e\u043d\u044c_\u0438\u044e\u043b\u044c_\u0430\u0432\u0433._\u0441\u0435\u043d\u0442._\u043e\u043a\u0442._\u043d\u043e\u044f\u0431._\u0434\u0435\u043a.".split("_")},weekdays:{standalone:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0430_\u0441\u0443\u0431\u0431\u043e\u0442\u0430".split("_"),format:"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435_\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a_\u0432\u0442\u043e\u0440\u043d\u0438\u043a_\u0441\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440\u0433_\u043f\u044f\u0442\u043d\u0438\u0446\u0443_\u0441\u0443\u0431\u0431\u043e\u0442\u0443".split("_"),isFormat:/\[ ?[\u0412\u0432] ?(?:\u043f\u0440\u043e\u0448\u043b\u0443\u044e|\u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e|\u044d\u0442\u0443)? ?\] ?dddd/},weekdaysShort:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u0432\u0441_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),monthsParse:An,longMonthsParse:An,shortMonthsParse:An,monthsRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsShortRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044c\u044f]|\u044f\u043d\u0432\.?|\u0444\u0435\u0432\u0440\u0430\u043b[\u044c\u044f]|\u0444\u0435\u0432\u0440?\.?|\u043c\u0430\u0440\u0442\u0430?|\u043c\u0430\u0440\.?|\u0430\u043f\u0440\u0435\u043b[\u044c\u044f]|\u0430\u043f\u0440\.?|\u043c\u0430[\u0439\u044f]|\u0438\u044e\u043d[\u044c\u044f]|\u0438\u044e\u043d\.?|\u0438\u044e\u043b[\u044c\u044f]|\u0438\u044e\u043b\.?|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0430\u0432\u0433\.?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044c\u044f]|\u0441\u0435\u043d\u0442?\.?|\u043e\u043a\u0442\u044f\u0431\u0440[\u044c\u044f]|\u043e\u043a\u0442\.?|\u043d\u043e\u044f\u0431\u0440[\u044c\u044f]|\u043d\u043e\u044f\u0431?\.?|\u0434\u0435\u043a\u0430\u0431\u0440[\u044c\u044f]|\u0434\u0435\u043a\.?)/i,monthsStrictRegex:/^(\u044f\u043d\u0432\u0430\u0440[\u044f\u044c]|\u0444\u0435\u0432\u0440\u0430\u043b[\u044f\u044c]|\u043c\u0430\u0440\u0442\u0430?|\u0430\u043f\u0440\u0435\u043b[\u044f\u044c]|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044f\u044c]|\u0438\u044e\u043b[\u044f\u044c]|\u0430\u0432\u0433\u0443\u0441\u0442\u0430?|\u0441\u0435\u043d\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043e\u043a\u0442\u044f\u0431\u0440[\u044f\u044c]|\u043d\u043e\u044f\u0431\u0440[\u044f\u044c]|\u0434\u0435\u043a\u0430\u0431\u0440[\u044f\u044c])/i,monthsShortStrictRegex:/^(\u044f\u043d\u0432\.|\u0444\u0435\u0432\u0440?\.|\u043c\u0430\u0440[\u0442.]|\u0430\u043f\u0440\.|\u043c\u0430[\u044f\u0439]|\u0438\u044e\u043d[\u044c\u044f.]|\u0438\u044e\u043b[\u044c\u044f.]|\u0430\u0432\u0433\.|\u0441\u0435\u043d\u0442?\.|\u043e\u043a\u0442\.|\u043d\u043e\u044f\u0431?\.|\u0434\u0435\u043a\.)/i,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0433.",LLL:"D MMMM YYYY \u0433., H:mm",LLLL:"dddd, D MMMM YYYY \u0433., H:mm"},calendar:{sameDay:"[\u0421\u0435\u0433\u043e\u0434\u043d\u044f, \u0432] LT",nextDay:"[\u0417\u0430\u0432\u0442\u0440\u0430, \u0432] LT",lastDay:"[\u0412\u0447\u0435\u0440\u0430, \u0432] LT",nextWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return"[\u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e] dddd, [\u0432] LT"}},lastWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[\u0412\u043e] dddd, [\u0432] LT":"[\u0412] dddd, [\u0432] LT";switch(this.day()){case 0:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u043e\u0435] dddd, [\u0432] LT";case 1:case 2:case 4:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u044b\u0439] dddd, [\u0432] LT";case 3:case 5:case 6:return"[\u0412 \u043f\u0440\u043e\u0448\u043b\u0443\u044e] dddd, [\u0432] LT"}},sameElse:"L"},relativeTime:{future:"\u0447\u0435\u0440\u0435\u0437 %s",past:"%s \u043d\u0430\u0437\u0430\u0434",s:"\u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434",ss:En,m:En,mm:En,h:"\u0447\u0430\u0441",hh:En,d:"\u0434\u0435\u043d\u044c",dd:En,M:"\u043c\u0435\u0441\u044f\u0446",MM:En,y:"\u0433\u043e\u0434",yy:En},meridiemParse:/\u043d\u043e\u0447\u0438|\u0443\u0442\u0440\u0430|\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430/i,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u0435\u0440\u0430)$/.test(e)},meridiem:function(e,a,t){return e<4?"\u043d\u043e\u0447\u0438":e<12?"\u0443\u0442\u0440\u0430":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u0435\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e|\u044f)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":return e+"-\u0439";case"D":return e+"-\u0433\u043e";case"w":case"W":return e+"-\u044f";default:return e}},week:{dow:1,doy:4}});var Fn=["\u062c\u0646\u0648\u0631\u064a","\u0641\u064a\u0628\u0631\u0648\u0631\u064a","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u064a\u0644","\u0645\u0626\u064a","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0621\u0650","\u0622\u06af\u0633\u067d","\u0633\u064a\u067e\u067d\u0645\u0628\u0631","\u0622\u06aa\u067d\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u068a\u0633\u0645\u0628\u0631"],zn=["\u0622\u0686\u0631","\u0633\u0648\u0645\u0631","\u0627\u06b1\u0627\u0631\u0648","\u0627\u0631\u0628\u0639","\u062e\u0645\u064a\u0633","\u062c\u0645\u0639","\u0687\u0646\u0687\u0631"];l.defineLocale("sd",{months:Fn,monthsShort:Fn,weekdays:zn,weekdaysShort:zn,weekdaysMin:zn,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return"\u0634\u0627\u0645"===e},meridiem:function(e,a,t){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0627\u0684] LT",nextDay:"[\u0633\u0680\u0627\u06bb\u064a] LT",nextWeek:"dddd [\u0627\u06b3\u064a\u0646 \u0647\u0641\u062a\u064a \u062a\u064a] LT",lastDay:"[\u06aa\u0627\u0644\u0647\u0647] LT",lastWeek:"[\u06af\u0632\u0631\u064a\u0644 \u0647\u0641\u062a\u064a] dddd [\u062a\u064a] LT",sameElse:"L"},relativeTime:{future:"%s \u067e\u0648\u0621",past:"%s \u0627\u06b3",s:"\u0686\u0646\u062f \u0633\u064a\u06aa\u0646\u068a",ss:"%d \u0633\u064a\u06aa\u0646\u068a",m:"\u0647\u06aa \u0645\u0646\u067d",mm:"%d \u0645\u0646\u067d",h:"\u0647\u06aa \u06aa\u0644\u0627\u06aa",hh:"%d \u06aa\u0644\u0627\u06aa",d:"\u0647\u06aa \u068f\u064a\u0646\u0647\u0646",dd:"%d \u068f\u064a\u0646\u0647\u0646",M:"\u0647\u06aa \u0645\u0647\u064a\u0646\u0648",MM:"%d \u0645\u0647\u064a\u0646\u0627",y:"\u0647\u06aa \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),l.defineLocale("se",{months:"o\u0111\u0111ajagem\xe1nnu_guovvam\xe1nnu_njuk\u010dam\xe1nnu_cuo\u014bom\xe1nnu_miessem\xe1nnu_geassem\xe1nnu_suoidnem\xe1nnu_borgem\xe1nnu_\u010dak\u010dam\xe1nnu_golggotm\xe1nnu_sk\xe1bmam\xe1nnu_juovlam\xe1nnu".split("_"),monthsShort:"o\u0111\u0111j_guov_njuk_cuo_mies_geas_suoi_borg_\u010dak\u010d_golg_sk\xe1b_juov".split("_"),weekdays:"sotnabeaivi_vuoss\xe1rga_ma\u014b\u014beb\xe1rga_gaskavahkku_duorastat_bearjadat_l\xe1vvardat".split("_"),weekdaysShort:"sotn_vuos_ma\u014b_gask_duor_bear_l\xe1v".split("_"),weekdaysMin:"s_v_m_g_d_b_L".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"MMMM D. [b.] YYYY",LLL:"MMMM D. [b.] YYYY [ti.] HH:mm",LLLL:"dddd, MMMM D. [b.] YYYY [ti.] HH:mm"},calendar:{sameDay:"[otne ti] LT",nextDay:"[ihttin ti] LT",nextWeek:"dddd [ti] LT",lastDay:"[ikte ti] LT",lastWeek:"[ovddit] dddd [ti] LT",sameElse:"L"},relativeTime:{future:"%s gea\u017ees",past:"ma\u014bit %s",s:"moadde sekunddat",ss:"%d sekunddat",m:"okta minuhta",mm:"%d minuhtat",h:"okta diimmu",hh:"%d diimmut",d:"okta beaivi",dd:"%d beaivvit",M:"okta m\xe1nnu",MM:"%d m\xe1nut",y:"okta jahki",yy:"%d jagit"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("si",{months:"\u0da2\u0db1\u0dc0\u0dcf\u0dbb\u0dd2_\u0db4\u0dd9\u0db6\u0dbb\u0dc0\u0dcf\u0dbb\u0dd2_\u0db8\u0dcf\u0dbb\u0dca\u0dad\u0dd4_\u0d85\u0db4\u0dca\u200d\u0dbb\u0dda\u0dbd\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd\u0dc3\u0dca\u0dad\u0dd4_\u0dc3\u0dd0\u0db4\u0dca\u0dad\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0d94\u0d9a\u0dca\u0dad\u0ddd\u0db6\u0dbb\u0dca_\u0db1\u0ddc\u0dc0\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca_\u0daf\u0dd9\u0dc3\u0dd0\u0db8\u0dca\u0db6\u0dbb\u0dca".split("_"),monthsShort:"\u0da2\u0db1_\u0db4\u0dd9\u0db6_\u0db8\u0dcf\u0dbb\u0dca_\u0d85\u0db4\u0dca_\u0db8\u0dd0\u0dba\u0dd2_\u0da2\u0dd6\u0db1\u0dd2_\u0da2\u0dd6\u0dbd\u0dd2_\u0d85\u0d9c\u0ddd_\u0dc3\u0dd0\u0db4\u0dca_\u0d94\u0d9a\u0dca_\u0db1\u0ddc\u0dc0\u0dd0_\u0daf\u0dd9\u0dc3\u0dd0".split("_"),weekdays:"\u0d89\u0dbb\u0dd2\u0daf\u0dcf_\u0dc3\u0db3\u0dd4\u0daf\u0dcf_\u0d85\u0d9f\u0dc4\u0dbb\u0dd4\u0dc0\u0dcf\u0daf\u0dcf_\u0db6\u0daf\u0dcf\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4\u0dc3\u0dca\u0db4\u0dad\u0dd2\u0db1\u0dca\u0daf\u0dcf_\u0dc3\u0dd2\u0d9a\u0dd4\u0dbb\u0dcf\u0daf\u0dcf_\u0dc3\u0dd9\u0db1\u0dc3\u0dd4\u0dbb\u0dcf\u0daf\u0dcf".split("_"),weekdaysShort:"\u0d89\u0dbb\u0dd2_\u0dc3\u0db3\u0dd4_\u0d85\u0d9f_\u0db6\u0daf\u0dcf_\u0db6\u0dca\u200d\u0dbb\u0dc4_\u0dc3\u0dd2\u0d9a\u0dd4_\u0dc3\u0dd9\u0db1".split("_"),weekdaysMin:"\u0d89_\u0dc3_\u0d85_\u0db6_\u0db6\u0dca\u200d\u0dbb_\u0dc3\u0dd2_\u0dc3\u0dd9".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"a h:mm",LTS:"a h:mm:ss",L:"YYYY/MM/DD",LL:"YYYY MMMM D",LLL:"YYYY MMMM D, a h:mm",LLLL:"YYYY MMMM D [\u0dc0\u0dd0\u0db1\u0dd2] dddd, a h:mm:ss"},calendar:{sameDay:"[\u0d85\u0daf] LT[\u0da7]",nextDay:"[\u0dc4\u0dd9\u0da7] LT[\u0da7]",nextWeek:"dddd LT[\u0da7]",lastDay:"[\u0d8a\u0dba\u0dda] LT[\u0da7]",lastWeek:"[\u0db4\u0dc3\u0dd4\u0d9c\u0dd2\u0dba] dddd LT[\u0da7]",sameElse:"L"},relativeTime:{future:"%s\u0d9a\u0dd2\u0db1\u0dca",past:"%s\u0d9a\u0da7 \u0db4\u0dd9\u0dbb",s:"\u0dad\u0dad\u0dca\u0db4\u0dbb \u0d9a\u0dd2\u0dc4\u0dd2\u0db4\u0dba",ss:"\u0dad\u0dad\u0dca\u0db4\u0dbb %d",m:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4\u0dc0",mm:"\u0db8\u0dd2\u0db1\u0dd2\u0dad\u0dca\u0dad\u0dd4 %d",h:"\u0db4\u0dd0\u0dba",hh:"\u0db4\u0dd0\u0dba %d",d:"\u0daf\u0dd2\u0db1\u0dba",dd:"\u0daf\u0dd2\u0db1 %d",M:"\u0db8\u0dcf\u0dc3\u0dba",MM:"\u0db8\u0dcf\u0dc3 %d",y:"\u0dc0\u0dc3\u0dbb",yy:"\u0dc0\u0dc3\u0dbb %d"},dayOfMonthOrdinalParse:/\d{1,2} \u0dc0\u0dd0\u0db1\u0dd2/,ordinal:function(e){return e+" \u0dc0\u0dd0\u0db1\u0dd2"},meridiemParse:/\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4|\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4|\u0db4\u0dd9.\u0dc0|\u0db4.\u0dc0./,isPM:function(e){return"\u0db4.\u0dc0."===e||"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4"===e},meridiem:function(e,a,t){return 11<e?t?"\u0db4.\u0dc0.":"\u0db4\u0dc3\u0dca \u0dc0\u0dbb\u0dd4":t?"\u0db4\u0dd9.\u0dc0.":"\u0db4\u0dd9\u0dbb \u0dc0\u0dbb\u0dd4"}});var Jn="janu\xe1r_febru\xe1r_marec_apr\xedl_m\xe1j_j\xfan_j\xfal_august_september_okt\xf3ber_november_december".split("_"),Nn="jan_feb_mar_apr_m\xe1j_j\xfan_j\xfal_aug_sep_okt_nov_dec".split("_");function Rn(e){return 1<e&&e<5}function In(e,a,t,s){var n=e+" ";switch(t){case"s":return a||s?"p\xe1r sek\xfand":"p\xe1r sekundami";case"ss":return a||s?n+(Rn(e)?"sekundy":"sek\xfand"):n+"sekundami";break;case"m":return a?"min\xfata":s?"min\xfatu":"min\xfatou";case"mm":return a||s?n+(Rn(e)?"min\xfaty":"min\xfat"):n+"min\xfatami";break;case"h":return a?"hodina":s?"hodinu":"hodinou";case"hh":return a||s?n+(Rn(e)?"hodiny":"hod\xedn"):n+"hodinami";break;case"d":return a||s?"de\u0148":"d\u0148om";case"dd":return a||s?n+(Rn(e)?"dni":"dn\xed"):n+"d\u0148ami";break;case"M":return a||s?"mesiac":"mesiacom";case"MM":return a||s?n+(Rn(e)?"mesiace":"mesiacov"):n+"mesiacmi";break;case"y":return a||s?"rok":"rokom";case"yy":return a||s?n+(Rn(e)?"roky":"rokov"):n+"rokmi";break}}function Cn(e,a,t,s){var n=e+" ";switch(t){case"s":return a||s?"nekaj sekund":"nekaj sekundami";case"ss":return n+=1===e?a?"sekundo":"sekundi":2===e?a||s?"sekundi":"sekundah":e<5?a||s?"sekunde":"sekundah":"sekund";case"m":return a?"ena minuta":"eno minuto";case"mm":return n+=1===e?a?"minuta":"minuto":2===e?a||s?"minuti":"minutama":e<5?a||s?"minute":"minutami":a||s?"minut":"minutami";case"h":return a?"ena ura":"eno uro";case"hh":return n+=1===e?a?"ura":"uro":2===e?a||s?"uri":"urama":e<5?a||s?"ure":"urami":a||s?"ur":"urami";case"d":return a||s?"en dan":"enim dnem";case"dd":return n+=1===e?a||s?"dan":"dnem":2===e?a||s?"dni":"dnevoma":a||s?"dni":"dnevi";case"M":return a||s?"en mesec":"enim mesecem";case"MM":return n+=1===e?a||s?"mesec":"mesecem":2===e?a||s?"meseca":"mesecema":e<5?a||s?"mesece":"meseci":a||s?"mesecev":"meseci";case"y":return a||s?"eno leto":"enim letom";case"yy":return n+=1===e?a||s?"leto":"letom":2===e?a||s?"leti":"letoma":e<5?a||s?"leta":"leti":a||s?"let":"leti"}}l.defineLocale("sk",{months:Jn,monthsShort:Nn,weekdays:"nede\u013ea_pondelok_utorok_streda_\u0161tvrtok_piatok_sobota".split("_"),weekdaysShort:"ne_po_ut_st_\u0161t_pi_so".split("_"),weekdaysMin:"ne_po_ut_st_\u0161t_pi_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm"},calendar:{sameDay:"[dnes o] LT",nextDay:"[zajtra o] LT",nextWeek:function(){switch(this.day()){case 0:return"[v nede\u013eu o] LT";case 1:case 2:return"[v] dddd [o] LT";case 3:return"[v stredu o] LT";case 4:return"[vo \u0161tvrtok o] LT";case 5:return"[v piatok o] LT";case 6:return"[v sobotu o] LT"}},lastDay:"[v\u010dera o] LT",lastWeek:function(){switch(this.day()){case 0:return"[minul\xfa nede\u013eu o] LT";case 1:case 2:return"[minul\xfd] dddd [o] LT";case 3:return"[minul\xfa stredu o] LT";case 4:case 5:return"[minul\xfd] dddd [o] LT";case 6:return"[minul\xfa sobotu o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"pred %s",s:In,ss:In,m:In,mm:In,h:In,hh:In,d:In,dd:In,M:In,MM:In,y:In,yy:In},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("sl",{months:"januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),monthsShort:"jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljek_torek_sreda_\u010detrtek_petek_sobota".split("_"),weekdaysShort:"ned._pon._tor._sre._\u010det._pet._sob.".split("_"),weekdaysMin:"ne_po_to_sr_\u010de_pe_so".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danes ob] LT",nextDay:"[jutri ob] LT",nextWeek:function(){switch(this.day()){case 0:return"[v] [nedeljo] [ob] LT";case 3:return"[v] [sredo] [ob] LT";case 6:return"[v] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return"[v] dddd [ob] LT"}},lastDay:"[v\u010deraj ob] LT",lastWeek:function(){switch(this.day()){case 0:return"[prej\u0161njo] [nedeljo] [ob] LT";case 3:return"[prej\u0161njo] [sredo] [ob] LT";case 6:return"[prej\u0161njo] [soboto] [ob] LT";case 1:case 2:case 4:case 5:return"[prej\u0161nji] dddd [ob] LT"}},sameElse:"L"},relativeTime:{future:"\u010dez %s",past:"pred %s",s:Cn,ss:Cn,m:Cn,mm:Cn,h:Cn,hh:Cn,d:Cn,dd:Cn,M:Cn,MM:Cn,y:Cn,yy:Cn},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),l.defineLocale("sq",{months:"Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_N\xebntor_Dhjetor".split("_"),monthsShort:"Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_N\xebn_Dhj".split("_"),weekdays:"E Diel_E H\xebn\xeb_E Mart\xeb_E M\xebrkur\xeb_E Enjte_E Premte_E Shtun\xeb".split("_"),weekdaysShort:"Die_H\xebn_Mar_M\xebr_Enj_Pre_Sht".split("_"),weekdaysMin:"D_H_Ma_M\xeb_E_P_Sh".split("_"),weekdaysParseExact:!0,meridiemParse:/PD|MD/,isPM:function(e){return"M"===e.charAt(0)},meridiem:function(e,a,t){return e<12?"PD":"MD"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Sot n\xeb] LT",nextDay:"[Nes\xebr n\xeb] LT",nextWeek:"dddd [n\xeb] LT",lastDay:"[Dje n\xeb] LT",lastWeek:"dddd [e kaluar n\xeb] LT",sameElse:"L"},relativeTime:{future:"n\xeb %s",past:"%s m\xeb par\xeb",s:"disa sekonda",ss:"%d sekonda",m:"nj\xeb minut\xeb",mm:"%d minuta",h:"nj\xeb or\xeb",hh:"%d or\xeb",d:"nj\xeb dit\xeb",dd:"%d dit\xeb",M:"nj\xeb muaj",MM:"%d muaj",y:"nj\xeb vit",yy:"%d vite"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var Gn={words:{ss:["\u0441\u0435\u043a\u0443\u043d\u0434\u0430","\u0441\u0435\u043a\u0443\u043d\u0434\u0435","\u0441\u0435\u043a\u0443\u043d\u0434\u0438"],m:["\u0458\u0435\u0434\u0430\u043d \u043c\u0438\u043d\u0443\u0442","\u0458\u0435\u0434\u043d\u0435 \u043c\u0438\u043d\u0443\u0442\u0435"],mm:["\u043c\u0438\u043d\u0443\u0442","\u043c\u0438\u043d\u0443\u0442\u0435","\u043c\u0438\u043d\u0443\u0442\u0430"],h:["\u0458\u0435\u0434\u0430\u043d \u0441\u0430\u0442","\u0458\u0435\u0434\u043d\u043e\u0433 \u0441\u0430\u0442\u0430"],hh:["\u0441\u0430\u0442","\u0441\u0430\u0442\u0430","\u0441\u0430\u0442\u0438"],dd:["\u0434\u0430\u043d","\u0434\u0430\u043d\u0430","\u0434\u0430\u043d\u0430"],MM:["\u043c\u0435\u0441\u0435\u0446","\u043c\u0435\u0441\u0435\u0446\u0430","\u043c\u0435\u0441\u0435\u0446\u0438"],yy:["\u0433\u043e\u0434\u0438\u043d\u0430","\u0433\u043e\u0434\u0438\u043d\u0435","\u0433\u043e\u0434\u0438\u043d\u0430"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,t){var s=Gn.words[t];return 1===t.length?a?s[0]:s[1]:e+" "+Gn.correctGrammaticalCase(e,s)}};l.defineLocale("sr-cyrl",{months:"\u0458\u0430\u043d\u0443\u0430\u0440_\u0444\u0435\u0431\u0440\u0443\u0430\u0440_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0438\u043b_\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043f\u0442\u0435\u043c\u0431\u0430\u0440_\u043e\u043a\u0442\u043e\u0431\u0430\u0440_\u043d\u043e\u0432\u0435\u043c\u0431\u0430\u0440_\u0434\u0435\u0446\u0435\u043c\u0431\u0430\u0440".split("_"),monthsShort:"\u0458\u0430\u043d._\u0444\u0435\u0431._\u043c\u0430\u0440._\u0430\u043f\u0440._\u043c\u0430\u0458_\u0458\u0443\u043d_\u0458\u0443\u043b_\u0430\u0432\u0433._\u0441\u0435\u043f._\u043e\u043a\u0442._\u043d\u043e\u0432._\u0434\u0435\u0446.".split("_"),monthsParseExact:!0,weekdays:"\u043d\u0435\u0434\u0435\u0459\u0430_\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u0430\u043a_\u0443\u0442\u043e\u0440\u0430\u043a_\u0441\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0440\u0442\u0430\u043a_\u043f\u0435\u0442\u0430\u043a_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),weekdaysShort:"\u043d\u0435\u0434._\u043f\u043e\u043d._\u0443\u0442\u043e._\u0441\u0440\u0435._\u0447\u0435\u0442._\u043f\u0435\u0442._\u0441\u0443\u0431.".split("_"),weekdaysMin:"\u043d\u0435_\u043f\u043e_\u0443\u0442_\u0441\u0440_\u0447\u0435_\u043f\u0435_\u0441\u0443".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[\u0434\u0430\u043d\u0430\u0441 \u0443] LT",nextDay:"[\u0441\u0443\u0442\u0440\u0430 \u0443] LT",nextWeek:function(){switch(this.day()){case 0:return"[\u0443] [\u043d\u0435\u0434\u0435\u0459\u0443] [\u0443] LT";case 3:return"[\u0443] [\u0441\u0440\u0435\u0434\u0443] [\u0443] LT";case 6:return"[\u0443] [\u0441\u0443\u0431\u043e\u0442\u0443] [\u0443] LT";case 1:case 2:case 4:case 5:return"[\u0443] dddd [\u0443] LT"}},lastDay:"[\u0458\u0443\u0447\u0435 \u0443] LT",lastWeek:function(){return["[\u043f\u0440\u043e\u0448\u043b\u0435] [\u043d\u0435\u0434\u0435\u0459\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u043e\u043d\u0435\u0434\u0435\u0459\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0443\u0442\u043e\u0440\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0440\u0435\u0434\u0435] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u0447\u0435\u0442\u0432\u0440\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u043e\u0433] [\u043f\u0435\u0442\u043a\u0430] [\u0443] LT","[\u043f\u0440\u043e\u0448\u043b\u0435] [\u0441\u0443\u0431\u043e\u0442\u0435] [\u0443] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"\u043f\u0440\u0435 %s",s:"\u043d\u0435\u043a\u043e\u043b\u0438\u043a\u043e \u0441\u0435\u043a\u0443\u043d\u0434\u0438",ss:Gn.translate,m:Gn.translate,mm:Gn.translate,h:Gn.translate,hh:Gn.translate,d:"\u0434\u0430\u043d",dd:Gn.translate,M:"\u043c\u0435\u0441\u0435\u0446",MM:Gn.translate,y:"\u0433\u043e\u0434\u0438\u043d\u0443",yy:Gn.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}});var Un={words:{ss:["sekunda","sekunde","sekundi"],m:["jedan minut","jedne minute"],mm:["minut","minute","minuta"],h:["jedan sat","jednog sata"],hh:["sat","sata","sati"],dd:["dan","dana","dana"],MM:["mesec","meseca","meseci"],yy:["godina","godine","godina"]},correctGrammaticalCase:function(e,a){return 1===e?a[0]:2<=e&&e<=4?a[1]:a[2]},translate:function(e,a,t){var s=Un.words[t];return 1===t.length?a?s[0]:s[1]:e+" "+Un.correctGrammaticalCase(e,s)}};l.defineLocale("sr",{months:"januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),monthsShort:"jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"nedelja_ponedeljak_utorak_sreda_\u010detvrtak_petak_subota".split("_"),weekdaysShort:"ned._pon._uto._sre._\u010det._pet._sub.".split("_"),weekdaysMin:"ne_po_ut_sr_\u010de_pe_su".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd, D. MMMM YYYY H:mm"},calendar:{sameDay:"[danas u] LT",nextDay:"[sutra u] LT",nextWeek:function(){switch(this.day()){case 0:return"[u] [nedelju] [u] LT";case 3:return"[u] [sredu] [u] LT";case 6:return"[u] [subotu] [u] LT";case 1:case 2:case 4:case 5:return"[u] dddd [u] LT"}},lastDay:"[ju\u010de u] LT",lastWeek:function(){return["[pro\u0161le] [nedelje] [u] LT","[pro\u0161log] [ponedeljka] [u] LT","[pro\u0161log] [utorka] [u] LT","[pro\u0161le] [srede] [u] LT","[pro\u0161log] [\u010detvrtka] [u] LT","[pro\u0161log] [petka] [u] LT","[pro\u0161le] [subote] [u] LT"][this.day()]},sameElse:"L"},relativeTime:{future:"za %s",past:"pre %s",s:"nekoliko sekundi",ss:Un.translate,m:Un.translate,mm:Un.translate,h:Un.translate,hh:Un.translate,d:"dan",dd:Un.translate,M:"mesec",MM:Un.translate,y:"godinu",yy:Un.translate},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}}),l.defineLocale("ss",{months:"Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),monthsShort:"Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),weekdays:"Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),weekdaysShort:"Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),weekdaysMin:"Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[Namuhla nga] LT",nextDay:"[Kusasa nga] LT",nextWeek:"dddd [nga] LT",lastDay:"[Itolo nga] LT",lastWeek:"dddd [leliphelile] [nga] LT",sameElse:"L"},relativeTime:{future:"nga %s",past:"wenteka nga %s",s:"emizuzwana lomcane",ss:"%d mzuzwana",m:"umzuzu",mm:"%d emizuzu",h:"lihora",hh:"%d emahora",d:"lilanga",dd:"%d emalanga",M:"inyanga",MM:"%d tinyanga",y:"umnyaka",yy:"%d iminyaka"},meridiemParse:/ekuseni|emini|entsambama|ebusuku/,meridiem:function(e,a,t){return e<11?"ekuseni":e<15?"emini":e<19?"entsambama":"ebusuku"},meridiemHour:function(e,a){return 12===e&&(e=0),"ekuseni"===a?e:"emini"===a?11<=e?e:e+12:"entsambama"===a||"ebusuku"===a?0===e?0:e+12:void 0},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:"%d",week:{dow:1,doy:4}}),l.defineLocale("sv",{months:"januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"s\xf6ndag_m\xe5ndag_tisdag_onsdag_torsdag_fredag_l\xf6rdag".split("_"),weekdaysShort:"s\xf6n_m\xe5n_tis_ons_tor_fre_l\xf6r".split("_"),weekdaysMin:"s\xf6_m\xe5_ti_on_to_fr_l\xf6".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [kl.] HH:mm",LLLL:"dddd D MMMM YYYY [kl.] HH:mm",lll:"D MMM YYYY HH:mm",llll:"ddd D MMM YYYY HH:mm"},calendar:{sameDay:"[Idag] LT",nextDay:"[Imorgon] LT",lastDay:"[Ig\xe5r] LT",nextWeek:"[P\xe5] dddd LT",lastWeek:"[I] dddd[s] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"f\xf6r %s sedan",s:"n\xe5gra sekunder",ss:"%d sekunder",m:"en minut",mm:"%d minuter",h:"en timme",hh:"%d timmar",d:"en dag",dd:"%d dagar",M:"en m\xe5nad",MM:"%d m\xe5nader",y:"ett \xe5r",yy:"%d \xe5r"},dayOfMonthOrdinalParse:/\d{1,2}(e|a)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"e":1===a?"a":2===a?"a":"e")},week:{dow:1,doy:4}}),l.defineLocale("sw",{months:"Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),monthsShort:"Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),weekdays:"Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),weekdaysShort:"Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),weekdaysMin:"J2_J3_J4_J5_Al_Ij_J1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[leo saa] LT",nextDay:"[kesho saa] LT",nextWeek:"[wiki ijayo] dddd [saat] LT",lastDay:"[jana] LT",lastWeek:"[wiki iliyopita] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s baadaye",past:"tokea %s",s:"hivi punde",ss:"sekunde %d",m:"dakika moja",mm:"dakika %d",h:"saa limoja",hh:"masaa %d",d:"siku moja",dd:"masiku %d",M:"mwezi mmoja",MM:"miezi %d",y:"mwaka mmoja",yy:"miaka %d"},week:{dow:1,doy:7}});var Vn={1:"\u0be7",2:"\u0be8",3:"\u0be9",4:"\u0bea",5:"\u0beb",6:"\u0bec",7:"\u0bed",8:"\u0bee",9:"\u0bef",0:"\u0be6"},Kn={"\u0be7":"1","\u0be8":"2","\u0be9":"3","\u0bea":"4","\u0beb":"5","\u0bec":"6","\u0bed":"7","\u0bee":"8","\u0bef":"9","\u0be6":"0"};l.defineLocale("ta",{months:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),monthsShort:"\u0b9c\u0ba9\u0bb5\u0bb0\u0bbf_\u0baa\u0bbf\u0baa\u0bcd\u0bb0\u0bb5\u0bb0\u0bbf_\u0bae\u0bbe\u0bb0\u0bcd\u0b9a\u0bcd_\u0b8f\u0baa\u0bcd\u0bb0\u0bb2\u0bcd_\u0bae\u0bc7_\u0b9c\u0bc2\u0ba9\u0bcd_\u0b9c\u0bc2\u0bb2\u0bc8_\u0b86\u0b95\u0bb8\u0bcd\u0b9f\u0bcd_\u0b9a\u0bc6\u0baa\u0bcd\u0b9f\u0bc6\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b85\u0b95\u0bcd\u0b9f\u0bc7\u0bbe\u0baa\u0bb0\u0bcd_\u0ba8\u0bb5\u0bae\u0bcd\u0baa\u0bb0\u0bcd_\u0b9f\u0bbf\u0b9a\u0bae\u0bcd\u0baa\u0bb0\u0bcd".split("_"),weekdays:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bcd\u0bb1\u0bc1\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0b9f\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8_\u0b9a\u0ba9\u0bbf\u0b95\u0bcd\u0b95\u0bbf\u0bb4\u0bae\u0bc8".split("_"),weekdaysShort:"\u0b9e\u0bbe\u0baf\u0bbf\u0bb1\u0bc1_\u0ba4\u0bbf\u0b99\u0bcd\u0b95\u0bb3\u0bcd_\u0b9a\u0bc6\u0bb5\u0bcd\u0bb5\u0bbe\u0baf\u0bcd_\u0baa\u0bc1\u0ba4\u0ba9\u0bcd_\u0bb5\u0bbf\u0baf\u0bbe\u0bb4\u0ba9\u0bcd_\u0bb5\u0bc6\u0bb3\u0bcd\u0bb3\u0bbf_\u0b9a\u0ba9\u0bbf".split("_"),weekdaysMin:"\u0b9e\u0bbe_\u0ba4\u0bbf_\u0b9a\u0bc6_\u0baa\u0bc1_\u0bb5\u0bbf_\u0bb5\u0bc6_\u0b9a".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, HH:mm",LLLL:"dddd, D MMMM YYYY, HH:mm"},calendar:{sameDay:"[\u0b87\u0ba9\u0bcd\u0bb1\u0bc1] LT",nextDay:"[\u0ba8\u0bbe\u0bb3\u0bc8] LT",nextWeek:"dddd, LT",lastDay:"[\u0ba8\u0bc7\u0bb1\u0bcd\u0bb1\u0bc1] LT",lastWeek:"[\u0b95\u0b9f\u0ba8\u0bcd\u0ba4 \u0bb5\u0bbe\u0bb0\u0bae\u0bcd] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0b87\u0bb2\u0bcd",past:"%s \u0bae\u0bc1\u0ba9\u0bcd",s:"\u0b92\u0bb0\u0bc1 \u0b9a\u0bbf\u0bb2 \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",ss:"%d \u0bb5\u0bbf\u0ba8\u0bbe\u0b9f\u0bbf\u0b95\u0bb3\u0bcd",m:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0bae\u0bcd",mm:"%d \u0ba8\u0bbf\u0bae\u0bbf\u0b9f\u0b99\u0bcd\u0b95\u0bb3\u0bcd",h:"\u0b92\u0bb0\u0bc1 \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",hh:"%d \u0bae\u0ba3\u0bbf \u0ba8\u0bc7\u0bb0\u0bae\u0bcd",d:"\u0b92\u0bb0\u0bc1 \u0ba8\u0bbe\u0bb3\u0bcd",dd:"%d \u0ba8\u0bbe\u0b9f\u0bcd\u0b95\u0bb3\u0bcd",M:"\u0b92\u0bb0\u0bc1 \u0bae\u0bbe\u0ba4\u0bae\u0bcd",MM:"%d \u0bae\u0bbe\u0ba4\u0b99\u0bcd\u0b95\u0bb3\u0bcd",y:"\u0b92\u0bb0\u0bc1 \u0bb5\u0bb0\u0bc1\u0b9f\u0bae\u0bcd",yy:"%d \u0b86\u0ba3\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd"},dayOfMonthOrdinalParse:/\d{1,2}\u0bb5\u0ba4\u0bc1/,ordinal:function(e){return e+"\u0bb5\u0ba4\u0bc1"},preparse:function(e){return e.replace(/[\u0be7\u0be8\u0be9\u0bea\u0beb\u0bec\u0bed\u0bee\u0bef\u0be6]/g,function(e){return Kn[e]})},postformat:function(e){return e.replace(/\d/g,function(e){return Vn[e]})},meridiemParse:/\u0baf\u0bbe\u0bae\u0bae\u0bcd|\u0bb5\u0bc8\u0b95\u0bb1\u0bc8|\u0b95\u0bbe\u0bb2\u0bc8|\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd|\u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1|\u0bae\u0bbe\u0bb2\u0bc8/,meridiem:function(e,a,t){return e<2?" \u0baf\u0bbe\u0bae\u0bae\u0bcd":e<6?" \u0bb5\u0bc8\u0b95\u0bb1\u0bc8":e<10?" \u0b95\u0bbe\u0bb2\u0bc8":e<14?" \u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd":e<18?" \u0b8e\u0bb1\u0bcd\u0baa\u0bbe\u0b9f\u0bc1":e<22?" \u0bae\u0bbe\u0bb2\u0bc8":" \u0baf\u0bbe\u0bae\u0bae\u0bcd"},meridiemHour:function(e,a){return 12===e&&(e=0),"\u0baf\u0bbe\u0bae\u0bae\u0bcd"===a?e<2?e:e+12:"\u0bb5\u0bc8\u0b95\u0bb1\u0bc8"===a||"\u0b95\u0bbe\u0bb2\u0bc8"===a?e:"\u0ba8\u0ba3\u0bcd\u0baa\u0b95\u0bb2\u0bcd"===a&&10<=e?e:e+12},week:{dow:0,doy:6}}),l.defineLocale("te",{months:"\u0c1c\u0c28\u0c35\u0c30\u0c3f_\u0c2b\u0c3f\u0c2c\u0c4d\u0c30\u0c35\u0c30\u0c3f_\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f\u0c32\u0c4d_\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c42\u0c32\u0c46\u0c56_\u0c06\u0c17\u0c38\u0c4d\u0c1f\u0c41_\u0c38\u0c46\u0c2a\u0c4d\u0c1f\u0c46\u0c02\u0c2c\u0c30\u0c4d_\u0c05\u0c15\u0c4d\u0c1f\u0c4b\u0c2c\u0c30\u0c4d_\u0c28\u0c35\u0c02\u0c2c\u0c30\u0c4d_\u0c21\u0c3f\u0c38\u0c46\u0c02\u0c2c\u0c30\u0c4d".split("_"),monthsShort:"\u0c1c\u0c28._\u0c2b\u0c3f\u0c2c\u0c4d\u0c30._\u0c2e\u0c3e\u0c30\u0c4d\u0c1a\u0c3f_\u0c0f\u0c2a\u0c4d\u0c30\u0c3f._\u0c2e\u0c47_\u0c1c\u0c42\u0c28\u0c4d_\u0c1c\u0c42\u0c32\u0c46\u0c56_\u0c06\u0c17._\u0c38\u0c46\u0c2a\u0c4d._\u0c05\u0c15\u0c4d\u0c1f\u0c4b._\u0c28\u0c35._\u0c21\u0c3f\u0c38\u0c46.".split("_"),monthsParseExact:!0,weekdays:"\u0c06\u0c26\u0c3f\u0c35\u0c3e\u0c30\u0c02_\u0c38\u0c4b\u0c2e\u0c35\u0c3e\u0c30\u0c02_\u0c2e\u0c02\u0c17\u0c33\u0c35\u0c3e\u0c30\u0c02_\u0c2c\u0c41\u0c27\u0c35\u0c3e\u0c30\u0c02_\u0c17\u0c41\u0c30\u0c41\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c41\u0c15\u0c4d\u0c30\u0c35\u0c3e\u0c30\u0c02_\u0c36\u0c28\u0c3f\u0c35\u0c3e\u0c30\u0c02".split("_"),weekdaysShort:"\u0c06\u0c26\u0c3f_\u0c38\u0c4b\u0c2e_\u0c2e\u0c02\u0c17\u0c33_\u0c2c\u0c41\u0c27_\u0c17\u0c41\u0c30\u0c41_\u0c36\u0c41\u0c15\u0c4d\u0c30_\u0c36\u0c28\u0c3f".split("_"),weekdaysMin:"\u0c06_\u0c38\u0c4b_\u0c2e\u0c02_\u0c2c\u0c41_\u0c17\u0c41_\u0c36\u0c41_\u0c36".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY, A h:mm",LLLL:"dddd, D MMMM YYYY, A h:mm"},calendar:{sameDay:"[\u0c28\u0c47\u0c21\u0c41] LT",nextDay:"[\u0c30\u0c47\u0c2a\u0c41] LT",nextWeek:"dddd, LT",lastDay:"[\u0c28\u0c3f\u0c28\u0c4d\u0c28] LT",lastWeek:"[\u0c17\u0c24] dddd, LT",sameElse:"L"},relativeTime:{future:"%s \u0c32\u0c4b",past:"%s \u0c15\u0c4d\u0c30\u0c3f\u0c24\u0c02",s:"\u0c15\u0c4a\u0c28\u0c4d\u0c28\u0c3f \u0c15\u0c4d\u0c37\u0c23\u0c3e\u0c32\u0c41",ss:"%d \u0c38\u0c46\u0c15\u0c28\u0c4d\u0c32\u0c41",m:"\u0c12\u0c15 \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c02",mm:"%d \u0c28\u0c3f\u0c2e\u0c3f\u0c37\u0c3e\u0c32\u0c41",h:"\u0c12\u0c15 \u0c17\u0c02\u0c1f",hh:"%d \u0c17\u0c02\u0c1f\u0c32\u0c41",d:"\u0c12\u0c15 \u0c30\u0c4b\u0c1c\u0c41",dd:"%d \u0c30\u0c4b\u0c1c\u0c41\u0c32\u0c41",M:"\u0c12\u0c15 \u0c28\u0c46\u0c32",MM:"%d \u0c28\u0c46\u0c32\u0c32\u0c41",y:"\u0c12\u0c15 \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c02",yy:"%d \u0c38\u0c02\u0c35\u0c24\u0c4d\u0c38\u0c30\u0c3e\u0c32\u0c41"},dayOfMonthOrdinalParse:/\d{1,2}\u0c35/,ordinal:"%d\u0c35",meridiemParse:/\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f|\u0c09\u0c26\u0c2f\u0c02|\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02|\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"===a?e<4?e:e+12:"\u0c09\u0c26\u0c2f\u0c02"===a?e:"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02"===a?10<=e?e:e+12:"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f":e<10?"\u0c09\u0c26\u0c2f\u0c02":e<17?"\u0c2e\u0c27\u0c4d\u0c2f\u0c3e\u0c39\u0c4d\u0c28\u0c02":e<20?"\u0c38\u0c3e\u0c2f\u0c02\u0c24\u0c4d\u0c30\u0c02":"\u0c30\u0c3e\u0c24\u0c4d\u0c30\u0c3f"},week:{dow:0,doy:6}}),l.defineLocale("tet",{months:"Janeiru_Fevereiru_Marsu_Abril_Maiu_Ju\xf1u_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),monthsShort:"Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),weekdays:"Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),weekdaysShort:"Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),weekdaysMin:"Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Ohin iha] LT",nextDay:"[Aban iha] LT",nextWeek:"dddd [iha] LT",lastDay:"[Horiseik iha] LT",lastWeek:"dddd [semana kotuk] [iha] LT",sameElse:"L"},relativeTime:{future:"iha %s",past:"%s liuba",s:"minutu balun",ss:"minutu %d",m:"minutu ida",mm:"minutu %d",h:"oras ida",hh:"oras %d",d:"loron ida",dd:"loron %d",M:"fulan ida",MM:"fulan %d",y:"tinan ida",yy:"tinan %d"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}});var $n={0:"-\u0443\u043c",1:"-\u0443\u043c",2:"-\u044e\u043c",3:"-\u044e\u043c",4:"-\u0443\u043c",5:"-\u0443\u043c",6:"-\u0443\u043c",7:"-\u0443\u043c",8:"-\u0443\u043c",9:"-\u0443\u043c",10:"-\u0443\u043c",12:"-\u0443\u043c",13:"-\u0443\u043c",20:"-\u0443\u043c",30:"-\u044e\u043c",40:"-\u0443\u043c",50:"-\u0443\u043c",60:"-\u0443\u043c",70:"-\u0443\u043c",80:"-\u0443\u043c",90:"-\u0443\u043c",100:"-\u0443\u043c"};l.defineLocale("tg",{months:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u044f\u043a\u0448\u0430\u043d\u0431\u0435_\u0434\u0443\u0448\u0430\u043d\u0431\u0435_\u0441\u0435\u0448\u0430\u043d\u0431\u0435_\u0447\u043e\u0440\u0448\u0430\u043d\u0431\u0435_\u043f\u0430\u043d\u04b7\u0448\u0430\u043d\u0431\u0435_\u04b7\u0443\u043c\u044a\u0430_\u0448\u0430\u043d\u0431\u0435".split("_"),weekdaysShort:"\u044f\u0448\u0431_\u0434\u0448\u0431_\u0441\u0448\u0431_\u0447\u0448\u0431_\u043f\u0448\u0431_\u04b7\u0443\u043c_\u0448\u043d\u0431".split("_"),weekdaysMin:"\u044f\u0448_\u0434\u0448_\u0441\u0448_\u0447\u0448_\u043f\u0448_\u04b7\u043c_\u0448\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u0418\u043c\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextDay:"[\u041f\u0430\u0433\u043e\u04b3 \u0441\u043e\u0430\u0442\u0438] LT",lastDay:"[\u0414\u0438\u0440\u04ef\u0437 \u0441\u043e\u0430\u0442\u0438] LT",nextWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u043e\u044f\u043d\u0434\u0430 \u0441\u043e\u0430\u0442\u0438] LT",lastWeek:"dddd[\u0438] [\u04b3\u0430\u0444\u0442\u0430\u0438 \u0433\u0443\u0437\u0430\u0448\u0442\u0430 \u0441\u043e\u0430\u0442\u0438] LT",sameElse:"L"},relativeTime:{future:"\u0431\u0430\u044a\u0434\u0438 %s",past:"%s \u043f\u0435\u0448",s:"\u044f\u043a\u0447\u0430\u043d\u0434 \u0441\u043e\u043d\u0438\u044f",m:"\u044f\u043a \u0434\u0430\u049b\u0438\u049b\u0430",mm:"%d \u0434\u0430\u049b\u0438\u049b\u0430",h:"\u044f\u043a \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u044f\u043a \u0440\u04ef\u0437",dd:"%d \u0440\u04ef\u0437",M:"\u044f\u043a \u043c\u043e\u04b3",MM:"%d \u043c\u043e\u04b3",y:"\u044f\u043a \u0441\u043e\u043b",yy:"%d \u0441\u043e\u043b"},meridiemParse:/\u0448\u0430\u0431|\u0441\u0443\u0431\u04b3|\u0440\u04ef\u0437|\u0431\u0435\u0433\u043e\u04b3/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u0448\u0430\u0431"===a?e<4?e:e+12:"\u0441\u0443\u0431\u04b3"===a?e:"\u0440\u04ef\u0437"===a?11<=e?e:e+12:"\u0431\u0435\u0433\u043e\u04b3"===a?e+12:void 0},meridiem:function(e,a,t){return e<4?"\u0448\u0430\u0431":e<11?"\u0441\u0443\u0431\u04b3":e<16?"\u0440\u04ef\u0437":e<19?"\u0431\u0435\u0433\u043e\u04b3":"\u0448\u0430\u0431"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0443\u043c|\u044e\u043c)/,ordinal:function(e){return e+($n[e]||$n[e%10]||$n[100<=e?100:null])},week:{dow:1,doy:7}}),l.defineLocale("th",{months:"\u0e21\u0e01\u0e23\u0e32\u0e04\u0e21_\u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c_\u0e21\u0e35\u0e19\u0e32\u0e04\u0e21_\u0e40\u0e21\u0e29\u0e32\u0e22\u0e19_\u0e1e\u0e24\u0e29\u0e20\u0e32\u0e04\u0e21_\u0e21\u0e34\u0e16\u0e38\u0e19\u0e32\u0e22\u0e19_\u0e01\u0e23\u0e01\u0e0e\u0e32\u0e04\u0e21_\u0e2a\u0e34\u0e07\u0e2b\u0e32\u0e04\u0e21_\u0e01\u0e31\u0e19\u0e22\u0e32\u0e22\u0e19_\u0e15\u0e38\u0e25\u0e32\u0e04\u0e21_\u0e1e\u0e24\u0e28\u0e08\u0e34\u0e01\u0e32\u0e22\u0e19_\u0e18\u0e31\u0e19\u0e27\u0e32\u0e04\u0e21".split("_"),monthsShort:"\u0e21.\u0e04._\u0e01.\u0e1e._\u0e21\u0e35.\u0e04._\u0e40\u0e21.\u0e22._\u0e1e.\u0e04._\u0e21\u0e34.\u0e22._\u0e01.\u0e04._\u0e2a.\u0e04._\u0e01.\u0e22._\u0e15.\u0e04._\u0e1e.\u0e22._\u0e18.\u0e04.".split("_"),monthsParseExact:!0,weekdays:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a\u0e1a\u0e14\u0e35_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysShort:"\u0e2d\u0e32\u0e17\u0e34\u0e15\u0e22\u0e4c_\u0e08\u0e31\u0e19\u0e17\u0e23\u0e4c_\u0e2d\u0e31\u0e07\u0e04\u0e32\u0e23_\u0e1e\u0e38\u0e18_\u0e1e\u0e24\u0e2b\u0e31\u0e2a_\u0e28\u0e38\u0e01\u0e23\u0e4c_\u0e40\u0e2a\u0e32\u0e23\u0e4c".split("_"),weekdaysMin:"\u0e2d\u0e32._\u0e08._\u0e2d._\u0e1e._\u0e1e\u0e24._\u0e28._\u0e2a.".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm",LLLL:"\u0e27\u0e31\u0e19dddd\u0e17\u0e35\u0e48 D MMMM YYYY \u0e40\u0e27\u0e25\u0e32 H:mm"},meridiemParse:/\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07|\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07/,isPM:function(e){return"\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"===e},meridiem:function(e,a,t){return e<12?"\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07":"\u0e2b\u0e25\u0e31\u0e07\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07"},calendar:{sameDay:"[\u0e27\u0e31\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextDay:"[\u0e1e\u0e23\u0e38\u0e48\u0e07\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",nextWeek:"dddd[\u0e2b\u0e19\u0e49\u0e32 \u0e40\u0e27\u0e25\u0e32] LT",lastDay:"[\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e27\u0e32\u0e19\u0e19\u0e35\u0e49 \u0e40\u0e27\u0e25\u0e32] LT",lastWeek:"[\u0e27\u0e31\u0e19]dddd[\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27 \u0e40\u0e27\u0e25\u0e32] LT",sameElse:"L"},relativeTime:{future:"\u0e2d\u0e35\u0e01 %s",past:"%s\u0e17\u0e35\u0e48\u0e41\u0e25\u0e49\u0e27",s:"\u0e44\u0e21\u0e48\u0e01\u0e35\u0e48\u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",ss:"%d \u0e27\u0e34\u0e19\u0e32\u0e17\u0e35",m:"1 \u0e19\u0e32\u0e17\u0e35",mm:"%d \u0e19\u0e32\u0e17\u0e35",h:"1 \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",hh:"%d \u0e0a\u0e31\u0e48\u0e27\u0e42\u0e21\u0e07",d:"1 \u0e27\u0e31\u0e19",dd:"%d \u0e27\u0e31\u0e19",M:"1 \u0e40\u0e14\u0e37\u0e2d\u0e19",MM:"%d \u0e40\u0e14\u0e37\u0e2d\u0e19",y:"1 \u0e1b\u0e35",yy:"%d \u0e1b\u0e35"}}),l.defineLocale("tl-ph",{months:"Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),monthsShort:"Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),weekdays:"Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),weekdaysShort:"Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),weekdaysMin:"Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"MM/D/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY HH:mm",LLLL:"dddd, MMMM DD, YYYY HH:mm"},calendar:{sameDay:"LT [ngayong araw]",nextDay:"[Bukas ng] LT",nextWeek:"LT [sa susunod na] dddd",lastDay:"LT [kahapon]",lastWeek:"LT [noong nakaraang] dddd",sameElse:"L"},relativeTime:{future:"sa loob ng %s",past:"%s ang nakalipas",s:"ilang segundo",ss:"%d segundo",m:"isang minuto",mm:"%d minuto",h:"isang oras",hh:"%d oras",d:"isang araw",dd:"%d araw",M:"isang buwan",MM:"%d buwan",y:"isang taon",yy:"%d taon"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}});var Zn="pagh_wa\u2019_cha\u2019_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");function Bn(e,a,t,s){var n=function(e){var a=Math.floor(e%1e3/100),t=Math.floor(e%100/10),s=e%10,n="";0<a&&(n+=Zn[a]+"vatlh");0<t&&(n+=(""!==n?" ":"")+Zn[t]+"maH");0<s&&(n+=(""!==n?" ":"")+Zn[s]);return""===n?"pagh":n}(e);switch(t){case"ss":return n+" lup";case"mm":return n+" tup";case"hh":return n+" rep";case"dd":return n+" jaj";case"MM":return n+" jar";case"yy":return n+" DIS"}}l.defineLocale("tlh",{months:"tera\u2019 jar wa\u2019_tera\u2019 jar cha\u2019_tera\u2019 jar wej_tera\u2019 jar loS_tera\u2019 jar vagh_tera\u2019 jar jav_tera\u2019 jar Soch_tera\u2019 jar chorgh_tera\u2019 jar Hut_tera\u2019 jar wa\u2019maH_tera\u2019 jar wa\u2019maH wa\u2019_tera\u2019 jar wa\u2019maH cha\u2019".split("_"),monthsShort:"jar wa\u2019_jar cha\u2019_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa\u2019maH_jar wa\u2019maH wa\u2019_jar wa\u2019maH cha\u2019".split("_"),monthsParseExact:!0,weekdays:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysShort:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),weekdaysMin:"lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[DaHjaj] LT",nextDay:"[wa\u2019leS] LT",nextWeek:"LLL",lastDay:"[wa\u2019Hu\u2019] LT",lastWeek:"LLL",sameElse:"L"},relativeTime:{future:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"leS":-1!==e.indexOf("jar")?a.slice(0,-3)+"waQ":-1!==e.indexOf("DIS")?a.slice(0,-3)+"nem":a+" pIq"},past:function(e){var a=e;return a=-1!==e.indexOf("jaj")?a.slice(0,-3)+"Hu\u2019":-1!==e.indexOf("jar")?a.slice(0,-3)+"wen":-1!==e.indexOf("DIS")?a.slice(0,-3)+"ben":a+" ret"},s:"puS lup",ss:Bn,m:"wa\u2019 tup",mm:Bn,h:"wa\u2019 rep",hh:Bn,d:"wa\u2019 jaj",dd:Bn,M:"wa\u2019 jar",MM:Bn,y:"wa\u2019 DIS",yy:Bn},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}});var qn={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'\xfcnc\xfc",4:"'\xfcnc\xfc",100:"'\xfcnc\xfc",6:"'nc\u0131",9:"'uncu",10:"'uncu",30:"'uncu",60:"'\u0131nc\u0131",90:"'\u0131nc\u0131"};function Qn(e,a,t,s){var n={s:["viensas secunds","'iensas secunds"],ss:[e+" secunds",e+" secunds"],m:["'n m\xedut","'iens m\xedut"],mm:[e+" m\xeduts",e+" m\xeduts"],h:["'n \xfeora","'iensa \xfeora"],hh:[e+" \xfeoras",e+" \xfeoras"],d:["'n ziua","'iensa ziua"],dd:[e+" ziuas",e+" ziuas"],M:["'n mes","'iens mes"],MM:[e+" mesen",e+" mesen"],y:["'n ar","'iens ar"],yy:[e+" ars",e+" ars"]};return s?n[t][0]:a?n[t][0]:n[t][1]}function Xn(e,a,t){var s,n;return"m"===t?a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443":"h"===t?a?"\u0433\u043e\u0434\u0438\u043d\u0430":"\u0433\u043e\u0434\u0438\u043d\u0443":e+" "+(s=+e,n={ss:a?"\u0441\u0435\u043a\u0443\u043d\u0434\u0430_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434":"\u0441\u0435\u043a\u0443\u043d\u0434\u0443_\u0441\u0435\u043a\u0443\u043d\u0434\u0438_\u0441\u0435\u043a\u0443\u043d\u0434",mm:a?"\u0445\u0432\u0438\u043b\u0438\u043d\u0430_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d":"\u0445\u0432\u0438\u043b\u0438\u043d\u0443_\u0445\u0432\u0438\u043b\u0438\u043d\u0438_\u0445\u0432\u0438\u043b\u0438\u043d",hh:a?"\u0433\u043e\u0434\u0438\u043d\u0430_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d":"\u0433\u043e\u0434\u0438\u043d\u0443_\u0433\u043e\u0434\u0438\u043d\u0438_\u0433\u043e\u0434\u0438\u043d",dd:"\u0434\u0435\u043d\u044c_\u0434\u043d\u0456_\u0434\u043d\u0456\u0432",MM:"\u043c\u0456\u0441\u044f\u0446\u044c_\u043c\u0456\u0441\u044f\u0446\u0456_\u043c\u0456\u0441\u044f\u0446\u0456\u0432",yy:"\u0440\u0456\u043a_\u0440\u043e\u043a\u0438_\u0440\u043e\u043a\u0456\u0432"}[t].split("_"),s%10==1&&s%100!=11?n[0]:2<=s%10&&s%10<=4&&(s%100<10||20<=s%100)?n[1]:n[2])}function ed(e){return function(){return e+"\u043e"+(11===this.hours()?"\u0431":"")+"] LT"}}l.defineLocale("tr",{months:"Ocak_\u015eubat_Mart_Nisan_May\u0131s_Haziran_Temmuz_A\u011fustos_Eyl\xfcl_Ekim_Kas\u0131m_Aral\u0131k".split("_"),monthsShort:"Oca_\u015eub_Mar_Nis_May_Haz_Tem_A\u011fu_Eyl_Eki_Kas_Ara".split("_"),weekdays:"Pazar_Pazartesi_Sal\u0131_\xc7ar\u015famba_Per\u015fembe_Cuma_Cumartesi".split("_"),weekdaysShort:"Paz_Pts_Sal_\xc7ar_Per_Cum_Cts".split("_"),weekdaysMin:"Pz_Pt_Sa_\xc7a_Pe_Cu_Ct".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bug\xfcn saat] LT",nextDay:"[yar\u0131n saat] LT",nextWeek:"[gelecek] dddd [saat] LT",lastDay:"[d\xfcn] LT",lastWeek:"[ge\xe7en] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s \xf6nce",s:"birka\xe7 saniye",ss:"%d saniye",m:"bir dakika",mm:"%d dakika",h:"bir saat",hh:"%d saat",d:"bir g\xfcn",dd:"%d g\xfcn",M:"bir ay",MM:"%d ay",y:"bir y\u0131l",yy:"%d y\u0131l"},ordinal:function(e,a){switch(a){case"d":case"D":case"Do":case"DD":return e;default:if(0===e)return e+"'\u0131nc\u0131";var t=e%10;return e+(qn[t]||qn[e%100-t]||qn[100<=e?100:null])}},week:{dow:1,doy:7}}),l.defineLocale("tzl",{months:"Januar_Fevraglh_Mar\xe7_Avr\xefu_Mai_G\xfcn_Julia_Guscht_Setemvar_Listop\xe4ts_Noemvar_Zecemvar".split("_"),monthsShort:"Jan_Fev_Mar_Avr_Mai_G\xfcn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),weekdays:"S\xfaladi_L\xfane\xe7i_Maitzi_M\xe1rcuri_Xh\xfaadi_Vi\xe9ner\xe7i_S\xe1turi".split("_"),weekdaysShort:"S\xfal_L\xfan_Mai_M\xe1r_Xh\xfa_Vi\xe9_S\xe1t".split("_"),weekdaysMin:"S\xfa_L\xfa_Ma_M\xe1_Xh_Vi_S\xe1".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"D. MMMM [dallas] YYYY",LLL:"D. MMMM [dallas] YYYY HH.mm",LLLL:"dddd, [li] D. MMMM [dallas] YYYY HH.mm"},meridiemParse:/d\'o|d\'a/i,isPM:function(e){return"d'o"===e.toLowerCase()},meridiem:function(e,a,t){return 11<e?t?"d'o":"D'O":t?"d'a":"D'A"},calendar:{sameDay:"[oxhi \xe0] LT",nextDay:"[dem\xe0 \xe0] LT",nextWeek:"dddd [\xe0] LT",lastDay:"[ieiri \xe0] LT",lastWeek:"[s\xfcr el] dddd [lasteu \xe0] LT",sameElse:"L"},relativeTime:{future:"osprei %s",past:"ja%s",s:Qn,ss:Qn,m:Qn,mm:Qn,h:Qn,hh:Qn,d:Qn,dd:Qn,M:Qn,MM:Qn,y:Qn,yy:Qn},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}}),l.defineLocale("tzm-latn",{months:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),monthsShort:"innayr_br\u02e4ayr\u02e4_mar\u02e4s\u02e4_ibrir_mayyw_ywnyw_ywlywz_\u0263w\u0161t_\u0161wtanbir_kt\u02e4wbr\u02e4_nwwanbir_dwjnbir".split("_"),weekdays:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysShort:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),weekdaysMin:"asamas_aynas_asinas_akras_akwas_asimwas_asi\u1e0dyas".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[asdkh g] LT",nextDay:"[aska g] LT",nextWeek:"dddd [g] LT",lastDay:"[assant g] LT",lastWeek:"dddd [g] LT",sameElse:"L"},relativeTime:{future:"dadkh s yan %s",past:"yan %s",s:"imik",ss:"%d imik",m:"minu\u1e0d",mm:"%d minu\u1e0d",h:"sa\u025ba",hh:"%d tassa\u025bin",d:"ass",dd:"%d ossan",M:"ayowr",MM:"%d iyyirn",y:"asgas",yy:"%d isgasn"},week:{dow:6,doy:12}}),l.defineLocale("tzm",{months:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),monthsShort:"\u2d49\u2d4f\u2d4f\u2d30\u2d62\u2d54_\u2d31\u2d55\u2d30\u2d62\u2d55_\u2d4e\u2d30\u2d55\u2d5a_\u2d49\u2d31\u2d54\u2d49\u2d54_\u2d4e\u2d30\u2d62\u2d62\u2d53_\u2d62\u2d53\u2d4f\u2d62\u2d53_\u2d62\u2d53\u2d4d\u2d62\u2d53\u2d63_\u2d56\u2d53\u2d5b\u2d5c_\u2d5b\u2d53\u2d5c\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d3d\u2d5f\u2d53\u2d31\u2d55_\u2d4f\u2d53\u2d61\u2d30\u2d4f\u2d31\u2d49\u2d54_\u2d37\u2d53\u2d4a\u2d4f\u2d31\u2d49\u2d54".split("_"),weekdays:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysShort:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),weekdaysMin:"\u2d30\u2d59\u2d30\u2d4e\u2d30\u2d59_\u2d30\u2d62\u2d4f\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4f\u2d30\u2d59_\u2d30\u2d3d\u2d54\u2d30\u2d59_\u2d30\u2d3d\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d4e\u2d61\u2d30\u2d59_\u2d30\u2d59\u2d49\u2d39\u2d62\u2d30\u2d59".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[\u2d30\u2d59\u2d37\u2d45 \u2d34] LT",nextDay:"[\u2d30\u2d59\u2d3d\u2d30 \u2d34] LT",nextWeek:"dddd [\u2d34] LT",lastDay:"[\u2d30\u2d5a\u2d30\u2d4f\u2d5c \u2d34] LT",lastWeek:"dddd [\u2d34] LT",sameElse:"L"},relativeTime:{future:"\u2d37\u2d30\u2d37\u2d45 \u2d59 \u2d62\u2d30\u2d4f %s",past:"\u2d62\u2d30\u2d4f %s",s:"\u2d49\u2d4e\u2d49\u2d3d",ss:"%d \u2d49\u2d4e\u2d49\u2d3d",m:"\u2d4e\u2d49\u2d4f\u2d53\u2d3a",mm:"%d \u2d4e\u2d49\u2d4f\u2d53\u2d3a",h:"\u2d59\u2d30\u2d44\u2d30",hh:"%d \u2d5c\u2d30\u2d59\u2d59\u2d30\u2d44\u2d49\u2d4f",d:"\u2d30\u2d59\u2d59",dd:"%d o\u2d59\u2d59\u2d30\u2d4f",M:"\u2d30\u2d62o\u2d53\u2d54",MM:"%d \u2d49\u2d62\u2d62\u2d49\u2d54\u2d4f",y:"\u2d30\u2d59\u2d33\u2d30\u2d59",yy:"%d \u2d49\u2d59\u2d33\u2d30\u2d59\u2d4f"},week:{dow:6,doy:12}}),l.defineLocale("ug-cn",{months:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),monthsShort:"\u064a\u0627\u0646\u06cb\u0627\u0631_\u0641\u06d0\u06cb\u0631\u0627\u0644_\u0645\u0627\u0631\u062a_\u0626\u0627\u067e\u0631\u06d0\u0644_\u0645\u0627\u064a_\u0626\u0649\u064a\u06c7\u0646_\u0626\u0649\u064a\u06c7\u0644_\u0626\u0627\u06cb\u063a\u06c7\u0633\u062a_\u0633\u06d0\u0646\u062a\u06d5\u0628\u0649\u0631_\u0626\u06c6\u0643\u062a\u06d5\u0628\u0649\u0631_\u0646\u0648\u064a\u0627\u0628\u0649\u0631_\u062f\u06d0\u0643\u0627\u0628\u0649\u0631".split("_"),weekdays:"\u064a\u06d5\u0643\u0634\u06d5\u0646\u0628\u06d5_\u062f\u06c8\u0634\u06d5\u0646\u0628\u06d5_\u0633\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u0686\u0627\u0631\u0634\u06d5\u0646\u0628\u06d5_\u067e\u06d5\u064a\u0634\u06d5\u0646\u0628\u06d5_\u062c\u06c8\u0645\u06d5_\u0634\u06d5\u0646\u0628\u06d5".split("_"),weekdaysShort:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),weekdaysMin:"\u064a\u06d5_\u062f\u06c8_\u0633\u06d5_\u0686\u0627_\u067e\u06d5_\u062c\u06c8_\u0634\u06d5".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649",LLL:"YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm",LLLL:"dddd\u060c YYYY-\u064a\u0649\u0644\u0649M-\u0626\u0627\u064a\u0646\u0649\u06adD-\u0643\u06c8\u0646\u0649\u060c HH:mm"},meridiemParse:/\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5|\u0633\u06d5\u06be\u06d5\u0631|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646|\u0686\u06c8\u0634|\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646|\u0643\u06d5\u0686/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5"===a||"\u0633\u06d5\u06be\u06d5\u0631"===a||"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646"===a?e:"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646"===a||"\u0643\u06d5\u0686"===a?e+12:11<=e?e:e+12},meridiem:function(e,a,t){var s=100*e+a;return s<600?"\u064a\u06d0\u0631\u0649\u0645 \u0643\u06d0\u0686\u06d5":s<900?"\u0633\u06d5\u06be\u06d5\u0631":s<1130?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0628\u06c7\u0631\u06c7\u0646":s<1230?"\u0686\u06c8\u0634":s<1800?"\u0686\u06c8\u0634\u062a\u0649\u0646 \u0643\u06d0\u064a\u0649\u0646":"\u0643\u06d5\u0686"},calendar:{sameDay:"[\u0628\u06c8\u06af\u06c8\u0646 \u0633\u0627\u0626\u06d5\u062a] LT",nextDay:"[\u0626\u06d5\u062a\u06d5 \u0633\u0627\u0626\u06d5\u062a] LT",nextWeek:"[\u0643\u06d0\u0644\u06d5\u0631\u0643\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",lastDay:"[\u062a\u06c6\u0646\u06c8\u06af\u06c8\u0646] LT",lastWeek:"[\u0626\u0627\u0644\u062f\u0649\u0646\u0642\u0649] dddd [\u0633\u0627\u0626\u06d5\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0643\u06d0\u064a\u0649\u0646",past:"%s \u0628\u06c7\u0631\u06c7\u0646",s:"\u0646\u06d5\u0686\u0686\u06d5 \u0633\u06d0\u0643\u0648\u0646\u062a",ss:"%d \u0633\u06d0\u0643\u0648\u0646\u062a",m:"\u0628\u0649\u0631 \u0645\u0649\u0646\u06c7\u062a",mm:"%d \u0645\u0649\u0646\u06c7\u062a",h:"\u0628\u0649\u0631 \u0633\u0627\u0626\u06d5\u062a",hh:"%d \u0633\u0627\u0626\u06d5\u062a",d:"\u0628\u0649\u0631 \u0643\u06c8\u0646",dd:"%d \u0643\u06c8\u0646",M:"\u0628\u0649\u0631 \u0626\u0627\u064a",MM:"%d \u0626\u0627\u064a",y:"\u0628\u0649\u0631 \u064a\u0649\u0644",yy:"%d \u064a\u0649\u0644"},dayOfMonthOrdinalParse:/\d{1,2}(-\u0643\u06c8\u0646\u0649|-\u0626\u0627\u064a|-\u06be\u06d5\u067e\u062a\u06d5)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"-\u0643\u06c8\u0646\u0649";case"w":case"W":return e+"-\u06be\u06d5\u067e\u062a\u06d5";default:return e}},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:7}}),l.defineLocale("uk",{months:{format:"\u0441\u0456\u0447\u043d\u044f_\u043b\u044e\u0442\u043e\u0433\u043e_\u0431\u0435\u0440\u0435\u0437\u043d\u044f_\u043a\u0432\u0456\u0442\u043d\u044f_\u0442\u0440\u0430\u0432\u043d\u044f_\u0447\u0435\u0440\u0432\u043d\u044f_\u043b\u0438\u043f\u043d\u044f_\u0441\u0435\u0440\u043f\u043d\u044f_\u0432\u0435\u0440\u0435\u0441\u043d\u044f_\u0436\u043e\u0432\u0442\u043d\u044f_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430_\u0433\u0440\u0443\u0434\u043d\u044f".split("_"),standalone:"\u0441\u0456\u0447\u0435\u043d\u044c_\u043b\u044e\u0442\u0438\u0439_\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c_\u043a\u0432\u0456\u0442\u0435\u043d\u044c_\u0442\u0440\u0430\u0432\u0435\u043d\u044c_\u0447\u0435\u0440\u0432\u0435\u043d\u044c_\u043b\u0438\u043f\u0435\u043d\u044c_\u0441\u0435\u0440\u043f\u0435\u043d\u044c_\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c_\u0436\u043e\u0432\u0442\u0435\u043d\u044c_\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434_\u0433\u0440\u0443\u0434\u0435\u043d\u044c".split("_")},monthsShort:"\u0441\u0456\u0447_\u043b\u044e\u0442_\u0431\u0435\u0440_\u043a\u0432\u0456\u0442_\u0442\u0440\u0430\u0432_\u0447\u0435\u0440\u0432_\u043b\u0438\u043f_\u0441\u0435\u0440\u043f_\u0432\u0435\u0440_\u0436\u043e\u0432\u0442_\u043b\u0438\u0441\u0442_\u0433\u0440\u0443\u0434".split("_"),weekdays:function(e,a){var t={nominative:"\u043d\u0435\u0434\u0456\u043b\u044f_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0430_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044f_\u0441\u0443\u0431\u043e\u0442\u0430".split("_"),accusative:"\u043d\u0435\u0434\u0456\u043b\u044e_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a_\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a_\u0441\u0435\u0440\u0435\u0434\u0443_\u0447\u0435\u0442\u0432\u0435\u0440_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u044e_\u0441\u0443\u0431\u043e\u0442\u0443".split("_"),genitive:"\u043d\u0435\u0434\u0456\u043b\u0456_\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043a\u0430_\u0432\u0456\u0432\u0442\u043e\u0440\u043a\u0430_\u0441\u0435\u0440\u0435\u0434\u0438_\u0447\u0435\u0442\u0432\u0435\u0440\u0433\u0430_\u043f\u2019\u044f\u0442\u043d\u0438\u0446\u0456_\u0441\u0443\u0431\u043e\u0442\u0438".split("_")};return e?t[/(\[[\u0412\u0432\u0423\u0443]\]) ?dddd/.test(a)?"accusative":/\[?(?:\u043c\u0438\u043d\u0443\u043b\u043e\u0457|\u043d\u0430\u0441\u0442\u0443\u043f\u043d\u043e\u0457)? ?\] ?dddd/.test(a)?"genitive":"nominative"][e.day()]:t.nominative},weekdaysShort:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),weekdaysMin:"\u043d\u0434_\u043f\u043d_\u0432\u0442_\u0441\u0440_\u0447\u0442_\u043f\u0442_\u0441\u0431".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY \u0440.",LLL:"D MMMM YYYY \u0440., HH:mm",LLLL:"dddd, D MMMM YYYY \u0440., HH:mm"},calendar:{sameDay:ed("[\u0421\u044c\u043e\u0433\u043e\u0434\u043d\u0456 "),nextDay:ed("[\u0417\u0430\u0432\u0442\u0440\u0430 "),lastDay:ed("[\u0412\u0447\u043e\u0440\u0430 "),nextWeek:ed("[\u0423] dddd ["),lastWeek:function(){switch(this.day()){case 0:case 3:case 5:case 6:return ed("[\u041c\u0438\u043d\u0443\u043b\u043e\u0457] dddd [").call(this);case 1:case 2:case 4:return ed("[\u041c\u0438\u043d\u0443\u043b\u043e\u0433\u043e] dddd [").call(this)}},sameElse:"L"},relativeTime:{future:"\u0437\u0430 %s",past:"%s \u0442\u043e\u043c\u0443",s:"\u0434\u0435\u043a\u0456\u043b\u044c\u043a\u0430 \u0441\u0435\u043a\u0443\u043d\u0434",ss:Xn,m:Xn,mm:Xn,h:"\u0433\u043e\u0434\u0438\u043d\u0443",hh:Xn,d:"\u0434\u0435\u043d\u044c",dd:Xn,M:"\u043c\u0456\u0441\u044f\u0446\u044c",MM:Xn,y:"\u0440\u0456\u043a",yy:Xn},meridiemParse:/\u043d\u043e\u0447\u0456|\u0440\u0430\u043d\u043a\u0443|\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430/,isPM:function(e){return/^(\u0434\u043d\u044f|\u0432\u0435\u0447\u043e\u0440\u0430)$/.test(e)},meridiem:function(e,a,t){return e<4?"\u043d\u043e\u0447\u0456":e<12?"\u0440\u0430\u043d\u043a\u0443":e<17?"\u0434\u043d\u044f":"\u0432\u0435\u0447\u043e\u0440\u0430"},dayOfMonthOrdinalParse:/\d{1,2}-(\u0439|\u0433\u043e)/,ordinal:function(e,a){switch(a){case"M":case"d":case"DDD":case"w":case"W":return e+"-\u0439";case"D":return e+"-\u0433\u043e";default:return e}},week:{dow:1,doy:7}});var ad=["\u062c\u0646\u0648\u0631\u06cc","\u0641\u0631\u0648\u0631\u06cc","\u0645\u0627\u0631\u0686","\u0627\u067e\u0631\u06cc\u0644","\u0645\u0626\u06cc","\u062c\u0648\u0646","\u062c\u0648\u0644\u0627\u0626\u06cc","\u0627\u06af\u0633\u062a","\u0633\u062a\u0645\u0628\u0631","\u0627\u06a9\u062a\u0648\u0628\u0631","\u0646\u0648\u0645\u0628\u0631","\u062f\u0633\u0645\u0628\u0631"],td=["\u0627\u062a\u0648\u0627\u0631","\u067e\u06cc\u0631","\u0645\u0646\u06af\u0644","\u0628\u062f\u06be","\u062c\u0645\u0639\u0631\u0627\u062a","\u062c\u0645\u0639\u06c1","\u06c1\u0641\u062a\u06c1"];return l.defineLocale("ur",{months:ad,monthsShort:ad,weekdays:td,weekdaysShort:td,weekdaysMin:td,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd\u060c D MMMM YYYY HH:mm"},meridiemParse:/\u0635\u0628\u062d|\u0634\u0627\u0645/,isPM:function(e){return"\u0634\u0627\u0645"===e},meridiem:function(e,a,t){return e<12?"\u0635\u0628\u062d":"\u0634\u0627\u0645"},calendar:{sameDay:"[\u0622\u062c \u0628\u0648\u0642\u062a] LT",nextDay:"[\u06a9\u0644 \u0628\u0648\u0642\u062a] LT",nextWeek:"dddd [\u0628\u0648\u0642\u062a] LT",lastDay:"[\u06af\u0630\u0634\u062a\u06c1 \u0631\u0648\u0632 \u0628\u0648\u0642\u062a] LT",lastWeek:"[\u06af\u0630\u0634\u062a\u06c1] dddd [\u0628\u0648\u0642\u062a] LT",sameElse:"L"},relativeTime:{future:"%s \u0628\u0639\u062f",past:"%s \u0642\u0628\u0644",s:"\u0686\u0646\u062f \u0633\u06cc\u06a9\u0646\u0688",ss:"%d \u0633\u06cc\u06a9\u0646\u0688",m:"\u0627\u06cc\u06a9 \u0645\u0646\u0679",mm:"%d \u0645\u0646\u0679",h:"\u0627\u06cc\u06a9 \u06af\u06be\u0646\u0679\u06c1",hh:"%d \u06af\u06be\u0646\u0679\u06d2",d:"\u0627\u06cc\u06a9 \u062f\u0646",dd:"%d \u062f\u0646",M:"\u0627\u06cc\u06a9 \u0645\u0627\u06c1",MM:"%d \u0645\u0627\u06c1",y:"\u0627\u06cc\u06a9 \u0633\u0627\u0644",yy:"%d \u0633\u0627\u0644"},preparse:function(e){return e.replace(/\u060c/g,",")},postformat:function(e){return e.replace(/,/g,"\u060c")},week:{dow:1,doy:4}}),l.defineLocale("uz-latn",{months:"Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),monthsShort:"Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),weekdays:"Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),weekdaysShort:"Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),weekdaysMin:"Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[Bugun soat] LT [da]",nextDay:"[Ertaga] LT [da]",nextWeek:"dddd [kuni soat] LT [da]",lastDay:"[Kecha soat] LT [da]",lastWeek:"[O'tgan] dddd [kuni soat] LT [da]",sameElse:"L"},relativeTime:{future:"Yaqin %s ichida",past:"Bir necha %s oldin",s:"soniya",ss:"%d soniya",m:"bir daqiqa",mm:"%d daqiqa",h:"bir soat",hh:"%d soat",d:"bir kun",dd:"%d kun",M:"bir oy",MM:"%d oy",y:"bir yil",yy:"%d yil"},week:{dow:1,doy:7}}),l.defineLocale("uz",{months:"\u044f\u043d\u0432\u0430\u0440_\u0444\u0435\u0432\u0440\u0430\u043b_\u043c\u0430\u0440\u0442_\u0430\u043f\u0440\u0435\u043b_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433\u0443\u0441\u0442_\u0441\u0435\u043d\u0442\u044f\u0431\u0440_\u043e\u043a\u0442\u044f\u0431\u0440_\u043d\u043e\u044f\u0431\u0440_\u0434\u0435\u043a\u0430\u0431\u0440".split("_"),monthsShort:"\u044f\u043d\u0432_\u0444\u0435\u0432_\u043c\u0430\u0440_\u0430\u043f\u0440_\u043c\u0430\u0439_\u0438\u044e\u043d_\u0438\u044e\u043b_\u0430\u0432\u0433_\u0441\u0435\u043d_\u043e\u043a\u0442_\u043d\u043e\u044f_\u0434\u0435\u043a".split("_"),weekdays:"\u042f\u043a\u0448\u0430\u043d\u0431\u0430_\u0414\u0443\u0448\u0430\u043d\u0431\u0430_\u0421\u0435\u0448\u0430\u043d\u0431\u0430_\u0427\u043e\u0440\u0448\u0430\u043d\u0431\u0430_\u041f\u0430\u0439\u0448\u0430\u043d\u0431\u0430_\u0416\u0443\u043c\u0430_\u0428\u0430\u043d\u0431\u0430".split("_"),weekdaysShort:"\u042f\u043a\u0448_\u0414\u0443\u0448_\u0421\u0435\u0448_\u0427\u043e\u0440_\u041f\u0430\u0439_\u0416\u0443\u043c_\u0428\u0430\u043d".split("_"),weekdaysMin:"\u042f\u043a_\u0414\u0443_\u0421\u0435_\u0427\u043e_\u041f\u0430_\u0416\u0443_\u0428\u0430".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"D MMMM YYYY, dddd HH:mm"},calendar:{sameDay:"[\u0411\u0443\u0433\u0443\u043d \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",nextDay:"[\u042d\u0440\u0442\u0430\u0433\u0430] LT [\u0434\u0430]",nextWeek:"dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastDay:"[\u041a\u0435\u0447\u0430 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",lastWeek:"[\u0423\u0442\u0433\u0430\u043d] dddd [\u043a\u0443\u043d\u0438 \u0441\u043e\u0430\u0442] LT [\u0434\u0430]",sameElse:"L"},relativeTime:{future:"\u042f\u043a\u0438\u043d %s \u0438\u0447\u0438\u0434\u0430",past:"\u0411\u0438\u0440 \u043d\u0435\u0447\u0430 %s \u043e\u043b\u0434\u0438\u043d",s:"\u0444\u0443\u0440\u0441\u0430\u0442",ss:"%d \u0444\u0443\u0440\u0441\u0430\u0442",m:"\u0431\u0438\u0440 \u0434\u0430\u043a\u0438\u043a\u0430",mm:"%d \u0434\u0430\u043a\u0438\u043a\u0430",h:"\u0431\u0438\u0440 \u0441\u043e\u0430\u0442",hh:"%d \u0441\u043e\u0430\u0442",d:"\u0431\u0438\u0440 \u043a\u0443\u043d",dd:"%d \u043a\u0443\u043d",M:"\u0431\u0438\u0440 \u043e\u0439",MM:"%d \u043e\u0439",y:"\u0431\u0438\u0440 \u0439\u0438\u043b",yy:"%d \u0439\u0438\u043b"},week:{dow:1,doy:7}}),l.defineLocale("vi",{months:"th\xe1ng 1_th\xe1ng 2_th\xe1ng 3_th\xe1ng 4_th\xe1ng 5_th\xe1ng 6_th\xe1ng 7_th\xe1ng 8_th\xe1ng 9_th\xe1ng 10_th\xe1ng 11_th\xe1ng 12".split("_"),monthsShort:"Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),monthsParseExact:!0,weekdays:"ch\u1ee7 nh\u1eadt_th\u1ee9 hai_th\u1ee9 ba_th\u1ee9 t\u01b0_th\u1ee9 n\u0103m_th\u1ee9 s\xe1u_th\u1ee9 b\u1ea3y".split("_"),weekdaysShort:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysMin:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysParseExact:!0,meridiemParse:/sa|ch/i,isPM:function(e){return/^ch$/i.test(e)},meridiem:function(e,a,t){return e<12?t?"sa":"SA":t?"ch":"CH"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [n\u0103m] YYYY",LLL:"D MMMM [n\u0103m] YYYY HH:mm",LLLL:"dddd, D MMMM [n\u0103m] YYYY HH:mm",l:"DD/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[H\xf4m nay l\xfac] LT",nextDay:"[Ng\xe0y mai l\xfac] LT",nextWeek:"dddd [tu\u1ea7n t\u1edbi l\xfac] LT",lastDay:"[H\xf4m qua l\xfac] LT",lastWeek:"dddd [tu\u1ea7n r\u1ed3i l\xfac] LT",sameElse:"L"},relativeTime:{future:"%s t\u1edbi",past:"%s tr\u01b0\u1edbc",s:"v\xe0i gi\xe2y",ss:"%d gi\xe2y",m:"m\u1ed9t ph\xfat",mm:"%d ph\xfat",h:"m\u1ed9t gi\u1edd",hh:"%d gi\u1edd",d:"m\u1ed9t ng\xe0y",dd:"%d ng\xe0y",M:"m\u1ed9t th\xe1ng",MM:"%d th\xe1ng",y:"m\u1ed9t n\u0103m",yy:"%d n\u0103m"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(e){return e},week:{dow:1,doy:4}}),l.defineLocale("x-pseudo",{months:"J~\xe1\xf1\xfa\xe1~r\xfd_F~\xe9br\xfa~\xe1r\xfd_~M\xe1rc~h_\xc1p~r\xedl_~M\xe1\xfd_~J\xfa\xf1\xe9~_J\xfal~\xfd_\xc1\xfa~g\xfast~_S\xe9p~t\xe9mb~\xe9r_\xd3~ct\xf3b~\xe9r_\xd1~\xf3v\xe9m~b\xe9r_~D\xe9c\xe9~mb\xe9r".split("_"),monthsShort:"J~\xe1\xf1_~F\xe9b_~M\xe1r_~\xc1pr_~M\xe1\xfd_~J\xfa\xf1_~J\xfal_~\xc1\xfag_~S\xe9p_~\xd3ct_~\xd1\xf3v_~D\xe9c".split("_"),monthsParseExact:!0,weekdays:"S~\xfa\xf1d\xe1~\xfd_M\xf3~\xf1d\xe1\xfd~_T\xfa\xe9~sd\xe1\xfd~_W\xe9d~\xf1\xe9sd~\xe1\xfd_T~h\xfars~d\xe1\xfd_~Fr\xedd~\xe1\xfd_S~\xe1t\xfar~d\xe1\xfd".split("_"),weekdaysShort:"S~\xfa\xf1_~M\xf3\xf1_~T\xfa\xe9_~W\xe9d_~Th\xfa_~Fr\xed_~S\xe1t".split("_"),weekdaysMin:"S~\xfa_M\xf3~_T\xfa_~W\xe9_T~h_Fr~_S\xe1".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[T~\xf3d\xe1~\xfd \xe1t] LT",nextDay:"[T~\xf3m\xf3~rr\xf3~w \xe1t] LT",nextWeek:"dddd [\xe1t] LT",lastDay:"[\xdd~\xe9st~\xe9rd\xe1~\xfd \xe1t] LT",lastWeek:"[L~\xe1st] dddd [\xe1t] LT",sameElse:"L"},relativeTime:{future:"\xed~\xf1 %s",past:"%s \xe1~g\xf3",s:"\xe1 ~f\xe9w ~s\xe9c\xf3~\xf1ds",ss:"%d s~\xe9c\xf3\xf1~ds",m:"\xe1 ~m\xed\xf1~\xfat\xe9",mm:"%d m~\xed\xf1\xfa~t\xe9s",h:"\xe1~\xf1 h\xf3~\xfar",hh:"%d h~\xf3\xfars",d:"\xe1 ~d\xe1\xfd",dd:"%d d~\xe1\xfds",M:"\xe1 ~m\xf3\xf1~th",MM:"%d m~\xf3\xf1t~hs",y:"\xe1 ~\xfd\xe9\xe1r",yy:"%d \xfd~\xe9\xe1rs"},dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var a=e%10;return e+(1==~~(e%100/10)?"th":1===a?"st":2===a?"nd":3===a?"rd":"th")},week:{dow:1,doy:4}}),l.defineLocale("yo",{months:"S\u1eb9\u0301r\u1eb9\u0301_E\u0300re\u0300le\u0300_\u1eb8r\u1eb9\u0300na\u0300_I\u0300gbe\u0301_E\u0300bibi_O\u0300ku\u0300du_Ag\u1eb9mo_O\u0300gu\u0301n_Owewe_\u1ecc\u0300wa\u0300ra\u0300_Be\u0301lu\u0301_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),monthsShort:"S\u1eb9\u0301r_E\u0300rl_\u1eb8rn_I\u0300gb_E\u0300bi_O\u0300ku\u0300_Ag\u1eb9_O\u0300gu\u0301_Owe_\u1ecc\u0300wa\u0300_Be\u0301l_\u1ecc\u0300p\u1eb9\u0300\u0300".split("_"),weekdays:"A\u0300i\u0300ku\u0301_Aje\u0301_I\u0300s\u1eb9\u0301gun_\u1eccj\u1ecd\u0301ru\u0301_\u1eccj\u1ecd\u0301b\u1ecd_\u1eb8ti\u0300_A\u0300ba\u0301m\u1eb9\u0301ta".split("_"),weekdaysShort:"A\u0300i\u0300k_Aje\u0301_I\u0300s\u1eb9\u0301_\u1eccjr_\u1eccjb_\u1eb8ti\u0300_A\u0300ba\u0301".split("_"),weekdaysMin:"A\u0300i\u0300_Aj_I\u0300s_\u1eccr_\u1eccb_\u1eb8t_A\u0300b".split("_"),longDateFormat:{LT:"h:mm A",LTS:"h:mm:ss A",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY h:mm A",LLLL:"dddd, D MMMM YYYY h:mm A"},calendar:{sameDay:"[O\u0300ni\u0300 ni] LT",nextDay:"[\u1ecc\u0300la ni] LT",nextWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301n'b\u1ecd] [ni] LT",lastDay:"[A\u0300na ni] LT",lastWeek:"dddd [\u1eccs\u1eb9\u0300 to\u0301l\u1ecd\u0301] [ni] LT",sameElse:"L"},relativeTime:{future:"ni\u0301 %s",past:"%s k\u1ecdja\u0301",s:"i\u0300s\u1eb9ju\u0301 aaya\u0301 die",ss:"aaya\u0301 %d",m:"i\u0300s\u1eb9ju\u0301 kan",mm:"i\u0300s\u1eb9ju\u0301 %d",h:"wa\u0301kati kan",hh:"wa\u0301kati %d",d:"\u1ecdj\u1ecd\u0301 kan",dd:"\u1ecdj\u1ecd\u0301 %d",M:"osu\u0300 kan",MM:"osu\u0300 %d",y:"\u1ecddu\u0301n kan",yy:"\u1ecddu\u0301n %d"},dayOfMonthOrdinalParse:/\u1ecdj\u1ecd\u0301\s\d{1,2}/,ordinal:"\u1ecdj\u1ecd\u0301 %d",week:{dow:1,doy:4}}),l.defineLocale("zh-cn",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u5468\u65e5_\u5468\u4e00_\u5468\u4e8c_\u5468\u4e09_\u5468\u56db_\u5468\u4e94_\u5468\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5Ah\u70b9mm\u5206",LLLL:"YYYY\u5e74M\u6708D\u65e5ddddAh\u70b9mm\u5206",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:11<=e?e:e+12},meridiem:function(e,a,t){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:"[\u4e0b]ddddLT",lastDay:"[\u6628\u5929]LT",lastWeek:"[\u4e0a]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u5468)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u5468";default:return e}},relativeTime:{future:"%s\u5185",past:"%s\u524d",s:"\u51e0\u79d2",ss:"%d \u79d2",m:"1 \u5206\u949f",mm:"%d \u5206\u949f",h:"1 \u5c0f\u65f6",hh:"%d \u5c0f\u65f6",d:"1 \u5929",dd:"%d \u5929",M:"1 \u4e2a\u6708",MM:"%d \u4e2a\u6708",y:"1 \u5e74",yy:"%d \u5e74"},week:{dow:1,doy:4}}),l.defineLocale("zh-hk",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,t){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929]LT",nextDay:"[\u660e\u5929]LT",nextWeek:"[\u4e0b]ddddLT",lastDay:"[\u6628\u5929]LT",lastWeek:"[\u4e0a]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5167",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),l.defineLocale("zh-tw",{months:"\u4e00\u6708_\u4e8c\u6708_\u4e09\u6708_\u56db\u6708_\u4e94\u6708_\u516d\u6708_\u4e03\u6708_\u516b\u6708_\u4e5d\u6708_\u5341\u6708_\u5341\u4e00\u6708_\u5341\u4e8c\u6708".split("_"),monthsShort:"1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"),weekdays:"\u661f\u671f\u65e5_\u661f\u671f\u4e00_\u661f\u671f\u4e8c_\u661f\u671f\u4e09_\u661f\u671f\u56db_\u661f\u671f\u4e94_\u661f\u671f\u516d".split("_"),weekdaysShort:"\u9031\u65e5_\u9031\u4e00_\u9031\u4e8c_\u9031\u4e09_\u9031\u56db_\u9031\u4e94_\u9031\u516d".split("_"),weekdaysMin:"\u65e5_\u4e00_\u4e8c_\u4e09_\u56db_\u4e94_\u516d".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY\u5e74M\u6708D\u65e5",LLL:"YYYY\u5e74M\u6708D\u65e5 HH:mm",LLLL:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm",l:"YYYY/M/D",ll:"YYYY\u5e74M\u6708D\u65e5",lll:"YYYY\u5e74M\u6708D\u65e5 HH:mm",llll:"YYYY\u5e74M\u6708D\u65e5dddd HH:mm"},meridiemParse:/\u51cc\u6668|\u65e9\u4e0a|\u4e0a\u5348|\u4e2d\u5348|\u4e0b\u5348|\u665a\u4e0a/,meridiemHour:function(e,a){return 12===e&&(e=0),"\u51cc\u6668"===a||"\u65e9\u4e0a"===a||"\u4e0a\u5348"===a?e:"\u4e2d\u5348"===a?11<=e?e:e+12:"\u4e0b\u5348"===a||"\u665a\u4e0a"===a?e+12:void 0},meridiem:function(e,a,t){var s=100*e+a;return s<600?"\u51cc\u6668":s<900?"\u65e9\u4e0a":s<1130?"\u4e0a\u5348":s<1230?"\u4e2d\u5348":s<1800?"\u4e0b\u5348":"\u665a\u4e0a"},calendar:{sameDay:"[\u4eca\u5929] LT",nextDay:"[\u660e\u5929] LT",nextWeek:"[\u4e0b]dddd LT",lastDay:"[\u6628\u5929] LT",lastWeek:"[\u4e0a]dddd LT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(\u65e5|\u6708|\u9031)/,ordinal:function(e,a){switch(a){case"d":case"D":case"DDD":return e+"\u65e5";case"M":return e+"\u6708";case"w":case"W":return e+"\u9031";default:return e}},relativeTime:{future:"%s\u5167",past:"%s\u524d",s:"\u5e7e\u79d2",ss:"%d \u79d2",m:"1 \u5206\u9418",mm:"%d \u5206\u9418",h:"1 \u5c0f\u6642",hh:"%d \u5c0f\u6642",d:"1 \u5929",dd:"%d \u5929",M:"1 \u500b\u6708",MM:"%d \u500b\u6708",y:"1 \u5e74",yy:"%d \u5e74"}}),l.locale("en"),l});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Numeric',[],function() {
    /**************************************************************************************************************/

    /**
     Declare namespace for Numeric functions.
     TODO : Should be put into GlobWeb
     */
    var Numeric = {};

    /**************************************************************************************************************/

    /**
     Linear interpolation between [a, b], t must be [0, 1]
     */
    Numeric.lerp = function(t, a, b) {
        return a + (b - a) * t;
    };

    /**************************************************************************************************************/

    /**
     Cosine interpolation between [a, b], t must be [0, 1]
     */
    Numeric.coserp = function(t, a, b) {
        var t2 = (1 - Math.cos(t * Math.PI)) / 2;
        return a + (b - a) * t2;
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolation = function(
        t,
        startPos,
        startVel,
        endPos,
        endVel
    ) {
        var t2 = t * t;
        var t3 = t2 * t;

        // Evaluate the position

        var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
        var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
        var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

        var M01 =
            -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
        var M11 =
            -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
        var M21 =
            -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];

        var position = vec3.create();
        position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
        position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
        position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];

        return position;
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolationDerivative = function(
        t,
        startPos,
        startVel,
        endPos,
        endVel
    ) {
        var t2 = t * t;

        // Evaluates the direction

        var M01 =
            6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
        var M11 =
            6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
        var M21 =
            6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

        var M02 =
            -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
        var M12 =
            -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
        var M22 =
            -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

        var direction = vec3.create();
        direction[0] = M01 * t2 + M02 * t + startVel[0];
        direction[1] = M11 * t2 + M12 * t + startVel[1];
        direction[2] = M21 * t2 + M22 * t + startVel[2];

        return direction;
    };

    /**************************************************************************************************************/

    /**
     Map x between [xMin, xMax] to [0, 1]
     */
    Numeric.map01 = function(x, xMin, xMax) {
        return xMin !== xMax ? (x - xMin) / (xMax - xMin) : 0;
    };

    /**************************************************************************************************************/

    /*
     Map x between [xMin, xMax] to [outMin, outMax]
     */
    Numeric.mapLinear = function(x, xMin, xMax, outMin, outMax) {
        return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
    };

    /**************************************************************************************************************/

    Numeric.easeInQuad = function(t) {
        return t * t;
    };

    /**************************************************************************************************************/

    Numeric.easeOutQuad = function(t) {
        // use 1-(t^2) with input [-1, 0]
        var v = t - 1; // map [0 1] to [-1 0]
        return 1.0 - v * v;
    };

    /**************************************************************************************************************/

    /**
     Remap input t ([0, 1]) to a curve starting slowly
     and accelerating till 0.5 an decelerating till 1
     */
    Numeric.easeInOutQuad = function(t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*t^2) with input [0, 1]
            out = out + out; // map [0 0.5] outo [0 1]
            out = 0.5 * (out * out);
        } else {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = out + out - 2.0; // map [0.5 1] to [-1 0]
            out = 0.5 * (1.0 - out * out);
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /*
     */
    Numeric.easeOutInQuad = function(t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = out + out - 1.0; // map [0 0.5] to [-1 0]
            out = 0.5 * (1.0 - out * out);
        } else {
            // use (0.5*t^2) with input [0, 1]
            out = out + out - 1.0; // map [0.5 1] outo [0 1]
            out = 0.5 * (out * out);
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /**
     Convert the given degree value in radian
     */
    Numeric.toRadian = function(degree) {
        return (degree * Math.PI) / 180.0;
    };

    /**************************************************************************************************************/

    /**
     Convert the given radian value in degree
     */
    Numeric.toDegree = function(radian) {
        return (radian * 180.0) / Math.PI;
    };

    /**************************************************************************************************************/

    /**
     Line-line intersection
     rayDirection must be normalized.
     Returns t at which intersection occurs or -1 if no intersection.
     */

    Numeric.lineIntersection = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (det === 0) {
            return [-1, -1];
        }

        var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

        ua /= det;
        ub /= det;

        return [ua, ub];
        //return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
    };

    /**************************************************************************************************************/

    /**
     *    Round the given number
     *
     *    @param num Number to round
     *    @param dec Number of decimals
     */
    Numeric.roundNumber = function(num, dec) {
        return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };

    /**
     * Return the sign of a value
     */
    Numeric.sign = function(v) {
        if (v < 0) return -1;
        else {
            if (v > 0) return 1;
            else return 0;
        }
    };

    Numeric.equals = function(a, b) {
        return Math.abs(a - b) < Number.EPSILON;
    };

    Numeric.shortestPath360 = function(startLongitude, endLongitude) {
        var startLongValue, endLongValue;
        if (Math.abs(endLongitude - startLongitude) < 180.0) {
            startLongValue = startLongitude;
            endLongValue = endLongitude;
        } else {
            if (startLongitude < endLongitude) {
                startLongValue = startLongitude + 360;
                endLongValue = endLongitude;
            } else {
                startLongValue = startLongitude;
                endLongValue = endLongitude + 360;
            }
        }
        return [startLongValue, endLongValue];
    };

    Numeric.shortestPath180 = function(startLongitude, endLongitude) {
        var startLongValue, endLongValue;
        if (
            Math.sign(startLongitude) * Math.sign(endLongitude) > 0 ||
            Numeric.equals(startLongitude, 0) ||
            Numeric.equals(endLongitude, 0)
        ) {
            // 1st case:
            // Nothing to do because :
            // - the two values have the same sign
            // - and max(angle) <= 180 (longitude included in [-180,180]
            // so we have the shortest path
            startLongValue = startLongitude;
            endLongValue = endLongitude;
        } else {
            // we convert everything from [0 to 360]
            var longGeoCenter = (startLongitude + 360) % 360;
            var longGeoPos = (endLongitude + 360) % 360;
            var path = Numeric.shortestPath360(longGeoCenter, longGeoPos);
            startLongValue = path[0];
            endLongValue = path[1];
        }
        return [startLongValue, endLongValue];
    };

    /**************************************************************************************************************/

    return Numeric;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 *    Module with constants
 */
define('Tiling/HEALPixTables',[],function() {
    /**************************************************************************************************************/

    var HealPixTables = {
        ctab: [
            0,
            1,
            256,
            257,
            2,
            3,
            258,
            259,
            512,
            513,
            768,
            769,
            514,
            515,
            770,
            771,
            4,
            5,
            260,
            261,
            6,
            7,
            262,
            263,
            516,
            517,
            772,
            773,
            518,
            519,
            774,
            775,
            1024,
            1025,
            1280,
            1281,
            1026,
            1027,
            1282,
            1283,
            1536,
            1537,
            1792,
            1793,
            1538,
            1539,
            1794,
            1795,
            1028,
            1029,
            1284,
            1285,
            1030,
            1031,
            1286,
            1287,
            1540,
            1541,
            1796,
            1797,
            1542,
            1543,
            1798,
            1799,
            8,
            9,
            264,
            265,
            10,
            11,
            266,
            267,
            520,
            521,
            776,
            777,
            522,
            523,
            778,
            779,
            12,
            13,
            268,
            269,
            14,
            15,
            270,
            271,
            524,
            525,
            780,
            781,
            526,
            527,
            782,
            783,
            1032,
            1033,
            1288,
            1289,
            1034,
            1035,
            1290,
            1291,
            1544,
            1545,
            1800,
            1801,
            1546,
            1547,
            1802,
            1803,
            1036,
            1037,
            1292,
            1293,
            1038,
            1039,
            1294,
            1295,
            1548,
            1549,
            1804,
            1805,
            1550,
            1551,
            1806,
            1807,
            2048,
            2049,
            2304,
            2305,
            2050,
            2051,
            2306,
            2307,
            2560,
            2561,
            2816,
            2817,
            2562,
            2563,
            2818,
            2819,
            2052,
            2053,
            2308,
            2309,
            2054,
            2055,
            2310,
            2311,
            2564,
            2565,
            2820,
            2821,
            2566,
            2567,
            2822,
            2823,
            3072,
            3073,
            3328,
            3329,
            3074,
            3075,
            3330,
            3331,
            3584,
            3585,
            3840,
            3841,
            3586,
            3587,
            3842,
            3843,
            3076,
            3077,
            3332,
            3333,
            3078,
            3079,
            3334,
            3335,
            3588,
            3589,
            3844,
            3845,
            3590,
            3591,
            3846,
            3847,
            2056,
            2057,
            2312,
            2313,
            2058,
            2059,
            2314,
            2315,
            2568,
            2569,
            2824,
            2825,
            2570,
            2571,
            2826,
            2827,
            2060,
            2061,
            2316,
            2317,
            2062,
            2063,
            2318,
            2319,
            2572,
            2573,
            2828,
            2829,
            2574,
            2575,
            2830,
            2831,
            3080,
            3081,
            3336,
            3337,
            3082,
            3083,
            3338,
            3339,
            3592,
            3593,
            3848,
            3849,
            3594,
            3595,
            3850,
            3851,
            3084,
            3085,
            3340,
            3341,
            3086,
            3087,
            3342,
            3343,
            3596,
            3597,
            3852,
            3853,
            3598,
            3599,
            3854,
            3855
        ],
        utab: [
            0,
            1,
            4,
            5,
            16,
            17,
            20,
            21,
            64,
            65,
            68,
            69,
            80,
            81,
            84,
            85,
            256,
            257,
            260,
            261,
            272,
            273,
            276,
            277,
            320,
            321,
            324,
            325,
            336,
            337,
            340,
            341,
            1024,
            1025,
            1028,
            1029,
            1040,
            1041,
            1044,
            1045,
            1088,
            1089,
            1092,
            1093,
            1104,
            1105,
            1108,
            1109,
            1280,
            1281,
            1284,
            1285,
            1296,
            1297,
            1300,
            1301,
            1344,
            1345,
            1348,
            1349,
            1360,
            1361,
            1364,
            1365,
            4096,
            4097,
            4100,
            4101,
            4112,
            4113,
            4116,
            4117,
            4160,
            4161,
            4164,
            4165,
            4176,
            4177,
            4180,
            4181,
            4352,
            4353,
            4356,
            4357,
            4368,
            4369,
            4372,
            4373,
            4416,
            4417,
            4420,
            4421,
            4432,
            4433,
            4436,
            4437,
            5120,
            5121,
            5124,
            5125,
            5136,
            5137,
            5140,
            5141,
            5184,
            5185,
            5188,
            5189,
            5200,
            5201,
            5204,
            5205,
            5376,
            5377,
            5380,
            5381,
            5392,
            5393,
            5396,
            5397,
            5440,
            5441,
            5444,
            5445,
            5456,
            5457,
            5460,
            5461,
            16384,
            16385,
            16388,
            16389,
            16400,
            16401,
            16404,
            16405,
            16448,
            16449,
            16452,
            16453,
            16464,
            16465,
            16468,
            16469,
            16640,
            16641,
            16644,
            16645,
            16656,
            16657,
            16660,
            16661,
            16704,
            16705,
            16708,
            16709,
            16720,
            16721,
            16724,
            16725,
            17408,
            17409,
            17412,
            17413,
            17424,
            17425,
            17428,
            17429,
            17472,
            17473,
            17476,
            17477,
            17488,
            17489,
            17492,
            17493,
            17664,
            17665,
            17668,
            17669,
            17680,
            17681,
            17684,
            17685,
            17728,
            17729,
            17732,
            17733,
            17744,
            17745,
            17748,
            17749,
            20480,
            20481,
            20484,
            20485,
            20496,
            20497,
            20500,
            20501,
            20544,
            20545,
            20548,
            20549,
            20560,
            20561,
            20564,
            20565,
            20736,
            20737,
            20740,
            20741,
            20752,
            20753,
            20756,
            20757,
            20800,
            20801,
            20804,
            20805,
            20816,
            20817,
            20820,
            20821,
            21504,
            21505,
            21508,
            21509,
            21520,
            21521,
            21524,
            21525,
            21568,
            21569,
            21572,
            21573,
            21584,
            21585,
            21588,
            21589,
            21760,
            21761,
            21764,
            21765,
            21776,
            21777,
            21780,
            21781,
            21824,
            21825,
            21828,
            21829,
            21840,
            21841,
            21844,
            21845
        ],

        // coordinate of the lowest corner of each face
        jrll: [2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4],
        jpll: [1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7],

        xoffset: [-1, -1, 0, 1, 1, 1, 0, -1],
        yoffset: [0, 1, 1, 1, 0, -1, -1, -1],
        facearray: [
            [8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9], // S
            [5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8], // SE
            [-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1], // E
            [4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10], // SW
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], // center
            [1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4], // NE
            [-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1], // W
            [3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7], // NW
            [2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]
        ], // N
        swaparray: [
            [0, 0, 3], // S
            [0, 0, 6], // SE
            [0, 0, 0], // E
            [0, 0, 5], // SW
            [0, 0, 0], // center
            [5, 0, 0], // NE
            [0, 0, 0], // W
            [6, 0, 0], // NW
            [3, 0, 0]
        ], // N

        swap_cycle: [
            [],
            [0, 1, 8, 12, 16, 21, 40],
            [0, 1, 2, 40, 114],
            [0, 4, 160, 263],
            [0, 4, 30, 49, 51, 87, 526, 1027, 1105, 1387, 1807, 2637],
            [0, 8, 10, 18, 39, 74, 146, 307, 452, 4737],
            [0, 1, 2, 7, 9, 17, 80, 410, 1526, 1921, 32859, 33566, 38931],
            [
                0,
                5,
                6,
                10,
                12,
                24,
                27,
                95,
                372,
                494,
                924,
                1409,
                3492,
                4248,
                9137,
                66043,
                103369,
                156899
            ],
            [
                0,
                1,
                2,
                3,
                4,
                45,
                125,
                351,
                697,
                24337,
                102940,
                266194,
                341855,
                419857
            ],
            [
                0,
                1,
                2,
                3,
                9,
                16,
                1705,
                2082,
                2126,
                8177,
                12753,
                15410,
                52642,
                80493,
                83235,
                88387,
                99444,
                1675361,
                2495125
            ],
            [
                0,
                2,
                6,
                8,
                9,
                11,
                20,
                50,
                93,
                152,
                183,
                2137,
                13671,
                44794,
                486954,
                741908,
                4803258,
                5692573
            ],
            [
                0,
                1,
                5,
                6,
                44,
                53,
                470,
                2847,
                3433,
                4906,
                13654,
                14710,
                400447,
                1797382,
                2744492,
                18775974,
                23541521
            ],
            [
                0,
                4,
                9,
                10,
                16,
                33,
                83,
                117,
                318,
                451,
                5759,
                10015,
                128975,
                171834,
                211256,
                347608,
                1278690,
                2154097,
                2590798,
                3427694,
                5581717,
                21012301,
                27023976,
                72522811,
                95032729,
                139166747,
                171822389
            ],
            [
                0,
                5,
                10,
                267,
                344,
                363,
                2968,
                3159,
                9083,
                18437,
                76602,
                147614,
                1246902,
                1593138,
                2035574,
                6529391,
                9511830,
                11340287,
                29565945,
                281666026,
                677946848
            ]
        ]
    };

    return HealPixTables;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Long',[],function() {
    /**
     * @name Long
     * @class
     *   Long class for only unsigned integers
     *  Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     *  values as *signed* integers.  See the from* functions below for more
     *  convenient ways of constructing Longs.
     *
     *  The internal representation of a long is the two given signed, 32-bit values.
     *  We use 32-bit pieces because these are the size of integers on which
     *  Javascript performs bit-operations.  For operations like addition and
     *  multiplication, we split each number into 16-bit pieces, which can easily be
     *  multiplied within Javascript's floating-point representation without overflow
     *  or change in sign.
     *
     *  In the algorithms below, we frequently reduce the negative case to the
     *  positive case by negating the input(s) and then post-processing the result.
     *  Note that we must ALWAYS check specially whether those values are MIN_VALUE
     *  (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     *  a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     * @constructor
     * @param {number} low  The low (signed) 32 bits of the long.
     * @param {number} high  The high (signed) 32 bits of the long.
     */
    var Long = function(low, high) {
        /**
         * @type {number}
         * @private
         */
        this.low_ = low | 0; // force into 32 signed bits.

        /**
         * @type {number}
         * @private
         */
        this.high_ = high | 0; // force into 32 signed bits.
    };

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @private
     */
    Long.IntCache_ = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @function fromInt
     * @memberof Long
     * @param {number} value The 32-bit integer in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromInt = function(value) {
        if (-128 <= value && value < 128) {
            var cachedObj = Long.IntCache_[value];
            if (cachedObj) {
                return cachedObj;
            }
        }

        var obj = new Long(value | 0, value < 0 ? -1 : 0);
        if (-128 <= value && value < 128) {
            Long.IntCache_[value] = obj;
        }
        return obj;
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @function fromNumber
     * @memberof Long
     * @param {number} value The number in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromNumber = function(value) {
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (value <= -Long.TWO_PWR_63_DBL_) {
            return Long.MIN_VALUE;
        } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
            return Long.MAX_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value).negate();
        } else {
            return new Long(
                value % Long.TWO_PWR_32_DBL_ | 0,
                (value / Long.TWO_PWR_32_DBL_) | 0
            );
        }
    };

    /**
     * Returns a Long representing the 64-bit integer that comes by concatenating
     * the given high and low bits.  Each is assumed to use 32 bits.
     * @function fromBits
     * @memberof Long
     * @param {number} lowBits The low 32-bits.
     * @param {number} highBits The high 32-bits.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromBits = function(lowBits, highBits) {
        return new Long(lowBits, highBits);
    };

    /**
     * Number used repeated below in calculations.  This must appear before the
     * first call to any from* function below.
     * @type {number}
     * @private
     */
    Long.TWO_PWR_16_DBL_ = 1 << 16;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_24_DBL_ = 1 << 24;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;

    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

    /** @type {!Long} */
    Long.ZERO = Long.fromInt(0);

    /** @type {!Long} */
    Long.ONE = Long.fromInt(1);

    /** @type {!Long} */
    Long.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0);

    /** @type {!Long} */
    Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

    /**
     * @type {!Long}
     * @private
     */
    Long.TWO_PWR_24_ = Long.fromInt(1 << 24);

    /** @return {number} The value, assuming it is a 32-bit integer. */
    Long.prototype.toInt = function() {
        return this.low_;
    };

    /** @return {number} The closest floating-point representation to this value. */
    Long.prototype.toNumber = function() {
        return this.high_ * Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };

    /** @return {number} The low 32-bits as an unsigned value. */
    Long.prototype.getLowBitsUnsigned = function() {
        return this.low_ >= 0 ? this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
    };

    /** @return {boolean} Whether this value is zero. */
    Long.prototype.isZero = function() {
        return this.high_ === 0 && this.low_ === 0;
    };

    /** @return {boolean} Whether this value is negative. */
    Long.prototype.isNegative = function() {
        return this.high_ < 0;
    };

    /** @return {boolean} Whether this value is odd. */
    Long.prototype.isOdd = function() {
        return (this.low_ & 1) === 1;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     */
    Long.prototype.equals = function(other) {
        return this.high_ === other.high_ && this.low_ === other.low_;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     */
    Long.prototype.lessThan = function(other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     */
    Long.prototype.greaterThanOrEqual = function(other) {
        return this.compare(other) >= 0;
    };

    /**
     * Compares this Long with the given one.
     * @function compare
     * @memberof Long.prototype
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     */
    Long.prototype.compare = function(other) {
        if (this.equals(other)) {
            return 0;
        }

        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) {
            return -1;
        }
        if (!thisNeg && otherNeg) {
            return 1;
        }

        // at this point, the signs are the same, so subtraction will not overflow
        if (this.subtract(other).isNegative()) {
            return -1;
        } else {
            return 1;
        }
    };

    /**
     * Return the negation
     * @function negate
     * @memberof Long.prototype
     * @return {!Long} The negation of this value.
     */
    Long.prototype.negate = function() {
        if (this.equals(Long.MIN_VALUE)) {
            return Long.MIN_VALUE;
        } else {
            return this.not().add(Long.ONE);
        }
    };

    /**
     * Returns the sum of this and the given Long.
     * @function add
     * @memberof Long.prototype
     * @param {Long} other Long to add to this one.
     * @return {!Long} The sum of this and the given Long.
     */
    Long.prototype.add = function(other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xffff;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xffff;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xffff;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xffff;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 + b48;
        c48 &= 0xffff;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

    /**
     * Returns the difference of this and the given Long.
     * @function subtract
     * @memberof Long.prototype
     * @param {Long} other Long to subtract from this.
     * @return {!Long} The difference of this and the given Long.
     */
    Long.prototype.subtract = function(other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @function multiply
     * @memberof Long.prototype
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
     */
    Long.prototype.multiply = function(other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate()
                    .multiply(other)
                    .negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }

        // If both longs are small, use float multiplication
        if (
            this.lessThan(Long.TWO_PWR_24_) &&
            other.lessThan(Long.TWO_PWR_24_)
        ) {
            return Long.fromNumber(this.toNumber() * other.toNumber());
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xffff;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xffff;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xffff;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xffff;

        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xffff;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xffff;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xffff;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xffff;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

    /** @return {!Long} The bitwise-NOT of this value. */
    Long.prototype.not = function() {
        return Long.fromBits(~this.low_, ~this.high_);
    };

    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @function and
     * @memberof Long.prototype
     * @param {Long} other The Long with which to AND.
     * @return {!Long} The bitwise-AND of this and the other.
     */
    Long.prototype.and = function(other) {
        return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };

    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @function or
     * @memberof Long.prototype
     * @param {Long} other The Long with which to OR.
     * @return {!Long} The bitwise-OR of this and the other.
     */
    Long.prototype.or = function(other) {
        return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };

    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @function shiftRightUnsigned
     * @memberof Long.prototype
     * @param {number} numBits The number of bits by which to shift.
     * @return {!Long} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     */
    Long.prototype.shiftRightUnsigned = function(numBits) {
        numBits &= 63;
        if (numBits === 0) {
            return this;
        } else {
            var high = this.high_;
            if (numBits < 32) {
                var low = this.low_;
                return Long.fromBits(
                    (low >>> numBits) | (high << (32 - numBits)),
                    high >>> numBits
                );
            } else if (numBits === 32) {
                return Long.fromBits(high, 0);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0);
            }
        }
    };

    /**************************************************************************************************************/

    return Long;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/CircleFinder',[], function() {
    /**************************************************************************************************************/

    var center, cosrad;

    var CircleFinder = function(point) {
        //CircleFinder.prototype.constructor.call(this, point);

        np = point.length;
        //HealpixUtils.check(np >= 3, "too few points");

        center = vec3.add2(point[0], point[1]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[0], center);
        for (i = 2; i < np; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                this.getCircle(point, i);
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCircle = function(point, q1, q2) {
        center = vec3.add2(point[q1], point[q2]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[q1], center);
        for (i = 0; i < q1; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                var subPoint = vec3.subtract2(point[q1], point[i]);
                var subPoint2 = vec3.subtract2(point[q2], point[i]);
                center = vec3.cross2(subPoint, subPoint2);
                center = vec3.normalize2(center);
                cosrad = vec3.dot2(point[q1], center);
                if (cosrad < 0) {
                    center = vec3.flip(center);
                    cosrad = -cosrad;
                }
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCircle = function(point, q) {
        center = vec3.add2(point[0], point[q]);
        center = vec3.normalize2(center);
        cosrad = vec3.dot2(point[0], center);
        for (i = 1; i < q; ++i) {
            if (vec3.dot2(point[i], center) < cosrad) {
                // point outside the current circle
                this.getCircle(point, i, q);
            }
        }
    };

    /**************************************************************************************************************/

    CircleFinder.prototype.getCenter = function() {
        return center;
    };

    CircleFinder.prototype.getCosRad = function() {
        return cosrad;
    };

    return CircleFinder;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/HEALPixBase',["./HEALPixTables", "../Utils/Long", "../Utils/CircleFinder"], function(
    HealPixTables,
    Long,
    CircleFinder
) {
    /**************************************************************************************************************/

    var HALF_PI = 3.14159265 / 2;

    var lonLat2ang = function(lon, lat) {
        if (lon < 0) {
            lon += 360;
        }

        var phi = (lon * Math.PI) / 180.0;

        var theta = ((-lat + 90.0) * Math.PI) / 180.0;
        return [phi, theta];
    };

    /**************************************************************************************************************/

    /** Returns the remainder of the division {@code v1/v2}.
     The result is non-negative.
     @param v1 dividend; can be positive or negative
     @param v2 divisor; must be positive
     @return Remainder of the division; positive and smaller than {@code v2} */
    var fmodulo = function(v1, v2) {
        if (v1 >= 0.0) {
            return v1 < v2 ? v1 : v1 % v2;
        }
        var tmp = (v1 % v2) + v2;
        return tmp === v2 ? 0.0 : tmp;
    };

    /**************************************************************************************************************/

    var spread_bits = function(v) {
        return (
            HealPixTables.utab[v & 0xff] |
            (HealPixTables.utab[(v >>> 8) & 0xff] << 16) |
            (HealPixTables.utab[(v >>> 16) & 0xff] << 32) |
            (HealPixTables.utab[(v >>> 24) & 0xff] << 48)
        );
    };

    /**************************************************************************************************************/

    var xyf2nest = function(ix, iy, face_num, order) {
        return (
            (face_num << (2 * order)) + spread_bits(ix) + (spread_bits(iy) << 1)
        );
    };

    /**************************************************************************************************************/

    var loc2pix = function(order, phi, theta) {
        var nside2 = Math.pow(2, order);
        var z = Math.cos(theta);
        //var phi = phi;

        var loc = {
            phi: phi,
            theta: theta,
            z: z
        };

        if (Math.abs(z) > 9.0 / 10.0) {
            loc.sth = Math.sin(theta);
            loc.have_sth = true;
        }

        var inv_halfpi = 2.0 / Math.PI;
        var tt = fmodulo(phi * inv_halfpi, 4.0); // in [0,4)
        var jp, jm, nSideMinusOne;
        var za = Math.abs(z);
        if (za <= 2.0 / 3.0) {
            // Equatorial region
            var temp1 = nside2 * (0.5 + tt);
            var temp2 = nside2 * (z * 0.75);

            jp = Long.fromNumber(temp1 - temp2);
            jm = Long.fromNumber(temp1 + temp2);
            var ifp = jp.shiftRightUnsigned(order);
            var ifm = jm.shiftRightUnsigned(order);
            var face_num;
            if (ifp.equals(ifm)) {
                face_num = ifp.or(Long.fromInt(4));
            } else {
                if (ifp.lessThan(ifm)) {
                    face_num = ifp;
                } else {
                    face_num = ifm.add(Long.fromInt(8));
                }
            }

            nSideMinusOne = Long.fromNumber(nside2 - 1);
            var ix = jm.and(nSideMinusOne);
            var iy = nSideMinusOne.subtract(jp.and(nSideMinusOne));

            return xyf2nest(ix.toInt(), iy.toInt(), face_num.toInt(), order);
        } // polar region, za > 2/3
        else {
            var ntt = parseInt(Math.min(3, parseInt(tt, 10)), 10);
            var tp = tt - ntt;
            var tmp =
                za < 9.0 / 10.0 || !loc.have_sth
                    ? nside2 * Math.sqrt(3 * (1 - za))
                    : (nside2 * loc.sth) / Math.sqrt((1.0 + za) / 3.0);

            jp = Long.fromNumber(tp * tmp);
            jm = Long.fromNumber((1.0 - tp) * tmp);
            var lNside = Long.fromNumber(nside2);
            nSideMinusOne = Long.fromNumber(nside2 - 1.0);
            var lOne = Long.fromInt(1);
            if (jp.greaterThanOrEqual(lNside)) {
                jp = nSideMinusOne;
            }
            if (jm.greaterThanOrEqual(lNside)) {
                jm = nSideMinusOne;
            }

            if (z >= 0) {
                return xyf2nest(
                    lNside
                        .subtract(jm)
                        .subtract(lOne)
                        .toInt(),
                    lNside
                        .subtract(jp)
                        .subtract(lOne)
                        .toInt(),
                    ntt,
                    order
                );
            } else {
                return xyf2nest(jp.toInt(), jm.toInt(), ntt + 8, order);
            }
        }
    };

    var pstack = function(sz) {
        this.p = new Array(sz);
        this.o = new Array(sz);

        for (var i = 0; i < this.p.length; i++) {
            //this.p[i] = Long.fromInt(0);
            this.p[i] = 0;
            this.o[i] = 0;
        }

        this.s = this.m = 0;
    };

    pstack.prototype.push = function(p_, o_) {
        this.p[this.s] = p_;
        this.o[this.s] = o_;
        ++this.s;
    };

    pstack.prototype.otop = function() {
        return this.o[this.s - 1];
    };

    pstack.prototype.ptop = function() {
        return this.p[this.s - 1];
    };

    pstack.prototype.pop = function() {
        this.s--;
    };

    pstack.prototype.popToMark = function() {
        this.s = this.m;
    };

    pstack.prototype.mark = function() {
        this.m = this.s;
    };

    pstack.prototype.size = function() {
        return this.s;
    };

    /**************************************************************************************************************/

    var HEALPixBase = {
        init: function(options) {
            this.order_max = 29;
            this.bn = [];
            this.nside = null;

            try {
                for (var i = 0; i <= this.order_max; ++i) {
                    this.bn[i] = this.createBoundaries(1.0 << i, "NESTED");
                }
            } catch (ex) {
                /*doesn't happen*/
            }
        },

        createBoundaries: function(nside_in, scheme_in) {
            this.nside = nside_in - 1;
            return this.calculateBoundaries(nside_in, scheme_in);
        },

        compress_bits: function(v) {
            var longV = Long.fromNumber(v);
            var longMask = Long.fromNumber(0x5555555555555);
            var raw = longV.and(longMask);
            var dec = raw.shiftRightUnsigned(15);
            raw = raw.or(dec);
            var raw1 = raw.and(Long.fromNumber(0xffff)).toInt();
            var dec2 = raw.shiftRightUnsigned(32);
            var raw2 = dec2.and(Long.fromNumber(0xffff)).toInt();

            return (
                HealPixTables.ctab[raw1 & 0xff] |
                (HealPixTables.ctab[raw1 >>> 8] << 4) |
                (HealPixTables.ctab[raw2 & 0xff] << 16) |
                (HealPixTables.ctab[raw2 >>> 8] << 20)
            );
        },

        /**
         *    Function describing a location on the sphere
         */
        fxyf: function(_fx, _fy, _face) {
            var jr = HealPixTables.jrll[_face] - _fx - _fy;
            var z = 0;
            var phi = 0;
            var sth = 0;
            var have_sth = false;

            var nr, tmp;
            if (jr < 1) {
                nr = jr;
                tmp = (nr * nr) / 3.0;
                z = 1 - tmp;
                if (z > 0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else if (jr > 3) {
                nr = 4 - jr;
                tmp = (nr * nr) / 3.0;
                z = tmp - 1;
                if (z < -0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else {
                nr = 1;
                z = ((2 - jr) * 2.0) / 3.0;
            }

            tmp = HealPixTables.jpll[_face] * nr + _fx - _fy;
            if (tmp < 0) {
                tmp += 8;
            }
            if (tmp >= 8) {
                tmp -= 8;
            }

            phi = nr < 1e-15 ? 0 : (0.5 * HALF_PI * tmp) / nr;

            var st = have_sth ? sth : Math.sqrt((1.0 - z) * (1.0 + z));
            return [st * Math.cos(phi), st * Math.sin(phi), z];
        },

        /** Returns the maximum angular distance between a pixel center and its
         corners.
         @return number angular distance between a pixel center and its
         corners. */
        maxPixrad: function(order, nl4) {
            var nside2 = Math.pow(2, order);
            var va = vec3.createZPhi(2.0 / 3.0, Math.PI / nl4);
            var t1 = 1.0 - 1.0 / nside2;
            t1 *= t1;
            var vb = vec3.createZPhi(1 - t1 / 3, 0);
            return vec3.angle2(va, vb);
        },

        pix2vec: function(pix, boundaries) {
            var loc = this.pix2loc(pix, boundaries);
            var st = loc.have_sth
                ? loc.sth
                : Math.sqrt((1.0 - loc.z) * (1.0 + loc.z));
            return vec3.createFrom(
                st * Math.cos(loc.phi),
                st * Math.sin(loc.phi),
                loc.z
            );
        },

        pix2loc: function(pix, boundaries) {
            var z, phi, sth, have_sth;

            //var fact2 = 4.0 / pix;
            //var fact1 = (nside << 1) * fact2;
            //var nl2 = 2 * nside;
            //var nl3 = 3 * nside;
            //var nl4 = 4 * nside;
            //var npface = nside * nside;
            //var ncap = 2 * nside * (nside - 1); // pixels in each polar cap
            //var npix = 12 * npface;
            //var fact2 = 4.0 / npix;
            //var fact1 = (nside << 1) * fact2;

            var loc = {
                phi: null,
                sth: 0.0,
                have_sth: false,
                z: null
            };

            var xyf = this.nest2xyf(pix, boundaries.npface, boundaries.order);

            var jr =
                (HealPixTables.jrll[xyf.face] << boundaries.order) -
                xyf.ix -
                xyf.iy -
                1;

            var nr, tmp;
            if (jr < boundaries.nside) {
                nr = jr;
                tmp = nr * nr * boundaries.fact2;
                loc.z = 1 - tmp;
                if (loc.z > 0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            } else if (jr > boundaries.nl3) {
                nr = boundaries.nl4 - jr;
                tmp = nr * nr * boundaries.fact2;
                loc.z = tmp - 1;
                if (loc.z < -0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            } else {
                nr = boundaries.nside;
                loc.z = (boundaries.nl2 - jr) * boundaries.fact1;
            }

            tmp = HealPixTables.jpll[xyf.face] * nr + xyf.ix - xyf.iy;
            //assert (tmp < 8 * nr); // must not happen

            if (tmp < 0) {
                tmp += 8 * nr;
            }

            loc.phi =
                nr === boundaries.nside
                    ? 0.75 * HALF_PI * tmp * boundaries.fact1
                    : (0.5 * HALF_PI * tmp) / nr;
            return loc;
        },

        nest2xyf: function(ipix, npface, order) {
            var pix = ipix & (npface - 1);

            var ix = HEALPixBase.compress_bits(pix);
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            var face = ipix >>> (2 * order);

            return {
                ix: ix,
                iy: iy,
                face: face
            };
        },

        /**
         *    Static function
         *    Convert nside to order
         *    (ilog2(nside))
         */
        nside2order: function(arg) {
            var res = 0;
            while (arg > 0x0000ffff) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000ff) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000f) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },

        calculateBoundaries: function(nside_in, scheme_in) {
            if (this.nside === nside_in) {
                return;
            }
            this.nside = nside_in;

            var order = this.nside2order(nside_in);

            if (scheme_in === "NESTED" && order < 0) {
                throw new Exception(
                    "Nside must be a power of 2 for NESTED scheme"
                );
            }

            var nl2 = 2 * this.nside;
            var nl3 = 3 * this.nside;
            var nl4 = 4 * this.nside;
            var npface = this.nside * this.nside;
            var ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap
            var npix = 12 * npface;
            var fact2 = 4.0 / npix;
            var fact1 = (this.nside << 1) * fact2;

            return {
                order: order,
                nside: this.nside,
                scheme: scheme_in,
                nl2: nl2,
                nl3: nl3,
                nl4: nl4,
                npface: npface,
                ncap: ncap,
                npix: npix,
                fact1: fact1,
                fact2: fact2
            };
        },

        // MATH lib from Java Astro lib

        convertPolygonToHealpixOrder: function(coordinates, fact, order) {
            var vertex = [];
            var factor = fact || 4;
            var healpixOrder = order || 5;

            _.each(coordinates, function(point) {
                var cPr = Math.PI / 180;

                var cd = Math.cos(point[1] * cPr);
                var x = Math.cos(point[0] * cPr) * cd;
                var y = Math.sin(point[0] * cPr) * cd;
                var z = Math.sin(point[1] * cPr);

                var theta = Math.atan2(Math.sqrt(x * x + y * y), z);
                var phi = Math.atan2(y, x);
                if (phi < 0.0) {
                    phi += 2 * Math.PI;
                }
                if (phi >= 2 * Math.PI) {
                    phi -= 2 * Math.PI;
                }

                vertex.push({
                    theta: theta,
                    phi: phi
                });
            });

            return this.queryPolygonInclusive(vertex, factor, healpixOrder);
        },

        queryPolygonInclusive: function(vertex, fact, healpixOrder) {
            Math.PI = 3.14159265358979323846;
            var halfpi = Math.PI / 2.0;

            var inclusive = fact !== 0;
            var nv = vertex.length;
            var ncirc = inclusive ? nv + 1 : nv;

            if (nv < 3) {
                console.error("not enough vertices in polygon");
                return;
            }

            var vv = new Array(nv);
            var i;
            for (i = 0; i < nv; ++i) {
                vv[i] = vec3.createPhiTheta(vertex[i].phi, vertex[i].theta);
            }

            var normal = new Array(ncirc);
            var flip = 0;

            for (i = 0; i < nv; ++i) {
                normal[i] = vec3.cross2(vv[i], vv[(i + 1) % nv]);

                //var hnd = normal[i].dot(vv[(i + 2) % nv]);
                var hnd = vec3.dot2(normal[i], vv[(i + 2) % nv]);

                if (i === 0) {
                    flip = hnd < 0.0 ? -1 : 1;
                }

                normal[i] = vec3.scale2(
                    normal[i],
                    flip / vec3.length2(normal[i])
                );
            }

            var rad = new Array(ncirc);
            this.fill(rad, halfpi);

            if (inclusive) {
                var cf = new CircleFinder(vv);

                normal[nv] = cf.getCenter();
                rad[nv] = Math.acos(cf.getCosRad());
            }

            var res = this.queryMultiDisc(normal, rad, fact, healpixOrder);
            console.dir(res);
            return res;
        },

        fill: function(a, val) {
            for (var i = 0, len = a.length; i < len; i++) {
                a[i] = val;
            }
        },

        queryMultiDisc: function(norm, rad, fact, healpixOrder) {
            var order = healpixOrder;
            var inclusive = fact !== 0;
            var nv = norm.length;
            //HealpixUtils.check(nv == rad.length, "inconsistent input arrays");
            var res = [];

            var oplus = 0;
            if (inclusive) {
                //HealpixUtils.check((1L << (order_max - order)) >= fact, "invalid oversampling factor");
                //HealpixUtils.check((fact & (fact - 1)) == 0, "oversampling factor must be a power of 2");
                oplus = this.ilog2(fact);
            }
            var omax = order + oplus; // the order up to which we test
            var currentBoundaries;

            // TODO: ignore all disks with radius>=pi

            // building 3 dimensions array
            var crlimit = new Array(omax + 1);
            for (var i = 0; i < omax + 1; i++) {
                crlimit[i] = new Array(nv);
                for (var j = 0; j < nv; j++) {
                    crlimit[i][j] = new Array(3);
                }
            }

            var options = {
                order: order
            };
            HEALPixBase.init(options); // set variables nl2, nl3, npix, nface...
            var o;
            for (
                o = 0;
                o <= omax;
                ++o // prepare data at the required orders
            ) {
                currentBoundaries = HEALPixBase.bn[o];
                var dr = HEALPixBase.maxPixrad(o, currentBoundaries.nl4); // safety distance

                for (i = 0; i < nv; ++i) {
                    crlimit[o][i][0] =
                        rad[i] + dr > Math.PI ? -1 : Math.cos(rad[i] + dr);
                    crlimit[o][i][1] =
                        o === 0 ? Math.cos(rad[i]) : crlimit[0][i][1];
                    crlimit[o][i][2] =
                        rad[i] - dr < 0.0 ? 1.0 : Math.cos(rad[i] - dr);
                }
            }

            var stk = new pstack(12 + 3 * omax);
            for (i = 0; i < 12; i++) {
                // insert the 12 base pixels in reverse order
                stk.push(11 - i, 0);
            }

            while (stk.size() > 0) {
                // as long as there are pixels on the stack
                // pop current pixel number and order from the stack
                var pix = stk.ptop();
                o = stk.otop();
                stk.pop();

                currentBoundaries = HEALPixBase.bn[o];

                var pv = HEALPixBase.pix2vec(pix, currentBoundaries);

                var zone = 3;
                for (i = 0; i < nv && zone > 0; ++i) {
                    var crad = vec3.dot2(pv, norm[i]);

                    for (var iz = 0; iz < zone; ++iz) {
                        if (crad < crlimit[o][i][iz]) {
                            zone = iz;
                            //console.log("zone :" + zone + " pix:" + pix + " crad:" + crad);
                        }
                    }
                }

                if (zone > 0) {
                    this.check_pixel(
                        o,
                        omax,
                        zone,
                        res,
                        pix,
                        stk,
                        inclusive,
                        healpixOrder
                    );
                }
            }
            return res;
        },

        check_pixel: function(
            o,
            omax,
            zone,
            pixset,
            pix,
            stk,
            inclusive,
            healpixOrder
        ) {
            var order = healpixOrder;
            var i;
            if (zone === 0) {
                return;
            }

            if (o < order) {
                if (zone >= 3) {
                    // output all subpixels
                    var sdist = 2 * (order - o); // the "bit-shift distance" between map orders
                    var start = pix << sdist;
                    var end = (pix + 1) << sdist;
                    for (i = start; i <= end; i++) {
                        pixset.push(i);
                    }
                } else {
                    // (zone>=1)
                    for (i = 0; i < 4; ++i) {
                        stk.push(4 * pix + 3 - i, o + 1); // add children
                    }
                }
            } else if (o > order) {
                // this implies that inclusive==true
                if (zone >= 2) {
                    // pixel center in shape
                    pixset.push(pix >>> (2 * (o - order))); // output the parent pixel at order
                    stk.popToMark(); // unwind the stack
                } // (zone>=1): pixel center in safety range
                else {
                    if (o < omax) {
                        // check sublevels
                        for (i = 0; i < 4; ++i) {
                            // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix >>> (2 * (o - order))); // output the parent pixel at order
                        stk.popToMark(); // unwind the stack
                    }
                }
            } // o==order
            else {
                if (zone >= 2) {
                    pixset.push(pix);
                } else if (inclusive) {
                    // and (zone>=1)
                    if (order < omax) {
                        // check sublevels
                        stk.mark(); // remember current stack position
                        for (i = 0; i < 4; ++i) {
                            // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix); // output the pixel
                    }
                }
            }
        },

        ilog2: function(arg) {
            var res = 0;
            while (arg > 0x0000ffff) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000ff) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000f) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },
        /**
         *    Returns pixel index of point on sphere
         *
         *    @param order Tile order
         *    @param lon Longitude
         *    @param lat Latitude
         */
        lonLat2pix: function(order, lon, lat) {
            var loc = lonLat2ang(lon, lat);
            return loc2pix(order, loc[0], loc[1]);
        },

        /**
         Create the children of the given pixel
         */
        getChildren: function(npix) {
            return [npix * 4, npix * 4 + 1, npix * 4 + 2, npix * 4 + 3];
        },

        uniq2hpix: function(uniq, hpix) {
            if (hpix == null) {
                hpix = [];
            }
            hpix[0] = HEALPixBase.log2(uniq / 4) / 2;
            var nside = HEALPixBase.pow2(hpix[0]);
            hpix[1] = uniq - 4 * nside * nside;
            hpix[0] = parseInt(hpix[0], 10);
            return hpix;
        },

        log2: function(nside) {
            var i = 0;
            while (nside >>> ++i > 0) {
                // nop
            }
            return --i;
        },

        pow2: function(order) {
            return 1 << order;
        },

        /**
         * calculates angular resolution of the pixel map in arc seconds.
         *
         * @param nside
         * @return double resolution in arcsec
         */
        getPixRes: function(nside) {
            var rad2arcsec = (180.0 * 60.0 * 60.0) / Math.PI;
            return rad2arcsec * Math.sqrt((4 * Math.PI) / (12 * nside * nside));
        }
    };

    /**************************************************************************************************************/

    return HEALPixBase;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/UtilsIntersection',["./Numeric", "../Tiling/HEALPixBase"], function(Numeric, HEALPixBase) {
    var UtilsIntersection = {};

    UtilsIntersection.convertPolygonToHealpixOrder = function(
        coordinates,
        fact,
        order
    ) {
        return HEALPixBase.convertPolygonToHealpixOrder(
            coordinates,
            fact,
            order
        );
    };

    /**
     * Check if a point lies on a line
     * @param point
     * @param segmentStart
     * @param segmentEnd
     * @returns {boolean}
     */
    UtilsIntersection.pointInLine = function(point, segmentStart, segmentEnd) {
        var deltax = segmentEnd[0] - segmentStart[0];
        var deltay, t;
        var liesInXDir = false;

        if (deltax === 0) {
            liesInXDir = point[0] === segmentStart[0];
        } else {
            t = (point[0] - segmentStart[0]) / deltax;
            liesInXDir = t >= 0 && t <= 1;
        }

        if (liesInXDir) {
            deltay = segmentEnd[1] - segmentStart[1];
            if (deltax === 0) {
                return point[1] === segmentStart[1];
            } else {
                t = (point[1] - segmentStart[1]) / deltay;
                return t >= 0 && t <= 1;
            }
        } else {
            return false;
        }
    };

    /**
     *    Determine if a point lies inside a sphere of radius depending on viewport
     */
    UtilsIntersection.pointInSphere = function(
        ctx,
        point,
        sphere,
        pointTextureHeight
    ) {
        var point3D = [];
        var sphere3D = [];

        // Compute pixel size vector to offset the points from the earth
        var pixelSizeVector = ctx.getRenderContext().computePixelSizeVector();

        ctx.getCoordinateSystem().get3DFromWorld(point, point3D);
        ctx.getCoordinateSystem().get3DFromWorld(sphere, sphere3D);

        var radius =
            pointTextureHeight *
            (pixelSizeVector[0] * sphere3D[0] +
                pixelSizeVector[1] * sphere3D[1] +
                pixelSizeVector[2] * sphere3D[2] +
                pixelSizeVector[3]);

        //Calculate the squared distance from the point to the center of the sphere
        var vecDist = [];
        vec3.subtract(point3D, sphere3D, vecDist);
        vecDist = vec3.dot(vecDist, vecDist);

        //Calculate if the squared distance between the sphere's center and the point
        //is less than the squared radius of the sphere
        if (vecDist < radius * radius) {
            return true;
        }

        //If not, return false
        return false;
    };

    /**
     * Convert spherical coordinate to cartesian
     */
    function to3D(pt) {
        var lon = (pt[0] * Math.PI) / 180;
        var lat = (pt[1] * Math.PI) / 180;
        var x = Math.cos(lat) * Math.cos(lon);
        var y = Math.cos(lat) * Math.sin(lon);
        var z = Math.sin(lat);
        return [x, y, z];
    }

    function greatArcIntersection(a0, a1, b0, b1) {
        var p = vec3.cross(a0, a1, []);
        var q = vec3.cross(b0, b1, []);
        var t = vec3.normalize(vec3.cross(p, q, []));

        var s1 = vec3.dot(vec3.cross(a0, p, []), t);
        var s2 = vec3.dot(vec3.cross(a1, p, []), t);
        var s3 = vec3.dot(vec3.cross(b0, q, []), t);
        var s4 = vec3.dot(vec3.cross(b1, q, []), t);

        var st =
            Numeric.sign(-s1) +
            Numeric.sign(s2) +
            Numeric.sign(-s3) +
            Numeric.sign(s4);
        return Math.abs(st) === 4;
    }

    /**
     * Point in ring with spherical geometry
     */
    UtilsIntersection.pointInRing = function(point, ring) {
        var nvert = ring.length;
        var nbinter = 0;

        var p0 = to3D(point);
        var p1 = to3D([point[0], point[1] + 90]);

        for (var i = 0; i < nvert - 1; i++) {
            if (
                greatArcIntersection(to3D(ring[i]), to3D(ring[i + 1]), p0, p1)
            ) {
                nbinter++;
            }
        }
        return nbinter % 2 === 1;
    };

    /**
     * Checks if a value v is between the interval [min, max].
     * @function isValueBetween
     * @param {float} v - value
     * @param {float} min - min value
     * @param {float} max - max value
     * @return {boolean} true when v is between min and max otherwise talse
     */
    UtilsIntersection.isValueBetween = function(v, min, max) {
        return v >= min && v <= max;
    };

    /**
     * Checks is two bounding boxes intersect
     * @function boundsIntersects
     * @param {{west:float, north:float, east:float, south:float}} a - bounding box
     * @param {{west:float, north:float, east:float, south:float}} b - bounding box
     * @return {boolean} true when the two bounding boxes intersect otherwise false
     */
    UtilsIntersection.boundsIntersects = function(a, b) {
        if (a === null || b === null) {
            return false;
        }
        if (
            a.north === null ||
            typeof a.north === "undefined" ||
            b.north === null ||
            typeof b.north === "undefined"
        ) {
            return false;
        }
        var xOk =
            UtilsIntersection.isValueBetween(a.west, b.west, b.east) ||
            UtilsIntersection.isValueBetween(a.east, b.west, b.east) ||
            (a.west <= b.west && a.east >= b.east);

        var yOk =
            UtilsIntersection.isValueBetween(a.north, b.south, b.north) ||
            UtilsIntersection.isValueBetween(a.south, b.south, b.north) ||
            (a.south <= b.south && a.north >= b.north);

        return xOk && yOk;
    };

    /**
     * Checks if the coordinates cross the date line.
     * @function isCrossDateLine
     * @param {float} minLong - min longitude
     * @param {float} maxLong - max longitude
     * @return {boolean} true when the coordinates cross the date line otherwise false
     */
    UtilsIntersection.isCrossDateLine = function(minLong, maxLong) {
        return Math.abs(minLong - maxLong) > 180;
    };

    return UtilsIntersection;
});

define('Error/NetworkError',[], function() {
    var NetworkError = function() {
        var superInstance = Error.apply(null, arguments);
        this.name = "NetworkError";
        this.code = arguments.length > 2 ? arguments[2] : null;
        copyOwnPropertiesFrom(this, superInstance);
        this.layerDescription = null;
    };

    function copyOwnPropertiesFrom(target, source) {
        Object.getOwnPropertyNames(source).forEach(function(propKey) {
            var desc = Object.getOwnPropertyDescriptor(source, propKey);
            Object.defineProperty(target, propKey, desc);
        });
        return target;
    }

    NetworkError.prototype = Object.create(Error.prototype);

    NetworkError.prototype.constructor = NetworkError;

    NetworkError.prototype.setLayerDescription = function(layerDescription) {
        this.layerDescription = layerDescription;
    };

    NetworkError.prototype.getLayerDescription = function() {
        return this.layerDescription;
    };

    return NetworkError;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Utils',[
    "jquery",
    "moment",
    "./Numeric",
    "./UtilsIntersection",
    "../Error/NetworkError"
], function($, Moment, Numeric, UtilsIntersection, NetworkError) {
    var Utils = {};

    /**
     * Inherits from an object
     */
    Utils.inherits = function(base, sub) {
        function tempCtor() {}

        tempCtor.prototype = base.prototype;
        sub.prototype = new tempCtor();
        sub.prototype.constructor = sub;
    };

    /**
     *    HSV values in [0..1[
     *    returns [r, g, b] values from 0 to 255
     */
    function hsv_to_rgb(h, s, v) {
        var h_i = Math.floor(h * 6);
        var f = h * 6 - h_i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var r;
        var g;
        var b;
        switch (h_i) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
            default:
                r = 1;
                g = 1;
                b = 1;
        }
        return [r, g, b];
    }

    /**
     * Generates eye-friendly color based on hsv.
     * @return {int[]} rgb array
     */
    Utils.generateColor = function() {
        //use golden ratio
        var golden_ratio_conjugate = 0.618033988749895;
        var h = Math.random();
        h += golden_ratio_conjugate;
        h %= 1;
        return hsv_to_rgb(h, 0.5, 0.95);
    };

    /**
     * Format the given feature identifier to remove special caracters(as ?, [, ], ., etc..) which cannot be used as HTML id's
     * @param {string} id - identifier
     * @return {string} HTML identifier
     */
    Utils.formatId = function(id) {
        var result;
        if (typeof id === "string") {
            result = id.replace(
                /\s{1,}|\.{1,}|\[{1,}|\]{1,}|\({1,}|\){1,}|\~{1,}|\+{1,}|\{1,}|\-{1,}|\'{1,}|\"{1,}/g,
                ""
            );
        } else {
            result = id;
        }
        return result;
    };

    /**
     * Checks if a value v is between the interval [min, max].
     * @function isValueBetween
     * @param {float} v - value
     * @param {float} min - min value
     * @param {float} max - max value
     * @return {boolean} true when v is between min and max otherwise false
     */
    Utils.isValueBetween = function(v, min, max) {
        return v >= min && v <= max;
    };

    /**
     * Computes base URL from getCapabilities URL.
     * @function computeBaseUrlFromCapabilities
     * @param {string} capabilitiesUrl - getCapabilities URL
     * @param {string[]} parameters - parameters of the getCapabilities
     * @return {string} base URL
     */
    Utils.computeBaseUrlFromCapabilities = function(
        capabilitiesUrl,
        parameters
    ) {
        if (
            typeof capabilitiesUrl != "string" ||
            capabilitiesUrl.length == 0 ||
            !Array.isArray(parameters)
        )
            return null;

        var url = capabilitiesUrl;
        if (url.indexOf("?") > -1) {
            url = url.substr(0, url.indexOf("?"));
        }
        // url cannot be undefined because we need to query a getCapabilities or something else with a parameter
        var queryString =
            capabilitiesUrl.replace(url + "?", "") || capabilitiesUrl;
        var query = Utils.parseQuery(queryString);
        // we delete all parameters required by a standard.
        for (var i = 0; i < parameters.length; i++) {
            var parameter = parameters[i];
            delete query[parameter];
        }
        // we build the new Url with remaining parameters.
        var nbParameter = 0;
        for (var key in query) {
            var value = query[key];
            if (nbParameter == 0) {
                url = url + "?" + key + "=" + value;
            } else {
                url = url + "&" + key + "=" + value;
            }
            nbParameter++;
        }

        return url;
    };

    Utils.parseQuery = function(str) {
        if (typeof str != "string" || str.length == 0) return {};
        var s = str.split("&");
        var s_length = s.length;
        var bit,
            query = {},
            first,
            second;
        for (var i = 0; i < s_length; i++) {
            bit = s[i].split("=");
            first = decodeURIComponent(bit[0]);
            if (first.length == 0) continue;
            second = decodeURIComponent(bit[1]);
            if (typeof query[first] == "undefined") query[first] = second;
            else if (query[first] instanceof Array) query[first].push(second);
            else query[first] = [query[first], second];
        }
        return query;
    };

    /**
     * Add parameter to
     * @function addParameterTo
     * @param {String} url - parameter url
     * @param {String} name - parameter name
     * @param {String} value - parameter value
     * @return {String} url updated
     */
    Utils.addParameterTo = function(url, name, value) {
        var separator = "&";
        if (typeof url !== "string" || url.indexOf("?", 0) === -1) {
            separator = "?";
        }
        return url + separator + name + "=" + value;
    };

    /**
     * Parses the base URL.
     * @function parseBaseURL
     * @param {string} url - the URL
     * @return {*} the base URL
     */
    Utils.parseBaseURL = function(url) {
        var result;
        var index = url.indexOf("?");
        if (index == -1) {
            result = url;
        } else {
            result = url.substring(0, url.indexOf("?") + 1);
        }
        return result;
    };

    /**
     * Parses the query string and returns the parameters of the URL.
     * @function parseQueryString
     * @param {string} url - query string
     * @return {{}} parameters of the query string
     */
    Utils.parseQueryString = function(url) {
        var queryString = url.substring(url.indexOf("?") + 1).split("&");
        var params = {};
        var pair;
        // march and parse
        for (var i = queryString.length - 1; i >= 0; i--) {
            pair = queryString[i].split("=");
            params[decodeURIComponent(pair[0])] = decodeURIComponent(
                pair[1] || ""
            );
        }
        return params;
    };

    /**
     * Request an URL.
     * @function requestUrl
     * @param {string} url - URL to request
     * @param {string} datatype - datatype of the response
     * @param {Object} options - options
     * @param {Utils~requestCallback} callback - The callback that handles the response.
     * @param {Utils~requestFallback} fallBack - The fallback that handles the error.
     */
    Utils.requestUrl = function(url, datatype, options, callback, fallBack) {
        $.ajax({
            type: "GET",
            url: url,
            dataType: datatype,
            success: function(response) {
                if (callback) {
                    callback(response, options);
                }
            },
            error: function(xhr, ajaxOptions, thrownError) {
                var message;
                var code;
                if (xhr.status === 0) {
                    message =
                        "Unreachable URL or No 'Access-Control-Allow-Origin' header is present on the " +
                        url;
                    code = 0;
                } else {
                    message = thrownError.message;
                    code = thrownError.code;
                }
                if (fallBack) {
                    fallBack(new NetworkError(message, "Utils.js", code));
                }
            }
        });
    };

    /**
     * This callback process the response when the request is a success.
     * @callback Utils~requestCallback
     * @param {Object} response - the response of the server
     * @param {Object} options - options
     */

    /**
     * This fallback process the error of the server.
     * @callback Utils~requestFallback
     * @param {Object} request - the request to the server
     * @param {int} status - status code
     * @param {Object} error - error
     * @param {Object} options - options
     */

    /**
     * Proxifies an URL according to a proxy configuration.
     * @function proxify
     * @param {string} url - URL to proxify
     * @param {{use:boolean, url:string}} proxy - proxy configuration
     * @return {*}
     */
    Utils.proxify = function(url, proxy) {
        if (typeof url !== "string") {
            return url;
        }
        var proxifiedUrl = url;
        if (proxy) {
            if (proxy.use === true) {
                if (url.toLowerCase().startsWith("http") === false) {
                    proxifiedUrl = url;
                } else if (url.startsWith(proxy.url)) {
                    proxifiedUrl = url; // No change, proxy always set
                } else {
                    proxifiedUrl = proxy.url + encodeURIComponent(url); // Add proxy redirection
                }
            }
        }
        return proxifiedUrl;
    };

    /**
     * Converts UTC hms from date to hours.
     * @function _UT
     * @param {date} date - date
     * @returns {number} hours
     * @private
     */
    function _UT(date) {
        var hour = date.getUTCHours();
        var min = date.getUTCMinutes();
        var sec = date.getUTCSeconds();
        return hour + min / 60 + sec / 3600;
    }

    /**
     * Computes Julian day number at 0 hr UT.
     * @function _J0
     * @param {date} date - date
     * @returns {number} Julian day number at 0 hr UT
     * @private
     */
    function _J0(date) {
        var year = date.getUTCFullYear();
        var month = date.getUTCMonth() + 1;
        var day = date.getUTCDate();
        var UT = _UT(date);
        //TODO check 1721013.5 should be -730531.5 !!!
        return (
            367 * year -
            Math.floor((7 / 4) * (year + Math.floor((month + 9) / 12))) +
            Math.floor((275 * month) / 9) +
            day +
            1721013.5
        );
    }

    /**
     * Computes Julian day.
     * @function JD
     * @param {date} date - date
     * @returns {number} julian day
     * @private
     */
    Utils.JD = function(date) {
        return _J0(date) + _UT(date) / 24;
    };

    /**
     * Computes the Greenwich sidereal time at 0 hr UT.
     * See equation [Seidelmann,1992]
     * @function _GST0
     * @param date date
     * @returns {number} the Greenwich sidereal time at 0 hr UT
     * @private
     */
    function _GST0(date) {
        //JC is Julian centuries between the Julian day J0 and J2000(2,451,545.0)
        var julianCentury = (_J0(date) - 2451545.0) / 36525;
        var GST0 =
            100.4606184 +
            36000.77004 * julianCentury +
            0.000387933 * julianCentury * julianCentury -
            2.583e-8 * julianCentury * julianCentury * julianCentury;
        return GST0 % 360;
    }

    /**
     * Computes the Greenwich sidereal time at any other UT time.
     * @function GST
     * @param {date} date - date
     * @returns {number} the Greenwich sidereal time at any other UT time
     */
    Utils.GST = function(date) {
        return (_GST0(date) + (360.98564724 * _UT(date)) / 24) % 360;
    };

    /**
     * Computes the local sidereal time.
     * @function LST
     * @param {date} date - date
     * @param {float} longitude - longitude
     * @returns {number}
     */
    Utils.LST = function(date, longitude) {
        return (Utils.GST(date) + longitude) % 360;
    };

    /**
     * Computes the Sidereal Hour Angle
     * @function SHA
     * @param {float} ra - right ascension in decimal degree
     * @returns {number} SHA in decimal degree
     */
    Utils.SHA = function(ra) {
        return 360.0 - (15.0 * ra * 24.0) / 360.0;
    };

    /**
     * Computes the GHA (Greenwich Hour Angle).
     * GHA indicates the position past the plane of the Greenwich meridian measured in degrees. Equivalent to longitude on earth.
     * @function GHA
     * @param {date} date - date
     * @param {float} ra - right ascension in decimal degree
     * @returns {number} Greenwich Hour Angle in decimal degree
     */
    Utils.GHA = function(date, ra) {
        var GHA_Aries = (15.0 * Utils.GST(date) * 24.0) / 360.0;
        return (Utils.SHA(ra) + GHA_Aries) % 360;
    };

    /**
     * Converts longitude/latitude to XYZ
     * @function longLat2XYZ
     * @param {float} longitude - longitude in decimal degree
     * @param {float} latitude - latitude in decimal degree
     * @returns {{x: float, y: float, z: float}} the cartesian coordinates
     */
    Utils.longLat2XYZ = function(longitude, latitude) {
        var latInRadians = Numeric.toRadian(latitude);
        var longInRadians = Numeric.toRadian(longitude);
        var cosLat = Math.cos(latInRadians);
        return {
            x: cosLat * Math.cos(longInRadians),
            y: cosLat * Math.sin(longInRadians),
            z: Math.sin(latInRadians)
        };
    };

    /**
     * Computes the distance of the camera in meters for which the bbox of the target is the camera FOV.
     * @function computeDistanceCameraFromBbox
     * @param {float[]} bbox - bbox of the target
     * @param {float} fov - camera FOV
     * @param {float} planetRadius - planet radius in meters
     * @param {boolean} isFlat - is it a projected CRS
     * @return {float} the distance of the camera in meters.
     */
    Utils.computeDistanceCameraFromBbox = function(
        bbox,
        fov,
        planetRadius,
        isFlat
    ) {
        var angularDistance = Math.abs(bbox[2] - bbox[0]);
        if (UtilsIntersection.isCrossDateLine(bbox[0], bbox[2])) {
            angularDistance = 360 - angularDistance;
        }
        var visibleAngularDistance;
        if (isFlat) {
            visibleAngularDistance = angularDistance;
        } else if (angularDistance > 180) {
            visibleAngularDistance = 360 - angularDistance;
        } else {
            visibleAngularDistance = angularDistance;
        }

        var distance =
            (2 * Math.PI * planetRadius * visibleAngularDistance) / 360;
        return (0.5 * distance) / Math.tan(0.5 * Numeric.toRadian(fov));
    };

    Utils.defineTimeRequest = function(temporalRanges, timeRequest) {
        var startDate = timeRequest.from;
        var stopDate = timeRequest.to;

        var times = temporalRanges.split(",");
        if (times.length == 1) {
            // no range
            var time = times[0];
        } else {
            // temporalRange
            var startTime = times[0];
            var stopTime = times[1];
            var frequency = times[2];
        }
    };

    Utils.formatResolution = function(format) {
        var timeResolution;
        if (Utils.aContainsB.call(this, format, "ss")) {
            timeResolution = "seconds";
        } else if (Utils.aContainsB.call(this, format, "mm")) {
            timeResolution = "minutes";
        } else if (Utils.aContainsB.call(this, format, "HH")) {
            timeResolution = "hours";
        } else if (Utils.aContainsB.call(this, format, "DD")) {
            timeResolution = "days";
        } else if (Utils.aContainsB.call(this, format, "MM")) {
            timeResolution = "months";
        } else if (Utils.aContainsB.call(this, format, "YYYY")) {
            timeResolution = "years";
        } else {
            throw new Error();
        }
        return timeResolution;
    };

    Utils.aContainsB = function(a, b) {
        return a.indexOf(b) >= 0;
    };

    Utils.convertToMoment = function(time) {
        return time instanceof Moment() ? time : Moment().utc(time);
    };

    Utils.isPassiveSupported = function() {
        var passiveSupported = false;

        try {
            var options = Object.defineProperty({}, "passive", {
                get: function() {
                    passiveSupported = true;
                }
            });

            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
        } catch (err) {
            passiveSupported = false;
        }
        return passiveSupported;
    };

    /**
     * Assert function.
     * @param {Boolean} condition test condition
     * @param {string} message Output when the assert is not true
     * @param {string} [filename] where the error occurs 
     * @throws {Error} sent message when the condition is false 
     */
    Utils.assert = function(condition, message, filename) {
        if (!condition) {            
            if (filename == null) {
                message = filename+": "+message;    
            }            
            throw new Error("Assert failed" + (typeof message !== "undefined" ? " - " + message : ""));
        }

    };

    return Utils;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Event',[],function() {
    /**************************************************************************************************************/

    /**
     @name Event
     @class
         A light-weight event object.
     */
    var Event = function() {
        // Event callbacks
        this.callbacks = {};
    };

    /**************************************************************************************************************/

    /**
     Subscribe to an event

     @param name Event name
     <ul>
     <li>startNavigation : called when navigation is started (by the user or through animation)</li>
     <li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
     <li>baseLayersReady : called when the base layers are ready to be displayed</li>
     <li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
     <li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
     <li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
     <li>startLoad : called when a layer start to be loaded</li>
     <li>endLoad : called when layer end loading</li>
     </ul>
     @param callback Callback function
     */
    Event.prototype.subscribe = function(name, callback) {
        if (!this.callbacks[name]) {
            this.callbacks[name] = [callback];
        } else {
            this.callbacks[name].push(callback);
        }
    };

    /**************************************************************************************************************/

    /**
     Unsubscribe to an event

     @param name Event name {@link Globe#subscribe}
     @param callback Callback function
     */
    Event.prototype.unsubscribe = function(name, callback) {
        if (this.callbacks[name]) {
            var i = this.callbacks[name].indexOf(callback);
            if (i !== -1) {
                this.callbacks[name].splice(i, 1);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     Publish an event

     @param name Event name
     @param context Context
     */
    Event.prototype.publish = function(name, context) {
        if (this.callbacks[name]) {
            var cbs = this.callbacks[name];
            for (var i = 0; i < cbs.length; i++) {
                cbs[i](context);
            }
        }
    };

    /**************************************************************************************************************/

    return Event;
});

define('Time/Time',["jquery", "moment", "../Utils/Constants", "../Utils/Utils"], function(
    $,
    Moment,
    Constants,
    Utils
) {
    /**
     * Time parameter
     * @typedef {Object} Time.time
     * @property {moment} date - Date of the event
     * @property {moment} display - date as defined in the server level
     * @property {Time.period} period - period of the event
     */

    /**
     * Period parameter
     * @typedef {Object} Time.period
     * @property {moment} from - Start date
     * @property {moment} to - Stop date
     */

    const REGEXP_YEAR = /^\d{4}$/;

    /**
     * Handles time.
     * @param {Time.time} time
     * @constructor
     */
    var Time = function(time) {
        this.date = time.date;
        this.display = time.display;
        this.period = time.period;
    };

    /**
     * Tests if the time input parameter is based on TimeTravel.
     * @param {Time.time} value time
     * @return {boolean} true when TimeTravel parameter is used otherwise false
     * @private
     */
    function _isTimeTravel(value) {
        return (
            value.hasOwnProperty("date") &&
            value.hasOwnProperty("display") &&
            value.hasOwnProperty("period")
        );
    }

    /**
     * Tests if the time input parameter is based on a period
     * @param {Time.period} value time
     * @return {boolean} true when period parameter is used otherwise false
     * @private
     */
    function _isPeriod(value) {
        return value.hasOwnProperty("from") && value.hasOwnProperty("to");
    }

    /**
     * Tests if the time input parameter is based on a semi-period (to not defined)
     * @param {Time.period} value time
     * @return {boolean} true when period parameter is used otherwise false
     * @private
     */
    function _isOpenedInterval(value) {
        return value.hasOwnProperty("from");
    }

    /**
     * Tests if the time input parameter is based on a string
     * @param {string} value time
     * @return {boolean} true when a string is used to define the date
     * @private
     */
    function _isDateString(value) {
        return typeof value === "string";
    }

    /**
     * Tests if the time input parameter is based on a Date object
     * @param {Date} value time
     * @return {boolean} true when a Date object is used to define the date
     * @private
     */
    function _isDate(value) {
        return value instanceof Date;
    }

    /**
     * Tests is value is a numeric value.
     * @param value value to test
     * @return {boolean} true when value is a numeric otherwise false
     * @private
     */
    function _isNumeric(value) {
        return !isNaN(value);
    }

    /**
     * Returns the unit (year, mont, day) of the date
     * @param {UNIT_TIME_WMS} unit
     * @return {TIME_STEP} the unit
     * @private
     */
    function _unitWithoutTime(unit) {
        var unitTime;
        switch (unit) {
            case Constants.UNIT_TIME_WMS.YEAR:
                unitTime = Constants.TIME_STEP.YEAR;
                break;
            case Constants.UNIT_TIME_WMS.MONTH:
                unitTime = Constants.TIME_STEP.MONTH;
                break;
            case Constants.UNIT_TIME_WMS.DAY:
                unitTime = Constants.TIME_STEP.DAY;
                break;
            default:
                throw new Error("Unknown date format");
        }
        return unitTime;
    }

    /**
     * Returns the unit (hour, minute, second) of the time.
     * @param {UNIT_TIME_WMS} unit unit of the time
     * @return {TIME_STEP} Unit of the time
     * @private
     */
    function _unitWithTime(unit) {
        var unitTime;
        switch (unit) {
            case Constants.UNIT_TIME_WMS.HOUR:
                unitTime = Constants.TIME_STEP.HOUR;
                break;
            case Constants.UNIT_TIME_WMS.MINUTE:
                unitTime = Constants.TIME_STEP.MINUTE;
                break;
            case Constants.UNIT_TIME_WMS.SECONDE:
                unitTime = Constants.TIME_STEP.SECONDE;
                break;
            default:
                throw new Error("Onknown time format");
        }
        return unitTime;
    }

    /**
     * Parses the resolution returned by the server side.
     * @param resolution
     * @return {{step: *, unit: *}} The resolution of the temporal step
     * @private
     */
    function _timeResolution(resolution) {
        var stepTime, unitTime;
        var unit = resolution.slice(-1);
        if (resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.TIME)) {
            //time => hour, min, sec
            stepTime = resolution.substring(2, resolution.length - 1);
            unitTime = _unitWithTime(unit);
        } else if (
            resolution.startsWith(Constants.UNIT_RESOLUTION_WMS.NOT_TIME)
        ) {
            //day, month year
            stepTime = resolution.substring(1, resolution.length - 1);
            unitTime = _unitWithoutTime(unit);
        } else {
            throw new Error("Unknown resolution");
        }

        var res = {
            step: stepTime,
            unit: unitTime
        };
        return res;
    }

    /**
     * Tests if the time definition is a sampling (min/max/step)
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a sampling
     * @private
     */
    function _isSampling(timeDefinition) {
        return timeDefinition.indexOf("/") !== -1;
    }

    /**
     * Tests if the time definition is a single value
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a discrete value
     * @private
     */
    function _isDistinctValue(timeDefinition) {
        return (
            !_isSampling(timeDefinition) && timeDefinition.indexOf(",") === -1
        );
    }

    /**
     * Tests if two dates are equals
     * @param {moment} date1
     * @param {moment} date2
     * @return {boolean} true when dates are equals otherwise false
     * @private
     */
    function _isEqual(date1, date2) {
        var interval1 = _createPeriod(date1);
        var interval2 = _createPeriod(date2);
        return (
            (interval2.from <= interval1.from &&
                interval1.from <= interval2.to) ||
            (interval2.from <= interval1.to && interval1.to <= interval2.to) ||
            (interval1.from <= interval2.from &&
                interval2.from <= interval1.to) ||
            (interval1.from <= interval2.to && interval2.to <= interval1.to)
        );
    }

    /**
     * Create a period from a given date
     * @param {moment} date
     * @return {{from, to}} the period
     * @private
     */
    function _createPeriod(date) {
        var format = date.creationData().format;
        var timeResolution = _lowestFormatResolution(format);
        return {
            from: Moment(date).startOf(timeResolution),
            to: Moment(date).endOf(timeResolution)
        };
    }

    function _isIntersect(period1, date2) {
        var interval2 = _createPeriod(date2);
        return (
            (interval2.from <= period1.from && period1.from <= interval2.to) ||
            (interval2.from <= period1.to && period1.to <= interval2.to) ||
            (period1.from <= interval2.from && interval2.from <= period1.to) ||
            (period1.from <= interval2.to && interval2.to <= period1.to)
        );
    }

    /**
     * Binary Search to find the date in min/max/resolution for which the date is equal to requestedTime
     * @param {moment} requestedTime requested time
     * @param {{from,to}} requestedPeriodTime requested period time
     * @param {moment} startTime start date
     * @param {int} nbValues number of value between startDate/stopDate
     * @param {{step,unit}} timeResolution time resolution
     * @return {number} -1 when the requestedTime is not find in the binarySearch otherwise false
     */
    function _binarySearch(
        requestedTime,
        requestedPeriodTime,
        startTime,
        nbValues,
        timeResolution
    ) {
        var guess,
            start,
            currentDate,
            min = 0,
            max = nbValues;

        while (min <= max) {
            guess = Math.floor((min + max) / 2);
            currentDate = Moment(startTime);
            currentDate.add(guess * timeResolution.step, timeResolution.unit);
            if (
                _isEqual(requestedTime, currentDate) ||
                _isIntersect(requestedPeriodTime, currentDate)
            )
                return guess;
            else if (requestedTime > currentDate) min = guess + 1;
            else max = guess - 1;
        }
        return -1;
    }

    /**
     * Lowest format resolution.
     * @param {string} format
     * @return The time moment unit
     * @private
     */
    function _lowestFormatResolution(format) {
        var timeResolution;
        if (Utils.aContainsB.call(this, format, "ss")) {
            timeResolution = Constants.TIME_MOMENT_STEP.SECOND;
        } else if (Utils.aContainsB.call(this, format, "mm")) {
            timeResolution = Constants.TIME_MOMENT_STEP.MINUTE;
        } else if (Utils.aContainsB.call(this, format, "HH")) {
            timeResolution = Constants.TIME_MOMENT_STEP.HOUR;
        } else if (Utils.aContainsB.call(this, format, "DD")) {
            timeResolution = Constants.TIME_MOMENT_STEP.DAY;
        } else if (Utils.aContainsB.call(this, format, "MM")) {
            timeResolution = Constants.TIME_MOMENT_STEP.MONTH;
        } else if (Utils.aContainsB.call(this, format, "YYYY")) {
            timeResolution = Constants.TIME_MOMENT_STEP.YEAR;
        } else {
            throw new Error();
        }
        return timeResolution;
    }

    /**
     * Template for time travel
     * @param {string} date date
     * @param {string} display the real value from the server
     * @param {string} from start date
     * @param {string} to stop date
     * @param {boolean} computed true when we do not find the real date from the server
     * @return {{date: *, display: *, period: {from: *, to: *}, computed: *}}
     * @private
     */
    function _templateTimeTravel(date, display, from, to, computed) {
        return {
            date: _convertMoment(date),
            display: display,
            period: {
                from: _convertMoment(from),
                to: _convertMoment(to)
            },
            computed: computed
        };
    }

    function _convertMoment(date) {
        var time;
        if (REGEXP_YEAR.test(date)) {
            time = Moment.utc(date, "YYYY");
        } else if (date instanceof Date) {
            time = Moment.utc(date.toISOString());
        } else {
            time = Moment.utc(date);
        }
        return time;
    }

    /**
     * Converts a string date to a Time object
     * @param {string} time
     * @return {{date, display, period, computed}|{date: *, display: *, period: {from: *, to: *}, computed: *}}
     * @private
     */
    function _convertStringDateToTime(time) {
        var timeRequested = _convertMoment(time);
        var format = timeRequested.creationData().format;
        var timeResolution = _lowestFormatResolution(format);
        var from = Moment.utc(timeRequested).startOf(timeResolution);
        var to = Moment.utc(timeRequested).endOf(timeResolution);
        return _templateTimeTravel(time, time, from, to, false);
    }

    /**
     * Lowest format resolution.
     * @param {string} format
     * @return The time moment unit
     */
    Time.lowestFormatResolution = function(format) {
        return _lowestFormatResolution(format);
    };

    /**
     * Parses the resolution returned by the server side.
     * @param resolution
     * @return {{step: *, unit: *}} The resolution of the temporal step
     */
    Time.timeResolution = function(resolution) {
        return _timeResolution(resolution);
    };

    /**
     * Tests if the time definition is a sampling (min/max/step)
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a sampling
     */
    Time.isSampling = function(timeDefinition) {
        return _isSampling(timeDefinition);
    };

    /**
     * Tests if the time definition is a single value
     * @param {string} timeDefinition
     * @return {boolean} true when timeDefinition is a discrete value
     */
    Time.isDistinctValue = function(timeDefinition) {
        return _isDistinctValue(timeDefinition);
    };

    /**
     * Parses the date and returns Time.
     * @param {Time.time|Time.period|string|Date} time
     * @return {Time} time object
     */
    Time.parse = function(time) {
        var result;
        if (_isTimeTravel(time)) {
            result = _templateTimeTravel(
                time.date,
                time.display,
                time.period.from,
                time.period.to,
                true
            );
        } else if (_isPeriod(time)) {
            result = _templateTimeTravel(
                time.from,
                time.from,
                time.from,
                time.to,
                false
            );
        } else if (_isOpenedInterval(time)) {
            result = _templateTimeTravel(
                time.from,
                time.from,
                time.from,
                Moment(),
                false
            );
        } else if (_isDateString(time)) {
            result = _convertStringDateToTime(time);
        } else if (_isDate(time)) {
            result = _convertStringDateToTime(time.toISOString());
        } else {
            throw new Error("Unsupported time format");
        }
        return new Time(result);
    };

    /**
     * Tests if the singleDefinition is equal to the time object.
     * @param {string} singleTimeDefinition
     * @return {boolean} true when the singleDefinition is equal to the time object otherwise false
     */
    Time.prototype.isEqual = function(singleTimeDefinition) {
        var singleTimeMoment = _convertMoment(singleTimeDefinition);
        var isEqual = _isEqual(this.date, singleTimeMoment);
        if (isEqual) {
            var format = singleTimeMoment.creationData().format;
            this.display = singleTimeMoment.format(format);
        }
        return isEqual;
    };

    /**
     * Tests if the samplingDefinition is in the sample.
     * @param {string} samplingTimeDefinition
     * @return {boolean} true when the samplingDefinition is in the sample otherwise false.
     */
    Time.prototype.isInSampling = function(samplingTimeDefinition) {
        samplingTimeDefinition = samplingTimeDefinition.trim();
        var minMaxStepTimeDef = samplingTimeDefinition.split("/");
        var startDateTimeDef = _convertMoment(minMaxStepTimeDef[0]);
        var stopDateTimeDef = _convertMoment(minMaxStepTimeDef[1]);
        var stepDateTimeDef = minMaxStepTimeDef[2];
        var timeResolutionDef = _timeResolution(stepDateTimeDef);
        var nbValues = Math.floor(
            stopDateTimeDef.diff(startDateTimeDef, timeResolutionDef.unit) /
                parseInt(timeResolutionDef.step)
        );
        var idx = _binarySearch(
            this.date,
            this.period,
            startDateTimeDef,
            nbValues,
            timeResolutionDef
        );
        var isFound;
        if (idx === -1) {
            isFound = false;
        } else {
            isFound = true;
            var format = startDateTimeDef.creationData().format;
            this.display = Moment.utc(startDateTimeDef)
                .add(idx * timeResolutionDef.step, timeResolutionDef.unit)
                .format(format);
        }
        return isFound;
    };

    /**
     * Tests if the timeDefinition is in Time definition.
     * TimeDefinition can be a sample of discrete values and/or start/stop/resolution
     * @param {string} timeDefinition
     * @return {boolean} true when the timeDefinition is in Time definition otherwise false
     */
    Time.prototype.isInTimeDefinition = function(timeDefinition) {
        timeDefinition = timeDefinition.trim();
        var dataTime, momentDataTime, timeIdx;
        var isInside = false;
        var times = timeDefinition.split(",");
        for (timeIdx = 0; timeIdx < times.length && !isInside; timeIdx++) {
            dataTime = times[timeIdx].trim();
            if (_isDistinctValue(dataTime)) {
                isInside = this.isEqual(dataTime);
            } else if (_isSampling(dataTime)) {
                isInside = this.isInSampling(dataTime);
            } else {
                throw new Error("Unknown timeDefinition format");
            }
        }
        return isInside;
    };

    /**
     * Returns the real value coming from the server.
     * @return {string} the real value coming from the server
     */
    Time.prototype.getDisplayValue = function() {
        return this.display;
    };

    return Time;
});

// Generated by CoffeeScript 1.3.3
(function() {
  var WCS,
    __bind = function(fn, me){
      return function(){
        return fn.apply(me, arguments);
      };
    },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  WCS = (typeof exports !== "undefined" && exports !== null) && this || (this.WCS = {});

  WCS.Math = {};

  WCS.Math.R2D = 180 / Math.PI;

  WCS.Math.D2R = Math.PI / 180;

  WCS.Math.WCSTRIG_TOL = 1e-10;

  WCS.Math.cosd = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.cos(angle * WCS.Math.D2R);
  };

  WCS.Math.sind = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 - 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.sin(angle * WCS.Math.D2R);
  };

  WCS.Math.sincosd = function(angle) {
    var c, i, s, _ref, _ref1;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          s = 0;
          c = 1;
          break;
        case 1:
          s = (_ref = angle > 0) != null ? _ref : {
            1: -1
          };
          c = 0;
          break;
        case 2:
          s = 0;
          c = -1;
          break;
        case 3:
          s = (_ref1 = angle > 0) != null ? _ref1 : -{
            1: 1
          };
          c = 0;
      }
      return s * c;
    }
    s = Math.sin(angle * WCS.Math.D2R);
    c = Math.cos(angle * WCS.Math.D2R);
    return s * c;
  };

  WCS.Math.tand = function(angle) {
    var resid;
    resid = angle & 360;
    if (resid === 0 || Math.abs(resid) === 180) {
      return 0;
    } else if (resid === 45 || resid === 225) {
      return 1;
    } else if (resid === -135 || resid === -315) {
      return -1;
    }
    return Math.tan(angle * WCS.Math.D2R);
  };

  WCS.Math.acosd = function(v) {
    if (v >= 1) {
      if (v - 1 < WCS.Math.WCSTRIG_TOL) {
        return 0;
      }
    } else if (v === 0) {
      return 90;
    } else if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return 180;
      }
    }
    return Math.acos(v) * WCS.Math.R2D;
  };

  WCS.Math.asind = function(v) {
    if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return -90;
      } else if (v === 0) {
        return 0;
      } else if (v >= 1) {
        if (v - 1 < WCS.Math.WCSTRIG_TOL) {
          return 90;
        }
      }
    }
    return Math.asin(v) * WCS.Math.R2D;
  };

  WCS.Math.atand = function(v) {
    if (v === -1) {
      return -45;
    } else if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 45;
    }
    return Math.atan(v) * WCS.Math.R2D;
  };

  WCS.Math.atan2d = function(y, x) {
    if (y === 0) {
      if (x >= 0) {
        return 0;
      } else if (x < 0) {
        return 180;
      }
    } else if (x === 0) {
      if (y > 0) {
        return 90;
      } else if (y < 0) {
        return -90;
      }
    }
    return Math.atan2(y, x) * WCS.Math.R2D;
  };

  WCS.Math.toRightTriangular = function(mat) {
    var els, i, j, k, kp, multiplier, n, np, p;
    n = mat.length;
    k = n;
    kp = mat[0].length;
    while (true) {
      i = k - n;
      if (mat[i][i] === 0) {
        j = i + 1;
        while (j < k) {
          if (mat[j][i] !== 0) {
            els = [];
            np = kp;
            while (true) {
              p = kp - np;
              els.push(mat[i][p] + mat[j][p]);
              if (!--np) {
                break;
              }
            }
            mat[i] = els;
            break;
          }
          j += 1;
        }
      }
      if (mat[i][i] !== 0) {
        j = i + 1;
        while (j < k) {
          multiplier = mat[j][i] / mat[i][i];
          els = [];
          np = kp;
          while (true) {
            p = kp - np;
            els.push((p <= i ? 0 : mat[j][p] - mat[i][p] * multiplier));
            if (!--np) {
              break;
            }
          }
          mat[j] = els;
          j += 1;
        }
      }
      if (!--n) {
        break;
      }
    }
    return mat;
  };

  WCS.Math.determinant = function(mat) {
    var det, i, k, m, n;
    m = WCS.Math.toRightTriangular(mat);
    det = m[0][0];
    n = m.length - 1;
    k = n;
    while (true) {
      i = k - n + 1;
      det = det * m[i][i];
      if (!--n) {
        break;
      }
    }
    return det;
  };

  WCS.Math.matrixInverse = function(m) {
    var I, h, i, inv, j, mat, temp, w;
    w = m[0].length;
    h = m.length;
    I = new Array(h);
    inv = new Array(h);
    temp = [];
    mat = [];
    j = 0;
    while (j < h) {
      mat[j] = [];
      i = 0;
      while (i < w) {
        mat[j][i] = m[j][i];
        i += 1;
      }
      j += 1;
    }
    j = 0;
    while (j < h) {
      I[j] = new Array(w);
      inv[j] = new Array(w);
      i = 0;
      while (i < w) {
        I[j][i] = (i === j ? 1 : 0);
        i += 1;
      }
      temp[j] = mat[j].concat(I[j]);
      j += 1;
    }
    WCS.Math.gaussJordan(temp);
    j = 0;
    while (j < h) {
      inv[j] = temp[j].slice(w, 2 * w);
      j += 1;
    }
    return inv;
  };

  WCS.Math.gaussJordan = function (m, eps) {
  if (!eps) eps = 1e-10;
  var h, w, y, y2, x, maxrow, tmp, c;
  h = m.length;
  w = m[0].length;
  y = -1;

  while (++y < h) {
    maxrow = y;

    // Find max pivot.
    y2 = y;
    while (++y2 < h) {
      if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
        maxrow = y2;
    }

    // Swap.
    tmp = m[y];
    m[y] = m[maxrow];
    m[maxrow] = tmp;

    // Singular?
    if (Math.abs(m[y][y]) <= eps)
      return false;

    // Eliminate column y.
    y2 = y;
    while (++y2 < h) {
      c = m[y2][y] / m[y][y];
      x = y - 1;
      while (++x < w) {
        m[y2][x] -= m[y][x] * c;
      }
    }
  }

  // Backsubstitute.
  y = h;
  while (--y >= 0) {
    c = m[y][y];
    y2 = -1;
    while (++y2 < y) {
      x = w;
      while (--x >= y) {
        m[y2][x] -=  m[y][x] * m[y2][y] / c;
      }
    }
    m[y][y] /= c;
    // Normalize row y.
    x = h - 1;
    while (++x < w) {
      m[y][x] /= c;
    }
  }
  return true;
};;

  WCS.Mapper = (function() {

    function Mapper(header) {
      this.coordinateToPixel = __bind(this.coordinateToPixel, this);

      this.pixelToCoordinate = __bind(this.pixelToCoordinate, this);

      this.fromCelestial = __bind(this.fromCelestial, this);

      this.toCelestial = __bind(this.toCelestial, this);

      this.fromIntermediate = __bind(this.fromIntermediate, this);

      this.toIntermediate = __bind(this.toIntermediate, this);

      this.computeCelestialParameters = __bind(this.computeCelestialParameters, this);

      this.getSipCoefficients = __bind(this.getSipCoefficients, this);

      this.setProjection = __bind(this.setProjection, this);

      this.derivePC = __bind(this.derivePC, this);

      this.checkCard = __bind(this.checkCard, this);

      this.verifyHeader = __bind(this.verifyHeader, this);
      this.wcsobj = {};
      this.projection = void 0;
      this.longitudeAxis = void 0;
      this.latitudeAxis = void 0;
      this.sip = void 0;
      this.verifyHeader(header);
      this.setProjection(header);
    }

    Mapper.prototype.verifyHeader = function(header) {
      var arrayName, axis, date, j, key, naxis, requiredCards, _i, _j, _k, _ref;
      this.wcsobj.naxis = naxis = header['NAXIS'] || header['WCSAXES'] || 2;
      this.wcsobj.radesys = header['RADESYS'] || 'ICRS';
      requiredCards = ['CRPIX', 'CRVAL', 'CTYPE'];
      this.wcsobj.crpix = [];
      this.wcsobj.crval = [];
      this.wcsobj.ctype = [];
      for (axis = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; axis = 1 <= naxis ? ++_i : --_i) {
        for (j = _j = 0, _ref = requiredCards.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
          key = requiredCards[j] + axis;
          if (!header.hasOwnProperty(key)) {
            throw "Not enough information to compute WCS, missing required keyword " + key;
          }
          arrayName = requiredCards[j].toLowerCase();
          this.wcsobj[arrayName].push(header[key]);
        }
      }
      this.wcsobj.cunit = [];
      this.wcsobj.cdelt = [];
      for (axis = _k = 1; 1 <= naxis ? _k <= naxis : _k >= naxis; axis = 1 <= naxis ? ++_k : --_k) {
        key = 'CUNIT' + axis;
        this.wcsobj.cunit.push(header[key] || 'deg');
        key = 'CDELT' + axis;
        this.wcsobj.cdelt.push(header[key] || 1);
      }
      this.wcsobj.lonpole = header['LONPOLE'] || 0;
      this.wcsobj.latpole = header['LATPOLE'] || 0;
      this.wcsobj.equinox = header['EQUINOX'] || 2000;
      date = new Date();
      this.wcsobj.dateObs = header['DATE_OBS'] || (date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate());
      this.wcsobj.dateObs = header['DATE_OBS'] || ("" + (date.getFullYear()) + "-" + (date.getMonth() + 1) + "-" + (date.getDate()));
      this.wcsobj.pc = this.checkCard(header, 'PC', naxis) || this.derivePC(header);
      this.wcsobj.pcInv = WCS.Math.matrixInverse(this.wcsobj.pc);
      this.wcsobj.cd = this.checkCard(header, 'CD', naxis);
      if (this.wcsobj.cd != null) {
        return this.wcsobj.cdInv = WCS.Math.matrixInverse(this.wcsobj.cd);
      }
    };

    Mapper.prototype.checkCard = function(header, key, dimensions) {
      var fullKey, i, j, obj, _i, _j;
      obj = [];
      for (i = _i = 1; 1 <= dimensions ? _i <= dimensions : _i >= dimensions; i = 1 <= dimensions ? ++_i : --_i) {
        obj[i - 1] = [];
        for (j = _j = 1; 1 <= dimensions ? _j <= dimensions : _j >= dimensions; j = 1 <= dimensions ? ++_j : --_j) {
          fullKey = "" + key + i + "_" + j;
          if (!header.hasOwnProperty(fullKey)) {
            return;
          }
          obj[i - 1].push(header[fullKey]);
        }
      }
      return obj;
    };

    Mapper.prototype.derivePC = function(header) {
      var cd, cd11, cd12, cd21, cd22, cos_rho, crota, lambda, rho_a, rho_b, _ref;
      if (header.hasOwnProperty('CROTA2')) {
        crota = header['CROTA2'];
        lambda = this.wcsobj.cdelt[1] / this.wcsobj.cdelt[0];
      } else {
        cd = this.checkCard(header, 'CD', this.wcsobj.naxis);
        if (cd == null) {
          _ref = [0, 1], crota = _ref[0], lambda = _ref[1];
        } else {
          cd11 = cd[0][0];
          cd12 = cd[0][1];
          cd21 = cd[1][0];
          cd22 = cd[1][1];
          if (cd21 > 0) {
            rho_a = Math.atan2(cd21, cd11);
          } else if (cd21 === 0) {
            rho_a = 0;
          } else {
            rho_a = Math.atan2(-cd21, -cd11);
          }
          if (cd12 > 0) {
            rho_b = Math.atan2(cd12, -cd22);
          } else if (cd12 === 0) {
            rho_b = 0;
          } else {
            rho_b = Math.atan2(-cd21, cd22);
          }
          crota = 0.5 * (rho_a + rho_b);
          cos_rho = Math.cos(crota);
          this.wcsobj.cdelt1 = cd11 / cos_rho;
          this.wcsobj.cdelt2 = cd22 / cos_rho;
          lambda = this.wcsobj.cdelt2 / this.wcsobj.cdelt1;
        }
      }
      return cd;
    };

    Mapper.prototype.setProjection = function(header) {
      var conic, cylindrical, key, key1, key2, key3, polyConic, quadCube, zenithal, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      zenithal = ['AIR', 'ARC', 'AZP', 'NCP', 'SIN', 'STG', 'SZP', 'TAN', 'TAN-SIP', 'ZEA', 'ZPN'];
      cylindrical = ['CYP', 'CEA', 'CAR', 'MER', 'SFL', 'PAR', 'MOL', 'AIT'];
      conic = ['COP', 'COE', 'COD', 'COO'];
      polyConic = ['BON', 'PCO'];
      quadCube = ['TSC', 'CSC', 'QSC'];
      this.projection = this.wcsobj.ctype[0].slice(5);
      this.longitudeAxis = this.wcsobj.ctype[0].match("RA|GLON|ELON|HLON|SLON") ? 1 : 2;
      this.latitudeAxis = this.wcsobj.ctype[1].match("DEC|GLAT|ELAT|HLAT|SLAT") ? 2 : 1;
      if (_ref = this.projection, __indexOf.call(zenithal, _ref) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 90;
        this.wcsobj.alphaP = this.wcsobj.crval[0];
        this.wcsobj.deltaP = this.wcsobj.crval[1];
        this.wcsobj.lonpole = this.wcsobj.crval[1] >= this.wcsobj.theta0 ? 0 : 180;
        switch (this.projection) {
          case 'AIR':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.thetaB = header.hasOwnProperty(key) ? parseFloat(header[key]) : 90;
            this.wcsobj.etaB = (90 - this.wcsobj.thetaB) / 2;
            ({
              toSpherical: function(x, y) {
                throw 'Sorry, not yet implemented!';
              },
              fromSpherical: function(phi, theta) {
                throw 'Sorry, not yet implemented!';
              }
            });
            break;
          case 'ARC':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - r;
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 90 - theta;
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'AZP':
            _ref1 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref1[0], key2 = _ref1[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.gamma = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'NCP':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'SIN':
            _ref2 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref2[0], key2 = _ref2[1];
            this.wcsobj.eta = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.nu = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.acosd(Math.PI * r / 180);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / Math.PI * WCS.Math.cosd(theta);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'STG':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.atand(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.tand((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'SZP':
            _ref3 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2", "PV" + this.latitudeAxis + "_3"], key1 = _ref3[0], key2 = _ref3[1], key3 = _ref3[2];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.phiC = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.wcsobj.thetaC = header.hasOwnProperty(key3) ? parseFloat(header[key3]) : 90;
            this.wcsobj.xp = -this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.sind(this.wcsobj.phiC);
            this.wcsobj.yp = this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.cosd(this.wcsobj.phiC);
            this.wcsobj.zp = this.wcsobj.mu * WCS.Math.sind(this.wcsobj.thetaC) + 1;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented';
            };
            this.fromSpherical = function(phi, theta) {
              var divisor, x, y;
              throw 'Sorry, not yet implemented';
              divisor = _this.wcsobj.zp - 1 + WCS.Math.sind(theta);
              x = (180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.sind(phi) - _this.wcsobj.xp * (1 - WCS.Math.sind(theta))) / divisor;
              y = (-180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.cosd(phi) + _this.wcsobj.yp * (1 - WCS.Math.sind(theta))) / divisor;
              return [x, y];
            };
            break;
          case 'TAN':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'TAN-SIP':
            this.getSipCoefficients(header);
            this.f = function(u, v, coeffs) {
              var order, p, q, value, _i, _j;
              value = 0;
              order = coeffs[0].length - 1;
              for (p = _i = 0; 0 <= order ? _i <= order : _i >= order; p = 0 <= order ? ++_i : --_i) {
                for (q = _j = 0; 0 <= order ? _j <= order : _j >= order; q = 0 <= order ? ++_j : --_j) {
                  value += coeffs[p][q] * Math.pow(u, p) * Math.pow(v, q);
                }
              }
              return value;
            };
            this.toIntermediate = function(points) {
              var dx, dy, i, j, proj, u, v, _i, _j, _ref4, _ref5;
              proj = [];
              u = points[0] - _this.wcsobj.crpix[0];
              v = points[1] - _this.wcsobj.crpix[1];
              dx = dy = 0;
              dx = _this.f(u, v, _this.sip.aCoeffs);
              dy = _this.f(u, v, _this.sip.bCoeffs);
              points[0] = points[0] + dx;
              points[1] = points[1] + dy;
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                proj[i] = 0;
                points[i] -= _this.wcsobj.crpix[i];
                for (j = _j = 0, _ref5 = _this.wcsobj - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  proj[i] += _this.wcsobj.cd[i][j] * points[j];
                }
              }
              return proj;
            };
            this.fromIntermediate = function(proj) {
              var dx, dy, i, j, points, tmp, _i, _j, _ref4, _ref5;
              tmp = [];
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                tmp[i] = 0;
                for (j = _j = 0, _ref5 = _this.wcsobj.naxis - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  tmp[i] += _this.wcsobj.cdInv[i][j] * proj[j];
                }
                tmp[i] += _this.wcsobj.crpix[i];
              }
              dx = dy = 0;
              dx = _this.f(tmp[0], tmp[1], _this.sip.apCoeffs);
              dy = _this.f(tmp[0], tmp[1], _this.sip.bpCoeffs);
              points = [];
              points[0] = tmp[0] + dx;
              points[1] = tmp[1] + dy;
              points[0] += _this.wcsobj.crpix[0];
              points[1] += _this.wcsobj.crpix[1];
              return points;
            };
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZEA':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.asind(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.sind((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZPN':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
        }
      }
      if (_ref4 = this.projection, __indexOf.call(cylindrical, _ref4) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        this.computeCelestialParameters(this.wcsobj.phi0, this.wcsobj.theta0);
        switch (this.projection) {
          case 'CYP':
            _ref5 = ["PV" + this.latitudeAxis + "_1,", "PV" + this.latitudeAxis + "_2"], key1 = _ref5[0], key2 = _ref5[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 1;
            this.wcsobj.lambda = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 1;
            if (this.wcsobj.mu + this.wcsobj.lambda === 0) {
              raise("Divide by zero error");
            }
            this.toSpherical = function(x, y) {
              var nu, phi, theta;
              nu = (Math.PI * y) / (180 * (_this.wcsobj.mu + _this.wcsobj.lambda));
              theta = WCS.Math.atan2d(nu, 1) + WCS.Math.asind(nu * _this.wcsobj.mu / Math.sqrt(nu * nu + 1));
              phi = x / _this.wcsobj.lambda;
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = _this.wcsobj.lambda * phi;
              y = (180 / Math.PI) * ((_this.wcsobj.mu + _this.wcsobj.lambda) / (_this.wcsobj.mu + WCS.Math.cosd(theta))) * WCS.Math.sind(theta);
              return [x, y];
            };
            break;
          case 'CEA':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.lambda = header.hasOwnProperty(key) ? parseFloat(header[key]) : 1;
            this.toSpherical = function(x, y) {
              var theta;
              theta = WCS.Math.asind(Math.PI * _this.wcsobj.lambda * y / 180);
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = 180 / Math.PI * WCS.Math.sind(theta) / _this.wcsobj.lambda;
              return [phi, y];
            };
            break;
          case 'CAR':
            this.toSpherical = function(x, y) {
              return [x, y];
            };
            this.fromSpherical = function(phi, theta) {
              return [phi, theta];
            };
            break;
          case 'MER':
            this.toSpherical = function(x, y) {
              var theta;
              theta = 2 * WCS.Math.atand(Math.exp(y * Math.PI / 180)) - 90;
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = (180 / Math.PI) * Math.log(WCS.Math.tand((90 + theta) / 2));
              return [phi, y];
            };
            break;
          case 'SFL':
            this.toSpherical = function(x, y) {
              var phi;
              phi = x / WCS.Math.cosd(y);
              return [phi, y];
            };
            this.fromSpherical = function(phi, theta) {
              var x;
              x = phi * WCS.Math.cosd(theta);
              return [x, theta];
            };
            break;
          case 'PAR':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = 3 * WCS.Math.asind(y / 180);
              phi = x / (1 - 4 * Math.pow(y / 180, 2));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = phi * (2 * WCS.Math.cosd(2 * theta / 3) - 1);
              y = 180 * WCS.Math.sind(theta / 3);
              return [x, y];
            };
            break;
          case 'MOL':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = WCS.Math.asind(WCS.Math.asind((Math.PI * y) / (180 * Math.sqrt(2))) / 90 + (y / 180) * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              phi = (Math.PI * x) / (2 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              throw 'Sorry, not yet implemented!';
              x = 2 * Math.sqrt(2) / Math.PI * phi * WCS.Math.cosd(gamma);
              y = Math.sqrt(2) * 180 / Math.PI * WCS.Math.sind(gamma);
              return [x, y];
            };
            break;
          case 'AIT':
            this.toSpherical = function(x, y) {
              var phi, theta, x_z, y_z, z;
              x_z = Math.pow((Math.PI * x) / (4 * 180), 2);
              y_z = Math.pow((Math.PI * y) / (2 * 180), 2);
              z = Math.sqrt(1 - x_z - y_z);
              theta = WCS.Math.asind(Math.PI * y * z / 180);
              phi = 2 * WCS.Math.atan2d(Math.PI * z * x / (2 * 180), 2 * z * z - 1);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var gamma, x, y;
              gamma = 180 / Math.PI * Math.sqrt(2 / (1 + WCS.Math.cosd(theta) * WCS.Math.cosd(phi / 2)));
              x = 2 * gamma * WCS.Math.cosd(theta) * WCS.Math.sind(phi / 2);
              y = gamma * WCS.Math.sind(theta);
              return [x, y];
            };
        }
      }
      if (_ref6 = this.projection, __indexOf.call(conic, _ref6) >= 0) {
        key = "PV" + this.latitudeAxis + "_1";
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = header.hasOwnProperty(key) ? header[key] : 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref7 = this.projection, __indexOf.call(polyConic, _ref7) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref8 = this.projection, __indexOf.call(quadCube, _ref8) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
    };

    Mapper.prototype.getSipCoefficients = function(header) {
      var i, j, key, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (!(header.hasOwnProperty('A_ORDER') || header.hasOwnProperty('B_ORDER'))) {
        throw "What's the polynomial order, man!";
      }
      this.sip = {};
      this.sip.aOrder = header.A_ORDER;
      this.sip.bOrder = header.B_ORDER;
      this.sip.apOrder = header.AP_ORDER || 0;
      this.sip.bpOrder = header.BP_ORDER || 0;
      this.sip.aCoeffs = [];
      this.sip.bCoeffs = [];
      this.sip.apCoeffs = [];
      this.sip.bpCoeffs = [];
      for (i = _i = 0, _ref = this.sip.aOrder; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sip.aCoeffs[i] = [];
        for (j = _j = 0, _ref1 = this.sip.aOrder; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          key = "A_" + i + "_" + j;
          this.sip.aCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _k = 0, _ref2 = this.sip.bOrder; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.sip.bCoeffs[i] = [];
        for (j = _l = 0, _ref3 = this.sip.bOrder; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
          key = "B_" + i + "_" + j;
          this.sip.bCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _m = 0, _ref4 = this.sip.apOrder; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        this.sip.apCoeffs[i] = [];
        for (j = _n = 0, _ref5 = this.sip.apOrder; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          key = "AP_" + i + "_" + j;
          this.sip.apCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _o = 0, _ref6 = this.sip.bpOrder; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
        this.sip.bpCoeffs[i] = [];
        for (j = _p = 0, _ref7 = this.sip.bpOrder; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
          key = "BP_" + i + "_" + j;
          this.sip.bpCoeffs[i][j] = header[key] || 0;
        }
      }
      if (!(this.sip.aCoeffs || this.sip.bCoeffs)) {
        throw "Where are the coefficients dude!";
      }
    };

    Mapper.prototype.computeCelestialParameters = function(phi0, theta0) {
      var alpha0, delta0, deltaP1, deltaP2, dist1, dist2, phiP, sol1, sol2, thetaP, _ref, _ref1;
      _ref = this.wcsobj.crval, alpha0 = _ref[0], delta0 = _ref[1];
      _ref1 = [this.wcsobj.lonpole, this.wcsobj.latpole], phiP = _ref1[0], thetaP = _ref1[1];
      deltaP1 = WCS.Math.atan2d(WCS.Math.sind(this.wcsobj.theta0), WCS.Math.cosd(this.wcsobj.theta0 * WCS.Math.cosd(phiP - this.wcsobj.phi0)));
      deltaP2 = WCS.Math.acosd(WCS.Math.sind(delta0) / Math.sqrt(1 - Math.pow(WCS.Math.cosd(this.wcsobj.theta0), 2) * Math.pow(WCS.Math.sind(phiP - this.wcsobj.phi0), 2)));
      sol1 = sol2 = false;
      if (deltaP1 + deltaP2 >= -90 && deltaP1 + deltaP2 <= 90) {
        sol1 = true;
      }
      if (deltaP1 - deltaP2 >= -90 && deltaP1 - deltaP2 <= 90) {
        sol2 = true;
      }
      if (sol1 && sol2) {
        dist1 = Math.abs(deltaP1 + deltaP2 - thetaP);
        dist2 = Math.abs(deltaP1 - deltaP2 - thetaP);
        this.wcsobj.deltaP = dist1 < dist2 ? deltaP1 + deltaP2 : deltaP1 - deltaP2;
      } else if (sol1) {
        this.wcsobj.deltaP = deltaP1 + deltaP2;
      } else if (sol2) {
        this.wcsobj.deltaP = deltaP1 - deltaP2;
      } else {
        this.wcsobj.deltaP = thetaP;
      }
      return this.wcsobj.alphaP = Math.abs(delta0) === 90 ? alpha0 : alpha0 - WCS.Math.asind(WCS.Math.sind(phiP - this.wcsobj.phi0) * WCS.Math.cosd(this.wcsobj.theta0) / WCS.Math.cosd(delta0));
    };

    Mapper.prototype.toIntermediate = function(points) {
      var i, j, proj, _i, _j, _ref, _ref1;
      proj = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        proj[i] = 0;
        points[i] -= this.wcsobj.crpix[i];
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          proj[i] += this.wcsobj.cdelt[i] * this.wcsobj.pc[i][j] * points[j];
        }
      }
      return proj;
    };

    Mapper.prototype.fromIntermediate = function(proj) {
      var i, j, points, _i, _j, _ref, _ref1;
      points = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        points[i] = 0;
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          points[i] += this.wcsobj.pcInv[i][j] * proj[j] / this.wcsobj.cdelt[i];
        }
        points[i] += this.wcsobj.crpix[i];
      }
      return points;
    };

    Mapper.prototype.toCelestial = function(phi, theta) {
      var cosDecP, cosDphi, cosTheta, dec, ra, sinDecP, sinDphi, sinTheta, xTemp, yTemp, zTemp;
      sinTheta = WCS.Math.sind(theta);
      cosTheta = WCS.Math.cosd(theta);
      sinDphi = WCS.Math.sind(phi - this.wcsobj.lonpole);
      cosDphi = WCS.Math.cosd(phi - this.wcsobj.lonpole);
      sinDecP = WCS.Math.sind(this.wcsobj.deltaP);
      cosDecP = WCS.Math.cosd(this.wcsobj.deltaP);
      xTemp = sinTheta * cosDecP - cosTheta * sinDecP * cosDphi;
      yTemp = -cosTheta * sinDphi;
      zTemp = sinTheta * sinDecP + cosTheta * cosDecP * cosDphi;
      ra = WCS.Math.atan2d(yTemp, xTemp) + this.wcsobj.alphaP;
      ra = (ra + 360) % 360;
      dec = WCS.Math.asind(zTemp);
      return [ra, dec];
    };

    Mapper.prototype.fromCelestial = function(ra, dec) {
      var cosDalpha, cosDelta, cosDp, phi, sinDalpha, sinDelta, sinDp, theta, xTemp, yTemp;
      sinDelta = WCS.Math.sind(dec);
      cosDelta = WCS.Math.cosd(dec);
      sinDp = WCS.Math.sind(this.wcsobj.deltaP);
      cosDp = WCS.Math.cosd(this.wcsobj.deltaP);
      sinDalpha = WCS.Math.sind(ra - this.wcsobj.alphaP);
      cosDalpha = WCS.Math.cosd(ra - this.wcsobj.alphaP);
      xTemp = sinDelta * cosDp - cosDelta * sinDp * cosDalpha;
      yTemp = -cosDelta * sinDalpha;
      phi = this.wcsobj.lonpole + WCS.Math.atan2d(yTemp, xTemp);
      theta = WCS.Math.asind(sinDelta * sinDp + cosDelta * cosDp * cosDalpha);
      return [phi, theta];
    };

    Mapper.prototype.pixelToCoordinate = function() {
      var coords;
      coords = this.toIntermediate(arguments[0], arguments[1]);
      coords = this.toSpherical(coords[0], coords[1]);
      coords = this.toCelestial(coords[0], coords[1]);
      return {
        ra: coords[this.longitudeAxis - 1],
        dec: coords[this.latitudeAxis - 1]
      };
    };

    Mapper.prototype.coordinateToPixel = function() {
      var coords;
      coords = this.fromCelestial(arguments[0], arguments[1]);
      coords = this.fromSpherical(coords[0], coords[1]);
      coords = this.fromIntermediate(coords);
      return {
        x: coords[0],
        y: coords[1]
      };
    };

    return Mapper;

  })();

}).call(this);

define("wcs", function(){});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/UtilsFits',["wcs"], function(wcs) {
    var UtilsFits = {};

    function createCoordinate(x, y) {
        var coordinate = wcs.pixelToCoordinate([x, y]);
        return [coordinate.ra, coordinate.dec];
    }

    /**
     *    Get GeoJson polygon coordinates representing fits using wcs data from header
     */
    UtilsFits.getPolygonCoordinatesFromFits = function(fits) {
        var hdu = fits.getHDU();
        var fitsData = hdu.data;

        // Create mapper
        wcs = new WCS.Mapper(hdu.header);
        var coords = [];

        // Find coordinates of coming fits
        coords.push(createCoordinate(0, fitsData.height));
        coords.push(createCoordinate(fitsData.width, fitsData.height));
        coords.push(createCoordinate(fitsData.width, 0));
        coords.push(createCoordinate(0, 0));
        // Close the polygon
        coords.push(coords[0]);
        return coords;
    };

    return UtilsFits;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/FeatureStyle',["../Utils/Constants"], function(Constants) {
    // Simple colors
    var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
    };

    var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
    var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
    var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;

    /**************************************************************************************************************/

    /**
     @name FeatureStyle
     @class
         The style to display a Feature
     @param {JSON} style an object containing the following style properties
     <ul>
     <li>strokeColor : the color for line, or polygon outline</li>
     <li>strokeWidth : the width of a line</li>
     <li>fillColor : the color for solid polygon or point</li>
     <li>fillTextureUrl : the texture for solid polygon</li>
     <li>iconUrl : the icon to be used for point</li>
     <li>pointMaxSize : Distance maximum (in meter) from the ground to the camera for which a point is displayed</li>
     <li>extrusionScale : extrusion scale (in meter)</li>
     </ul>
     @constructor
     */
    var FeatureStyle = function(style) {
        // Color used for lines or polygon outline
        this.strokeColor = [1.0, 0.0, 0.0, 1.0];
        // Color used to full polygon
        this.fillColor = [1.0, 0.0, 0.0, 1.0];
        this.fillTextureUrl = null;
        this.fillTexture = null;
        this.fillShader = null;
        this.strokeWidth = 1;
        this.iconUrl = null;
        this.icon = null;
        this.label = null;
        this.textColor = [1.0, 1.0, 1.0, 1.0];
        this.fill = false;
        this.pointMaxSize = 40;
        this.opacity = 1.0;
        this.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
        this.extrusionScale = 1.0;

        if (style) {
            for (var s in style) {
                if (style.hasOwnProperty(s)) {
                    this[s] = style[s];
                }
            }
        }
    };

    /**
     Convert a color from a string to RGB
     @function fromStringToColor
     @memberof FeatureStyle
     @param {String} color_string Color string
     @return {float[]} array with [r,g,b,alpha]
     */
    FeatureStyle.fromStringToColor = function(color_string) {
        var r = 0,
            g = 0,
            b = 0,
            a = 255;
        var match;

        color_string = color_string.trim();
        color_string = color_string.toLowerCase();
        // strip any leading #
        if (color_string.charAt(0) === "#") {
            // remove # if any
            color_string = color_string.substr(1, 6);
        }

        // Convert a litteral color to rgb string
        if (simple_colors.hasOwnProperty(color_string)) {
            color_string = simple_colors[color_string];
        }

        match = parseHex.exec(color_string);
        if (match) {
            r = parseInt(match[1], 16);
            g = parseInt(match[2], 16);
            b = parseInt(match[3], 16);
        }

        match = parseRgb.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
        }

        match = parseRgba.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
            a = parseInt(match[4], 10);
        }

        // validate/cleanup values
        r = r < 0 ? 0 : r > 255 ? 255 : r;
        g = g < 0 ? 0 : g > 255 ? 255 : g;
        b = b < 0 ? 0 : b > 255 ? 255 : b;
        a = a < 0 ? 0 : a > 255 ? 255 : a;

        return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
    };

    /**************************************************************************************************************/

    /**
     Convert an internal color to a string based color representation
     @function fromColorToString
     @memberof FeatureStyle
     @param {float[]} color array with [r,g,b]
     @return {String}Color string
     */
    FeatureStyle.fromColorToString = function(color) {
        var hashColor = "#";
        for (var i = 0; i < 3; i++) {
            var component = parseInt(color[i] * 255.0, 10).toString(16);
            hashColor += component < 10 ? "0" + component : component;
        }

        return hashColor;
    };

    FeatureStyle.prototype.getStrokeColor = function() {
        return this.strokeColor;
    };

    FeatureStyle.prototype.setStrokeColor = function(strokeColor) {
        this.strokeColor = strokeColor;
        return this.strokeColor;
    };

    FeatureStyle.prototype.getFillColor = function() {
        return this.fillColor;
    };

    FeatureStyle.prototype.setFillColor = function(fillColor) {
        this.fillColor = fillColor;
        return this.fillColor;
    };

    FeatureStyle.prototype.getFillTextureURL = function() {
        return this.fillTextureUrl;
    };

    FeatureStyle.prototype.setFillTextureURL = function(fillTextureURL) {
        this.fillTextureUrl = fillTextureURL;
        return this.fillTextureUrl;
    };

    FeatureStyle.prototype.getFillTexture = function() {
        return this.fillTexture;
    };

    FeatureStyle.prototype.setFillTexture = function(fillTexture) {
        this.fillShader = fillTexture;
        return this.fillShader;
    };

    FeatureStyle.prototype.getFillShader = function() {
        return this.fillShader;
    };

    FeatureStyle.prototype.setFillShader = function(fillShader) {
        this.fillShader = fillShader;
        return this.fillShader;
    };

    FeatureStyle.prototype.getStrokeWidth = function() {
        return this.strokeWidth;
    };

    FeatureStyle.prototype.setStrokeWidth = function(strokeWidth) {
        this.strokeWidth = strokeWidth;
        return this.strokeWidth;
    };

    FeatureStyle.prototype.getIconURL = function() {
        return this.iconUrl;
    };

    FeatureStyle.prototype.setIconURL = function(iconURL) {
        this.iconUrl = iconURL;
        return this.iconUrl;
    };

    FeatureStyle.prototype.getIcon = function() {
        return this.icon;
    };

    FeatureStyle.prototype.setIcon = function(icon) {
        this.icon = icon;
    };

    FeatureStyle.prototype.getLabel = function() {
        return this.label;
    };

    FeatureStyle.prototype.setLabel = function(label) {
        this.label = label;
    };

    FeatureStyle.prototype.getTextColor = function() {
        return this.textColor;
    };

    FeatureStyle.prototype.setTextColor = function(textColor) {
        this.textColor = textColor;
        return this.textColor;
    };

    FeatureStyle.prototype.isFill = function() {
        return this.isFill;
    };

    FeatureStyle.prototype.setFill = function(isFill) {
        this.isFill = isFill;
        return this.isFill;
    };

    FeatureStyle.prototype.getPointMaxSize = function() {
        return this.pointMaxSize;
    };

    FeatureStyle.prototype.setPointMaxSize = function(pointMaxSize) {
        this.pointMaxSize = pointMaxSize;
    };

    FeatureStyle.prototype.getOpacity = function() {
        return this.opacity;
    };

    FeatureStyle.prototype.setOpacity = function(opacity) {
        if (typeof opacity === "number" && opacity >= 0.0 && opacity <= 1.0) {
            this.opacity = opacity;
        } else {
            throw new RangeError(
                "opacity value should be a value in [0..1]",
                "AbstractLayer.js"
            );
        }
    };

    FeatureStyle.prototype.getZIndex = function() {
        return this.zIndex;
    };

    FeatureStyle.prototype.setZIndex = function(zIndex) {
        this.zIndex = zIndex;
        return this.zIndex;
    };

    /**
     * Get extrusion scale
     * @function getExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @return {float} Extrusion scale
     */
    FeatureStyle.prototype.getExtrusionScale = function() {
        return this.extrusionScale;
    };

    /**
     * Set extrusion scale
     * @function setExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @param {float} value Extrusion scale
     */
    FeatureStyle.prototype.setExtrusionScale = function(value) {
        this.extrusionScale = value;
    };

    /**************************************************************************************************************/

    return FeatureStyle;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Utils/UtilityFactory',[
    "./Constants",
    "./UtilsFits",
    "./Numeric",
    "./UtilsIntersection",
    "../Renderer/FeatureStyle"
], function(Constants, UtilsFits, Numeric, UtilsIntersection, FeatureStyle) {
    return {
        create: function(type, options) {
            var obj;
            switch (type) {
                case Constants.UTILITY.Fits:
                    obj = UtilsFits;
                    break;
                case Constants.UTILITY.Intersection:
                    obj = UtilsIntersection;
                    break;
                case Constants.UTILITY.Numeric:
                    obj = Numeric;
                    break;
                case Constants.UTILITY.CreateStyle:
                    obj = new FeatureStyle(options);
                    break;
                case Constants.UTILITY.FeatureStyle:
                    obj = FeatureStyle;
                    break;
                default:
                    throw new RangeError(
                        "Cannot create the utility " + type,
                        "UtilityFactory.js"
                    );
            }
            return obj;
        }
    };
});

var xmlToJSON = function () { this.version = "1.3.5"; var e = { mergeCDATA: !0, grokAttr: !0, grokText: !0, normalize: !0, xmlns: !0, namespaceKey: "_ns", textKey: "_text", valueKey: "_value", attrKey: "_attr", cdataKey: "_cdata", attrsAsObject: !0, stripAttrPrefix: !0, stripElemPrefix: !0, childrenAsArray: !0 }, t = new RegExp(/(?!xmlns)^.*:/), r = new RegExp(/^\s+|\s+$/g); return this.grokType = function (e) { return /^\s*$/.test(e) ? null : /^(?:true|false)$/i.test(e) ? "true" === e.toLowerCase() : isFinite(e) ? parseFloat(e) : e }, this.parseString = function (e, t) { return this.parseXML(this.stringToXML(e), t) }, this.parseXML = function (a, n) { for (var s in n) e[s] = n[s]; var l = {}, i = 0, o = ""; if (e.xmlns && a.namespaceURI && (l[e.namespaceKey] = a.namespaceURI), a.attributes && a.attributes.length > 0) { var c = {}; for (i; i < a.attributes.length; i++) { var u = a.attributes.item(i); m = {}; var p = ""; p = e.stripAttrPrefix ? u.name.replace(t, "") : u.name, e.grokAttr ? m[e.valueKey] = this.grokType(u.value.replace(r, "")) : m[e.valueKey] = u.value.replace(r, ""), e.xmlns && u.namespaceURI && (m[e.namespaceKey] = u.namespaceURI), e.attrsAsObject ? c[p] = m : l[e.attrKey + p] = m } e.attrsAsObject && (l[e.attrKey] = c) } if (a.hasChildNodes()) for (var y, d, m, h = 0; h < a.childNodes.length; h++)4 === (y = a.childNodes.item(h)).nodeType ? e.mergeCDATA ? o += y.nodeValue : l.hasOwnProperty(e.cdataKey) ? (l[e.cdataKey].constructor !== Array && (l[e.cdataKey] = [l[e.cdataKey]]), l[e.cdataKey].push(y.nodeValue)) : e.childrenAsArray ? (l[e.cdataKey] = [], l[e.cdataKey].push(y.nodeValue)) : l[e.cdataKey] = y.nodeValue : 3 === y.nodeType ? o += y.nodeValue : 1 === y.nodeType && (0 === i && (l = {}), d = e.stripElemPrefix ? y.nodeName.replace(t, "") : y.nodeName, m = xmlToJSON.parseXML(y), l.hasOwnProperty(d) ? (l[d].constructor !== Array && (l[d] = [l[d]]), l[d].push(m)) : (e.childrenAsArray ? (l[d] = [], l[d].push(m)) : l[d] = m, i++)); else o || (e.childrenAsArray ? (l[e.textKey] = [], l[e.textKey].push(null)) : l[e.textKey] = null); if (o) if (e.grokText) { var x = this.grokType(o.replace(r, "")); null !== x && void 0 !== x && (l[e.textKey] = x) } else e.normalize ? l[e.textKey] = o.replace(r, "").replace(/\s+/g, " ") : l[e.textKey] = o.replace(r, ""); return l }, this.xmlToString = function (e) { try { return e.xml ? e.xml : (new XMLSerializer).serializeToString(e) } catch (e) { return null } }, this.stringToXML = function (e) { try { var t = null; return window.DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = !1, t.loadXML(e), t) } catch (e) { return null } }, this }.call({}); "undefined" != typeof module && null !== module && module.exports ? module.exports = xmlToJSON : "function" == typeof define && define.amd && define('xmltojson',[],function () { return xmlToJSON });
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/AbstractLayer',[
    "jquery",
    "underscore-min",
    "../Utils/Event",
    "moment",
    "../Time/Time",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/UtilityFactory",
    "xmltojson",
    "../Error/NetworkError"
], function(
    $,
    _,
    Event,
    Moment,
    Time,
    Utils,
    Constants,
    UtilityFactory,
    XmlToJson,
    NetworkError
) {
    const DEFAULT_ICON =
        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMBQkVBRMIQtMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAvklEQVQY012QMWpCURBFz3yfG7CIwSatpLGwsJJsQEHssr2UttapkkK0zRJEFPKLj5UYPGme8vgDt5l7uNwZKEYNdaZO1FR6VQkBT8AbMAGe1e7dTwXUB8bAFPgF9sBWPUXENbWgBTAELkCTw7bqMdR5kTQCehlogB/gE/iqcs9OVhT9I8v7EZU6UJfqh3pWa3WlvqsvakoRcVOPwCYnvQI1sM67Q0T8JYAWvAEOwDewj4jr4z0teJdf84AA/gF1uG92uhcfoAAAAABJRU5ErkJggg==";

    /**
     * AbstractLayer configuration
     * @typedef {Object} AbstractLayer.configuration
     * @property {String} [name=""] - Layer name
     * @property {String} [attribution=""] - Attribution
     * @property {String} [copyrightUrl=""] - Copyright URL
     * @property {String} [ack=""] - ack
     * @property {String} [icon=a default image] - An icon to represent the layer
     * @property {String} [description=""] - A description
     * @property {boolean} [visible=true] - A boolean flag to display the layer
     * @property {Object} [properties={}] properties
     * @property {boolean} [pickable=false] - Sets to true to make the layer pickable
     * @property {boolean} [service=[]] - List of services related to the layer
     * @property {GEOMETRY} dataType - the data type for vector layers
     * @property background
     * @property category
     * @param {Crs} coordinateSystem
     * @param {string} [format=""]
     * @param {string} [baseUrl=""]
     * @param {boolean} [deletable=""]
     * @param {Array} [color= a random color]
     * @param {float} [opacity=1.0] - An opacity value
     * @param {FeatureStyle} [style]
     * @param {Array} [services=[]}
     * @param {layerCallback} callback - A callback that transfoms data.
     */

    /**
     * Time configuration
     * @typedef {Object} Time.configuration
     * @property {date} date - Current date
     * @property {string} display - Current date as text for display
     * @property {Time.period.configuration}  - Period
     */

    /**
     * Time period configuration
     * @typedef {Object} Time.period.configuration
     * @property {date} from - start date
     * @property {date} to - stop date
     */

    /**
     * This callback allows to transform FeatureCollection from a GeoJson.
     * @callback layerCallback
     * @param {data} FeatureCollection
     */

    /**
     * @name AbstractLayer
     * @class
     *   Abstract class for creating layer.
     * @augments Event
     * @param {LAYER} type - layer type
     * @param {AbstractLayer.configuration} options - Layer Configuration
     * @constructor
     * @implements {Layer}
     */
    var AbstractLayer = function(type, options) {
        Event.prototype.constructor.call(this, options);

        this.globe = null;
        this.options = options || {};
        this.ID = "URN:Mizar:Layer:" + _.uniqueId(this.constructor.name + ":");
        this.name = this.options.name != null ? this.options.name : "";
        this.attribution = this.options.attribution || "";
        this.copyrightUrl = this.options.copyrightUrl || "";
        this.ack = this.options.ack || "";
        this.description = this.options.description || "";
        this.visible = this.options.visible || false;
        this.properties = this.options.properties || {};
        this.services = this.options.services || [];
        this.type = type;
        this.pickable = this.options.pickable || false;
        this.dataType = this.options.dataType || "";
        this.background = options.background || false;
        this.category = this.options.background
            ? "background"
            : this.options.category;
        this.coordinateSystem = options.coordinateSystem;
        this.format = this.options.format || "";
        this.baseUrl = this.options.baseUrl || "";
        this.deletable = this.options.deletable || false;
        this.dimension = this.options.dimension;
        this.callbackContext = null;
        this.linkedTo = this.options.linkedTo || "";
        this.servicesRunningOnCollection = [];
        this.servicesRunningOnRecords = {};
        this.vectorLayer = false;
        this.metadataAPI = this.options.metadataAPI
            ? this.options.metadataAPI
            : null;
        this.time = null;
        // Do we take DEM into account with this layer ?
        this.pickingNoDEM = this.options.pickingNoDEM
            ? this.options.pickingNoDEM
            : false;

        // Set if we need to auto fill the time travel range/step with auto discovered time values
        this.autoFillTimeTravel = this.options.autoFillTimeTravel
            ? this.options.autoFillTimeTravel
            : false;

        // Create style if needed
        this.style = _createStyle.call(this, this.options, this.icon);

        // Ensure that the attribution link will be opened in new tab
        if (
            this.attribution &&
            this.attribution.search("<a") >= 0 &&
            this.attribution.search("target=") < 0
        ) {
            this.attribution = this.attribution.replace(" ", " target=_blank ");
        }

        //this.services = _createAvailableServices(this.options);
        this.multiLayers = [];

        //cache to know which custom (e;g time, style, ...) Raster parameters are send
        this.imageLoadedAtTime = {};

        /**
         * Used to allow/deny http request
         * @type {boolean}
         */
        this.allowedHTTPRequest = true;
    };

    function _createAvailableServices(options) {
        var availableServices;
        if (options.hasOwnProperty("availableServices")) {
            availableServices = options.availableServices;
        } else {
            availableServices = [];
        }
        return availableServices;
    }

    /**
     * Create style
     * @param options
     * @returns {*}
     * @private
     */
    function _createStyle(options) {
        var style;
        if (options.hasOwnProperty("style")) {
            // we use style from layerDescription.
            style = UtilityFactory.create(
                Constants.UTILITY.CreateStyle,
                options.style
            );
        } else if (options.style === "FeatureStyle") {
            // use a previous definition
            style = options.style;
        } else {
            // Update layer color
            var color = _createColor.call(this, options);

            // Layer opacity must be in range [0, 1]
            var opacity = _createOpacity.call(this, options);

            // Create a default icon if needed.
            var icon = _createIcon.call(this, options);

            // Create a default zIndex if needed
            var zIndex = _createZIndex.call(this, options);

            // create default style
            style = UtilityFactory.create(Constants.UTILITY.CreateStyle, {
                rendererHint: "Basic",
                opacity: opacity,
                iconUrl: icon,
                fillColor: color,
                strokeColor: color,
                zIndex: zIndex
            });
        }
        return style;
    }

    function _createZIndex(options) {
        var zIndex;
        if (options.hasOwnProperty("zIndex")) {
            zIndex = options.zIndex;
        } else {
            zIndex = Constants.DISPLAY.DEFAULT_RASTER;
        }
        return zIndex;
    }

    function _createIcon(options) {
        var icon;
        if (options.hasOwnProperty("icon")) {
            icon = options.icon;
        } else {
            icon = DEFAULT_ICON;
        }
        return icon;
    }

    /**
     * Creates opacity
     * @param options
     * @returns {*}
     * @private
     */
    function _createOpacity(options) {
        var opacity;
        if (options.hasOwnProperty("opacity")) {
            opacity = options.opacity / 100.0;
        } else {
            opacity = 1.0;
        }
        return opacity;
    }

    /**
     * Creates color.
     * @param options
     * @returns {*}
     * @private
     */
    function _createColor(options) {
        var color;
        if (options.hasOwnProperty("color")) {
            color =
                options.color instanceof Array
                    ? options.color
                    : UtilityFactory.create(
                          Constants.UTILITY.FeatureStyle
                      ).fromStringToColor(options.color);
        } else {
            // Generate random color
            var rgb = Utils.generateColor();
            color = rgb.concat([1]);
        }
        return color;
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, AbstractLayer);

    /**************************************************************************************************************/

    /**
     * Tests if the layer must be refreshed.
     * @param {string} param parameter
     * @param value value
     * @return {boolean} true when the layer must be refreshed otherwise false
     * @private
     */
    AbstractLayer.prototype._hasToBeRefreshed = function(param, value) {
        var mustBeRefreshed = false;
        if (param === "time" && this.containsDimension(param)) {
            var time = Time.parse(value);
            var isInTimeDimension = time.isInTimeDefinition(
                this.getDimensions().time.value
            );
            value = isInTimeDimension ? time.getDisplayValue() : null;
            this.allowedHTTPRequest = value !== null;
        } else if (param === "time") {
            mustBeRefreshed = false;
            return mustBeRefreshed;
        }
        if (this.imageLoadedAtTime[param] === undefined) {
            // this a new parameter, then we refresh
            mustBeRefreshed = true;
            this.imageLoadedAtTime[param] = value;
        } else if (this.imageLoadedAtTime[param] === value) {
            mustBeRefreshed = false;
        } else {
            mustBeRefreshed = true;
            this.imageLoadedAtTime[param] = value;
        }
        return mustBeRefreshed;
    };

    AbstractLayer.prototype.hasDimension = function() {
        return this.dimension != null;
    };

    AbstractLayer.prototype.getDimensions = function() {
        return this.dimension == null ? {} : this.dimension;
    };

    AbstractLayer.prototype.containsDimension = function(variable) {
        return this.hasDimension() && this.dimension[variable] != null;
    };

    /**
     * return short name
     * @function getShortName
     * @memberof AbstractLayer#
     * @return {String} Short name
     */
    AbstractLayer.prototype.getShortName = function() {
        var shortName = Utils.formatId(this.name);
        if (typeof shortName === "string") {
            shortName = shortName
                .replace(/[^a-z0-9\s]/gi, "")
                .replace(/[_\s]/g, "-");
        }

        return shortName;
    };

    /**************************************************************************************************************/

    /**
     * @function hasServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnCollection = function() {
        return this.servicesRunningOnCollection.length > 0;
    };

    /**************************************************************************************************************/

    /**
     * @function postProcessDateTime
     * @memberof AbstractLayer#
     */
    /*        AbstractLayer.prototype.postProcessTime = function (time) {
         return time;
         };
         */
    /**************************************************************************************************************/

    /**
     * @function setDateTime
     * @memberof AbstractLayer#
     * @param {Time.configuration} time configuration
     */
    AbstractLayer.prototype.setTime = function(time) {
        this.time = time;
    };

    /**************************************************************************************************************/

    /**
     * @function forceRefresh
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.forceRefresh = function() {
        var tileManager = this.getGlobe().getTileManager();
        tileManager.updateVisibleTiles(this);
        this.getGlobe().refresh();
    };

    /**
     * @function getServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnCollection = function() {
        var layers = [];
        for (var layerIndex in this.servicesRunningOnCollection) {
            var layerID = this.servicesRunningOnCollection[layerIndex];
            var layer = this.callbackContext.getLayerByID(layerID);
            if (layer != null) {
                layers.push(layer);
            }
        }
        return layers;
    };

    /**
     * @function removeServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnCollection = function() {
        for (var layerIndex in this.servicesRunningOnCollection) {
            var layerID = this.servicesRunningOnCollection[layerIndex];
            this.callbackContext.removeLayer(layerID);
        }
        return this.servicesRunningOnCollection.length === 0;
    };

    /**
     * @function hasServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnRecords = function() {
        return Object.keys(this.servicesRunningOnRecords).length > 0;
    };

    /**
     * @function getServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnRecords = function() {
        var layers = [];
        for (var featureIndex in this.servicesRunningOnRecords) {
            var featureID = this.servicesRunningOnRecords[featureIndex];
            layers = layers.concat(this.getServicesRunningOnRecord(featureID));
        }
        return layers;
    };

    /**
     * @function removeServicesRunningOnRecords
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnRecords = function() {
        for (var featureID in this.servicesRunningOnRecords) {
            this.removeServicesRunningOnRecord(featureID);
        }
        return Object.keys(this.servicesRunningOnRecords).length === 0;
    };

    /**
     * @function hasServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.hasServicesRunningOnRecord = function(featureID) {
        return this.servicesRunningOnRecords.hasOwnProperty(featureID);
    };

    /**
     * @function getServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServicesRunningOnRecord = function(featureID) {
        var layers = [];
        if (this.hasServicesRunningOnRecord(featureID)) {
            var servicesForFeatureID = this.servicesRunningOnRecords[featureID];
            for (var layerIndex in servicesForFeatureID.layerIds) {
                var layerID = servicesForFeatureID[layerIndex];
                var layer = this.callbackContext.getLayerByID(layerID);
                if (layer != null) {
                    layers.push(layer);
                }
            }
        } else {
            // do nothing
        }
        return layers;
    };

    /**
     * @function addServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.addServicesRunningOnRecord = function(
        featureID,
        layerIDs
    ) {
        var isAdded;
        if (
            featureID != null &&
            layerIDs != null &&
            !this.hasServicesRunningOnRecord(featureID)
        ) {
            var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
            this.servicesRunningOnRecords[featureID] = {
                layerIds: layersIDArray
            };
            isAdded = true;
        } else {
            isAdded = false;
        }
        return isAdded;
    };

    /**
     * @function removeServicesRunningOnRecord
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.removeServicesRunningOnRecord = function(
        featureID
    ) {
        var isRemoved;
        if (this.hasServicesRunningOnRecord(featureID)) {
            var servicesForFeatureID = this.servicesRunningOnRecords[featureID];
            for (var layerIndex in servicesForFeatureID.layerIds) {
                var layerID = servicesForFeatureID.layerIds[layerIndex];
                this.callbackContext.removeLayer(layerID);
            }
            delete this.servicesRunningOnRecords[featureID];
            isRemoved = true;
        } else {
            isRemoved = false;
        }
        return isRemoved;
    };

    /**
     * @function addServicesRunningOnCollection
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.addServicesRunningOnCollection = function(
        layerIDs
    ) {
        var isAdded;
        if (layerIDs != null) {
            var layersIDArray = Array.isArray(layerIDs) ? layerIDs : [layerIDs];
            this.servicesRunningOnCollection = this.servicesRunningOnCollection.concat(
                layersIDArray
            );
            isAdded = true;
        } else {
            isAdded = false;
        }
        return isAdded;
    };

    /**************************************************************************************************************/

    /**
     * Get getCapabilities url
     * @function getGetCapabilitiesUrl
     * @memberof AbstractLayer#
     * @return {String} url
     */
    AbstractLayer.prototype.getGetCapabilitiesUrl = function() {
        return this.proxify(this.getCapabilitiesUrl);
    };

    /**************************************************************************************************************/

    /**
     * Load the getCapabilities into json variable
     * @function loadGetCapabilities
     * @memberof AbstractLayer
     * @param {function} callback Callback function
     * @param {String} paramUrl url (if ommited, reconstructed with getCapabilitiesUrl)
     * @param {Object} sourceObject source object
     * @return {JSON} data loaded
     */
    AbstractLayer.prototype.loadGetCapabilities = function(
        callback,
        paramUrl,
        sourceObject
    ) {
        var url;
        var urlRaw;
        if (typeof paramUrl === "undefined") {
            url = this.getGetCapabilitiesUrl();
            urlRaw = this.getCapabilitiesUrl;
        } else {
            url = this.proxify(paramUrl);
            urlRaw = paramUrl;
        }
        $.ajax({
            type: "GET",
            url: url,
            dataType: "text",
            async: false,
            success: function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var result = XmlToJson.parseString(response, myOptions);
                callback(result, sourceObject);
            },
            error: function(xhr, ajaxOptions, thrownError) {
                throw new NetworkError(
                    thrownError.message,
                    "AbstractLayer.js",
                    thrownError.code
                );
            }
        });
    };

    /**************************************************************************************************************/

    /**
     * Proxify an url
     * @function proxify
     * @memberof AbstractLayer#
     * @param {String} url - URL
     * @return {String} Url proxified
     */
    AbstractLayer.prototype.proxify = function(url) {
        return Utils.proxify(url, this.options.proxy);
    };

    /**
     * @function getMetadataAPI
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getMetadataAPI = function() {
        return this.metadataAPI;
    };

    /**
     * @function getGlobe
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getGlobe = function() {
        return this.globe;
    };

    /**
     * @function getID
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getID = function() {
        return this.ID;
    };

    /**
     * @function getName
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getName = function() {
        return this.name;
    };

    /**
     * @function getInformationType
     * @memberof AbstractLayer#
     * @abstract
     */
    AbstractLayer.prototype.getInformationType = function() {
        throw new SyntaxError(
            "getInformationType not implemented",
            "AbstractLayer.js"
        );
    }

    /**
     * @function getAttribution
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getAttribution = function() {
        return this.attribution;
    };

    /**
     * @function getCopyrightUrl
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getCopyrightUrl = function() {
        return this.copyrightUrl;
    };

    /**
     * @function getAck
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getAck = function() {
        return this.ack;
    };

    /**
     * @function getDescription
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * @function isVisible
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isVisible = function() {
        return this.visible;
    };

    /**
     * @function setOnTheTop
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.setOnTheTop = function() {
        var manager = this.getGlobe().getRendererManager();
        manager.setSelectedRasterBucket(this);
    };

    /**
     * @function setVisible
     * @memberof AbstractLayer#
     * @throws {TypeError} - The parameter of setVisible should be a boolean
     */
    AbstractLayer.prototype.setVisible = function(arg) {
        if (typeof arg === "boolean") {
            if (this.visible !== arg && this.getGlobe().attributionHandler) {
                this.getGlobe().attributionHandler.toggleAttribution(this);
            }
            this.visible = arg;

            if (!this.isBackground() && this.visible) {
                this.setOnTheTop();
            }

            var ctxTime = this.callbackContext.getTime();
            if (ctxTime !== this.time) {
                this.setTime(ctxTime);
            }

            // Manage autoFillTimeTravel
            if (this.autoFillTimeTravel === true) {
                if (this.visible === true) {
                    //add !
                    if (this.callbackContext.timeTravelService) {
                        this.callbackContext.timeTravelService.update(
                            this.timeTravelValues
                        );
                    }
                } else {
                    // Remove
                    if (this.callbackContext.timeTravelService) {
                        this.callbackContext.timeTravelService.update({
                            remove: { ID: this.ID }
                        });
                    }
                }
            }

            this.getGlobe()
                .getRenderContext()
                .requestFrame();
            this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
        } else {
            throw new TypeError(
                "the parameter of visible should be a boolean",
                "AbstractLayer.js"
            );
        }
    };

    /**
     * @function getOpacity
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getOpacity = function() {
        return this.getStyle().getOpacity();
    };

    /**
     * @function setOpacity
     * @memberof AbstractLayer#
     * @throws {RangeError} opacity - opacity value should be a value in [0..1]
     */
    AbstractLayer.prototype.setOpacity = function(arg) {
        var style = this.getStyle();
        style.setOpacity(arg);
        this.getGlobe()
            .getRenderContext()
            .requestFrame();
        this.publish(Constants.EVENT_MSG.LAYER_OPACITY_CHANGED, this);
    };

    /**
     * @function getProperties
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getProperties = function() {
        return this.properties;
    };

    /**
     * @function getType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getType = function() {
        return this.type;
    };

    /**
     * @function isPickable
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isPickable = function() {
        return this.pickable;
    };

    /**
     * @function isType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isType = function(type) {
        return this.type === type;
    };

    /**
     * @function getServices
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getServices = function() {
        return this.services;
    };

    /**
     * @function getCoordinateSystem
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getCoordinateSystem = function() {
        return this.coordinateSystem;
    };

    /**
     * @function isAttached
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isAttached = function() {
        return !this.isDetached;
    };
    
    /**
     * @function isDetached
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isDetached = function() {
        return this.globe == null;
    };

    /**
     * @function _attach
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype._attach = function(g) {
        this.globe = g;
        if (
            this.attribution &&
            this.globe.attributionHandler &&
            this.isVisible()
        ) {
            this.globe.attributionHandler.addAttribution(this);
        }
    };

    /**
     * @function _detach
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype._detach = function() {
        if (this.attribution && this.globe.attributionHandler) {
            this.globe.attributionHandler.removeAttribution(this);
        }
        this.globe = null;
    };

    /**
     * @function getBaseUrl
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getBaseUrl = function() {
        return this.baseUrl;
    };

    /**
     * @function getDataType
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getDataType = function() {
        return this.dataType;
    };

    /**
     * @function getFormat
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getFormat = function() {
        return this.format;
    };

    /**
     * @function isDeletable
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isDeletable = function() {
        return this.deletable;
    };

    /**
     * @function getStyle
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.getStyle = function() {
        return this.style;
    };

    /**
     * Sets the vector layer style.
     * @function setStyle
     * @memberof AbstractLayer#
     * @param {FeatureStyle} arg Feature style
     */
    AbstractLayer.prototype.setStyle = function(arg) {
        this.style = arg;
    };

    /**
     * @function isBackground
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isBackground = function() {
        return this.background;
    };

    /**
     * @function isVectorLayer
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.isVectorLayer = function() {
        return this.vectorLayer;
    };

    /**
     * Decrypt time range to generate time travel informations
     * @function generateTimeTravel
     * @param {String} timeDetails Details of time range
     * @memberof AbstractLayer#
     */
    AbstractLayer.prototype.generateTimeTravel = function(timeDetails) {
        if (timeDetails) {
            // In a general case, timeDetails.value could have this shape:
            //  val1,val2,min1/max1/step1,val3,min2/max2/step2
            var timesDefinition = timeDetails.value.split(",");
            var distinctValues = []; // records the distinct values : val1,val2,val3
            var sampleValues = []; // records the samples values : min1/max1/step1,min2/max2/step2
            var timeDefinition;

            // We need to iter because it is possible that we have a mix of distinct values and sample values
            for (var i = 0; i < timesDefinition.length; i++) {
                timeDefinition = timesDefinition[i].trim();
                if (Time.isDistinctValue(timeDefinition)) {
                    distinctValues.push(timeDefinition);
                } else if (Time.isSampling(timeDefinition)) {
                    sampleValues.push(timeDefinition);
                } else {
                    console.log(
                        "This should be refactored if we handle an interval min/max at the server level"
                    );
                }
            }
            // Add distinct values in time travel
            if (distinctValues.length > 0) {
                this.timeTravelValues = {
                    add: {
                        enumeratedValues: distinctValues,
                        ID: this.ID
                    }
                };
            }

            // Add sample values in time travel
            if (sampleValues.length > 0) {
                var start, end, step, tmpArray, sampleDefinition;
                for (i = 0; i < sampleValues.length; i++) {
                    sampleDefinition = sampleValues[i];
                    tmpArray = sampleDefinition.split("/");
                    start = Moment(tmpArray[0]);
                    end = Moment(tmpArray[1]);
                    step = Time.timeResolution(tmpArray[2]);
                    this.timeTravelValues = {
                        add: {
                            start: start,
                            end: end,
                            stepKind: step.unit,
                            stepValue: step.step,
                            ID: this.ID
                        }
                    };
                }
            }
        }
    };

    return AbstractLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/Program',[],function() {
    /**************************************************************************************************************/

    /**
	 @name Program
	 @class
	   Program constructor
	 @param renderContext
	 @constructor
	 */
    var Program = function(renderContext) {
        this.renderContext = renderContext;
        this.glProgram = null;
        this.attributes = {};
        this.uniforms = {};
        this.numActiveAttribArray = 0;
    };

    /**************************************************************************************************************/

    /**
     * Creates a shader of the given type from the given source string
     * @function createShader
     * @memberof Program.prototype
     * @param type
     * @param source
     * @return Shader
     */
    Program.prototype.createShader = function(type, source) {
        var gl = this.renderContext.gl;
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(
                "Shader compilation error: " + gl.getShaderInfoLog(shader)
            );
            console.error(source);
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    };

    /**************************************************************************************************************/

    /**
     * Create the program from source shaders
     * @function createFromSource
     * @memberof Program.prototype
     * @param vertexSource
     * @param fragmentSource
     * @return {Boolean}
     */
    Program.prototype.createFromSource = function(
        vertexSource,
        fragmentSource
    ) {
        var gl = this.renderContext.gl;

        //  Create the gl shaders from the source
        var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
        var fragmentShader = this.createShader(
            gl.FRAGMENT_SHADER,
            fragmentSource
        );
        if (vertexShader === null || fragmentShader === null) {
            return false;
        }

        var i;

        // Create the program and attach the shaderss
        this.glProgram = gl.createProgram();
        gl.attachShader(this.glProgram, vertexShader);
        gl.attachShader(this.glProgram, fragmentShader);

        // Link and test the program is ok
        gl.linkProgram(this.glProgram);
        if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) {
            console.log(
                "Program link error: " + gl.getProgramInfoLog(this.glProgram)
            );
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            gl.deleteProgram(this.glProgram);
            this.glProgram = null;
            return false;
        }

        // Get vertex attributes used in the program, stored them in an attributes object
        var attributeCount = gl.getProgramParameter(
            this.glProgram,
            gl.ACTIVE_ATTRIBUTES
        );
        this.numActiveAttribArray = 0;
        for (i = 0; i < attributeCount; ++i) {
            var attribute = gl.getActiveAttrib(this.glProgram, i);
            var loc = gl.getAttribLocation(this.glProgram, attribute.name);
            this.attributes[attribute.name] = loc;

            if (loc + 1 > this.numActiveAttribArray) {
                this.numActiveAttribArray = loc + 1;
            }
        }

        // Get uniforms used in the program, stored them in an uniforms object
        var uniformCount = gl.getProgramParameter(
            this.glProgram,
            gl.ACTIVE_UNIFORMS
        );
        for (i = 0; i < uniformCount; ++i) {
            var uniform = gl.getActiveUniform(this.glProgram, i);
            this.uniforms[uniform.name] = gl.getUniformLocation(
                this.glProgram,
                uniform.name
            );
        }

        return true;
    };

    /**************************************************************************************************************/

    /**
     * Load from file (must be located on the server)
     * @function loadFromFile
     * @memberof Program.prototype
     * @param vertexFile
     * @param fragmentFile
     * @return {Boolean}
     */
    Program.prototype.loadFromFile = function(vertexFile, fragmentFile) {
        var xhr = new XMLHttpRequest();
        xhr.open("get", this.renderContext.shadersPath + vertexFile, false);
        xhr.send(null);

        var vertexSource = xhr.responseText;
        xhr.open("get", this.renderContext.shadersPath + fragmentFile, false);
        xhr.send(null);
        var fragmentSource = xhr.responseText;

        return this.createFromSource(vertexSource, fragmentSource);
    };

    /**************************************************************************************************************/

    /**
     * Apply the programs
     * @function apply
     * @memberof Program.prototype
     */
    Program.prototype.apply = function() {
        var rc = this.renderContext;
        var gl = rc.gl;
        var i;

        // Bind program
        gl.useProgram(this.glProgram);

        for (i = rc.numActiveAttribArray; i < this.numActiveAttribArray; i++) {
            gl.enableVertexAttribArray(i);
        }
        for (i = this.numActiveAttribArray; i < rc.numActiveAttribArray; i++) {
            gl.disableVertexAttribArray(i);
        }
        rc.numActiveAttribArray = this.numActiveAttribArray;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the program
     * @function dispose
     * @memberof Program.prototype
     */
    Program.prototype.dispose = function() {
        this.renderContext.gl.deleteProgram(this.glProgram);
    };

    /**************************************************************************************************************/

    return Program;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/BoundingBox',[],function() {
    /**
	 @name BoundingBox
	 @class
	  Bounding Box
	 @param {float[]} min Min corner as 3D point (array of 3 float)
	 @param {float[]} max Max corner as 3D point (array of 3 float)
	 @constructor
	 */
    var BoundingBox = function(min, max) {
        if (min) {
            this.min = vec3.create(min);
        }
        if (max) {
            this.max = vec3.create(max);
        }
    };

    /**
	Extent the bounding box with the given point
	@function extend
	@memberof BoundingBox.prototype
	@param {float} x Coord x of extent point
	@param {float} y Coord y of extent point
	@param {float} z Coord z of extent point
*/
    BoundingBox.prototype.extend = function(x, y, z) {
        if (!this.min) {
            this.min = vec3.create();
            this.max = vec3.create();

            this.min[0] = x;
            this.min[1] = y;
            this.min[2] = z;
            this.max[0] = x;
            this.max[1] = y;
            this.max[2] = z;
        } else {
            if (x < this.min[0]) {
                this.min[0] = x;
            }
            if (y < this.min[1]) {
                this.min[1] = y;
            }
            if (z < this.min[2]) {
                this.min[2] = z;
            }
            if (x > this.max[0]) {
                this.max[0] = x;
            }
            if (y > this.max[1]) {
                this.max[1] = y;
            }
            if (z > this.max[2]) {
                this.max[2] = z;
            }
        }
    };
    /**
 	Compute the bounding box from an array of vertices
 	@function compute
 	@memberof BoundingBox.prototype
 	@param {float[]} vertices All coords as array of multiple of 3 float)
 	@param {float} length Vertices array length
 	@param {float} stride Stride (3 by default)
 */
    BoundingBox.prototype.compute = function(vertices, length, stride) {
        if (!this.min) {
            this.min = vec3.create();
            this.max = vec3.create();
        }

        this.min[0] = vertices[0];
        this.min[1] = vertices[1];
        this.min[2] = vertices[2];
        this.max[0] = vertices[0];
        this.max[1] = vertices[1];
        this.max[2] = vertices[2];

        var i, j;
        var st = stride || 3;
        var ll = length || vertices.length;

        for (i = st; i < ll; i += st) {
            for (j = 0; j < 3; j++) {
                if (vertices[i + j] < this.min[j]) {
                    this.min[j] = vertices[i + j];
                }
                if (vertices[i + j] > this.max[j]) {
                    this.max[j] = vertices[i + j];
                }
            }
        }
    };

    /**
 	Get the corner of a bounding box
 	@function getCorner
 	@memberof BoundingBox.prototype
 	@param {float} pos Position
 	@return {?} Corner
 */
    BoundingBox.prototype.getCorner = function(pos) {
        return [
            pos & 1 ? this.max[0] : this.min[0],
            pos & 2 ? this.max[1] : this.min[1],
            pos & 4 ? this.max[2] : this.min[2]
        ];
    };

    /**
 	Get the center of a bounding box
 	@function getCenter
 	@memberof BoundingBox.prototype
 	@return {?} Center
 */
    BoundingBox.prototype.getCenter = function() {
        return [
            (this.max[0] + this.min[0]) * 0.5,
            (this.max[1] + this.min[1]) * 0.5,
            (this.max[2] + this.min[2]) * 0.5
        ];
    };

    /**
 	Get the radius of a bounding box
 	@function getRadius
 	@memberof BoundingBox.prototype
 	@return {float} Radius
 */
    BoundingBox.prototype.getRadius = function() {
        var vec = vec3.create();
        vec3.subtract(this.max, this.min, vec);
        return 0.5 * vec3.length(vec);
    };

    /**************************************************************************************************************/

    return BoundingBox;
});

// jshint ignore: start

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3

define('Renderer/glMatrix',[], function() {
    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};

    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function(vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function(x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function(vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    vec3.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON)
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function(vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function(vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function(vec, vec2, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            x2 = vec2[0],
            y2 = vec2[1],
            z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function(vec) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function(vec) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function(vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.direction = function (vec, vec2, dest) {
     if (!dest) { dest = vec; }

     var x = vec[0] - vec2[0],
     y = vec[1] - vec2[1],
     z = vec[2] - vec2[2],
     len = Math.sqrt(x * x + y * y + z * z);

     if (!len) {
     dest[0] = 0;
     dest[1] = 0;
     dest[2] = 0;
     return dest;
     }

     len = 1 / len;
     dest[0] = x * len;
     dest[1] = y * len;
     dest[2] = z * len;
     return dest;
     };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function(vec, vec2, lerp, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function(vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];

        return Math.sqrt(x * x + y * y + z * z);
    };

    /** Vector cross product.
     @param v1 vector
     @param v2 another vector
     @return number vector cross product between this vector and {@code v}
     */
    vec3.angle = function(v1, v2) {
        return Math.atan2(vec3.length(vec3.cross(v1, v2)), vec3.dot(v1, v2));
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
     if (!dest) { dest = vec; }

     if(!unprojectMat) {
     unprojectMat = mat4.create();
     }

     var m = unprojectMat;
     var v = unprojectVec;

     v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
     v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
     v[2] = 2.0 * vec[2] - 1.0;
     v[3] = 1.0;

     mat4.multiply(proj, view, m);
     if(!mat4.inverse(m)) { return null; }

     mat4.multiplyVec4(m, v);
     if(v[3] === 0.0) { return null; }

     dest[0] = v[0] / v[3];
     dest[1] = v[1] / v[3];
     dest[2] = v[2] / v[3];

     return dest;
     };*/

    /*    var xUnitVec3 = vec3.createFrom(1,0,0);
     var yUnitVec3 = vec3.createFrom(0,1,0);
     var zUnitVec3 = vec3.createFrom(0,0,1);

     var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
    /*    vec3.rotationTo = function (a, b, dest) {
     if (!dest) { dest = quat4.create(); }

     var d = vec3.dot(a, b);
     var axis = tmpvec3;
     if (d >= 1.0) {
     quat4.set(identityQuat4, dest);
     } else if (d < (0.000001 - 1.0)) {
     vec3.cross(xUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(yUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(zUnitVec3, a, axis);
     vec3.normalize(axis);
     quat4.fromAngleAxis(Math.PI, axis, dest);
     } else {
     var s = Math.sqrt((1.0 + d) * 2.0);
     var sInv = 1.0 / s;
     vec3.cross(a, b, axis);
     dest[0] = axis[0] * sInv;
     dest[1] = axis[1] * sInv;
     dest[2] = axis[2] * sInv;
     dest[3] = s * 0.5;
     quat4.normalize(dest);
     }
     if (dest[3] > 1.0) dest[3] = 1.0;
     else if (dest[3] < -1.0) dest[3] = -1.0;
     return dest;
     };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function(vec) {
        return "[" + vec[0] + ", " + vec[1] + ", " + vec[2] + "]";
    };

    // Vec3 lib used for Astro Math lib

    vec3.createZPhi = function(z, phi) {
        var sth = Math.sqrt((1.0 - z) * (1.0 + z));
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        return vec3.createFrom(x, y, z);
    };

    vec3.createPhiTheta = function(phi, theta) {
        var sth = Math.sin(theta);
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        var z = sth * Math.cos(theta);
        return vec3.createFrom(x, y, z);
    };

    vec3.add2 = function(vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 + x2, y1 + y2, z1 + z2];
    };

    vec3.subtract2 = function(vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 - x2, y1 - y2, z1 - z2];
    };

    vec3.flip = function(vec) {
        var x = vec[0];
        var y = vec[1];
        var z = vec[2];

        return [(x = -x), (y = -y), (z = -z)];
    };

    vec3.scale2 = function(vec, val) {
        var x = vec.x;
        var y = vec.y;
        var z = vec.z;

        return {
            x: x * val,
            y: (y *= val),
            z: (z *= val)
        };
    };

    vec3.normalize2 = function(vec) {
        var x = vec[0];
        var y = vec[1];
        var z = vec[2];
        var d = 1.0 / Math.sqrt(x * x + y * y + z * z);

        return [(x *= d), (y *= d), (z *= d)];
    };

    vec3.cross2 = function(vec, vec2) {
        return {
            x: vec[1] * vec2[2] - vec2[1] * vec[2],
            y: vec[2] * vec2[0] - vec2[2] * vec[0],
            z: vec[0] * vec2[1] - vec2[0] * vec[1]
        };
    };

    vec3.length2 = function(vec) {
        var x = vec.x,
            y = vec.y,
            z = vec.z;
        return Math.sqrt(x * x + y * y + z * z);
    };

    vec3.dot2 = function(vec, vec2) {
        var x1 = vec.x !== undefined ? vec.x : vec[0];
        var y1 = vec.y !== undefined ? vec.y : vec[1];
        var z1 = vec.z !== undefined ? vec.z : vec[2];
        var x2 = vec2.x !== undefined ? vec2.x : vec2[0];
        var y2 = vec2.y !== undefined ? vec2.y : vec2[1];
        var z2 = vec2.z !== undefined ? vec2.z : vec2[2];

        return x1 * x2 + y1 * y2 + z1 * z2;
    };

    vec3.angle2 = function(v1, v2) {
        return Math.atan2(vec3.length2(vec3.cross2(v1, v2)), vec3.dot2(v1, v2));
    };
    //

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new isntance of mat3
     *
     * @param {mat3} [mat] mat3 containing values to initialize with
     *
     * @returns {mat3} a new 3x3 matrix
     */
    mat3.create = function(mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        }

        return dest;
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function(mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
    /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
     var dest = new MatrixArray(16);

     dest[0] = m00;
     dest[1] = m01;
     dest[2] = m02;
     dest[3] = m03;
     dest[4] = m10;
     dest[5] = m11;
     dest[6] = m12;
     dest[7] = m13;
     dest[8] = m20;
     dest[9] = m21;
     dest[10] = m22;
     dest[11] = m23;
     dest[12] = m30;
     dest[13] = m31;
     dest[14] = m32;
     dest[15] = m33;

     return dest;
     };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function(mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    mat4.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
                Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
                Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
                Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
                Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
                Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
                Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
                Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
                Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
                Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
                Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
                Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
                Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
                Math.abs(a[15] - b[15]) < FLOAT_EPSILON)
        );
    };

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function(dest) {
        if (!dest) {
            dest = mat4.create();
        }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function(mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1],
                a02 = mat[2],
                a03 = mat[3],
                a12 = mat[6],
                a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function(mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11],
            a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15];

        return (
            a30 * a21 * a12 * a03 -
            a20 * a31 * a12 * a03 -
            a30 * a11 * a22 * a03 +
            a10 * a31 * a22 * a03 +
            a20 * a11 * a32 * a03 -
            a10 * a21 * a32 * a03 -
            a30 * a21 * a02 * a13 +
            a20 * a31 * a02 * a13 +
            a30 * a01 * a22 * a13 -
            a00 * a31 * a22 * a13 -
            a20 * a01 * a32 * a13 +
            a00 * a21 * a32 * a13 +
            a30 * a11 * a02 * a23 -
            a10 * a31 * a02 * a23 -
            a30 * a01 * a12 * a23 +
            a00 * a31 * a12 * a23 +
            a10 * a01 * a32 * a23 -
            a00 * a11 * a32 * a23 -
            a20 * a11 * a02 * a33 +
            a10 * a21 * a02 * a33 +
            a20 * a01 * a12 * a33 -
            a00 * a21 * a12 * a33 -
            a10 * a01 * a22 * a33 +
            a00 * a11 * a22 * a33
        );
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function(mat, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11],
            a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15],
            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,
            d =
                b00 * b11 -
                b01 * b10 +
                b02 * b09 +
                b03 * b08 -
                b04 * b07 +
                b05 * b06,
            invDet;

        // Calculate the determinant
        if (!d) {
            return null;
        }
        invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function(mat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function(mat, dest) {
        if (!dest) {
            dest = mat3.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
    /*   mat4.toInverseMat3 = function (mat, dest) {
     // Cache the matrix values (makes for huge speed increases!)
     var a00 = mat[0], a01 = mat[1], a02 = mat[2],
     a10 = mat[4], a11 = mat[5], a12 = mat[6],
     a20 = mat[8], a21 = mat[9], a22 = mat[10],

     b01 = a22 * a11 - a12 * a21,
     b11 = -a22 * a10 + a12 * a20,
     b21 = a21 * a10 - a11 * a20,

     d = a00 * b01 + a01 * b11 + a02 * b21,
     id;

     if (!d) { return null; }
     id = 1 / d;

     if (!dest) { dest = mat3.create(); }

     dest[0] = b01 * id;
     dest[1] = (-a22 * a01 + a02 * a21) * id;
     dest[2] = (a12 * a01 - a02 * a11) * id;
     dest[3] = b11 * id;
     dest[4] = (a22 * a00 - a02 * a20) * id;
     dest[5] = (-a12 * a00 + a02 * a10) * id;
     dest[6] = b21 * id;
     dest[7] = (-a21 * a00 + a01 * a20) * id;
     dest[8] = (a11 * a00 - a01 * a10) * id;

     return dest;
     };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function(mat, mat2, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3];
        var a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];
        var a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];
        var a30 = mat[12],
            a31 = mat[13],
            a32 = mat[14],
            a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0 = mat2[0],
            b1 = mat2[1],
            b2 = mat2[2],
            b3 = mat2[3];
        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

    /**
     Project a vec3
     */
    mat4.project = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }
        mat4.multiplyVec4(mat, vec, dest);
        var iw = 1.0 / dest[3];
        dest[0] *= iw;
        dest[1] *= iw;
        dest[2] *= iw;
        return dest;
    };

    /**
     * mat4.rotateVec3
     * Rotate a vec3 with the given matrix
     *
     * Params:
     * mat - mat4 to transform the vector with
     * vec - vec3 to transform
     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
     *
     * Returns:
     * dest if specified, vec otherwise
     */
    mat4.rotateVec3 = function(mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z;

        return dest;
    };

    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function(mat, vec, dest) {
        var x = vec[0],
            y = vec[1],
            z = vec[2],
            a00,
            a01,
            a02,
            a03,
            a10,
            a11,
            a12,
            a13,
            a20,
            a21,
            a22,
            a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        dest[0] = a00;
        dest[1] = a01;
        dest[2] = a02;
        dest[3] = a03;
        dest[4] = a10;
        dest[5] = a11;
        dest[6] = a12;
        dest[7] = a13;
        dest[8] = a20;
        dest[9] = a21;
        dest[10] = a22;
        dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function(mat, vec, dest) {
        var x = vec[0],
            y = vec[1],
            z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function(mat, angle, axis, dest) {
        var x = axis[0],
            y = axis[1],
            z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s,
            c,
            t,
            a00,
            a01,
            a02,
            a03,
            a10,
            a11,
            a12,
            a13,
            a20,
            a21,
            a22,
            a23,
            b00,
            b01,
            b02,
            b10,
            b11,
            b12,
            b20,
            b21,
            b22;

        if (!len) {
            return null;
        }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function(mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) {
            // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = right - left,
            tb = top - bottom,
            fn = far - near;
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function(fovy, aspect, near, far, dest) {
        var top = near * Math.tan((fovy * Math.PI) / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function(left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = right - left,
            tb = top - bottom,
            fn = far - near;
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function(eye, center, up, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x0,
            x1,
            x2,
            y0,
            y1,
            y2,
            z0,
            z1,
            z2,
            len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    /*    mat4.fromRotationTranslation = function (quat, vec, dest) {
     if (!dest) { dest = mat4.create(); }

     // Quaternion math
     var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
     x2 = x + x,
     y2 = y + y,
     z2 = z + z,

     xx = x * x2,
     xy = x * y2,
     xz = x * z2,
     yy = y * y2,
     yz = y * z2,
     zz = z * z2,
     wx = w * x2,
     wy = w * y2,
     wz = w * z2;

     dest[0] = 1 - (yy + zz);
     dest[1] = xy + wz;
     dest[2] = xz - wy;
     dest[3] = 0;
     dest[4] = xy - wz;
     dest[5] = 1 - (xx + zz);
     dest[6] = yz + wx;
     dest[7] = 0;
     dest[8] = xz + wy;
     dest[9] = yz - wx;
     dest[10] = 1 - (xx + yy);
     dest[11] = 0;
     dest[12] = vec[0];
     dest[13] = vec[1];
     dest[14] = vec[2];
     dest[15] = 1;

     return dest;
     };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function(mat) {
        return (
            "[" +
            mat[0] +
            ", " +
            mat[1] +
            ", " +
            mat[2] +
            ", " +
            mat[3] +
            ", " +
            mat[4] +
            ", " +
            mat[5] +
            ", " +
            mat[6] +
            ", " +
            mat[7] +
            ", " +
            mat[8] +
            ", " +
            mat[9] +
            ", " +
            mat[10] +
            ", " +
            mat[11] +
            ", " +
            mat[12] +
            ", " +
            mat[13] +
            ", " +
            mat[14] +
            ", " +
            mat[15] +
            "]"
        );
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function(quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function(x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function(quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} true if a is equivalent to b
     */
    quat4.equal = function(a, b) {
        return (
            a === b ||
            (Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
                Math.abs(a[3] - b[3]) < FLOAT_EPSILON)
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function(dest) {
        if (!dest) {
            dest = quat4.create();
        }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function(quat, dest) {
        var x = quat[0],
            y = quat[1],
            z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2) {
        return (
            quat[0] * quat2[0] +
            quat[1] * quat2[1] +
            quat[2] * quat2[2] +
            quat[3] * quat2[3]
        );
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0],
            q1 = quat[1],
            q2 = quat[2],
            q3 = quat[3],
            dot = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3,
            invDot = dot ? 1.0 / dot : 0;

        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

        if (!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0] * invDot;
        dest[1] = -quat[1] * invDot;
        dest[2] = -quat[2] * invDot;
        dest[3] = quat[3] * invDot;
        return dest;
    };

    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function(quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function(quat) {
        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function(quat, dest) {
        if (!dest) {
            dest = quat;
        }

        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function(quat, quat2, dest) {
        if (!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0] + quat2[0];
        dest[1] = quat[1] + quat2[1];
        dest[2] = quat[2] + quat2[2];
        dest[3] = quat[3] + quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function(quat, quat2, dest) {
        if (!dest) {
            dest = quat;
        }

        var qax = quat[0],
            qay = quat[1],
            qaz = quat[2],
            qaw = quat[3],
            qbx = quat2[0],
            qby = quat2[1],
            qbz = quat2[2],
            qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function(quat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0],
            y = vec[1],
            z = vec[2],
            qx = quat[0],
            qy = quat[1],
            qz = quat[2],
            qw = quat[3],
            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function(quat, val, dest) {
        if (!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0] * val;
        dest[1] = quat[1] * val;
        dest[2] = quat[2] * val;
        dest[3] = quat[3] * val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function(quat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x = quat[0],
            y = quat[1],
            z = quat[2],
            w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,
            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function(quat, quat2, slerp, dest) {
        if (!dest) {
            dest = quat;
        }

        var cosHalfTheta =
                quat[0] * quat2[0] +
                quat[1] * quat2[1] +
                quat[2] * quat2[2] +
                quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = quat[0] * 0.5 + quat2[0] * 0.5;
            dest[1] = quat[1] * 0.5 + quat2[1] * 0.5;
            dest[2] = quat[2] * 0.5 + quat2[2] * 0.5;
            dest[3] = quat[3] * 0.5 + quat2[3] * 0.5;
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = quat[0] * ratioA + quat2[0] * ratioB;
        dest[1] = quat[1] * ratioA + quat2[1] * ratioB;
        dest[2] = quat[2] * ratioA + quat2[2] * ratioB;
        dest[3] = quat[3] * ratioA + quat2[3] * ratioB;

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();

        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if (fTrace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0); // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot; // 1/(4w)
            dest[0] = (mat[7] - mat[5]) * fRoot;
            dest[1] = (mat[2] - mat[6]) * fRoot;
            dest[2] = (mat[3] - mat[1]) * fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = (quat4.fromRotationMatrix.s_iNext = quat4
                .fromRotationMatrix.s_iNext || [1, 2, 0]);
            var i = 0;
            if (mat[4] > mat[0]) i = 1;
            if (mat[8] > mat[i * 3 + i]) i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];

            fRoot = Math.sqrt(
                mat[i * 3 + i] - mat[j * 3 + j] - mat[k * 3 + k] + 1.0
            );
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k * 3 + j] - mat[j * 3 + k]) * fRoot;
            dest[j] = (mat[j * 3 + i] + mat[i * 3 + j]) * fRoot;
            dest[k] = (mat[k * 3 + i] + mat[i * 3 + k]) * fRoot;
        }

        return dest;
    };

    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();

        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];

        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0] * src[0] + src[1] * src[1] + src[2] * src[2];
        if (sqrlen > 0) {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0] * invlen;
            dest[1] = src[1] * invlen;
            dest[2] = src[2] * invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }

        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function(quat) {
        return (
            "[" +
            quat[0] +
            ", " +
            quat[1] +
            ", " +
            quat[2] +
            ", " +
            quat[3] +
            "]"
        );
    };

    /*
     * Exports
     */

    window.vec3 = vec3;
    window.mat4 = mat4;
    window.quat4 = quat4;

    return mat4;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/Ray',["./glMatrix"], function() {
    /**************************************************************************************************************/

    /**
	 @name Ray
	 @class
	   Ray constructor
	 @param origin
	 @param dir
	 @constructor
	 */
    var Ray = function(orig, dir) {
        this.orig = orig;
        this.dir = dir;
    };

    /**************************************************************************************************************/

    /**
     * Create a ray from a pixel
     * @function createFromPixel
     * @memberof Ray
     * @param renderContext
     * @param x
     * @param y
     * @return {Ray} Ray
     */
    Ray.createFromPixel = function(renderContext, x, y) {
        // reverse y because (0,0) is top left but opengl's normalized
        // device coordinate (-1,-1) is bottom left
        var nx = (x / renderContext.canvas.width) * 2.0 - 1.0;
        var ny = -((y / renderContext.canvas.height) * 2.0 - 1.0);

        var inverseViewProjectionMatrix = mat4.create();
        mat4.inverse(
            renderContext.viewProjectionMatrix,
            inverseViewProjectionMatrix
        );
        // Transform pos to world using inverse viewProjection matrix
        var pos3D = mat4.multiplyVec4(inverseViewProjectionMatrix, [
            nx,
            ny,
            -1,
            1
        ]);

        pos3D[0] /= pos3D[3];
        pos3D[1] /= pos3D[3];
        pos3D[2] /= pos3D[3];

        // console.log('Old EP ' + renderContext.eyePosition );
        var inverseViewMatrix = mat4.create();
        mat4.inverse(renderContext.viewMatrix, inverseViewMatrix);
        vec3.set([0.0, 0.0, 0.0], renderContext.eyePosition);
        mat4.multiplyVec3(inverseViewMatrix, renderContext.eyePosition);
        // console.log('New EP ' + renderContext.eyePosition );

        var orig = vec3.create(renderContext.eyePosition);
        var dir = vec3.subtract(
            pos3D,
            renderContext.eyePosition,
            vec3.create()
        );
        vec3.normalize(dir);

        return new Ray(orig, dir);
    };

    /**************************************************************************************************************/

    /**
     * Create a ray from an event
     * @function createFromEvent
     * @memberof Ray
     * @param renderContext
     * @param event
     * @return {Ray} Ray
     */
    Ray.createFromEvent = function(renderContext, event) {
        var pos = renderContext.getXYRelativeToCanvas(event);
        return Ray.createFromPixel(pos[0], pos[1]);
    };

    /**************************************************************************************************************/

    /**
     * Intersection object returned
     * @function Intersection
     * @memberof Ray
     * @param t
     */
    Ray.Intersection = function(t) {
        this.t = t;
        this.geometry = null;
    };

    /**************************************************************************************************************/

    /**
     * Compute a point on the ray given its t parameter
     * @function computePoint
     * @memberof Ray.prototype
     * @param t
     * @return Point
     */
    Ray.prototype.computePoint = function(t) {
        var pt = vec3.create();
        vec3.scale(this.dir, t, pt);
        vec3.add(pt, this.orig);
        return pt;
    };

    /**************************************************************************************************************/

    /**
     *	Compute intersection between a plan and ray
     * @function planeIntersect
     * @memberof Ray.prototype
     * @param {vec3} pt
     * @param {vec3} normal
     * @return {number}The nearest intersection, < 0 if no intersection
     */
    Ray.prototype.planeIntersect = function(pt, normal) {
        // Assuming vectors are all normalized
        var denom = vec3.dot(normal, this.dir);
        var epsilon = 1e-6;
        if (Math.abs(denom) > epsilon) {
            var p0l0 = vec3.create();
            vec3.subtract(pt, this.orig, p0l0);
            var t = vec3.dot(p0l0, normal) / denom;
            return t;
        }
        return -1;
    };

    /**************************************************************************************************************/

    /**
     * Compute intersection between a sphere and ray
     * @function sphereIntersect
     * @memberof Ray.prototype
     * @param center
     * @param radius
     * @return the nearest intersection, < 0 if no intersection
     */
    Ray.prototype.sphereIntersect = function(center, radius) {
        // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

        var rs = vec3.subtract(this.orig, center, vec3.create());
        // rayDirection is normalized so a = 1
        // var a = vec3.dot(rayDirection, rayDirection);
        var b = 2.0 * vec3.dot(this.dir, rs);
        var c = vec3.dot(rs, rs) - radius * radius;

        // as a == 1, discriminant = b^2 - (4*c)
        // var discr = (b*b) - (4*a*c);
        var discr = b * b - 4 * c;
        if (discr < 0) {
            return -1;
        }

        // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
        discr = Math.sqrt(discr);
        var tNear = (-b - discr) / 2;
        var tFar = (-b + discr) / 2;
        if (tNear > tFar) {
            // Swap t values
            var tmp = tNear;
            tNear = tFar;
            tFar = tmp;
        }

        if (tFar < 0) {
            // Hit is beyond ray origin
            return -1;
        }

        return tNear < 0 ? tFar : tNear;
    };

    /**************************************************************************************************************/

    var EPS = 1e-15;
    /**
  * Ray triangle intersection optimized
  * @function triangleIntersectOptimized
  * @memberof Ray.prototype
  * @param verts
  * @param i0
  * @param i1
  * @param i2
  * @return the nearest intersection, null if no intersection

  */
    Ray.prototype.triangleIntersectOptimized = function(verts, i0, i1, i2) {
        var e1x = verts[i1] - verts[i0];
        var e1y = verts[i1 + 1] - verts[i0 + 1];
        var e1z = verts[i1 + 2] - verts[i0 + 2];

        var e2x = verts[i2] - verts[i0];
        var e2y = verts[i2 + 1] - verts[i0 + 1];
        var e2z = verts[i2 + 2] - verts[i0 + 2];

        var px = this.dir[1] * e2z - this.dir[2] * e2y;
        var py = this.dir[2] * e2x - this.dir[0] * e2z;
        var pz = this.dir[0] * e2y - this.dir[1] * e2x;

        var det = e1x * px + e1y * py + e1z * pz;

        if (det > -EPS && det < EPS) {
            return null;
        }

        var inv_det = 1.0 / det;

        var tx = this.orig[0] - verts[i0];
        var ty = this.orig[1] - verts[i0 + 1];
        var tz = this.orig[2] - verts[i0 + 2];

        var u = (tx * px + ty * py + tz * pz) * inv_det;
        if (u < 0.0 || u > 1.0) {
            return null;
        }

        var qx = ty * e1z - tz * e1y;
        var qy = tz * e1x - tx * e1z;
        var qz = tx * e1y - ty * e1x;

        var v =
            (this.dir[0] * qx + this.dir[1] * qy + this.dir[2] * qz) * inv_det;
        if (v < 0.0 || u + v > 1.0) {
            return null;
        }

        var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;
        if (t >= 0) {
            return new Ray.Intersection(t);
        } else {
            return null;
        }
    };

    /**************************************************************************************************************/

    /**
     * @function nodeIntersect
     * @memberof Ray.prototype
     * @param node
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.nodeIntersect = function(node, intersects) {
        var i;
        intersects = intersects || [];

        for (i = 0; i < node.children.length; i++) {
            node.children[i].intersectWith(this, intersects);
        }

        for (i = 0; i < node.geometries.length; i++) {
            this.geometryIntersect(node.geometries[i], intersects);
        }

        intersects.sort(function(a, b) {
            return a.t - b.t;
        });
        return intersects;
    };

    /**
     * @function lodNodeIntersect
     * @memberof Ray.prototype
     * @param node
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.lodNodeIntersect = function(node, intersects) {
        var i;
        intersects = intersects || [];

        if (this.sphereIntersect(node.center, node.radius) >= 0) {
            if (node.children.length > 0 && node.childToLoad === 0) {
                for (i = 0; i < node.children.length; i++) {
                    this.lodNodeIntersect(node.children[i], intersects);
                }
            } else {
                for (i = 0; i < node.geometries.length; i++) {
                    this.geometryIntersect(node.geometries[i], intersects);
                }
            }
        }

        return intersects;
    };

    /**
     * @function geometryIntersect
     * @memberof Ray.prototype
     * @param geometry
     * @param intersects
     * @return Intersects
     */
    Ray.prototype.geometryIntersect = function(geometry, intersects) {
        var indices = geometry.mesh.indices;
        for (var i = 0; i < indices.length; i += 3) {
            var intersect = this.triangleIntersectOptimized(
                geometry.mesh.vertices,
                geometry.mesh.numElements * indices[i],
                geometry.mesh.numElements * indices[i + 1],
                geometry.mesh.numElements * indices[i + 2]
            );

            if (intersect) {
                intersect.geometry = geometry;
                intersects.push(intersect);
            }
        }
    };

    return Ray;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Tile',[
    "../Renderer/BoundingBox",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(BoundingBox, Ray) {
    /**************************************************************************************************************/

    /**
         Tile constructor
         @name Tile
         @constructor
         */
    var Tile = function() {
        // Parent/child relationship
        this.parent = null;
        this.parentIndex = -1;
        this.children = null;

        // Graphics data to render the tile
        this.vertices = null;
        this.texture = null;
        this.vertexBuffer = null;
        this.texTransform = [1.0, 1.0, 0.0, 0.0];

        // Tile spatial data
        this.matrix = null;
        this.inverseMatrix = null;
        this.bbox = new BoundingBox();

        // For culling
        this.radius = 0.0;
        this.distance = 0.0;
        this.closestPointToEye = [0.0, 0.0, 0.0];

        // Specific object to store extension from renderers
        this.extension = {};

        // For debug
        //this.color = [ Math.random(), Math.random(), Math.random() ];

        this.state = Tile.State.NONE;

        // Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
        this.config = null;
    };

    /**************************************************************************************************************/

    /**
     *    Tile state enumerations
     */
    Tile.State = {
        ERROR: -10,
        NONE: 0,
        REQUESTED: 1,
        LOADING: 2,
        LOADED: 3
    };

    /**************************************************************************************************************/

    /**
     * Compute position on the tile using normalized coordinate between [0,size-1]
     */
    Tile.prototype.computePosition = function(u, v) {
        var size = this.config.tesselation;
        u = Math.min(size - 1, Math.max(0, u));
        v = Math.min(size - 1, Math.max(0, v));

        var vFloor = Math.floor(v);
        var vFrac = v - vFloor;
        var uFloor = Math.floor(u);
        var uFrac = u - uFloor;
        var vertexSize = this.config.vertexSize;
        var vertexOffset = vertexSize * (vFloor * size + uFloor);
        var vec = [0.0, 0.0, 0.0];
        for (var i = 0; i < 3; i++) {
            vec[i] =
                (1.0 - vFrac) *
                    (1.0 - uFrac) *
                    this.vertices[vertexOffset + i] +
                vFrac *
                    (1.0 - uFrac) *
                    this.vertices[vertexOffset + vertexSize * size + i] +
                vFrac *
                    uFrac *
                    this.vertices[
                        vertexOffset + vertexSize * size + vertexSize + i
                    ] +
                (1.0 - vFrac) *
                    uFrac *
                    this.vertices[vertexOffset + vertexSize + i];
        }
        return vec;
    };

    /**************************************************************************************************************/

    /**
     *    Initialize the tile from its parent
     */
    Tile.prototype.initFromParent = function(parent, i, j) {
        this.parent = parent;
        this.parentIndex = j * 2 + i;
        this.matrix = parent.matrix;
        this.inverseMatrix = parent.inverseMatrix;
        this.texture = parent.texture;
        this.config = parent.config;

        this.vertexBuffer = parent.vertexBuffer;

        // Recompute the bounding box
        // Very fast and coarse version but it does not work with HEALPix tiling
        //var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
        //var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
        //var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
        //var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];

        var size = this.config.tesselation;
        var halfTesselation = (size - 1) / 2;
        for (var n = 0; n <= halfTesselation; n++) {
            var offset =
                this.config.vertexSize *
                ((n + j * halfTesselation) * size + i * halfTesselation);
            for (var k = 0; k <= halfTesselation; k++) {
                this.bbox.extend(
                    parent.vertices[offset],
                    parent.vertices[offset + 1],
                    parent.vertices[offset + 2]
                );
                offset += this.config.vertexSize;
            }
        }

        // Compute the bounding box
        this.radius = this.bbox.getRadius();

        // Init extension
        for (var x in parent.extension) {
            if (parent.extension.hasOwnProperty(x)) {
                var e = parent.extension[x];
                if (e.initChild) {
                    e.initChild(this, i, j);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Test if the tile needs to be refined
     */
    Tile.prototype.needsToBeRefined = function(renderContext) {
        if (this.distance < this.radius) {
            return true;
        }
        // Approximate the radius of one texel : the radius of the tile divided by the image size
        // The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
        // and the radius (ie maximum width/length) is too pessimistic
        var radius =
            (0.25 *
                (this.bbox.max[0] -
                    this.bbox.min[0] +
                    (this.bbox.max[1] - this.bbox.min[1]))) /
            this.imageSize;
        // Transform the closest point from the eye in world coordinates
        var mat = this.matrix;
        var c = this.closestPointToEye;
        var px = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
        var py = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
        var pz = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

        // Compute the pixel size of the radius texel
        var pixelSizeVector = renderContext.pixelSizeVector;
        var pixelSize =
            radius /
            (px * pixelSizeVector[0] +
                py * pixelSizeVector[1] +
                pz * pixelSizeVector[2] +
                pixelSizeVector[3]);
        // Check if pixel radius of a texel is superior to the treshold
        // The pixel size can be negative when the closest point is close to the near plane, so take absolute value
        return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
    };

    /**************************************************************************************************************/

    /**
     *    Test if the tile is culled given the current view parameters
     */
    Tile.prototype.isCulled = function(renderContext) {
        // Compute the eye in tile local space
        var mat = this.inverseMatrix;
        var c = renderContext.eyePosition;
        if (!mat) {
            return false;
        }
        var ex = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
        var ey = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
        var ez = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

        // If the eye is in the radius of the tile, consider the tile is not culled
        this.distance = Math.sqrt(ex * ex + ey * ey + ez * ez);
        if (this.distance < this.radius) {
            this.distance = 0.0;
            return false;
        } else {
            var pt = this.closestPointToEye;

            // Compute closest point to eye with the bbox of the tile
            pt[0] = Math.min(Math.max(ex, this.bbox.min[0]), this.bbox.max[0]);
            pt[1] = Math.min(Math.max(ey, this.bbox.min[1]), this.bbox.max[1]);
            pt[2] = Math.min(Math.max(ez, this.bbox.min[2]), this.bbox.max[2]);

            // Compute horizontal culling only if the eye is "behind" the tile
            // and the coordinate system is not a plane(no need to compute horizon culling on plane)
            if (ez < 0.0 && !this.config.coordinateSystem.isFlat()) {
                const eyeGeoAltitude = this.config.coordinateSystem.from3DToGeo(
                    c
                )[2];
                if (eyeGeoAltitude > 0) {
                    // Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
                    var vx = pt[0];
                    var vy = pt[1];
                    var vz = pt[2] + this.config.coordinateSystem.geoide.radius;
                    var vl = Math.sqrt(vx * vx + vy * vy + vz * vz);
                    vx /= vl;
                    vy /= vl;
                    vz /= vl;

                    // Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
                    // The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
                    var edx =
                        ex - vx * this.config.coordinateSystem.geoide.radius;
                    var edy =
                        ey - vy * this.config.coordinateSystem.geoide.radius;
                    var edz =
                        ez -
                        (vz - 1.0) * this.config.coordinateSystem.geoide.radius;

                    // Compute dot product between eye direction and the vertical at the point
                    var el = Math.sqrt(edx * edx + edy * edy + edz * edz);
                    var eDv = (edx * vx + edy * vy + edz * vz) / el;

                    eDv *= this.config.cullSign;

                    if (eDv < -0.05) {
                        return true;
                    }
                }
            }

            // Compute local frustum
            var localFrustum = renderContext.localFrustum;
            localFrustum.inverseTransform(
                renderContext.worldFrustum,
                this.matrix
            );

            // Check if the tile is inside the frustum
            return !localFrustum.containsBoundingBox(this.bbox);
        }
    };

    /**************************************************************************************************************/

    /**
     *    Dispose the tile
     */
    Tile.prototype.dispose = function(renderContext, tilePool) {
        // Dispose extension even if tile isn't loaded because it can be culled
        for (var x in this.extension) {
            if (this.extension[x].dispose) {
                this.extension[x].dispose(renderContext, tilePool);
            }
        }

        if (this.state === Tile.State.LOADED) {
            tilePool.disposeGLBuffer(this.vertexBuffer);
            if (this.texture) {
                tilePool.disposeGLTexture(this.texture);
            }

            this.vertexBuffer = null;
            this.texture = null;
            this.parent = null;

            this.state = Tile.State.NONE;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Delete the children
     */
    Tile.prototype.deleteChildren = function(renderContext, tilePool) {
        if (this.children) {
            for (var i = 0; i < 4; i++) {
                // Recursively delete its children
                this.children[i].deleteChildren(renderContext, tilePool);
                // Dispose its ressources (WebGL)
                this.children[i].dispose(renderContext, tilePool);
            }

            // Cleanup the tile
            this.children = null;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Build skirt vertices
     */
    Tile.prototype.buildSkirtVertices = function(
        center,
        srcOffset,
        srcStep,
        dstOffset
    ) {
        var vertices = this.vertices;
        var skirtHeight = this.radius * 0.05;

        var size = this.config.tesselation;
        for (var i = 0; i < size; i++) {
            /*		//Not optimized version of skirt computation
                 var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
                 var dir = vec3.subtract( srcPos, center, vec3.create() );
                 vec3.normalize(dir);
                 vec3.scale( dir, skirtHeight );
                 vec3.subtract( srcPos, dir );*/

            // Optimized version of skirt computation
            var x = vertices[srcOffset] - center[0];
            var y = vertices[srcOffset + 1] - center[1];
            var z = vertices[srcOffset + 2] - center[2];
            var scale = skirtHeight / Math.sqrt(x * x + y * y + z * z);
            x *= scale;
            y *= scale;
            z *= scale;

            vertices[dstOffset] = vertices[srcOffset] - x;
            vertices[dstOffset + 1] = vertices[srcOffset + 1] - y;
            vertices[dstOffset + 2] = vertices[srcOffset + 2] - z;

            for (var n = 3; n < this.config.vertexSize; n++) {
                vertices[dstOffset + n] = vertices[srcOffset + n];
            }

            dstOffset += this.config.vertexSize;
            srcOffset += srcStep;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Generate normals for a tile
     */
    Tile.prototype.generateNormals = function() {
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        var lineSize = vertexSize * size;

        var vo = 0;
        for (var j = 0; j < size; j++) {
            var vp1 = j === size - 1 ? 0 : lineSize;
            var vm1 = j === 0 ? 0 : -lineSize;
            for (var i = 0; i < size; i++) {
                var up1 = i === size - 1 ? 0 : vertexSize;
                var um1 = i === 0 ? 0 : -vertexSize;
                var u = [
                    this.vertices[vo + up1] - this.vertices[vo + um1],
                    this.vertices[vo + up1 + 1] - this.vertices[vo + um1 + 1],
                    this.vertices[vo + up1 + 2] - this.vertices[vo + um1 + 2]
                ];
                var v = [
                    this.vertices[vo + vp1] - this.vertices[vo + vm1],
                    this.vertices[vo + vp1 + 1] - this.vertices[vo + vm1 + 1],
                    this.vertices[vo + vp1 + 2] - this.vertices[vo + vm1 + 2]
                ];

                var normal = vec3.cross(u, v, []);
                vec3.normalize(normal);
                this.vertices[vo + 3] = normal[0];
                this.vertices[vo + 4] = normal[1];
                this.vertices[vo + 5] = normal[2];

                vo += vertexSize;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Generate the tile
     */
    Tile.prototype.generate = function(tilePool, image, elevations) {
        // Generate the vertices
        this.vertices = this.generateVertices(elevations);

        // Compute the bounding box
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        this.bbox.compute(this.vertices, vertexSize * size * size, vertexSize);
        this.radius = this.bbox.getRadius();

        // Compute normals if needed
        if (this.config.normals) {
            this.generateNormals();
        }
        // Compute skirt from vertices
        if (this.config.skirt) {
            // Compute local earth center, used to generate skirts
            var localEarthCenter = [0.0, 0.0, 0.0];
            mat4.multiplyVec3(this.inverseMatrix, localEarthCenter);

            // Skirts
            var dstOffset = vertexSize * (size * size); // TOP
            this.buildSkirtVertices(localEarthCenter, 0, vertexSize, dstOffset);
            dstOffset += vertexSize * size; // BOTTOM
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * (size * (size - 1)),
                vertexSize,
                dstOffset
            );
            dstOffset += vertexSize * size; // LEFT
            this.buildSkirtVertices(
                localEarthCenter,
                0,
                vertexSize * size,
                dstOffset
            );
            dstOffset += vertexSize * size; // RIGHT
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * (size - 1),
                vertexSize * size,
                dstOffset
            );

            // These skirts are only used by children tile
            dstOffset += vertexSize * size; // CENTER
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * ((size * (size - 1)) / 2),
                vertexSize,
                dstOffset
            );
            dstOffset += vertexSize * size; // MIDDLE
            this.buildSkirtVertices(
                localEarthCenter,
                vertexSize * ((size - 1) / 2),
                vertexSize * size,
                dstOffset
            );
        }

        // Avoid double creation of vertex buffer for level0Tiles generation
        if (this.vertexBuffer !== null && this.parent === null) {
            tilePool.disposeGLBuffer(this.vertexBuffer);
        }
        this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

        // Create texture
        if (image) {
            this.texture = tilePool.createGLTexture(image);
            this.imageSize = this.config.imageSize;
        }

        this.state = Tile.State.LOADED;
    };

    /**************************************************************************************************************/

    Tile.prototype.intersect = function(ray, indices, rc) {
        if (this.isCulled(rc)) {
            return -1;
        }

        // We intersect, check the children recursively for a finer result
        var minChildrenIntersection;

        if (this.children) {
            for (var i = 0; i < this.children.length; ++i) {
                const child = this.children[i];
                if (child.vertices) {
                    const intersection = child.intersect(ray, indices, rc);
                    if (
                        intersection >= 0 &&
                        (!minChildrenIntersection ||
                            intersection < minChildrenIntersection)
                    ) {
                        minChildrenIntersection = intersection;
                    }
                }
            }
        }

        // Children will be more fine-grained
        var final_t;
        if (minChildrenIntersection && minChildrenIntersection >= 0) {
            final_t = minChildrenIntersection;
        } else if (this.vertices == null) {
            console.warn("vertices is null");
        } else {
            var intersection = null;

            for (var j = 0; indices && j < indices.length / 3; ++j) {
                const i0 = indices[j * 3 + 0] * 3;
                const i1 = indices[j * 3 + 1] * 3;
                const i2 = indices[j * 3 + 2] * 3;

                var v0 = [
                    this.vertices[i0 + 0],
                    this.vertices[i0 + 1],
                    this.vertices[i0 + 2]
                ];
                var v1 = [
                    this.vertices[i1 + 0],
                    this.vertices[i1 + 1],
                    this.vertices[i1 + 2]
                ];
                var v2 = [
                    this.vertices[i2 + 0],
                    this.vertices[i2 + 1],
                    this.vertices[i2 + 2]
                ];

                v0 = mat4.multiplyVec3(this.matrix, v0);
                v1 = mat4.multiplyVec3(this.matrix, v1);
                v2 = mat4.multiplyVec3(this.matrix, v2);

                var verts = [
                    v0[0],
                    v0[1],
                    v0[2],
                    v1[0],
                    v1[1],
                    v1[2],
                    v2[0],
                    v2[1],
                    v2[2]
                ];

                const tmp_i = ray.triangleIntersectOptimized(verts, 0, 3, 6);
                if (tmp_i) {
                    if (!intersection || tmp_i.t < intersection.t) {
                        intersection = tmp_i;
                    }
                }
            }

            if (intersection) {
                final_t = intersection.t;
            }
        }

        if (!final_t) {
            return -1;
        }

        const result = final_t;
        return result;
    };

    return Tile;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/ImageRequest',[], function() {
    /**
     *    @constructor
     *    ImageRequest constructor
     */
    var ImageRequest = function(options) {
        this.successCallback = options.successCallback;
        this.failCallback = options.failCallback;
        this.abortCallback = options.abortCallback;
        this.image = null;
    };

    /**************************************************************************************************************/

    /**
     *    Send image request
     */
    ImageRequest.prototype.send = function(url, crossOrigin) {
        this.image = new Image();
        this.image.crossOrigin = crossOrigin;
        this.image.dataType = "byte";

        var self = this;
        this.image.onload = function() {
            var isComplete =
                self.image.naturalWidth !== 0 && self.image.complete;
            if (isComplete) {
                self.successCallback(self);
            }
        };
        this.image.onerror = this.failCallback.bind(this);
        this.image.src = url;
    };

    /**************************************************************************************************************/

    /**
     *    Abort image request
     */
    ImageRequest.prototype.abort = function() {
        if (this.abortCallback) {
            this.abortCallback(this);
        }
        this.image.src = "";
    };

    /**************************************************************************************************************/

    return ImageRequest;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/RendererTileData',[],function() {
    /**************************************************************************************************************/
    /**
  @name RendererTileData
  @class
	  RendererTileData constructor
    Contains a list of renderables for the tiles
  @param manager
  @constructor
  */
    var RendererTileData = function(manager) {
        this.manager = manager;
        this.renderables = [];
    };

    /**************************************************************************************************************/

    /**
     * Initialize a child tile
     * @function initChild
     * @memberof RendererTileData.prototype
     * @param childTile
     * @param i
     * @param j
     */
    RendererTileData.prototype.initChild = function(childTile, i, j) {
        var childData;
        for (var n = 0; n < this.renderables.length; n++) {
            if (this.renderables[n].initChild) {
                var r = this.renderables[n].initChild(i, j, childTile);
                if (r) {
                    if (!childData) {
                        childData = childTile.extension.renderer = new RendererTileData(
                            this.manager
                        );
                    }
                    childData.renderables.push(r);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Traverse the renderer data
     * @function traverse
     * @memberof RendererTileData.prototype
     * @param {Tile} tile Tile
     * @param isLeaf
     */
    RendererTileData.prototype.traverse = function(tile, isLeaf) {
        for (var i = 0; i < this.renderables.length; i++) {
            var renderable = this.renderables[i];
            var bucket = renderable.bucket;
            if (bucket.layer.isVisible() && bucket.layer.getOpacity() > 0) {
                if (renderable.traverse) {
                    renderable.traverse(this.manager, tile, isLeaf);
                } else {
                    if (renderable.hasChildren && !isLeaf) {
                        continue;
                    }

                    this.manager.renderables.push(renderable);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get a renderable from the tile, given the bucket
     * @function getRenderable
     * @memberof RendererTileData.prototype
     * @param {Bucket} bucket Bucket
     * @return Renderable
     */
    RendererTileData.prototype.getRenderable = function(bucket) {
        for (var i = 0; i < this.renderables.length; i++) {
            if (bucket === this.renderables[i].bucket) {
                return this.renderables[i];
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    /**
     * Dispose renderable data from tile
     * @function dispose
     * @memberof RendererTileData.prototype
     * @param renderContext
     * @param tilePool
     */
    RendererTileData.prototype.dispose = function(renderContext, tilePool) {
        for (var i = 0; i < this.renderables.length; i++) {
            this.renderables[i].dispose(renderContext, tilePool);
        }
        this.renderables.length = 0;
    };

    /**************************************************************************************************************/

    return RendererTileData;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/RasterOverlayRenderer',[
    "./Program",
    "../Tiling/Tile",
    "../Utils/ImageRequest",
    "./RendererTileData",
    "../Utils/Constants"
], function(Program, Tile, ImageRequest, RendererTileData, Constants) {
    /**************************************************************************************************************/

    /**
         @name RasterOverlayRenderer
         @class
             RasterOverlayRenderer constructor
         @param {AbstractGlobe} globe AbstractGLobe
         @constructor
         */

    var RasterOverlayRenderer = function(globe) {
        this.vertexShader = "attribute vec3 vertex;\n";
        this.vertexShader += "attribute vec2 tcoord;\n";
        this.vertexShader += "uniform mat4 modelViewMatrix;\n";
        this.vertexShader += "uniform mat4 projectionMatrix;\n";
        this.vertexShader += "uniform vec4 textureTransform; \n";
        this.vertexShader += "varying vec2 texCoord;\n";
        this.vertexShader += "void main(void) \n";
        this.vertexShader += "{\n";
        this.vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
        this.vertexShader +=
            "	texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n";
        this.vertexShader += "}\n";

        this.fragmentShader = "precision lowp float;\n";
        this.fragmentShader += "varying vec2 texCoord;\n";
        this.fragmentShader += "uniform sampler2D overlayTexture;\n";
        this.fragmentShader += "uniform float opacity; \n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader +=
            "	gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n";
        this.fragmentShader += "	gl_FragColor.a *= opacity; \n";
        this.fragmentShader += "}\n";

        this.rendererManager = globe.getRendererManager();
        this.tileManager = globe.tileManager;

        this.programs = [];
        this.program = this.createProgram({
            vertexCode: this.vertexShader,
            fragmentCode: this.fragmentShader,
            updateUniforms: null
        });

        this.buckets = [];
        this.imageRequests = [];
        this.frameNumber = 0;

        var self = this;
        for (var i = 0; i < 4; i++) {
            var imageRequest = new ImageRequest({
                successCallback: function() {
                    if (this.renderable) {
                        if (this.renderable.bucket.layer.handleImage) {
                            this.renderable.bucket.layer.handleImage(this);
                        }

                        this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(
                            this.image
                        );
                        this.renderable.texture = this.renderable.ownTexture;
                        this.renderable.uvScale = 1.0;
                        this.renderable.uTrans = 0.0;
                        this.renderable.vTrans = 0.0;
                        this.renderable.updateChildrenTexture();
                        this.renderable.onRequestFinished(true);
                        this.renderable = null;
                        self.tileManager.renderContext.requestFrame();
                    }
                },
                failCallback: function() {
                    if (this.renderable) {
                        this.renderable.onRequestFinished(true);
                        this.renderable = null;
                    }
                },
                abortCallback: function() {
                    //console.log("Raster overlay request abort.");
                    if (this.renderable) {
                        this.renderable.onRequestFinished(false);
                        this.renderable = null;
                    }
                }
            });

            this.imageRequests.push(imageRequest);
        }
    };

    /**************************************************************************************************************/

    /**
         @name RasterOverlayRenderable
         @class
             Create a renderable for the overlay.
         There is one renderable per overlay and per tile.
         @param {Bucket} bucket Bucket
         @constructor
         */
    var RasterOverlayRenderable = function(bucket) {
        this.bucket = bucket;
        this.ownTexture = null;
        this.texture = null;
        this.request = null;
        this.requestFinished = false;
        this.tile = null;
        this.uvScale = 1.0;
        this.uTrans = 0.0;
        this.vTrans = 0.0;
    };

    /**************************************************************************************************************/

    /**
     * Called when a request is started
     * @function onRequestStarted
     * @memberof RasterOverlayRenderable.prototype
     * @param {String}request Request
     * @fires Layer#startLoad
     */
    RasterOverlayRenderable.prototype.onRequestStarted = function(request) {
        this.request = request;
        this.requestFinished = false;
        var layer = this.bucket.layer;
        if (layer._numRequests === 0) {
            layer.globe.publishEvent(
                Constants.EVENT_MSG.LAYER_START_LOAD,
                layer
            );
        }
        layer._numRequests++;
    };

    /**************************************************************************************************************/

    /**
     * Called when a request is finished
     * @function onRequestFinished
     * @memberof RasterOverlayRenderable.prototype
     * @param completed
     * @fires Layer#endLoad
     */
    RasterOverlayRenderable.prototype.onRequestFinished = function(completed) {
        this.request = null;
        this.requestFinished = completed;
        var layer = this.bucket.layer;
        layer._numRequests--;
        if (layer.getGlobe() && layer._numRequests === 0) {
            layer
                .getGlobe()
                .publishEvent(Constants.EVENT_MSG.LAYER_END_LOAD, layer);
        }
    };

    /**************************************************************************************************************/

    /**
     * Initialize a child renderable
     * @function initChild
     * @memberof RasterOverlayRenderable.prototype
     * @param i
     * @param j
     * @param childTile
     */
    RasterOverlayRenderable.prototype.initChild = function(i, j, childTile) {
        // Request finished and no texture  : no init needed for children
        /*	// TODO : does not work because sometimes level 0 cannot be loaded
             if (this.requestFinished && !this.ownTexture)
             return null;*/

        var renderable = this.bucket.createRenderable();
        renderable.tile = childTile;
        if (this.texture) {
            renderable.texture = this.texture;
            renderable.uvScale = this.uvScale;
            renderable.uTrans = this.uTrans;
            renderable.vTrans = this.vTrans;
        }

        return renderable;
    };

    /**************************************************************************************************************/

    /**
     * Generate child renderable
     * @function generateChild
     * @memberof RasterOverlayRenderable.prototype
     * @param {Tile} tile Tile
     */
    RasterOverlayRenderable.prototype.generateChild = function(tile) {
        // Request finished and no texture  : no generate needed for children
        /*	// TODO : does not work because sometimes level 0 cannot be loaded
             if (this.requestFinished && !this.ownTexture)
             return;*/

        var r = this.bucket.renderer;
        r.addOverlayToTile(tile, this.bucket, this);
    };

    /**************************************************************************************************************/

    /**
     * Update the children texture
     * @function updateChildrenTexture
     * @memberof RasterOverlayRenderable.prototype
     */
    RasterOverlayRenderable.prototype.updateChildrenTexture = function() {
        if (this.tile.children) {
            for (var i = 0; i < 4; i++) {
                var rd = this.tile.children[i].extension.renderer;
                if (rd) {
                    var cr = rd.getRenderable(this.bucket);
                    if (cr && !cr.ownTexture) {
                        cr.updateTextureFromParent(this);
                        cr.updateChildrenTexture();
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Update texture from its parent
     * @function updateTextureFromParent
     * @memberof RasterOverlayRenderable.prototype
     * @param parent
     */
    RasterOverlayRenderable.prototype.updateTextureFromParent = function(
        parent
    ) {
        if (this.tile.state === Tile.State.LOADED) {
            this.texture = parent.texture;
            this.uvScale = parent.uvScale * 0.5;
            this.uTrans = parent.uTrans;
            this.vTrans = parent.vTrans;

            this.uTrans += this.tile.parentIndex & 1 ? this.uvScale : 0;
            this.vTrans += this.tile.parentIndex & 2 ? this.uvScale : 0;
        } else {
            this.texture = parent.texture;
            this.uvScale = parent.uvScale;
            this.uTrans = parent.uTrans;
            this.vTrans = parent.vTrans;
        }
    };

    /**************************************************************************************************************/

    /**
         * Traverse renderable : add it to renderables list if there is a texture
         Request the texture
         * @function traverse
         * @memberof RasterOverlayRenderable.prototype
         * @param manager
         * @param {Tile} tile Tile
         * @param {Boolean} isLeaf
         */
    RasterOverlayRenderable.prototype.traverse = function(
        manager,
        tile,
        isLeaf
    ) {
        if (isLeaf && this.texture) {
            manager.renderables.push(this);
        }

        if (!this.requestFinished && this.tile.state === Tile.State.LOADED) {
            this.bucket.renderer.requestOverlayTextureForTile(this);
        }
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof RasterOverlayRenderable.prototype
     * @param renderContext
     * @param tilePool
     */
    RasterOverlayRenderable.prototype.dispose = function(
        renderContext,
        tilePool
    ) {
        if (this.ownTexture) {
            tilePool.disposeGLTexture(this.ownTexture);
            this.ownTexture = null;
        }
    };

    /**************************************************************************************************************/

    /**
         @name Bucket
         @class
             Bucket constructor for RasterOverlay
         @param layer
         @constructor
         */
    var Bucket = function(layer) {
        this.layer = layer;
        this.renderer = null;
        this.style = layer.style;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {RasterOverlayRenderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new RasterOverlayRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Add an overlay into the renderer.
     * The overlay is added to all loaded tiles.
     * @function addOverlay
     * @memberof RasterOverlayRenderer.prototype
     * @param overlay
     */
    RasterOverlayRenderer.prototype.addOverlay = function(overlay) {
        // Initialize num requests to 0
        overlay._numRequests = 0;

        var bucket = new Bucket(overlay);
        bucket.renderer = this;
        bucket.id = this.rendererManager.bucketId++;
        this.buckets.push(bucket);

        overlay._bucket = bucket;

        for (var i = 0; i < this.tileManager.level0Tiles.length; i++) {
            var tile = this.tileManager.level0Tiles[i];
            if (tile.state === Tile.State.LOADED) {
                this.addOverlayToTile(tile, bucket);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove an overlay
     * The overlay is removed from all loaded tiles.
     * @function removeOverlay
     * @memberof RasterOverlayRenderer.prototype
     * @param overlay
     */
    RasterOverlayRenderer.prototype.removeOverlay = function(overlay) {
        var index = this.buckets.indexOf(overlay._bucket);
        this.buckets.splice(index, 1);

        var rc = this.tileManager.renderContext;
        var tp = this.tileManager.tilePool;
        this.tileManager.visitTiles(function(tile) {
            var rs = tile.extension.renderer;
            var renderable = rs ? rs.getRenderable(overlay._bucket) : null;
            if (renderable) {
                // Remove the renderable
                var index = rs.renderables.indexOf(renderable);
                rs.renderables.splice(index, 1);

                // Dispose its data
                renderable.dispose(rc, tp);

                // Remove tile data if not needed anymore
                if (rs.renderables.length === 0) {
                    delete tile.extension.renderer;
                }
            }
        });
    };

    /**************************************************************************************************************/

    /**
     * Add an overlay into a tile.
     * Create tile data if needed, and create the renderable for the overlay.
     * @function addOverlayToTile
     * @memberof RasterOverlayRenderer.prototype
     * @param tile
     * @param bucket
     * @param parentRenderable
     */
    RasterOverlayRenderer.prototype.addOverlayToTile = function(
        tile,
        bucket,
        parentRenderable
    ) {
        if (!this.overlayIntersects(tile.geoBound, bucket.layer)) {
            return;
        }

        if (!tile.extension.renderer) {
            tile.extension.renderer = new RendererTileData(
                this.rendererManager
            );
        }

        var renderable = bucket.createRenderable();
        renderable.tile = tile;
        tile.extension.renderer.renderables.push(renderable);

        if (parentRenderable && parentRenderable.texture) {
            renderable.updateTextureFromParent(parentRenderable);
        }

        if (tile.children) {
            // Add the overlay to loaded children
            for (var i = 0; i < 4; i++) {
                if (tile.children[i].state === Tile.State.LOADED) {
                    this.addOverlayToTile(tile.children[i], bucket, renderable);
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Create an interpolated for polygon clipping
     */
    var _createInterpolatedVertex = function(t, p1, p2) {
        return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
    };

    /**************************************************************************************************************/

    /**
     * Clip polygon to a side (used by bound-overlay intersection)
     * @function clipPolygonToSide
     * @memberof RasterOverlayRenderer.prototype
     * @param coord
     * @param sign
     * @param value
     * @param polygon
     */
    RasterOverlayRenderer.prototype.clipPolygonToSide = function(
        coord,
        sign,
        value,
        polygon
    ) {
        var clippedPolygon = [];
        var t, newPoint;
        // iterate through vertices
        for (var i = 0; i < polygon.length; i++) {
            var p1 = polygon[i];
            var p2 = polygon[(i + 1) % polygon.length];
            var val1 = p1[coord];
            var val2 = p2[coord];

            // test containement
            var firstInside = (val1 - value) * sign >= 0.0;
            var secondInside = (val2 - value) * sign >= 0.0;

            // output vertices for inside polygon
            if (!firstInside && secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
                clippedPolygon.push(p2);
            } else if (firstInside && secondInside) {
                clippedPolygon.push(p2);
            } else if (firstInside && !secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
            }
        }

        return clippedPolygon;
    };

    /**************************************************************************************************************/

    /**
     * Check the intersection between a geo bound and an overlay
     * @function overlayIntersects
     * @memberof RasterOverlayRenderer.prototype
     * @param bound
     * @param overlay
     * @return {Boolean} Is intersects ?
     */
    RasterOverlayRenderer.prototype.overlayIntersects = function(
        bound,
        overlay
    ) {
        if (overlay.coordinates) {
            var c;
            c = this.clipPolygonToSide(0, 1, bound.west, overlay.coordinates);
            c = this.clipPolygonToSide(0, -1, bound.east, c);
            c = this.clipPolygonToSide(1, 1, bound.south, c);
            c = this.clipPolygonToSide(1, -1, bound.north, c);
            return c.length > 0;
        } else if (overlay.geoBound) {
            return overlay.geoBound.intersects(bound);
        }

        // No geobound or coordinates : always return true
        return true;
    };

    /**************************************************************************************************************/

    /**
     * Generate Raster overlay data on the tile.
     * The method is called by TileManager when a new tile has been generated.
     * @function generateLevelZero
     * @memberof RasterOverlayRenderer.prototype
     * @param {Tile} tile Tile
     */
    RasterOverlayRenderer.prototype.generateLevelZero = function(tile) {
        // Traverse all overlays
        for (var i = 0; i < this.buckets.length; i++) {
            this.addOverlayToTile(tile, this.buckets[i]);
        }
    };

    /**************************************************************************************************************/

    /**
     * Request the overlay texture for a tile
     * @function requestOverlayTextureForTile
     * @memberof RasterOverlayRenderer.prototype
     * @param renderable
     */
    RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function(
        renderable
    ) {
        if (!renderable.request) {
            var imageRequest;
            for (var i = 0; i < this.imageRequests.length; i++) {
                if (!this.imageRequests[i].renderable) {
                    imageRequest = this.imageRequests[i];
                    break;
                }
            }

            if (imageRequest) {
                var url = renderable.bucket.layer.getUrl(renderable.tile);
                if (url !== null) {
                    renderable.onRequestStarted(imageRequest);
                    imageRequest.renderable = renderable;
                    imageRequest.frameNumber = this.frameNumber;
                    imageRequest.send(
                        renderable.bucket.layer.getUrl(renderable.tile),
                        renderable.bucket.layer.crossOrigin
                    );
                }
            }
        } else {
            renderable.request.frameNumber = this.frameNumber;
        }
    };

    /**************************************************************************************************************/

    /**
     * Create program from customShader object
     * @function createProgram
     * @memberof RasterOverlayRenderer.prototype
     * @param customShader
     * @return {Program} Program
     */
    RasterOverlayRenderer.prototype.createProgram = function(customShader) {
        var program = new Program(this.tileManager.renderContext);
        program.createFromSource(this.vertexShader, customShader.fragmentCode);

        // Add program
        program.id = this.programs.length;
        this.programs.push({
            fragmentCode: customShader.fragmentCode,
            program: program
        });
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Get program if known by renderer, create otherwise
     * @function getProgram
     * @memberof RasterOverlayRenderer.prototype
     * @param customShader
     * @return {Program} Program
     */
    RasterOverlayRenderer.prototype.getProgram = function(customShader) {
        var program;

        for (var id = 0; id < this.programs.length; id++) {
            if (this.programs[id].fragmentCode === customShader.fragmentCode) {
                program = this.programs[id].program;
            }
        }

        if (!program) {
            program = this.createProgram(customShader);
        }
        return program;
    };

    /**************************************************************************************************************/

    /**
     *    Render the raster overlays for the given tiles
     * @function render
     * @memberof RasterOverlayRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    RasterOverlayRenderer.prototype.render = function(renderables, start, end) {
        var rc = this.tileManager.renderContext;
        var gl = rc.gl;

        // Update gl states
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);

        var modelViewMatrix = mat4.create();

        var currentTile = null;
        var currentIB = null;
        var currentProgram = null;

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var bucket = renderable.bucket;
            var layer = bucket.layer;

            var updateUniforms;
            var program;
            if (layer.customShader) {
                program = this.getProgram(layer.customShader);
                updateUniforms = layer.customShader.updateUniforms;
            } else {
                program = this.getProgram({
                    vertexCode: this.vertexShader,
                    fragmentCode: this.fragmentShader,
                    updateUniforms: null
                });
            }

            // Apply program if changed
            if (program !== currentProgram) {
                currentProgram = program;
                program.apply();

                gl.uniformMatrix4fv(
                    program.uniforms.projectionMatrix,
                    false,
                    rc.projectionMatrix
                );
                gl.uniform1i(program.uniforms.overlayTexture, 0);

                // Bind tcoord buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
                gl.vertexAttribPointer(
                    program.attributes.tcoord,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
            }

            if (updateUniforms) {
                updateUniforms(gl, program);
            }

            // Bind the vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
            gl.vertexAttribPointer(
                program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                4 * renderable.tile.config.vertexSize,
                0
            );

            // Bind the index buffer only if different (index buffer is shared between tiles)
            var indexBuffer =
                renderable.tile.state === Tile.State.LOADED
                    ? this.tileManager.tileIndexBuffer.getSolid()
                    : this.tileManager.tileIndexBuffer.getSubSolid(
                          renderable.tile.parentIndex
                      );
            if (currentIB !== indexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                currentIB = indexBuffer;
            }

            // Bind the tile tile matrix
            mat4.multiply(
                rc.viewMatrix,
                renderable.tile.matrix,
                modelViewMatrix
            );
            gl.uniformMatrix4fv(
                program.uniforms.modelViewMatrix,
                false,
                modelViewMatrix
            );

            gl.uniform1f(program.uniforms.opacity, layer.getOpacity());
            gl.uniform4f(
                program.uniforms.textureTransform,
                renderable.uvScale,
                renderable.uvScale,
                renderable.uTrans,
                renderable.vTrans
            );

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, renderable.texture);

            // Finally draw the tiles
            gl.drawElements(
                gl.TRIANGLES,
                currentIB.numIndices,
                gl.UNSIGNED_SHORT,
                0
            );
        }

        // reset gl states
        gl.disable(gl.BLEND);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof RasterOverlayRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    RasterOverlayRenderer.prototype.canApply = function(type, style) {
        return false;
    };

    /**************************************************************************************************************/

    return RasterOverlayRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Cache',[],function() {
    /**
     *    Cache storing <AbstractRasterLayer> tile requests in browser's local storage
     *    Due to performance reasons, it's recommended to use it only for tiles of level 0
     *    @param options
     *        <ul>
     *            <li>layer: Layer which will contain the given cache(required)</li>
     *            <li>cacheLevel: the maximum level of tiles to be cached</li>
     *        </ul>
     */
    var Cache = function(options) {
        this.layer = options.layer;

        this.cacheLevel = options.hasOwnProperty("cacheLevel")
            ? options.cacheLevel
            : 1;

        if (!localStorage.getItem(this.layer.getName())) {
            // Create cache space in local storage named after layer
            localStorage.setItem(this.layer.getName(), JSON.stringify({}));
        }

        this._cacheMap = JSON.parse(localStorage.getItem(this.layer.getName()));

        this.imgCanvas = document.createElement("canvas");
        // Make sure canvas is as big as layer requests
        this.imgCanvas.width = options.tilePixelSize || 256;
        this.imgCanvas.height = options.tilePixelSize || 256;

        this.imgContext = this.imgCanvas.getContext("2d");
    };

    /**************************************************************************************************************/

    /**
     *    Get tile request from cache for the given tile
     *    @returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
     */
    Cache.prototype.getFromCache = function(tile) {
        var cachedTileRequest = null;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            var tileInfo = this._cacheMap[tileId];
            if (tileInfo) {
                // Update access info
                tileInfo.lastAccess = Date.now();

                var image = new Image();
                image.src = tileInfo.dataUrl;
                image.dataType = "byte";
                cachedTileRequest = {
                    image: image,
                    elevations: tileInfo.elevations
                };
            }
        }
        return cachedTileRequest;
    };

    /**************************************************************************************************************/

    /**
     *    Internal method to generate data url from HTML image object
     */
    Cache.prototype._createDataURL = function(image) {
        // Draw image into canvas element
        this.imgContext.drawImage(image, 0, 0, image.width, image.height);

        // Save image as a data URL
        return this.imgCanvas.toDataURL("image/png");
    };

    /**************************************************************************************************************/

    /**
     *    Store tile request in cache
     */
    Cache.prototype.storeInCache = function(tileRequest) {
        var tile = tileRequest.tile;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            this._cacheMap[tileId] = {
                dataUrl: this._createDataURL(tileRequest.image),
                elevations: tileRequest.elevations,
                lastAccess: Date.now()
            };

            // Update local storage with new cache
            localStorage.setItem(
                this.layer.getName(),
                JSON.stringify(this._cacheMap)
            );
        }
    };

    return Cache;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/AbstractRasterLayer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractLayer",
    "../Renderer/RasterOverlayRenderer",
    "../Utils/Cache"
], function(Utils, Constants, AbstractLayer, RasterOverlayRenderer, Cache) {
    /**
     * AbstractRasterLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractRasterLayer.configuration
     * @property {int} tilePixelSize - the image size of a tile in pixels
     * @property tiling - Tiling
     * @property {int} numberOfLevels - number of levels in the pyramidal tiles
     * @property [geoBound=null] - geography boundary
     * @property [coordinates=null]
     * @property {int} [zIndex=0]
     * @property {string} [crossOrigin="anonymous"]
     * @property {string} baseUrl
     * @property cache
     */

    /**
     * @name AbstractRasterLayer
     * @class
     *     Base class for raster layer
     * @augments AbstractLayer
     * @param {LAYER} type - the type of the layer
     * @param {AbstractRasterLayer.configuration} options -Configuration properties for the AbstractRasterLayer.
     * @constructor
     * @implements {RasterLayer}
     */
    var AbstractRasterLayer = function(type, options) {
        options.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_RASTER;
        AbstractLayer.prototype.constructor.call(this, type, options);

        // Base properties
        this.tilePixelSize = options.tilePixelSize;
        this.tiling = options.tiling;
        this.numberOfLevels = options.numberOfLevels || 21;
        this.minLevel = options.minLevel;
        this.maxLevel = options.maxLevel;
        this.geoBound = options.geoBound || null;
        this.coordinates = options.coordinates || null;
        this.crossOrigin = options.crossOrigin || "anonymous";

        // Init cache if defined
        if (options.cache) {
            options.cache.layer = this;
            this.cache = new Cache(options.cache);
        }

        // Internal
        this._ready = true; // Ready is use by TileManager
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AbstractRasterLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof AbstractRasterLayer#
     */
    AbstractRasterLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.RASTER;
    }


    /**
     * Returns the URL to query the raster.
     * @param {Tile} tile for which the URL is created
     * @returns {string} the URL
     * @memberof AbstractRasterLayer#     
     */
    AbstractRasterLayer.prototype.getUrl = function(tile) {
        throw new SyntaxError(
            "getUrl() not implemented",
            "AbstractRasterLayer.js"
        );
    };

    /**
     * Returns the proxified Url when the tile level is between [minLevel, maxLevel]
     * @param url url
     * @returns {Boolean} the proxified Url when the tile level is between [minLevel, maxLevel]
     * @memberof AbstractRasterLayer#     
     */
    AbstractRasterLayer.prototype.proxify = function(url, level) {
        var proxifyUrl;
        if (this.isBetweenMinMaxLevel(level)) {
            proxifyUrl = AbstractLayer.prototype.proxify.call(this, url);
        } else {
            proxifyUrl = null;
        }
        return proxifyUrl;
    };

    /**
     * Returns true when the tile is defined between [minLevel,maxLevel] otherwise false.
     * @param level level of the tile
     * @returns {Boolean} true when the tile level is defined between [minLevel,maxLevel] otherwise false.
     * @memberof AbstractRasterLayer#     
     */
    AbstractRasterLayer.prototype.isBetweenMinMaxLevel = function(level) {
        var isInside;
        if (this.minLevel != null && this.maxLevel != null) {
            isInside = this.minLevel <= level && level <= this.maxLevel;
        } else if (this.minLevel != null) {
            isInside = level >= this.minLevel;
        } else if (this.maxLevel != null) {
            isInside = level <= this.maxLevel;
        } else {
            isInside = true;
        }

        return isInside;
    };

    /**
     * Attach the raster layer to the planet
     * @function _attach
     * @memberof AbstractRasterLayer#
     * @param {Globe} g - globe
     * @private
     */
    AbstractRasterLayer.prototype._attach = function(g) {
        if (this.isBackground()) {
            // Override id of background layer because of unicity of background not overlayed layer
            //TODO : check if it is still needed
            this.id = 0;
        }

        AbstractLayer.prototype._attach.call(this, g);
        if (!this.isBackground()) {
            // Create the renderer if needed
            if (!g.rasterOverlayRenderer) {
                var renderer = new RasterOverlayRenderer(g);
                g.getRendererManager().renderers.push(renderer);
                g.rasterOverlayRenderer = renderer;
            }
            g.rasterOverlayRenderer.addOverlay(this);
        }
    };

    /**************************************************************************************************************/

    /**
     * Detach the raster layer from the planet
     * @function _detach
     * @memberof AbstractRasterLayer#
     * @private
     */
    AbstractRasterLayer.prototype._detach = function() {
        // Remove raster from overlay renderer if needed
        if (!this.isBackground() && this.getGlobe().rasterOverlayRenderer) {
            this.getGlobe().rasterOverlayRenderer.removeOverlay(this);
        }

        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    return AbstractRasterLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/GeoBound',["../Utils/Constants"], function(Constants) {
    /**************************************************************************************************************/

    /**
     @name GeoBound
     @class
         Geo Bound
     @param {float} w West
     @param {float} s South
     @param {float} e East
     @param {float} n North
     @constructor
     */
    var GeoBound = function(w, s, e, n) {
        this.south = s;
        this.west = w;
        this.north = n;
        this.east = e;
    };

    /**
     Get geo center
     @function getCenter
     @memberof GeoBound.prototype
     @return {float[]} Geo center as array of 2 float
     */
    GeoBound.prototype.getCenter = function() {
        return [
            (this.east + this.west) * 0.5,
            (this.south + this.north) * 0.5,
            0.0
        ];
    };

    /**
     Get North
     @function getNorth
     @memberof GeoBound.prototype
     @return {float} North
     */
    GeoBound.prototype.getNorth = function() {
        return this.north;
    };

    /**
     Set North
     @function setNorth
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setNorth = function(val) {
        this.north = val;
    };

    /**
     Get South
     @function getSouth
     @memberof GeoBound.prototype
     @return {float} South
     */
    GeoBound.prototype.getSouth = function() {
        return this.south;
    };

    /**
     Set South
     @function setSouth
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setSouth = function(val) {
        this.south = val;
    };

    /**
     Get West
     @function getWest
     @memberof GeoBound.prototype
     @return {float} West
     */
    GeoBound.prototype.getWest = function() {
        return this.west;
    };

    /**
     Set West
     @function setWest
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setWest = function(val) {
        this.west = val;
    };

    /**
     Get East
     @function getEast
     @memberof GeoBound.prototype
     @return {float} East
     */
    GeoBound.prototype.getEast = function() {
        return this.east;
    };

    /**
     Set East
     @function setEast
     @memberof GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setEast = function(val) {
        this.east = val;
    };

    /**
     Compute the geo bound from coordinates
     @function computeFromCoordinates
     @memberof GeoBound.prototype
     @param {float[][]} coordinates Coordinates as bi-dimensionnal array of float
     */
    GeoBound.prototype.computeFromCoordinates = function(coordinates) {
        this.west = coordinates[0][0];
        this.east = coordinates[0][0];
        this.south = coordinates[0][1];
        this.north = coordinates[0][1];

        for (var i = 1; i < coordinates.length; i++) {
            this.west = Math.min(this.west, coordinates[i][0]);
            this.east = Math.max(this.east, coordinates[i][0]);
            this.south = Math.min(this.south, coordinates[i][1]);
            this.north = Math.max(this.north, coordinates[i][1]);
        }
    };

    function transformCoordinates(coordinates, crsID, globeCrs) {
        var len = coordinates.length,
            convertedCoord = new Array(len); // boost in Safari
        for (var i = 0; i < len; ++i) {
            convertedCoord[i] = coordinates[i].slice(0);
        }

        convertedCoord[0][0] = globeCrs.convert(
            coordinates[0][0],
            crsID,
            globeCrs.getGeoideName()
        );
        convertedCoord[0][1] = globeCrs.convert(
            coordinates[0][1],
            crsID,
            globeCrs.getGeoideName()
        );
        for (var j = 1; j < coordinates.length; j++) {
            convertedCoord[j][0] = globeCrs.convert(
                coordinates[j][0],
                crsID,
                globeCrs.getGeoideName()
            );
            convertedCoord[j][1] = globeCrs.convert(
                coordinates[j][1],
                crsID,
                globeCrs.getGeoideName()
            );
        }
        return convertedCoord;
    }

    GeoBound.prototype.computeFromCoordinatesInCrsTo = function(
        coordinates,
        crsID,
        globeCrs
    ) {
        var coords;
        if (crsID === globeCrs.getGeoideName()) {
            coords = coordinates;
        } else {
            coords = transformCoordinates(coordinates, crsID, globeCrs);
        }
        this.computeFromCoordinates(coords);
        return coords;
    };

    /**
     Check if a point is inside the given bound
     @function isPointInside
     @memberof GeoBound.prototype
     @param {Array} point The point
     @return {Boolean} return the test
     */
    GeoBound.prototype.isPointInside = function(point) {
        return (
            point[0] >= this.west &&
            point[0] <= this.east &&
            point[1] >= this.south &&
            point[1] <= this.north
        );
    };

    /**
     Intersects this geo bound with another one
     @function intersects
     @memberof GeoBound.prototype
     @param {GeoBound} geoBound Geo bound
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersects = function(geoBound) {
        if (this.west >= geoBound.east || this.east <= geoBound.west) {
            return false;
        }

        return !(this.south >= geoBound.north || this.north <= geoBound.south);
    };

    /**
     Intersects this geo bound with GeoJSON geometry
     @function intersectsGeometry
     @memberof GeoBound.prototype
     @param {JSON} geometry GeoJSON geometry
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersectsGeometry = function(geometry) {
        var isIntersected = false;
        var i, j;
        var geoBound = new GeoBound();
        var coords = geometry.coordinates;
        switch (geometry.type) {
            case Constants.GEOMETRY.LineString:
                geoBound.computeFromCoordinates(coords);
                isIntersected |= this.intersects(geoBound);
                break;
            case Constants.GEOMETRY.Polygon:
                // Don't take care about holes
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    geoBound.computeFromCoordinates(coords[i]);
                    isIntersected |= this.intersects(geoBound);
                }
                break;
            case Constants.GEOMETRY.MultiLineString:
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    geoBound.computeFromCoordinates(coords[i]);
                    isIntersected |= this.intersects(geoBound);
                }
                break;
            case Constants.GEOMETRY.MultiPolygon:
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    for (j = 0; j < coords[i].length && !isIntersected; j++) {
                        geoBound.computeFromCoordinates(coords[i][j]);
                        isIntersected |= this.intersects(geoBound);
                    }
                }
                break;
        }
        return isIntersected;
    };

    /**************************************************************************************************************/

    return GeoBound;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/GeoTiling',[
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/UtilsIntersection",
    "./Tile",
    "../Renderer/GeoBound",
    "./HEALPixBase",
    "../Renderer/glMatrix"
], function(Utils, Constants, UtilsIntersection, Tile, GeoBound, HEALPixBase) {
    /** @constructor
         Tile constructor
         */
    var GeoTile = function(geoBound, level, x, y) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);
        this.bound = this.geoBound = geoBound;
        this.level = level;
        this.x = x;
        this.y = y;
    };

    /**************************************************************************************************************/

    /** inherits from Tile */
    GeoTile.prototype = new Tile();

    /**************************************************************************************************************/

    /** @export
         Get elevation at a geo position
         */
    GeoTile.prototype.getElevation = function(lon, lat) {
        // Get the lon/lat in coordinates between [0,1] in the tile
        var u =
            (lon - this.geoBound.getWest()) /
            (this.geoBound.getEast() - this.geoBound.getWest());
        var v =
            (lat - this.geoBound.getNorth()) /
            (this.geoBound.getSouth() - this.geoBound.getNorth());

        // Quick fix when lat is on the border of the tile
        var childIndex =
            (v >= 1 ? 1 : Math.floor(2 * v)) * 2 + Math.floor(2 * u);

        if (
            this.children &&
            this.children[childIndex] &&
            this.children[childIndex].state === Tile.State.LOADED
        ) {
            return this.children[childIndex].getElevation(lon, lat);
        }

        var tess = this.config.tesselation;
        var i = Math.floor(u * tess);
        var j = Math.floor(v * tess);

        var vo = this.config.vertexSize * (j * tess + i);
        var vertex = [
            this.vertices[vo],
            this.vertices[vo + 1],
            this.vertices[vo + 2]
        ];
        mat4.multiplyVec3(this.matrix, vertex);

        var geo = this.config.coordinateSystem.getWorldFrom3D(vertex);
        return geo[2];
    };

    /**************************************************************************************************************/

    /**
         Create the children
         */
    GeoTile.prototype.createChildren = function() {
        // Create the children
        var lonCenter =
            (this.geoBound.getEast() + this.geoBound.getWest()) * 0.5;
        var latCenter =
            (this.geoBound.getNorth() + this.geoBound.getSouth()) * 0.5;

        var level = this.level + 1;

        var tile00 = new GeoTile(
            new GeoBound(
                this.geoBound.getWest(),
                latCenter,
                lonCenter,
                this.geoBound.getNorth()
            ),
            level,
            2 * this.x,
            2 * this.y
        );
        var tile10 = new GeoTile(
            new GeoBound(
                lonCenter,
                latCenter,
                this.geoBound.getEast(),
                this.geoBound.getNorth()
            ),
            level,
            2 * this.x + 1,
            2 * this.y
        );
        var tile01 = new GeoTile(
            new GeoBound(
                this.geoBound.getWest(),
                this.geoBound.getSouth(),
                lonCenter,
                latCenter
            ),
            level,
            2 * this.x,
            2 * this.y + 1
        );
        var tile11 = new GeoTile(
            new GeoBound(
                lonCenter,
                this.geoBound.getSouth(),
                this.geoBound.getEast(),
                latCenter
            ),
            level,
            2 * this.x + 1,
            2 * this.y + 1
        );

        tile00.initFromParent(this, 0, 0);
        tile10.initFromParent(this, 1, 0);
        tile01.initFromParent(this, 0, 1);
        tile11.initFromParent(this, 1, 1);

        this.children = [tile00, tile10, tile01, tile11];
    };

    /**************************************************************************************************************/

    /**
         Convert coordinates in longitude,latitude to coordinate in "tile space"
         Tile space means coordinates are between [0,tesselation-1] if inside the tile
         Used by renderers algorithm to clamp coordinates on the tile
         */
    GeoTile.prototype.lonlat2tile = function(coordinates) {
        var ul = this.geoBound.getEast() - this.geoBound.getWest();
        var vl = this.geoBound.getSouth() - this.geoBound.getNorth();
        var factor = this.config.tesselation - 1;
        var tileCoords = [];
        for (var i = 0; i < coordinates.length; i++) {
            var u =
                (factor * (coordinates[i][0] - this.geoBound.getWest())) / ul;
            var v =
                (factor * (coordinates[i][1] - this.geoBound.getNorth())) / vl;
            tileCoords.push([u, v]);
        }
        return tileCoords;
    };

    /**************************************************************************************************************/

    /**
         Generate vertices for tile
         */
    GeoTile.prototype.generateVertices = function(elevations) {
        // Compute tile matrix
        this.matrix = this.config.coordinateSystem.getLHVTransform(
            this.geoBound.getCenter()
        );
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Build the vertices
        var vertexSize = this.config.vertexSize;
        var size = this.config.tesselation;
        var vertices = new Float32Array(vertexSize * size * (size + 6));
        var lonStep =
            (this.geoBound.getEast() - this.geoBound.getWest()) / (size - 1);
        var latStep =
            (this.geoBound.getSouth() - this.geoBound.getNorth()) / (size - 1);
        var radius = this.config.coordinateSystem.getGeoide().getRadius();
        var scale = this.config.coordinateSystem.getGeoide().getHeightScale();
        var offset = 0;

        // Optimized build for sphere coordinates : uncomment if needed
        var lat = this.geoBound.getNorth() /* * Math.PI / 180.0*/;
        // latStep = latStep * Math.PI / 180.0;
        // lonStep = lonStep * Math.PI / 180.0;
        var pos3d = [0.0, 0.0, 0.0];
        for (var j = 0; j < size; j++) {
            //var cosLat = Math.cos( lat );
            //var sinLat = Math.sin( lat );

            var lon = this.geoBound.getWest() /* * Math.PI / 180.0*/;

            for (var i = 0; i < size; i++) {
                // var height = elevations ? scale * elevations[ offset ] : 0.0;
                // var x = (radius + height) * Math.cos( lon ) * cosLat;
                // var y = (radius + height) * Math.sin( lon ) * cosLat;
                // var z = (radius + height) * sinLat;

                var height = elevations ? elevations[offset] : 0.0;
                this.config.coordinateSystem.get3DFromWorld(
                    [lon, lat, height],
                    pos3d
                );
                var x = pos3d[0];
                var y = pos3d[1];
                var z = pos3d[2];
                var vi = offset * vertexSize;
                vertices[vi] =
                    invMatrix[0] * x +
                    invMatrix[4] * y +
                    invMatrix[8] * z +
                    invMatrix[12];
                vertices[vi + 1] =
                    invMatrix[1] * x +
                    invMatrix[5] * y +
                    invMatrix[9] * z +
                    invMatrix[13];
                vertices[vi + 2] =
                    invMatrix[2] * x +
                    invMatrix[6] * y +
                    invMatrix[10] * z +
                    invMatrix[14];

                offset++;
                lon += lonStep;
            }

            lat += latStep;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /** @constructor
         GeoTiling constructor
         */
    var GeoTiling = function(nx, ny) {
        this.level0NumTilesX = nx;
        this.level0NumTilesY = ny;
    };

    /**************************************************************************************************************/

    /**
         Generate the tiles for level zero
         */
    GeoTiling.prototype.generateLevelZeroTiles = function(config) {
        config.skirt = !config.coordinateSystem.isFlat();
        config.cullSign = 1;
        config.srs = "CRS:84";

        var level0Tiles = [];

        var latStep =
            (config.coordinateSystem.getGeoBound().getNorth() -
                config.coordinateSystem.getGeoBound().getSouth()) /
            this.level0NumTilesY;
        var lonStep =
            (config.coordinateSystem.getGeoBound().getEast() -
                config.coordinateSystem.getGeoBound().getWest()) /
            this.level0NumTilesX;

        // Manage (just for latitude) a partial GeoTiling cover (not only 360 * 180)
        this.latStart = config.coordinateSystem.getGeoBound().getSouth();
        this.latDelta =
            config.coordinateSystem.getGeoBound().getNorth() -
            config.coordinateSystem.getGeoBound().getSouth();

        for (var j = 0; j < this.level0NumTilesY; j++) {
            for (var i = 0; i < this.level0NumTilesX; i++) {
                var geoBound = new GeoBound(
                    config.coordinateSystem.getGeoBound().getWest() +
                        i * lonStep,
                    config.coordinateSystem.getGeoBound().getNorth() -
                        (j + 1) * latStep,
                    config.coordinateSystem.getGeoBound().getWest() +
                        (i + 1) * lonStep,
                    config.coordinateSystem.getGeoBound().getNorth() -
                        j * latStep
                );
                var tile = new GeoTile(geoBound, 0, i, j);
                tile.config = config;
                level0Tiles.push(tile);
            }
        }

        return level0Tiles;
    };

    /**
     * Compute the bbox of a feature
     */
    var _getBBox = function(geometry) {
        // Get the coordinates
        var coords;
        var checkDateLine = true;
        switch (geometry.type) {
            case Constants.GEOMETRY.Point:
                coords = geometry.coordinates;
                return [coords[0], coords[1], coords[0], coords[1]];
            case Constants.GEOMETRY.MultiPoint:
                coords = geometry.coordinates;
                checkDateLine = false;
                break;
            case Constants.GEOMETRY.Polygon:
                coords = geometry.coordinates[0];
                break;
            case Constants.GEOMETRY.MultiPolygon:
                coords = geometry.coordinates[0][0];
                break;
            case Constants.GEOMETRY.LineString:
                coords = geometry.coordinates;
                break;
            case Constants.GEOMETRY.MultiLineString:
                coords = geometry.coordinates[0];
                break;
        }

        if (!coords || coords.length === 0) {
            return;
        }

        var minX = coords[0][0];
        var minY = coords[0][1];
        var maxX = coords[0][0];
        var maxY = coords[0][1];

        var numOuterRings =
            geometry.type === Constants.GEOMETRY.MultiPolygon ||
            geometry.type === Constants.GEOMETRY.MultiLineString
                ? geometry.coordinates.length
                : 1;
        for (var j = 0; j < numOuterRings; j++) {
            switch (geometry.type) {
                case Constants.GEOMETRY.MultiPolygon:
                    coords = geometry.coordinates[j][0];
                    break;
                case Constants.GEOMETRY.MultiLineString:
                    coords = geometry.coordinates[j];
                    break;
            }

            for (var i = 0; i < coords.length; i++) {
                minX = Math.min(minX, coords[i][0]);
                minY = Math.min(minY, coords[i][1]);
                maxX = Math.max(maxX, coords[i][0]);
                maxY = Math.max(maxY, coords[i][1]);

                // Check if the coordinates cross dateline
                if (
                    checkDateLine &&
                    i > 0 &&
                    UtilsIntersection.isCrossDateLine(
                        coords[i - 1][0],
                        coords[i][0]
                    )
                ) {
                    minX = -180;
                    maxX = 180;
                }
            }
        }

        return [minX, minY, maxX, maxY];
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */

    GeoTiling.prototype._lon2LevelZeroIndex = function(lon) {
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(((lon + 180) * this.level0NumTilesX) / 360)
        );
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    GeoTiling.prototype._lat2LevelZeroIndex = function(lat) {
        // Take into account a partial bbox for GeoTiling
        var topLat = this.latStart + this.latDelta;
        return Math.min(
            this.level0NumTilesY - 1,
            Math.floor(((topLat - lat) * this.level0NumTilesY) / this.latDelta)
        );
    };
    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    GeoTiling.prototype.lonlat2LevelZeroIndex = function(lon, lat) {
        return (
            this._lat2LevelZeroIndex(lat) * this.level0NumTilesX +
            this._lon2LevelZeroIndex(lon)
        );
    };

    /**************************************************************************************************************/

    /**
         Get the overlapped tile by the given geometry
         */
    GeoTiling.prototype.getOverlappedLevelZeroTiles = function(geometry) {
        var tileIndices = [];

        var bbox = _getBBox(geometry);
        if (bbox) {
            var i1 = this._lon2LevelZeroIndex(bbox[0]);
            var j1 = this._lat2LevelZeroIndex(bbox[3]);
            var i2 = this._lon2LevelZeroIndex(bbox[2]);
            var j2 = this._lat2LevelZeroIndex(bbox[1]);

            for (var j = j1; j <= j2; j++) {
                for (var i = i1; i <= i2; i++) {
                    tileIndices.push(j * this.level0NumTilesX + i);
                }
            }
        }

        return tileIndices;
    };

    /**************************************************************************************************************/

    /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
    GeoTiling.prototype.findInsideTile = function(lon, lat, tiles) {
        var tile = null;
        for (var i = 0; i < tiles.length; i++) {
            tile = tiles[i];
            var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
            if (index === tile.pixelIndex) {
                return tile;
            }
        }
        // index not found, check with lon lat
        for (i = 0; i < tiles.length; i++) {
            tile = tiles[i];
            var found =
                lat <= tile.bound.north &&
                lat >= tile.bound.south &&
                lon <= tile.bound.east &&
                lon >= tile.bound.west;
            if (found === true) {
                return tile;
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    return GeoTiling;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMSLayer',[
    "jquery",
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/GeoTiling",
    "../Utils/UtilsIntersection"
], function(
    $,
    Utils,
    AbstractLayer,
    AbstractRasterLayer,
    Constants,
    GeoTiling,
    UtilsIntersection
) {
    /**
     * Configuration parameters to query a Web Map Service (WMS) and Web Map Service-Time (WMS-Time)
     * @typedef {AbstractLayer.configuration} AbstractRasterLayer.wms_configuration
     * @property {string} type - Must be "WMS" - the type of this service
     * @property {string} layers - Layers to display on map. Value is a comma-separated list of layer names.
     * @property {string} [styles=""] - Styles in which layers are to be rendered. Value is a comma-separated list
     * of style names, or empty if default styling is required. Style names may be empty in the list, to use
     * default layer styling.
     * @property {string} [version = "1.3.0"] - Service version
     * @property {string} [format = "image/jpeg"] - Format for the map output
     * @property {string} [transparent = false] - 	Whether the map background should be transparent. Values are
     * true or false. Default is false
     * @property {string} [time] - Time value or range for map data using WMS-Time
     * @property {int} [tilePixelSize = 256] - tile in pixels
     * @property {int} [numberOfLevels = 21] - number of levels
     * @property {{west:float, north:float, east:float, south:float}} [restrictTo] - Bounding box on which the WMS
     * query is allowed. The WMS query must intersect the bounding box sets to restrictTo. When restrictTo is not
     * defined, the bounding box is equivalent to the whole planet.
     * @property {boolean} [autoFillTimeTravel] - Set to true so that Mizar can automatically retrieve the
     * defined time from the time dimension.
     * @property {{units:string,unitSymbol:string,default:string,multipleValues:string,nearestValue:string,value:string}} [dimension.time] - Supported time for WMS-T
     */

    //TODO : check id restrictTo is set to the extent of the layer
    //TODO : For version 1.3.0 crs must be CRS:84 and then tile.config.srs must be CRS:84 with BBOX coord long/lat
    //TODO : For version 1.3.0 and crs=EPSG:xxxx => too bad because we have the bbox coord in this order lat/long
    //TODO : For version != 1.3.0, crs is not used anymore, we srs and it akes an EPSG code with the bbox order long/lat

    /**
     * @name WMSLayer
     * @class
     *    Creates a layer for imagery data using WMS (Web Map Service) or WMS-Time (Web Map Service - Time) protocol
     *    based on a GeoTiling(4, 2) with a pixelSize = 256 by default.<br/>
     *    WMS provides a standard interface for requesting a geo-spatial map image.
     *    The standard guarantees that these images can all be overlaid on one another.
     *    <br/><br/>
     *    Example of a WMS request<br/>
     *    <code>
     *        http://example.com/wms?request=GetMap&service=WMS&version=1.3.0&layers=MyLayer
     *        &styles=population&crs=CRS:84&bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578
     *        &width=780&height=330&format=image/png
     *    </code>
     *
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.wms_configuration} options - WMS Configuration
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.opengeospatial.org/standards/wms WMS} standard
     */
    var WMSLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 256;
        options.tiling = new GeoTiling(4, 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        options.transparent = options.transparent || false;

        this.restrictTo = options.restrictTo;
        this.autoFillTimeTravel = options.autoFillTimeTravel;

        //this._computeBaseUrlAndCapabilities(options);

        AbstractRasterLayer.prototype.constructor.call(
            this,
            options.type,
            options
        );

        this.timeTravelValues = null;

        // If needed, try to fill time travel parameters
        if (
            this.autoFillTimeTravel === true &&
            this.containsDimension("time")
        ) {
            this.generateTimeTravel(options.dimension.time);
        }

        this.getMapBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            this.tilePixelSize,
            this.tilePixelSize,
            options
        );
        this.layers = options.layers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WMSLayer);

    /**************************************************************************************************************/

    /**
     * Static part of the URL to query the WMS/WMS-T server.
     * @function _queryImage
     * @memberof WMSLayer#
     * @param {string} baseUrl - Base URL of the WMS/WMS-Time server
     * @param {int} xTilePixelSize - Number of pixels along X for the output image
     * @param {int} yTilePixelSize - Number of pixels along Y for the output image
     * @param {AbstractRasterLayer.wms_configuration} options - options
     * @return {string} the URL
     * @private
     */
    function _queryImage(baseUrl, xTilePixelSize, yTilePixelSize, options) {
        // Build the base GetMap URL
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wms");
        url = Utils.addParameterTo(
            url,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.3.0"
        );
        url = Utils.addParameterTo(url, "request", "getMap");
        url = Utils.addParameterTo(url, "layers", options.layers);
        url = Utils.addParameterTo(
            url,
            "styles",
            options.hasOwnProperty("styles") ? options.styles : ""
        );
        url = Utils.addParameterTo(
            url,
            "format",
            options.hasOwnProperty("format") ? options.format : "image/jpeg"
        );

        // transparent option
        if (options.hasOwnProperty("transparent")) {
            url = Utils.addParameterTo(url, "transparent", options.transparent);
        }
        url = Utils.addParameterTo(url, "width", xTilePixelSize);
        url = Utils.addParameterTo(url, "height", yTilePixelSize);

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        // custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    /**
     * Checks whether the footprint (that represents the restricted zone area) intersects with the tile
     * @function _tileIsIntersectedFootprint
     * @memberof WMSLayer#
     * @param {{west:float, north:float, east:float, south:float}} tile - Tile
     * @param {{west:float, north:float, east:float, south:float}} footprint - restricted zone area
     * @return {boolean} true when the tile intersects with the footprint otherwise false
     * @private
     */
    function _tileIsIntersectedFootprint(tile, footprint) {
        var isIntersect;
        if (footprint != null) {
            // check if tile is inside restrict zone
            isIntersect = UtilsIntersection.boundsIntersects(tile, footprint);
        } else {
            isIntersect = true;
        }
        return isIntersect;
    }

    /**
     * Sets the time to query
     * @function setTime
     * @memberof WMSLayer#
     * @param {Time.configuration} time - time to query
     */
    WMSLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    /**
     * Returns the legend from the WMS/WMS-T server
     * @function getLegend
     * @memberof WMSLayer#
     * @return {{title:string, format:string, url:string, size:string}} the legend information
     */
    WMSLayer.prototype.getLegend = function() {
        var metadata = this.metadataAPI;
        var legend;
        if (metadata.Style) {
            var defaultStyle = metadata.Style[0];
            var title = defaultStyle.Title;
            var format = defaultStyle.LegendURL[0].Format;
            var url = defaultStyle.LegendURL[0].OnlineResource;
            var size = defaultStyle.LegendURL[0].size;
            if (title === undefined || title === "default") {
                legend = {};
            } else {
                legend = {
                    title: title,
                    format: format,
                    url: url,
                    size: size
                };
            }
        } else {
            legend = {};
        }
        return legend;
    };

    //WMSLayer.prototype.getFeatureInfo = function(position, resolution, callback, fallback) {
    //    var positionResolution;
    //    if (resolution) {
    //        positionResolution = resolution;
    //    } else {
    //        positionResolution = {
    //            longitude:0.0001,
    //            latitude:0.0001
    //        }
    //    }
    //    var url = this.getMapBaseUrl;
    //    var baseURL = Utils.parseBaseURL(url);
    //    var params = Utils.parseQueryString(url);
    //    params['crs'] = "CRS:84";
    //    params['query_layers'] = this.options.layers;
    //    params['request'] = "GetFeatureInfo";
    //    params['width'] = 2;
    //    params['height'] = 2;
    //    params['x'] = 1;
    //    params['y'] = 1;
    //    params['bbox'] = position.longitude+","+position.latitude+","+(position.longitude+positionResolution.longitude)+","+(position.latitude+positionResolution.latitude)
    //
    //    url = baseURL;
    //    for(var param in params) {
    //        url = Utils.addParameterTo(url, param, params[param]);
    //    }
    //
    //    Utils.requestUrl(url, "text", null,
    //        function(response, options) {
    //            var lines = response.trim().split('\n');
    //            var featuresInfo = {};
    //            for (var i = 0; i < lines.length; ++i) {
    //                var layerName;
    //
    //                if (lines[i].substring(0, 5) === "Layer") {
    //                    layerName  = lines[i].match(/'(.*?)'/)[1];
    //                } else if(lines[i].substring(0, 9) === "  Feature") {
    //                    featuresInfo[layerName] = [];
    //                } else if(lines[i].substring(0, 11) === "    value_0") {
    //                    featuresInfo[layerName].push(parseFloat(lines[i].match(/'(.*?)'/)[1]));
    //                }
    //            }
    //            if(callback) {
    //                callback(featuresInfo);
    //            }
    //        },
    //        fallback);
    //
    //};

    /**
     * Sets visible/hidden the layer and the legend related to the layer.
     * To make visible the legend, a <div id="legendDiv"/> must be set in the HTML file.
     * @function setVisible
     * @memberof WMSLayer#
     * @param arg true when the layer must be visible otherwise false
     */
    WMSLayer.prototype.setVisible = function(arg) {
        AbstractRasterLayer.prototype.setVisible.call(this, arg);
        if (document.getElementById("legendDiv")) {
            var legend = this.getLegend();
            if (Object.keys(legend).length > 0) {
                document.getElementById("legendDiv").innerHTML = "";
                if (arg === true) {
                    document.getElementById("legendDiv").innerHTML =
                        "<div id='legendTxt' class='column'>" +
                        legend.title +
                        "</div><div id='legendUrl' class='column'><img src='" +
                        legend.url +
                        "'/></div>";
                }
            }
        }
    };

    /**
     * Returns the url for the given tile
     * The URL is returned in the following case :
     * - the HTTP request is allowed (case of the time request, the requested time is inside a supported time value
     * or range - when no time dimension, no constraint).
     * - the image is background (when an image is in background, this image is always request, we do not try to
     * make optimization)
     * - the spatial tile intersects with the image extent (useful when we want to display a single footprint as
     * an image - in this case, we do not want to make the request to the server when we know the request does not
     * intersect the image's footprint)
     * @function getUrl
     * @memberof WMSLayer#
     * @param {Tile} tile Tile
     * @return {String} Url
     */
    WMSLayer.prototype.getUrl = function(tile) {
        // Just add the bounding box to the GetMap URL
        var bound = tile.bound;
        var url, bbox;
        // we cannot reject the request to the server when the layer is defined as background otherwise there is
        // no image to show and Mizar is waiting for an image
        if (this.allowedHTTPRequest) {
            if (
                this.isBackground() ||
                _tileIsIntersectedFootprint(bound, this.restrictTo)
            ) {
                bbox =
                    bound.west +
                    "," +
                    bound.south +
                    "," +
                    bound.east +
                    "," +
                    bound.north;
                url = this.getMapBaseUrl;
                url = Utils.addParameterTo(
                    url,
                    "transparent",
                    this.options.transparent
                );
                url = Utils.addParameterTo(url, "crs", tile.config.srs);
                url = Utils.addParameterTo(url, "bbox", bbox);
            } else {
                url = null;
            }
        } else {
            url = null;
        }

        return this.proxify(url, tile.level);
    };

    /**
     * Set a parameter and add it to the static query parameters.
     * The parameter is added according to some [use cases]{@link AbstractLayer#_hasToBeRefreshed} with the time.
     * @function setParameter
     * @memberof WMSLayer#
     * @param paramName parameter name
     * @param value value name
     */
    WMSLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getMapBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.tilePixelSize,
                this.tilePixelSize,
                this.options
            );
            this.forceRefresh();
        }
    };

    /**************************************************************************************************************/

    return WMSLayer;
});

define('Registry/WMTSMetadata',[], function() {
    var WMTSMetadata = function(json) {
        this.serviceIdentification = new ServiceIdentification(
            json.Capabilities.ServiceIdentification
        );
        this.serviceProvider = new ServiceProvider(
            json.Capabilities.ServiceProvider
        );
        //this.operationsMetadata;
        this.contents = new Contents(json.Capabilities.Contents);
        //this.themes;
        this.serviceMetadataURL = WMTSMetadata.getValueTag(
            json.Capabilities._attrhref
        );
    };

    var ServiceIdentification = function(json) {
        if (json === undefined) {
            this.version = null;
            this.title = null;
            this.abstract = null;
            this.keywords = null;
            this.serviceType = null;
            this.fees = null;
            this.accessConstraints = null;
        } else {
            this.version = WMTSMetadata.getValueTag(json._attrversion);
            this.title = WMTSMetadata.getValueTag(json.Title);
            this.abstract = WMTSMetadata.getValueTag(json.Abstract);
            this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
            this.serviceType = WMTSMetadata.getValueTag(json.ServiceType);
            this.fees = WMTSMetadata.getValueTag(json.Fees);
            this.accessConstraints = WMTSMetadata.parseAccessConstraints(
                json.AccessConstraints
            );
        }
    };

    var ServiceProvider = function(json) {
        if (json === undefined) {
            this.providerName = null;
            this.providerSite = null;
            this.serviceContact = null;
        } else {
            this.providerName = WMTSMetadata.getValueTag(json.ProviderName);
            this.providerSite = null;
            this.serviceContact = new ServiceContact(json.ServiceContact);
        }
    };

    var ServiceContact = function(json) {
        if (json === undefined) {
            this.individualName = null;
            this.positionName = null;
            this.contactInfo = null;
            this.role = null;
        } else {
            this.individualName = WMTSMetadata.getValueTag(json.IndividualName);
            this.positionName = WMTSMetadata.getValueTag(json.PositionName);
            this.contactInfo = new ContactInfo(json.ContactInfo);
            this.role = WMTSMetadata.getValueTag(json.Role);
        }
    };

    var ContactInfo = function(json) {
        if (json === undefined) {
            this.phone = null;
            this.address = null;
            this.onlineResource = null;
            this.hoursOfService = null;
            this.contactInstructions = null;
        } else {
            this.phone = new Phone(json.Phone);
            this.address = new Address(json.Address);
            this.onlineResource = null;
            this.hoursOfService = WMTSMetadata.getValueTag(json.HoursOfService);
            this.contactInstructions = WMTSMetadata.getValueTag(
                json.ContactInstructions
            );
        }
    };

    var Phone = function(json) {
        if (json === undefined) {
            this.voice = null;
            this.facsimile = null;
        } else {
            this.voice = WMTSMetadata.parseVoice(json.Voice);
            this.facsimile = WMTSMetadata.parsePhone(json.Facsimile);
        }
    };

    var Address = function(json) {
        if (json === undefined) {
            this.deliveryPoint = null;
            this.city = null;
            this.administrativeArea = null;
            this.postalCode = null;
            this.country = null;
            this.electronicMailAddress = null;
        } else {
            this.deliveryPoint = WMTSMetadata.getValueTag(json.DeliveryPoint);
            this.city = WMTSMetadata.getValueTag(json.City);
            this.administrativeArea = WMTSMetadata.getValueTag(
                json.AdministrativeArea
            );
            this.postalCode = WMTSMetadata.getValueTag(json.PostalCode);
            this.country = WMTSMetadata.getValueTag(json.Country);
            this.electronicMailAddress = WMTSMetadata.getValueTag(
                json.ElectronicMailAddress
            );
        }
    };

    var Contents = function(json) {
        if (json === undefined) {
            this.layers = null;
            this.tileMatrixSets = null;
        } else {
            this.layers = WMTSMetadata.parseLayer(json.Layer);
            this.tileMatrixSets = new TileMatrixSet(json.TileMatrixSet);
        }
    };

    WMTSMetadata.parseLayer = function(json) {
        var layers = [];
        if (json === undefined) {
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                layers.push(new Layer(json[i]));
            }
        } else {
            layers.push(new Layer(json));
        }
        return layers;
    };

    WMTSMetadata.parseTileMatrixSetLink = function(json) {
        var tileMatrixSetLink = [];
        if (json === undefined) {
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                tileMatrixSetLink.push(
                    WMTSMetadata.getValueTag(json.TileMatrixSet[i])
                );
            }
        } else {
            tileMatrixSetLink.push(
                WMTSMetadata.getValueTag(json.TileMatrixSet)
            );
        }
        return tileMatrixSetLink;
    };

    WMTSMetadata.parseFormat = function(json) {
        var formats = [];
        if (json === undefined) {
        } else if (Array.isArray(json)) {
            for (var i = 0; i < json.length; i++) {
                formats.push(WMTSMetadata.getValueTag(json.Format[i]));
            }
        } else {
            formats.push(WMTSMetadata.getValueTag(json));
        }
        return formats;
    };

    var Layer = function(json) {
        if (json === undefined) {
            this.identifier = null;
            this.format = null;
            this.infoFormat = null;
            this.style = null;
            this.tileMatrixSetLink = null;
            this.title = null;
            this.abstract = null;
            this.wgs84BoundingBox = null;
            this.boundingBox = null;
            this.keywords = null;
            this.metadata = null;
            this.datasetDescriptionSummary = null;
            this.otherSource = null;
            this.dimension = null;
            this.resourceURL = null;
        } else {
            this.identifier = WMTSMetadata.getValueTag(json.Identifier);
            this.format = WMTSMetadata.parseFormat(json.Format);
            this.infoFormat = null;
            this.style = null;
            this.tileMatrixSetLink = WMTSMetadata.parseTileMatrixSetLink(
                json.TileMatrixSetLink
            );
            this.title = WMTSMetadata.getValueTag(json.Title);
            this.abstract = WMTSMetadata.getValueTag(json.Abstract);
            this.wgs84BoundingBox = WMTSMetadata.parseWGS84BoundingBox(
                json.WGS84BoundingBox
            );
            this.boundingBox = WMTSMetadata.parseBoundingBox(json.BoundingBox);
            this.keywords = WMTSMetadata.parseKeywordList(json.Keywords);
            this.metadata = null;
            this.datasetDescriptionSummary = null;
            this.otherSource = null;
            this.dimension = null;
            this.resourceURL = null;
        }
    };

    var TileMatrixSet = function(json) {
        this.identifier = null;
        this.supportedCRS = null;
        this.wellKnownScaleSet = null;
        this.tileMatrix = null;
    };

    var TileMatrix = function(json) {
        this.identifier = null;
        this.scaleDenominator = null;
        this.topLeftCorner = null;
        this.tileWidth = null;
        this.tileHeight = null;
        this.matrixWidth = null;
        this.matrixHeight = null;
    };

    WMTSMetadata.getValueTag = function(json) {
        var result;
        if (json !== undefined) {
            result = json.hasOwnProperty("_text")
                ? WMTSMetadata.getText(json)
                : WMTSMetadata.getValue(json);
        } else {
            result = null;
        }
        return result;
    };

    WMTSMetadata.getText = function(keyword) {
        return keyword._text;
    };

    WMTSMetadata.getValue = function(keyword) {
        return keyword._value;
    };

    WMTSMetadata.parseKeywordList = function(keywordsJson) {
        var keywords = [];
        if (
            keywordsJson !== undefined &&
            keywordsJson.hasOwnProperty("Keyword")
        ) {
            if (Array.isArray(keywordsJson.Keyword)) {
                for (var keyword in keywordsJson.Keyword) {
                    keywords.push(
                        WMTSMetadata.getValueTag(keywordsJson.Keyword[keyword])
                    );
                }
            } else {
                keywords.push(WMTSMetadata.getValueTag(keywordsJson.Keyword));
            }
        }
        return keywords;
    };

    WMTSMetadata.parseVoice = function(json) {
        var voices = [];
        if (json !== undefined && json.hasOwnProperty("Voice")) {
            if (Array.isArray(json.Voice)) {
                for (var voice in json.Voice) {
                    voices.push(WMTSMetadata.getValueTag(json.Voice[voice]));
                }
            } else {
                voices.push(WMTSMetadata.getValueTag(json.Voice));
            }
        }
        return voices;
    };

    WMTSMetadata.parseFacsimile = function(json) {
        var phones = [];
        if (json !== undefined && json.hasOwnProperty("Facsimile")) {
            if (Array.isArray(json.Facsimile)) {
                for (var facs in json.Facsimile) {
                    phones.push(WMTSMetadata.getValueTag(json.Facsimile[facs]));
                }
            } else {
                phones.push(WMTSMetadata.getValueTag(json.Facsimile));
            }
        }
        return phones;
    };

    WMTSMetadata.parseAccessConstraints = function(json) {
        var acccessConstraints = [];
        if (json !== undefined && json.hasOwnProperty("AccessConstraints")) {
            if (Array.isArray(json.AccessConstraints)) {
                for (var access in json.AccessConstraints) {
                    acccessConstraints.push(
                        WMTSMetadata.getValueTag(json.AccessConstraints[access])
                    );
                }
            } else {
                acccessConstraints.push(
                    WMTSMetadata.getValueTag(json.AccessConstraints)
                );
            }
        }
        return acccessConstraints;
    };

    WMTSMetadata.parseWGS84BoundingBox = function(wgs84BoundingBoxJson) {
        var wgs84BoundingBox = [];
        if (wgs84BoundingBoxJson !== undefined) {
            if (Array.isArray(wgs84BoundingBoxJson)) {
                for (var wgs84 in wgs84BoundingBoxJson) {
                    wgs84BoundingBox.push({
                        lowerCorner: WMTSMetadata.getValueTag(
                            wgs84.LowerCorner
                        ),
                        upperCorner: WMTSMetadata.getValueTag(wgs84.UpperCorner)
                    });
                }
            } else {
                wgs84BoundingBox.push({
                    lowerCorner: WMTSMetadata.getValueTag(
                        wgs84BoundingBoxJson.LowerCorner
                    ),
                    upperCorner: WMTSMetadata.getValueTag(
                        wgs84BoundingBoxJson.UpperCorner
                    )
                });
            }
        }
        return wgs84BoundingBox;
    };

    WMTSMetadata.parseBoundingBox = function(BoundingBoxJson) {
        //TODO crs dimensions
        var boundingBox = [];
        if (BoundingBoxJson !== undefined) {
            if (Array.isArray(BoundingBoxJson)) {
                for (var bbox in BoundingBoxJson) {
                    boundingBox.push({
                        lowerCorner: WMTSMetadata.getValueTag(bbox.LowerCorner),
                        upperCorner: WMTSMetadata.getValueTag(bbox.UpperCorner)
                    });
                }
            } else {
                boundingBox.push({
                    lowerCorner: WMTSMetadata.getValueTag(
                        BoundingBoxJson.LowerCorner
                    ),
                    upperCorner: WMTSMetadata.getValueTag(
                        BoundingBoxJson.UpperCorner
                    )
                });
            }
        }
        return boundingBox;
    };

    return WMTSMetadata;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMTSLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Registry/WMTSMetadata"
], function(
    Utils,
    AbstractLayer,
    AbstractRasterLayer,
    Constants,
    WMTSMetadata
) {
    /**
     * Configuration parameters to query a Web Map Tile Service (WMTS)
     * @typedef {AbstractRasterLayer} AbstractRasterLayer.wmts_configuration
     * @property {string} [version = "1.0.0"] WMTS version
     * @property {string} layer - basic unit of geographic information that may be requested as a map from a server
     * @property {string} matrixSet - The name of pyramidal images
     * @property {int} startLevel - Start level of the index
     * @property {string} [style] - Styled Layers Descriptor
     */
    /**
     * @name WMTSLayer
     * @class
     *    Creates a layer for imagery data using WMTS protocol.
     *    <br/>
     *    WMTS protocol provides tiles with a resolution of <i>tilePixelSize</i><br/>
     *    based on a GeoTiling(4, 2)<br/>
     *    <img src="../doc/images/wmts_tile.png"/><br/>
     *    <br/
     *    Example of a WMTS request:
     *    <code>
     *            http://example.com/wmts?LAYER=MyLayer1,MyLayer2&
     *            EXCEPTIONS=text/xml&FORMAT=image/jpeg&SERVICE=WMTS&
     *            VERSION=1.0.0&REQUEST=GetTile&STYLE=normal&
     *            TILEMATRIXSET=PM&TILEMATRIX=18&TILEROW=90241&TILECOL=132877&
     *    </code>
     *    <br/><br/>
     *    The parameters of a WMTS server are the following:
     *    <ul>
     *        <li><b>TILEMATRIXSET</b>: The name of pyramidal images</li>
     *        <li><b>TILEMATRIX</b>: The name of the matrix that contains the tile</li>
     *        <li><b>TILEROW</b>: The line number from the top left corner from the tile</li>
     *        <li><b>TILECOL</b>: The column number from the top left corner from the tile</li>
     *    </ul>
     *    <img src="../doc/images/wmts_pixel.png"/>
     *
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.configuration} options - WMTS configuration
     * @property {int} [tilePixelSize = 256] - tile in pixels
     * @property {int} [numberOfLevels = 21] - number of levels
     * @property {string} [version = "1.0.0"] - WMS version
     * @property {string} [transparent]
     * @property {string} [time] - Time dimension
     * @property {string} [format = "image/png"] - output image format
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.opengeospatial.org/standards/wmts WMTS} standard
     * @see {@link http://www.opengeospatial.org/standards/sld SLD} standard
     */
    var WMTSLayer = function(options) {
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.WMTS,
            options
        );
        this.getTileBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            options
        );
        this.imageLoadedAtTime = null;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WMTSLayer);

    /**************************************************************************************************************/

    function _queryImage(baseUrl, options) {
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wmts");
        url = Utils.addParameterTo(url, "version", options.version || "1.0.0");
        url = Utils.addParameterTo(url, "request", "GetTile");
        url = Utils.addParameterTo(url, "layer", options.layers);
        url = Utils.addParameterTo(url, "tilematrixset", "WGS84");
        //            url = Utils.addParameterTo(url, "tilematrixset", options.tilematrixset);

        if (options.hasOwnProperty("style")) {
            url = Utils.addParameterTo(url, "style", options.style);
        }

        url = Utils.addParameterTo(
            url,
            "format",
            options.hasOwnProperty("format") ? options.format : "image/png"
        );

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        //custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    WMTSLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    WMTSLayer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMTS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile
     * @function getUrl
     * @memberof WMTSLayer#
     * @param {Tile} tile Tile
     * @return {String} Url
     */
    WMTSLayer.prototype.getUrl = function(tile) {
        var url;
        if (this.allowedHTTPRequest) {
            url = this.getTileBaseUrl;
            url = Utils.addParameterTo(url, "tilematrix", tile.level + 1);
            url = Utils.addParameterTo(url, "tilecol", tile.x);
            url = Utils.addParameterTo(url, "tilerow", tile.y);
        } else {
            url = null;
        }
        return this.proxify(url, tile.level);
    };

    WMTSLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getCoverageBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.options
            );
            this.forceRefresh();
        }
    };

    ///**
    // * Checks if Mizar must query the WMS server to refresh data.
    // * When the camera does not move but that the time change, we have two cases :
    // * - the requested time is included in the time frame of the image => no query
    // * - the requested time is outside of the time frame of the image => this is a new image, need to query
    // * @param paramName
    // * @param value
    // * @return {*}
    // * @private
    // */
    //WMTSLayer.prototype._hasToBeRefreshed = function(paramName, value) {
    //    var hasToBeRefreshed;
    //    if(paramName==="time") {
    //        var timeRequest = AbstractLayer.createTimeRequest(value);
    //        var allowedTime = this.getDimensions().time;
    //        var selectedDate = AbstractLayer.selectedTime(allowedTime.value, timeRequest);
    //        if(this.imageLoadedAtTime != null && selectedDate == null) {
    //            // we query because the state has changed
    //            hasToBeRefreshed = true;
    //            this.imageLoadedAtTime = null;
    //        } else if(selectedDate == null) {
    //            // No image found on the server related to the requested time, no need to query => we save network
    //            hasToBeRefreshed = false;
    //        } else if (this.imageLoadedAtTime === selectedDate) {
    //            // Same state, no need to query
    //            hasToBeRefreshed = false;
    //        } else {
    //            // At the requested time, there is an image on the server and this is not the current one => query
    //            hasToBeRefreshed = true;
    //            this.imageLoadedAtTime = selectedDate;
    //        }
    //    } else {
    //        hasToBeRefreshed = true;
    //    }
    //    this.mustbeSkipped = !hasToBeRefreshed;
    //    return hasToBeRefreshed;
    //};

    /**************************************************************************************************************/

    return WMTSLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WCSElevationLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/GeoTiling"
], function(Utils, AbstractLayer, AbstractRasterLayer, Constants, GeoTiling) {
    /**
     * WCSElevation configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.wcsElevation_configuration
     * @property {int} [tilePixelSize = 33]
     * @property {int} [numberOfLevels = 21]
     * @property {string} baseUrl - the base Url to access the WCS server
     * @property {string} coverage - the name of the coverage to use (WCS parameter)
     * @property {string} crs - the coordinate reference system to use (WCS parameter)
     * @property {string} [outputCRS=crs] for 2.0
     * @property {string} version -  2.0.x or 1.0.x is supported
     * @property {float} [scale=1] - elevation scale value
     * @property {float} [scaleData=1] - elevation scale value to apply to have the true altitude
     * @property {string} [format='image/x-aaigrid']
     * @property {float} [minElevation=0]
     */

    /**
     * @name WCSElevationLayer
     * @class
     *    Create a layer for elevation data using WCS protocol  based on a GeoTiling(4, 2)
     *    with a pixelSize = 33 by default. The only supported format is right now image/x-aaigrid. It is an ASCII
     *    format that is easily parsed in Javascript.
     * @augments AbstractRasterLayer
     * @param {AbstractLayer.wcsElevation_configuration} options - WCSElevation Configuration
     * @constructor
     * @memberof module:Layer
     */
    var WCSElevationLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 33;
        options.tiling = new GeoTiling(4, 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        options.version = options.version || "2.0.0";
        options.format = options.format || "image/x-aaigrid";
        options.minElevation = options.minElevation || 0;
        options.scale = options.scale || 1;
        options.scaleData = options.scaleData || 1;
        options.crs = options.crs || "EPSG:4326";
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.WCSElevation,
            options
        );
        // Build the base GetMap URL
        this.getCoverageBaseUrl = _queryImage.call(
            this,
            this.getBaseUrl(),
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, WCSElevationLayer);

    /**************************************************************************************************************/

    function _queryImage(baseUrl, options) {
        var url = baseUrl;
        url = Utils.addParameterTo(url, "service", "wcs");
        url = Utils.addParameterTo(url, "version", options.version);
        url = Utils.addParameterTo(url, "request", "GetCoverage");

        switch (options.version.substring(0, 3)) {
            case "2.0":
                url = Utils.addParameterTo(url, "outputCRS", options.crs);
                url = Utils.addParameterTo(
                    url,
                    "size",
                    "x(" + options.tilePixelSize + ")"
                );
                url = Utils.addParameterTo(
                    url,
                    "size",
                    "y(" + options.tilePixelSize + ")"
                );
                url = Utils.addParameterTo(url, "coverageid", options.coverage);
                break;
            case "1.0":
                url = Utils.addParameterTo(url, "width", options.tilePixelSize);
                url = Utils.addParameterTo(
                    url,
                    "height",
                    options.tilePixelSize
                );
                url = Utils.addParameterTo(url, "crs", options.crs);
                url = Utils.addParameterTo(url, "coverage", options.coverage);
                break;
        }
        url = Utils.addParameterTo(url, "format", options.format);

        if (options.hasOwnProperty("time")) {
            url = Utils.addParameterTo(url, "time", options.time);
        }

        // time constraints and custom params
        for (var param in this.imageLoadedAtTime) {
            if (param !== "time" && this.imageLoadedAtTime[param] !== null) {
                url = Utils.addParameterTo(
                    url,
                    param,
                    this.imageLoadedAtTime[param]
                );
            }
        }

        return url;
    }

    /**
     * Parse a elevation response
     * @function parseElevations
     * @memberof WCSElevationLayer#
     * @param {String} text Response as text
     */
    WCSElevationLayer.prototype.parseElevations = function(text) {
        if (text === null || text.match("ServiceExceptionReport") != null) {
            return this._returnZeroElevations();
        }
        switch (this.options.format) {
            case "image/x-aaigrid":
                return this._parseAAIGrid(text);
            default:
                console.log(
                    "WARN: Format '" + this.format + "' could not be parsed."
                );
                return this._returnZeroElevations();
        }
    };

    /**
     * Fallback elevations when no data was returned
     * @function _returnZeroElevations
     * @memberof WCSElevationLayer#
     * @returns {float[]} Array of float
     * @private
     */
    WCSElevationLayer.prototype._returnZeroElevations = function() {
        var elevations = [];
        for (
            var i = 0;
            i < this.options.tilePixelSize * this.options.tilePixelSize;
            ++i
        ) {
            elevations.push(0);
        }
        return elevations;
    };

    /**
     * Parse a elevation response from AAIGrid
     * @function _parseAAIGrid
     * @memberof WCSElevationLayer#
     * @param {String} text Response as text
     * @private
     */
    WCSElevationLayer.prototype._parseAAIGrid = function(text) {
        var elevations = [];
        var i;
        var lines = text.trim().split("\n");

        var dataLinesStart = 0;
        var noDATA = Number.NEGATIVE_INFINITY;
        for (i = 0; i < lines.length; ++i) {
            if (lines[i].substring(0, 1) === " ") {
                dataLinesStart = i;
                break;
            } else if (lines[i].substring(0, 1) === "NODATA_value") {
                var elt = lines[i].trim().split(/\s+/);
                noDATA = elt[1];
            }
        }

        var oldVal = Number.NEGATIVE_INFINITY;
        for (i = dataLinesStart; i < lines.length; i++) {
            var elts = lines[i].trim().split(/\s+/);
            for (var n = 0; n < elts.length; n++) {
                var elevation;
                if (isNaN(elts[n]) || elts[n] === noDATA) {
                    elevation = oldVal;
                } else {
                    elevation = parseFloat(elts[n], 10);
                    oldVal = elevation;
                }
                //var elevation = parseInt(elts[n], 10);
                if (elevation < this.options.minElevation) {
                    elevation = this.options.minElevation;
                }
                elevations.push(
                    elevation * this.options.scale * this.options.scaleData
                );
            }
        }

        return elevations;
    };

    /**
     * Get an url for the given tile
     * @function getUrl
     * @memberof WCSElevationLayer#
     * @param {Tile} tile Tile
     * @return {String} Url
     */
    WCSElevationLayer.prototype.getUrl = function(tile) {
        var geoBound = tile.geoBound;

        var url;
        if (this.allowedHTTPRequest) {
            url = this.getCoverageBaseUrl;

            if (this.options.version.substring(0, 3) === "2.0") {
                url = Utils.addParameterTo(
                    url,
                    "subset",
                    "x" +
                        this.options.crs +
                        "(" +
                        geoBound.west +
                        "," +
                        geoBound.east +
                        ")"
                );
                url = Utils.addParameterTo(
                    url,
                    "subset",
                    "y" +
                        this.options.crs +
                        "(" +
                        geoBound.south +
                        "," +
                        geoBound.north +
                        ")"
                );
            } else if (this.options.version.substring(0, 3) === "1.0") {
                url = Utils.addParameterTo(
                    url,
                    "bbox",
                    geoBound.west +
                        "," +
                        geoBound.south +
                        "," +
                        geoBound.east +
                        "," +
                        geoBound.north
                );
            }
        } else {
            url = null;
        }
        return this.proxify(url, tile.level);
    };

    WCSElevationLayer.prototype.setParameter = function(paramName, value) {
        if (this._hasToBeRefreshed(paramName, value)) {
            this.options[paramName] = this.imageLoadedAtTime[paramName];
            this.getCoverageBaseUrl = _queryImage.call(
                this,
                this.getBaseUrl(),
                this.options
            );
            this.forceRefresh();
        }
    };

    WCSElevationLayer.prototype.getScale = function() {
        return this.options.scale;
    };

    WCSElevationLayer.prototype.getScaleData = function() {
        return this.options.scaleData;
    };

    WCSElevationLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    /**************************************************************************************************************/

    return WCSElevationLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/AbstractVectorLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/FeatureStyle"
], function(Utils, AbstractLayer, Constants, FeatureStyle) {
    /**
     * AbstractVectorLayer layer configuration
     * @typedef {AbstractVectorLayer.configuration} AbstractLayer.vector_configuration
     * @property {string} url - the url of json data to load when attaching to globe
     * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
     * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
     * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
     */
    /**
     * @name AbstractVectorLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractLayer
     * @param {LAYER} type - the type of the layer
     * @param {AbstractVectorLayer.configuration} options - Configuration properties for the AbstractVectorLayer
     * @constructor
     * @implements {VectorLayer}
     */
    var AbstractVectorLayer = function(type, options) {
        this.zIndex = options.zIndex || Constants.DISPLAY.DEFAULT_VECTOR;
        AbstractLayer.prototype.constructor.call(this, type, options);

        this.vectorLayer = true;
        this.url = options.url;

        if (options && options.callback) {
            this.callback = options.callback;
        } else {
            this.callback = null;
        }

        this.minLevel =
            options && options.hasOwnProperty("minLevel")
                ? options.minLevel
                : 0;
        this.maxLevel =
            options && options.hasOwnProperty("maxLevel")
                ? options.maxLevel
                : 21;

        this.features = [];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AbstractVectorLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    }

    /**
     * Returns the min level for which the vector is displayed.
     * @function getMinLevel
     * @memberof AbstractVectorLayer#
     * @returns {int} Returns the min level for which the vector is displayed.
     */
    AbstractVectorLayer.prototype.getMinLevel = function() {
        return this.minLevel;
    };

    /**
     * Returns the max level for which the vector is not displayed.
     * @function getMaxLevel
     * @memberof AbstractVectorLayer#
     * @returns {int} Returns the max level for which the vector is not displayed.
     */
    AbstractVectorLayer.prototype.getMaxLevel = function() {
        return this.maxLevel;
    };

    /**
     * Returns the URL to get the vector data.
     * @function getUrl
     * @memberof AbstractVectorLayer#
     * @returns {String} the URL to get the vector data
     */
    AbstractVectorLayer.prototype.getUrl = function() {
        return this.proxify(this.url);
    };

    /**
     * Attach the vector layer to the globe
     * @function _attach
     * @memberof AbstractVectorLayer#
     * @param {AbstractGlobe} g globe
     * @private
     */
    AbstractVectorLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        // Add the feature to renderers
        for (var i = 0; i < this.features.length; i++) {
            this._addFeatureToRenderers(this.features[i]);
        }
    };

    /**
     * Detach the vector layer from the globe
     * @function _detach
     * @memberof AbstractVectorLayer#
     * @private
     */
    AbstractVectorLayer.prototype._detach = function() {
        // Remove feature from renderers
        for (var i = 0; i < this.features.length; i++) {
            this._removeFeatureFromRenderers(this.features[i]);
        }

        AbstractLayer.prototype._detach.call(this);
    };

    /**
     * Adds a feature collection, in GeoJSON format
     * @function addFeatureCollection
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     */
    AbstractVectorLayer.prototype.addFeatureCollection = function(
        featureCollection
    ) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.addFeature(feature[i]);
            }
        }
    };

    /**
     * Removes a feature collection, in GeoJSON format
     * @function removeFeatureCollection
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     */
    AbstractVectorLayer.prototype.removeFeatureCollection = function(
        featureCollection
    ) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.removeFeature(features[i]);
            }
        }
    };

    /**
     * Add a feature to renderers.
     * @function _addFeatureToRenderers
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     * @private
     */
    AbstractVectorLayer.prototype._addFeatureToRenderers = function(feature) {
        var geometry = feature.geometry;

        // Manage style, if undefined try with properties, otherwise use defaultStyle
        var style;
        var props = feature.properties;
        if (props && props.style) {
            style = props.style;
        } else {
            style = this.style;
        }
        style.zIndex = this.zIndex;

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            for (var i = 0; i < geoms.length; i++) {
                this.getGlobe()
                    .getRendererManager()
                    .addGeometry(this, geoms[i], style);
            }
        } else {
            // Add geometry to renderers
            this.getGlobe()
                .getRendererManager()
                .addGeometry(this, geometry, style);
        }
    };

    /**
     * Removes a feature from renderers.
     * @function _removeFeatureFromRenderers
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     * @returns {boolean} true when the feature is removed from the globe otherwise false
     * @private
     */
    AbstractVectorLayer.prototype._removeFeatureFromRenderers = function(
        feature
    ) {
        var isRemoved = true;
        var geometry = feature.geometry;

        // Manage geometry collection
        if (geometry.type === "GeometryCollection") {
            var geoms = geometry.geometries;
            if (this.getGlobe() && this.getGlobe().getRendererManager()) {
                for (var i = 0; i < geoms.length; i++) {
                    isRemoved =
                        isRemoved &&
                        this.getGlobe()
                            .getRendererManager()
                            .removeGeometry(geoms[i], this);
                }
            } else {
                isRemoved = false;
            }
        } else if (
            this.getGlobe() &&
            this.getGlobe().getRendererManager()
        ) {
            isRemoved = this.getGlobe()
                .getRendererManager()
                .removeGeometry(geometry, this);
        } else {
            isRemoved = false;
        }
        return isRemoved;
    };

    /**
     * Add a feature to the layer
     * @function addFeature
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     */
    AbstractVectorLayer.prototype.addFeature = function(feature) {
        // Check feature geometry : only add valid feature
        var geometry = feature.geometry;
        if (!geometry || !geometry.type) {
            return;
        }
        this.features.push(feature);

        // Add features to renderer if layer is attached to planet
        if (this.getGlobe()) {
            this._addFeatureToRenderers(feature);
            if (this.isVisible()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
        }
    };

    /**
     * Removes a feature from the layer.
     * @function removeFeature
     * @memberof AbstractVectorLayer#
     * @param {GeoJSON} feature Feature
     */
    AbstractVectorLayer.prototype.removeFeature = function(feature) {
        var index = this.features.indexOf(feature);
        this.features.splice(index, 1);
        if (this.getGlobe()) {
            this._removeFeatureFromRenderers(feature);
            if (this.isVisible()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
        }
    };

    /**
     * Removes all features from the layer.
     * @function removeAllFeatures
     * @memberof AbstractVectorLayer#
     */
    AbstractVectorLayer.prototype.removeAllFeatures = function() {
        // Remove feature from renderers
        if (this.getGlobe()) {
            for (var i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }
        }
        this.features.length = 0;

        // Refresh rendering if needed
        if (this.getGlobe() && this.isVisible()) {
            this.getGlobe()
                .getRenderContext()
                .requestFrame();
        }
    };

    /**
     * Modifies the feature style for a specific feature.
     * @function modifyFeatureStyle
     * @memberof AbstractVectorLayer#
     * @param {GeoJson} feature feature for which the feature style is modified
     * @param {FeatureStyle} style Feature style
     */
    AbstractVectorLayer.prototype.modifyFeatureStyle = function(
        feature,
        style
    ) {
        if (this._removeFeatureFromRenderers(feature)) {
            feature.properties.style = style;
            this._addFeatureToRenderers(feature);
        }
    };

    /**
     * Modifies the feature style for all features.
     * @function modifyStyle
     * @memberof AbstractVectorLayer#
     * @param {FeatureStyle} style Feature style
     */
    AbstractVectorLayer.prototype.modifyStyle = function(style) {
        var i;
        for (i = 0; i < this.features.length; i++) {
            this._removeFeatureFromRenderers(this.features[i]);
        }

        this.setStyle(style);

        for (i = 0; i < this.features.length; i++) {
            this._addFeatureToRenderers(this.features[i]);
        }
    };

    return AbstractVectorLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/VectorLayer',[
    "../Utils/Utils",
    "./AbstractVectorLayer",
    "../Utils/Constants"
], function(Utils, AbstractVectorLayer, Constants) {
    /**
     * Vector layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.vector_configuration
     * @property {string} url - the url of json data to load when attaching to globe
     * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
     * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
     * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
     */
    /**
     * @name VectorLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractVectorLayer
     * @param {AbstractLayer.vector_configuration} options - Vector configuration
     * @constructor
     * @memberof module:Layer
     */
    var VectorLayer = function(options) {
        AbstractVectorLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Vector,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractVectorLayer, VectorLayer);

    /**************************************************************************************************************/

    return VectorLayer;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Provider
 * @module Provider
 * @implements {Provider}
 */
define('Provider/AbstractProvider',["jquery"], function($) {
    /**************************************************************************************************************/

    /**
     * @name AbstractProvider
     * @class
     *  Abstract Provider constructor
     * @param {object} options
     * @constructor
     * @memberof module:Provider
     */
    var AbstractProvider = function(options) {
        this.options = options;
    };

    /**
     * @function loadFiles
     * @memberof Provider#
     * @abstract
     */
    AbstractProvider.prototype.loadFiles = function(layer, configuration) {};

    /**
     * @function handleFeatures
     * @memberof Provider#
     */
    AbstractProvider.prototype.handleFeatures = function(layer) {};

    /**************************************************************************************************************/

    return AbstractProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/PlanetProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Constants"
], function($, AbstractProvider, FeatureStyle, Constants) {
    var self;
    var interval;
    var poiFeatureCollection;
    var DEGS = 180 / Math.PI; // convert radians to degrees
    var RADS = Math.PI / 180; // convert degrees to radians
    var EPS = 1.0e-12; // machine error constant
    var pname = new Array(
        "Mercury",
        "Venus",
        "Sun",
        "Mars",
        "Jupiter",
        "Saturn",
        "Uranus",
        "Neptune",
        "Pluto"
    );

    function frealstr(num, width, fract) {
        var str = num.toFixed(fract);
        var len = str.length;
        var real = "";
        var i;

        for (i = 0; i < width - len; i++) {
            // append leading spaces
            real += " ";
        }

        for (i = 0; i < len; i++) {
            // append digits
            real += str.charAt(i);
        }

        return real;
    }

    /*
         * Json template for a point
         */
    function poiDesc(mizarLayer, type, name, obj) {
        var style;
        if (type === Constants.GEOMETRY.Point) {
            style = new FeatureStyle({
                iconUrl: mizarLayer.style.iconUrl,
                strokeColor: FeatureStyle.fromStringToColor(obj.color),
                fillColor: FeatureStyle.fromStringToColor(obj.color)
            });
        } else {
            style = new FeatureStyle({
                label: name,
                strokeColor: FeatureStyle.fromStringToColor(obj.color),
                fillColor: FeatureStyle.fromStringToColor(obj.color)
            });
        }
        return {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "planet" + type + "_" + name,
                coordinates: [obj.ra, obj.dec],
                crs: {
                    type: "name",
                    properties: {
                        name: Constants.CRS.Equatorial
                    }
                }
            },
            properties: {
                name: name,
                distance: frealstr(obj.rvec, 9, 6) + " AU",
                style: style
            }
        };
    }

    // right ascension, declination coordinate structure
    function Coord() {
        this.ra = parseFloat("0"); // right ascension [deg]
        this.dec = parseFloat("0"); // declination [deg]
        this.rvec = parseFloat("0"); // distance [AU]
    }

    // day number to/from J2000 (Jan 1.5, 2000)
    function day_number(y, m, d, hour, mins) {
        var h = hour + mins / 60;
        return (
            367 * y -
            Math.floor((7 * (y + Math.floor((m + 9) / 12))) / 4) +
            Math.floor((275 * m) / 9) +
            d -
            730531.5 +
            h / 24
        );
    }

    /**************************************************************************************************************/

    // orbital element structure
    function Elem() {
        this.color = ""; // color of the planet
        this.a = parseFloat("0"); // semi-major axis [AU]
        this.e = parseFloat("0"); // eccentricity of orbit
        this.i = parseFloat("0"); // inclination of orbit [deg]
        this.O = parseFloat("0"); // longitude of the ascending node [deg]
        this.w = parseFloat("0"); // longitude of perihelion [deg]
        this.L = parseFloat("0"); // mean longitude [deg]
    }

    // return the integer part of a number
    function abs_floor(x) {
        var r;
        if (x >= 0.0) {
            r = Math.floor(x);
        } else {
            r = Math.ceil(x);
        }
        return r;
    }

    // return an angle in the range 0 to 2pi radians
    function mod2pi(x) {
        var b = x / (2 * Math.PI);
        var a = 2 * Math.PI * (b - abs_floor(b));
        if (a < 0) {
            a = 2 * Math.PI + a;
        }
        return a;
    }

    // compute the true anomaly from mean anomaly using iteration
    //  M - mean anomaly in radians
    //  e - orbit eccentricity
    function true_anomaly(M, e) {
        var V, E1;

        // initial approximation of eccentric anomaly
        var E = M + e * Math.sin(M) * (1.0 + e * Math.cos(M));

        do // iterate to improve accuracy
        {
            E1 = E;
            E = E1 - (E1 - e * Math.sin(E1) - M) / (1 - e * Math.cos(E1));
        } while (Math.abs(E - E1) > EPS);

        // convert eccentric anomaly to true anomaly
        V = 2 * Math.atan(Math.sqrt((1 + e) / (1 - e)) * Math.tan(0.5 * E));

        if (V < 0) {
            V = V + 2 * Math.PI;
        } // modulo 2pi

        return V;
    }

    /**
     * Computes the elements of the orbit for planet-i at day number-d
     * @param p - result
     * @param i - planet-i
     * @param d - day number
     * @throws {RangeError} function mean_elements() failed!
     */
    function mean_elements(p, i, d) {
        var cy = d / 36525; // centuries since J2000

        switch (i) {
            case 0: // Mercury
                p.color = "rgb(170,150,170)";
                p.a = 0.38709893 + 0.00000066 * cy;
                p.e = 0.20563069 + 0.00002527 * cy;
                p.i = (7.00487 - (23.51 * cy) / 3600) * RADS;
                p.O = (48.33167 - (446.3 * cy) / 3600) * RADS;
                p.w = (77.45645 + (573.57 * cy) / 3600) * RADS;
                p.L = mod2pi((252.25084 + (538101628.29 * cy) / 3600) * RADS);
                break;
            case 1: // Venus
                p.color = "rgb(245,222,179)";
                p.a = 0.72333199 + 0.00000092 * cy;
                p.e = 0.00677323 - 0.00004938 * cy;
                p.i = (3.39471 - (2.86 * cy) / 3600) * RADS;
                p.O = (76.68069 - (996.89 * cy) / 3600) * RADS;
                p.w = (131.53298 - (108.8 * cy) / 3600) * RADS;
                p.L = mod2pi((181.97973 + (210664136.06 * cy) / 3600) * RADS);
                break;
            case 2: // Earth/Sun
                p.color = "rgb(255,193,37)";
                p.a = 1.00000011 - 0.00000005 * cy;
                p.e = 0.01671022 - 0.00003804 * cy;
                p.i = (0.00005 - (46.94 * cy) / 3600) * RADS;
                p.O = (-11.26064 - (18228.25 * cy) / 3600) * RADS;
                p.w = (102.94719 + (1198.28 * cy) / 3600) * RADS;
                p.L = mod2pi((100.46435 + (129597740.63 * cy) / 3600) * RADS);
                break;
            case 3: // Mars
                p.color = "rgb(255,50,50)";
                p.a = 1.52366231 - 0.00007221 * cy;
                p.e = 0.09341233 + 0.00011902 * cy;
                p.i = (1.85061 - (25.47 * cy) / 3600) * RADS;
                p.O = (49.57854 - (1020.19 * cy) / 3600) * RADS;
                p.w = (336.04084 + (1560.78 * cy) / 3600) * RADS;
                p.L = mod2pi((355.45332 + (68905103.78 * cy) / 3600) * RADS);
                break;
            case 4: // Jupiter
                p.color = "rgb(255,150,150)";
                p.a = 5.20336301 + 0.00060737 * cy;
                p.e = 0.04839266 - 0.0001288 * cy;
                p.i = (1.3053 - (4.15 * cy) / 3600) * RADS;
                p.O = (100.55615 + (1217.17 * cy) / 3600) * RADS;
                p.w = (14.75385 + (839.93 * cy) / 3600) * RADS;
                p.L = mod2pi((34.40438 + (10925078.35 * cy) / 3600) * RADS);
                break;
            case 5: // Saturn
                p.color = "rgb(200,150,150)";
                p.a = 9.53707032 - 0.0030153 * cy;
                p.e = 0.0541506 - 0.00036762 * cy;
                p.i = (2.48446 + (6.11 * cy) / 3600) * RADS;
                p.O = (113.71504 - (1591.05 * cy) / 3600) * RADS;
                p.w = (92.43194 - (1948.89 * cy) / 3600) * RADS;
                p.L = mod2pi((49.94432 + (4401052.95 * cy) / 3600) * RADS);
                break;
            case 6: // Uranus
                p.color = "rgb(130,150,255)";
                p.a = 19.19126393 + 0.00152025 * cy;
                p.e = 0.04716771 - 0.0001915 * cy;
                p.i = (0.76986 - (2.09 * cy) / 3600) * RADS;
                p.O = (74.22988 - (1681.4 * cy) / 3600) * RADS;
                p.w = (170.96424 + (1312.56 * cy) / 3600) * RADS;
                p.L = mod2pi((313.23218 + (1542547.79 * cy) / 3600) * RADS);
                break;
            case 7: // Neptune
                p.color = "rgb(100,100,255)";
                p.a = 30.06896348 - 0.00125196 * cy;
                p.e = 0.00858587 + 0.0000251 * cy;
                p.i = (1.76917 - (3.64 * cy) / 3600) * RADS;
                p.O = (131.72169 - (151.25 * cy) / 3600) * RADS;
                p.w = (44.97135 - (844.43 * cy) / 3600) * RADS;
                p.L = mod2pi((304.88003 + (786449.21 * cy) / 3600) * RADS);
                break;
            case 8: // Pluto
                p.color = "rgb(100,100,255)";
                p.a = 39.48168677 - 0.00076912 * cy;
                p.e = 0.24880766 + 0.00006465 * cy;
                p.i = (17.14175 + (11.07 * cy) / 3600) * RADS;
                p.O = (110.30347 - (37.33 * cy) / 3600) * RADS;
                p.w = (224.06676 - (132.25 * cy) / 3600) * RADS;
                p.L = mod2pi((238.92881 + (522747.9 * cy) / 3600) * RADS);
                break;
            default:
                throw RangeError(
                    "function mean_elements() failed!",
                    "PlanetProvider.js"
                );
        }
    }

    // compute RA, DEC, and distance of planet-p for day number-d
    // result returned in structure obj in degrees and astronomical units
    function get_coord(obj, p, d) {
        var planet = new Elem();
        mean_elements(planet, p, d);
        var ap = planet.a;
        var ep = planet.e;
        var ip = planet.i;
        var op = planet.O;
        var pp = planet.w;
        var lp = planet.L;

        var earth = new Elem();
        mean_elements(earth, 2, d);
        var ae = earth.a;
        var ee = earth.e;
        //var ie = earth.i;
        //var oe = earth.O;
        var pe = earth.w;
        var le = earth.L;

        // position of Earth in its orbit
        var me = mod2pi(le - pe);
        var ve = true_anomaly(me, ee);
        var re = (ae * (1 - ee * ee)) / (1 + ee * Math.cos(ve));

        // heliocentric rectangular coordinates of Earth
        var xe = re * Math.cos(ve + pe);
        var ye = re * Math.sin(ve + pe);
        var ze = 0.0;

        // position of planet in its orbit
        var mp = mod2pi(lp - pp);
        var vp = true_anomaly(mp, planet.e);
        var rp = (ap * (1 - ep * ep)) / (1 + ep * Math.cos(vp));

        // heliocentric rectangular coordinates of planet
        var xh =
            rp *
            (Math.cos(op) * Math.cos(vp + pp - op) -
                Math.sin(op) * Math.sin(vp + pp - op) * Math.cos(ip));
        var yh =
            rp *
            (Math.sin(op) * Math.cos(vp + pp - op) +
                Math.cos(op) * Math.sin(vp + pp - op) * Math.cos(ip));
        var zh = rp * (Math.sin(vp + pp - op) * Math.sin(ip));

        if (p === 2) {
            // earth --> compute sun
            xh = 0;
            yh = 0;
            zh = 0;
        }

        // convert to geocentric rectangular coordinates
        var xg = xh - xe;
        var yg = yh - ye;
        var zg = zh - ze;

        // rotate around x axis from ecliptic to equatorial coords
        var ecl = 23.439281 * RADS; //value for J2000.0 frame
        var xeq = xg;
        var yeq = yg * Math.cos(ecl) - zg * Math.sin(ecl);
        var zeq = yg * Math.sin(ecl) + zg * Math.cos(ecl);

        // find the RA and DEC from the rectangular equatorial coords
        obj.ra = mod2pi(Math.atan2(yeq, xeq)) * DEGS;
        obj.dec = Math.atan(zeq / Math.sqrt(xeq * xeq + yeq * yeq)) * DEGS;
        obj.rvec = Math.sqrt(xeq * xeq + yeq * yeq + zeq * zeq);
        obj.color = planet.color;
    }

    /**
     *    Handle features on layer
     */
    var computePositions = function(mizarLayer) {
        var pois = [];
        var now = new Date();
        var year = now.getUTCFullYear();
        var month = now.getUTCMonth() + 1;
        var day = now.getUTCDate();
        var hour = now.getUTCHours();
        var mins = now.getUTCMinutes();
        var secs = now.getUTCSeconds();

        // compute day number for date/time
        var dn = day_number(year, month, day, hour, mins + secs / 60);
        var obj = new Coord();
        // compute location of objects
        for (var p = 0; p < 9; p++) {
            get_coord(obj, p, dn);
            // Add label
            var poi_label = poiDesc(mizarLayer, "Label", pname[p], obj);
            pois.push(poi_label);

            // Add point itself
            var poi_point = poiDesc(
                mizarLayer,
                Constants.GEOMETRY.Point,
                pname[p],
                obj
            );
            pois.push(poi_point);
        }

        // Create feature collection
        poiFeatureCollection = {
            type: "FeatureCollection",
            features: pois
        };

        mizarLayer.addFeatureCollection(poiFeatureCollection);
    };

    /**************************************************************************************************************/

    /**
     * @name PlanetProvider
     * @class
     *    Providing planet positions based on ephemeris computations
     * @param {Object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     * @see http://www.abecedarical.com/javascript/script_planet_orbits.html
     */

    var PlanetProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**
     * Loads files
     * @param {Layer} layer - Mizar layer
     * @param {Object} configuration - configuration
     * @param {int} [configuration.interval = 60000] - Recomputes planet position every minute if not defined
     * @memberof PlanetProvider#
     */
    PlanetProvider.prototype.loadFiles = function(layer, configuration) {
        interval = configuration.interval ? configuration.interval : 60000;
        self.handleFeatures(layer);
    };

    /**
     * Calculate planets position and add them to the passed layer
     * @function handleFeatures
     * @memberof PlanetProvider#
     * @param {Layer} layer
     */
    PlanetProvider.prototype.handleFeatures = function(layer) {
        computePositions(layer);
        setInterval(function() {
            layer.removeFeatureCollection(poiFeatureCollection);
            computePositions(layer);
        }, interval);
    };

    PlanetProvider.prototype.getSunPosition = function(date) {
        var year = date.getUTCFullYear();
        var month = date.getUTCMonth() + 1;
        var day = date.getUTCDate();
        var hour = date.getUTCHours();
        var mins = date.getUTCMinutes();
        var secs = date.getUTCSeconds();
        // compute day number for date/time
        var dn = day_number(year, month, day, hour, mins + secs / 60);
        var obj = new Coord();
        get_coord(obj, 2, dn);
        return obj;
    };

    return PlanetProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * A layer is an information that can be superimposed on another information.
 * <img src="../doc/images/gis_layers.gif">
 * It exists different natures of layer,
 * which are listed as below :
 * <ul>
 *     <li>{@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.</li>
 *     <li>{@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.</li>
 *     <li>{@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky</li>
 *     <li>{@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe</li>
 *     <li>{@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain</li>
 *     <li>{@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue</li>
 *     <li>{@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits</li>
 *     <li>{@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG</li>
 *     <li>{@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index</li>
 *     <li>{@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service</li>
 *     <li>{@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server</li>
 *     <li>{@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet</li>
 *     <li>{@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector</li>
 *     <li>{@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server</li>
 *     <li>{@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server</li>
 * </ul>
 * <br/>
 * In addition to the classes, a {@link module:Layer.LayerFactory factory} is available to help for creating layer.
 * Once the layer is created, the client can handle it by the use of its {@link Layer interface}.
 * @implements {Layer}
 * @module Layer
 */
define('Layer/AtmosphereLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Provider/PlanetProvider",
    "../Renderer/Program",
    "../Time/Time"
], function(Utils, AbstractLayer, Constants, PlanetProvider, Program, Time) {
    /**
     * Atmosphere layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.atmosphere_configuration
     * @property {float} [kr=0.0025] the rayleigh parameter
     * @property {float} [km=0.0015] the mie parameter
     * @property {float} [sunBrightness=15] The Sun brightness
     * @property {float} [exposure=2.0] the exposure, use for basic high dynamic range
     * @property {float[]} [wavelength=[0.650, 0.570, 0.475]] the RGB color of the sun
     * @property {float[]} [lightDir=[1, 0, 0]] The location of the light in (x,y,z)
     */

    /**
     * @name AtmosphereLayer
     * @class
     * Creates an atmosphere on the planet.
     * @augments AbstractLayer
     * @param {AbstractLayer.atmosphere_configuration} options - Atmosphere configuration.
     * @constructor
     * @memberof module:Layer
     */
    var AtmosphereLayer = function(options) {
        var currentDate = new Date();
        var tomorrow = new Date();
        tomorrow.setDate(currentDate.getDate() + 1);
        options.dimension = {
            time: {
                units: "ISO8601",
                unitSymbol: null,
                default: null,
                multipleValues: null,
                nearestValue: null,
                current: null,
                value:
                    currentDate.toISOString() +
                    "/" +
                    tomorrow.toISOString() +
                    "/PT1H"
            }
        };
        // For rendering
        options.zIndex = Constants.DISPLAY.RENDERING;

        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Atmosphere,
            options
        );
        if (!this.name) {
            this.name = "Atmosphere";
        }
        this.kr = (options && options.kr) || 0.0025;
        this.km = (options && options.km) || 0.0015;
        this.sunBrightness = (options && options.sunBrightness) || 15.0;
        this.exposure = (options && options.exposure) || 2.0;
        this.wavelength = (options && options.wavelength) || [
            0.65,
            0.57,
            0.475
        ];
        this.lightDir =
            (options && options.lightDir) ||
            _computeLightDir.call(this, new Date());

        // internal properties
        this._skyProgram = null;
        this._groundProgram = null;
        this._originalProgram = null;
        this._isValid = false;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AtmosphereLayer);

    /**************************************************************************************************************/

    /**
     * Computes light direction
     * @param date date
     * @returns {number[]} [x, y, z]
     * @private
     */
    function _computeLightDir(date) {
        var sunProvider = new PlanetProvider();
        var sunPosition = sunProvider.getSunPosition(date);
        var latitude = sunPosition.dec;
        var longitude = -Utils.GHA(date, sunPosition.ra);
        var coords = Utils.longLat2XYZ(longitude, latitude);
        return [coords.x, coords.y, coords.z];
    }

    /**
     * @function getInformationType
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.ATMOSPHERE;
    }    

    /**
     * Attaches the atmosphere layer to the planet.
     * @function _attach
     * @memberof AtmosphereLayer#
     * @param {Planet} g Planet
     * @private
     */
    AtmosphereLayer.prototype._attach = function(g) {
        this.globe = g;
        this._innerRadius = this.getGlobe()
            .getCoordinateSystem()
            .getGeoide()
            .getRadius();
        this._outerRadius = this._innerRadius * 1.005;
        var renderContext = g.getRenderContext();

        // Setup program, uniform now that we have the render context

        this._skyFromSpaceProgram = new Program(renderContext);
        this._skyFromSpaceProgram.loadFromFile(
            "SkyFromSpaceVert.glsl",
            "SkyFrag.glsl"
        );
        this._skyFromAtmosphereProgram = new Program(renderContext);
        this._skyFromAtmosphereProgram.loadFromFile(
            "SkyFromAtmosphereVert.glsl",
            "SkyFrag.glsl"
        );

        this._groundFromSpaceProgram = new Program(renderContext);
        this._groundFromSpaceProgram.loadFromFile(
            "GroundFromSpaceVert.glsl",
            "GroundFrag.glsl"
        );

        this._groundFromAtmosphereProgram = new Program(renderContext);
        this._groundFromAtmosphereProgram.loadFromFile(
            "GroundFromAtmosphereVert.glsl",
            "GroundFrag.glsl"
        );

        // Check if the atmosphre is valid : all programs must be OK
        this._isValid =
            this._skyFromSpaceProgram.glProgram !== null &&
            this._skyFromAtmosphereProgram.glProgram !== null &&
            this._groundFromSpaceProgram.glProgram !== null &&
            this._groundFromAtmosphereProgram.glProgram !== null;

        if (!this._isValid) {
            return;
        }
        this._skyFromSpaceProgram.apply();
        this._initUniforms(this._skyFromSpaceProgram.uniforms);
        this._skyFromAtmosphereProgram.apply();
        this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
        this._groundFromSpaceProgram.apply();
        this._initUniforms(this._groundFromSpaceProgram.uniforms);
        this._groundFromAtmosphereProgram.apply();
        this._initUniforms(this._groundFromAtmosphereProgram.uniforms);

        // Create the sphere
        var vertices = [];
        var indices = [];

        var nbEl = 72;
        var nbAz = 144;

        // Create the vertices
        var el;
        var az;
        for (el = -nbEl; el <= nbEl; el++) {
            var elevation = (el * (Math.PI * 0.5)) / nbEl;
            for (az = -nbAz; az <= nbAz; az++) {
                var azimuth = (az * Math.PI) / nbAz;

                var x =
                    this._outerRadius * Math.cos(azimuth) * Math.cos(elevation);
                var y =
                    this._outerRadius * Math.sin(azimuth) * Math.cos(elevation);
                var z = this._outerRadius * Math.sin(elevation);

                vertices.push(x);
                vertices.push(y);
                vertices.push(z);
            }
        }

        // build the sphere triangles
        for (el = 0; el < 2 * nbEl; el++) {
            for (az = 0; az < 2 * nbAz; az++) {
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az + 1);

                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az);
            }
        }

        var gl = renderContext.gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
        );

        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );
        this._numIndices = indices.length;

        this._originalProgram = g.getTileManager().program;

        g.preRenderers.push(this);
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Initializes uniforms.
     * @function _initUniforms
     * @memberof AtmosphereLayer#
     * @param uniforms
     * @private
     */
    AtmosphereLayer.prototype._initUniforms = function(uniforms) {
        var gl = this.getGlobe().getRenderContext().gl;

        var g = -0.95; // The Mie phase asymmetry factor
        var scale = 1.0 / (this._outerRadius - this._innerRadius);
        var rayleighScaleDepth = 0.25;
        //var mieScaleDepth = 0.1;

        vec3.normalize(this.lightDir);

        gl.uniform1f(uniforms.fKrESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKmESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKr4PI, this.kr * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fKm4PI, this.km * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fExposure, this.exposure);

        var wavelength = [
            Math.pow(this.wavelength[0], 4.0),
            Math.pow(this.wavelength[1], 4.0),
            Math.pow(this.wavelength[2], 4.0)
        ];
        gl.uniform3f(
            uniforms.v3InvWavelength,
            1.0 / wavelength[0],
            1.0 / wavelength[1],
            1.0 / wavelength[2]
        );

        gl.uniform3f(
            uniforms.v3LightPos,
            this.lightDir[0],
            this.lightDir[1],
            this.lightDir[2]
        );
        gl.uniform1f(uniforms.fInnerRadius, this._innerRadius);
        gl.uniform1f(
            uniforms.fInnerRadius2,
            this._innerRadius * this._innerRadius
        );
        gl.uniform1f(uniforms.fOuterRadius, this._outerRadius);
        gl.uniform1f(
            uniforms.fOuterRadius2,
            this._outerRadius * this._outerRadius
        );
        gl.uniform1f(uniforms.fScale, scale);
        gl.uniform1f(uniforms.fScaleDepth, rayleighScaleDepth);
        gl.uniform1f(uniforms.fScaleOverScaleDepth, scale / rayleighScaleDepth);
        gl.uniform1f(uniforms.g, g);
        gl.uniform1f(uniforms.g2, g * g);
    };

    /**************************************************************************************************************/

    /**
     * Pre-rendesr the atmoshpere.
     * @function preRender
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.preRender = function() {
        if (!this._isValid) {
            return;
        }
        var tileManager = this.getGlobe().getTileManager();
        if (!this.isVisible()) {
            tileManager.program = this._originalProgram;
            return;
        }

        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;
        var x, y, z;

        // Compute the eye position from the view matrix : the eye position is equals to [0,0,0] * inv(viewMatrix)
        // Optimized to avoid to compute the view matrix inverse
        var vm = rc.viewMatrix;
        x = vm[12];
        y = vm[13];
        z = vm[14];
        var eyePos = [
            -(vm[0] * x + vm[1] * y + vm[2] * z),
            -(vm[4] * x + vm[5] * y + vm[6] * z),
            -(vm[8] * x + vm[9] * y + vm[10] * z)
        ];
        var eyeHeight = vec3.length(eyePos);

        this._skyProgram =
            eyeHeight < this._outerRadius
                ? this._skyFromAtmosphereProgram
                : this._skyFromSpaceProgram;
        this._groundProgram =
            eyeHeight < this._outerRadius
                ? this._groundFromAtmosphereProgram
                : this._groundFromSpaceProgram;

        this._skyProgram.apply();

        gl.uniform3f(
            this._skyProgram.uniforms.v3CameraPos,
            eyePos[0],
            eyePos[1],
            eyePos[2]
        );
        gl.uniform1f(
            this._skyProgram.uniforms.fCameraHeight2,
            eyeHeight * eyeHeight
        );
        gl.uniform1f(this._skyProgram.uniforms.fCameraHeight, eyeHeight);

        this._groundProgram.apply();

        var earthCenter = [0.0, 0.0, 0.0];
        mat4.multiplyVec3(rc.viewMatrix, earthCenter);
        gl.uniform3f(
            this._groundProgram.uniforms.earthCenter,
            earthCenter[0],
            earthCenter[1],
            earthCenter[2]
        );

        vec3.normalize(this.lightDir);
        x = this.lightDir[0];
        y = this.lightDir[1];
        z = this.lightDir[2];
        var mat = rc.viewMatrix;
        var lightDirUpdated = [];
        lightDirUpdated[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        lightDirUpdated[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        lightDirUpdated[2] = mat[2] * x + mat[6] * y + mat[10] * z;
        gl.uniform3f(
            this._groundProgram.uniforms.lightDir,
            lightDirUpdated[0],
            lightDirUpdated[1],
            lightDirUpdated[2]
        );

        gl.uniform3f(
            this._groundProgram.uniforms.v3CameraPos,
            eyePos[0],
            eyePos[1],
            eyePos[2]
        );
        gl.uniform1f(
            this._groundProgram.uniforms.fCameraHeight2,
            eyeHeight * eyeHeight
        );
        gl.uniform1f(this._groundProgram.uniforms.fCameraHeight, eyeHeight);

        tileManager.program = this._groundProgram;

        //	rc.minFar = 2.0;
    };

    /**************************************************************************************************************/

    /**
     * Renders the atmosphere.
     * @function render
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.render = function() {
        if (!this._isValid || !this.isVisible() || !this.getGlobe()) {
            return;
        }
        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;

        gl.enable(gl.CULL_FACE);

        this._skyProgram.apply();

        gl.uniformMatrix4fv(
            this._skyProgram.uniforms.projectionMatrix,
            false,
            rc.projectionMatrix
        );
        gl.uniformMatrix4fv(
            this._skyProgram.uniforms.viewMatrix,
            false,
            rc.viewMatrix
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(
            this._skyProgram.attributes.vertex,
            3,
            gl.FLOAT,
            false,
            0,
            0
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLES, this._numIndices, gl.UNSIGNED_SHORT, 0);

        gl.disable(gl.CULL_FACE);
    };

    AtmosphereLayer.prototype.setTime = function(time) {
        AbstractLayer.prototype.setTime(time);
        this.setParameter("time", time);
    };

    AtmosphereLayer.prototype.setParameter = function(param, value) {
        if (param === "time") {
            var time = Time.parse(value);
            var date = new Date(time.date);
            this.lightDir = _computeLightDir.call(this, date);
            this._skyFromSpaceProgram.apply();
            this._initUniforms(this._skyFromSpaceProgram.uniforms);
            this._skyFromAtmosphereProgram.apply();
            this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
            this._groundFromSpaceProgram.apply();
            this._initUniforms(this._groundFromSpaceProgram.uniforms);
            this._groundFromAtmosphereProgram.apply();
            this._initUniforms(this._groundFromAtmosphereProgram.uniforms);
            this.forceRefresh();
        }
    };

    /**************************************************************************************************************/

    return AtmosphereLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/MercatorTiling',["./Tile", "../Renderer/GeoBound", "./GeoTiling"], function(
    Tile,
    GeoBound,
    GeoTiling
) {
    var lon2merc = function(lon) {
        return (lon * 20037508.34) / 180;
    };

    var lat2merc = function(lat) {
        var y =
            Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);
        return (y * 20037508.34) / 180;
    };

    var tile2long = function(x, z) {
        return (x / Math.pow(2, z)) * 360 - 180;
    };

    var tile2lat = function(y, z) {
        var n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
        return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    };

    /**************************************************************************************************************/

    /** @constructor
       Tile constructor
       */
    var MercatorTile = function(level, x, y) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);

        this.level = level;
        this.x = x;
        this.y = y;

        this.geoBound = new GeoBound(
            tile2long(x, level),
            tile2lat(y + 1, level),
            tile2long(x + 1, level),
            tile2lat(y, level)
        );
        this.bound = new GeoBound(
            lon2merc(this.geoBound.west),
            lat2merc(this.geoBound.south),
            lon2merc(this.geoBound.east),
            lat2merc(this.geoBound.north)
        );
    };

    /**************************************************************************************************************/

    /** Inhertis from tile */
    MercatorTile.prototype = new Tile();

    /**************************************************************************************************************/

    /** @export
       Get elevation at a geo position
       */
    MercatorTile.prototype.getElevation = function(lon, lat) {
        // TODO
        return 0.0;
    };

    /**************************************************************************************************************/

    /**
       Create the children
       */
    MercatorTile.prototype.createChildren = function() {
        // Create the children
        var tile00 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y);
        var tile10 = new MercatorTile(
            this.level + 1,
            2 * this.x + 1,
            2 * this.y
        );
        var tile01 = new MercatorTile(
            this.level + 1,
            2 * this.x,
            2 * this.y + 1
        );
        var tile11 = new MercatorTile(
            this.level + 1,
            2 * this.x + 1,
            2 * this.y + 1
        );

        tile00.initFromParent(this, 0, 0);
        tile10.initFromParent(this, 1, 0);
        tile01.initFromParent(this, 0, 1);
        tile11.initFromParent(this, 1, 1);

        this.children = [tile00, tile10, tile01, tile11];
    };

    /**************************************************************************************************************/

    /**
       Convert coordinates in longitude,latitude to coordinate in "tile space"
       Tile space means coordinates are between [0,tesselation-1] if inside the tile
       Used by renderers algorithm to clamp coordinates on the tile
       */
    MercatorTile.prototype.lonlat2tile = function(coordinates) {
        var tpl = Math.pow(2, this.level);
        var factor = this.config.tesselation - 1;

        var tileCoords = [];
        for (var i = 0; i < coordinates.length; i++) {
            var x = (coordinates[i][0] + 180.0) / 360.0;
            var sinLat = Math.sin((coordinates[i][1] * Math.PI) / 180.0);
            var y =
                0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4.0 * Math.PI);

            tileCoords.push([
                factor * (x * tpl - this.x),
                factor * (y * tpl - this.y)
            ]);
        }

        return tileCoords;
    };

    /**************************************************************************************************************/

    /**
       Generate vertices for tile
       */
    MercatorTile.prototype.generateVertices = function(elevations) {
        // Compute tile matrix
        this.matrix = this.config.coordinateSystem.getLHVTransform(
            this.geoBound.getCenter()
        );
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Build the vertices
        var size = this.config.tesselation;
        var vertices = new Float32Array(3 * size * (size + 6));
        var step = 1.0 / (size - 1);
        var radius = this.config.coordinateSystem.geoide.radius;
        var scale = this.config.coordinateSystem.geoide.heightScale;
        var offset = 0;

        var twoPowLevel = Math.pow(2, this.level);
        var pos3d = [0.0, 0.0, 0.0];
        var v = this.y;
        for (var j = 0; j < size; j++) {
            var n = Math.PI * (1.0 - (2.0 * v) / twoPowLevel);
            var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
            lat = (lat * 180) / Math.PI;

            var cosLat = Math.cos(lat);
            var sinLat = Math.sin(lat);

            var u = this.x;

            for (var i = 0; i < size; i++) {
                var lon = 180 * ((2.0 * u) / twoPowLevel - 1.0);
                var height = elevations ? scale * elevations[offset] : 0.0;

                this.config.coordinateSystem.fromGeoTo3D(
                    [lon, lat, height],
                    pos3d
                );
                var x = pos3d[0];
                var y = pos3d[1];
                var z = pos3d[2];

                var vertexOffset = offset * 3;
                vertices[vertexOffset] =
                    invMatrix[0] * x +
                    invMatrix[4] * y +
                    invMatrix[8] * z +
                    invMatrix[12];
                vertices[vertexOffset + 1] =
                    invMatrix[1] * x +
                    invMatrix[5] * y +
                    invMatrix[9] * z +
                    invMatrix[13];
                vertices[vertexOffset + 2] =
                    invMatrix[2] * x +
                    invMatrix[6] * y +
                    invMatrix[10] * z +
                    invMatrix[14];

                offset++;
                u += step;
            }

            v += step;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /**
       Override buildSkirtVertices for mercator.
       Use skirt to "fill" the pole
       */
    MercatorTile.prototype.buildSkirtVertices = function(
        center,
        srcOffset,
        srcStep,
        dstOffset
    ) {
        var size = this.config.tesselation;
        var vertexSize = this.config.vertexSize;
        var numTilesY = Math.pow(2, this.level);

        // Check if the tile is at the north (isTop) or south (isBottom) pole
        var isTop = this.y === 0 && dstOffset === vertexSize * (size * size);
        var isBottom =
            this.y === numTilesY - 1 &&
            dstOffset === vertexSize * ((size + 1) * size);

        if (isTop || isBottom) {
            var vertices = this.vertices;

            var pt = this.config.coordinateSystem.fromGeoTo3D(
                isTop ? [0.0, 90.0, 0.0] : [0.0, -90.0, 0.0]
            );
            mat4.multiplyVec3(this.inverseMatrix, pt);

            for (var i = 0; i < size; i++) {
                vertices[dstOffset] = pt[0];
                vertices[dstOffset + 1] = pt[1];
                vertices[dstOffset + 2] = pt[2];

                for (var n = 3; n < vertexSize; n++) {
                    vertices[dstOffset + n] = vertices[srcOffset + n];
                }

                dstOffset += vertexSize;
            }

            // Recompute the bbox to have correct culling
            //this.bbox.compute(this.vertices,dstOffset + vertexSize*size,vertexSize);
            //this.radius = this.bbox.getRadius();
        } else {
            Tile.prototype.buildSkirtVertices.call(
                this,
                center,
                srcOffset,
                srcStep,
                dstOffset
            );
        }
    };

    /**************************************************************************************************************/

    /**
     MercatorTiling constructor
     @constructor
     */
    var MercatorTiling = function(startLevel) {
        this.startLevel = startLevel;
        this.level0NumTilesX = Math.pow(2, this.startLevel);
    };

    /** inherits from geotiling */
    MercatorTiling.prototype = new GeoTiling();

    /**************************************************************************************************************/

    /**
     Generate the tiles for level zero
     */
    MercatorTiling.prototype.generateLevelZeroTiles = function(config) {
        config.skirt = !config.coordinateSystem.isFlat();
        config.cullSign = 1;
        config.srs = "EPSG:3857";
        config.project = function(coord) {
            return [lon2merc(coord[0]), lat2merc(coord[1])];
        };

        var level0Tiles = [];

        var level0NumTilesX = Math.pow(2, this.startLevel);
        var level0NumTilesY = Math.pow(2, this.startLevel);

        for (var j = 0; j < level0NumTilesY; j++) {
            for (var i = 0; i < level0NumTilesX; i++) {
                var tile = new MercatorTile(this.startLevel, i, j);
                tile.config = config;
                level0Tiles.push(tile);
            }
        }

        return level0Tiles;
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lon2LevelZeroIndex = function(lon) {
        var x = (lon + 180) / 360;
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(x * this.level0NumTilesX)
        );
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lat2LevelZeroIndex = function(lat) {
        var sinLatitude = Math.sin((lat * Math.PI) / 180);
        var y =
            0.5 -
            Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
        return Math.min(
            this.level0NumTilesX - 1,
            Math.floor(y * this.level0NumTilesX)
        );
    };

    /**************************************************************************************************************/

    return MercatorTiling;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/BingLayer',[
    "../Utils/Utils",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/MercatorTiling"
], function(Utils, AbstractRasterLayer, Constants, MercatorTiling) {
    /**************************************************************************************************************/
    var BingTileSystem = (function() {
        var EarthRadius = 6378137;
        var MinLatitude = -85.05112878;
        var MaxLatitude = 85.05112878;
        var MinLongitude = -180;
        var MaxLongitude = 180;

        /**
         * Clips a number to the specified minimum and maximum values.
         * @param n - The number to clip.
         * @param minValue - Minimum allowable value.
         * @param maxValue - Maximum allowable value.
         * @returns {number} The clipped value.
         * @private
         * @constructor
         */
        function Clip(n, minValue, maxValue) {
            return Math.min(Math.max(n, minValue), maxValue);
        }

        /**
         * Determines the map width and height (in pixels) at a specified level of detail.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number} The map width and height in pixels.
         * @constructor
         * @private
         */
        function MapSize(levelOfDetail) {
            return 256 << levelOfDetail;
        }

        /**
         * Determines the ground resolution (in meters per pixel) at a specified
         * latitude and level of detail.
         * @param latitude - Latitude (in degrees) at which to measure the ground resolution
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number}
         * @constructor
         */
        function GroundResolution(latitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            return (
                (Math.cos((latitude * Math.PI) / 180.0) *
                    2.0 *
                    Math.PI *
                    EarthRadius) /
                MapSize(levelOfDetail)
            );
        }

        /**
         * Determines the map scale at a specified latitude, level of detail, and screen resolution.
         * @param latitude - Latitude (in degrees) at which to measure the map scale.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @param screenDpi - Resolution of the screen, in dots per inch.
         * @returns {number} The map scale, expressed as the denominator N of the ratio 1 : N.
         * @constructor
         * @private
         */
        function MapScale(latitude, levelOfDetail, screenDpi) {
            return (
                (GroundResolution(latitude, levelOfDetail) * screenDpi) / 0.0254
            );
        }

        /**
         * Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
         * into pixel XY coordinates at a specified level of detail.
         * @param latitude - Latitude of the point, in degrees
         * @param longitude - Longitude of the point, in degrees
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the X coordinate in pixels, Output parameter receiving the Y coordinate in pixels]
         * @constructor
         */
        function LatLongToPixelXY(latitude, longitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            longitude = Clip(longitude, MinLongitude, MaxLongitude);

            var x = (longitude + 180) / 360;
            var sinLatitude = Math.sin((latitude * Math.PI) / 180);
            var y =
                0.5 -
                Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);

            var mapSize = MapSize(levelOfDetail);
            var pixelX = Clip(x * mapSize + 0.5, 0, mapSize - 1);
            var pixelY = Clip(y * mapSize + 0.5, 0, mapSize - 1);

            return [Math.floor(pixelX), Math.floor(pixelY)];
        }

        /**
         * Converts a pixel from pixel XY coordinates at a specified level of detail
         * into latitude/longitude WGS-84 coordinates (in degrees).
         * @param pixelX - X coordinate of the point, in pixels
         * @param pixelY - Y coordinates of the point, in pixels
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the latitude in degrees, Output parameter receiving the longitude in degrees]
         * @constructor
         */
        function PixelXYToLatLong(pixelX, pixelY, levelOfDetail) {
            var mapSize = MapSize(levelOfDetail);
            var x = Clip(pixelX, 0, mapSize - 1) / mapSize - 0.5;
            var y = 0.5 - Clip(pixelY, 0, mapSize - 1) / mapSize;

            var latitude =
                90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
            var longitude = 360 * x;

            return [latitude, longitude];
        }

        /**
         * Converts pixel XY coordinates into tile XY coordinates of the tile containing the specified pixel.
         * @param pixelXY [Pixel X coordinate, Pixel Y coordinate]
         * @returns {float[]} [Output parameter receiving the tile X coordinate, Output parameter receiving the tile Y coordinate]
         * @constructor
         */
        function PixelXYToTileXY(pixelXY) {
            return [pixelXY[0] / 256, pixelXY[1] / 256];
        }

        /**
         * Converts tile XY coordinates into pixel XY coordinates of the upper-left pixel of the specified tile.
         * @param tileXY [Tile X coordinate, Tile Y coordinate.]
         * @returns {float[]} [Output parameter receiving the pixel X coordinate,  Output parameter receiving the pixel Y coordinate]
         * @constructor
         */
        function TileXYToPixelXY(tileXY) {
            return [tileXY[0] * 256, tileXY[1] * 256];
        }

        /**
         * Converts tile XY coordinates into a QuadKey at a specified level of detail.
         * @param tileX - Tile X coordinate
         * @param tileY - Tile Y coordinate
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {string} A string containing the QuadKey
         * @constructor
         * @private
         */
        function TileXYToQuadKey(tileX, tileY, levelOfDetail) {
            var quadKey = "";
            for (var i = levelOfDetail; i > 0; i--) {
                var digit = "0";
                var mask = 1 << (i - 1);
                if ((tileX & mask) !== 0) {
                    digit++;
                }
                if ((tileY & mask) !== 0) {
                    digit++;
                    digit++;
                }
                quadKey += digit;
            }
            return quadKey;
        }

        /**
         * Converts a QuadKey into tile XY coordinates.
         * @param quadKey - QuadKey of the tile
         * @constructor
         */
        function QuadKeyToTileXY(quadKey) {
            var tileX = 0,
                tileY = 0;
            var levelOfDetail = quadKey.length();
            for (var i = levelOfDetail; i > 0; i--) {
                var mask = 1 << (i - 1);
                switch (quadKey[levelOfDetail - i]) {
                    case "0":
                        break;

                    case "1":
                        tileX |= mask;
                        break;

                    case "2":
                        tileY |= mask;
                        break;

                    case "3":
                        tileX |= mask;
                        tileY |= mask;
                        break;

                    default:
                        throw new ArgumentException(
                            "Invalid QuadKey digit sequence."
                        );
                }
            }
        }

        return {
            tileXYToQuadKey: TileXYToQuadKey,
            latLongToPixelXY: LatLongToPixelXY
        };
    })();

    /**************************************************************************************************************/

    /**
     * Bing layer configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.bing_configuration
     * @property {int} [baseLevel=2]
     * @property {onreadyCallback} [onready] - CallBack function.
     * @property {String} imageSet the image set to use, can be Aerial, Road
     * @property {String} key the bing key to use
     */

    /**
     * Callback when the layer is ready.
     * @callback onreadyCallback
     * @param {BingLayer} Bing layer
     */

    /**
     * @name BingLayer
     * @class
     *     Bing Maps is a web mapping service provided as a part of Microsoft's Bing suite of search engines and powered
     * by the Bing Maps for Enterprise framework.
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.bing_configuration} options -Bing Layer configuration
     * @see {@link https://en.wikipedia.org/wiki/Bing_Maps}
     * @memberof module:Layer
     */
    var BingLayer = function(options) {
        // Call ancestor
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Bing,
            options
        );

        this.tilePixelSize = 256;
        this.tiling = new MercatorTiling(options.baseLevel || 2);
        this.numberOfLevels = 18;
        this.baseUrl = "";
        this.baseUrlSubDomains = [];
        this._ready = false;

        var self = this;

        // Need to provide a global callback for JSONP
        window._bingTileProviderCallback = function(result) {
            self.baseUrl = self.proxify(
                result.resourceSets[0].resources[0].imageUrl
            );
            self.baseUrlSubDomains = self.proxify(
                result.resourceSets[0].resources[0].imageUrlSubdomains
            );
            self._ready = true;

            // Call callback if set
            if (options.onready && options.onready instanceof Function) {
                options.onready(self);
            }

            // Request a frame
            if (self.globe) {
                self.globe.getRenderContext().requestFrame();
            }
        };

        // JSONP Call : needed because of cross-site origin policy
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = this.proxify(
            "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" +
                options.imageSet +
                "?jsonp=_bingTileProviderCallback&key=" +
                options.key
        );
        script.id = "_bingTileProviderCallback";
        document.getElementsByTagName("head")[0].appendChild(script);
    };

    Utils.inherits(AbstractRasterLayer, BingLayer);

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile.
     * @function getUrl
     * @memberof BingLayer#
     * @param {Tile} tile Tile
     * @returns {string} Url
     */
    BingLayer.prototype.getUrl = function(tile) {
        var url = this.baseUrl.replace(
            "{quadkey}",
            BingTileSystem.tileXYToQuadKey(tile.x, tile.y, tile.level)
        );
        url = url.replace(
            "{subdomain}",
            this.baseUrlSubDomains[
                Math.floor(Math.random() * this.baseUrlSubDomains.length)
            ]
        );
        return this.proxify(url, tile.level);
    };

    /**************************************************************************************************************/

    return BingLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/GroundOverlayRenderer',["./Program", "../Tiling/Tile"], function(Program, Tile) {
    //*************************************************************************

    /**
	@name GroundOverlayRenderer
	@class
	 GroundOverlayRenderer constructor
	@param {TileManager} tileManager Tile manager
	@constructor
	*/
    var GroundOverlayRenderer = function(tileManager) {
        this.enabled = true;

        this.renderContext = tileManager.renderContext;
        this.tileManager = tileManager;

        var vertexShader = "attribute vec3 vertex;\n";
        vertexShader += "attribute vec2 tcoord;\n";
        vertexShader += "uniform mat4 modelViewMatrix;\n";
        vertexShader += "uniform mat4 projectionMatrix;\n";
        vertexShader += "uniform vec4 extent; \n";
        vertexShader += "varying vec2 texCoord;\n";
        vertexShader += "void main(void) \n";
        vertexShader += "{\n";
        vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
        vertexShader +=
            "	texCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n";
        vertexShader +=
            "	texCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n";
        vertexShader += "}\n";

        var fragmentShader = "#ifdef GL_ES\n";
        fragmentShader += "precision highp float;\n";
        fragmentShader += "#endif\n";
        fragmentShader += "\n";
        fragmentShader += "varying vec2 texCoord;\n";
        fragmentShader += "uniform sampler2D overlayTexture;\n";
        fragmentShader += "uniform mat3 transform;\n";
        fragmentShader += "uniform float opacity; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void)\n";
        fragmentShader += "{\n";
        fragmentShader += "	vec3 tc = transform * vec3(texCoord,1.0); \n";
        fragmentShader += "	tc.xy /= tc.z; \n";
        fragmentShader +=
            "	gl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n";
        fragmentShader +=
            "	gl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n";
        fragmentShader += "}\n";

        this.program = new Program(this.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        this.groundOverlays = [];
    };

    //*************************************************************************

    /*
	Render the ground overlays above the tiles in parameter
 */
    GroundOverlayRenderer.prototype.render = function(tiles) {
        if (this.enabled === false) {
            // Disabled, so no rendering
            return;
        }

        var gl = this.renderContext.gl;

        // Setup program
        this.program.apply();

        var attributes = this.program.attributes;

        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            this.renderContext.projectionMatrix
        );
        gl.uniform1i(this.program.uniforms.overlayTexture, 0);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.depthMask(false);

        var modelViewMatrix = mat4.create();

        var currentIB = null;

        for (var j = 0; j < this.groundOverlays.length; j++) {
            var go = this.groundOverlays[j];

            // Image is not loaded, nothing to be done
            if (!go.image.complete) {
                continue;
            }

            if (!go.texture) {
                go.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(
                    go.image,
                    go.flipY
                );
            }

            var initialized = false;

            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                if (go.geoBound.intersects(tile.geoBound)) {
                    if (!initialized) {
                        gl.uniformMatrix3fv(
                            this.program.uniforms.transform,
                            false,
                            go.inverseTransform
                        );
                        gl.uniform1f(
                            this.program.uniforms.opacity,
                            go.getOpacity()
                        );

                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindTexture(gl.TEXTURE_2D, go.texture);

                        gl.bindBuffer(
                            gl.ARRAY_BUFFER,
                            this.tileManager.tcoordBuffer
                        );
                        gl.vertexAttribPointer(
                            attributes.tcoord,
                            2,
                            gl.FLOAT,
                            false,
                            0,
                            0
                        );

                        initialized = true;
                    }

                    var extent =
                        tile.state === Tile.State.LOADED
                            ? tile.bound
                            : tile.parent.bound;

                    gl.uniform4f(
                        this.program.uniforms.extent,
                        extent.west,
                        extent.east,
                        extent.north,
                        extent.south
                    );
                    mat4.multiply(
                        this.renderContext.viewMatrix,
                        tile.matrix,
                        modelViewMatrix
                    );
                    gl.uniformMatrix4fv(
                        this.program.uniforms.modelViewMatrix,
                        false,
                        modelViewMatrix
                    );

                    // Bind the vertex buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                    gl.vertexAttribPointer(
                        attributes.vertex,
                        3,
                        gl.FLOAT,
                        false,
                        0,
                        0
                    );

                    // Bind the index buffer only if different (index buffer is shared between tiles)
                    var indexBuffer =
                        tile.state === Tile.State.LOADED
                            ? this.tileManager.tileIndexBuffer.getSolid()
                            : this.tileManager.tileIndexBuffer.getSubSolid(
                                  tile.parentIndex
                              );
                    if (currentIB !== indexBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        currentIB = indexBuffer;
                    }

                    // Finally draw the tiles
                    gl.drawElements(
                        gl.TRIANGLES,
                        indexBuffer.numIndices,
                        gl.UNSIGNED_SHORT,
                        0
                    );
                }
            }
        }

        gl.disable(gl.BLEND);
        gl.depthMask(true);
    };

    //*************************************************************************

    return GroundOverlayRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/GroundOverlayLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/GeoBound",
    "../Renderer/GroundOverlayRenderer"
], function(Utils, AbstractLayer, Constants, GeoBound, GroundOverlayRenderer) {
    /**
     * GroundOverlay Layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.groundOverlay_configuration
     * @param {float[]} quad  - An array of 4 points to define the area on the terrain to drape the image
     * @param {Object|String} image - the image to drape on the terrain, can be an Image element or a string (url of the image)
     * @param {boolean} [flipY=true] - flip or not the image
     */

    /**
     * @name GroundOverlayLayer
     * @class
     * This layer draws an image overlay draped onto the terrain
     * @augments AbstractLayer
     * @param {AbstractLayer.groundOverlay_configuration} options - Ground overlay configuration
     * @constructor
     * @memberof module:Layer
     */
    var GroundOverlayLayer = function(options) {
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.GroundOverlay,
            options
        );

        this.geoBound = null;
        this.image = null;
        this.globe = null;
        this.flipY = null;

        this.quad = options.quad;
        if (typeof options.flipY === "undefined") {
            this.flipY = true;
        } else {
            this.flipY = options.flipY;
        }

        if (this.quad !== null && typeof this.quad !== "undefined") {
            // Compute the geo bound of the ground overlay
            this.geoBound = new GeoBound();
            this.geoBound.computeFromCoordinates(this.quad);
        }

        if (typeof options.image === "string") {
            this.image = new Image();
            this.image.crossOrigin = "";
            this.image.src = options.image;
        } else if (options.image instanceof HTMLImageElement) {
            this.image = options.image;
        }
        this.image.layer = this;

        this.image.onload = function() {
            this.layer.getGlobe().refresh();
        };
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, GroundOverlayLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.RASTER;
    }

    /**
     * Attaches layer to the globe.
     * @function _attach
     * @memberof GroundOverlayLayer#
     * @param {AbstractGlobe} planet - Globe to attach
     * @private
     */
    GroundOverlayLayer.prototype._attach = function(planet) {
        // Add layer to ground overlay renderer, create one if needed
        var renderer = planet.groundOverlayRenderer;
        if (!renderer) {
            renderer = new GroundOverlayRenderer(planet.getTileManager());
            planet.getTileManager().addPostRenderer(renderer);
            planet.groundOverlayRenderer = renderer;
        }
        renderer.groundOverlays.push(this);

        this.globe = planet;

        this.computeTransform();
    };

    //*************************************************************************

    /**
     * Update
     * @function update
     * @memberof GroundOverlayLayer#
     * @param {JSon} quad Quad coordinates
     * @param {String} url Url of image
     */
    GroundOverlayLayer.prototype.update = function(quad, url) {
        this.getGlobe().groundOverlayRenderer.enabled = true;

        this.geoBound = null;
        this.geoBound = new GeoBound();

        this.geoBound.computeFromCoordinates(this.quad);

        this.image = null;
        this.image = new Image();

        this.image.crossOrigin = "";
        this.image.src = url;
        this.image.layer = this;

        this.computeTransform();

        this.image.onload = function() {
            this.layer.getGlobe().refresh();
        };
    };

    //*************************************************************************

    /**
     * Detaches layer from the globe.
     * @function _detach
     * @memberof GroundOverlayLayer#
     * @param {AbstractGlobe} globe - globe to detach
     * @private
     */
    GroundOverlayLayer.prototype._detach = function(planet) {
        // Remove layer from the planet renderer for ground overlay
        var prevRenderer = this.getGlobe().groundOverlayRenderer;
        if (prevRenderer) {
            var index = prevRenderer.groundOverlays.indexOf(this);
            if (index !== -1) {
                prevRenderer.groundOverlays.splice(index, 1);

                if (prevRenderer.groundOverlays.length === 0) {
                    this.getGlobe()
                        .getTileManager()
                        .removePostRenderer(prevRenderer);
                    this.getGlobe().groundOverlayRenderer = null;
                }
            }
        }
    };

    //*************************************************************************

    /**
     * Computes the inverse transform from unit square to geo position
     * Code taken from QTransform
     * @function computeInverse
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.computeInverse = function() {
        var det =
            this.transform[0] *
                (this.transform[8] * this.transform[4] -
                    this.transform[5] * this.transform[7]) -
            this.transform[3] *
                (this.transform[8] * this.transform[1] - this.transform[7]) *
                this.transform[3] +
            this.transform[6] *
                (this.transform[5] * this.transform[1] -
                    this.transform[4] * this.transform[2]);

        var h11, h12, h13, h21, h22, h23, h31, h32, h33;
        h11 =
            this.transform[4] * this.transform[8] -
            this.transform[5] * this.transform[7];
        h21 =
            this.transform[5] * this.transform[6] -
            this.transform[3] * this.transform[8];
        h31 =
            this.transform[3] * this.transform[7] -
            this.transform[4] * this.transform[6];
        h12 =
            this.transform[2] * this.transform[7] -
            this.transform[1] * this.transform[8];
        h22 =
            this.transform[0] * this.transform[8] -
            this.transform[2] * this.transform[6];
        h32 =
            this.transform[1] * this.transform[6] -
            this.transform[0] * this.transform[7];
        h13 =
            this.transform[1] * this.transform[5] -
            this.transform[2] * this.transform[4];
        h23 =
            this.transform[2] * this.transform[3] -
            this.transform[0] * this.transform[5];
        h33 =
            this.transform[0] * this.transform[4] -
            this.transform[1] * this.transform[3];

        this.inverseTransform = [
            h11 / det,
            h12 / det,
            h13 / det,
            h21 / det,
            h22 / det,
            h23 / det,
            h31 / det,
            h32 / det,
            h33 / det
        ];
    };

    //*************************************************************************

    /**
     * Computes the transform from geo position to unit square
     * Code taken from QTransform
     * @function computeTransform
     * @memberof GroundOverlayLayer#
     */
    GroundOverlayLayer.prototype.computeTransform = function() {
        if (this.quad === null) {
            // Sleeping mode, no compute
            console.log("return");
            return;
        }

        var q1 = this.quad[0];
        var q2 = this.quad[1];
        var q3 = this.quad[2];
        var q4 = this.quad[3];

        var tileConfig = this.getGlobe().getTileManager().tileConfig;
        if (tileConfig.srs !== "CRS:84") {
            q1 = tileConfig.project(q1);
            q2 = tileConfig.project(q2);
            q3 = tileConfig.project(q3);
            q4 = tileConfig.project(q4);
        }

        var dx0 = q1[0];
        var dx1 = q2[0];
        var dx2 = q3[0];
        var dx3 = q4[0];

        var dy0 = q1[1];
        var dy1 = q2[1];
        var dy2 = q3[1];
        var dy3 = q4[1];

        var ax = dx0 - dx1 + dx2 - dx3;
        var ay = dy0 - dy1 + dy2 - dy3;

        if (!ax && !ay) {
            //afine transform
            this.transform = [
                dx1 - dx0,
                dy1 - dy0,
                0,
                dx2 - dx1,
                dy2 - dy1,
                0,
                dx0,
                dy0,
                1
            ];
        } else {
            var ax1 = dx1 - dx2;
            var ax2 = dx3 - dx2;
            var ay1 = dy1 - dy2;
            var ay2 = dy3 - dy2;

            /*determinants */
            var gtop = ax * ay2 - ax2 * ay;
            var htop = ax1 * ay - ax * ay1;
            var bottom = ax1 * ay2 - ax2 * ay1;

            var a, b, c, d, e, f, g, h;
            /*i is always 1*/

            if (!bottom) {
                return;
            }

            g = gtop / bottom;
            h = htop / bottom;

            a = dx1 - dx0 + g * dx1;
            b = dx3 - dx0 + h * dx3;
            c = dx0;
            d = dy1 - dy0 + g * dy1;
            e = dy3 - dy0 + h * dy3;
            f = dy0;

            this.transform = [a, d, g, b, e, h, c, f, 1.0];
        }

        this.computeInverse();
    };

    //*************************************************************************

    return GroundOverlayLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/OSMLayer',[
    "../Utils/Utils",
    "./AbstractRasterLayer",
    "../Utils/Constants",
    "../Tiling/MercatorTiling"
], function(Utils, AbstractRasterLayer, Constants, MercatorTiling) {
    /**************************************************************************************************************/

    /**
     * Open Street Map configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.osm_configuration
     * @property {int} [tilePixelSize=256]
     * @property {int} [baseLevel=2]
     * @property {int} [numberOfLevels=21]
     */
    /**
     * @name OSMLayer
     * @class
     *    A layer to display data coming from OpenStreetMap server. OpenStreetMap (OSM) is a collaborative project to
     * create a free editable map of the world
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.osm_configuration} options - OSM Configuration
     * @memberof module:Layer
     */
    var OSMLayer = function(options) {
        options.tilePixelSize = options.tilePixelSize || 256;
        options.tiling = new MercatorTiling(options.baseLevel || 2);
        options.numberOfLevels = options.numberOfLevels || 21;
        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.OSM,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, OSMLayer);

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile.
     * @function getUrl
     * @memberof OSMLayer#
     * @param {Tile} tile Tile
     * @return {String} Url
     */
    OSMLayer.prototype.getUrl = function(tile) {
        var url =
            this.baseUrl +
            "/" +
            tile.level +
            "/" +
            tile.x +
            "/" +
            tile.y +
            ".png";
        return this.proxify(url, tile.level);
    };

    /**************************************************************************************************************/

    return OSMLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/TileWireframeLayer',[
    "../Utils/Utils",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/Program",
    "../Tiling/Tile"
], function (Utils, AbstractLayer, Constants, Program, Tile) {
    /**
     * TileWireFrameLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.tileWireFrame_configuration
     * @property [outline=false]
     */

    /**
     * @name TileWireframeLayer
     * @class
     *    This layer draws an TileWireframe  layer
     * @augments AbstractLayer
     * @param {AbstractLayer.tileWireFrame_configuration} options - TileWireFrame configuration
     * @memberof module:Layer
     * @constructor
     */
    var TileWireframeLayer = function (options) {
        options.zIndex = Constants.DISPLAY.RENDERING;
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.TileWireframe,
            options
        );
        this.outline = options && options.outline ? options.outline : false;
        this.globe = null;
        this.program = null;
        this.indexBuffer = null;
        this.subIndexBuffer = [null, null, null, null];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, TileWireframeLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof TileWireframeLayer#
     */
    TileWireframeLayer.prototype.getInformationType = function () {
        return Constants.INFORMATION_TYPE.VECTOR;
    }

    /**
     * Build the index buffer
     * @function buildIndexBuffer
     * @memberof TileWireframeLayer#
     */
    TileWireframeLayer.prototype.buildIndexBuffer = function () {
        var gl = this.getGlobe().getRenderContext().gl;
        var size = this.getGlobe().getTileManager().tileConfig.tesselation;
        var indices = [];
        var i, j, ii, n, k;
        var step = this.outline ? size - 1 : 1;
        var ib;

        // Build horizontal lines
        for (j = 0; j < size; j += step) {
            for (i = 0; i < size - 1; i++) {
                indices.push(j * size + i);
                indices.push(j * size + i + 1);
            }
        }

        // Build vertical lines
        for (j = 0; j < size; j += step) {
            for (i = 0; i < size - 1; i++) {
                indices.push(i * size + j);
                indices.push((i + 1) * size + j);
            }
        }

        ib = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );

        ib.numIndices = indices.length;
        this.indexBuffer = ib;

        var halfTesselation = (size - 1) / 2;
        step = this.outline ? halfTesselation : 1;
        for (ii = 0; ii < 4; ii++) {
            i = ii % 2;
            j = Math.floor(ii / 2);

            // Build the sub grid for 'inside' tile
            indices = [];
            for (
                n = halfTesselation * j;
                n < halfTesselation * (j + 1) + 1;
                n += step
            ) {
                for (
                    k = halfTesselation * i;
                    k < halfTesselation * (i + 1);
                    k++
                ) {
                    indices.push(n * size + k);
                    indices.push(n * size + k + 1);
                }
            }
            for (
                n = halfTesselation * i;
                n < halfTesselation * (i + 1) + 1;
                n += step
            ) {
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(k * size + n);
                    indices.push((k + 1) * size + n);
                }
            }

            ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW
            );
            ib.numIndices = indices.length;
            this.subIndexBuffer[ii] = ib;
        }
    };

    /**************************************************************************************************************/
    /**
     * Attaches the layer to the planet
     * @function _attach
     * @memberof TileWireframeLayer#
     * @param {AbstractGlobe} g globe
     * @private
     */
    TileWireframeLayer.prototype._attach = function (g) {
        AbstractLayer.prototype._attach.call(this, g);

        if (this.isVisible()) {
            this.getGlobe()
                .getTileManager()
                .addPostRenderer(this);
        }

        if (!this.program) {
            var vertexShader = "attribute vec3 vertex;\n";
            vertexShader += "uniform mat4 modelViewMatrix;\n";
            vertexShader += "uniform mat4 projectionMatrix;\n";
            vertexShader += "void main(void) \n";
            vertexShader += "{\n";
            vertexShader +=
                "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
            vertexShader += "}\n";

            var fragmentShader = "precision highp float; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "void main(void)\n";
            fragmentShader += "{\n";
            fragmentShader += "	gl_FragColor = vec4(color,alpha);\n";
            fragmentShader += "}\n";

            this.program = new Program(this.getGlobe().getRenderContext());
            this.program.createFromSource(vertexShader, fragmentShader);

            this.buildIndexBuffer();
        }
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the planet
     * @function _detach
     * @memberof TileWireframeLayer#
     * @private
     */
    TileWireframeLayer.prototype._detach = function () {
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Renders the tiles outline
     * @function render
     * @memberof TileWireframeLayer#
     * @param {Array} tiles Array of Tile
     */
    TileWireframeLayer.prototype.render = function (tiles) {
        var rc = this.getGlobe().getRenderContext();
        var gl = rc.gl;

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);

        // Setup program
        this.program.apply();
        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            rc.projectionMatrix
        );

        var vertexAttribute = this.program.attributes.vertex;
        var currentIB = null;

        for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];

            var isLoaded = tile.state === Tile.State.LOADED;
            var isLevelZero = tile.parentIndex === -1;

            // Update uniforms for modelview matrix
            mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
            gl.uniformMatrix4fv(
                this.program.uniforms.modelViewMatrix,
                false,
                rc.modelViewMatrix
            );
            var color = this.getStyle().getStrokeColor();
            gl.uniform3f(
                this.program.uniforms.color,
                color[0],
                color[1],
                color[2]
            );
            gl.uniform1f(this.program.uniforms.alpha, this.getOpacity());

            // Bind the vertex buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
            gl.vertexAttribPointer(
                vertexAttribute,
                3,
                gl.FLOAT,
                false,
                4 * tile.config.vertexSize,
                0
            );
            var indexBuffer =
                isLoaded || isLevelZero
                    ? this.indexBuffer
                    : this.subIndexBuffer[tile.parentIndex];
            // Bind the index buffer only if different (index buffer is shared between tiles)
            if (currentIB !== indexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                currentIB = indexBuffer;
            }

            // Draw the tiles in wireframe mode
            var numIndices = currentIB.numIndices;
            gl.drawElements(gl.LINES, numIndices, gl.UNSIGNED_SHORT, 0);
        }

        gl.disable(gl.BLEND);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    /**
     * Get/Set visibility of the layer
     * @function setVisible
     * @memberof TileWireframeLayer#
     * @param {boolean} arg Visiblity
     */
    TileWireframeLayer.prototype.setVisible = function (arg) {
        AbstractLayer.prototype.setVisible.call(this, arg);

        if (typeof arg === "boolean") {
            if (this.isVisible()) {
                this.getGlobe()
                    .getTileManager()
                    .addPostRenderer(this);
            } else {
                this.getGlobe()
                    .getTileManager()
                    .removePostRenderer(this);
            }
        }

        return this.isVisible();
    };

    return TileWireframeLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Mesh',[],function() {
    /**************************************************************************************************************/

    /** @constructor
     Mesh constructor
     */
    var Mesh = function(renderContext) {
        this.renderContext = renderContext;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.indexBuffer = null;
        this.colorBuffer = null;
        this.numVertices = 0;
        this.mode = renderContext.gl.TRIANGLES;
    };

    /**************************************************************************************************************/

    /*
     Mesh setVertices method
     */
    Mesh.prototype.setVertices = function(vertices) {
        var gl = this.renderContext.gl;
        if (this.vertexBuffer === null) {
            this.vertexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
        );
        this.numVertices = vertices.length;
    };

    /**************************************************************************************************************/

    /*
     Mesh setTexCoords method
     */
    Mesh.prototype.setTexCoords = function(tcoords) {
        var gl = this.renderContext.gl;
        if (this.tcoordBuffer === null) {
            this.tcoordBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(tcoords),
            gl.STATIC_DRAW
        );
    };

    /**************************************************************************************************************/

    /*
     Mesh setColors method
     */
    Mesh.prototype.setColors = function(colors) {
        var gl = this.renderContext.gl;
        if (this.colorBuffer === null) {
            this.colorBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(colors),
            gl.STATIC_DRAW
        );
    };

    /**************************************************************************************************************/

    /*
     Mesh setIndices method
     */
    Mesh.prototype.setIndices = function(indices) {
        var gl = this.renderContext.gl;
        if (this.indexBuffer === null) {
            this.indexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indices),
            gl.STATIC_DRAW
        );
        this.numIndices = indices.length;
    };

    /**************************************************************************************************************/

    /*
     Convert to wireframe (for debug purposes)
     */
    Mesh.prototype.setIndicesToWireframe = function(indices) {
        this.mode = this.renderContext.gl.LINES;

        // Convert indices
        var wireframeIndices = [];
        wireframeIndices.length = 2 * indices.length;

        for (var i = 0; i < indices.length; i += 3) {
            wireframeIndices[2 * i] = indices[i];
            wireframeIndices[2 * i + 1] = indices[i + 1];

            wireframeIndices[2 * i + 2] = indices[i + 1];
            wireframeIndices[2 * i + 3] = indices[i + 2];

            wireframeIndices[2 * i + 4] = indices[i + 2];
            wireframeIndices[2 * i + 5] = indices[i];
        }

        this.setIndices(wireframeIndices);
    };

    /**************************************************************************************************************/

    /*
     Mesh render method
     */
    Mesh.prototype.render = function(attributes) {
        var gl = this.renderContext.gl;

        // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0);
        if (attributes.hasOwnProperty("tcoord")) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
            gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
        }
        if (attributes.hasOwnProperty("color")) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);
        }
        if (this.indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(this.mode, this.numIndices, gl.UNSIGNED_SHORT, 0);
        } else {
            gl.drawArrays(this.mode, 0, this.numVertices / 3);
        }
    };

    /**************************************************************************************************************/

    /*
     Mesh dispose method
     */
    Mesh.prototype.dispose = function() {
        var gl = this.renderContext.gl;
        if (this.indexBuffer) {
            gl.deleteBuffer(this.indexBuffer);
        }
        if (this.vertexBuffer) {
            gl.deleteBuffer(this.vertexBuffer);
        }
        if (this.tcoordBuffer) {
            gl.deleteBuffer(this.tcoordBuffer);
        }
        if (this.colorBuffer) {
            gl.deleteBuffer(this.colorBuffer);
        }

        this.indexBuffer = null;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.colorBuffer = null;
    };

    /**************************************************************************************************************/

    return Mesh;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Crs/AstroCoordTransform',[],function() {
    /**************************************************************************************************************/

    /** The Constant twoPi. */
    var twoPi = 2.0 * Math.PI;

    /** The Constant fourPi. */
    var fourPi = 4.0 * Math.PI;

    /** The Constant degToRad. */
    var degToRad = 180.0 / Math.PI;

    /** The Constant psi. */
    var psi = [
        [0.57595865315, 4.9261918136, 0.0, 0.0, 0.11129056012, 4.7005372834],
        [0.574770433, 4.9368292465, 0.0, 0.0, 0.11142137093, 4.71279419371]
    ];

    /** The Constant stheta. */
    var stheta = [
        [
            0.88781538514,
            -0.88781538514,
            0.39788119938,
            -0.39788119938,
            0.86766174755,
            -0.86766174755
        ],
        [
            0.88998808748,
            -0.88998808748,
            0.39777715593,
            -0.39777715593,
            0.86766622025,
            -0.86766622025
        ]
    ];

    /** The Constant ctheta. */
    var ctheta = [
        [
            0.46019978478,
            0.46019978478,
            0.9174369467,
            0.9174369467,
            0.49715499774,
            0.49715499774
        ],
        [
            0.45598377618,
            0.45598377618,
            0.91748206207,
            0.91748206207,
            0.49714719172,
            0.49714719172
        ]
    ];

    /** The Constant phi. */
    var phi = [
        [4.9261918136, 0.57595865315, 0.0, 0.0, 4.7005372834, 0.11129056012],
        [4.9368292465, 0.574770433, 0.0, 0.0, 4.71279419371, 0.11142137093]
    ];

    var AstroCoordTransform = {
        /**Transforms an angular position in radians in a given coordinate system to a position
         in an other coordinate system, also in radians. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transform: function(pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] - phi[J2000][trType];
            b = pos[1];
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b);

            a = Math.atan2(
                ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb,
                cb * Math.cos(a)
            );
            ao = (a + psi[J2000][trType] + fourPi) % twoPi;

            return [ao, bo]; // phi, theta
        },

        /**Transforms an angular position in degrees in a given coordinate system to a position
         in an other coordinate systems, also in degrees. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transformInDeg: function(pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] / degToRad - phi[J2000][trType];
            b = pos[1] / degToRad;
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b) * degToRad;

            a = Math.atan2(
                ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb,
                cb * Math.cos(a)
            );
            ao = ((a + psi[J2000][trType] + fourPi) % twoPi) * degToRad;

            return [ao, bo];
        }
    };

    /**
     *    Transform type enumerations
     */
    AstroCoordTransform.Type = {
        EQ2GAL: 0, //RA-Dec (2000) -> Galactic
        GAL2EQ: 1, //Galactic      -> RA-Dec
        EQ2ECL: 2, //RA-Dec        -> Ecliptic
        ECL2EQ: 3, //Ecliptic      -> RA-Dec
        ECL2GAL: 4, //Ecliptic      -> Galactic
        GAL2ECL: 5 //Galactic      -> Ecliptic
    };

    /**************************************************************************************************************/

    return AstroCoordTransform;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Geoide',[], function() {
    /**
     * Geoide configuration
     * @typedef {Object} AbstractCrs.geoide_configuration
     * @property {float} radius - internal radius in vector length
     * @property {float} realPlanetRadius - real planet radius in meter
     */

    /**
     * @name Geoide
     * @class
     * Geodetic datum is a set of parameters that define the position of the origin, the scale, and the orientation of a
     * coordinate system in relationship with the planet.
     * @param {AbstractCrs.geoide_configuration} options - Options for Geoide
     * @constructor
     * @throws {ReferenceError} Will throw an error when options.realPlanetRadius or options.radius are not defined
     * @memberof module:Crs
     * @todo add flattening parameter
     */
    var Geoide = function(options) {
        this.radius =
            options && options.hasOwnProperty("radius") ? options.radius : null;
        this.realPlanetRadius =
            options && options.hasOwnProperty("realPlanetRadius")
                ? options.realPlanetRadius
                : null;
        if (this.radius === null || this.realPlanetRadius === null) {
            throw new ReferenceError(
                "Radius and realPlanetRadius must be set to define a geoide",
                "Geoide.js"
            );
        }
        this.heightScale = this.radius / this.realPlanetRadius;
    };

    /**
     * Get real planet radius in meter
     * @function getRealPlanetRadius
     * @memberof Geoide#
     * @return {float} Real planet radius
     */
    Geoide.prototype.getRealPlanetRadius = function() {
        return this.realPlanetRadius;
    };

    /**
     * Get radius in vector length
     * @function getRadius
     * @memberof Geoide#
     * @return {float} Radius
     */
    Geoide.prototype.getRadius = function() {
        return this.radius;
    };

    /**
     * Get height scale = 1/realPlanetRadius
     * @function getHeightScale
     * @memberof Geoide#
     * @return {float} Height scale
     */
    Geoide.prototype.getHeightScale = function() {
        return this.heightScale;
    };
    /**************************************************************************************************************/

    return Geoide;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Crs/AbstractCrs',[
    "../Utils/Numeric",
    "./Geoide",
    "../Utils/Constants",
    "./AstroCoordTransform",
    "../Renderer/glMatrix"
], function(Numeric, Geoide, Constants, AstroCoordTransform) {
    /**
     * Abstract coordinate reference system configuration
     * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
     * @property {CRS} geoideName - name of the coordinate reference system
     * @property {CONTEXT} type - Type of the CRS
     * @property {GeoBound} geoBound - Geographical bounding box
     */

    /**
     * @name AbstractCrs
     * @class
     * Creates an coordinate reference system for a globe and data.
     *
     * A coordinate reference system is a coordinate system that is related to an object
     * by a {@link Geoide geodetic datum}.
     *
     * A coordinate system is a set of mathematical rules for specifying how coordinates are to be assigned to points
     * @param {AbstractCrs.configuration} options - Options for the coordinate reference system.
     * @throws {ReferenceError} Will throw when option.geoideName, options.geoBound and options.type are not defined
     * @constructor
     * @implements {Crs}
     */
    var AbstractCrs = function(options) {
        this.flat = false;
        this.geoide = null;
        this.type = null;
        this.geoBound = null;

        // If geoideName is specified, use it
        if (options && options.geoideName && options.type && options.geoBound) {
            this.geoide = new Geoide(options);
            this.geoideName = options.geoideName;
            this.type = options.type;
            this.geoBound = options.geoBound;
        } else {
            throw new ReferenceError(
                "The geoide's parameters, the geoBound and the type of context must be defined",
                AbstractCrs.js
            );
        }
    };

    /**
     * @function isFlat
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.isFlat = function() {
        return this.flat;
    };

    /**
     * @function getVerticalAt3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getVerticalAt3D = function(pos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        if (this.isFlat()) {
            dest[0] = 0.0;
            dest[1] = 0.0;
            dest[2] = 1.0;
        } else {
            vec3.normalize(pos, dest);
        }
        return dest;
    };

    /**
     * @function fromGeoTo3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromGeoTo3D = function(geo, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        if (!geo || geo.length < 2) {
            console.log("Erreur !");
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }
        var longInRad = Numeric.toRadian(geo[0]);
        var latInRad = Numeric.toRadian(geo[1]);
        var cosLat = Math.cos(latInRad);

        // Take height into account
        var height = geo.length > 2 ? this.geoide.getHeightScale() * geo[2] : 0;
        var radius = this.geoide.getRadius() + height;

        dest[0] = radius * Math.cos(longInRad) * cosLat;
        dest[1] = radius * Math.sin(longInRad) * cosLat;
        dest[2] = radius * Math.sin(latInRad);

        return dest;
    };

    /**
     * @function from3DToGeo
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.from3DToGeo = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var r = Math.sqrt(
            position3d[0] * position3d[0] +
                position3d[1] * position3d[1] +
                position3d[2] * position3d[2]
        );
        var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
        var lat = Math.asin(position3d[2] / r);
        dest[0] = Numeric.toDegree(lon);
        dest[1] = Numeric.toDegree(lat);
        dest[2] =
            this.geoide.getRealPlanetRadius() * (r - this.geoide.getRadius());
        return dest;
    };

    /**
     * @function getLocalTransform
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getLocalTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var longitude = (geo[0] * Math.PI) / 180.0;
        var latitude = (geo[1] * Math.PI) / 180.0;

        var up = [
            Math.cos(longitude) * Math.cos(latitude),
            Math.sin(longitude) * Math.cos(latitude),
            Math.sin(latitude)
        ];
        var east = [-Math.sin(longitude), Math.cos(longitude), 0];
        var north = vec3.create();
        vec3.cross(up, east, north);

        dest[0] = east[0];
        dest[1] = east[1];
        dest[2] = east[2];
        dest[3] = 0.0;

        dest[4] = north[0];
        dest[5] = north[1];
        dest[6] = north[2];
        dest[7] = 0.0;

        dest[8] = up[0];
        dest[9] = up[1];
        dest[10] = up[2];
        dest[11] = 0.0;

        dest[12] = 0.0;
        dest[13] = 0.0;
        dest[14] = 0.0;
        dest[15] = 1.0;

        return dest;
    };

    /**
     * @function getLHVTransform
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getLHVTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var longitude = (geo[0] * Math.PI) / 180.0;
        var latitude = (geo[1] * Math.PI) / 180.0;

        var up = [
            Math.cos(longitude) * Math.cos(latitude),
            Math.sin(longitude) * Math.cos(latitude),
            Math.sin(latitude)
        ];
        var east = [-Math.sin(longitude), Math.cos(longitude), 0];
        var north = vec3.create();
        vec3.cross(up, east, north);

        var pt = this.get3DFromWorld(geo);

        dest[0] = east[0];
        dest[1] = east[1];
        dest[2] = east[2];
        dest[3] = 0.0;

        dest[4] = north[0];
        dest[5] = north[1];
        dest[6] = north[2];
        dest[7] = 0.0;

        dest[8] = up[0];
        dest[9] = up[1];
        dest[10] = up[2];
        dest[11] = 0.0;

        dest[12] = pt[0];
        dest[13] = pt[1];
        dest[14] = pt[2];
        dest[15] = 1.0;

        return dest;
    };

    /**
     * @function getSideVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getSideVector = function(matrix, v) {
        v[0] = matrix[0];
        v[1] = matrix[1];
        v[2] = matrix[2];
        return v;
    };

    /**
     * @function getFrontVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getFrontVector = function(matrix, v) {
        v[0] = matrix[4];
        v[1] = matrix[5];
        v[2] = matrix[6];

        return v;
    };

    /**
     * @function getUpVector
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getUpVector = function(matrix, v) {
        v[0] = matrix[8];
        v[1] = matrix[9];
        v[2] = matrix[10];

        return v;
    };

    /**
     * @function formatCoordinates
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.formatCoordinates = function(geo) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getGeoide
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoide = function() {
        return this.geoide;
    };

    /**
     * @function getGeoideName
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoideName = function() {
        return this.geoideName;
    };

    /**
     * @function getType
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getType = function() {
        return this.type;
    };

    /**
     * @function getElevation
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getElevation = function(globe, geoPos) {
        return globe.getElevation(geoPos.coordinates[0], geoPos.coordinates[1]);
    };

    /**
     * @function getWorldFrom3D
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getWorldFrom3D = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        var geoPos = this.from3DToGeo(position3d);
        this._setupPosAfterTrans(geoPos);
        dest[0] = geoPos[0];
        dest[1] = geoPos[1];
        dest[2] = geoPos.length > 2 ? geoPos[2] : 0;
        return dest;
    };

    /**
     * @function get3DFromWorld
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.get3DFromWorld = function(posWorld, dest) {
        if (!dest) {
            dest = vec3.create();
        }
        var pos = posWorld.slice(0);
        this._setupPosBeforeTrans(pos);
        this.fromGeoTo3D(pos, dest);
        return dest;
    };

    /**
     * @function get3DFromWorldInCrs
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.get3DFromWorldInCrs = function(
        posWorld,
        posCrsID,
        dest
    ) {
        if (!dest) {
            dest = vec3.create();
        }
        var posWorldInCurrentCrs = this.convert(
            posWorld,
            posCrsID,
            this.getGeoideName()
        );
        this.get3DFromWorld(posWorldInCurrentCrs, dest);
        return dest;
    };

    /**
     * @function getSexagesimalFromDeg
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getSexagesimalFromDeg = function(degPos, dest) {
        dest = dest || [];

        var deg = degPos[0];
        // RA
        if (deg < 0) {
            deg += 360;
        }

        dest[0] = this.fromDegreesToHMS(deg);
        dest[1] = this.fromDegreesToDMS(degPos[1]);

        return dest;
    };

    /**
     * @function getDecimalDegFromSexagesimal
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getDecimalDegFromSexagesimal = function(
        sexagesimalPos,
        dest
    ) {
        dest = dest || [];

        // we use string because : parseFloat("-0") returns 0..
        function sign(stringDegree) {
            return stringDegree[0] === "-" ? -1 : 1;
        }

        var longitude = sexagesimalPos[0].split(" ");
        // long
        var deg = parseFloat(longitude[0]);
        var min = parseFloat(longitude[1]);
        var sec = parseFloat(longitude[2]);

        dest[0] = (deg + min / 60 + sec / 3600) * 15.0;

        var latitude = sexagesimalPos[1].split(" ");
        // lat
        deg = parseFloat(latitude[0]);
        min = parseFloat(latitude[1]);
        sec = parseFloat(latitude[2]);

        dest[1] = sign(latitude[0]) * (Math.abs(deg) + min / 60 + sec / 3600);

        return dest;
    };

    /**
     * @function convert
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.convert = function(geo, from, to) {
        // No conversion needed
        if (from === to) {
            return geo;
        }

        var convertedGeo = null;
        var convertType = null;
        switch (from + "2" + to) {
            case Constants.CRS.Galactic + "2" + Constants.CRS.Equatorial:
                convertType = AstroCoordTransform.Type.GAL2EQ;
                convertedGeo = AstroCoordTransform.transformInDeg(
                    geo,
                    convertType
                );
                break;
            case Constants.CRS.Equatorial + "2" + Constants.CRS.Galactic:
                convertType = AstroCoordTransform.Type.EQ2GAL;
                convertedGeo = AstroCoordTransform.transformInDeg(
                    geo,
                    convertType
                );
                if (convertedGeo[0] < 0) {
                    // TODO : Check if convertedGeo can be negative
                    console.warn(
                        "EQ2GAL transformation returned negative value"
                    );
                    convertedGeo[0] += 360;
                }
                break;
            case Constants.CRS.Mars_2000 + "2" + Constants.CRS.Mars_2000_old:
            case Constants.CRS.Mars_2000_old + "2" + Constants.CRS.Mars_2000:
                convertedGeo = geo;
                break;
            case Constants.CRS.Moon_2000 + "2" + Constants.CRS.Moon_2000_old:
            case Constants.CRS.Moon_2000_old + "2" + Constants.CRS.Moon_2000:
                convertedGeo = geo;
                break;
            default:
                throw new RangeError(
                    "Conversion " + from + " to " + to + " is not implemented",
                    "AbstractCrs.js"
                );
        }

        return convertedGeo;
    };

    /**
     * Adds a zero before the number < 10
     * @function _pad2Digits
     * @param number number to format
     * @returns {String}
     * @private
     */
    AbstractCrs.prototype._pad2Digits = function(number) {
        return number < 10 ? "0" + number : number;
    };

    /**
     * @function fromDegreesToHMS
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromDegreesToHMS = function(degree) {
        var localDegree = degree / 15;

        var absLon = Math.abs(localDegree);
        var hours = Math.floor(absLon);
        var decimal = (absLon - hours) * 60;
        var min = Math.floor(decimal);
        var sec = (decimal - min) * 60;

        return (
            this._pad2Digits(hours) +
            "h " +
            this._pad2Digits(min) +
            "m " +
            this._pad2Digits(Numeric.roundNumber(sec, 2)) +
            "s"
        );
    };

    /**
     * @function fromDegreesToDMS
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.fromDegreesToDMS = function(degree) {
        function stringSign(val) {
            return val >= 0 ? "+" : "-";
        }

        var absLat = Math.abs(degree);
        var deg = Math.floor(absLat);
        var decimal = (absLat - deg) * 60;
        var min = Math.floor(decimal);
        var sec = (decimal - min) * 60;

        return (
            stringSign(degree) +
            this._pad2Digits(deg) +
            String.fromCharCode(176) +
            " " +
            this._pad2Digits(min) +
            "' " +
            this._pad2Digits(Numeric.roundNumber(sec, 2)) +
            '"'
        );
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof AbstractCrs#
     * @bastract
     */
    AbstractCrs.prototype._setupPosAfterTrans = function(posWorld) {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getGeoBound
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.getGeoBound = function() {
        return this.geoBound;
    };

    /**
     * @function getName
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getName = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getDescription
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getDescription = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getLongitudeLabel
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getLongitudeLabel = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function getLatitudeLabel
     * @memberof AbstractCrs#
     * @abstract
     */
    AbstractCrs.prototype.getLatitudeLabel = function() {
        throw new SyntaxError("Not implemented");
    };

    /**
     * @function isProjected
     * @memberof AbstractCrs#
     * @return {boolean} true when the Crs is projected in 2D otherwise false.
     */
    AbstractCrs.prototype.isProjected = function() {
        return false;
    };

    /**
     * @function destroy
     * @memberof AbstractCrs#
     */
    AbstractCrs.prototype.destroy = function() {
        this.flat = null;
        this.geoide = null;
        this.type = null;
        this.geoBound = null;
        this.projected = null;
    };

    /**************************************************************************************************************/
    return AbstractCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/WGS84Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    const DESCRIPTION =
        "WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which " +
        "the geographic longitude increases to the east. The geographic latitude is measured in degrees north or south " +
        "of the Earth equator. In Mizar, the latitudes are projected on a sphere";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name WGS84Crs
     * @class
     * WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which the
     * geographic longitude increases to the east. The geographic latitude is measured in degrees north or south
     * of the Earth equator.
     * <br/>
     * <img src="../doc/images/earth.jpg" width="200px"/>
     * <br/>
     * WGS84Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = CRS:84</li>
     *     <li>radius = 1</li>
     *     <li>realPlanetRadius = 6378137 meters</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var WGS84Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.WGS84,
            radius: 1.0,
            realPlanetRadius: 6378137,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, WGS84Crs);

    /**************************************************************************************************************/

    /**
     * Formats the coordinates (longitude, latitude) as (x.xxx&deg, y.yyy&deg).
     * @function formatCoordinates
     * @memberof WGS84Crs#
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the formatted chain
     */
    WGS84Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof WGS84Crs#
     * Do nothing
     * @param posWorld
     * @private
     */
    WGS84Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof WGS84Crs#
     * @param posWorld
     * @private
     */
    WGS84Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getName = function() {
        return Constants.CRS.WGS84;
    };

    /**
     * @function getDescription
     * @memberof WGS84Crs#
     */
    WGS84Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return WGS84Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Mars2000Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in " +
        "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
        "north or south of the Mars equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name Mars2000Crs
     * @class
     * Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in which the
     * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
     * of the Mars equator.
     * <br/>
     * Mars2000Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU2000:49901</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 3396190</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var Mars2000Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Mars_2000,
            radius: 1.0,
            realPlanetRadius: 3396190,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, Mars2000Crs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof Mars2000Crs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    Mars2000Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof Mars2000Crs
     * @private
     */
    Mars2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof Mars2000Crs
     * @private
     */
    Mars2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getName = function() {
        return Constants.CRS.Mars_2000;
    };

    /**
     * @function getDescription
     * @memberof Mars2000Crs#
     */
    Mars2000Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return Mars2000Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Moon2000Crs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in " +
        "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
        "north or south of the Moon equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name Moon2000Crs
     * @class
     * Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in which the
     * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
     * of the Moon equator.
     * <br/>
     * Moon2000Crs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU2000:30101</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 1737400</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var Moon2000Crs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Moon_2000,
            radius: 1.0,
            realPlanetRadius: 1737400,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, Moon2000Crs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof Moon2000Crs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    Moon2000Crs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof Moon2000Crs
     * @private
     */
    Moon2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof Moon2000Crs
     * @private
     */
    Moon2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getName = function() {
        return Constants.CRS.Moon_2000;
    };

    /**
     * @function getDescription
     * @memberof Moon2000Crs#
     */
    Moon2000Crs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return Moon2000Crs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * A coordinate reference system is a coordinate system that is related to an object
 * by a {@link module:Crs.Geoide geodetic datum}.
 * Mizar currently supports the following coordinates reference systems :
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/equatorial.png" width="200px"/></td>
 *         <td>{@link module:Crs.EquatorialCrs EquatorialCrs}</td>
 *         <td>Provides an equatorial coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/galactic.png" width="200px"/></td>
 *         <td>{@link module:Crs.GalacticCrs GalacticCrs}</td>
 *         <td>Provides a galactic coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.Mars2000Crs Mars2000Crs}</td>
 *         <td>Provides a coordinate reference system base on the Mars geoide</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/earth.jpg" width="200px"/></td>
 *         <td>{@link module:Crs.WGS84Crs WGS84Crs}</td>
 *         <td>Provides a coordinate reference system base on the Earth geoide</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.ProjectedCrs ProjectedCrs}</td>
 *         <td>Provides a projected coordinate reference system on a map</td>
 *     </tr>
 * </table>
 * <br/>
 * In addition to the classes, a {@link module:Crs.CoordinateSystemFactory factory} is available to help for creating
 * coordinate reference system. Once the coordinate reference system is created, the client can handle it by the use of its
 * {@link Crs interface}.
 *
 * @module Crs
 * @implements {Crs}
 */
define('Crs/EquatorialCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractCrs, GeoBound, Utils, Constants) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which a celestial object's position on the celestial " +
        "sphere is described in terms of its declination and right ascension, measured with respect to the celestial " +
        "equator. Declination and right ascension correspond directly to geographic latitude and longitude as " +
        "projected outward onto the celestial sphere. Declination is measured in degrees north or south of the " +
        "celestial equator but right ascension  is measured in hours, minutes, and seconds eastward along the " +
        "celestial equator from the point of the vernal equinox. Because the celestial equator moves among the fixed " +
        "stars with the precession of the Earth's poles, an object's declination and right ascension change " +
        "gradually over time, and coordinates in the equatorial system must be specified for particular years. By " +
        "Default J2000 is used";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "&alpha;";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "&delta;";

    /**
     * @name EquatorialCrs
     * @class
     * System in which a celestial object's position on the celestial
     * sphere is described in terms of its declination and right ascension, measured with respect to the celestial equator.
     * Declination and right ascension correspond directly to geographic latitude and longitude as projected outward onto
     * the celestial sphere. Declination is measured in degrees north or south of the celestial equator but right ascension
     * is measured in hours, minutes, and seconds eastward along the celestial equator from the point of the vernal equinox.
     * Because the celestial equator moves among the fixed stars with the precession of the Earth's poles, an object's
     * declination and right ascension change gradually over time, and coordinates in the equatorial system must be
     * specified for particular years.
     * <br/>
     * <i>source : equatorial coordinate system. Dictionary.com. The American Heritage Science Dictionary.
     * Houghton Mifflin Company. http://www.dictionary.com/browse/equatorial-coordinate-system (accessed: March 5, 2017).</i>
     * <br/>
     * <img src="../doc/images/equatorial.png"/>
     * <br/>
     * EquatorialCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = Equatorial</li>
     *     <li>radius = 10.0</li>
     *     <li>realPlanetRadius = 1.0</li>
     *     <li>type = Sky</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param {Object} options - No option to give
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Equatorial_coordinate_system Wikipedia}
     * @memberof module:Crs
     */
    var EquatorialCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Equatorial,
            radius: 10.0,
            realPlanetRadius: 1.0,
            type: Constants.CONTEXT.Sky,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, EquatorialCrs);

    /**************************************************************************************************************/

    /**
     * @function transformVec
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.transformVec = function(vec) {
        var transformMatrix = this.computeTransformMatrix();
        var res = [];
        mat4.multiplyVec3(transformMatrix, vec, res);
        return res;
    };

    /**
     * @function computeTransformMatrix
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.computeTransformMatrix = function() {
        var transformMatrix = [];

        var galNorth = this.convert(
            [0, 90],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DNorth = this.fromGeoTo3D(galNorth);

        var galCenter = this.convert(
            [0, 0],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DCenter = this.fromGeoTo3D(galCenter);

        var galEast = this.convert(
            [90, 0],
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        var gal3DEast = this.fromGeoTo3D(galEast);

        transformMatrix[0] = gal3DCenter[0];
        transformMatrix[1] = gal3DCenter[1];
        transformMatrix[2] = gal3DCenter[2];
        transformMatrix[3] = 0.0;
        transformMatrix[4] = gal3DEast[0];
        transformMatrix[5] = gal3DEast[1];
        transformMatrix[6] = gal3DEast[2];
        transformMatrix[7] = 0.0;
        transformMatrix[8] = gal3DNorth[0];
        transformMatrix[9] = gal3DNorth[1];
        transformMatrix[10] = gal3DNorth[2];
        transformMatrix[11] = 0.0;
        transformMatrix[12] = 0.0;
        transformMatrix[13] = 0.0;
        transformMatrix[14] = 0.0;
        transformMatrix[15] = 1.0;

        return transformMatrix;
    };

    /**
     * @function formatCoordinates
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.formatCoordinates = function(geo) {
        var sexa = this.getSexagesimalFromDeg(geo);
        var dest = [];
        dest[0] = this.getLongitudeLabel() + " = " + sexa[0];
        dest[1] = this.getLatitudeLabel() + " = " + sexa[1];
        return dest;
    };

    /**
     * @function getLongitudeLabel
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof EquatorialCrs#
     * @private
     */
    EquatorialCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] += 360.0;
        }
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof EquatorialCrs#
     * @private
     */
    EquatorialCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        if (posWorld[0] > 180) {
            posWorld[0] -= 360.0;
        }
    };

    /**
     * @function getName
     * @memberof EquatorialCrs#
     */
    EquatorialCrs.prototype.getName = function() {
        return Constants.CRS.Equatorial;
    };

    /**
     * @function getDescription
     * @memberof EquatorialCrs#
     * @abstract
     */
    EquatorialCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    /**************************************************************************************************************/

    return EquatorialCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/GalacticCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which a celestial object's position on the celestial sphere is described in " +
        "relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured along the " +
        "galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way. The " +
        "galactic equator, also called the galactic circle, is inclined at an angle of approximately 62 to the " +
        "celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in " +
        "the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line " +
        "through the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic " +
        "latitude is measured in degrees north or south of the galactic equator toward the galactic poles.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "l";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "b";

    /**
     * @name GalacticCrs
     * @class
     * System in which a celestial object's position on the celestial
     * sphere is described in relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured
     * along the galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way.
     * The galactic equator, also called the galactic circle, is inclined at an angle of approximately 62 to the
     * celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in
     * the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line through
     * the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic latitude is
     * measured in degrees north or south of the galactic equator toward the galactic poles.
     * <br/>
     * <i>source : galactic coordinate system. Dictionary.com. The American Heritage Science Dictionary.
     * Houghton Mifflin Company. http://www.dictionary.com/browse/galactic-coordinate-system (accessed: March 5, 2017).</i>
     * <br/>
     * <img src="../doc/images/galactic.png"/>
     * <br/>
     * GalacticCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = Galactic</li>
     *     <li>radius = 10.0</li>
     *     <li>realPlanetRadius = 1.0</li>
     *     <li>type = Sky</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - no option to give.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Galactic_coordinate_system Wikipedia}
     * @memberof module:Crs
     */
    var GalacticCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Galactic,
            radius: 10.0,
            realPlanetRadius: 1.0,
            type: Constants.CONTEXT.Sky,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, GalacticCrs);

    /**************************************************************************************************************/

    /**
     * @function formatCoordinates
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        astro[0] =
            this.getLongitudeLabel() + " = " + Numeric.roundNumber(geo[0], 3);
        astro[0] += "&deg;";
        astro[1] =
            this.getLatitudeLabel() + " = " + Numeric.roundNumber(geo[1], 3);
        astro[1] += "&deg;";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * @function _setupPosAfterTrans
     * @memberof GalacticCrs#
     * @private
     */
    GalacticCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] += 360.0;
        }
        posWorld = this.convert(
            posWorld,
            Constants.CRS.Equatorial,
            Constants.CRS.Galactic
        );
    };

    /**
     * @function _setupPosBeforeTrans
     * @memberof GalacticCrs#
     * @rpivate
     */
    GalacticCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        posWorld = this.convert(
            posWorld,
            Constants.CRS.Galactic,
            Constants.CRS.Equatorial
        );
        if (posWorld[0] > 180) {
            posWorld[0] -= 360.0;
        }
    };

    /**
     * @function getName
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getName = function() {
        return Constants.CRS.Galactic;
    };

    /**
     * @function getName
     * @memberof GalacticCrs#
     */
    GalacticCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return GalacticCrs;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/AbstractProjection',["../Renderer/GeoBound"], function(GeoBound) {
    /**
     * Base projection configuration
     * @typedef {Object} AbstractProjection.configuration
     * @property {PROJECTION} projectionName - Name of the projection
     */

    /**
     * @name AbstractProjection
     * @class
     *   Abstract class for projections.
     * A map projection is one of many methods used to represent the 3-dimensional surface of the earth or other round body
     * on a 2-dimensional plane in cartography. The creation of a map projection involves two steps :
     * <ul>
     *     <li>selection of a model for the shape of the body (choosing between a sphere or ellipsoid),</li>
     *     <li>transform planetographic coordinates to plane coordinates.</li>
     * </ul>
     * @param {float[]} projectionCenter - the projection center as (longitude, latitude)
     * @param {float[]} geoBound - Geo boundary as [minLongitude, minLatitude, maxLongitude, maxLatitude]
     * @param {AbstractProjection.configuration} options - Not used currently
     * @constructor
     * @implements {Projection}
     */
    var AbstractProjection = function(projectionCenter, geoBound, options) {
        this.geoBound = new GeoBound(
            geoBound[0],
            geoBound[1],
            geoBound[2],
            geoBound[3]
        );
        this.projectionCenter = projectionCenter;
        this.options = options || {};
    };

    /**
     * @function getProjectionCenter
     * @memberof AbstractProjection#
     */
    AbstractProjection.prototype.getProjectionCenter = function() {
        return this.projectionCenter;
    };

    /**
     * @function getGeoBound
     * @memberof AbstractProjection#
     */
    AbstractProjection.prototype.getGeoBound = function() {
        return this.geoBound;
    };

    /**
     * @function unProject
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.unProject = function(position3d, dest) {
        throw new SyntaxError(
            "unProject not implemented",
            "AbstractProjection.js"
        );
    };

    /**
     * @function project
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.project = function(geoPos, dest) {
        throw new SyntaxError(
            "project not implemented",
            "AbstractProjection.js"
        );
    };

    /**
     * @function getName
     * @memberof AbstractProjection#
     * @abstract
     */
    AbstractProjection.prototype.getName = function() {
        throw new SyntaxError(
            "getName not implemented",
            "AbstractProjection.js"
        );
    };

    /**************************************************************************************************************/

    return AbstractProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of projection, which is used to represent a planet on a 2D map.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/aitoff.png" width="200px"/></td>
 *         <td>{@link module:Projection.AitoffProjection AitoffProjection}</td>
 *         <td>Provides a AITOFF projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/august.png" width="200px"/></td>
 *         <td>{@link module:Projection.AugustProjection AugustProjection}</td>
 *         <td>Provides an august projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/azimuth.png" width="200px"/></td>
 *         <td>{@link module:Projection.AzimuthProjection AzimuthProjection}</td>
 *         <td>Provides an azimuth projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mercator.png" width="200px"/></td>
 *         <td>{@link module:Projection.MercatorProjection MercatorProjection}</td>
 *         <td>Provides a mercator projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mollweide.png" width="200px"/></td>
 *         <td>{@link module:Projection.MollweideProjection MollweideProjection}</td>
 *         <td>Provides a mollweide projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/platecarr.png" width="200px"/></td>
 *         <td>{@link module:Projection.PlateProjection PlateProjection}</td>
 *         <td>Provides a plate carre projection</td>
 *     </tr>
 * </table>
 *
 * The projection is automatically instantiated by the {@link module:Crs.ProjectedCrs ProjectedCrs} class.
 * @module Projection
 * @implements {Projection}
 */
define('Projection/AitoffProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name AitoffProjection
     * @class
     *    The Aitoff coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     *  <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     *  <li>a projection : the Aitoff projection.</li>
     * </ul>
     *
     * The Aitoff projection is a modified azimuthal map projection first proposed by David A. Aitoff in 1889.
     * Based on the equatorial form of the azimuthal equidistant projection, Aitoff halved longitudes from the central
     * meridian, projected by the azimuthal equidistant, and then stretched the result horizontally into a 2:1 ellipse.
     * <img src="../doc/images/aitoff.png" width="200px"/>
     *
     *
     * @see {@link https://en.wikipedia.org/wiki/Aitoff_projection}
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - Aitoff projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AitoffProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AitoffProjection);

    /**************************************************************************************************************/

    /**
     *    Inverse sampling function(sinc)
     */
    var _sinci = function(x) {
        return x ? x / Math.sin(x) : 1;
    };

    /**
     * @function unProject
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var epsilon = 0.005;
        var deltaLambda;
        var deltaPhi;
        // Abort if [x, y] is not within an ellipse centered at [0, 0] with
        // semi-major axis pi and semi-minor axis pi/2.
        if (
            position3d[0] * position3d[0] + 4 * position3d[1] * position3d[1] >
            Math.PI * Math.PI + epsilon
        ) {
            return;
        }

        var lambda = position3d[0],
            phi = position3d[1],
            i = 25;

        do {
            var sinLambda = Math.sin(lambda),
                sinLambda_2 = Math.sin(lambda / 2),
                cosLambda_2 = Math.cos(lambda / 2),
                sinPhi = Math.sin(phi),
                cosPhi = Math.cos(phi),
                sin_2phi = Math.sin(2 * phi),
                sin2phi = sinPhi * sinPhi,
                cos2phi = cosPhi * cosPhi,
                sin2lambda_2 = sinLambda_2 * sinLambda_2,
                F,
                C = 1 - cos2phi * cosLambda_2 * cosLambda_2,
                E = C
                    ? Math.acos(cosPhi * cosLambda_2) * Math.sqrt((F = 1 / C))
                    : (F = 0),
                fx = 2 * E * cosPhi * sinLambda_2 - position3d[0],
                fy = E * sinPhi - position3d[1],
                deltaXLambda =
                    F *
                    (cos2phi * sin2lambda_2 +
                        E * cosPhi * cosLambda_2 * sin2phi),
                deltaXPhi =
                    F *
                    (0.5 * sinLambda * sin_2phi - E * 2 * sinPhi * sinLambda_2),
                deltaYLambda =
                    F *
                    0.25 *
                    (sin_2phi * sinLambda_2 - E * sinPhi * cos2phi * sinLambda),
                deltaYPhi =
                    F * (sin2phi * cosLambda_2 + E * sin2lambda_2 * cosPhi),
                denominator =
                    deltaXPhi * deltaYLambda - deltaYPhi * deltaXLambda;
            if (!denominator) {
                break;
            }
            deltaLambda = (fy * deltaXPhi - fx * deltaYPhi) / denominator;
            deltaPhi = (fx * deltaYLambda - fy * deltaXLambda) / denominator;
            lambda -= deltaLambda;
            phi -= deltaPhi;
        } while (
            (Math.abs(deltaLambda) > epsilon || Math.abs(deltaPhi) > epsilon) &&
            --i > 0
        );

        dest[0] = (lambda * 180) / Math.PI;
        dest[1] = (phi * 180) / Math.PI;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var phi = (geoPos[1] * Math.PI) / 180; // latitude

        var cosPhi = Math.cos(phi);
        var sinciAlpha = _sinci(Math.acos(cosPhi * Math.cos((lambda /= 2))));

        dest[0] = 2 * cosPhi * Math.sin(lambda) * sinciAlpha;
        dest[1] = Math.sin(phi) * sinciAlpha;
        dest[2] = geoPos[2];

        // Triple winkel: mode
        // TODO: inverse
        // dest[0] = (dest[0] + lambda / Math.PI/2) / 2;
        // dest[1] = (dest[1] + phi) / 2;

        return dest;
    };

    /**
     * @function getName
     * @memberof AitoffProjection#
     */
    AitoffProjection.prototype.getName = function() {
        return Constants.PROJECTION.Aitoff;
    };

    /**************************************************************************************************************/

    return AitoffProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/AugustProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name AugustProjection
     * @class
     *    The August coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the August projection.</li>
     * </ul>
     * <img src="../doc/images/august.png" width="200px">
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - August projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AugustProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AugustProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof AugustProjection#
     * @throws "must be implemented"
     */
    AugustProjection.prototype.unProject = function(position3d, dest) {
        throw new SyntaxError("must be implemented");
    };

    /**
     * @function project
     * @memberof AugustProjection#
     */
    AugustProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var phi = (geoPos[1] * Math.PI) / 180; // latitude

        var tanPhi = Math.tan(phi / 2),
            k = Math.sqrt(1 - tanPhi * tanPhi),
            c = 1 + k * Math.cos((lambda /= 2)),
            x = (Math.sin(lambda) * k) / c,
            y = tanPhi / c,
            x2 = x * x,
            y2 = y * y;

        dest[0] = (4 / 3) * x * (3 + x2 - 3 * y2);
        dest[1] = (4 / 3) * y * (3 + 3 * x2 - y2);
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof AugustProjection#
     */
    AugustProjection.prototype.getName = function() {
        return Constants.PROJECTION.August;
    };

    /**************************************************************************************************************/

    return AugustProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/MercatorProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * Mercator projection configuration
     * @typedef {AbstractProjection.configuration} AbstractProjection.mercator_configuration
     * @property {float} [lambda0 = 0.0] - the longitude of an arbitrary central meridian usually(but not always) Greenwich, in degrees
     * (default value is 0)
     */

    /**
     * @name MercatorProjection
     * @class
     *    The Mercator coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoide, which is set as parameter of the options object,</li>
     * <li>a projection : the Mercator projection.</li>
     * </ul>
     * The Mercator projection is a cylindrical map projection presented by the Flemish geographer and cartographer
     * Gerardus Mercator in 1569. It became the standard map projection for nautical purposes because of its ability to
     * represent lines of constant course<br/>
     * <img src="../doc/images/mercator.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.mercator_configuration} [options] - Mercator projection configuration.
     * @see {@link https://en.wikipedia.org/wiki/Mercator_projection}
     * @constructor
     * @memberof module:Projection
     */
    var MercatorProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -80, 180, 84],
            options
        );
        this.lambda0 = options && options.lambda0 ? options.lambda0 : 0.0; // Greenwich (i.e., zero)
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, MercatorProjection);

    /**************************************************************************************************************/

    /**
     *  Hyperbolic sine
     */
    var _sinh = function(x) {
        var expY = Math.exp(x);
        return (expY - 1 / expY) / 2;
    };

    /**
     * @function unProject
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        dest[0] = this.lambda0 + (position3d[0] * 180) / Math.PI;
        dest[1] = (Math.atan(_sinh(position3d[1])) * 180) / Math.PI;
        dest[2] = position3d[2];

        if (Math.abs(dest[1]) > 85.05) return null;

        return dest;
    };

    /**
     * @function project
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        // Clamp latitude values, since mercator converges to infinity at poles
        if (geoPos[1] > 85.05) {
            geoPos[1] = 85.05;
        }
        if (geoPos[1] < -85.05) {
            geoPos[1] = -85.05;
        }

        var longInRad = (geoPos[0] * Math.PI) / 180; // longitude
        var latInRad = (geoPos[1] * Math.PI) / 180; // latitude

        var x = longInRad - (this.lambda0 * Math.PI) / 180;
        var y = Math.log(Math.tan(latInRad) + 1 / Math.cos(latInRad));

        dest[0] = x;
        dest[1] = y;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof MercatorProjection#
     */
    MercatorProjection.prototype.getName = function() {
        return Constants.PROJECTION.Mercator;
    };

    /**************************************************************************************************************/

    return MercatorProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/MollweideProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name MollweideProjection
     * @class
     *    The Mollweide coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Mollweide projection.</li>
     * </ul>
     * The Mollweide projection is an equal-area, pseudocylindrical map projection generally used for global maps of
     * the world or night sky.<br/>
     * <img src="../doc/images/mollweide.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - No options.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
     * @memberof module:Projection
     */
    var MollweideProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, MollweideProjection);

    /**************************************************************************************************************/

    /**
     *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
     *  @see https://en.wikipedia.org/wiki/Mollweide_projection
     */
    function _findTheta(lat) {
        // Avoid divide by zero
        if (Math.abs(lat) === Math.PI / 2) {
            return lat;
        }

        var epsilon = 0.001;
        var thetaN = lat; // n
        var thetaN1; // n+1

        do {
            var twoThetaN = 2 * thetaN;
            thetaN = thetaN1;
            if (!thetaN) {
                thetaN = lat;
            }
            thetaN1 =
                twoThetaN / 2 -
                (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) /
                    (2 + 2 * Math.cos(twoThetaN));
        } while (Math.abs(thetaN1 - thetaN) >= epsilon);

        return thetaN1;
    }

    /**
     * @function unProject
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var auxTheta = Math.asin(position3d[1] / Math.sqrt(2));
        var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
        var lambda =
            (Math.PI * position3d[0]) / (2 * Math.sqrt(2) * Math.cos(auxTheta));

        dest[0] = (lambda * 180) / Math.PI;
        dest[1] = (phi * 180) / Math.PI;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var theta0 = (geoPos[1] * Math.PI) / 180; // latitude
        var auxTheta = _findTheta(theta0);

        // Transfrom to Mollweide coordinate system
        var mollX =
            ((2 * Math.sqrt(2)) / Math.PI) * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        dest[0] = mollX;
        dest[1] = mollY;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof MollweideProjection#
     */
    MollweideProjection.prototype.getName = function() {
        return Constants.PROJECTION.Mollweide;
    };

    /**************************************************************************************************************/

    return MollweideProjection;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/PlateProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * @name PlateProjection
     * @class
     *    The Plate coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Plate carre projection.</li>
     * </ul>
     * <img src="../doc/images/platecarr.png" width="200px"/>
     * @augments AbstractProjection
     * @param {AbstractProjection.configuration} [options] - No options.
     * @constructor
     * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
     * @memberof module:Projection
     */
    var PlateProjection = function(options) {
        AbstractProjection.prototype.constructor.call(
            this,
            [0, 0],
            [-180, -90, 180, 90],
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, PlateProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.unProject = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = (position3d[0] * 180) / Math.PI;
        dest[1] = (position3d[1] * 180) / Math.PI;
        dest[2] = position3d[2];

        return dest;
    };

    /**
     * @function project
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = (geoPos[0] * Math.PI) / 180;
        dest[1] = (geoPos[1] * Math.PI) / 180;
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof PlateProjection#
     */
    PlateProjection.prototype.getName = function() {
        return Constants.PROJECTION.Plate;
    };

    /**************************************************************************************************************/

    return PlateProjection;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Projection/AzimuthProjection',[
    "./AbstractProjection",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(AbstractProjection, Utils, Constants) {
    /**
     * Azimuthal projection configuration
     * @typedef {AbstractProjection.configuration} AbstractProjection.azimuth_configuration
     * @property {string} [pole = "north"] - Projection center. It can be "north" or "south"
     */

    /**
     * @name AzimuthProjection
     * @class
     *    The Azimuth coordinate system is a coordinate reference system. It is composed of :
     * <ul>
     * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
     * <li>a projection : the Azimuth projection.</li>
     * </ul>
     * <img src="../doc/images/azimuth.png" width="200px"/>
     *
     * @see {@link https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection}
     * @augments AbstractProjection
     * @param {AbstractProjection.azimuth_configuration} [options] - Azimuthal projection configuration.
     * @constructor
     * @memberof module:Projection
     */
    var AzimuthProjection = function(options) {
        this.pole = (options && options.pole) || "north";
        var geoBound;
        var projectionCenter;
        if (this.pole === "south") {
            geoBound = [-180, -90, 180, 0];
            projectionCenter = [0, -90];
        } else {
            geoBound = [-180, 0, 180, 90];
            projectionCenter = [0, 90];
            this.pole = "north";
        }
        AbstractProjection.prototype.constructor.call(
            this,
            projectionCenter,
            geoBound,
            options
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProjection, AzimuthProjection);

    /**************************************************************************************************************/

    /**
     * @function unProject
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.unProject = function(position3d, dest) {
        var p = Math.sqrt(
            position3d[0] * position3d[0] + position3d[1] * position3d[1]
        );
        var o = Math.atan2(position3d[0], -position3d[1]);

        p = (p * 180) / Math.PI;
        o = (o * 180) / Math.PI;

        o *= this.pole === "south" ? -1 : 1;

        if (p > 90) return null;

        if (!dest) {
            dest = new Array(3);
        }
        dest[0] = o;
        dest[1] = this.pole === "south" ? p - 90 : 90 - p;
        dest[2] = position3d[2];
        return dest;
    };

    /**
     * @function project
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.project = function(geoPos, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        var p = this.pole === "south" ? 90 + geoPos[1] : 90 - geoPos[1];
        p = (p * Math.PI) / 180;

        var o = (geoPos[0] * Math.PI) / 180;
        o *= this.pole === "south" ? -1 : 1;
        dest[0] = p * Math.sin(o);
        dest[1] = -p * Math.cos(o);
        dest[2] = geoPos[2];
        return dest;
    };

    /**
     * @function getName
     * @memberof AzimuthProjection#
     */
    AzimuthProjection.prototype.getName = function() {
        return Constants.PROJECTION.Azimuth;
    };

    /**************************************************************************************************************/

    return AzimuthProjection;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ProjectionFactory
 * @class
 * Factory to create a projection
 * @memberof module:Projection
 */
define('Projection/ProjectionFactory',[
    "../Utils/Constants",
    "./AitoffProjection",
    "./AugustProjection",
    "./MercatorProjection",
    "./MollweideProjection",
    "./PlateProjection",
    "./AzimuthProjection"
], function(
    Constants,
    AitoffProjection,
    AugustProjection,
    MercatorProjection,
    MollweideProjection,
    PlateProjection,
    AzimuthProjection
) {
    /**
     * Creates a projection based on the name of the projection and its options.
     * @param {PROJECTION} projectionName - Name of the projection
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options for the projection
     * @returns {Projection} projection
     * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
     * @private
     */
    function _createProjection(projectionName, options) {
        var cs;
        switch (projectionName) {
            case Constants.PROJECTION.Aitoff:
                cs = new AitoffProjection(options);
                break;
            case Constants.PROJECTION.August:
                cs = new AugustProjection(options);
                break;
            case Constants.PROJECTION.Azimuth:
                cs = new AzimuthProjection(options);
                break;
            case Constants.PROJECTION.Mercator:
                cs = new MercatorProjection(options);
                break;
            case Constants.PROJECTION.Mollweide:
                cs = new MollweideProjection(options);
                break;
            case Constants.PROJECTION.Plate:
                cs = new PlateProjection(options);
                break;
            default:
                throw new RangeError(
                    "Unable to create the projection " + options.projectionName,
                    "ProjectionFactory.js"
                );
        }
        return cs;
    }

    return {
        /**
         * Create a projection
         * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options.
         * @return {Projection}
         * @throws {ReferenceError} Will throw when options.projectionName is not defined
         * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
         * @alias module:Projection.ProjectionFactory.create
         */
        create: function(options) {
            var cs;

            if (options && options.projectionName) {
                cs = _createProjection(options.projectionName, options);
            } else {
                throw new ReferenceError(
                    "Unable to get options.projectionName",
                    "ProjectionFactory.js"
                );
            }

            return cs;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/ProjectedCrs',[
    "./AbstractCrs",
    "../Utils/Utils",
    "../Projection/ProjectionFactory",
    "../Renderer/glMatrix"
], function(AbstractCrs, Utils, ProjectionFactory) {
    /**
     * ProjectedCrs configuration
     * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
     * @property {CRS} geoideName - name of the coordinate reference system
     * @property {CONTEXT} type - Type of the CRS
     * @property {GeoBound} geoBound - Geographical bounding box
     */

    /**
     * @name ProjectedCrs
     * @class
     * A coordinate reference system projected on a 2D map.
     * @augments AbstractCrs
     * @param {Crs} cs - coordinate reference system
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - projection configuration
     * @constructor
     * @memberof module:Crs
     * @throws {ReferenceError} Will throw when options.projectionName is not defined
     * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
     */
    var ProjectedCrs = function(cs, options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: cs.getGeoideName(),
            radius: cs.getGeoide().getRadius(),
            realPlanetRadius: cs.getGeoide().getRealPlanetRadius(),
            type: cs.getType(),
            geoBound: cs.getGeoBound()
        });
        this.cs = cs;
        this.projection = ProjectionFactory.create(options);
        this.geoBound.setWest(this.projection.getGeoBound().getWest());
        this.geoBound.setSouth(this.projection.getGeoBound().getSouth());
        this.geoBound.setEast(this.projection.getGeoBound().getEast());
        this.geoBound.setNorth(this.projection.getGeoBound().getNorth());
        this.flat = true;
    };
    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, ProjectedCrs);

    /**************************************************************************************************************/

    /**
     * Formats the coordinates
     * @function formatCoordinates
     * @memberof ProjectedCrs
     * @param geo the spatial position in degrees
     * @return {string[]} the format coordinates of the geoide given in parameter
     */
    ProjectedCrs.prototype.formatCoordinates = function(geo) {
        return this.cs.formatCoordinates(geo);
    };

    /**
     * @function getLongitudeLabel
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getLongitudeLabel = function() {
        return this.cs.getLongitudeLabel();
    };

    /**
     * @function getLatitudeLabel
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getLatitudeLabel = function() {
        return this.cs.getLatitudeLabel();
    };

    /**
     * Returns the physical position in degrees.
     * @function getWorldFrom3D
     * @memberof ProjectedCrs
     * @param position3d the position in 3D
     * @param {float[]} dest the physical position
     * @return {float[]} the physical position
     */
    ProjectedCrs.prototype.getWorldFrom3D = function(position3d, dest) {
        if (!dest) {
            dest = new Array(3);
        }
        this.projection.unProject(position3d, dest);
        this.cs._setupPosAfterTrans(dest);
        dest[2] = dest[2] / this.geoide.getHeightScale();
        return dest;
    };

    /**
     * Returns the 3D position from physical position
     * @param posWorld physical position
     * @param {float[]}dest the 3D position
     * @return {float[]} the 3D position
     */
    ProjectedCrs.prototype.get3DFromWorld = function(posWorld, dest) {
        if (!dest) {
            dest = vec3.create();
        }
        var pos = posWorld.slice(0);
        this.cs._setupPosBeforeTrans(pos);
        this.projection.project(pos, dest);
        dest[2] = dest[2] ? dest[2] * this.geoide.getHeightScale() : 0.0;
        return dest;
    };

    /**
     * Returns the local transformation
     * @function getLocalTransform
     * @memberof ProjectedCrs#
     * @param {Array} geo
     * @param {Array} dest
     * @return {Array} dest Matrix as 16 values
     */
    ProjectedCrs.prototype.getLocalTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        mat4.identity(dest);
        return dest;
    };

    /**************************************************************************************************************/

    /**
     * Returns the LHV transformation
     * @function getLHVTransform
     * @memberof ProjectedCrs
     * @param {Array} geo
     * @param {Array} dest
     * @return {Array} dest Matrix as 16 values
     */
    ProjectedCrs.prototype.getLHVTransform = function(geo, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var pt = this.projection.project(geo);
        mat4.identity(dest);
        dest[12] = pt[0];
        dest[13] = pt[1];
        dest[14] = pt[2] ? pt[2] * this.geoide.getHeightScale() : 0.0;
        dest[15] = 1.0;
        return dest;
    };

    /**
     * Returns the projection.
     * @function getProjection
     * @memberof ProjectedCrs
     * @returns {AbstractProjection} the used projection
     */
    ProjectedCrs.prototype.getProjection = function() {
        return this.projection;
    };

    /**
     * @function getName
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getName = function() {
        return this.cs.getName();
    };

    /**
     * @function getDescription
     * @memberof ProjectedCrs#
     */
    ProjectedCrs.prototype.getDescription = function() {
        return this.cs.getDescription();
    };

    /**
     * @function isProjected
     * @memberof ProjectedCrs#
     * @return {boolean} true.
     */
    ProjectedCrs.prototype.isProjected = function() {
        return true;
    };

    return ProjectedCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/HorizontalLocalCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "System in which an local object's position is described in the observer's local horizon." +
        "It is expressed in terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90 " +
        "(nadir) to 90 (zenith) but azimuth is measured in degrees eastward along the horizon from the North";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Az";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Alt";

    /**
     * @name HorizontalLocalCrs
     * @class
     * System in which an local object's position is described in the observer's local horizon. It is expressed in
     * terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90 (nadir) to 90 (zenith)
     * but azimuth is measured in degrees eastward along the horizon from the North.
     * <br/>
     * HorizontalLocalCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = HorizontalLocal</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 1</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var HorizontalLocalCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.HorizontalLocal,
            radius: 1.0,
            realPlanetRadius: 1,
            type: Constants.CONTEXT.Ground,
            geoBound: new GeoBound(0, -90, 360, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, HorizontalLocalCrs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof HorizontalLocalCrs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    HorizontalLocalCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var azimuth = Numeric.roundNumber(geo[0], 3);
        var altitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLongitudeLabel() + " = " + azimuth;
        astro[0] += "&deg;";
        astro[1] = this.getLatitudeLabel() + " = " + altitude;
        astro[1] += "&deg;";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof HorizontalLocalCrs
     * @private
     */
    HorizontalLocalCrs.prototype._setupPosAfterTrans = function(posWorld) {
        if (posWorld[0] < 0) {
            posWorld[0] = -1 * posWorld[0];
        } else {
            posWorld[0] = 360 - posWorld[0];
        }
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof HorizontalLocalCrs
     * @private
     */
    HorizontalLocalCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        if (posWorld[0] < 180) {
            posWorld[0] = -1 * posWorld[0];
        } else {
            posWorld[0] = 360 - posWorld[0];
        }
    };

    /**
     * @function getName
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getName = function() {
        return Constants.CRS.HorizontalLocal;
    };

    /**
     * @function getDescription
     * @memberof HorizontalLocalCrs#
     */
    HorizontalLocalCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return HorizontalLocalCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/SunCrs',[
    "./AbstractCrs",
    "../Renderer/GeoBound",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Utils/Numeric"
], function(AbstractCrs, GeoBound, Utils, Constants, Numeric) {
    /**
     * @constant
     * @type {string}
     */
    const DESCRIPTION =
        "Sun coordinate Reference System is a coordinate system using the Sun sphere and in " +
        "which the heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees " +
        "north or south of the Sun equator.";

    /**
     * @constant
     * @type {string}
     */
    const LONGITUDE_LABEL = "Long";

    /**
     * @constant
     * @type {string}
     */
    const LATITUDE_LABEL = "Lat";

    /**
     * @name SunCrs
     * @class
     * Sun  coordinate Reference System is a coordinate system using the Sun sphere and in which the
     * heliocentric longitude increases to the east. The heliocentric latitude is measured in degrees north or south
     * of the Sun equator.
     * <br/>
     * SunCrs is initialized with the following parameters :
     * <ul>
     *     <li>geoideName = IAU:Sun</li>
     *     <li>radius = 1.0</li>
     *     <li>realPlanetRadius = 696342000</li>
     *     <li>type = Planet</li>
     *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
     * </ul>
     * @augments AbstractCrs
     * @param options - No option to give.
     * @constructor
     * @memberof module:Crs
     */
    var SunCrs = function(options) {
        AbstractCrs.prototype.constructor.call(this, {
            geoideName: Constants.CRS.Sun,
            radius: 1.0,
            realPlanetRadius: 696342000,
            type: Constants.CONTEXT.Planet,
            geoBound: new GeoBound(-180, -90, 180, 90)
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractCrs, SunCrs);

    /**************************************************************************************************************/

    /**
     * Formats coordinates as (x.xxx N, y.yyy E).
     * @function formatCoordinates
     * @memberof SunCrs
     * @param {float[]} geo the spatial position in degree
     * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
     */
    SunCrs.prototype.formatCoordinates = function(geo) {
        var astro = [];
        var longitude = Numeric.roundNumber(geo[0], 3);
        var latitude = Numeric.roundNumber(geo[1], 3);
        astro[0] = this.getLatitudeLabel() + " = ";
        astro[0] += latitude >= 0 ? latitude + " N" : -1.0 * latitude + " S";
        astro[1] = this.getLongitudeLabel() + " = ";
        astro[1] += longitude >= 0 ? longitude + " E" : -1.0 * longitude + " W";
        return astro;
    };

    /**
     * @function getLongitudeLabel
     * @memberof SunCrs#
     */
    SunCrs.prototype.getLongitudeLabel = function() {
        return LONGITUDE_LABEL;
    };

    /**
     * @function getLatitudeLabel
     * @memberof SunCrs#
     */
    SunCrs.prototype.getLatitudeLabel = function() {
        return LATITUDE_LABEL;
    };

    /**
     * Do nothing
     * @function _setupPosAfterTrans
     * @memberof SunCrs#
     * @private
     */
    SunCrs.prototype._setupPosAfterTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * Do nothing
     * @function _setupPosBeforeTrans
     * @memberof SunCrs#
     * @private
     */
    SunCrs.prototype._setupPosBeforeTrans = function(posWorld) {
        //Do Nothing
    };

    /**
     * @function getName
     * @memberof SunCrs#
     */
    SunCrs.prototype.getName = function() {
        return Constants.CRS.Sun;
    };

    /**
     * @function getDescription
     * @memberof SunCrs#
     */
    SunCrs.prototype.getDescription = function() {
        return DESCRIPTION;
    };

    return SunCrs;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name CoordinateSystemFactory
 * @class
 * Factory to create a coordinate reference system
 * @memberof module:Crs
 */
define('Crs/CoordinateSystemFactory',[
    "../Utils/Constants",
    "./WGS84Crs",
    "./Mars2000Crs",
    "./Moon2000Crs",
    "./EquatorialCrs",
    "./GalacticCrs",
    "./ProjectedCrs",
    "./HorizontalLocalCrs",
    "./SunCrs"
], function(
    Constants,
    WGS84Crs,
    Mars2000Crs,
    Moon2000Crs,
    EquatorialCrs,
    GalacticCrs,
    ProjectedCrs,
    HorizontalLocalCrs,
    SunCrs
) {
    /**
     * Creates a coordinate reference system based on its geoide name and its options.
     * @param {CRS} geoideName
     * @param {AbstractCrs.crsFactory} options - options to create a coordinate reference system
     * @returns {Crs} the created coordinate reference system
     * @throws {RangeError} Will throw an error when geoideName  is not part of {@link CRS}
     * @private
     */
    function _createCrs(geoideName, options) {
        var cs;
        switch (geoideName) {
            case Constants.CRS.Equatorial:
                cs = new EquatorialCrs(options);
                break;
            case Constants.CRS.Galactic:
                cs = new GalacticCrs(options);
                break;
            // For Earth
            case Constants.CRS.WGS84:
                cs = new WGS84Crs(options);
                break;
            // For Mars
            case Constants.CRS.Mars_2000_old:
            case Constants.CRS.Mars_2000:
                cs = new Mars2000Crs(options);
                break;
            // For Moon
            case Constants.CRS.Moon_2000_old:
            case Constants.CRS.Moon_2000:
                cs = new Moon2000Crs(options);
                break;
            // For Ground
            case Constants.CRS.HorizontalLocal:
                cs = new HorizontalLocalCrs(options);
                break;
            // For Sun
            case Constants.CRS.Sun:
                cs = new SunCrs(options);
                break;
            // Unknown geoide name
            default:
                throw new RangeError(
                    "Datum " + geoideName + " not implemented",
                    "CoordinateSystemFactory.js"
                );
        }
        return cs;
    }

    return {
        /**
         * Data model to create a coordinate reference system through the factory
         * @typedef {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} AbstractCrs.crsFactory
         * @property {CRS} options.geoideName - name of the geoide
         */
        /**
         * Factory for CRS.
         * @param {AbstractCrs.crsFactory} options - Options to create a coordinate reference system
         * @return {Crs} Object to handle CRS
         * @alias module:Crs.CoordinateSystemFactory.create
         * @throws {ReferenceError} Will throw an error when options.geoideName is not defined
         * @throws {RangeError} Will throw an error when options.geoideName  is not part of {@link CRS}
         * @throws {RangeError} Will throw an error when options.projectionName is not part of {@link PROJECTION}
         */
        create: function(options) {
            var cs;
            if (options && options.geoideName) {
                cs = _createCrs(options.geoideName, options);
            } else {
                throw new ReferenceError(
                    "geoideName not defined in " + JSON.stringify(options),
                    "CoordinateSystemFactory.js"
                );
            }

            if (options && options.projectionName) {
                cs = new ProjectedCrs(cs, options);
            }
            return cs;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/CoordinateGridLayer',[
    "./AbstractLayer",
    "../Utils/Utils",
    "../Renderer/Ray",
    "../Renderer/Program",
    "../Tiling/Mesh",
    "../Crs/AstroCoordTransform",
    "../Renderer/FeatureStyle",
    "../Utils/Constants",
    "../Crs/CoordinateSystemFactory"
], function(
    AbstractLayer,
    Utils,
    Ray,
    Program,
    Mesh,
    AstroCoordTransform,
    FeatureStyle,
    Constants,
    CoordinateSystemFactory
) {
    /**
     *    GL Textures pool
     *    @constructor
     */
    var TexturePool = function(pgl) {
        // TODO : changement gl en pgl pour viter doublon
        var gl = pgl;
        var glTextures = [];

        /**
             Create a non power of two texture from an image
             */
        var createNewGLTexture = function(image) {
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                image
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE
            );
            return tex;
        };

        /**
             Reuse a GL texture
             */
        var reuseGLTexture = function(image) {
            var glTexture = glTextures.pop();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                image
            );
            return glTexture;
        };

        /**
             Create a GL texture
             */
        this.createGLTexture = function(image) {
            if (glTextures.length > 0) {
                return reuseGLTexture(image);
            } else {
                return createNewGLTexture(image);
            }
        };

        /**
             Dispose a GL texture
             */
        this.disposeGLTexture = function(texture) {
            glTextures.push(texture);
        };

        this.disposeAll = function() {
            for (var i = 0; i < glTextures.length; i++) {
                gl.deleteTexture(glTextures[i]);
            }
            glTextures.length = 0;
        };
    };

    /**************************************************************************************************************/

    /**
         * CoordinateGridLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.coordinateGrid_configuration
         * @property {float} [longitudeSample=15] - Longitude sampling in decimal degree
         * @property {float} [latitudeSample=10] - Latitude sampling in decimal degree
         * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - The coordinate system of the grid
         * @property {String} [longFormat="Deg"] Representation of longitude axe(HMS, DMS, Deg)
         * @property {String} [latFormat="Deg"] Representation of latitude axe(HMS, DMS, Deg)
         * @property {Integer} [tesselation=2] Tesselation order (only for latitude bands currently)
         
         * 
         */
    /**
     * @name CoordinateGridLayer
     * @class
     *    A layer for coordinate grid
     * @augments AbstractLayer
     * @param {AbstractLayer.coordinateGrid_configuration} options - coordinate grid layer configuration
     * @constructor
     * @memberof module:Layer
     */
    var CoordinateGridLayer = function(options) {
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.CoordinateGrid,
            options
        );
        this.globe = null;

        // Equatorial coordinates label renderables
        this.labels = {};

        // WebGL textures
        this.texturePool = null;

        this.longitudeSample = options.longitudeSample || 15; // *24 = 360
        this.latitudeSample = options.latitudeSample || 10; // *18 = 180

        // Canvas for generation of equatorial coordinate labels
        this.canvas2d = document.createElement("canvas");
        this.canvas2d.width = 100;
        this.canvas2d.height = 20;

        // Grid buffers
        this.vertexBuffer = null;
        this.indexBuffer = null;

        this.gridCrs = CoordinateSystemFactory.create(options.coordinateSystem);

        this.longFormat = options.longFormat ? options.longFormat : "Deg";
        this.latFormat = options.latFormat ? options.latFormat : "Deg";

        // Keep trace on geoBound
        this.geoBound = {};
        this.tesselation = options.tesselation || 2;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, CoordinateGridLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    }

    /**
     * Generates an image data from text.
     * @function generateImageData
     * @memberof CoordinateGridLayer#
     * @param {String} text Text generated in canvas
     * @return {Object} Context of 2D canvas
     */
    CoordinateGridLayer.prototype.generateImageData = function(text) {
        var ctx = this.canvas2d.getContext("2d");
        ctx.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
        ctx.fillStyle = FeatureStyle.fromColorToString(
            this.getStyle().getStrokeColor()
        );
        ctx.font = "18px sans-serif";
        ctx.textBaseline = "top";
        ctx.textAlign = "center";
        var x = this.canvas2d.width / 2;

        ctx.fillText(text, x, 0);

        return ctx.getImageData(
            0,
            0,
            this.canvas2d.width,
            this.canvas2d.height
        );
    };

    /**************************************************************************************************************/

    /**
     * Attaches the layer to the globe.
     * @function _attach
     * @memberof CoordinateGridLayer#
     * @param {Planet} g Planet
     * @private
     */
    CoordinateGridLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        if (this.isVisible()) {
            this.getGlobe()
                .getTileManager()
                .addPostRenderer(this);
        }

        if (!this.gridProgram) {
            /*  var vertexShader = "\
                 attribute vec3 vertex;\n\
                 uniform mat4 viewProjectionMatrix;\n\
                 void main(void) \n\
                 {\n\
                 gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
                 }\n\
                 ";*/
            var vertexShader = "attribute vec3 vertex;\n";
            vertexShader += "uniform mat4 viewProjectionMatrix;\n";
            vertexShader += "void main(void) \n";
            vertexShader += "{\n";
            vertexShader +=
                "gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
            vertexShader += "}\n";

            /*                var fragmentShader = "\
                 precision highp float; \n\
                 uniform float alpha; \n\
                 uniform vec3 color; \n\
                 void main(void)\n\
                 {\n\
                 gl_FragColor = vec4(color,alpha);\n\
                 }\n\
                 ";*/

            var fragmentShader = "precision highp float; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "void main(void)\n";
            fragmentShader += "{\n";
            fragmentShader += "gl_FragColor = vec4(color,alpha);\n";
            fragmentShader += "}\n";

            /*                var vertexLabelShader = "\
                 attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
                 uniform mat4 viewProjectionMatrix; \n\
                 uniform vec3 poiPosition; // world position \n\
                 uniform vec2 poiScale; // x,y scale \n\
                 \n\
                 varying vec2 texCoord; \n\
                 \n\
                 void main(void)  \n\
                 { \n\
                 // Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
                 texCoord = vertex.xy + vec2(0.5); \n\
                 // Invert y \n\
                 texCoord.y = 1.0 - texCoord.y; \n\
                 \n\
                 // Compute poi position in clip coordinate \n\
                 gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
                 gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
                 } \n\
                 ";*/

            var vertexLabelShader =
                "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
            vertexLabelShader += "uniform mat4 viewProjectionMatrix; \n";
            vertexLabelShader +=
                "uniform vec3 poiPosition; // world position \n";
            vertexLabelShader += "uniform vec2 poiScale; // x,y scale \n";
            vertexLabelShader += "\n";
            vertexLabelShader += "varying vec2 texCoord; \n";
            vertexLabelShader += "\n";
            vertexLabelShader += "void main(void)  \n";
            vertexLabelShader += "{ \n";
            vertexLabelShader +=
                "// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
            vertexLabelShader += "texCoord = vertex.xy + vec2(0.5); \n";
            vertexLabelShader += "// Invert y \n";
            vertexLabelShader += "texCoord.y = 1.0 - texCoord.y; \n";
            vertexLabelShader += "\n";
            vertexLabelShader +=
                "// Compute poi position in clip coordinate \n";
            vertexLabelShader +=
                "gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
            vertexLabelShader +=
                "gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
            vertexLabelShader += "} \n";

            /*    var fragmentLabelShader = "\
                 #ifdef GL_ES \n\
                 precision highp float; \n\
                 #endif \n\
                 \n\
                 varying vec2 texCoord; \n\
                 uniform sampler2D texture; \n\
                 uniform float alpha; \n\
                 \n\
                 void main(void) \n\
                 { \n\
                 vec4 textureColor = texture2D(texture, texCoord); \n\
                 gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n\
                 } \n\
                 ";*/
            var fragmentLabelShader = "#ifdef GL_ES \n";
            fragmentLabelShader += "precision highp float; \n";
            fragmentLabelShader += "#endif \n";
            fragmentLabelShader += "\n";
            fragmentLabelShader += "varying vec2 texCoord; \n";
            fragmentLabelShader += "uniform sampler2D texture; \n";
            fragmentLabelShader += "uniform float alpha; \n";
            fragmentLabelShader += "\n";
            fragmentLabelShader += "void main(void) \n";
            fragmentLabelShader += "{ \n";
            fragmentLabelShader +=
                "	vec4 textureColor = texture2D(texture, texCoord); \n";
            fragmentLabelShader +=
                "	gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n";
            fragmentLabelShader += "} \n";

            this.gridProgram = new Program(this.getGlobe().getRenderContext());
            this.labelProgram = new Program(this.getGlobe().getRenderContext());
            this.gridProgram.createFromSource(vertexShader, fragmentShader);
            this.labelProgram.createFromSource(
                vertexLabelShader,
                fragmentLabelShader
            );
        }

        // Texture used to show the equatorial coordinates
        this.labelMesh = new Mesh(this.getGlobe().getRenderContext());
        var vertices = [
            -0.5,
            -0.5,
            0.0,
            -0.5,
            0.5,
            0.0,
            0.5,
            0.5,
            0.0,
            0.5,
            -0.5,
            0.0
        ];
        var indices = [0, 3, 1, 1, 3, 2];
        this.labelMesh.setVertices(vertices);
        this.labelMesh.setIndices(indices);

        // Init grid buffers
        var gl = this.getGlobe().getRenderContext().gl;
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();

        // Init texture pool
        if (!this.texturePool) {
            this.texturePool = new TexturePool(gl);
        }
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the globe.
     * @function _detach
     * @memberof CoordinateGridLayer#
     * @private
     */
    CoordinateGridLayer.prototype._detach = function() {
        var gl = this.getGlobe().getRenderContext().gl;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);

        this.texturePool.disposeAll();
        for (var i in this.labels) {
            if (this.labels.hasOwnProperty(i)) {
                delete this.labels[i];
            }
        }

        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Clamps the geoBound to longitude/latitude samples.
     * @function clampGeoBound
     * @memberof CoordinateGridLayer#
     * @param {GeoBound} geoBound Bbox
     * @return {GeoBound} Bbox clamped
     */
    CoordinateGridLayer.prototype.clampGeoBound = function(geoBound) {
        geoBound.west =
            Math.floor(geoBound.west / this.longitudeSample) *
            this.longitudeSample;
        geoBound.east =
            Math.ceil(geoBound.east / this.longitudeSample) *
            this.longitudeSample;
        geoBound.north =
            Math.ceil(geoBound.north / this.latitudeSample) *
            this.latitudeSample;
        geoBound.south =
            Math.floor(geoBound.south / this.latitudeSample) *
            this.latitudeSample;
        return geoBound;
    };

    /**
     * Renders the grid.
     * @function render
     * @memberof CoordinateGridLayer#
     * @param {Array} tiles Tiles
     */
    CoordinateGridLayer.prototype.render = function(tiles) {
        var renderContext = this.getGlobe().getRenderContext();
        var gl = renderContext.gl;

        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Compute current geoBound
        //TODO a modifier
        var geoBound;
        // Transform geoBound computed in default coordinate system to coordinate system of current grid if different
        var self = this;
        geoBound = this.getGlobe().getViewportGeoBound(function(coordinate) {
            //return coordinate;
            return self.globe
                .getCoordinateSystem()
                .convert(
                    coordinate,
                    Constants.CRS.Equatorial,
                    self.gridCrs.getGeoideName()
                );
        });

        // Clamp geoBound angles to longitude/latitude samples
        geoBound = this.clampGeoBound(geoBound);

        // Regenerate grid & labels only if geoBound has changed
        if (
            this.geoBound.west !== geoBound.west ||
            this.geoBound.east !== geoBound.east ||
            this.geoBound.north !== geoBound.north ||
            this.geoBound.south !== geoBound.south
        ) {
            this.geoBound = geoBound;
            this.computeSamples();
            this.generateGridBuffers();
            this.generateLabels();
        } else {
            this.updateLabels();
        }

        /*** Render grid ***/
        this.gridProgram.apply();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.gridProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1f(this.gridProgram.uniforms.alpha, this.getOpacity());
        var color = this.getStyle().getStrokeColor();
        gl.uniform3f(
            this.gridProgram.uniforms.color,
            color[0],
            color[1],
            color[2]
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(
            this.gridProgram.attributes.vertex,
            this.vertexBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
        );

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(
            gl.LINES,
            this.indexBuffer.numItems,
            gl.UNSIGNED_SHORT,
            0
        );

        /*** Render labels ***/
        this.labelProgram.apply();

        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.labelProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1i(this.labelProgram.uniforms.texture, 0);

        var pixelSizeVector = renderContext.computePixelSizeVector();
        for (var n in this.labels) {
            if (this.labels.hasOwnProperty(n)) {
                var label = this.labels[n];
                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, label.texture);

                // 2.0 * because normalized device coordinates goes from -1 to 1
                var scale = [
                    (2.0 * label.textureWidth) / renderContext.canvas.width,
                    (2.0 * label.textureHeight) / renderContext.canvas.height
                ];

                gl.uniform2fv(this.labelProgram.uniforms.poiScale, scale);
                // gl.uniform2fv(this.labelProgram.uniforms["tst"], [ 0.5 / (label.textureWidth), 0.5 / (label.textureHeight)  ]);

                // Poi culling
                var worldPoi = label.pos3d;
                var poiVec = label.vertical;
                scale =
                    label.textureHeight *
                    (pixelSizeVector[0] * worldPoi[0] +
                        pixelSizeVector[1] * worldPoi[1] +
                        pixelSizeVector[2] * worldPoi[2] +
                        pixelSizeVector[3]);

                var x = poiVec[0] * scale + worldPoi[0];
                var y = poiVec[1] * scale + worldPoi[1];
                var z = poiVec[2] * scale + worldPoi[2];

                gl.uniform3f(this.labelProgram.uniforms.poiPosition, x, y, z);
                gl.uniform1f(this.labelProgram.uniforms.alpha, 1.0);

                this.labelMesh.render(this.labelProgram.attributes);
                label.needed = false;
            }
        }
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Get/Set visibility of the layer.
     * @function setVisible
     * @memberof CoordinateGridLayer#
     * @param {boolean} arg Visibility or not
     */
    CoordinateGridLayer.prototype.setVisible = function(arg) {
        AbstractLayer.prototype.setVisible.call(this, arg);
        if (typeof arg === "boolean") {
            if (this.isVisible()) {
                this.getGlobe()
                    .getTileManager()
                    .addPostRenderer(this);
            } else {
                this.getGlobe()
                    .getTileManager()
                    .removePostRenderer(this);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Computes samples depending on geoBound.
     * @function computeSamples
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.computeSamples = function() {
        var dlong = this.geoBound.east - this.geoBound.west;
        var dlat = this.geoBound.north - this.geoBound.south;

        // if under-sampled and not divergent
        while (
            dlong / this.longitudeSample < 3.0 &&
            this.longitudeSample > 1.0
        ) {
            this.longitudeSample /= 2;
            this.latitudeSample /= 2;
        }

        // if over-sampled and not exceed the initial value
        while (
            dlong / this.longitudeSample > 7.0 &&
            this.longitudeSample < 15.0
        ) {
            this.longitudeSample *= 2;
            this.latitudeSample *= 2;
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates buffers object of the grid.
     * @function generateGridBuffers
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.generateGridBuffers = function() {
        var phiStart, phiStop;
        var latNumber, phi, i;
        // Difference is larger than hemisphere
        if (this.geoBound.east - this.geoBound.west > 180.0) {
            // pole in the viewport
            phiStart = 0;
            phiStop = 360;
        } else {
            phiStart = this.geoBound.west;
            phiStop = this.geoBound.east;
        }

        // TODO adaptative generation of theta value
        // for (var theta = geoBound.south; theta <= geoBound.north; theta+=latStep) {

        var vertexPositionData = [];
        var latitudeBands = 180.0 / this.latitudeSample;

        for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            var theta = (latNumber * Math.PI) / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (phi = phiStart; phi <= phiStop; phi += this.longitudeSample) {
                // Tesselation
                var step = this.longitudeSample / this.tesselation;
                for (i = 0; i < this.tesselation; i++) {
                    var radPhi = ((phi + i * step) * Math.PI) / 180;

                    var sinPhi = Math.sin(radPhi);
                    var cosPhi = Math.cos(radPhi);

                    // z is the up vector
                    var x =
                        cosPhi *
                        sinTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();
                    var y =
                        sinPhi *
                        sinTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();
                    var z =
                        cosTheta *
                        this.getGlobe()
                            .getCoordinateSystem()
                            .getGeoide()
                            .getRadius();

                    //TODO a modifier
                    if (
                        this.gridCrs.getGeoideName() !==
                        Constants.CRS.Equatorial
                    ) {
                        var geo = this.getGlobe()
                            .getCoordinateSystem()
                            .from3DToGeo([x, y, z]);
                        geo = this.getGlobe()
                            .getCoordinateSystem()
                            .convert(
                                geo,
                                this.gridCrs.getGeoideName(),
                                Constants.CRS.Equatorial
                            );
                        var eq = this.getGlobe()
                            .getCoordinateSystem()
                            .fromGeoTo3D(geo);
                        vertexPositionData.push(eq[0], eq[1], eq[2]);
                    } else {
                        vertexPositionData.push(x, y, z);
                    }
                }
            }
        }

        var gl = this.getGlobe().getRenderContext().gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertexPositionData),
            gl.STATIC_DRAW
        );
        this.vertexBuffer.itemSize = 3;
        this.vertexBuffer.numItems = vertexPositionData.length / 3;

        var indexData = [];
        var longitudeBands = (phiStop - phiStart) / this.longitudeSample + 1;

        // Tesselation
        longitudeBands *= this.tesselation;

        for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (
                phi = phiStart, longNumber = 0;
                phi < phiStop;
                phi += this.longitudeSample, longNumber += this.tesselation
            ) {
                var first =
                    latNumber * longitudeBands +
                    (longNumber % (longitudeBands - 1));
                var second = first + longitudeBands;

                // Horizontal lines
                for (i = 0; i < this.tesselation; i++) {
                    indexData.push(first + i);
                    indexData.push(first + i + 1);
                }

                // Vertical lines
                indexData.push(first + this.tesselation);
                indexData.push(second + this.tesselation);

                indexData.push(second);
                indexData.push(first);
            }
        }

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(
            gl.ELEMENT_ARRAY_BUFFER,
            new Uint16Array(indexData),
            gl.STATIC_DRAW
        );
        this.indexBuffer.itemSize = 1;
        this.indexBuffer.numItems = indexData.length;
    };

    /**************************************************************************************************************/

    /**
     * Builds the angle representation.
     * @function buildAngle
     * @memberof CoordinateGridLayer#
     * @param {String} format The building format("HMS", "DMS" or "Deg")
     * @param {float} angle The angle to build
     * @return {String} Label
     */
    CoordinateGridLayer.prototype.buildAngle = function(format, angle) {
        var label;
        switch (format) {
            case "Deg":
                label = angle + "";
                break;
            case "HMS":
                label = this.getGlobe()
                    .getCoordinateSystem()
                    .fromDegreesToHMS(angle);
                break;
            case "DMS":
                label = this.getGlobe()
                    .getCoordinateSystem()
                    .fromDegreesToDMS(angle);
                break;
            default:
                console.error(format + " : format not supported");
                return null;
        }
        return label;
    };

    /**************************************************************************************************************/

    /**
     * Computes the geographic center of canvas in grid's coordinate system
     * @function computeGeoCenter
     * @memberof CoordinateGridLayer#
     * @return {Array} Geocenter as array of float
     */
    CoordinateGridLayer.prototype.computeGeoCenter = function() {
        var ray = Ray.createFromPixel(
            this.getGlobe().getRenderContext(),
            this.getGlobe().getRenderContext().canvas.width / 2.0,
            this.getGlobe().getRenderContext().canvas.height / 2.0
        );
        var center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.getGlobe()
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        var geoCenter = [];
        this.getGlobe()
            .getCoordinateSystem()
            .from3DToGeo(center3d, geoCenter);

        // Convert geoCenter into grid's coordinate system
        geoCenter = this.getGlobe()
            .getCoordinateSystem()
            .convert(
                geoCenter,
                Constants.CRS.Equatorial,
                this.gridCrs.getGeoideName()
            );

        return geoCenter;
    };

    /**************************************************************************************************************/

    /**
     * Updates 3D position of a given label.
     * @function updateLabel
     * @memberof CoordinateGridLayer#
     * @param {String} label The label id in labels object
     * @param {float[]} posGeo Updated geographic position of label
     */
    CoordinateGridLayer.prototype.updateLabel = function(label, posGeo) {
        posGeo = this.getGlobe()
            .getCoordinateSystem()
            .convert(
                posGeo,
                this.gridCrs.getGeoideName(),
                Constants.CRS.Equatorial
            );
        var pos3d = this.getGlobe()
            .getCoordinateSystem()
            .fromGeoTo3D(posGeo);
        var vertical = vec3.create();
        vec3.normalize(pos3d, vertical);

        this.labels[label].pos3d = pos3d;
        this.labels[label].vertical = vertical;
        this.labels[label].needed = true;
    };

    /**************************************************************************************************************/

    /**
     * Updates the position of all labels.
     * @function updateLabels
     * @memberof CoordinateGridLayer.prototype
     */
    CoordinateGridLayer.prototype.updateLabels = function() {
        var geoCenter = this.computeGeoCenter();
        for (var x in this.labels) {
            if (this.labels.hasOwnProperty(x)) {
                // Compute position of label
                var posGeo;
                if (this.labels[x].type === "lat") {
                    posGeo = [this.labels[x].angle, geoCenter[1]];
                } else if (this.labels[x].type === "long") {
                    posGeo = [geoCenter[0], this.labels[x].angle];
                }
                this.updateLabel(x, posGeo);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates labels of the grid.
     * @function generateLabels
     * @memberof CoordinateGridLayer#
     */
    CoordinateGridLayer.prototype.generateLabels = function() {
        var phiStop, phiStart;
        var imageData, phi, x, posGeo, angle, theta;

        // Difference is larger than hemisphere
        if (this.geoBound.east - this.geoBound.west > 180.0) {
            // pole in the viewport => generate all longitude bands
            phiStart = 0;
            phiStop = 360;
        } else {
            phiStart = this.geoBound.west;
            phiStop = this.geoBound.east;
        }

        var geoCenter = this.computeGeoCenter();
        var label;
        for (phi = phiStart; phi < phiStop; phi += this.longitudeSample) {
            // convert to positive [0..360[
            angle = phi < 0 ? phi + 360 : phi;

            label = this.buildAngle(this.longFormat, angle);

            if (!this.labels["lat_" + label]) {
                this.labels["lat_" + label] = {
                    angle: phi,
                    type: "lat"
                };
                imageData = this.generateImageData(label);
                this._buildTextureFromImage(
                    this.labels["lat_" + label],
                    imageData
                );
            }

            // Compute position of label
            posGeo = [phi, geoCenter[1]];
            this.updateLabel("lat_" + label, posGeo);
        }

        // TODO <!> Adaptative rendering isn't totally implemented for theta due to difficulty to compute extrem latitude using geoBound <!>
        thetaStart = Math.min(this.geoBound.north, this.geoBound.south);
        thetaStop = Math.max(this.geoBound.north, this.geoBound.south);

        for (
            theta = thetaStart;
            theta <= thetaStop;
            theta += this.latitudeSample
        ) {
            // 	for (var theta = -90; theta < 90; theta+=this.latitudeSample) {

            label = this.buildAngle(this.latFormat, theta);

            if (!this.labels["long_" + label]) {
                this.labels["long_" + label] = {
                    angle: theta,
                    type: "long"
                };
                imageData = this.generateImageData(label);
                this._buildTextureFromImage(
                    this.labels["long_" + label],
                    imageData
                );
            }

            // Compute position of label
            posGeo = [geoCenter[0], theta];
            this.updateLabel("long_" + label, posGeo);
        }

        // Dispose texture if not needed
        for (x in this.labels) {
            if (!this.labels[x].needed) {
                this.texturePool.disposeGLTexture(this.labels[x].texture);
                delete this.labels[x];
            }
        }
    };

    /**************************************************************************************************************/

    /*
         * Builds a texture from an image and store in a renderable
         * @function _buildTextureFromImage
         * @memberof CoordinateGridLayer#
         * @param {boolean} renderable Is renderable ?
         * @param {Object} image Image object
         */
    CoordinateGridLayer.prototype._buildTextureFromImage = function(
        renderable,
        image
    ) {
        renderable.texture = this.texturePool.createGLTexture(image);
        renderable.textureWidth = image.width;
        renderable.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    return CoordinateGridLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/HEALPixTiling',[
    "./Tile",
    "./HEALPixBase",
    "../Renderer/GeoBound",
    "../Utils/Numeric",
    "../Utils/Constants"
], function(Tile, HEALPixBase, GeoBound, Numeric, Constants) {
    /**
         Tile constructor

         Quadrilateral which composes one tile of HEALPix sphere

         nside : 2^order
         order : log2(nside);
         pix : pixel index number
         face : face number = [0..11]
         @constructor
         */
    var HEALPixTile = function(order, pix, face) {
        // Call ancestor constructor
        Tile.prototype.constructor.call(this);

        this.order = order;
        this.nside = Math.pow(2, this.order);
        this.pixelIndex = pix;
        this.face = face;

        // Compute texture transform
        /*	var width = 1728/64;
             var height = 1856/64;
             this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

        this.geoBound = null;
    };

    /**************************************************************************************************************/

    /** inherits from Tile */
    HEALPixTile.prototype = new Tile();

    /**************************************************************************************************************/

    /**
         Create the children
         */
    HEALPixTile.prototype.createChildren = function() {
        // Create the children

        var child00 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4,
            this.face
        );
        var child10 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 2,
            this.face
        );
        var child01 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 1,
            this.face
        );
        var child11 = new HEALPixTile(
            this.order + 1,
            this.pixelIndex * 4 + 3,
            this.face
        );

        child00.initFromParent(this, 0, 0);
        child10.initFromParent(this, 1, 0);
        child01.initFromParent(this, 0, 1);
        child11.initFromParent(this, 1, 1);

        this.children = [child00, child10, child01, child11];
    };

    /**************************************************************************************************************/

    /**
         Compute the local matrix for the tile
         */
    HEALPixTile.prototype.computeLocalMatrix = function(vertices) {
        var matrix = mat4.create();

        var east = vec3.create();
        var north = vec3.create();
        var up = vec3.create();

        var mx = 0;
        var my = 0;
        var mz = 0;
        for (var i = 0; i < vertices.length; i++) {
            mx += vertices[i][0];
            my += vertices[i][1];
            mz += vertices[i][2];
        }
        var barycenter = vec3.create([
            mx / vertices.length,
            my / vertices.length,
            mz / vertices.length
        ]);

        vec3.set(barycenter, up);
        vec3.normalize(up);

        vec3.subtract(vertices[0], vertices[3], north);

        vec3.cross(up, north, east);
        vec3.normalize(east);
        vec3.cross(up, east, north);
        vec3.normalize(north);

        matrix[0] = east[0];
        matrix[1] = east[1];
        matrix[2] = east[2];
        matrix[3] = 0.0;

        matrix[4] = north[0];
        matrix[5] = north[1];
        matrix[6] = north[2];
        matrix[7] = 0.0;

        matrix[8] = up[0];
        matrix[9] = up[1];
        matrix[10] = up[2];
        matrix[11] = 0.0;

        matrix[12] = barycenter[0];
        matrix[13] = barycenter[1];
        matrix[14] = barycenter[2];
        matrix[15] = 1.0;

        return matrix;
    };

    /**************************************************************************************************************/

    /**
         Generate vertices for tile
         */
    HEALPixTile.prototype.generateVertices = function() {
        // Build the vertices
        var size = this.config.tesselation;
        var worldSpaceVertices = [];
        var step = 1.0 / (size - 1);

        // xyf calculation
        var pix = this.pixelIndex & (this.nside * this.nside - 1);
        var ix = HEALPixBase.compress_bits(pix);
        var iy = HEALPixBase.compress_bits(pix >>> 1);
        var coordinateSystem = this.config.coordinateSystem;
        // Compute array of worldspace coordinates
        for (var u = 0; u < size; u++) {
            for (var v = 0; v < size; v++) {
                var vertice = HEALPixBase.fxyf(
                    (ix + u * step) / this.nside,
                    (iy + v * step) / this.nside,
                    this.face
                );

                // Take sphere radius into account
                vertice[0] *= coordinateSystem.getGeoide().getRadius();
                vertice[1] *= coordinateSystem.getGeoide().getRadius();
                vertice[2] *= coordinateSystem.getGeoide().getRadius();
                //TODO a modifier
                if (
                    coordinateSystem.getGeoideName() !==
                    Constants.CRS.Equatorial
                ) {
                    var geo = coordinateSystem.getWorldFrom3D(vertice);
                    var eq = coordinateSystem.convert(
                        geo,
                        coordinateSystem.getGeoideName(),
                        Constants.CRS.Equatorial
                    );
                    worldSpaceVertices[
                        u * size + v
                    ] = coordinateSystem.get3DFromWorld(eq);
                } else {
                    worldSpaceVertices[u * size + v] = vertice;
                }
            }
        }

        // Compute geoBound using corners of tile
        this.geoBound = new GeoBound();

        var corners = [];
        corners.push(coordinateSystem.getWorldFrom3D(worldSpaceVertices[0]));
        corners.push(
            coordinateSystem.getWorldFrom3D(worldSpaceVertices[size - 1])
        );
        corners.push(
            coordinateSystem.getWorldFrom3D(
                worldSpaceVertices[size * (size - 1)]
            )
        );
        corners.push(
            coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * size - 1])
        );

        this.geoBound.computeFromCoordinates(corners);

        // Compute tile matrix
        this.matrix = this.computeLocalMatrix(worldSpaceVertices);
        var invMatrix = mat4.create();
        mat4.inverse(this.matrix, invMatrix);
        this.inverseMatrix = invMatrix;

        // Compute tile matrix
        /*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
             var geoCenter = coordinateSystem.getWorldFrom3D(center);
             this.matrix = coordinateSystem.getLHVTransform( geoCenter );
             var invMatrix = mat4.create();
             mat4.inverse( this.matrix, invMatrix );
             this.inverseMatrix = invMatrix;*/

        // Build the vertices
        var vertices = new Float32Array(3 * size * size);

        // Vertex coordinates in local space
        var vertexOffset = 0;
        for (var i = 0; i < worldSpaceVertices.length; i++) {
            vertices[vertexOffset] =
                invMatrix[0] * worldSpaceVertices[i][0] +
                invMatrix[4] * worldSpaceVertices[i][1] +
                invMatrix[8] * worldSpaceVertices[i][2] +
                invMatrix[12];
            vertices[vertexOffset + 1] =
                invMatrix[1] * worldSpaceVertices[i][0] +
                invMatrix[5] * worldSpaceVertices[i][1] +
                invMatrix[9] * worldSpaceVertices[i][2] +
                invMatrix[13];
            vertices[vertexOffset + 2] =
                invMatrix[2] * worldSpaceVertices[i][0] +
                invMatrix[6] * worldSpaceVertices[i][1] +
                invMatrix[10] * worldSpaceVertices[i][2] +
                invMatrix[14];
            vertexOffset += 3;
        }

        return vertices;
    };

    /**************************************************************************************************************/

    /**
     *    HEALPixTiling constructor
     *    @name HEALPixTiling
     *
     *    @param order Starting tiling order
     *    @param options Options
     *        <ul>
     *            <li>coordSystem: Coordinate system of the given tiling</li>
     *        </ul>
     *    @constructor
     */
    var HEALPixTiling = function(order, options) {
        this.order = order;
        this.nside = Math.pow(2, this.order);
        this.coordinateSystem = options.coordinateSystem;
        // TODO undefined coord system
    };

    /**************************************************************************************************************/

    /**
         Generate the tiles for level zero
         */
    HEALPixTiling.prototype.generateLevelZeroTiles = function(
        config,
        tilePool
    ) {
        config.skirt = false;
        config.cullSign = -1;
        config.tesselation = 5;
        // TODO : change name to avoid ambiguity
        config.coordinateSystem = this.coordinateSystem;
        this.coordinateSystem = config.coordinateSystem;
        var level0Tiles = [];

        var qpf = Math.pow(this.nside, 2); // quad per face
        var nFaces = 12;
        var nQuads = nFaces * qpf;

        for (var i = 0; i < nQuads; i++) {
            var face = Math.floor(i / qpf);
            var tile = new HEALPixTile(this.order, i, face);
            tile.config = config;
            level0Tiles.push(tile);
        }

        return level0Tiles;
    };

    // Get all the coordinates of a geometry
    var _getGeometryCoordinates = function(geometry) {
        var coords, n;
        switch (geometry.type) {
            case Constants.GEOMETRY.Point:
                coords = [];
                coords.push(geometry.coordinates);
                break;
            case Constants.GEOMETRY.MultiPoint:
            case Constants.GEOMETRY.LineString:
                coords = geometry.coordinates;
                break;
            case Constants.GEOMETRY.MultiLineString:
                coords = [];
                for (n = 0; n < geometry.coordinates.length; n++) {
                    coords = coords.concat(geometry.coordinates[n]);
                }
                break;
            case Constants.GEOMETRY.Polygon:
                coords = geometry.coordinates[0];
                break;
            case Constants.GEOMETRY.MultiPolygon:
                coords = [];
                for (n = 0; n < geometry.coordinates.length; n++) {
                    coords = coords.concat(geometry.coordinates[n][0]);
                }
                break;
            case Constants.GEOMETRY.GeometryCollection:
                coords = [];
                for (n = 0; n < geometry.geometries.length; n++) {
                    coords = coords.concat(
                        _getGeometryCoordinates(geometry.geometries[n])
                    );
                }
                break;
        }
        return coords;
    };

    /**************************************************************************************************************/

    /**
         Get the level zero tiles that overlaps the given geometry
         */
    HEALPixTiling.prototype.getOverlappedLevelZeroTiles = function(geometry) {
        var tileIndices = [];

        var coords = _getGeometryCoordinates(geometry);
        if (!coords) {
            console.error("Invalid geometry type or not supported.");
            return tileIndices;
        }

        var indexMap = {};
        for (var i = 0; i < coords.length; i++) {
            var index = this.lonlat2LevelZeroIndex(coords[i][0], coords[i][1]);
            if (!indexMap[index]) {
                indexMap[index] = true;
                tileIndices.push(index);
            }
        }

        return tileIndices;
    };

    /**************************************************************************************************************/

    /**
         Locate a level zero tile
         */
    HEALPixTiling.prototype.lonlat2LevelZeroIndex = function(lon, lat) {
        //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
        //lon = geo[0];
        //lat = geo[1];
        return HEALPixBase.lonLat2pix(this.order, lon, lat);
    };

    /**************************************************************************************************************/

    /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
    HEALPixTiling.prototype.findInsideTile = function(lon, lat, tiles) {
        //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
        //lon = geo[0];
        //lat = geo[1];
        for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];
            var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
            if (index === tile.pixelIndex) {
                return tile;
            }
        }
        return null;
    };

    /**************************************************************************************************************/

    /**************************************************************************************************************/

    return HEALPixTiling;
});

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define('jquery.ui',["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
}},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});
/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('Gui/dialog/ErrorDialog',["jquery", "jquery.ui"], function($) {
    // The main div for error
    var errorDiv =
        '<div id="errorDiv" style="text-align: left" title="Error"></div>';

    // Create the div, use jQuery UI dialog

    var $text = "";
    var $buttonName = "";

    var $errorDiv = $(errorDiv)
        .appendTo("body")
        .dialog({
            autoOpen: false,
            width: 500,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: "errorBox",
            beforeClose: function(event, ui) {
                $text = "";
            }
        });
    var $active = false;
    var $displayWarning = false;
    var $displayDebug = false;

    _recordError = function(html) {
        $text += html + "<br/>";
        if ($("#warningContainer")) {
            $("#warningContainer").show();
            $errorDiv.on("dialogclose", function(event) {
                if ($buttonName) {
                    $buttonName.hide();
                }
            });
        }
        if ($active === true) {
            $errorDiv.html($text).dialog("open");
            $errorDiv.scrollTop(5000);
        }
    };

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function(html, debug) {
            if (debug == null) {
                debug = false;
            }
            if (debug && $displayDebug) {
                // debug mode for developers
                _recordError(html);
            } else if (!debug && $displayWarning === true) {
                //user mode : user needs to known when a problem happens with data
                _recordError(html);
            }
        },
        view: function() {
            $errorDiv.html($text).dialog("open");

            $errorDiv.scrollTop(5000);
            $active = true;
        },
        hide: function() {
            $errorDiv.dialog("close");
            $active = false;
        },
        isActive: function() {
            return $active;
        },
        setDisplayWarning: function(value) {
            $displayWarning = value;
        },
        setDisplayDebug: function(value) {
            $displayDebug = value;
        },
        setIcon: function(buttonName) {
            $buttonName = $(buttonName);
        },
        hasError : function() {
            return $text.length > 0;
        },
        getTxt : function() {
            return $text;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/HipsMetadata',["jquery", "../Utils/Constants", "../Gui/dialog/ErrorDialog"], function(
    $,
    Constants,
    ErrorDialog
) {
    /**
     * @namespace
     * GENERAL_WAVELENGTH
     * @property {String} Radio - Radio
     * @property {String} Millimeter - Millimeter
     * @property {String} Infrared - Infrared
     * @property {String} Optical - Optical
     * @property {String} UV - UV
     * @property {String} EUV - EUV
     * @property {String} X-ray - X-ray
     * @property {String} Gamma-ray - Gamma-ray
     */
    var GENERAL_WAVELENGTH = {
        Radio: "Radio",
        Millimeter: "Millimeter",
        Infrared: "Infrared",
        Optical: "Optical",
        UV: "UV",
        EUV: "EUV",
        "X-ray": "X-ray",
        "Gamma-ray": "Gamma-ray"
    };

    /**
     * @namespace
     * HIPS_FRAME
     * @property {String} equatorial - equatorial
     * @property {String} galactic - galactic
     * @property {String} ecliptic - ecliptic
     * @property {String} horizontalLocal - horizontalLocal
     */
    var HIPS_FRAME = {
        equatorial: Constants.CRS.Equatorial,
        galactic: Constants.CRS.Galactic,
        ecliptic: "ecliptic",
        horizontalLocal: Constants.CRS.HorizontalLocal
    };

    /**
     * @namespace
     * HIPS_TILE_FORMAT
     * @property {String} jpeg - jpeg
     * @property {String} png - png
     * @property {String} fits - fits
     * @property {String} tsv - tsv
     */
    var HIPS_TILE_FORMAT = {
        jpeg: "jpeg",
        png: "png",
        fits: "fits",
        tsv: "tsv"
    };

    /**
     * @namespace
     * SAMPLING
     * @property {String} none - none
     * @property {String} nearest - nearest
     * @property {String} bilinear - bilinear
     */
    var SAMPLING = {
        none: "non",
        nearest: "nearest",
        bilinear: "bilinear"
    };

    /**
     * @namespace
     * PIXEL_OVERLAY
     * @property {String} add - add
     * @property {String} mean - mean
     * @property {String} first - first
     * @property {String} border_fading - border_fading
     * @property {String} custom - custom
     */
    var PIXEL_OVERLAY = {
        add: "add",
        mean: "mean",
        first: "first",
        border_fading: "border_fading",
        custom: "custom"
    };

    /**
     * @namespace
     * SKY_VAL
     * @property {String} none - none
     * @property {String} hips_estimation - hips_estimation
     * @property {String} fits_keyword - fits_keyword
     */
    var SKY_VAL = {
        none: "none",
        hips_estimation: "hips_estimation",
        fits_keyword: "fits_keyword"
    };

    /**
     * @namespace
     * DATA_PRODUCT_TYPE
     * @property {String} image - image
     * @property {String} cube - cube
     * @property {String} catalog - catalog
     * @property {String} meta - meta
     */
    var DATA_PRODUCT_TYPE = {
        image: "image",
        cube: "cube",
        catalog: "catalog",
        meta: "meta"
    };

    /**
     * @namespace
     * SUB_TYPE_DATA
     * @property {String} color - color
     * @property {String} live - live
     */
    var SUB_TYPE_DATA = {
        color: "color",
        live: "live"
    };

    /**
     * Hips data model
     * Mandatory, description, isMultiple, default value, distinctvalue, isArray
     * @namespace
     * HIPS_METADATA
     * @property {String} creator_did - Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J
     * @property {String} [publisher_id] - Unique ID of the HiPS publisher  Format: IVOID - Ex : ivo://CDS
     * @property {String} [obs_collection] - Short name of original data set  Format: one word  Ex : 2MASS
     * @property {String} obs_title - Data set title  Format: free text, one line  Ex : HST F110W observations
     * @property {String} [obs_description] - Data set description  Format: free text, longer free text description of the dataset
     * @property {String} [obs_ack] - Acknowledgment mention"
     * @property {String} [prov_progenitor] - Provenance of the original data  Format: free text
     * @property {String} [bib_reference] - Bibliographic reference
     * @property {String} [bib_reference_url] - URL to bibliographic reference
     * @property {String} [obs_copyright] - Copyright mention  Format: free text
     * @property {String} [obs_copyright_url] - URL to a copyright mention
     * @property {GENERAL_WAVELENGTH} [obs_regime] - General wavelength
     * @property {String} [data_ucd] - UCD describing data contents
     * @property {String} hips_version="1.4" - Number of HiPS version  Format: number
     * @property {String} [hips_builder] - Name and version of the tool used for building the HiPS  Format: free text
     * @property {String} [hips_publisher] - Institute or person who built the HiPS  Format: free text  Ex : CDS (T.Boch)
     * @property {String} [hips_creation_date] - HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {String} hips_release_date - Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {String} [hips_service_url] - HiPS access url  Format: URL
     * @property {String} hips_status - HiPS status
     * @property {String} [hips_estsize] - HiPS size estimation  Format: positive integer  Unit : KB
     * @property {HIPS_FRAME} hips_frame - Coordinate frame reference
     * @property {int} hips_order - Deepest HiPS order  Format: positive integer
     * @property {int} [hips_tile_width=512] - Tiles width in pixels  Format: positive integer
     * @property {HIPS_TILE_FORMAT} hips_tile_format - List of available tile formats
     * @property {String} [hips_pixel_cut] - Suggested pixel display cut range (physical values)  Format: min max
     * @property {String} [hips_data_range] - Pixel data range taken into account during the HiPS generation (physical values)  Format: min max  Ex : -18.5 510.5
     * @property {SAMPLING} [hips_sampling] - Sampling applied for the HiPS generation
     * @property {PIXEL_OVERLAY} [hips_overlay] - Pixel composition method applied on the image overlay region during HiPS generation
     * @property {SKY_VAL} [hips_skyval] - Sky background subtraction method applied during HiPS generation
     * @property {String} [hips_pixel_bitpix] - Fits tile BITPIX code
     * @property {String} [data_pixel_bitpix] - Original data BITPIX code
     * @property {DATA_PRODUCT_TYPE} dataproduct_type - Type of data
     * @property {SUB_TYPE_DATA} [dataproduct_subtype] - Subtype of data
     * @property {String} [hips_progenitor_url] - URL to an associated progenitor HiPS
     * @property {int} [hips_cat_nrows] -  Number of rows of the HiPS catalog
     * @property {int} [hips_cube_depth] - Number of frames of the HiPS cube
     * @property {int} [hips_cube_firstframe=0] - Initial first index frame to display for a HiPS cube
     * @property {float} [data_cube_crpix3] - Coef for computing physical channel value
     * @property {float} [data_cube_crval3] - Coef for computing physical channel value
     * @property {float} [data_cube_cdelt3] - Coef for computing physical channel value
     * @property {String} [data_cube_bunit3] - Third axis unit
     * @property {float} [hips_initial_ra] - Default RA display position (ICRS frame)  Unit : degrees
     * @property {float} [hips_initial_dec] - Default DEC display position (ICRS frame)  Unit : degrees
     * @property {float} [hips_initial_fov] - Default display size  Unit : degrees
     * @property {float} [hips_pixel_scale] - HiPS pixel angular resolution at the highest order  Unit : degrees
     * @property {float} [s_pixel_scale] - Best pixel angular resolution of the original images  Unit : degrees
     * @property {float} [t_min] - Start time of the observations - Representation: MJD
     * @property {float} [t_max] - Stop time of the observations - Representation: MJD
     * @property {float} [em_min] - Start in spectral coordinates  Unit: meters
     * @property {float} [em_max] - Stop in spectral coordinates  Unit: meters
     * @property {String} [client_category] - / separated keywords suggesting a display hierarchy to the client  Ex : Image/InfraRed
     * @property {String} [client_sort_key] - Sort key suggesting a display order to the client inside a client_category  Sort : alphanumeric
     * @property {String} [addendum_did] - In case of live HiPS, creator_did of the added HiPS
     * @property {float} [moc_sky_fraction] - Fraction of the sky covers by the MOC associated to the HiPS  Format: real between 0 and 1
     */
    var HipsVersion_1_4 = {
        creator_did: [
            "R",
            "Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J",
            false,
            null,
            null,
            false
        ],
        publisher_id: [
            null,
            "Unique ID of the HiPS publisher  Format: IVOID - Ex : ivo://CDS",
            false,
            null,
            null,
            false
        ],
        obs_collection: [
            null,
            "Short name of original data set  Format: one word  Ex : 2MASS",
            false,
            null,
            null,
            false
        ],
        obs_title: [
            "R",
            "Data set title  Format: free text, one line  Ex : HST F110W observations",
            false,
            null,
            null,
            false
        ],
        obs_description: [
            "S",
            "Data set description  Format: free text, longer free text description of the dataset",
            false,
            null,
            null,
            false
        ],
        obs_ack: [null, "Acknowledgment mention", false, null, null, false],
        prov_progenitor: [
            "S",
            "Provenance of the original data  Format: free text",
            true,
            null,
            null,
            false
        ],
        bib_reference: [
            null,
            "Bibliographic reference",
            true,
            null,
            null,
            false
        ],
        bib_reference_url: [
            null,
            "URL to bibliographic reference",
            true,
            null,
            null,
            false
        ],
        obs_copyright: [
            null,
            "Copyright mention  Format: free text",
            false,
            null,
            null,
            false
        ],
        obs_copyright_url: [
            null,
            "URL to a copyright mention",
            false,
            null,
            null,
            false
        ],
        obs_regime: [
            "S",
            "General wavelength  Format: word",
            true,
            null,
            GENERAL_WAVELENGTH,
            false
        ],
        data_ucd: [
            null,
            "UCD describing data contents",
            true,
            null,
            null,
            false
        ],
        hips_version: [
            "R",
            "Number of HiPS version  Format: number",
            false,
            "1.4",
            null,
            false
        ],
        hips_builder: [
            null,
            "Name and version of the tool used for building the HiPS  Format: free text",
            false,
            null,
            null,
            false
        ],
        hips_publisher: [
            null,
            "Institute or person who built the HiPS  Format: free text  Ex : CDS (T.Boch)",
            false,
            null,
            null,
            false
        ],
        hips_creation_date: [
            "S",
            "HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ",
            false,
            null,
            null,
            false
        ],
        hips_release_date: [
            "R",
            "Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ",
            false,
            null,
            null,
            false
        ],
        hips_service_url: [
            null,
            "HiPS access url  Format: URL",
            false,
            null,
            null,
            false
        ],
        hips_status: [
            "R",
            "HiPS status",
            false,
            "public master clonableOnce",
            null,
            true
        ],
        hips_estsize: [
            null,
            "HiPS size estimation  Format: positive integer  Unit : KB",
            false,
            null,
            null,
            false
        ],
        hips_frame: [
            "R",
            "Coordinate frame reference",
            false,
            null,
            HIPS_FRAME,
            false
        ],
        hips_order: [
            "R",
            "Deepest HiPS order  Format: positive integer",
            false,
            null,
            null,
            false
        ],
        hips_tile_width: [
            null,
            "Tiles width in pixels  Format: positive integer",
            false,
            512,
            null,
            false
        ],
        hips_tile_format: [
            "R",
            "List of available tile formats. The first one is the default suggested to the client",
            false,
            null,
            HIPS_TILE_FORMAT,
            true
        ],
        hips_pixel_cut: [
            null,
            "Suggested pixel display cut range (physical values)  Format: min max",
            null,
            null,
            null,
            true
        ],
        hips_data_range: [
            null,
            "Pixel data range taken into account during the HiPS generation (physical values)  Format: min max  Ex : -18.5 510.5",
            false,
            null,
            null,
            true
        ],
        hips_sampling: [
            null,
            "Sampling applied for the HiPS generation",
            false,
            null,
            SAMPLING,
            false
        ],
        hips_overlay: [
            null,
            "Pixel composition method applied on the image overlay region during HiPS generation",
            false,
            null,
            PIXEL_OVERLAY,
            false
        ],
        hips_skyval: [
            null,
            "Sky background subtraction method applied during HiPS generation",
            false,
            null,
            SKY_VAL,
            false
        ],
        hips_pixel_bitpix: [
            null,
            "Fits tile BITPIX code",
            false,
            null,
            null,
            false
        ],
        data_pixel_bitpix: [
            null,
            "Original data BITPIX code",
            false,
            null,
            null
        ],
        dataproduct_type: [
            "R",
            "Type of data",
            false,
            null,
            DATA_PRODUCT_TYPE,
            false
        ],
        dataproduct_subtype: [
            "RD",
            "Subtype of data",
            false,
            null,
            SUB_TYPE_DATA,
            false
        ],
        hips_progenitor_url: [
            null,
            "URL to an associated progenitor HiPS",
            false,
            null,
            null,
            false
        ],
        hips_cat_nrows: [
            "S",
            "Number of rows of the HiPS catalog",
            false,
            null,
            null,
            false
        ],
        hips_cube_depth: [
            "RD",
            "Number of frames of the HiPS cube",
            false,
            null,
            null,
            false
        ],
        hips_cube_firstframe: [
            null,
            "Initial first index frame to display for a HiPS cube",
            false,
            0,
            null,
            false
        ],
        data_cube_crpix3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_crval3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_cdelt3: [
            null,
            "Coef for computing physical channel value (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        data_cube_bunit3: [
            null,
            "Third axis unit (see FITS doc)",
            false,
            null,
            null,
            false
        ],
        hips_initial_ra: [
            "S",
            "Default RA display position (ICRS frame)  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_initial_dec: [
            "S",
            "Default DEC display position (ICRS frame)  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_initial_fov: [
            "S",
            "Default display size  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        hips_pixel_scale: [
            null,
            "HiPS pixel angular resolution at the highest order  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        s_pixel_scale: [
            null,
            "Best pixel angular resolution of the original images  Unit : degrees",
            false,
            null,
            null,
            false
        ],
        t_min: [
            "S",
            "Start time of the observations - Representation: MJD",
            false,
            null,
            null,
            false
        ],
        t_max: [
            "S",
            "Stop time of the observations - Representation: MJD",
            false,
            null,
            null,
            false
        ],
        em_min: [
            "S",
            "Start in spectral coordinates  Unit: meters",
            false,
            null,
            null,
            false
        ],
        em_max: [
            "S",
            "Stop in spectral coordinates  Unit: meters",
            false,
            null,
            null,
            false
        ],
        client_category: [
            null,
            "/ separated keywords suggesting a display hierarchy to the client  Ex : Image/InfraRed",
            false,
            null,
            null,
            false
        ],
        client_sort_key: [
            null,
            "Sort key suggesting a display order to the client inside a client_category  Sort : alphanumeric",
            false,
            null,
            null,
            false
        ],
        addendum_did: [
            null,
            "In case of live HiPS, creator_did of the added HiPS",
            true,
            null,
            null,
            false
        ],
        moc_sky_fraction: [
            null,
            "Fraction of the sky covers by the MOC associated to the HiPS  Format: real between 0 and 1",
            false,
            null,
            null,
            false
        ]
    };

    /**
     * Checks if the required attribute is stored in hipsMetadata.<br>
     * when the attribute is not stored, then store this information in requiredKeywordNotFound.
     * @param {HIPS_METADATA} hipsMetadata
     * @param {string} mandatory - "R" is a required parameter
     * @param {string} key - attribute to check
     * @param {string} description Key's description
     * @param requiredKeywordNotFound - Array or required information not found
     * @private
     */
    function _checkRequiredParameters(
        hipsMetadata,
        mandatory,
        key,
        description,
        requiredKeywordNotFound
    ) {
        if (mandatory === "R" && !hipsMetadata.hasOwnProperty(key)) {
            //Fix for version=1.2
            if (key === "creator_did" && hipsMetadata.hips_version === "1.2") {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    "<font style='color:orange'>Warning :</font> Deprecated Hips version <b>1.2</b> for <font style='color:orange'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, please update it - <font style='color:orange'>use creator_did=publisher_did</font>"
                );
            }
            //Fix for version=1.3
            else if (
                key === "creator_did" &&
                hipsMetadata.hips_version === "1.3"
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    "<font style='color:orange'>Warning :</font> Deprecated Hips version <b>1.3</b> for <font style='color:orange'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, please update it - <font style='color:orange'>use creator_did=publisher_did</font>"
                );
            } else if (
                key === "obs_title" &&
                hipsMetadata.hips_version === "1.3"
            ) {
                hipsMetadata.obs_title = hipsMetadata.obs_collection;
                ErrorDialog.open(
                    "<font style='color:orange'>Warning :</font> Deprecated Hips version <b>1.3</b> for <font style='color:orange'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, please update it - <font style='color:orange'>use obs_title=obs_collection</font>"
                );
            }
            //Fox for version 1.4
            else if (
                key === "obs_title" &&
                hipsMetadata.hips_version === "1.4"
            ) {
                hipsMetadata.obs_title = hipsMetadata.obs_collection;
                ErrorDialog.open(
                    "<font style='color:yellow'>Warning :</font> obs_title not found in v1.4 for <font style='color:yellow'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, use obs_title, please fix it"
                );
            } else if (
                key === "creator_did" &&
                hipsMetadata.hips_version === "1.4"
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    "<font style='color:yellow'>Warning :</font> creator_did not found in v1.4 for <font style='color:yellow'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, use creator_did, please fix it"
                );
            }
            /// very old version
            else if (
                key === "hips_version" &&
                !hipsMetadata.hasOwnProperty("hips_version")
            ) {
                hipsMetadata.hips_version = "very old one";
                ErrorDialog.open(
                    "<font style='color:orange'>Warning :</font> Deprecated Hips version <b>unknown</b> for <font style='color:orange'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, please update it - <font style='color:orange'>use a version in your metadata</font>"
                );
            } else if (
                key === "creator_did" &&
                !hipsMetadata.hasOwnProperty("hips_version")
            ) {
                hipsMetadata.creator_did = hipsMetadata.publisher_did;
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : </font> Deprecated Hips version <b>unknown</b> for <font style='color:orange'><b>" +
                        hipsMetadata.obs_title +
                        "</b></font>, please update it - <font style='color:orange'>use creator_did = pulisher_did</font>"
                );
            }
            //Error
            else {
                requiredKeywordNotFound.push(
                    key + " (" + description + ") is not present. "
                );
            }
        }
    }

    /**
     *
     * @param {boolean} valueArray - is an Array
     * @param {string} key - attribute
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _transformAStringToArray(valueArray, key, hipsMetadata) {
        if (valueArray && hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = hipsMetadata[key].split(/\s+/);
        }
    }

    /**
     * Checks a value is among an enumerated list
     * @param {string} key - key to test
     * @param {string} description - key's description
     * @param distinctValue - enumeration
     * @param hipsMetadata - hipsMetadata
     * @param valueNotRight - Wrong value
     * @private
     */
    function _checkValueAmongEnumeratedList(
        key,
        valueArray,
        description,
        distinctValue,
        hipsMetadata,
        valueNotRight
    ) {
        if (distinctValue !== null && hipsMetadata.hasOwnProperty(key)) {
            if (valueArray) {
                for (var val in hipsMetadata[key]) {
                    if (hipsMetadata[key].hasOwnProperty(val)) {
                        var format = hipsMetadata[key][val];
                        if (!distinctValue.hasOwnProperty(format)) {
                            valueNotRight.push(
                                'The value "' +
                                    hipsMetadata[key] +
                                    '" of ' +
                                    key +
                                    " (" +
                                    description +
                                    ") is not correct. "
                            );
                            break;
                        }
                    }
                }
            } else {
                if (!distinctValue.hasOwnProperty(hipsMetadata[key])) {
                    valueNotRight.push(
                        'The value "' +
                            hipsMetadata[key] +
                            '" of ' +
                            key +
                            " (" +
                            description +
                            ") is not correct. "
                    );
                }
            }
        }
    }

    /**
     * fills hipsMetadata with the default value when the key is not present
     * @param {string} key - key
     * @param {string} defaultValue - default value
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _fillWithDefaultValue(key, defaultValue, hipsMetadata) {
        if (defaultValue !== null && !hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = defaultValue;
        }
    }

    /**
     * Validates and fixes metadata
     * @param {HIPS_METADATA} hipsMetadata
     * @throws RangeError - "unvalid hips metadata"
     */
    function _validateAndFixHips(hipsMetadata) {
        var requiredKeywordNotFound = [];
        var valueNotRight = [];
        var values,
            mandatory,
            description,
            isMutiple,
            defaultValue,
            distinctValue,
            valueArray;
        for (var key in HipsVersion_1_4) {
            if (HipsVersion_1_4.hasOwnProperty(key)) {
                values = HipsVersion_1_4[key];
                mandatory = values[0];
                description = values[1];
                defaultValue = values[3];
                distinctValue = values[4];
                valueArray = values[5];

                // checking the required parameter is here
                _checkRequiredParameters.call(
                    this,
                    hipsMetadata,
                    mandatory,
                    key,
                    description,
                    requiredKeywordNotFound
                );

                // Transforms a key's value into an array when it is necessary and store the result in hipsMetadata
                _transformAStringToArray.call(
                    this,
                    valueArray,
                    key,
                    hipsMetadata
                );

                // checking the value of the parameter among a list of values
                //_checkValueAmongEnumeratedList.call(this, key, valueArray, description, distinctValue, hipsMetadata, valueNotRight);

                // checking the key is here when a default value exists
                _fillWithDefaultValue.call(
                    this,
                    key,
                    defaultValue,
                    hipsMetadata
                );
            }
        }
        if (requiredKeywordNotFound.length > 0 || valueNotRight.length > 0) {
            var name = hipsMetadata.obs_title
                ? hipsMetadata.obs_title
                : hipsMetadata.obs_collection;
            var url = hipsMetadata.hips_service_url
                ? hipsMetadata.hips_service_url
                : this.baseUrl;
            throw new RangeError(
                "unvalid hips metadata for " +
                    name +
                    " (" +
                    url +
                    "): \n" +
                    requiredKeywordNotFound.toString() +
                    "\n" +
                    valueNotRight.toString(),
                "HipsMetadata.js"
            );
        }
    }

    /**
     * Loads Hips properties
     * @param baseUrl
     * @throws ReferenceError - Unable to load the Hips
     * @return {*}
     */
    function _loadHipsProperties(baseUrl) {
        var url = baseUrl + "/properties";
        var properties = $.ajax({
            type: "GET",
            url: baseUrl + "/properties",
            async: false
        }).responseText;
        if (typeof properties === "undefined") {
            throw new ReferenceError(
                "Unable to load the Hips at " + baseUrl,
                "HipsMetadata.js"
            );
        }
        var hipsProperties = _parseProperties.call(this, properties);
        _validateAndFixHips.call(this, hipsProperties);
        return hipsProperties;
    }

    /**
     * Parses properties
     * @param propertiestext
     * @return {{}}
     */
    function _parseProperties(propertiestext) {
        var propertyMap = {};
        var lines = propertiestext.split(/\r?\n/);
        var currentLine = "";
        $.each(lines, function(i, value) {
            //check if it is a comment line
            if (!/^\s*(\#|\!|$)/.test(value)) {
                // line is whitespace or first non-whitespace character is '#' or '!'
                value = value.replace(/^\s*/, ""); // remove space at start of line
                currentLine += value;
                if (/(\\\\)*\\$/.test(currentLine)) {
                    // line ends with an odd number of '\' (backslash)
                    //line ends with continuation character, remember it and don't process further
                    currentLine = currentLine.replace(/\\$/, "");
                } else {
                    /^\s*((?:[^\s:=\\]|\\.)+)\s*[:=\s]\s*(.*)$/.test(
                        currentLine
                    ); // sub-matches pick out key and value
                    var nkey = RegExp.$1;
                    var nvalue = RegExp.$2;
                    if (propertyMap.hasOwnProperty(nkey)) {
                        propertyMap[nkey] = propertyMap[nkey].isPrototypeOf(
                            Array
                        )
                            ? propertyMap[nkey].push(nvalue)
                            : [propertyMap[nkey], nvalue];
                    } else {
                        propertyMap[nkey] = nvalue;
                    }

                    currentLine = "";
                }
            }
        });
        return propertyMap;
    }

    /**
     * @name HipsMetadata
     * @class
     * Creates the Hips data model. When baseUrl is an URL, then the Hips properties is loaded by requesting
     * the properties file.
     * When the baseURl is the Hips description coming from registry, then the description is validated and fixed if needed.
     * @param baseUrl
     * @constructor
     */
    var HipsMetadata = function(baseUrl) {
        if (baseUrl == null) {
        } else if (typeof baseUrl === "string") {
            this.baseUrl = baseUrl;
            this.hipsMetadata = _loadHipsProperties.call(this, baseUrl);
        } else {
            this.hipsMetadata = baseUrl;
            // In hips registry, each record must provide at least creator_did, hips_release_date, hips_service_url, hips_status
            try {
                _validateAndFixHips.call(this, this.hipsMetadata);
            } catch (e) {
                this.baseUrl = this.hipsMetadata.hips_service_url;
                this.hipsMetadata = _loadHipsProperties.call(
                    this,
                    this.baseUrl
                );
            }
        }
    };

    /**
     * @name setMetadata
     * @param metadata
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.setMetadata = function(metadata) {
        this.hipsMetadata = metadata;
        this.baseUrl = metadata.hips_service_url;
    };

    /**
     * Supported {@link GENERAL_WAVELENGTH wavelength}
     * @name GeneralWavelength
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.GeneralWavelength = GENERAL_WAVELENGTH;

    /**
     * Supported {@link HIPS_FRAME Hips frame}
     * @name HipsFrame
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.HipsFrame = HIPS_FRAME;

    /**
     * Supported {@link HIPS_TILE_FORMAT Hips tile format}
     * @name HipsTileFormat
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.HipsTileFormat = HIPS_TILE_FORMAT;

    /**
     * Supported {@link SAMPLING Sampling}
     * @name Sampling
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.Sampling = SAMPLING;

    /**
     * Supported {@link PIXEL_OVERLAY pixel overlay}
     * @name PixelOverlay
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.PixelOverlay = PIXEL_OVERLAY;

    /**
     * Supported {@link SKY_VAL SkyVal}
     * @name SkyVal
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.SkyVal = SKY_VAL;

    /**
     * Supported {@link DATA_PRODUCT_TYPE DataProductType}
     * @name DataProductType
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.DataProductType = DATA_PRODUCT_TYPE;

    /**
     * Supported {@link SUB_TYPE_DATA SubTypeData}
     * @name SubTypeData
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.SubTypeData = SUB_TYPE_DATA;

    /**
     * Returns the Hips metadata.
     * @function getHipsMetadata
     * @returns {HIPS_METADATA}
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.getHipsMetadata = function() {
        return this.hipsMetadata;
    };

    /**
     * Returns base URL
     * @function getBaseUrl
     * @returns {string} the URL of the Hips
     * @memberof HipsMetadata#
     */
    HipsMetadata.prototype.getBaseUrl = function() {
        return this.baseUrl;
    };

    return HipsMetadata;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/AbstractHipsLayer',[
    "underscore-min",
    "./AbstractRasterLayer",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Tiling/HEALPixTiling",
    "../Crs/CoordinateSystemFactory",
    "./HipsMetadata"
], function(
    _,
    AbstractRasterLayer,
    Utils,
    Constants,
    HEALPixTiling,
    CoordinateSystemFactory,
    HipsMetadata
) {
    /**
     * AbstractHipsLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractHipsLayer.configuration
     * @property {Crs} [coordinateSystem = CoordinateSystemFactory.create({geoideName: Constants.MappingCrsHips2Mizar[this.hipsMetadata.hips_frame]})] - Coordinate reference system
     * @property {int} [tilePixelSize = hipsMetadata['hips_tile_width'] - Tiles width in pixels
     * @property {int} [baseLevel = 2] - min HiPS order
     * @property {HEALPixTiling} [tiling = new HEALPixTiling(options.baseLevel, {coordinateSystem: options.coordinateSystem})] - Tiling
     * @property {int} [numberOfLevels = hipsMetadata['hips_order']] - Deepest order min
     * @property {string} [name = hipsMetadata['obs_title']] - Data set title
     * @property {string} [attribution = <a href=\"" + this.hipsMetadata['obs_copyright_url'] + "\" target=\"_blank\">" + this.hipsMetadata['obs_copyright'] + "</a>"] - URL to a copyright mention
     * @property {string} [ack = hipsMetadata['obs_ack']] - Acknowledgment mention
     * @property {string} [icon = ""] - icon used as metadata representation on the map
     * @property {string} [description = hipsMetadata['obs_description']] - Data set description
     * @property {boolean} [visible = false] visibility by default on the map
     * @property {Object} properties - other metadata
     * @property {float} [properties.initialRa = undefined] - Initial RA
     * @property {float} [properties.initialDec = undefined] - Initial DEC
     * @property {float} [properties.initialFov = undefined] - Initial field of view
     * @property {float} [properties.mocCoverage = undefined] - Sky fraction coverage
     * @property {boolean} [pickable = false] - Pickable layer
     * @property {Array} [availableServices = {}] - List of services related to the layer
     * @property {Array} [format = hipsMetadata['hips_tile_format']] - List of available tile formats
     * @property {string} [baseUrl =  hipsMetadata['hips_service_url']] - Endpoint service
     * @property {string} [category = Image] - Default category
     * @property {boolean} background - Tell if the layer is set as background
     */

    /**
     * @name AbstractHipsLayer
     * @class
     * Abstract class for HIPS
     * @augments AbstractRasterLayer
     * @param {HipsMetadata} hipsMetadata
     * @param {AbstractHipsLayer.configuration} options - AbstractHipsLayer configuration
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     * @throws ReferenceError - Some required parameters are missing
     * @constructor
     */
    var AbstractHipsLayer = function(hipsMetadata, options) {
        _checkAndSetDefaultOptions.call(this, options);
        this.hipsMetadata = _createMetadata.call(
            this,
            hipsMetadata,
            Utils.proxify(options.baseUrl, options.proxy)
        );
        _overloadHipsMetataByConfiguration.call(
            this,
            options,
            this.hipsMetadata
        );

        options.tiling = new HEALPixTiling(options.baseLevel || 2, {
            coordinateSystem: options.coordinateSystem
        });
        options.icon = options.hasOwnProperty("icon")
            ? options.icon
            : options.mizarBaseUrl
                ? options.mizarBaseUrl + "css/images/star.png"
                : "";
        options.visible = options.hasOwnProperty("visible")
            ? options.visible
            : false;
        options.properties = options.hasOwnProperty("properties")
            ? options.properties
            : {};
        options.pickable = options.hasOwnProperty("pickable")
            ? options.pickable
            : false;
        options.services = options.hasOwnProperty("services")
            ? options.services
            : {};

        options.category = options.hasOwnProperty("category")
            ? options.category
            : "Image"; //this.hipsMetadata.client_category;

        if (this.hipsMetadata.hasOwnProperty("moc_access_url")) {
            options.services.Moc = {
                baseUrl: this.hipsMetadata.moc_access_url,
                skyFraction: this.hipsMetadata.moc_sky_fraction
            };
        }

        //Hack : set Galactic layer as background because only background owns two grids (equetorial and galactic)
        if (
            options.coordinateSystem.getGeoideName() === Constants.CRS.Galactic
        ) {
            options.background = true;
        }

        AbstractRasterLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Hips,
            options
        );

        this.fitsSupported = _.contains(
            this.hipsMetadata.hips_tile_format,
            "fits"
        );
    };

    /**
     * Check options.
     * @param options
     * @throws ReferenceError - Some required parameters are missing
     * @private
     */
    function _checkAndSetDefaultOptions(options) {
        if (!options) {
            throw new ReferenceError(
                "Some required parameters are missing",
                "AbstractHipsLayer.js"
            );
        } else {
            options.category = options.category || "Image";
            options.pickable = options.pickable || false;
        }
    }

    /**
     * Creates metadata.
     * @param hipsMetadata
     * @param baseUrl
     * @returns {*}
     * @private
     */
    function _createMetadata(hipsMetadata, baseUrl) {
        var metadata = hipsMetadata;
        if (typeof metadata === "undefined") {
            var hipsProperties = new HipsMetadata(baseUrl);
            metadata = hipsProperties.getHipsMetadata();
        }
        return metadata;
    }

    /**
     *
     * @param options
     * @param hipsMetadata
     * @private
     */
    function _overloadHipsMetataByConfiguration(options, hipsMetadata) {
        options.coordinateSystem = options.hasOwnProperty("coordinateSystem")
            ? CoordinateSystemFactory.create(options.coordinateSystem)
            : CoordinateSystemFactory.create({
                  geoideName:
                      Constants.MappingCrsHips2Mizar[hipsMetadata.hips_frame]
              });
        options.tilePixelSize = options.hasOwnProperty("tilePixelSize")
            ? options.tilePixelSize
            : hipsMetadata.hips_tile_width;
        options.baseLevel = options.hasOwnProperty("baseLevel")
            ? options.baseLevel
            : hipsMetadata.hasOwnProperty("hips_order_min")
                ? hipsMetadata.hips_order_min
                : 2;
        options.numberOfLevels = options.hasOwnProperty("numberOfLevels")
            ? options.numberOfLevels
            : hipsMetadata.hips_order;
        options.name = options.hasOwnProperty("name")
            ? options.name
            : hipsMetadata.obs_title;
        options.attribution = options.hasOwnProperty("attribution")
            ? options.attribution
            : '<a href="' +
              hipsMetadata.obs_copyright_url +
              '" target="_blank">' +
              hipsMetadata.obs_copyright +
              "</a>";
        options.copyrightUrl = options.hasOwnProperty("copyrightUrl")
            ? options.copyrightUrl
            : hipsMetadata.obs_copyright_url;
        options.ack = options.hasOwnProperty("ack")
            ? options.ack
            : hipsMetadata.obs_ack;
        options.description = options.hasOwnProperty("description")
            ? options.description
            : hipsMetadata.obs_description;
        options.format = options.hasOwnProperty("format")
            ? options.format
            : hipsMetadata.hips_tile_format;
        options.baseUrl = options.hasOwnProperty("baseUrl")
            ? options.baseUrl
            : hipsMetadata.hips_service_url;
        options.properties = options.hasOwnProperty("properties")
            ? options.properties
            : {};
        if (hipsMetadata.hasOwnProperty("obs_initial_ra")) {
            options.properties.initialRa = parseFloat(
                hipsMetadata.obs_initial_ra
            );
        }
        if (hipsMetadata.hasOwnProperty("obs_initial_dec")) {
            options.properties.initialDec = parseFloat(
                hipsMetadata.obs_initial_dec
            );
        }
        if (hipsMetadata.hasOwnProperty("obs_initial_fov")) {
            options.properties.initialFov = parseFloat(
                hipsMetadata.obs_initial_fov
            );
        }
        if (hipsMetadata.hasOwnProperty("moc_sky_fraction")) {
            options.properties.moc_sky_fraction = parseFloat(
                hipsMetadata.moc_sky_fraction
            );
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractRasterLayer, AbstractHipsLayer);

    /**************************************************************************************************************/

    /**
     * Returns the Metadata related to Hips protocol.
     * @return {Object}
     * @memberof AbstractHipsLayer#
     */
    AbstractHipsLayer.prototype.getHipsMetadata = function() {
        return this.hipsMetadata;
    };

    return AbstractHipsLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Renderer/ColorMap',["../Utils/Numeric"], function(Numeric) {
    /**************************************************************************************************************/
    var transferFonctions = {
        linear: [],
        asin: [],
        sqrt: [],
        sqr: [],
        log: []
    };

    var computeTransferFunctions = function() {
        for (var x in transferFonctions) {
            if (transferFonctions.hasOwnProperty(x)) {
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                var v;
                var val = [];
                for (var i = 0; i < 256; i++) {
                    v = i;
                    switch (x) {
                        case "linear":
                            val[i] = v;
                            break;
                        case "asin":
                            val[i] = Math.log(
                                v + Math.sqrt(Math.pow(v, 2) + 1.0)
                            );
                            break;
                        case "log":
                            val[i] = Math.log(v / 10.0 + 1);
                            break;
                        case "sqrt":
                            val[i] = Math.sqrt(v / 10.0);
                            break;
                        case "sqr":
                            val[i] = v * v;
                            break;
                        default:
                            break;
                    }

                    if (val[i] < min) {
                        min = val[i];
                    }
                    if (val[i] > max) {
                        max = val[i];
                    }
                }

                // Normalize between [0..256]
                for (i = 0; i < 256; i++) {
                    v = 256 * ((val[i] - min) / (max - min));

                    // Clamp
                    if (v > 256.0) {
                        v = 256.0;
                    } else {
                        if (v < 0.0) {
                            v = 0.0;
                        }
                    }

                    transferFonctions[x][i] = Math.floor(v);
                }
            }
        }
    };

    computeTransferFunctions();

    // Contstant colormaps
    var colormaps = {
        // composantes de la table 'Fire' (ImageJ)
        fire: {
            red: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                4,
                7,
                10,
                13,
                16,
                19,
                22,
                25,
                28,
                31,
                34,
                37,
                40,
                43,
                46,
                49,
                52,
                55,
                58,
                61,
                64,
                67,
                70,
                73,
                76,
                79,
                82,
                85,
                88,
                91,
                94,
                98,
                101,
                104,
                107,
                110,
                113,
                116,
                119,
                122,
                125,
                128,
                131,
                134,
                137,
                140,
                143,
                146,
                148,
                150,
                152,
                154,
                156,
                158,
                160,
                162,
                163,
                164,
                166,
                167,
                168,
                170,
                171,
                173,
                174,
                175,
                177,
                178,
                179,
                181,
                182,
                184,
                185,
                186,
                188,
                189,
                190,
                192,
                193,
                195,
                196,
                198,
                199,
                201,
                202,
                204,
                205,
                207,
                208,
                209,
                210,
                212,
                213,
                214,
                215,
                217,
                218,
                220,
                221,
                223,
                224,
                226,
                227,
                229,
                230,
                231,
                233,
                234,
                235,
                237,
                238,
                240,
                241,
                243,
                244,
                246,
                247,
                249,
                250,
                252,
                252,
                252,
                253,
                253,
                253,
                254,
                254,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],

            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                3,
                5,
                7,
                8,
                10,
                12,
                14,
                16,
                19,
                21,
                24,
                27,
                29,
                32,
                35,
                37,
                40,
                43,
                46,
                48,
                51,
                54,
                57,
                59,
                62,
                65,
                68,
                70,
                73,
                76,
                79,
                81,
                84,
                87,
                90,
                92,
                95,
                98,
                101,
                103,
                105,
                107,
                109,
                111,
                113,
                115,
                117,
                119,
                121,
                123,
                125,
                127,
                129,
                131,
                133,
                134,
                136,
                138,
                140,
                141,
                143,
                145,
                147,
                148,
                150,
                152,
                154,
                155,
                157,
                159,
                161,
                162,
                164,
                166,
                168,
                169,
                171,
                173,
                175,
                176,
                178,
                180,
                182,
                184,
                186,
                188,
                190,
                191,
                193,
                195,
                197,
                199,
                201,
                203,
                205,
                206,
                208,
                210,
                212,
                213,
                215,
                217,
                219,
                220,
                222,
                224,
                226,
                228,
                230,
                232,
                234,
                235,
                237,
                239,
                241,
                242,
                244,
                246,
                248,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],

            blue: [
                0,
                7,
                15,
                22,
                30,
                38,
                45,
                53,
                61,
                65,
                69,
                74,
                78,
                82,
                87,
                91,
                96,
                100,
                104,
                108,
                113,
                117,
                121,
                125,
                130,
                134,
                138,
                143,
                147,
                151,
                156,
                160,
                165,
                168,
                171,
                175,
                178,
                181,
                185,
                188,
                192,
                195,
                199,
                202,
                206,
                209,
                213,
                216,
                220,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                224,
                222,
                220,
                218,
                216,
                214,
                212,
                210,
                206,
                202,
                199,
                195,
                191,
                188,
                184,
                181,
                177,
                173,
                169,
                166,
                162,
                158,
                154,
                151,
                147,
                143,
                140,
                136,
                132,
                129,
                125,
                122,
                118,
                114,
                111,
                107,
                103,
                100,
                96,
                93,
                89,
                85,
                82,
                78,
                74,
                71,
                67,
                64,
                60,
                56,
                53,
                49,
                45,
                42,
                38,
                35,
                31,
                27,
                23,
                20,
                16,
                12,
                8,
                5,
                4,
                3,
                3,
                2,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                13,
                17,
                21,
                26,
                30,
                35,
                42,
                50,
                58,
                66,
                74,
                82,
                90,
                98,
                105,
                113,
                121,
                129,
                136,
                144,
                152,
                160,
                167,
                175,
                183,
                191,
                199,
                207,
                215,
                223,
                227,
                231,
                235,
                239,
                243,
                247,
                251,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ]
        },

        // composantes de la table EOSB (IDL color table 27)
        eosb: {
            red: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                9,
                18,
                27,
                36,
                45,
                49,
                57,
                72,
                81,
                91,
                100,
                109,
                118,
                127,
                136,
                131,
                139,
                163,
                173,
                182,
                191,
                200,
                209,
                218,
                227,
                213,
                221,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                253,
                251,
                249,
                247,
                245,
                243,
                241,
                215,
                214,
                235,
                234,
                232,
                230,
                228,
                226,
                224,
                222,
                198,
                196,
                216,
                215,
                213,
                211,
                209,
                207,
                205,
                203,
                181,
                179,
                197,
                196,
                194,
                192,
                190,
                188,
                186,
                184,
                164,
                162,
                178,
                176,
                175,
                173,
                171,
                169,
                167,
                165,
                147,
                145,
                159,
                157,
                156,
                154,
                152,
                150,
                148,
                146,
                130,
                128,
                140,
                138,
                137,
                135,
                133,
                131,
                129,
                127,
                113,
                111,
                121,
                119,
                117,
                117
            ],

            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                7,
                15,
                23,
                31,
                39,
                47,
                55,
                57,
                64,
                79,
                87,
                95,
                103,
                111,
                119,
                127,
                135,
                129,
                136,
                159,
                167,
                175,
                183,
                191,
                199,
                207,
                215,
                200,
                207,
                239,
                247,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                229,
                229,
                255,
                250,
                246,
                242,
                238,
                233,
                229,
                225,
                198,
                195,
                212,
                208,
                204,
                199,
                195,
                191,
                187,
                182,
                160,
                156,
                169,
                165,
                161,
                157,
                153,
                148,
                144,
                140,
                122,
                118,
                127,
                125,
                123,
                121,
                119,
                116,
                114,
                112,
                99,
                97,
                106,
                104,
                102,
                99,
                97,
                95,
                93,
                91,
                80,
                78,
                84,
                82,
                80,
                78,
                76,
                74,
                72,
                70,
                61,
                59,
                63,
                61,
                59,
                57,
                55,
                53,
                50,
                48,
                42,
                40,
                42,
                40,
                38,
                36,
                33,
                31,
                29,
                27,
                22,
                21,
                21,
                19,
                16,
                14,
                12,
                13,
                8,
                6,
                3,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ],

            blue: [
                116,
                121,
                127,
                131,
                136,
                140,
                144,
                148,
                153,
                157,
                145,
                149,
                170,
                174,
                178,
                182,
                187,
                191,
                195,
                199,
                183,
                187,
                212,
                216,
                221,
                225,
                229,
                233,
                238,
                242,
                221,
                225,
                255,
                247,
                239,
                231,
                223,
                215,
                207,
                199,
                172,
                164,
                175,
                167,
                159,
                151,
                143,
                135,
                127,
                119,
                100,
                93,
                95,
                87,
                79,
                71,
                63,
                55,
                47,
                39,
                28,
                21,
                15,
                7,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },

        // tableau des composantes pour Stern
        stern: {
            red: [
                0,
                18,
                36,
                54,
                72,
                90,
                108,
                127,
                145,
                163,
                199,
                217,
                235,
                254,
                249,
                244,
                239,
                234,
                229,
                223,
                218,
                213,
                208,
                203,
                197,
                192,
                187,
                182,
                177,
                172,
                161,
                156,
                151,
                146,
                140,
                135,
                130,
                125,
                120,
                115,
                109,
                104,
                99,
                94,
                89,
                83,
                78,
                73,
                68,
                63,
                52,
                47,
                42,
                37,
                32,
                26,
                21,
                16,
                11,
                6,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254
            ],

            green: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254
            ],

            blue: [
                0,
                1,
                3,
                5,
                7,
                9,
                11,
                13,
                15,
                17,
                21,
                23,
                25,
                27,
                29,
                31,
                33,
                35,
                37,
                39,
                41,
                43,
                45,
                47,
                49,
                51,
                53,
                55,
                57,
                59,
                63,
                65,
                67,
                69,
                71,
                73,
                75,
                77,
                79,
                81,
                83,
                85,
                87,
                89,
                91,
                93,
                95,
                97,
                99,
                101,
                105,
                107,
                109,
                111,
                113,
                115,
                117,
                119,
                121,
                123,
                127,
                129,
                131,
                133,
                135,
                137,
                139,
                141,
                143,
                145,
                149,
                151,
                153,
                155,
                157,
                159,
                161,
                163,
                165,
                167,
                169,
                171,
                173,
                175,
                177,
                179,
                181,
                183,
                185,
                187,
                191,
                193,
                195,
                197,
                199,
                201,
                203,
                205,
                207,
                209,
                211,
                213,
                215,
                217,
                219,
                221,
                223,
                225,
                227,
                229,
                233,
                235,
                237,
                239,
                241,
                243,
                245,
                247,
                249,
                251,
                255,
                251,
                247,
                243,
                238,
                234,
                230,
                226,
                221,
                217,
                209,
                204,
                200,
                196,
                192,
                187,
                183,
                179,
                175,
                170,
                166,
                162,
                158,
                153,
                149,
                145,
                141,
                136,
                132,
                128,
                119,
                115,
                111,
                107,
                102,
                98,
                94,
                90,
                85,
                81,
                77,
                73,
                68,
                64,
                60,
                56,
                51,
                47,
                43,
                39,
                30,
                26,
                22,
                17,
                13,
                9,
                5,
                0,
                3,
                7,
                15,
                19,
                22,
                26,
                30,
                34,
                38,
                41,
                45,
                49,
                57,
                60,
                64,
                68,
                72,
                76,
                79,
                83,
                87,
                91,
                95,
                98,
                102,
                106,
                110,
                114,
                117,
                121,
                125,
                129,
                137,
                140,
                144,
                148,
                152,
                156,
                159,
                163,
                167,
                171,
                175,
                178,
                182,
                186,
                190,
                194,
                197,
                201,
                205,
                209,
                216,
                220,
                224,
                228,
                232,
                235,
                239,
                243,
                247,
                251
            ]
        },

        // composantes de la table rainbow (IDL color table 13)
        rainbow: {
            red: [
                0,
                4,
                9,
                13,
                18,
                22,
                27,
                31,
                36,
                40,
                45,
                50,
                54,
                58,
                61,
                64,
                68,
                69,
                72,
                74,
                77,
                79,
                80,
                82,
                83,
                85,
                84,
                86,
                87,
                88,
                86,
                87,
                87,
                87,
                85,
                84,
                84,
                84,
                83,
                79,
                78,
                77,
                76,
                71,
                70,
                68,
                66,
                60,
                58,
                55,
                53,
                46,
                43,
                40,
                36,
                33,
                25,
                21,
                16,
                12,
                4,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                12,
                21,
                25,
                29,
                33,
                42,
                46,
                51,
                55,
                63,
                67,
                72,
                76,
                80,
                89,
                93,
                97,
                101,
                110,
                114,
                119,
                123,
                131,
                135,
                140,
                144,
                153,
                157,
                161,
                165,
                169,
                178,
                182,
                187,
                191,
                199,
                203,
                208,
                212,
                221,
                225,
                229,
                233,
                242,
                246,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255
            ],
            green: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                4,
                8,
                16,
                21,
                25,
                29,
                38,
                42,
                46,
                51,
                55,
                63,
                67,
                72,
                76,
                84,
                89,
                93,
                97,
                106,
                110,
                114,
                119,
                127,
                131,
                135,
                140,
                144,
                152,
                157,
                161,
                165,
                174,
                178,
                182,
                187,
                195,
                199,
                203,
                208,
                216,
                220,
                225,
                229,
                233,
                242,
                246,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                250,
                242,
                238,
                233,
                229,
                221,
                216,
                212,
                208,
                199,
                195,
                191,
                187,
                178,
                174,
                170,
                165,
                161,
                153,
                148,
                144,
                140,
                131,
                127,
                123,
                119,
                110,
                106,
                102,
                97,
                89,
                85,
                80,
                76,
                72,
                63,
                59,
                55,
                51,
                42,
                38,
                34,
                29,
                21,
                17,
                12,
                8,
                0
            ],
            blue: [
                0,
                3,
                7,
                10,
                14,
                19,
                23,
                28,
                32,
                38,
                43,
                48,
                53,
                59,
                63,
                68,
                72,
                77,
                81,
                86,
                91,
                95,
                100,
                104,
                109,
                113,
                118,
                122,
                127,
                132,
                136,
                141,
                145,
                150,
                154,
                159,
                163,
                168,
                173,
                177,
                182,
                186,
                191,
                195,
                200,
                204,
                209,
                214,
                218,
                223,
                227,
                232,
                236,
                241,
                245,
                250,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                246,
                242,
                238,
                233,
                225,
                220,
                216,
                212,
                203,
                199,
                195,
                191,
                187,
                178,
                174,
                170,
                165,
                157,
                152,
                148,
                144,
                135,
                131,
                127,
                123,
                114,
                110,
                106,
                102,
                97,
                89,
                84,
                80,
                76,
                67,
                63,
                59,
                55,
                46,
                42,
                38,
                34,
                25,
                21,
                16,
                12,
                8,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ]
        },

        // Simple grey levels
        grey: {
            red: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ],
            green: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ],
            blue: [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255
            ]
        }
    };

    /**
     *    Create texture from array
     *    TODO : maybe move this function to renderContext ?
     *
     *    @param gl Context
     *    @param dataArray Array creating the texture
     *    @param format Content format(gl.LUMINANCE, gl.RGB...)
     *    @param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
     *    @param width Width of texture
     *    @param height Height of texture
     *
     *    @return GLTexture, or null caused by not supported format
     */
    function _textureFromPixelArray(
        gl,
        dataArray,
        format,
        dataType,
        width,
        height
    ) {
        var dataTypedArray;
        if (dataType === gl.UNSIGNED_BYTE) {
            dataTypedArray = new Uint8Array(dataArray);
        } else {
            if (dataType === gl.FLOAT) {
                dataTypedArray = new Float32Array(dataArray);
            } else {
                return null;
            }
        }

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            format,
            width,
            height,
            0,
            format,
            dataType,
            dataTypedArray
        );

        // NPOT properties
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
    }

    return {
        /**
         *    Create custom colormap with equidistant intervals
         *
         *    @param name Colormap name
         *    @param colors The array of colors defining the colormap(must have length at least >=2)
         */
        addCustomColormap: function(name, colors) {
            if (colors.length < 2) {
                console.error("Colors length must be >= 2");
                return null;
            }

            var colormapSize = 256;
            var colormap = {
                red: [],
                green: [],
                blue: []
            };

            var nbIntervals = colors.length - 1;
            for (var i = 0; i < nbIntervals; i++) {
                var c1 = colors[i];
                var c2 = colors[i + 1];

                var intervalLength = colormapSize / (colors.length - 1);
                var start = colormap.red.length;
                var end = Math.floor((i + 1) * intervalLength);
                for (var j = start; j < end; j++) {
                    colormap.red.push(Numeric.lerp(j / end, c1[0], c2[0]));
                    colormap.green.push(Numeric.lerp(j / end, c1[1], c2[1]));
                    colormap.blue.push(Numeric.lerp(j / end, c1[2], c2[2]));
                }
            }

            // Add to colormaps object
            colormaps[name] = colormap;
        },

        /**
         * Generate colormap
         */
        generateColormap: function(gl, transferFonction, colormap, inverse) {
            // var pas1 = 128./(tr1-tr0);
            // var pas2 = 128./(tr2-tr1);

            // Get transfer function
            var fctGap = transferFonctions[transferFonction];

            var cm = [];

            var Sr, Sg, Sb;
            Sr = colormaps[colormap].red;
            Sg = colormaps[colormap].green;
            Sb = colormaps[colormap].blue;
            var max = Sr.length - 1;
            for (var i = 0; i < 256; i++) {
                // int j= i<tr0 ? 0 :
                //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
                //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
                //               max;

                var j = fctGap[i];

                // Clamp
                if (j > max) {
                    j = max;
                } else {
                    if (j < 0) {
                        j = 0;
                    }
                }
                if (inverse) {
                    j = max - j;
                }

                // Normalize between [0..1]
                cm[i * 3] = Sr[j] / 256.0;
                cm[i * 3 + 1] = Sg[j] / 256.0;
                cm[i * 3 + 2] = Sb[j] / 256.0;
            }

            // Create new texture
            return _textureFromPixelArray(
                gl,
                cm,
                gl.RGB,
                gl.FLOAT,
                cm.length / 3,
                1
            );
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/DynamicImage',["./ColorMap"], function(ColorMap) {
    /**************************************************************************************************************/

    // TODO : Unify shader programs between TileManager, ConvexPolygonRenderer and ImageRenderer
    //		* inverse Y coordinates(if needed)
    //		* vTextureCoord name refactor
    var defaultFragmentCode = "precision highp float; \n";
    defaultFragmentCode += "varying vec2 vTextureCoord;\n";
    defaultFragmentCode += "uniform sampler2D texture; \n";
    defaultFragmentCode += "uniform sampler2D colormap; \n";
    defaultFragmentCode += "uniform float min; \n";
    defaultFragmentCode += "uniform float max; \n";
    defaultFragmentCode += "uniform vec4 color; \n";
    defaultFragmentCode += "void main(void)\n";
    defaultFragmentCode += "{\n";
    defaultFragmentCode += "	float i = texture2D(texture,vTextureCoord).r;\n";
    defaultFragmentCode +=
        "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
    defaultFragmentCode += "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
    defaultFragmentCode +=
        "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b,color.a);\n";
    defaultFragmentCode += "}\n";

    var defaultCallback = function(gl, renderable, program) {
        if (!program) {
            program = renderable.polygonProgram;
        }
        gl.uniform1f(program.uniforms.max, renderable.style.uniformValues.tmax);
        gl.uniform1f(program.uniforms.min, renderable.style.uniformValues.tmin);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(
            gl.TEXTURE_2D,
            renderable.style.uniformValues.colormapTex
        );
        gl.uniform1i(program.uniforms.colormap, 1);
    };

    /**************************************************************************************************************/

    /**
	 @name DynamicImage
	 @class
		DynamicImage constructor
	 @param renderContext
	 @param pixels
	 @param format
	 @param dataType
	 @param width
	 @param height
	 @param options
	 @constructor
	 */
    var DynamicImage = function(
        renderContext,
        pixels,
        format,
        dataType,
        width,
        height,
        options
    ) {
        // Initialize fragment shader and uniformsCallback if needed
        defaultFragmentCode =
            options && options.fragmentCode
                ? options.fragmentCode
                : defaultFragmentCode;
        defaultCallback =
            options && options.updateUniforms
                ? options.updateUniforms
                : defaultCallback;

        this.fragmentCode = defaultFragmentCode;
        this.updateUniforms = defaultCallback;
        this.tmin = 0.0;
        this.tmax = 1.0;
        this.colormapTex = null;
        this.renderContext = renderContext;

        // Parameters for histogram generation
        this.pixels = pixels;
        this.transferFn = "raw";
        this.inverse = false;

        // Create texture
        var gl = renderContext.gl;
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        // TODO : Flip around X axis
        //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            format,
            width,
            height,
            0,
            format,
            dataType,
            pixels
        );

        if (dataType === gl.FLOAT) {
            // Choose floating point texture filtering depending on extension support
            var float_linear_ext = gl.getExtension("OES_texture_float_linear");
            var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MIN_FILTER,
                float_filtering
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MAG_FILTER,
                float_filtering
            );
        } else {
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_MIN_FILTER,
                gl.LINEAR_MIPMAP_LINEAR
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        // NPOT properties
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        this.texture = tex;
        this.width = width;
        this.height = height;

        this.computeMinMax(pixels);
        renderContext.requestFrame();
    };

    /**************************************************************************************************************/

    /**
     * Compute min/max of fits data
     * @function computeMinMax
     * @memberof DynamicImage.prototype
     * @param pixels Fits data
     */
    DynamicImage.prototype.computeMinMax = function(pixels) {
        var max = Number.MIN_VALUE;
        var min = Number.MAX_VALUE;
        for (var i = 1; i < pixels.length; i++) {
            var val = pixels[i];
            if (isNaN(val)) {
                continue;
            }
            if (max < val) {
                max = val;
            }
            if (min > val) {
                min = val;
            }
        }
        this.min = min;
        this.max = max;
        this.tmax = max;
        this.tmin = min;
    };

    /**************************************************************************************************************/

    /**
     * Update colormap of current image
     * @function updateColormap
     * @memberof DynamicImage.prototype
     * @param transferFn Transfer function("linear", "log", "sqrt", "pow2", "asin")
     * @param colormap Colormap("grey", "rainbow", "fire", "stern", "eosb")
     * @param inverse Boolean indicating if colormap is inversed
     */
    DynamicImage.prototype.updateColormap = function(
        transferFn,
        colormap,
        inverse
    ) {
        var gl = this.renderContext.gl;
        if (transferFn !== "raw") {
            this.fragmentCode = defaultFragmentCode;
            this.updateUniforms = defaultCallback;
            // Dispose current texture
            if (this.colormapTex) {
                gl.deleteTexture(this.colormapTex);
            }

            this.colormapTex = ColorMap.generateColormap(
                gl,
                transferFn,
                colormap,
                inverse
            );
        } else {
            this.fragmentCode = null;
            this.updateUniforms = null;
        }
        this.transferFn = transferFn;
        this.inverse = inverse;
    };

    /**************************************************************************************************************/

    /**
     * Dispose textures
     * @function dispose
     * @memberof DynamicImage.prototype
     */
    DynamicImage.prototype.dispose = function() {
        var gl = this.renderContext.gl;
        if (this.colormapTex) {
            gl.deleteTexture(this.colormapTex);
        }
        if (this.texture) {
            gl.deleteTexture(this.texture);
        }

        this.colormapTex = null;
        this.texture = null;
    };

    /**************************************************************************************************************/

    return DynamicImage;
});

// Generated by CoffeeScript 1.4.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.2.3';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    function DataUnit(view, header) {
      this.view = view;
      this.begin = this.current = view.tell();
      this.length = void 0;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    Functions: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.extension = true;
        this.extensionType = value;
        this.verifyOrder("XTENSION", 0);
        return value;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"];
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"] + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTEND";
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "" + key + " must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BLANK";
        value = arguments[0];
        // if (!(this["BITPIX"] > 0)) {
        //   throw "" + key + " is not to be used for BITPIX = " + this['BITPIX'];
        // }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTVER";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      EXTLEVEL: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTLEVEL";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      TFIELDS: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TFIELDS";
        value = arguments[0];
        value = parseInt(value);
        this.verifyBetween(key, value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TBCOL";
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween(key, index, 0, this["TFIELDS"]);
        return value;
      },
      ZIMAGE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZIMAGE";
        value = arguments[0];
        return this.verifyBoolean(value);
      },
      ZCMPTYPE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZCMPTYPE";
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "" + key + " value " + value + " is not permitted";
        }
        if (value !== 'RICE_1' && value !== 'GZIP_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZBITPIX";
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZNAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween(key, value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZTILE";
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZPCOUNT";
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZGCOUNT";
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

    Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

    Header.stringPattern = /'(.*)'\s*\/*(.*)/;

    Header.arrayPattern = /([A-Za-z]+)(\d+)/;

    Header.include(HeaderVerify);

    function Header() {
      this.init = __bind(this.init, this);

      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.Functions;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cardIndex = 0;
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getIndex = function(key) {
      if (this.contains(key)) {
        return this.cards[key][0];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComment = function(key) {
      if (this.contains(key)) {
        if (this.cards[key][2] != null) {
          return this.cards[key][2];
        } else {
          return console.warn("" + key + " does not contain a comment");
        }
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComments = function() {
      if (this.contains('COMMENT')) {
        return this.cards['COMMENT'];
      } else {
        return console.warn("Header does not contain any COMMENT fields");
      }
    };

    Header.prototype.getHistory = function() {
      if (this.contains('HISTORY')) {
        return this.cards['HISTORY'];
      } else {
        return console.warn("Header does not contain any HISTORY fields");
      }
    };

    Header.prototype.set = function(key, value, comment) {
      this.cards[key] = comment ? [this.cardIndex, value, comment] : [this.cardIndex, value];
      return this.cardIndex += 1;
    };

    Header.prototype.setComment = function(comment) {
      if (!this.contains("COMMENT")) {
        this.cards["COMMENT"] = [];
        this.cardIndex += 1;
      }
      return this.cards["COMMENT"].push(comment);
    };

    Header.prototype.setHistory = function(history) {
      if (!this.contains("HISTORY")) {
        this.cards["HISTORY"] = [];
        this.cardIndex += 1;
      }
      return this.cards["HISTORY"].push(history);
    };

    Header.prototype.contains = function(keyword) {
      return this.cards.hasOwnProperty(keyword);
    };

    Header.prototype.readCard = function(line) {
      var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
      match = line.match(Header.keywordPattern);
      if (match == null) {
        return;
      }
      _ref = match.slice(1), key = _ref[0], value = _ref[1];
      if (key === "COMMENT" || key === "HISTORY") {
        match[1] = value.trim();
      } else if (value[0] === "'") {
        match = value.match(Header.stringPattern);
        match[1] = match[1].trim();
      } else {
        match = value.match(Header.nonStringPattern);
        match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F" ? match[1].trim() : parseFloat(match[1]);
      }
      match[2] = match[2].trim();
      _ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
      keyToVerify = key;
      _ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
      match = key.match(Header.arrayPattern);
      if (match != null) {
        keyToVerify = match[1];
        _ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
      }
      if (this.verifyCard.hasOwnProperty(keyToVerify)) {
        value = this.verifyCard[keyToVerify](value, array, index);
      }
      switch (key) {
        case "COMMENT":
          return this.setComment(value);
        case "HISTORY":
          return this.setHistory(value);
        default:
          this.set(key, value, comment);
          return this.__defineGetter__(key, function() {
            return this.cards[key][1];
          });
      }
    };

    Header.prototype.init = function(block) {
      var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
      lineWidth = 80;
      numLines = block.length / lineWidth;
      maxNumLines = 600;
      numLines = numLines < maxNumLines ? numLines : maxNumLines;
      _results = [];
      for (i = _i = 0, _ref = numLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readCard(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this["NAXIS"] === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    initArray: function(arrayType) {
      return this.data = new arrayType(this.width * this.height);
    },
    getExtremes: function() {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = this.data.length;
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(x, y) {
      return this.data[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    function Image(view, header) {
      var bitpix, i, naxis, _i,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header["NAXIS" + i]);
      }
      this.width = header["NAXIS1"];
      this.height = header["NAXIS2"] || 1;
      this.bzero = header["BZERO"] || 0;
      this.bscale = header["BSCALE"] || 1;
      this.rowByteSize = this.width * Math.abs(bitpix) / 8;
      this.totalRowsRead = 0;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      this.frame = 0;
      switch (bitpix) {
        case 8:
          if (this.bscale % 1 === 0) {
            this.arrayType = Uint8Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          }
          break;
        case 16:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int16Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          }
          break;
        case 32:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          }
          break;
        case 64:
          this.arrayType = this.bscale % 1 === 0 ? Int32Array : Float32Array;
          console.warn("Unusual behaviour with 64 bit integers.");
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return _this.bzero + _this.bscale * value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat64();
          };
          break;
        default:
          throw "Invalid BITPIX.";
      }
    }

    Image.prototype.getRow = function() {
      var i, _i, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[this.width * this.rowsRead + i] = this.accessor();
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    Image.prototype.getFrame = function(frame) {
      var height;
      this.frame = frame != null ? frame : this.frame;
      if (this.data == null) {
        this.initArray(this.arrayType);
      }
      this.totalRowsRead = this.width * this.frame;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.seek = function(frame) {
      if (frame == null) {
        frame = 0;
      }
      if (this.naxis.length === 2) {
        this.totalRowsRead = 0;
        return this.frame = 0;
      } else {
        this.totalRowsRead = this.height * frame;
        return this.frame = this.height / this.totalRowsRead - 1;
      }
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.dataAccessors = {
      L: function(view) {
        if (view.getInt8() === 84) {
          return true;
        } else {
          return false;
        }
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function Tabular(view, header) {
      this.getRow = __bind(this.getRow, this);
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.cols = header["TFIELDS"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header[key]);
      }
      return columnNames;
    };

    return Tabular;

  })(DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

    Table.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(view, header) {
      this.getRow = __bind(this.getRow, this);

      var form, i, match, _fn, _i, _ref,
        _this = this;
      Table.__super__.constructor.apply(this, arguments);
      _fn = function() {
        var accessor, dataType, decimals, length, _ref1;
        _ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
        accessor = function(value) {
          return Table.dataAccessors[dataType](value);
        };
        return _this.accessors.push(accessor);
      };
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header["TFORM" + i];
        match = form.match(Table.formPattern);
        _fn();
      }
    }

    Table.prototype.getRow = function(row) {
      var i, index, line, value, _i, _j, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      line = "";
      for (i = _i = 1, _ref = this.rowByteSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        line += this.view.getChar();
      }
      line = line.trim().split(/\s+/);
      row = {};
      for (index = _j = 0, _len = line.length; _j < _len; index = ++_j) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    function BinaryTable(view, header) {
      var dataType, i, keyword, length, match, value, _i, _ref, _ref1,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinaryTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinaryTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinaryTable.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data;
                data = BinaryTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          } else {
            (function(dataType, length) {
              var accessor, numBytes;
              if (dataType === 'X') {
                numBytes = Math.log(length) / Math.log(2);
                accessor = function() {
                  var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
                  byte2bits = function(byte) {
                    var bitarray;
                    bitarray = [];
                    i = 128;
                    while (i >= 1) {
                      bitarray.push((byte & i ? 1 : 0));
                      i /= 2;
                    }
                    return bitarray;
                  };
                  data = [];
                  for (i = _j = 1; 1 <= numBytes ? _j <= numBytes : _j >= numBytes; i = 1 <= numBytes ? ++_j : --_j) {
                    byte = _this.view.getUint8();
                    bitarray = byte2bits(byte);
                    for (_k = 0, _len = bitarray.length; _k < _len; _k++) {
                      bit = bitarray[_k];
                      data.push(bit);
                    }
                  }
                  return data.slice(0, +(length - 1) + 1 || 9e9);
                };
              } else if (dataType === 'A') {
                accessor = function() {
                  var data, _j;
                  data = '';
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data += BinaryTable.dataAccessors[dataType](_this.view);
                  }
                  return data.trim();
                };
              } else {
                accessor = function() {
                  var data, _j;
                  data = [];
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data.push(BinaryTable.dataAccessors[dataType](_this.view));
                  }
                  return data;
                };
              }
              return _this.accessors.push(accessor);
            })(dataType, length);
          }
        }
      }
    }

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    Rice: function(array, arrayLen, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    CompressedImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompressedImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompressedImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompressedImage.setValue(header, "BLANK", void 0);
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.width = header["ZNAXIS1"];
      this.height = header["ZNAXIS2"] || 1;
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = CompressedImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompressedImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompressedImage.setValue(header, "BZERO", 0);
      this.bscale = CompressedImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompressedImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompressedImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return new Float32Array(_this.ztile[0]);
                  }
                  pixels = new CompressedImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompressedImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, index, item, _j, _len;
                  data = _this._accessor(dataType);
                  if (data != null) {
                    data = new Float32Array(_this.width);
                    for (index = _j = 0, _len = data.length; _j < _len; index = ++_j) {
                      item = data[index];
                      data[index] = NaN;
                    }
                    return data;
                  } else {
                    return null;
                  }
                };
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompressedImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompressedImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompressedImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompressedImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompressedImage.prototype.defineGetRow = function() {
      var hasBlanks;
      this.totalRowsRead = 0;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompressedImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = value === blank ? NaN : zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getFrame = function() {
      var height;
      if (this.data == null) {
        this.initArray(Float32Array);
      }
      this.totalRowsRead = 0;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      return this.data;
    };

    CompressedImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompressedImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompressedImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompressedImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompressedImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompressedImage;

  })(Tabular);

  this.astro.FITS.CompressedImage = CompressedImage;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header[key];
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.LINEWIDTH = 80;

    File.BLOCKLENGTH = 2880;

    File.getType = function(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    };

    function File(buffer) {
      var name;
      name = File.getType(buffer);
      switch (name) {
        case 'arraybuffer':
          this.initFromBuffer(buffer);
          break;
        case 'object':
          this.initFromObject(buffer);
          break;
        default:
          throw 'fitsjs cannot initialize object';
      }
    }

    File.excessBytes = function(length) {
      return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH)) % File.BLOCKLENGTH;
    };

    File.extendDataView = function(view) {
      var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
      DataView.prototype.getString = function(length) {
        var c, i, value, _i, _ref;
        value = '';
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          c = this.getUint8();
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      DataView.prototype.getChar = function() {
        return this.getString(1);
      };
      view.offset = 0;
      getInt8 = view.getInt8;
      getUint8 = view.getUint8;
      getInt16 = view.getInt16;
      getUint16 = view.getUint16;
      getInt32 = view.getInt32;
      getUint32 = view.getUint32;
      getFloat32 = view.getFloat32;
      getFloat64 = view.getFloat64;
      view.getInt8 = function() {
        var value;
        value = getInt8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getUint8 = function() {
        var value;
        value = getUint8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getInt16 = function() {
        var value;
        value = getInt16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getUint16 = function() {
        var value;
        value = getUint16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getInt32 = function() {
        var value;
        value = getInt32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getUint32 = function() {
        var value;
        value = getUint32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat32 = function() {
        var value;
        value = getFloat32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat64 = function() {
        var value;
        value = getFloat64.apply(this, [this.offset, false]);
        this.offset += 8;
        return value;
      };
      view.seek = function(offset) {
        return this.offset = offset;
      };
      return view.tell = function() {
        return this.offset;
      };
    };

    File.prototype.initFromBuffer = function(buffer) {
      var data, hdu, header, _results;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      this.hdus = [];
      this.eof = false;
      File.extendDataView(this.view);
      _results = [];
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.eof) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    File.prototype.initFromObject = function(buffer) {
      this.length = buffer.length;
      this.view = null;
      this.hdus = buffer.hdus;
      return this.eof = true;
    };

    File.prototype.readHeader = function() {
      var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
      whitespacePattern = /\s{80}/;
      endPattern = /^END\s/;
      beginOffset = this.view.tell();
      done = false;
      while (true) {
        if (done) {
          break;
        }
        block = this.view.getString(File.BLOCKLENGTH);
        i = 0;
        while (true) {
          start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
          end = File.BLOCKLENGTH - File.LINEWIDTH * i;
          line = block.slice(start, end);
          match = line.match(whitespacePattern);
          if (match) {
            i += 1;
            continue;
          }
          match = line.match(endPattern);
          if (match) {
            endOffset = this.view.tell();
            this.view.seek(beginOffset);
            block = this.view.getString(endOffset - beginOffset);
            header = new Header();
            header.init(block);
            done = true;
            this.checkEOF();
            return header;
          }
          break;
        }
      }
    };

    File.prototype.readData = function(header) {
      var data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        data = new Image(this.view, header);
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            data = new CompressedImage(this.view, header);
          } else {
            data = new BinaryTable(this.view, header);
          }
        } else if (header.extensionType === "TABLE") {
          data = new Table(this.view, header);
        } else if (header.extensionType === "IMAGE") {
          data = new Image(this.view, header);
        }
      }
      excess = File.excessBytes(data.length);
      this.view.seek(this.view.tell() + data.length + excess);
      this.checkEOF();
      return data;
    };

    File.prototype.checkEOF = function() {
      if (this.view.offset >= this.length) {
        return this.eof = true;
      }
    };

    File.prototype.count = function() {
      return this.hdus.length;
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if (index == null) {
        index = void 0;
      }
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);

define("fits", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Layer/FitsLoader',["fits"], function() {
    /**
     *    Parse fits file
     *
     *    @param response XHR response containing fits
     *
     *    @return Parsed data
     */
    function parseFits(response) {
        var FITS = astro.FITS;
        // Initialize the FITS.File object using
        // the array buffer returned from the XHR
        var fits = new FITS.File(response);
        // Grab the first HDU with a data unit
        var hdu = fits.getHDU();
        var data = hdu.data;

        var uintPixels;
        var swapPixels = new Uint8Array(
            data.view.buffer,
            data.begin,
            data.length
        ); // with gl.UNSIGNED_byte

        var bpe;
        if (data.arrayType) {
            bpe = data.arrayType.BYTES_PER_ELEMENT;
        } else {
            bpe = Math.abs(hdu.header.BITPIX) / 8;
        }
        for (var i = 0; i < swapPixels.length; i += bpe) {
            var temp;
            // Swap to little-endian
            for (var j = 0; j < bpe / 2; j++) {
                temp = swapPixels[i + j];
                swapPixels[i + j] = swapPixels[i + bpe - 1 - j];
                swapPixels[i + bpe - 1 - j] = temp;
            }
        }

        return fits;
    }

    var loadFits = function(
        url,
        successCallback,
        failCallback,
        onprogressCallback
    ) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    if (xhr.response) {
                        var fits = parseFits(xhr.response);
                        if (successCallback) {
                            successCallback(fits);
                        }
                    }
                } else {
                    console.error("Error while loading " + url);
                    if (failCallback) {
                        failCallback();
                    }
                }
            }
        };

        // Define default on progress function, otherwise
        // Firefox won't take Content-length header into account
        // so evt.lengthComputable will be always set to false..
        xhr.onprogress = function(evt) {};
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.send();
        return xhr;
    };

    return {
        loadFits: loadFits,
        parseFits: parseFits
    };
});

(function() {'use strict';var p=void 0,v=!0,da=this;function fa(f,e){var c=f.split("."),a=da;!(c[0]in a)&&a.execScript&&a.execScript("var "+c[0]);for(var b;c.length&&(b=c.shift());)!c.length&&e!==p?a[b]=e:a=a[b]?a[b]:a[b]={}};var C="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function F(f,e){this.index="number"===typeof e?e:0;this.f=0;this.buffer=f instanceof(C?Uint8Array:Array)?f:new (C?Uint8Array:Array)(32768);if(2*this.buffer.length<=this.index)throw Error("invalid index");this.buffer.length<=this.index&&ga(this)}function ga(f){var e=f.buffer,c,a=e.length,b=new (C?Uint8Array:Array)(a<<1);if(C)b.set(e);else for(c=0;c<a;++c)b[c]=e[c];return f.buffer=b}
F.prototype.b=function(f,e,c){var a=this.buffer,b=this.index,g=this.f,l=a[b],m;c&&1<e&&(f=8<e?(H[f&255]<<24|H[f>>>8&255]<<16|H[f>>>16&255]<<8|H[f>>>24&255])>>32-e:H[f]>>8-e);if(8>e+g)l=l<<e|f,g+=e;else for(m=0;m<e;++m)l=l<<1|f>>e-m-1&1,8===++g&&(g=0,a[b++]=H[l],l=0,b===a.length&&(a=ga(this)));a[b]=l;this.buffer=a;this.f=g;this.index=b};F.prototype.finish=function(){var f=this.buffer,e=this.index,c;0<this.f&&(f[e]<<=8-this.f,f[e]=H[f[e]],e++);C?c=f.subarray(0,e):(f.length=e,c=f);return c};
var ia=new (C?Uint8Array:Array)(256),M;for(M=0;256>M;++M){for(var N=M,S=N,ja=7,N=N>>>1;N;N>>>=1)S<<=1,S|=N&1,--ja;ia[M]=(S<<ja&255)>>>0}var H=ia;function ka(f,e,c){var a,b="number"===typeof e?e:e=0,g="number"===typeof c?c:f.length;a=-1;for(b=g&7;b--;++e)a=a>>>8^T[(a^f[e])&255];for(b=g>>3;b--;e+=8)a=a>>>8^T[(a^f[e])&255],a=a>>>8^T[(a^f[e+1])&255],a=a>>>8^T[(a^f[e+2])&255],a=a>>>8^T[(a^f[e+3])&255],a=a>>>8^T[(a^f[e+4])&255],a=a>>>8^T[(a^f[e+5])&255],a=a>>>8^T[(a^f[e+6])&255],a=a>>>8^T[(a^f[e+7])&255];return(a^4294967295)>>>0}
var la=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,
2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,
2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,
2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,
3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,
936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],T=C?new Uint32Array(la):la;function U(f){this.buffer=new (C?Uint16Array:Array)(2*f);this.length=0}U.prototype.getParent=function(f){return 2*((f-2)/4|0)};U.prototype.push=function(f,e){var c,a,b=this.buffer,g;c=this.length;b[this.length++]=e;for(b[this.length++]=f;0<c;)if(a=this.getParent(c),b[c]>b[a])g=b[c],b[c]=b[a],b[a]=g,g=b[c+1],b[c+1]=b[a+1],b[a+1]=g,c=a;else break;return this.length};
U.prototype.pop=function(){var f,e,c=this.buffer,a,b,g;e=c[0];f=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(g=0;;){b=2*g+2;if(b>=this.length)break;b+2<this.length&&c[b+2]>c[b]&&(b+=2);if(c[b]>c[g])a=c[g],c[g]=c[b],c[b]=a,a=c[g+1],c[g+1]=c[b+1],c[b+1]=a;else break;g=b}return{index:f,value:e,length:this.length}};function ma(f,e){this.h=na;this.j=0;this.input=C&&f instanceof Array?new Uint8Array(f):f;this.c=0;e&&(e.lazy&&(this.j=e.lazy),"number"===typeof e.compressionType&&(this.h=e.compressionType),e.outputBuffer&&(this.a=C&&e.outputBuffer instanceof Array?new Uint8Array(e.outputBuffer):e.outputBuffer),"number"===typeof e.outputIndex&&(this.c=e.outputIndex));this.a||(this.a=new (C?Uint8Array:Array)(32768))}var na=2,V=[],$;
for($=0;288>$;$++)switch(v){case 143>=$:V.push([$+48,8]);break;case 255>=$:V.push([$-144+400,9]);break;case 279>=$:V.push([$-256+0,7]);break;case 287>=$:V.push([$-280+192,8]);break;default:throw"invalid literal: "+$;}
ma.prototype.g=function(){var f,e,c,a,b=this.input;switch(this.h){case 0:c=0;for(a=b.length;c<a;){e=C?b.subarray(c,c+65535):b.slice(c,c+65535);c+=e.length;var g=e,l=c===a,m=p,d=p,h=p,s=p,x=p,n=this.a,k=this.c;if(C){for(n=new Uint8Array(this.a.buffer);n.length<=k+g.length+5;)n=new Uint8Array(n.length<<1);n.set(this.a)}m=l?1:0;n[k++]=m|0;d=g.length;h=~d+65536&65535;n[k++]=d&255;n[k++]=d>>>8&255;n[k++]=h&255;n[k++]=h>>>8&255;if(C)n.set(g,k),k+=g.length,n=n.subarray(0,k);else{s=0;for(x=g.length;s<x;++s)n[k++]=
g[s];n.length=k}this.c=k;this.a=n}break;case 1:var q=new F(C?new Uint8Array(this.a.buffer):this.a,this.c);q.b(1,1,v);q.b(1,2,v);var u=oa(this,b),w,aa,z;w=0;for(aa=u.length;w<aa;w++)if(z=u[w],F.prototype.b.apply(q,V[z]),256<z)q.b(u[++w],u[++w],v),q.b(u[++w],5),q.b(u[++w],u[++w],v);else if(256===z)break;this.a=q.finish();this.c=this.a.length;break;case na:var B=new F(C?new Uint8Array(this.a.buffer):this.a,this.c),ra,L,O,P,Q,Ha=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],W,sa,X,ta,ba,ea=Array(19),
ua,R,ca,y,va;ra=na;B.b(1,1,v);B.b(ra,2,v);L=oa(this,b);W=pa(this.n,15);sa=qa(W);X=pa(this.m,7);ta=qa(X);for(O=286;257<O&&0===W[O-1];O--);for(P=30;1<P&&0===X[P-1];P--);var wa=O,xa=P,G=new (C?Uint32Array:Array)(wa+xa),r,I,t,Y,E=new (C?Uint32Array:Array)(316),D,A,J=new (C?Uint8Array:Array)(19);for(r=I=0;r<wa;r++)G[I++]=W[r];for(r=0;r<xa;r++)G[I++]=X[r];if(!C){r=0;for(Y=J.length;r<Y;++r)J[r]=0}r=D=0;for(Y=G.length;r<Y;r+=I){for(I=1;r+I<Y&&G[r+I]===G[r];++I);t=I;if(0===G[r])if(3>t)for(;0<t--;)E[D++]=0,
J[0]++;else for(;0<t;)A=138>t?t:138,A>t-3&&A<t&&(A=t-3),10>=A?(E[D++]=17,E[D++]=A-3,J[17]++):(E[D++]=18,E[D++]=A-11,J[18]++),t-=A;else if(E[D++]=G[r],J[G[r]]++,t--,3>t)for(;0<t--;)E[D++]=G[r],J[G[r]]++;else for(;0<t;)A=6>t?t:6,A>t-3&&A<t&&(A=t-3),E[D++]=16,E[D++]=A-3,J[16]++,t-=A}f=C?E.subarray(0,D):E.slice(0,D);ba=pa(J,7);for(y=0;19>y;y++)ea[y]=ba[Ha[y]];for(Q=19;4<Q&&0===ea[Q-1];Q--);ua=qa(ba);B.b(O-257,5,v);B.b(P-1,5,v);B.b(Q-4,4,v);for(y=0;y<Q;y++)B.b(ea[y],3,v);y=0;for(va=f.length;y<va;y++)if(R=
f[y],B.b(ua[R],ba[R],v),16<=R){y++;switch(R){case 16:ca=2;break;case 17:ca=3;break;case 18:ca=7;break;default:throw"invalid code: "+R;}B.b(f[y],ca,v)}var ya=[sa,W],za=[ta,X],K,Aa,Z,ha,Ba,Ca,Da,Ea;Ba=ya[0];Ca=ya[1];Da=za[0];Ea=za[1];K=0;for(Aa=L.length;K<Aa;++K)if(Z=L[K],B.b(Ba[Z],Ca[Z],v),256<Z)B.b(L[++K],L[++K],v),ha=L[++K],B.b(Da[ha],Ea[ha],v),B.b(L[++K],L[++K],v);else if(256===Z)break;this.a=B.finish();this.c=this.a.length;break;default:throw"invalid compression type";}return this.a};
function Fa(f,e){this.length=f;this.k=e}
var Ga=function(){function f(b){switch(v){case 3===b:return[257,b-3,0];case 4===b:return[258,b-4,0];case 5===b:return[259,b-5,0];case 6===b:return[260,b-6,0];case 7===b:return[261,b-7,0];case 8===b:return[262,b-8,0];case 9===b:return[263,b-9,0];case 10===b:return[264,b-10,0];case 12>=b:return[265,b-11,1];case 14>=b:return[266,b-13,1];case 16>=b:return[267,b-15,1];case 18>=b:return[268,b-17,1];case 22>=b:return[269,b-19,2];case 26>=b:return[270,b-23,2];case 30>=b:return[271,b-27,2];case 34>=b:return[272,
b-31,2];case 42>=b:return[273,b-35,3];case 50>=b:return[274,b-43,3];case 58>=b:return[275,b-51,3];case 66>=b:return[276,b-59,3];case 82>=b:return[277,b-67,4];case 98>=b:return[278,b-83,4];case 114>=b:return[279,b-99,4];case 130>=b:return[280,b-115,4];case 162>=b:return[281,b-131,5];case 194>=b:return[282,b-163,5];case 226>=b:return[283,b-195,5];case 257>=b:return[284,b-227,5];case 258===b:return[285,b-258,0];default:throw"invalid length: "+b;}}var e=[],c,a;for(c=3;258>=c;c++)a=f(c),e[c]=a[2]<<24|
a[1]<<16|a[0];return e}(),Ia=C?new Uint32Array(Ga):Ga;
function oa(f,e){function c(b,e){var a=b.k,c=[],g=0,f;f=Ia[b.length];c[g++]=f&65535;c[g++]=f>>16&255;c[g++]=f>>24;var d;switch(v){case 1===a:d=[0,a-1,0];break;case 2===a:d=[1,a-2,0];break;case 3===a:d=[2,a-3,0];break;case 4===a:d=[3,a-4,0];break;case 6>=a:d=[4,a-5,1];break;case 8>=a:d=[5,a-7,1];break;case 12>=a:d=[6,a-9,2];break;case 16>=a:d=[7,a-13,2];break;case 24>=a:d=[8,a-17,3];break;case 32>=a:d=[9,a-25,3];break;case 48>=a:d=[10,a-33,4];break;case 64>=a:d=[11,a-49,4];break;case 96>=a:d=[12,a-
65,5];break;case 128>=a:d=[13,a-97,5];break;case 192>=a:d=[14,a-129,6];break;case 256>=a:d=[15,a-193,6];break;case 384>=a:d=[16,a-257,7];break;case 512>=a:d=[17,a-385,7];break;case 768>=a:d=[18,a-513,8];break;case 1024>=a:d=[19,a-769,8];break;case 1536>=a:d=[20,a-1025,9];break;case 2048>=a:d=[21,a-1537,9];break;case 3072>=a:d=[22,a-2049,10];break;case 4096>=a:d=[23,a-3073,10];break;case 6144>=a:d=[24,a-4097,11];break;case 8192>=a:d=[25,a-6145,11];break;case 12288>=a:d=[26,a-8193,12];break;case 16384>=
a:d=[27,a-12289,12];break;case 24576>=a:d=[28,a-16385,13];break;case 32768>=a:d=[29,a-24577,13];break;default:throw"invalid distance";}f=d;c[g++]=f[0];c[g++]=f[1];c[g++]=f[2];var h,l;h=0;for(l=c.length;h<l;++h)n[k++]=c[h];u[c[0]]++;w[c[3]]++;q=b.length+e-1;x=null}var a,b,g,l,m,d={},h,s,x,n=C?new Uint16Array(2*e.length):[],k=0,q=0,u=new (C?Uint32Array:Array)(286),w=new (C?Uint32Array:Array)(30),aa=f.j,z;if(!C){for(g=0;285>=g;)u[g++]=0;for(g=0;29>=g;)w[g++]=0}u[256]=1;a=0;for(b=e.length;a<b;++a){g=
m=0;for(l=3;g<l&&a+g!==b;++g)m=m<<8|e[a+g];d[m]===p&&(d[m]=[]);h=d[m];if(!(0<q--)){for(;0<h.length&&32768<a-h[0];)h.shift();if(a+3>=b){x&&c(x,-1);g=0;for(l=b-a;g<l;++g)z=e[a+g],n[k++]=z,++u[z];break}0<h.length?(s=Ja(e,a,h),x?x.length<s.length?(z=e[a-1],n[k++]=z,++u[z],c(s,0)):c(x,-1):s.length<aa?x=s:c(s,0)):x?c(x,-1):(z=e[a],n[k++]=z,++u[z])}h.push(a)}n[k++]=256;u[256]++;f.n=u;f.m=w;return C?n.subarray(0,k):n}
function Ja(f,e,c){var a,b,g=0,l,m,d,h,s=f.length;m=0;h=c.length;a:for(;m<h;m++){a=c[h-m-1];l=3;if(3<g){for(d=g;3<d;d--)if(f[a+d-1]!==f[e+d-1])continue a;l=g}for(;258>l&&e+l<s&&f[a+l]===f[e+l];)++l;l>g&&(b=a,g=l);if(258===l)break}return new Fa(g,e-b)}
function pa(f,e){var c=f.length,a=new U(572),b=new (C?Uint8Array:Array)(c),g,l,m,d,h;if(!C)for(d=0;d<c;d++)b[d]=0;for(d=0;d<c;++d)0<f[d]&&a.push(d,f[d]);g=Array(a.length/2);l=new (C?Uint32Array:Array)(a.length/2);if(1===g.length)return b[a.pop().index]=1,b;d=0;for(h=a.length/2;d<h;++d)g[d]=a.pop(),l[d]=g[d].value;m=Ka(l,l.length,e);d=0;for(h=g.length;d<h;++d)b[g[d].index]=m[d];return b}
function Ka(f,e,c){function a(b){var c=d[b][h[b]];c===e?(a(b+1),a(b+1)):--l[c];++h[b]}var b=new (C?Uint16Array:Array)(c),g=new (C?Uint8Array:Array)(c),l=new (C?Uint8Array:Array)(e),m=Array(c),d=Array(c),h=Array(c),s=(1<<c)-e,x=1<<c-1,n,k,q,u,w;b[c-1]=e;for(k=0;k<c;++k)s<x?g[k]=0:(g[k]=1,s-=x),s<<=1,b[c-2-k]=(b[c-1-k]/2|0)+e;b[0]=g[0];m[0]=Array(b[0]);d[0]=Array(b[0]);for(k=1;k<c;++k)b[k]>2*b[k-1]+g[k]&&(b[k]=2*b[k-1]+g[k]),m[k]=Array(b[k]),d[k]=Array(b[k]);for(n=0;n<e;++n)l[n]=c;for(q=0;q<b[c-1];++q)m[c-
1][q]=f[q],d[c-1][q]=q;for(n=0;n<c;++n)h[n]=0;1===g[c-1]&&(--l[0],++h[c-1]);for(k=c-2;0<=k;--k){u=n=0;w=h[k+1];for(q=0;q<b[k];q++)u=m[k+1][w]+m[k+1][w+1],u>f[n]?(m[k][q]=u,d[k][q]=e,w+=2):(m[k][q]=f[n],d[k][q]=n,++n);h[k]=0;1===g[k]&&a(k)}return l}
function qa(f){var e=new (C?Uint16Array:Array)(f.length),c=[],a=[],b=0,g,l,m,d;g=0;for(l=f.length;g<l;g++)c[f[g]]=(c[f[g]]|0)+1;g=1;for(l=16;g<=l;g++)a[g]=b,b+=c[g]|0,b<<=1;g=0;for(l=f.length;g<l;g++){b=a[f[g]];a[f[g]]+=1;m=e[g]=0;for(d=f[g];m<d;m++)e[g]=e[g]<<1|b&1,b>>>=1}return e};function La(f,e){this.input=f;this.c=this.i=0;this.d={};e&&(e.flags&&(this.d=e.flags),"string"===typeof e.filename&&(this.filename=e.filename),"string"===typeof e.comment&&(this.l=e.comment),e.deflateOptions&&(this.e=e.deflateOptions));this.e||(this.e={})}
La.prototype.g=function(){var f,e,c,a,b,g,l,m,d=new (C?Uint8Array:Array)(32768),h=0,s=this.input,x=this.i,n=this.filename,k=this.l;d[h++]=31;d[h++]=139;d[h++]=8;f=0;this.d.fname&&(f|=Ma);this.d.fcomment&&(f|=Na);this.d.fhcrc&&(f|=Oa);d[h++]=f;e=(Date.now?Date.now():+new Date)/1E3|0;d[h++]=e&255;d[h++]=e>>>8&255;d[h++]=e>>>16&255;d[h++]=e>>>24&255;d[h++]=0;d[h++]=Pa;if(this.d.fname!==p){l=0;for(m=n.length;l<m;++l)g=n.charCodeAt(l),255<g&&(d[h++]=g>>>8&255),d[h++]=g&255;d[h++]=0}if(this.d.comment){l=
0;for(m=k.length;l<m;++l)g=k.charCodeAt(l),255<g&&(d[h++]=g>>>8&255),d[h++]=g&255;d[h++]=0}this.d.fhcrc&&(c=ka(d,0,h)&65535,d[h++]=c&255,d[h++]=c>>>8&255);this.e.outputBuffer=d;this.e.outputIndex=h;b=new ma(s,this.e);d=b.g();h=b.c;C&&(h+8>d.buffer.byteLength?(this.a=new Uint8Array(h+8),this.a.set(new Uint8Array(d.buffer)),d=this.a):d=new Uint8Array(d.buffer));a=ka(s,p,p);d[h++]=a&255;d[h++]=a>>>8&255;d[h++]=a>>>16&255;d[h++]=a>>>24&255;m=s.length;d[h++]=m&255;d[h++]=m>>>8&255;d[h++]=m>>>16&255;d[h++]=
m>>>24&255;this.i=x;C&&h<d.length&&(this.a=d=d.subarray(0,h));return d};var Pa=255,Oa=2,Ma=8,Na=16;fa("Zlib.Gzip",La);fa("Zlib.Gzip.prototype.compress",La.prototype.g);}).call(this);

define("gzip", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Layer/FitsRequest',["../Utils/ImageRequest"], function(ImageRequest) {
    /**************************************************************************************************************/

    /*
     *	Override send function to handle fits requests
     */
    ImageRequest.prototype.send = function(url, crossOrigin, noRequest) {
        var self = this;
        if (noRequest || url == null) {
            self.failCallback(self);
            return;
        }
        if (url.search("fits") > 0) {
            // Fits
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(e) {
                if (xhr && xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        if (xhr.response) {
                            self.image = xhr.response;
                            if (self.successCallback) {
                                self.successCallback(self);
                            }
                        }
                    } else {
                        if (xhr.status !== 0) {
                            // Fail
                            console.error("Error while loading " + url);
                            if (self.failCallback) {
                                self.failCallback(self);
                            }
                        }
                    }
                    xhr = null;
                }
            };

            xhr.onabort = function(e) {
                if (self.abortCallback) {
                    self.abortCallback(self);
                }
                self.xhr = null;
            };

            xhr.open("GET", url);
            xhr.responseType = "arraybuffer";
            xhr.send();
            this.xhr = xhr;
        } else {
            this.image = new Image();
            this.image.aborted = false;
            this.image.crossOrigin = "";
            this.image.dataType = "byte";
            this.image.onload = function() {
                var isComplete =
                    self.image.naturalWidth !== 0 && self.image.complete;
                if (isComplete && !this.aborted) {
                    self.successCallback(self);
                }
            };
            this.image.onerror = function() {
                if (self.failCallback && !this.aborted) {
                    self.failCallback(self);
                }
            };
            this.image.src = url;
        }
    };

    /**************************************************************************************************************/

    /*
     *	Override abort
     */
    ImageRequest.prototype.abort = function() {
        if (this.xhr) {
            this.xhr.abort();
        } else {
            if (this.abortCallback) {
                this.abortCallback(this);
            }
            this.image.aborted = true;
            this.image.src = "";
        }
    };

    /**************************************************************************************************************/
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/HipsFitsLayer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Tiling/HEALPixTiling",
    "./AbstractHipsLayer",
    "../Renderer/DynamicImage",
    "./FitsLoader",
    "gzip",
    "../Utils/ImageRequest",
    "./FitsRequest"
], function(
    Contants,
    Utils,
    Constants,
    HEALPixTiling,
    AbstractHipsLayer,
    DynamicImage,
    FitsLoader,
    gZip,
    ImageRequest
) {
    /**************************************************************************************************************/

    /**
     * HipsFits configuration
     * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.hipsFits_configuration
     * @property {Function} onready - Callback function
     */

    /**
     * @name HipsFitsLayer
     * @class
     * This layer draws an Hips Fits Image
     * @augments AbstractHipsLayer
     * @param {Object} hipsMetadata - HIPS Metadata
     * @param {AbstractHipsLayer.hipsFits_configuration} options - HipsFits configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     */
    var HipsFitsLayer = function(hipsMetadata, options) {
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            options
        );

        this._ready = false;
        this.fitsSupported = true;

        // allsky
        this.levelZeroImage = null;

        // TODO use DynamicImage shaders by unifying shader programs between TileManager and ConvexPolygonRenderer
        //		* inverse Y coordinates, some var names refactor..
        this.rawFragShader = "precision lowp float; \n";
        this.rawFragShader += "varying vec2 texCoord;\n";
        this.rawFragShader += "uniform sampler2D colorTexture; \n";
        this.rawFragShader += "uniform float opacity; \n";
        this.rawFragShader += "uniform float inversed; \n";
        this.rawFragShader += "bool isnan(float val) {\n";
        this.rawFragShader +=
            "		return (val <= 0.0 || 0.0 <= val) ? ((val == 5e-324) ? true : false) : true;\n";
        this.rawFragShader += "}\n";
        this.rawFragShader += "void main(void)\n";
        this.rawFragShader += "{\n";
        this.rawFragShader +=
            "	vec4 color = texture2D(colorTexture, vec2(texCoord.x, (inversed == 1.) ? 1.0 - texCoord.y : texCoord.y));\n";
        this.rawFragShader +=
            "	gl_FragColor = vec4(color.r,color.g,color.b, color.a*opacity);\n";
        this.rawFragShader +=
            "	if (isnan( (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3. ) )\n";
        this.rawFragShader += "	{\n";
        this.rawFragShader += "		gl_FragColor.a = 0.;\n";
        this.rawFragShader += "	}\n";
        this.rawFragShader += "}\n";

        this.colormapFragShader = "precision lowp float; \n";
        this.colormapFragShader += "varying vec2 texCoord;\n";
        this.colormapFragShader += "uniform sampler2D colorTexture; \n";
        this.colormapFragShader += "uniform sampler2D colormap; \n";
        this.colormapFragShader += "uniform float min; \n";
        this.colormapFragShader += "uniform float max; \n";
        this.colormapFragShader += "uniform float opacity; \n";
        this.colormapFragShader += "bool isnan(float val) {\n";
        this.colormapFragShader +=
            "	return (val <= 0.0 || 0.0 <= val) ? false : true;\n";
        this.colormapFragShader += "}\n";
        this.colormapFragShader += "void main(void)\n";
        this.colormapFragShader += "{\n";
        this.colormapFragShader +=
            "	float i = texture2D(colorTexture,vec2(texCoord.x, 1.0 - texCoord.y)).r;\n";
        this.colormapFragShader +=
            "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
        this.colormapFragShader +=
            "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
        this.colormapFragShader +=
            "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b, cmValue.a*opacity);\n";
        this.colormapFragShader += "	if (isnan( i ) )\n";
        this.colormapFragShader += "	{\n";
        this.colormapFragShader += "		 gl_FragColor.a = 0.;\n";
        this.colormapFragShader += "	}\n";
        this.colormapFragShader += "}\n";

        var self = this;

        this.customShader = {
            fragmentCode: this.rawFragShader,
            updateUniforms: function(gl, program) {
                // Level zero image is required to init uniforms
                gl.uniform1f(program.uniforms.inversed, self.inversed);
                if (self.levelZeroImage) {
                    gl.uniform1f(
                        program.uniforms.max,
                        self.levelZeroImage.tmax
                    );
                    gl.uniform1f(
                        program.uniforms.min,
                        self.levelZeroImage.tmin
                    );

                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(
                        gl.TEXTURE_2D,
                        self.levelZeroImage.colormapTex
                    );
                    gl.uniform1i(program.uniforms.colormap, 1);
                    gl.uniform1f(program.uniforms.opacity, self.getOpacity());
                }
            }
        };

        // Request for level zero image
        this.imageRequest = new ImageRequest({
            successCallback: function() {
                var data, res;
                self._ready = true;

                if (self.format === "fits") {
                    // Unzip if g-zipped
                    try {
                        data = new Uint8Array(self.imageRequest.image);
                        res = gZip.unzip(data);
                        self.imageRequest.image = new Uint8Array(res).buffer;
                    } catch (err) {
                        if (err !== "Not a GZIP file") {
                            // G-zip error
                            console.error(err);
                            this.failCallback();
                            return;
                        } else {
                            // Image isn't g-zipped, handle image as fits
                            console.log("not gzipped");
                            data = null;
                        }
                    }

                    self.handleImage(self.imageRequest);
                    var fitsData = self.imageRequest.image;
                    if (self.globe) {
                        // Create level zero image
                        var gl = self.globe.getRenderContext().gl;
                        self.levelZeroImage = new DynamicImage(
                            self.globe.getRenderContext(),
                            fitsData.typedArray,
                            gl.LUMINANCE,
                            gl.FLOAT,
                            fitsData.width,
                            fitsData.height
                        );
                        self.getLevelZeroTexture = function() {
                            return self.levelZeroImage.texture;
                        };
                    }
                } else {
                    self.levelZeroImage = this.image;
                    self.getLevelZeroTexture = null;
                }

                // Call callback if set
                if (options.onready && options.onready instanceof Function) {
                    options.onready(self);
                }

                // Request a frame
                if (self.globe) {
                    self.globe.getRenderContext().requestFrame();
                }
            },
            /**
             * @fires Layer#baseLayersError
             */
            failCallback: function() {
                if (self.globe) {
                    self.globe.publishEvent(
                        Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                        self
                    );
                    self._ready = false;
                }
            },
            abortCallback: function(iq) {
                self._ready = false;
            }
        });
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsFitsLayer);

    /**************************************************************************************************************/

    /**
     * Attach the Hips Fits layer to the globe
     * @function _attach
     * @memberof HipsFitsLayer.prototype
     * @param {AbstractGlobe} g Globe to attach
     * @private
     */
    HipsFitsLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);

        // Enable float texture extension to have higher luminance range
        var gl = this.getGlobe().getRenderContext().gl;

        this.requestLevelZeroImage();
        var ext = gl.getExtension("OES_texture_float");

        if (!ext) {
            // TODO
            console.error("no OES_texture_float");
            this.fitsSupported = false;
            //return;
        }
    };

    /**************************************************************************************************************/

    /**
     * Detach the Hips Fits layer from the globe
     * @function _detach
     * @memberof HipsFitsLayer#
     * @private
     */
    HipsFitsLayer.prototype._detach = function() {
        // Abort image request if in progress
        if (!this._ready) {
            this.imageRequest.abort();
        }
        this._ready = false;
        this.disposeResources();

        AbstractHipsLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Get url from a given tile
     * @function getUrl
     * @memberof HipsFitsLayer#
     * @param {Tile} tile Tile object
     */
    HipsFitsLayer.prototype.getUrl = function(tile) {
        var url = this.baseUrl;

        url += "/Norder";
        url += tile.order;

        url += "/Dir";
        url += Math.floor(tile.pixelIndex / 10000.0) * 10000.0;

        url += "/Npix";
        url += tile.pixelIndex;
        url += "." + this.format;

        return this.proxify(url);
    };

    /**************************************************************************************************************/

    /**
     * Extracts fits data from levelZeroImage.pixels to fitsPixel according to pixel index
     * @function extractFitsData
     * @memberof HipsFitsLayer#
     * @param pi Pixel index
     * @param fitsPixel Resulting typed vector containing fits data
     * @param sx X-offset of fitsPixel
     * @param sy Y-offset of fitsPixel
     */
    HipsFitsLayer.prototype.extractFitsData = function(pi, fitsPixel, sx, sy) {
        var size = 64;
        var height = this.levelZeroImage.height;
        var width = this.levelZeroImage.width;
        var pixels = this.levelZeroImage.pixels;

        var startIndex =
            size * width * (28 - Math.floor(pi / 27)) + (pi % 27) * size;

        // Extract fits data
        var typedLine;
        for (var i = 0; i < size; i++) {
            typedLine = pixels.subarray(
                startIndex + i * width,
                startIndex + i * width + size
            );
            fitsPixel.set(typedLine, sy + i * 128 + sx);
        }
    };

    /**************************************************************************************************************/

    /**
     * Generates the level0 texture for the tiles
     * @function generateLevel0Textures
     * @memberof HipsFitsLayer#
     * @param tiles
     * @param tilePool
     */
    HipsFitsLayer.prototype.generateLevel0Textures = function(tiles, tilePool) {
        var fitsPixel;
        var pi, sx, sy;
        var i, tile;
        var imgData;
        if (this.format !== "fits") {
            // Create a canvas to build the texture
            var canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 128;
            var context = canvas.getContext("2d");

            for (i = 0; i < tiles.length; i++) {
                tile = tiles[i];

                // Top left
                pi = tile.pixelIndex * 4;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    0,
                    0,
                    64,
                    64
                );

                // Top right
                pi = tile.pixelIndex * 4 + 2;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    64,
                    0,
                    64,
                    64
                );

                // Bottom left
                pi = tile.pixelIndex * 4 + 1;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    0,
                    64,
                    64,
                    64
                );

                // Bottom right
                pi = tile.pixelIndex * 4 + 3;
                sx = (pi % 27) * 64;
                sy = Math.floor(pi / 27) * 64;
                context.drawImage(
                    this.levelZeroImage,
                    sx,
                    sy,
                    64,
                    64,
                    64,
                    64,
                    64,
                    64
                );

                imgData = context.getImageData(0, 0, 128, 128);
                imgData.dataType = "byte";

                tile.texture = tilePool.createGLTexture(imgData);
                tile.imageSize = 128;
            }
        } else {
            for (i = 0; i < tiles.length; i++) {
                tile = tiles[i];
                fitsPixel = new Float32Array(128 * 128);

                // Top left
                pi = tile.pixelIndex * 4;
                this.extractFitsData(pi, fitsPixel, 0, 128 * 64);

                // Top right
                pi = tile.pixelIndex * 4 + 2;
                this.extractFitsData(pi, fitsPixel, 64, 128 * 64);

                // Bottom left
                pi = tile.pixelIndex * 4 + 1;
                this.extractFitsData(pi, fitsPixel, 0, 0);

                // Bottom right
                pi = tile.pixelIndex * 4 + 3;
                this.extractFitsData(pi, fitsPixel, 64, 0);

                imgData = {
                    typedArray: fitsPixel,
                    width: 128,
                    height: 128,
                    dataType: "float"
                };

                tile.texture = tilePool.createGLTexture(imgData);
                tile.imageSize = 128;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Handles the fits image.
     * @function handleImage
     * @memberof HipsFitsLayer#
     * @param imgRequest
     */
    HipsFitsLayer.prototype.handleImage = function(imgRequest) {
        if (!(imgRequest.image instanceof Image)) {
            var fits = FitsLoader.parseFits(imgRequest.image);
            var fitsData = fits.getHDU().data;
            var bpe = fitsData.arrayType.BYTES_PER_ELEMENT;
            var float32array, float64array;
            var i;
            if (fitsData.arrayType.name === "Float64Array") {
                float64array = new Float64Array(
                    fitsData.view.buffer,
                    fitsData.begin,
                    fitsData.length / bpe
                ); // bpe = 8
                float32array = new Float32Array(fitsData.length / bpe);
                // Create Float32Array from Float64Array
                for (i = 0; i < float64array.length; i++) {
                    float32array[i] = float64array[i];
                }
            } else {
                float32array = new Float32Array(
                    fitsData.view.buffer,
                    fitsData.begin,
                    fitsData.length / bpe
                ); // with gl.FLOAT, bpe = 4
            }

            // // Handle different types/formats.. just in case.
            // var dataType;
            // var typedArray;
            // var gl = this.globe.getRenderContext().gl;
            // var glType;
            // if ( fitsData.arrayType.name == "Float32Array" )
            // {
            // 	typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT );
            // 	dataType = "float";
            // 	glType = gl.FLOAT;
            // 	glFormat = gl.LUMINANCE;
            // }
            // else if ( fitsData.arrayType.name == "Uint8Array" )
            // {
            // 	typedArray = new Uint8Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT )
            // 	dataType = "int";
            // 	glType = gl.UNSIGNED_BYTE;
            // 	glFormat = gl.LUMINANCE;
            // }

            imgRequest.image = {
                typedArray: float32array,
                width: fitsData.width,
                height: fitsData.height,
                dataType: "float"
            };
        }
    };

    /**************************************************************************************************************/

    /**
     * Requests level zero image
     * @function requestLevelZeroImage
     * @memberof HipsFitsLayer#
     */
    HipsFitsLayer.prototype.requestLevelZeroImage = function() {
        // Set dataType always to jpg if fits isn't supported by graphic card
        if (!this.fitsSupported) {
            this.format = "jpg";
        }

        // Revert to raw rendering
        this.customShader.fragmentCode = this.rawFragShader;
        if (this.format === "fits") {
            this.inversed = 1.0;
        } else {
            this.inversed = 0.0;
        }

        var url = this.baseUrl + "/Norder3/Allsky." + this.format;
        this.imageRequest.send(url);
    };

    /**************************************************************************************************************/

    /**
     * Disposes the allocated resources
     * @function disposeResources
     * @memberof HipsFitsLayer#
     */
    HipsFitsLayer.prototype.disposeResources = function() {
        // Dispose level zero image & texture
        if (this.levelZeroImage && this.levelZeroImage.dispose) {
            this.levelZeroImage.dispose();
        }
        if (this.levelZeroTexture) {
            this.getGlobe()
                .getRenderContext()
                .gl.deleteTexture(this.levelZeroTexture);
        }

        this.levelZeroImage = null;
        this.levelZeroTexture = null;
    };

    /**************************************************************************************************************/

    /**
     *    Sets the format
     *    (currently never used)
     *    TODO: store basic format(could be 'png' or 'jpg'), to be
     *    able to revert from fits
     * @function setFormat
     * @memberof HipsFitsLayer#
     * @param {String} format Format
     */
    HipsFitsLayer.prototype.setFormat = function(format) {
        this.format = isFits ? "fits" : "jpg";
    };

    /**************************************************************************************************************/

    return HipsFitsLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/HipsGraphicLayer',[
    "../Utils/Utils",
    "../Tiling/HEALPixTiling",
    "./AbstractHipsLayer",
    "../Utils/Constants"
], function(Utils, HEALPixTiling, AbstractHipsLayer, Constants) {
    /**************************************************************************************************************/

    /**
     * HipsFits configuration
     * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.graphic_configuration
     * @property {Function} onready - Callback function
     */

    /**
     * @name HipsGraphicLayer
     * @class
     * This layer draws an Hips Image
     * @augments AbstractHipsLayer
     * @param {HipsMetadata} hipsMetadata
     * @param {AbstractHipsLayer.graphic_configuration} options - HipsGraphic configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     * @fires Layer#baseLayersError
     */
    var HipsGraphicLayer = function(hipsMetadata, options) {        
        //options.format = options.format || "jpg";
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            options
        );

        this._ready = false;
        

        // allsky
        this.levelZeroImage = new Image();
        var self = this;
        this.levelZeroImage.crossOrigin = "";
        this.levelZeroImage.onload = function() {
            self._ready = true;
            console.log("ready ok");
            // Call callback if set
            if (options.onready && options.onready instanceof Function) {
                options.onready(self);
            }

            // Request a frame
            if (self.globe) {
                self.globe.getRenderContext().requestFrame();
            }
        };
        this.levelZeroImage.onerror = function(event) {
            var error = self.getHipsMetadata();
            error.message = "Cannot load " + self.levelZeroImage.src;
            self.globe.publishEvent(
                Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                error
            );
            self._ready = false;

            console.error("Cannot load " + self.levelZeroImage.src);
        };

    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsGraphicLayer);

    /**************************************************************************************************************/

    /**
     * Attaches the raster layer to the planet.
     * @function _attach
     * @memberof HipsGraphicLayer#
     * @param g Globe
     * @private
     */
    HipsGraphicLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);

        // Load level zero image now, only for background
        this.loadOverview();
    };

    /**
     * Loads image overview
     * @function loadOverview
     * @memberof HipsGraphicLayer
     */
    HipsGraphicLayer.prototype.loadOverview = function() {
        if (this.isBackground()) {
            this.levelZeroImage.src =
                this.proxify(this.baseUrl) + "/Norder3/Allsky." + this.format;
        }
    }

    /**************************************************************************************************************/

    /**
     * Returns an url from a given tile.
     * @function getUrl
     * @memberof HipsGraphicLayer#
     * @param {Tile} tile Tile
     * @return {String} Url
     */
    HipsGraphicLayer.prototype.getUrl = function(tile) {
        var url = this.proxify(this.baseUrl);

        url += "/Norder";
        url += tile.order;

        url += "/Dir";
        var indexDirectory = Math.floor(tile.pixelIndex / 10000.0) * 10000.0;
        url += indexDirectory;

        url += "/Npix";
        url += tile.pixelIndex;
        url += "." + this.format;

        return this.proxify(url);
    };

    /**************************************************************************************************************/

    /**
     * Generates the level0 texture for the tiles.
     * @function generateLevel0Textures
     * @memberof HipsGraphicLayer
     * @param {Tile} tiles
     * @param {TilePool} tilePool
     */
    HipsGraphicLayer.prototype.generateLevel0Textures = function(
        tiles,
        tilePool
    ) {
        // Create a canvas to build the texture
        var canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        var i, pi, sx, sy, tile;
        var context = canvas.getContext("2d");

        for (i = 0; i < tiles.length; i++) {
            tile = tiles[i];

            // Top left
            pi = tile.pixelIndex * 4;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                0,
                0,
                64,
                64
            );

            // Top right
            pi = tile.pixelIndex * 4 + 2;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                64,
                0,
                64,
                64
            );

            // Bottom left
            pi = tile.pixelIndex * 4 + 1;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                0,
                64,
                64,
                64
            );

            // Bottom right
            pi = tile.pixelIndex * 4 + 3;
            sx = (pi % 27) * 64;
            sy = Math.floor(pi / 27) * 64;
            context.drawImage(
                this.levelZeroImage,
                sx,
                sy,
                64,
                64,
                64,
                64,
                64,
                64
            );

            var imgData = context.getImageData(0, 0, 128, 128);
            imgData.dataType = "byte";

            tile.texture = tilePool.createGLTexture(imgData);
            tile.imageSize = 128;
        }
    };

    /**************************************************************************************************************/

    return HipsGraphicLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/MocLayer',[
    "jquery",
    "underscore-min",
    "./AbstractLayer",
    "../Utils/Constants",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Tiling/HEALPixBase",
    "./FitsLoader"
], function(
    $,
    _,
    AbstractLayer,
    Constants,
    FeatureStyle,
    Utils,
    HEALPixBase,
    FitsLoader
) {
    /**
     * MocLayer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.moc_configuration
     * @property {string} baseUrl - service URL
     * @property {int} [startOrder = 2] - Starting order of HEALPix tiling
     * @property {Object} [style] - See {@link FeatureStyle} description
     */
    /**
     * @name MocLayer
     * @class
     * This layer draws a MOC data
     * @augments AbstractLayer
     * @param {AbstractLayer.moc_configuration} options - Moc layer configuration
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/MOC/20140602/index.html Moc}
     */
    var MocLayer = function(options) {
        options.dataType = Constants.GEOMETRY.LineString;
        AbstractLayer.prototype.constructor.call(
            this,
            Constants.LAYER.Moc,
            options
        );

        this.baseUrl = this.proxify(options.baseUrl);
        this.startOrder = options.startOrder || 2;

        if (options.coordinateSystem && options.coordinateSystem.geoideName) {
            this.crs = {
                properties: {
                    name: options.coordinateSystem.geoideName
                }
            };
        } else {
            this.crs = {
                properties: {
                    name: "Equatorial"
                }
            };
        }

        // Set style
        if (options && options.style) {
            this.style = new FeatureStyle(options.style);
        } else {
            this.style = new FeatureStyle();
        }

        this.featuresSet = null;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, MocLayer);

    /**************************************************************************************************************/

    /**
     * @function getInformationType
     * @memberof MocLayer#
     */
    MocLayer.prototype.getInformationType = function() {
        return Constants.INFORMATION_TYPE.VECTOR;
    }

    /**
     * Attaches the layer to the planet
     * @function _attach
     * @memberof MocLayer#
     * @param g Planet
     * @protected
     */
    MocLayer.prototype._attach = function(g) {
        AbstractLayer.prototype._attach.call(this, g);

        var self = this;
        var i;

        try {
            FitsLoader.loadFits(self.baseUrl, function(fits) {
                var healpixMoc = {};
                var binaryTable = fits.getHDU(1).data;

                // setting startOrder with first order in dataTable
                //self.startOrder = uniq2hpix(binaryTable.getRow(0)[binaryTable.columns[0]])[0];

                for (i = 0; i < binaryTable.rows; i++) {
                    var uniq = binaryTable.getRow(i);
                    var hpix = HEALPixBase.uniq2hpix(
                        uniq[binaryTable.columns[0]]
                    );

                    var order = hpix[0];
                    if (healpixMoc[order] === undefined) {
                        healpixMoc[order] = [];
                    }
                    healpixMoc[order].push(hpix[1]);
                }
                // MIZAR CANNOT display MOC with order less than 3, convert the current moc to a moc starting a order 3
                if (
                    healpixMoc.hasOwnProperty("0") ||
                    healpixMoc.hasOwnProperty("1") ||
                    healpixMoc.hasOwnProperty("2")
                ) {
                    for (i = 0; i < 3; i++) {
                        if (healpixMoc.hasOwnProperty(i)) {
                            var pixels = healpixMoc[i];
                            _.each(pixels, function(pixel) {
                                var pix = HEALPixBase.getChildren(pixel);
                                if (!healpixMoc.hasOwnProperty(i + 1)) {
                                    healpixMoc[i + 1] = [];
                                }
                                healpixMoc[i + 1].push(pix[0]);
                                healpixMoc[i + 1].push(pix[1]);
                                healpixMoc[i + 1].push(pix[2]);
                                healpixMoc[i + 1].push(pix[3]);
                            });
                            delete healpixMoc[i];
                        }
                    }
                }
                self.moc = healpixMoc;
                self.handleDistribution(healpixMoc);
                delete fits;
            });
        } catch (e) {
            $.ajax({
                type: "GET",
                url: self.baseUrl,
                dataType: "json",
                success: function(response) {
                    self.handleDistribution(response);
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    $("#addLayer_" + self.id)
                        .find("label")
                        .css("color", "red");
                    console.error(xhr.responseText);
                }
            });
        }

        // As post renderer, moc layer will regenerate data on tiles in case of base imagery change
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Generates moc data on tiles.
     * @function generate
     * @memberof MocLayer#
     * @param {Tile} tile Tile
     */
    MocLayer.prototype.generate = function(tile) {
        if (this.featuresSet && tile.order === this.startOrder) {
            var geometries = this.featuresSet[tile.pixelIndex];
            if (geometries) {
                for (var i = 0; i < geometries.length; i++) {
                    this.getGlobe()
                        .getRendererManager()
                        .addGeometryToTile(
                            this,
                            geometries[i],
                            this.style,
                            tile
                        );
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Renders
     * @function render
     * @memberof MocLayer#
     */
    MocLayer.prototype.render = function() {
        // No rendering
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the planet
     * @function _detach
     * @memberof MocLayer#
     * @private
     */
    MocLayer.prototype._detach = function() {
        for (var tileIndex in this.featuresSet) {
            if (this.featuresSet.hasOwnProperty(tileIndex)) {
                var tile = this.getGlobe().getTileManager().level0Tiles[
                    tileIndex
                ];
                for (var i = 0; i < this.featuresSet[tileIndex].length; i++) {
                    this.getGlobe()
                        .getRendererManager()
                        .removeGeometryFromTile(
                            this.featuresSet[tileIndex][i],
                            tile
                        );
                }
            }
        }
        this.featuresSet = null;
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);

        AbstractLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Returns children indices of starting tiling order.
     * @function findChildIndices
     * @memberof MocLayer#
     * @param index Parent index
     * @param order Parent order
     */
    MocLayer.prototype.findChildIndices = function(index, order) {
        var childOrder = this.startOrder;
        var orderDepth = childOrder - order;
        var numSubTiles = Math.pow(4, orderDepth); // Number of subtiles depending on order
        var firstSubTileIndex = index * numSubTiles;
        var indices = [];
        for (
            var i = firstSubTileIndex;
            i < firstSubTileIndex + numSubTiles;
            i++
        ) {
            indices.push(i);
        }

        return indices;
    };

    /**************************************************************************************************************/

    /**
     * Returns index of parent of starting tiling order.
     * @function findParentIndex
     * @memberof MocLayer#
     * @param index Child index
     * @param order Child order
     */
    MocLayer.prototype.findParentIndex = function(index, order) {
        var parentOrder = this.startOrder;
        var orderDepth = order - parentOrder;
        return Math.floor(index / Math.pow(4, orderDepth));
    };

    /**************************************************************************************************************/

    /**
     * Handles MOC response.
     * @function handleDistribution
     * @memberof MocLayer#
     * @param response MOC response
     */
    MocLayer.prototype.handleDistribution = function(response) {
        var gl = this.getGlobe()
            .getTileManager()
            .getRenderContext().gl;
        this.featuresSet = {};
        var parentIndex;
        var i, u, v;
        // For each order, compute rectangles geometry depending on the pixel index
        for (var key in response) {
            if (response.hasOwnProperty(key)) {
                var order = parseInt(key, 10);
                for (i = 0; i < response[key].length; i++) {
                    var pixelIndex = response[key][i];

                    if (order > this.startOrder) {
                        parentIndex = this.findParentIndex(pixelIndex, order);
                    } else if (order === this.startOrder) {
                        parentIndex = pixelIndex;
                    } else {
                        // Handle low orders(< 3) by creating children polygons of order 3
                        var indices = this.findChildIndices(pixelIndex, order);
                        if (
                            response[this.startOrder.toString()] === undefined
                        ) {
                            response[
                                this.startOrder.toString()
                            ] = response[0].concat(indices);
                        } else {
                            response[this.startOrder.toString()] = response[
                                this.startOrder.toString()
                            ].concat(indices);
                        }
                        continue;
                    }

                    var geometry = {
                        type: Constants.GEOMETRY.Polygon,
                        gid: "moc" + this.id + "_" + order + "_" + pixelIndex,
                        crs: this.crs,
                        coordinates: [[]]
                    };

                    // Build the vertices
                    var size = 2; // TODO
                    var step = 1;

                    // Tesselate only low-order tiles
                    if (order < 5) {
                        size = 5;
                        step = 1.0 / (size - 1);
                    }

                    var nside = Math.pow(2, order);
                    var pix = pixelIndex & (nside * nside - 1);
                    var ix = HEALPixBase.compress_bits(pix);
                    var iy = HEALPixBase.compress_bits(pix >>> 1);
                    var face = pixelIndex >>> (2 * order);

                    var vertice, geo;

                    // Horizontal boudaries
                    for (u = 0; u < 2; u++) {
                        for (v = 0; v < size; v++) {
                            vertice = HEALPixBase.fxyf(
                                (ix + u * (size - 1) * step) / nside,
                                (iy + v * step) / nside,
                                face
                            );
                            geo = this.getGlobe()
                                .getCoordinateSystem()
                                .getWorldFrom3D(vertice);
                            if (u === 0) {
                                // Invert to clockwise sense
                                geometry.coordinates[0][
                                    2 * u * size + (size - 1) - v
                                ] = [geo[0], geo[1]];
                            } else {
                                geometry.coordinates[0][2 * u * size + v] = [
                                    geo[0],
                                    geo[1]
                                ];
                            }
                        }
                    }

                    // Vertical boundaries
                    for (v = 0; v < 2; v++) {
                        for (u = 0; u < size; u++) {
                            vertice = HEALPixBase.fxyf(
                                (ix + u * step) / nside,
                                (iy + v * (size - 1) * step) / nside,
                                face
                            );
                            geo = this.getGlobe()
                                .getCoordinateSystem()
                                .getWorldFrom3D(vertice);
                            if (v === 1) {
                                // Invert to clockwise sense
                                geometry.coordinates[0][
                                    size + 2 * v * size + (size - 1) - u
                                ] = [geo[0], geo[1]];
                            } else {
                                geometry.coordinates[0][
                                    size + 2 * v * size + u
                                ] = [geo[0], geo[1]];
                            }
                        }
                    }

                    var parentTile = this.getGlobe().getTileManager()
                        .level0Tiles[parentIndex];

                    if (!this.featuresSet[parentIndex]) {
                        this.featuresSet[parentIndex] = [];
                    }

                    this.featuresSet[parentIndex].push(geometry);
                    this.getGlobe()
                        .getRendererManager()
                        .addGeometryToTile(
                            this,
                            geometry,
                            this.style,
                            parentTile
                        );
                }
            }
        }
    };

    return MocLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/RendererManager',["../Utils/Constants", "./RasterOverlayRenderer"], function(
    Constants,
    RasterOverlayRenderer
) {
    /**************************************************************************************************************/

    /**
     @name RendererManager
     @class
         RendererManager constructor
     @param {AbstractGlobe} globe AbstractGlobe
     @constructor
     */
    var RendererManager = function(globe) {
        // Create the registered renderers
        this.renderers = [];
        for (var i = 0; i < RendererManager.factory.length; i++) {
            this.renderers.push(RendererManager.factory[i](globe));
        }

        // The array of renderables used during rendering
        this.renderables = [];

        // To uniquely identify buckets created by the renderers
        this.bucketId = 0;
    };

    /**************************************************************************************************************/

    /**
     The factory for renderers
     */
    RendererManager.factory = [];

    /**************************************************************************************************************/

    /**
     * Set the selected layer on the top.
     * @function setSelectedRasterBucket
     * @memberof RendererManager.prototype
     * @param selectedLayer Layer to draw on the top
     */
    RendererManager.prototype.setSelectedRasterBucket = function(
        selectedLayer
    ) {
        var rendererIdx = this.renderers.length;
        while (rendererIdx--) {
            var renderer = this.renderers[rendererIdx];
            if (renderer instanceof RasterOverlayRenderer) {
                var buckets = renderer.buckets;
                var bucketIdx = buckets.length;
                while (bucketIdx--) {
                    var bucket = buckets[bucketIdx];
                    var layer = bucket.layer;
                    if (
                        bucket.style.zIndex ==
                            Constants.DISPLAY.SELECTED_RASTER &&
                        bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER
                    ) {
                        bucket.style.zIndex = Constants.DISPLAY.DEFAULT_RASTER;
                    }
                    if (
                        layer.getID() === selectedLayer.getID() &&
                        bucket.style.zIndex <= Constants.DISPLAY.SELECTED_RASTER
                    ) {
                        bucket.style.zIndex = Constants.DISPLAY.SELECTED_RASTER;
                    }
                }
            }
        }
    };

    /**
     * Get a renderer
     * @function getRenderer
     * @memberof RendererManager.prototype
     * @param geometry
     * @param style
     * @return Renderer
     */
    RendererManager.prototype.getRenderer = function(geometry, style) {
        for (var i = 0; i < this.renderers.length; i++) {
            if (this.renderers[i].canApply(geometry.type, style)) {
                return this.renderers[i];
            }
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     *    Generate the tile data
     * @function generate
     * @memberof RendererManager.prototype
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.generate = function(tile) {
        var i;
        if (!tile.parent) {
            for (i = 0; i < this.renderers.length; i++) {
                this.renderers[i].generateLevelZero(tile);
            }
        } else {
            var tileData = tile.parent.extension.renderer;
            if (tileData) {
                // delete renderer created at init time
                delete tile.extension.renderer;

                // Now generate renderables
                for (i = 0; i < tileData.renderables.length; i++) {
                    var renderable = tileData.renderables[i];
                    if (renderable.generateChild) {
                        renderable.generateChild(tile);
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderer
     * @function addGeometry
     * @memberof RendererManager.prototype
     * @param layer
     * @param geometry
     * @param style
     */
    RendererManager.prototype.addGeometry = function(
        layer,
        geometry,
        style
    ) {
        var renderer = this.getRenderer(geometry, style);
        if (renderer) {
            renderer.addGeometry(layer, geometry, style);
        } else {
            console.error("No renderer for RendererManager");
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderer
     * @function removeGeometry
     * @memberof RendererManager.prototype
     * @param geometry
     * @param layer
     * @return {Boolean}
     */
    RendererManager.prototype.removeGeometry = function(geometry, layer) {
        var bucket = geometry._bucket;
        if (bucket && bucket.layer === layer) {
            /*if (layer.type === "OpenSearch") {
             if (bucket.renderer.removeGeometryOneLevel(geometry) !== "undefined") {
             bucket.renderer.removeGeometryOneLevel(geometry);
             return true;
             }
             }*/
            bucket.renderer.removeGeometry(geometry);
            return true;
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a tile
     * @function addGeometryToTile
     * @memberof RendererManager.prototype
     * @param layer
     * @param geometry
     * @param style
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.addGeometryToTile = function(
        layer,
        geometry,
        style,
        tile
    ) {
        var renderer = this.getRenderer(geometry, style);
        renderer.addGeometryToTile(layer, geometry, style, tile);
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a tile
     * @function removeGeometryFromTile
     * @memberof RendererManager.prototype
     * @param geometry
     * @param {Tile} tile Tile
     */
    RendererManager.prototype.removeGeometryFromTile = function(
        geometry,
        tile
    ) {
        var bucket = geometry._bucket;
        bucket.renderer.removeGeometryFromTile(geometry, tile, false);
    };

    /**************************************************************************************************************/

    /**
     * Function to sort with zIndex, then bucket
     */
    var renderableSort = function(r1, r2) {
        var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
        if (zdiff === 0) {
            return r1.bucket.id - r2.bucket.id;
        } else {
            return zdiff;
        }
    };

    /**************************************************************************************************************/

    /**
     * Render all
     * @function render
     * @memberof RendererManager.prototype
     */
    RendererManager.prototype.render = function() {
        // Add main renderables
        var i, j;
        for (j = 0; j < this.renderers.length; j++) {
            var buckets = this.renderers[j].buckets;
            for (i = 0; i < buckets.length; i++) {
                if (buckets[i].layer.isVisible() && buckets[i].mainRenderable) {
                    this.renderables.push(buckets[i].mainRenderable);
                }
            }
        }

        // Renderable sort
        this.renderables.sort(renderableSort);
        //var renderCall = 0;

        i = 0;
        while (i < this.renderables.length) {
            j = i + 1;
            var currentRenderer = this.renderables[i].bucket.renderer;
            while (
                j < this.renderables.length &&
                this.renderables[j].bucket.renderer === currentRenderer
            ) {
                j++;
            }

            //var minLevel =  (this.renderables[i].bucket.layer.minLevel) ? this.renderables[i].bucket.layer.minLevel : 0;
            //var processedLevel = this.renderables[i].bucket.renderer.tileManager.processedLevel;
            //if(minLevel <= processedLevel) {
            currentRenderer.render(this.renderables, i, j);
            //}
            //renderCall++;

            i = j;
        }

        //console.log( "# of render calls "  + renderCall );

        this.renderables.length = 0;
    };

    /**************************************************************************************************************/

    return RendererManager;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchUtils',[],function() {
    var OpenSearchUtils = {};

    /*************************************************************************************************************/

    /**
     * Get the attribute value
     * @function getAttributeValue
     * @memberof OpenSearchUtils#
     * @param {Object} object Object describing the parameter
     * @param {String} name Name of the parameter
     * @return {String} Value
     */
    OpenSearchUtils.getAttributeValue = function(object, name) {
        var reconstructedName = "_attr" + name;
        if (typeof object[reconstructedName] !== "undefined") {
            if (typeof object[reconstructedName]._value != "undefined") {
                return object[reconstructedName]._value;
            }
        }
        return null;
    };

    /*************************************************************************************************************/

    /**
     * Get the value
     * @function getValue
     * @memberof OpenSearchUtils#
     * @param {Object} object Object describing the parameter
     * @param {String} name Name of the parameter
     * @return {String} Value
     */
    OpenSearchUtils.getValue = function(object, name) {
        if (typeof object[name] !== "undefined") {
            if (typeof object[name]._text !== "undefined") {
                return object[name]._text;
            }
        }
        return null;
    };

    /*************************************************************************************************************/

    /**
     * Set the current value of a parameter
     * @function setCurrentValueToParam
     * @memberof OpenSearchUtils#
     * @param {OpenSearchFrom} form Form
     * @param {String} name Name of the parameter
     * @param {String} value Value to set
     */
    OpenSearchUtils.setCurrentValueToParam = function(form, name, value) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.name === name) {
                param.currentValue = value;
                $("#p_" + name).val(value);
                break;
            }
        }
    };

    /*************************************************************************************************************/

    /**
     * Get the current value of a parameter
     * @function getCurrentValue
     * @memberof OpenSearchUtils#
     * @param {OpenSearchFrom} form Form
     * @param {String} name Name of the parameter
     * @return {String} Current value
     */
    OpenSearchUtils.getCurrentValue = function(form, name) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.name === name) {
                return param.currentValue;
            }
        }
    };

    /*************************************************************************************************************/

    /**
     * Init navigation values
     * @function initNavigationValues
     * @memberof OpenSearchUtils#
     * @param {OpenSearchFrom} form Form
     */
    OpenSearchUtils.initNavigationValues = function(form) {
        var param; // param managed
        for (var i = 0; i < form.parameters.length; i++) {
            param = form.parameters[i];
            if (param.name === "maxRecords") {
                param.currentValue = Math.ceil(param.maxInclusive * 0.2);
                //param.currentValue = Math.ceil(param.maxInclusive * 1);
                //param.currentValue = 20;
            } else if (param.name === "page") {
                param.currentValue = 1;
            } else {
                //console.log(param.name,param);
            }
        }
    };

    /*************************************************************************************************************/

    return OpenSearchUtils;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchParam',["./OpenSearchUtils"], function(OpenSearchUtils) {
    /**
     * @name OpenSearchParam
     * @class
     * All informations describing a parameter in an OpenSearch form
     * @param {Object} a json object describing the param
     * @memberof module:Layer
     */
    var OpenSearchParam = function(paramJson) {
        // init all values
        this.name = null; // Name of parameters
        this.value = null; // Value identifying the parameters
        this.title = null; // Title of parameter (for display)
        this.minInclusive = null; // (Level 1 Control - Number) Min value inclusive
        this.maxInclusive = null; // (Level 1 Control - Number) Max value inclusive
        this.pattern = null; // (Level 1 Control - String) Pattern
        this.options = null; // List of values if list provided
        this.currentValue = null; // Value to pass to parameter
        this.defaultValue = null; // Default value
        this.displayValue = ""; // Display value

        this.parseJson(paramJson);
    };

    /**************************************************************************************************************/

    /**
     * Parse Json
     * @function parseJson
     * @memberof OpenSearchParam#
     * @param {Object} paramJson Json object
     */

    OpenSearchParam.prototype.parseJson = function(paramJson) {
        this.name = OpenSearchUtils.getAttributeValue(paramJson, "name");
        this.name = this.name.replace(/\./g, "_");
        this.value = OpenSearchUtils.getAttributeValue(paramJson, "value");
        this.title = OpenSearchUtils.getAttributeValue(paramJson, "title");
        this.minInclusive = OpenSearchUtils.getAttributeValue(
            paramJson,
            "minInclusive"
        );
        this.maxInclusive = OpenSearchUtils.getAttributeValue(
            paramJson,
            "maxInclusive"
        );
        this.pattern = OpenSearchUtils.getAttributeValue(paramJson, "pattern");

        if (this.pattern === null) {
            this.patternAttribute = "";
        } else {
            this.patternAttribute = 'pattern="' + this.pattern + '" ';
        }

        if (paramJson.Option !== undefined) {
            this.options = [];
            if (paramJson.Option.length !== undefined) {
                for (var i = 0; i < paramJson.Option.length; i++) {
                    this.options.push(
                        OpenSearchUtils.getAttributeValue(
                            paramJson.Option[i],
                            "value"
                        )
                    );
                }
            } else {
                this.options.push(
                    OpenSearchUtils.getAttributeValue(paramJson.Option, "value")
                );
            }
        }
        if (paramJson.Option !== undefined) {
            this.options = [];
            if (paramJson.Option.length !== undefined) {
                for (var j = 0; j < paramJson.Option.length; j++) {
                    this.options.push(
                        OpenSearchUtils.getAttributeValue(
                            paramJson.Option[j],
                            "value"
                        )
                    );
                }
            } else {
                this.options.push(
                    OpenSearchUtils.getAttributeValue(paramJson.Option, "value")
                );
            }
        }

        if (this.options !== null) {
            this.type = "options";
        } else if (this.minInclusive !== null || this.maxInclusive !== null) {
            this.type = "number";
            if (this.title === null) {
                this.title = "";
            }
            if (this.maxInclusive === null) {
                this.title += "( >= " + this.minInclusive + " )";
            } else if (this.minInclusive === null) {
                this.title += "( <= " + this.maxInclusive + " )";
            } else {
                this.title +=
                    "( between " +
                    this.minInclusive +
                    " and " +
                    this.maxInclusive +
                    " )";
            }
        } else if (this.value.startsWith("{time:") === true) {
            this.type = "datetime";
        } else {
            this.type = "text";
        }

        if (this.title === null) {
            this.titleAttribute = "";
        } else {
            this.titleAttribute = 'title="' + this.title + '" ';
        }
    };

    /**************************************************************************************************************/

    /**
     * Return string representation
     * @function toString
     * @memberof OpenSearchParam#
     * @return {String} String representation
     */

    OpenSearchParam.prototype.toString = function() {
        var res = "";

        if (this.name !== null) {
            res += "     name : " + this.name + "\n";
        }

        if (this.value !== null) {
            res += "     value : " + this.value + "\n";
        }

        if (this.title !== null) {
            res += "     title : " + this.title + "\n";
        }

        if (this.minInclusive !== null) {
            res += "     minInclusive : " + this.minInclusive + "\n";
        }

        if (this.maxInclusive !== null) {
            res += "     maxInclusive : " + this.maxInclusive + "\n";
        }

        if (this.pattern !== null) {
            res += "     pattern : " + this.pattern + "\n";
        }

        if (this.options != null) {
            res += "     options : ";
            for (var i = 0; i < this.options.length; i++) {
                res += this.options[i] + ", ";
            }
            res += "\n";
        }
        return res;
    };

    /**************************************************************************************************************/

    /**
     * Get current value transformed (from IHM to Request)
     * @function currentValueTransformed
     * @memberof OpenSearchParam#
     * @return {String} Current value transformed
     */

    OpenSearchParam.prototype.currentValueTransformed = function() {
        // Only for date time, all other : no change
        if (this.type !== "datetime") {
            return this.currentValue;
        }

        if (
            this.currentValue === null ||
            typeof this.currentValue === "undefined"
        ) {
            return this.currentValue;
        }

        var deb = this.currentValue.substr(0, 10);
        var fin = this.currentValue.substr(-5);
        var res = deb + "T" + fin + ":00.00";
        return res;
    };

    /*************************************************************************************************************/

    return OpenSearchParam;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchForm',["./OpenSearchParam", "./OpenSearchUtils"], function(
    OpenSearchParam,
    OpenSearchUtils
) {
    /**
     * @name OpenSearchForm
     * @class
     * All informations describing an OpenSearch form
     * @param {Object} paramsJson a json object describing the form
     * @param {String} type form to load (application/json or application/atom+xml)
     * @memberof module:Layer
     */
    var OpenSearchForm = function(paramsJson, type) {
        // init all values
        this.type = null; // type of form (only application/json supported)
        this.template = null; // url template with params
        this.parameters = []; // list of params

        this.ignoredParameters = [];
        this.ignoredParameters.push("searchTerms");
        this.ignoredParameters.push("count");
        this.ignoredParameters.push("startIndex");
        this.ignoredParameters.push("startPage");
        this.ignoredParameters.push("language");
        this.ignoredParameters.push("inputEncoding");
        this.ignoredParameters.push("outputEncoding");

        this.parseJson(paramsJson, type);
    };

    /**************************************************************************************************************/

    /**
     * Parse url for request
     * @function parseUrl
     * @memberof OpenSearchForm#
     * @param {Objet} urlJson Json urls founded
     * @param {type} type Url type searched
     */
    OpenSearchForm.prototype.parseUrl = function(urlJson, type) {
        var typeValue = OpenSearchUtils.getAttributeValue(urlJson, "type");
        if (typeValue !== type) {
            // Not the good type, do not take it into account
            return;
        }
        this.type = typeValue;
        this.template = OpenSearchUtils.getAttributeValue(urlJson, "template");
        listParameters = urlJson.Parameter;
        if (typeof listParameters.length !== "undefined") {
            for (var i = 0; i < listParameters.length; i++) {
                var param = new OpenSearchParam(listParameters[i]);
                param.isDisplayed = true;
                for (var j = 0; j < this.ignoredParameters.length; j++) {
                    if (param.value === "{" + this.ignoredParameters[j] + "}") {
                        param.isDisplayed = false;
                    }
                }
                if (param.value.startsWith("{geo:")) {
                    param.isDisplayed = false;
                }
                this.parameters.push(param);
            }
        } else {
            this.parameters.push(new OpenSearchParam(listParameters));
        }
    };

    /**************************************************************************************************************/

    /**
     * Get a string representation of the form
     * @function toString
     * @memberof OpenSearchForm#
     * @return {String} String representation of the form
     */
    OpenSearchForm.prototype.toString = function() {
        var res = "";
        res += "  type : " + this.type + "\n";
        res += "  template : " + this.template + "\n";
        res += "  parameters :\n";
        for (var i = 0; i < this.parameters.length; i++) {
            res += this.parameters[i].toString() + "\n";
        }
        return res;
    };

    /**************************************************************************************************************/

    /**
     * Parse the json
     * @function parseJson
     * @memberof OpenSearchForm#
     * @param {Object} paramsJson Parameteres
     * @param {String} type Type
     */
    OpenSearchForm.prototype.parseJson = function(paramsJson, type) {
        if (typeof paramsJson.length !== "undefined") {
            // Management of an array
            for (var i = 0; i < paramsJson.length; i++) {
                this.parseUrl(paramsJson[i], type);
            }
        } else {
            this.parseUrl(paramsJson, type);
        }
    };

    /**************************************************************************************************************/

    /**
     * Update form parameters from GUI form
     * @function updateFromGUI
     * @memberof OpenSearchForm#
     */
    OpenSearchForm.prototype.updateFromGUI = function() {
        for (var i = 0; i < this.parameters.length; i++) {
            param = this.parameters[i];
            val = $("#p_" + param.name).val();
            if (val !== "") {
                param.currentValue = val;
            } else {
                param.currentValue = null;
            }
        }
    };

    /*************************************************************************************************************/

    return OpenSearchForm;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchResult',["jquery"], function($) {
    /**
     * @name OpenSearchResult
     * @class
     * This layer stock the metadata information of an openSearch result
     * @memberof module:Layer
     */
    var OpenSearchResult = function() {
        this.nbFound = 0;
        this.startIndex = 0;
        this.nbReturned = 0;
        // For ihm display on layer manager view
        this.featuresLoaded = 0;
        this.featuresTotal = 0;

        document.myOpenSearchResult = this;
    };

    /*************************************************************************************************************/

    /**
     * Parse response
     * @function parseResponse
     * @memberof OpenSearchResult#
     * @param {Object} response Response returned by distant server
     * @return {Int} Nb features founds (total)
     */
    OpenSearchResult.prototype.parseResponse = function(response) {
        this.nbFound = response.properties.totalResults;
        this.nbReturned = response.features.length;
        this.startIndex = response.properties.startIndex;
        this.nbItemsPerPage = response.properties.itemsPerPage;

        this.featuresLoaded += this.nbReturned;
        this.featuresTotal += this.nbFound;

        // Number of pages
        this.nbPages = Math.ceil(this.nbFound / this.nbItemsPerPage);
        // Current page
        this.currentPage =
            Math.floor((this.startIndex - 1) / this.nbItemsPerPage) + 1;

        return this.nbFound;
    };

    /*************************************************************************************************************/

    return OpenSearchResult;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchRequestPool',[], function() {
    /**
     * @name OpenSearchRequestPool
     * @class
     * This class manage the request pool of OpenSearch
     * @memberof module:Layer
     */
    var OpenSearchRequestPool = function() {
        this.maxRunningRequests = 4;
        this.maxPoolingRequests = 50;

        this.debugMode = false;

        // Running requests
        this.runningRequests = [];

        // Atomic management when reseting
        this.resetMode = false;

        // Pooling requests
        this.freeRequests = [];
        this.poolingRequests = [];

        this.layers = [];

        // Build all free requests
        for (var i = 0; i < this.maxPoolingRequests; i++) {
            var xhr = new XMLHttpRequest();
            xhr.numRequest = i;
            this.freeRequests.push(xhr);
        }

        this.debug("[New] " + this.getPoolsStatus());
    };

    /**************************************************************************************************************/

    /**
     * Debug information
     * @function debug
     * @memberof OpenSearchRequestPool#
     * @param {String} message Message to display
     */

    OpenSearchRequestPool.prototype.debug = function(message) {
        if (this.debugMode === true) {
            console.log("Pool:" + message);
        }
    };

    /**************************************************************************************************************/

    /**
     * Return the pool status
     * @function getPoolStatus
     * @memberof OpenSearchRequestPool#
     * @return {String} Pool status
     */

    OpenSearchRequestPool.prototype.getPoolsStatus = function() {
        var message = "";
        message +=
            "Run : " +
            this.runningRequests.length +
            "/" +
            this.maxRunningRequests +
            " , ";
        message +=
            "Wait : " +
            this.poolingRequests.length +
            "/" +
            this.maxPoolingRequests;
        return message;
    };

    /**************************************************************************************************************/

    /**
     * Get a free request
     * @function getFreeRequest
     * @memberof OpenSearchRequestPool#
     * @return {Object} Free request
     */

    OpenSearchRequestPool.prototype.getFreeRequest = function() {
        this.debug("[getFreeRequest]");
        if (this.freeRequests.length === 0) {
            // Take oldest request in pool and use it
            xhr = this.poolingRequests.splice(0, 1)[0];
            this.debug("Oldest pooling request cancel and reused");
            return xhr;
        } else {
            this.debug("Take one request from pool");
            return this.freeRequests.pop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a query to the pool
     *  Note : Query is ALWAYS ADDED at the end of the pool, the it's a FILO queue
     * @function addQuery
     * @memberof OpenSearchRequestPool#
     * @param {String} url Url query to get
     * @param {Tile} tile Tile associated with the query
     * @param {String} key Key of the tile
     */
    OpenSearchRequestPool.prototype.addQuery = function(url, tile, key, layer) {
        this.debug("[addQuery]");
        if (this.resetMode === true) {
            this.debug("addQuery halt, reset mode");
            return;
        }

        // Add layer to list
        if (typeof this.layers[layer.getID()] === "undefined") {
            this.layers[layer.getID()] = layer;
        }

        var bound = tile.bound;
        // First check if query is style wanted
        if (this.isQueryStillWanted(key, layer.getID())) {
            // Query still in pool or running, so do not add it again
            return;
        }

        // get query slot
        var xhr = this.getFreeRequest();

        // set value for managing
        self = this;

        // Associate the key
        xhr.key = key;
        xhr.layer = layer;

        xhr.onreadystatechange = function(e) {
            var i, feature;
            var response;
            var alreadyAdded;
            if (xhr.readyState === 4) {
                if (xhr.status === 200 && xhr.response !== null) {
                    response = JSON.parse(xhr.response);
                    nbFound = xhr.layer.result.parseResponse(response);
                    //self.layer.cache.addTile(bound,response.features,nbFound);
                    xhr.layer.manageFeaturesResponse(response.features, tile);
                } else if (xhr.status >= 400) {
                    //tileData.complete = true;
                    self.debug(xhr.responseText);
                    return;
                }

                self.manageFinishedRequest(xhr);

                // Publish event that layer have received new features
                if (
                    response !== undefined &&
                    response.features !== null &&
                    response.features.length > 0
                ) {
                    xhr.layer.getGlobe().publishEvent("features:added", {
                        layer: xhr.layer,
                        features: response.features
                    });
                }
            }
        };
        xhr.open("GET", url);

        // Add request to pooling (last position)
        this.poolingRequests.push(xhr);

        // Check if request can be done
        this.checkPool();
    };

    /**
     * Check for each layer if there is remaining load needed
o     * Check if there is any remaining query in the pool 
     * @function checkPool
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.checkEachLayerFinished = function() {
        for (var key in this.layers) {
            var current = this.layers[key];
            for (var i = 0; i < this.runningRequests.length; i++) {
                if (
                    typeof this.runningRequests[i].layer !== "undefined" &&
                    this.runningRequests[i].layer.getID() === key
                ) {
                    return;
                }
            }
            for (i = 0; i < this.poolingRequests.length; i++) {
                if (
                    typeof this.poolingRequests[i].layer !== "undefined" &&
                    this.poolingRequests[i].layer.getID() === key
                ) {
                    return;
                }
            }
            // no request running, stop ihm indicator
            current.getGlobe().publishEvent("endLoad", current);
        }
    };

    /**************************************************************************************************************/

    /**
     * Check if there is any remaining query in the pool
     * @function checkPool
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.checkPool = function() {
        this.debug("[checkPool]" + this.getPoolsStatus());

        if (this.resetMode === true) {
            this.debug("checkPool halt, reset mode");
            return;
        }

        if (this.runningRequests.length === this.maxRunningRequests) {
            // Running pool is full, wait for a free slot
            this.debug("no running slot available, wait");
            return;
        }

        this.checkEachLayerFinished();

        // There is at least one slot free
        this.debug("before : " + this.getPoolsStatus());

        // Remove it from pool
        var xhr = this.poolingRequests.pop();

        if (typeof xhr !== "undefined") {
            // Place it into running
            this.runningRequests.push(xhr);

            // Start ihm indicator
            xhr.layer.getGlobe().publishEvent("startLoad", xhr.layer);

            // Launch request
            xhr.send();

            this.debug("after : " + this.getPoolsStatus());

            // check for another request
            this.checkPool();
        }
    };

    /**************************************************************************************************************/

    /**
     * Manage data returned by a query
     * @function manageFinishedRequest
     * @memberof OpenSearchRequestPool#
     * @param {Object} xhr Query
     */
    OpenSearchRequestPool.prototype.manageFinishedRequest = function(xhr) {
        this.debug("[manageFinishedRequest]");

        if (this.resetMode === true) {
            this.debug("manageFinishedRequest halt, reset mode");
            return;
        }

        this.debug("before : " + this.getPoolsStatus());

        // Get index of ended request
        var index = -1;
        for (var i = 0; i < this.runningRequests.length; i++) {
            if (this.runningRequests[i].numRequest === xhr.numRequest) {
                index = i;
            }
        }

        // Remove the query
        if (index >= -1) {
            this.runningRequests.splice(index, 1);
        }

        // Set it into pool
        this.freeRequests.push(xhr);

        this.debug("after : " + this.getPoolsStatus());

        this.checkPool();
    };

    /**************************************************************************************************************/

    /**
     * Check if query (based on bound) is still wanted (in pool or running)
     * @function isQueryStillWanted
     * @memberof OpenSearchRequestPool#
     * @param {String} key Key of the query
     * @return {Boolean} true if query is still in pool
     */
    OpenSearchRequestPool.prototype.isQueryStillWanted = function(
        key,
        layerID
    ) {
        this.debug("[isQueryStillWanted]");
        for (var i = 0; i < this.runningRequests.length; i++) {
            // Recheck if runningRequests is modified outside
            if (
                typeof this.runningRequests[i] !== "undefined" &&
                this.runningRequests[i].key === key &&
                this.runningRequests[i].layer.getID() === layerID
            ) {
                return true;
            }
        }
        for (i = 0; i < this.poolingRequests.length; i++) {
            // Recheck if poolingRequests is modified outside
            if (
                typeof this.poolingRequests[i] !== "undefined" &&
                this.poolingRequests[i].key === key
            ) {
                return true;
            }
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
     * Reset the pool
     * @function reset
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.resetPool = function() {
        this.resetMode = true;
        this.debug("[resetPool]");
        this.removeRunningQueries();
        this.removePoolQueries();
        this.resetMode = false;
    };

    /**************************************************************************************************************/

    /**
     * Remove running queries
     * @function removeRunningQueries
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.removeRunningQueries = function() {
        this.debug("[removeRunningQueries]");

        var xhr = this.runningRequests.pop();
        while (xhr !== null && typeof xhr !== "undefined") {
            xhr.abort();
            this.freeRequests.push(xhr);
            xhr = this.runningRequests.pop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove pool queries
     * @function removePoolQueries
     * @memberof OpenSearchRequestPool#
     */
    OpenSearchRequestPool.prototype.removePoolQueries = function() {
        this.debug("[removePoolQueries]");

        var xhr = this.poolingRequests.pop();
        while (xhr !== null && typeof xhr !== "undefined") {
            this.freeRequests.push(xhr);
            xhr = this.poolingRequests.pop();
        }
    };

    /*************************************************************************************************************/

    return OpenSearchRequestPool;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchCache',[], function() {
    /**
     * @name OpenSearchCache
     * @class
     * Manage the OpenSearch cache
     * @memberof module:Layer
     */

    var OpenSearchCache = function() {
        this.maxTiles = 120;
        this.tileArray = [];

        this.debugMode = false;

        this.debug("[New] " + this.getCacheStatus());
    };

    /**************************************************************************************************************/

    /**
     * Debug information
     * @function debug
     * @memberof OpenSearchCache#
     * @param {String} message Message to display
     */

    OpenSearchCache.prototype.debug = function(message) {
        if (this.debugMode === true) {
            console.log("Cache:" + message);
        }
    };

    /**************************************************************************************************************/

    /**
     * Get cache status
     * @function getCacheStatus
     * @memberof OpenSearchCache#
     * @return {String} Status
     */

    OpenSearchCache.prototype.getCacheStatus = function() {
        var message = "";
        message +=
            "Cache : " +
            this.tileArray.length +
            "/" +
            this.maxTiles +
            " (size:" +
            this.getSize() +
            ")";
        return message;
    };

    /*************************************************************************************************************/

    /**
     * Calcul an unic key for bound
     * @function getKey
     * @memberof OpenSearchCache#
     * @param {Bound} bound Bound
     * @return {String} Key generated
     */

    OpenSearchCache.prototype.getKey = function(bound) {
        var key =
            bound.north +
            ":" +
            bound.east +
            ":" +
            bound.south +
            ":" +
            bound.west;
        return key;
    };

    /*************************************************************************************************************/

    /**
     * Calcul an unic key for an array of bound
     * @function getArrayBoundKey
     * @memberof OpenSearchCache#
     * @param {Array} tiles Array of tiles
     * @return {String} Key generated
     */

    OpenSearchCache.prototype.getArrayBoundKey = function(tiles) {
        var key = "";
        if (tiles === null || typeof tiles === "undefined") {
            return "";
        }
        for (var i = 0; i < tiles.length; i++) {
            key += this.getKey(tiles[i].bound);
        }
        return key;
    };

    /*************************************************************************************************************/

    /**
     * Get tile cache size (in term of number of features)
     * @function getTileSize
     * @memberof OpenSearchCache#
     * @param {Tile} tile Tile
     * @return {Integer} Number of features associated to the tile
     */

    OpenSearchCache.prototype.getTileSize = function(tile) {
        return tile.features.length;
    };

    /*************************************************************************************************************/

    /**
     * Get cache size (in term of number of features)
     * @function getSize
     * @memberof OpenSearchCache#
     * @return {Integer} Number of features associated to the cache
     */

    OpenSearchCache.prototype.getSize = function() {
        var nb = 0;
        for (var i = 0; i < this.tileArray.length; i++) {
            nb += this.getTileSize(this.tileArray[i]);
        }
        return nb;
    };

    /*************************************************************************************************************/

    /**
     * Add a tile and its features to the cache
     * @function addTile
     * @memberof OpenSearchCache#
     * @param {Bound} bound Bound
     * @param {Array} features Array of features to add
     * @param {Int} nbFound Total number of features found
     */

    OpenSearchCache.prototype.addTile = function(bound, features, nbFound) {
        this.debug("[addTile]" + this.getCacheStatus());

        var key = this.getKey(bound);
        var tile = {
            key: key,
            features: features.slice(),
            remains: nbFound
        };
        // If cache is full, remove first element
        if (this.tileArray.length === this.maxTiles) {
            this.debug("Cache full, remove oldest");
            this.tileArray.splice(0, 1);
        }
        this.tileArray.push(tile);
    };

    /*************************************************************************************************************/

    /**
     * Add features to an existing tile in cache
     * @function updateTile
     * @memberof OpenSearchCache#
     * @param {Tile} tile Tile
     * @param {Array} features Array of features to add
     */

    OpenSearchCache.prototype.updateTile = function(tile, features) {
        this.debug("[update]" + this.getCacheStatus());

        tile.features = tile.features.concat(features);
    };

    /*************************************************************************************************************/

    /**
     * Get a tile from the cache
     * @function getTile
     * @memberof OpenSearchCache#
     * @param {Bound} bound Bound
     * @return {Json} Cache element
     */

    OpenSearchCache.prototype.getTile = function(bound) {
        this.debug("[getTile]" + this.getCacheStatus());

        var key = this.getKey(bound);

        for (var i = 0; i < this.tileArray.length; i++) {
            // TODO : try in reverse order, best performance ?
            if (this.tileArray[i].key === key) {
                return this.tileArray[i];
            }
        }
        return null;
    };

    /*************************************************************************************************************/

    /**
     * Reset the cache
     * @function reset
     * @memberof OpenSearchCache#
     */

    OpenSearchCache.prototype.reset = function() {
        this.debug("[reset]");
        this.tileArray.length = 0;
    };

    /*************************************************************************************************************/

    return OpenSearchCache;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
define('Layer/OpenSearchLayer',[
    "../Renderer/FeatureStyle",
    "../Renderer/RendererManager",
    "../Utils/Utils",
    "../Utils/UtilsIntersection",
    "./AbstractLayer",
    "./GroundOverlayLayer",
    "../Renderer/RendererTileData",
    "../Tiling/Tile",
    "../Tiling/GeoTiling",
    "../Utils/Constants",
    "./OpenSearch/OpenSearchForm",
    "./OpenSearch/OpenSearchUtils",
    "./OpenSearch/OpenSearchResult",
    "./OpenSearch/OpenSearchRequestPool",
    "./OpenSearch/OpenSearchCache",
    "moment"
], function (
    FeatureStyle,
    RendererManager,
    Utils,
    UtilsIntersection,
    AbstractLayer,
    GroundOverlayLayer,
    RendererTileData,
    Tile,
    GeoTiling,
    Constants,
    OpenSearchForm,
    OpenSearchUtils,
    OpenSearchResult,
    OpenSearchRequestPool,
    OpenSearchCache,
    Moment
) {
        /**
         * Update status attribute.<br/>
         * Called with pagination
         * @event OpenSearchLayer#updateStatsAttribute
         * @type {OpenSearchLayer~pagination|OpenSearchLayer~result}
         */

        /**
         * Toggle WMS<br/>
         * Called to display/undisplay the WMS related to the opensearch record
         * @event OpenSearchLayer#toggleWMS
         * @type {object}
         * @property {string} layer_name Name of the layer to make visible
         * @property {boolean} visible display/undisplay the layer related to the opensearch record
         */

        /**
        * Opensearch pagination.
        * @typedef {object} OpenSearchLayer~pagination
        * @property {string} shortName of the opensearch layer
        * @property {int} current page in the query   
        */

        /**
        * Opensearch result.
        * @typedef {object} OpenSearchLayer~result
        * @property {string} shortName of the opensearch layer
        * @property {int} nb_loaded number of loaded records
        * @property {int} nb_total total number of records 
        */

        /**
        * The time object.
        * @typedef {object} TimeTravelParams~details
        * @property {date|moment} date - the current time.
        * @property {string} display - the current date as string for display.
        * @property {object} [period] - time period.
        * @property {moment} [period.from] - start date.
        * @property {moment} [period.to] - stop date.
        */
        /**
         * @name OpenSearchLayer
         * @class
         * This layer draws an OpenSearch dynamic layer
         * @augments AbstractLayer
         * @param {Object} options Configuration properties for the layer. See {@link AbstractLayer} for base properties
         * @param {String} options.serviceUrl Url of OpenSearch description XML file
         * @param {int} [options.minOrder=5] Starting order for OpenSearch requests
         * @param {int} [options.maxRequests=2] Max request
         * @param {Boolean} [options.invertY=false] a boolean, if set all the image data of current layer is flipped along the vertical axis
         * @param {Boolean} [options.coordSystemRequired=true]
         * @param {FeatureStyle} [options.style=new FeatureStyle()]
         * @memberof module:Layer
         */
        var OpenSearchLayer = function (options) {
            AbstractLayer.prototype.constructor.call(
                this,
                Constants.LAYER.OpenSearch,
                options
            );

            this.name = options.name;
            this.title = options.title;

            this.afterLoad = options.afterLoad;

            this.minOrder = options.minOrder || 5;
            this.maxRequests = options.maxRequests || 2;
            this.invertY = options.invertY || false;
            this.coordSystemRequired = options.hasOwnProperty("coordSystemRequired")
                ? options.coordSystemRequired
                : true;

            this.oldBound = null;

            this.previousViewKey = null;
            this.previousTileWidth = null;
            this.previousDistance = null;

            // Used for picking management
            //this.features = [];
            // Counter set, indicates how many times the feature has been requested
            //this.featuresSet = {};
            //this.tilesToLoad = [];

            // Keep save of all tiles where a feature is set, in order to remove all when reset
            //this.allTiles = {};

            // Keep trace of all features loaded (TODO: make object more light, just keep geometry and style ?)
            this.features = [];
            // Keep trace of all features id loaded
            this.featuresIdLoaded = [];
            // Keep trace of all tiles loaded (bound, key and features id associated)
            this.tilesLoaded = [];

            // last datetime for removing outside
            this.lastRemovingDateTime = null;
            this.removingDeltaSeconds = options.hasOwnProperty(
                "removingDeltaSeconds"
            )
                ? options.removingDeltaSeconds
                : 5;

            // OpenSearch result
            this.result = new OpenSearchResult();

            // Pool for request management (manage outside to be sharable between multiple opensearch layers)
            this.pool = options.openSearchRequestPool;

            // Cache for data management
            this.cache = new OpenSearchCache();

            // Force Refresh
            this.forceRefresh = false;

            this.getCapabilitiesUrl = options.baseUrl;

            if (typeof this.getGetCapabilitiesUrl() !== "undefined") {
                this.hasForm = true;
                this.loadGetCapabilities(
                    this.manageCapabilities,
                    this.getGetCapabilitiesUrl(),
                    this
                );
            } else {
                this.hasForm = false;
            }

            // Layer created on-the-fly to display quickook over openSearch layer
            // TODO: optimisation : created only once and reused ?
            this.currentQuicklookLayer = null;
            // Id of current feature displayed
            this.currentIdDisplayed = null;

            if (typeof document.currentOpenSearchLayer === "undefined") {
                document.currentOpenSearchLayer = [];
            }
            document.currentOpenSearchLayer[this.ID] = this;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, OpenSearchLayer);

        /**************************************************************************************************************/

        OpenSearchLayer.TileState = {
            LOADING: 0,
            LOADED: 1,
            NOT_LOADED: 2
        };

        /**************************************************************************************************************/

        /**
         * @function getInformationType
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.getInformationType = function () {
            return Constants.INFORMATION_TYPE.VECTOR;
        }

        /**
         * @function setTime
         * @memberof OpenSearchLayer#
         * @param {Time.configuration} time Time configuration
         */
        OpenSearchLayer.prototype.setTime = function (time) {
            AbstractLayer.prototype.setTime(time);
            this.setParameter.call(this, "mizar:time", time);
        };

        /**
         * @function setParameter
         * @memberof OpenSearchLayer#
         * @param {String} paramName Name of parameter
         * @param {Time.configuration} value Time configuration
         */
        OpenSearchLayer.prototype.setParameter = function (paramName, value) {
            if (paramName === "mizar:time") {
                value.period.from = Moment(value.period.from).format(
                    "YYYY-MM-DD HH:mm"
                );
                value.period.to = Moment(value.period.to).format(
                    "YYYY-MM-DD HH:mm"
                );

                OpenSearchUtils.setCurrentValueToParam(
                    this.getServices().queryForm,
                    "startDate",
                    value.period.from
                );
                OpenSearchUtils.setCurrentValueToParam(
                    this.getServices().queryForm,
                    "completionDate",
                    value.period.to
                );
            } else {
                OpenSearchUtils.setCurrentValueToParam(
                    this.getServices().queryForm,
                    paramName,
                    value
                );
            }
            this.resetAll();
        };

        /**
         * Go to next page
         * @function nextPage
         * @memberof OpenSearchLayer#
         * @fires OpenSearchLayer#updateStatsAttribute
         */
        OpenSearchLayer.prototype.nextPage = function () {
            var num = OpenSearchUtils.getCurrentValue(
                this.getServices().queryForm,
                "page"
            );
            // If not specified, set default to 1
            if (num === null || typeof num === "undefined") {
                num = 1;
            }
            OpenSearchUtils.setCurrentValueToParam(
                this.getServices().queryForm,
                "page",
                num * 1 + 1
            );

            // update labels
            this.callbackContext.publish(
                Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES,
                {
                    shortName: this.getShortName(),
                    page: num + 1
                }
            );

            this.forceRefresh = true;
            for (var i = 0; i < this.tilesLoaded.length; i++) {
                this.tilesLoaded[i].tile.osState[this.getID()] =
                    OpenSearchLayer.TileState.NOT_LOADED;
            }
            this.getGlobe()
                .getRenderContext()
                .requestFrame();
        };

        /**************************************************************************************************************/

        /**
         * When getCapabilities is loading, manage it
         * @function manageCapabilities
         * @memberof OpenSearchLayer#
         * @param json Json object
         * @param sourceObject Object where data is stored
         * @private
         */
        OpenSearchLayer.prototype.manageCapabilities = function (
            json,
            sourceObject
        ) {
            // check if form description is well provided
            var dataForm = null;
            var openSearchRoot = json.OpenSearchDescription;
            if (typeof openSearchRoot !== "undefined") {
                sourceObject.name =
                    typeof sourceObject.name !== "undefined"
                        ? sourceObject.name
                        : OpenSearchUtils.getValue(openSearchRoot, "ShortName");
                sourceObject.title =
                    typeof sourceObject.title !== "undefined"
                        ? sourceObject.title
                        : OpenSearchUtils.getValue(openSearchRoot, "LongName");
                var urls = openSearchRoot.Url;
                if (typeof urls !== "undefined") {
                    dataForm = urls;
                }
            }
            if (dataForm != null) {
                // Load form description
                sourceObject.getServices().queryForm = new OpenSearchForm(
                    dataForm,
                    "application/json"
                );
                console.log("FORM !", sourceObject.getServices().queryForm);
                OpenSearchUtils.initNavigationValues(
                    sourceObject.getServices().queryForm
                );
            } else {
                console.error("Form not correct");
            }

            if (
                sourceObject.callbackContext !== null &&
                typeof sourceObject.callbackContext !== "undefined"
            ) {
                sourceObject.callbackContext.addLayerFromObject(
                    sourceObject,
                    sourceObject.options
                );
            }

            if (typeof sourceObject.afterLoad === "function") {
                // Update GUI !!
                sourceObject.afterLoad(sourceObject);
            }
        };

        /**************************************************************************************************************/

        /**
         * Attaches the layer to the globe
         * @function _attach
         * @memberof OpenSearchLayer#
         * @param g The globe
         * @private
         */
        OpenSearchLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);
            this.extId += this.id;
            g.getTileManager().addPostRenderer(this);
        };

        /**************************************************************************************************************/

        /**
         * Detach the layer from the globe
         * @function _detach
         * @memberof OpenSearchLayer#
         * @private
         */
        OpenSearchLayer.prototype._detach = function () {
            this.getGlobe()
                .getTileManager()
                .removePostRenderer(this);
            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        OpenSearchLayer.prototype.getTileByKey = function (key) {
            for (var i = 0; i < this.tilesLoaded.length; i++) {
                if (this.tilesLoaded[i].key === key) {
                    return this.tilesLoaded[i];
                }
            }
            return null;
        };
        /**
         * Launches request to the OpenSearch service.
         * @function launchRequest
         * @memberof OpenSearchLayer#
         * @param {Tile} tile Tile
         * @param {String} url Url
         * @fires Layer#startLoad
         * @fires Layer#endLoad
         * @fires Layer#features:added
         */
        OpenSearchLayer.prototype.launchRequest = function (tile, url) {
            var key = this.cache.getKey(tile.bound);
            if (this.getTileByKey(key) === null) {
                this.tilesLoaded.push({
                    key: key,
                    tile: tile
                });
            }
            this.pool.addQuery(url, tile, key, this);
        };

        /**************************************************************************************************************/

        /**
         * Remove all previous features
         * @function removeFeatures
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.removeFeatures = function () {
            // clean renderers
            while (this.features.length > 0) {
                //this.getGlobe().rendererManager.removeGeometry(this.features[i].geometry);
                this.removeFeature(this.features[0].id);
            }

            for (var i = 0; i < this.tilesLoaded.length; i++) {
                this.tilesLoaded[i].tile.osState[this.getID()] =
                    OpenSearchLayer.TileState.NOT_LOADED;
            }

            //this.globe.refresh();
            if (this.getGlobe() && this.getGlobe().getRenderContext()) {
                this.getGlobe()
                    .getRenderContext()
                    .requestFrame();
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove all feature still used by a tile
         * @function removeTile
         * @param {Tile} tile Tile
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.removeTile = function (tile) {
            if (typeof tile.associatedFeaturesId === "undefined") {
                tile.associatedFeaturesId = [];
            }
            var index = null;
            // For each feature of the tile
            for (var i = 0; i < tile.associatedFeaturesId.length; i++) {
                var featureId = tile.associatedFeaturesId[i];
                // Is this feature is used in other tile ?
                var isUsed = false;
                for (var j = 0; j < this.tilesLoaded.length; j++) {
                    var aTile = this.tilesLoaded[j].tile;
                    if (tile.key !== aTile.key) {
                        if (typeof aTile.associatedFeaturesId !== "undefined") {
                            index = aTile.associatedFeaturesId.indexOf(featureId);
                        } else {
                            index = -1;
                        }
                        if (index >= 0) {
                            isUsed = true;
                            break;
                        }
                    }
                }

                if (isUsed === false) {
                    this.removeFeature(featureId);
                }
            }

            tile.associatedFeaturesId = [];

            // Remove the tile
            index = -1;
            for (i = 0; i < this.tilesLoaded.length; i++) {
                if (this.tilesLoaded[i].tile.key === tile.key) {
                    index = i;
                    break;
                }
            }
            if (index >= 0) {
                this.tilesLoaded.splice(index, 1);
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove all previous features
         * @function removeFeaturesOutside
         * @param {JSon} extent Extent
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.removeFeaturesOutside = function (extent) {
            // clean renderers
            var nbRemoved = 0;
            for (var i = 0; i < this.tilesLoaded.length; i++) {
                var tile = this.tilesLoaded[i].tile;
                var intersects = UtilsIntersection.boundsIntersects(
                    tile.bound,
                    extent
                );
                if (intersects === false) {
                    this.removeTile(tile);
                    nbRemoved++;
                }
            }
            //console.log(nbRemoved+" tiles removed");
        };

        /**************************************************************************************************************/

        /**
         * Adds feature to the layer
         * @function addFeature
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         */
        OpenSearchLayer.prototype.addFeature = function (feature) {
            // update list id added
            this.featuresIdLoaded.push(feature.id);

            var defaultCrs = {
                type: "name",
                properties: {
                    name: Constants.CRS.WGS84
                }
            };

            feature.geometry.gid = feature.id;

            // MS: Feature could be added from ClusterOpenSearch which have features with different styles
            var style = feature.properties.style
                ? feature.properties.style
                : this.style;
            //style.visible = true;
            style.opacity = this.getOpacity();

            this.features.push(feature);

            // Add features to renderer if layer is attached to planet
            if (this.globe) {
                this._addFeatureToRenderers(feature);
                if (this.isVisible()) {
                    this.getGlobe()
                        .getRenderContext()
                        .requestFrame();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Add a feature to renderers
         * @function _addFeatureToRenderers
         * @memberof GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        OpenSearchLayer.prototype._addFeatureToRenderers = function (feature) {
            var geometry = feature.geometry;

            // Manage style, if undefined try with properties, otherwise use defaultStyle
            var style = this.style;
            var props = feature.properties;
            if (props && props.style) {
                style = props.style;
            }

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                for (var i = 0; i < geoms.length; i++) {
                    this.getGlobe().rendererManager.addGeometry(
                        this,
                        geoms[i],
                        style
                    );
                }
            } else {
                // Add geometry to renderers
                this.getGlobe().rendererManager.addGeometry(
                    this,
                    geometry,
                    style
                );
            }
        };

        /**************************************************************************************************************/

        /**
         * Add a feature to renderers current level
         * @function _addFeatureToRenderersCurrentLevel
         * @memberof GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        OpenSearchLayer.prototype._addFeatureToRenderersCurrentLevel = function (
            feature
        ) {
            var geometry = feature.geometry;

            // Manage style, if undefined try with properties, otherwise use defaultStyle
            var style = this.style;
            var props = feature.properties;
            if (props && props.style) {
                style = props.style;
            }

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                for (var i = 0; i < geoms.length; i++) {
                    this.getGlobe().rendererManager.addGeometryCurrentLevel(
                        this,
                        geoms[i],
                        style
                    );
                }
            } else {
                // Add geometry to renderers
                this.getGlobe().rendererManager.addGeometryCurrentLevel(
                    this,
                    geometry,
                    style
                );
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove a feature from renderers
         * @function _removeFeatureFromRenderers
         * @memberof GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        OpenSearchLayer.prototype._removeFeatureFromRenderersCurrentLevel = function (
            feature
        ) {
            return this.globe.getRendererManager().removeGeometryCurrentLevel(
                feature.geometry,
                this
            );
        };

        /**
         * Remove a feature from renderers
         * @function _removeFeatureFromRenderers
         * @memberof GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        OpenSearchLayer.prototype._removeFeatureFromRenderers = function (feature) {
            return this.globe.getRendererManager().removeGeometry(
                feature.geometry,
                this
            );
        };

        /**
         * Removes feature from Dynamic OpenSearch layer.
         *  (called when it's sure to have to remove feature)
         * @function removeFeature
         * @memberof OpenSearchLayer#
         * @param {String} featureId Feature id
         */
        OpenSearchLayer.prototype.removeFeature = function (featureId) {
            var featureIndex = this.getFeatureIndexById(featureId);
            var feature = this.features[featureIndex];

            if (typeof feature === "undefined") {
                return;
            }
            // remove id from featuresId
            var index = this.featuresIdLoaded.indexOf(featureId);
            if (index !== -1) this.featuresIdLoaded.splice(index, 1);

            this.getGlobe().rendererManager.removeGeometry(
                feature.geometry,
                this
            );

            // Remove from list of features
            this.features.splice(featureIndex, 1);
        };

        /**************************************************************************************************************/

        /**
         * Load quicklook
         * @function loadQuicklook
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {String} url Url of image
         */
        OpenSearchLayer.prototype.loadQuicklook = function (feature, url) {
            // Save coordinates
            this.currentIdDisplayed = feature.id;

            // Get quad coordinates
            var coordinates = feature.geometry.coordinates[0];
            var quad = [];
            for (var i = 0; i < 4; i++) {
                quad[i] = coordinates[i];
            }

            if (this.currentQuicklookLayer === null) {
                // Creation first time
                this.currentQuicklookLayer = new GroundOverlayLayer({
                    quad: quad,
                    image: url
                });
                this.currentQuicklookLayer._attach(this.globe);
            } else {
                this.currentQuicklookLayer.update(quad, url);
            }
            this.getGlobe().refresh();
        };

        /**************************************************************************************************************/

        /**
         * Indicate if quicklook is currently displayed
         * @function isQuicklookDisplayed
         * @memberof OpenSearchLayer#
         * @return {Boolean} Is quicklook currently displayed ?
         */
        OpenSearchLayer.prototype.isQuicklookDisplayed = function () {
            // Trivial case
            return this.currentQuicklookLayer !== null;
        };

        /**************************************************************************************************************/

        /**removeGeometry
         * Remove quicklook
         * @function removeQuicklook
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.removeQuicklook = function () {
            if (this.currentQuicklookLayer === null) {
                return;
            }

            this.currentQuicklookLayer._detach();
            this.currentQuicklookLayer = null;
        };

        /**************************************************************************************************************/

        /**
         * Highlight feature
         * @function highlight
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {FeatureStyle} style Style
         */
        OpenSearchLayer.prototype.highlight = function (feature, style) {
            feature.properties.style = style;
            this._addFeatureToRenderersCurrentLevel(feature);
        };

        /**
         * Unhighlight feature
         * @function unhighlight
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {FeatureStyle} style Style
         */
        OpenSearchLayer.prototype.unhighlight = function (feature, style) {
            this._removeFeatureFromRenderersCurrentLevel(feature);
        };

        /**
         * Modify feature style.
         * @function modifyFeatureStyle
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {FeatureStyle} style Style
         */
        OpenSearchLayer.prototype.modifyFeatureStyle = function (feature, style) {
            if (this._removeFeatureFromRenderers(feature)) {
                feature.properties.style = style;
                this._addFeatureToRenderers(feature);
            }
        };

        /**************************************************************************************************************/

        /**
         * Prepare parameters for a given bound
         * @function prepareParameters
         * @memberof OpenSearchLayer#
         * @param {Bound} bound Bound
         */
        OpenSearchLayer.prototype.prepareParameters = function (bound) {
            var param; // param managed
            var code; // param code
            for (
                var i = 0;
                i < this.getServices().queryForm.parameters.length;
                i++
            ) {
                param = this.getServices().queryForm.parameters[i];
                code = param.value;
                code = code.replace("?}", "}");
                if (code === "{geo:box}") {
                    // set bbox
                    param.currentValue =
                        bound.west +
                        "," +
                        bound.south +
                        "," +
                        bound.east +
                        "," +
                        bound.north;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Build request url
         * @function buildUrl
         * @memberof OpenSearchLayer#
         * @param {Bound} bound Bound
         * @return {String} Url
         */
        OpenSearchLayer.prototype.buildUrl = function (bound) {
            //var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;
            if (!this.getServices().hasOwnProperty("queryForm")) {
                return null;
            }
            var url = this.getServices().queryForm.template;

            // Prepare parameters for this tile
            this.prepareParameters(bound);

            // Check each parameter
            var param; // param managed
            var currentValue; // value set
            for (
                var i = 0;
                i < this.getServices().queryForm.parameters.length;
                i++
            ) {
                param = this.getServices().queryForm.parameters[i];
                currentValue = param.currentValueTransformed();
                if (currentValue === null) {
                    // Remove parameter if not mandatory (with a ?)
                    url = url.replace(
                        "&" + param.name + "=" + param.value.replace("}", "?}"),
                        ""
                    );
                    url = url.replace(
                        param.name + "=" + param.value.replace("}", "?}"),
                        ""
                    );
                    // Set blank if parameter is mandatory
                    url = url.replace(param.value, "");
                } else {
                    // replace value
                    url = url.replace(param.value, currentValue);
                    // replace optional value
                    url = url.replace(param.value.replace("}", "?}"), currentValue);
                }
            }
            return this.proxify(url);
        };

        /**************************************************************************************************************/

        /**
         * Internal function to sort tiles
         * @function _sortTilesByDistance
         * @param {Tile} t1 First tile
         * @param {Tile} t2 Second tile
         * @private
         */
        function _sortTilesByDistance(t1, t2) {
            return t1.distance - t2.distance;
        }

        /**************************************************************************************************************/

        /**
         * Render function
         * @function render
         * @memberof OpenSearchLayer#
         * @param tiles The array of tiles to render
         */
        OpenSearchLayer.prototype.render = function (tiles) {
            if (!this.isVisible()) {
                return;
            }

            this.tiles = tiles;

            this.needRefresh = false;
            this.globalKey = this.cache.getArrayBoundKey(this.tiles);

            if (this.forceRefresh === true) {
                // Remove cache, in order to reload new features
                this.cleanCache();
                this.forceRefresh = false;
            }

            if (this.previousViewKey === null) {
                this.needRefresh = true;
            } else {
                this.needRefresh = this.previousViewKey !== this.globalKey;
            }

            if (this.needRefresh) {
                // Sort tiles in order to load the first tiles closed to the camera
                this.tiles.sort(_sortTilesByDistance);

                // =========================================================================
                // Determination of zoom level change
                // =========================================================================

                this.newTileWidth =
                    this.tiles[0].bound.east - this.tiles[0].bound.west;
                this.ctx = this.callbackContext;
                this.distance = null;
                if (this.ctx) {
                    this.initNav = this.ctx.getNavigation();
                    this.distance = this.initNav.getDistance();
                }

                // TODO : warning, float comparison not ok
                this.isZoomLevelChanged = false;
                this.isZoomLevelChanged =
                    this.newTileWidth !== this.previousTileWidth;
                if (this.ctx) {
                    this.isZoomLevelChanged =
                        this.isZoomLevelChanged &&
                        this.distance !== this.previousDistance;
                    this.previousDistance = this.distance;
                }
                if (this.isZoomLevelChanged) {
                    // Go to page 1
                    OpenSearchUtils.setCurrentValueToParam(
                        this.getServices().queryForm,
                        "page",
                        1
                    );

                    this.result.featuresLoaded = 0;
                    this.result.featuresLoaded = this.features.length;
                }

                // =========================================================================
                // Check each tile
                // =========================================================================

                this.previousTileWidth = this.newTileWidth;
                this.previousViewKey = this.globalKey;
                this.result.featuresTotal = 0;
                for (var i = 0; i < this.tiles.length; i++) {
                    this.currentTile = this.tiles[i];
                    if (typeof this.currentTile.key === "undefined") {
                        this.currentTile.key = this.cache.getKey(
                            this.currentTile.bound
                        );
                    }
                    // If no state defined...
                    if (
                        this.currentTile.osState === null ||
                        typeof this.currentTile.osState === "undefined"
                    ) {
                        //...set it to NOT_LOADED
                        this.currentTile.osState = [];
                    }
                    if (
                        this.currentTile.osState[this.getID()] === null ||
                        typeof this.currentTile.osState[this.getID()] ===
                        "undefined"
                    ) {
                        this.currentTile.osState[this.getID()] =
                            OpenSearchLayer.TileState.NOT_LOADED;
                    }
                    if (
                        this.currentTile.osState[this.getID()] ===
                        OpenSearchLayer.TileState.NOT_LOADED
                    ) {
                        var url = this.buildUrl(this.currentTile.bound);
                        if (url !== null) {
                            this.currentTile.osState[this.getID()] =
                                OpenSearchLayer.TileState.LOADING;
                            this.launchRequest(this.currentTile, url);
                        }
                    } else if (
                        this.currentTile.osState[this.getID()] ===
                        OpenSearchLayer.TileState.LOADED
                    ) {
                        //console.log("tile still loaded !!!");
                    } else if (
                        this.currentTile.osState[this.getID()] ===
                        OpenSearchLayer.TileState.LOADING
                    ) {
                        //console.log("tile loading...");
                    }

                    /**tileCache = this.cache.getTile(tiles[i].bound);
                        this.updateGUI();
                        if (tileCache === null) {
                            var url = this.buildUrl(tiles[i].bound);
                            if (url !== null) {
                                this.launchRequest(tiles[i], url);
                            }
                        } else {
                            this.result.featuresTotal += tileCache.remains;
                            this.manageFeaturesResponse(tileCache.features.slice(),tiles[i]);
                            this.updateGUI();
                        }*/

                    // Remove all feature outside view of tiles
                    this.doRemove = false;
                    if (this.lastRemovingDateTime === null) {
                        this.doRemove = true;
                    } else {
                        this.doRemove =
                            Date.now() - this.lastRemovingDateTime >=
                            this.removingDeltaSeconds * 1000;
                    }
                    if (this.doRemove) {
                        var viewExtent = this.getExtent(this.tiles);
                        this.lastRemovingDateTime = Date.now();
                        this.removeFeaturesOutside(viewExtent);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Get extent from array of tiles
         * @function getExtent
         * @param {Array} tiless Array of tiles
         * @return {Json} Extent (north, south, east, west)
         * @memberof OpenSearchLayer#
         */

        OpenSearchLayer.prototype.getExtent = function (tiles) {
            var result = {
                east: -180,
                west: +180,
                north: -90,
                south: +90
            };
            var bound;
            for (var i = 0; i < tiles.length; i++) {
                bound = tiles[i].bound;
                result.south =
                    bound.south < result.south ? bound.south : result.south;
                result.north =
                    bound.north > result.north ? bound.north : result.north;
                result.east = bound.east > result.east ? bound.east : result.east;
                result.west = bound.west < result.west ? bound.west : result.west;
            }
            return result;
        };

        /**************************************************************************************************************/

        /**
         * Get geometry extent
         * @function getGeometryExtent
         * @param {Json} geometry Geometry
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.getGeometryExtent = function (geometry) {
            var result = {
                east: -180,
                west: +180,
                north: -90,
                south: +90
            };
            for (var i = 0; i < geometry.coordinates[0].length; i++) {
                coord = geometry.coordinates[0][i];
                result.south = coord[1] < result.south ? coord[1] : result.south;
                result.north = coord[1] > result.north ? coord[1] : result.north;
                result.east = coord[0] > result.east ? coord[0] : result.east;
                result.west = coord[0] < result.west ? coord[0] : result.west;
            }
            return result;
        };

        /**************************************************************************************************************/

        /**
         * Submit OpenSearch form
         * @function submit
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.submit = function () {
            this.getServices().queryForm.updateFromGUI();
            this.resetAll();
        };

        /**************************************************************************************************************/

        /**
         * @function setVisible
         * @memberof OpenSearchLayer#
         * @throws {TypeError} - The parameter of setVisible should be a boolean
         */
        OpenSearchLayer.prototype.setVisible = function (arg) {
            console.log("setVisible");
            if (typeof arg === "boolean") {
                // Change for current layer
                if (this.visible !== arg && this.getGlobe().attributionHandler) {
                    this.getGlobe().attributionHandler.toggleAttribution(this);
                }
                this.visible = arg;

                var linkedLayers = this.callbackContext.getLinkedLayers(this.ID);
                // Change for wms linked layers
                for (var i = 0; i < linkedLayers.length; i++) {
                    linkedLayers[i].setVisible(arg);
                }

                if (
                    typeof this.currentQuicklookLayer !== "undefined" &&
                    this.currentQuicklookLayer !== null
                ) {
                    //this.currentQuicklookLayer.setVisible(this.visible);
                    if (this.visible === false) {
                        this.removeQuicklook();
                    }
                }

                if (this.getGlobe()) {
                    this.getGlobe()
                        .getRenderContext()
                        .requestFrame();
                }
                this.publish(Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED, this);
            } else {
                throw new TypeError(
                    "the parameter of setVisible should be a boolean",
                    "AbstractLayer.js"
                );
            }
            console.log("/setVisible");
        };

        /**************************************************************************************************************/

        /**
            /**
             * @function setOpacity
             * @memberof OpenSearchLayer#
             * @throws {RangeError} opacity - opacity value should be a value in [0..1]
             */
        OpenSearchLayer.prototype.setOpacity = function (arg) {
            if (typeof arg === "number" && arg >= 0.0 && arg <= 1.0) {
                var targetStyle = new FeatureStyle(this.getStyle());
                targetStyle.setOpacity(arg);

                for (var i = 0; i < this.features.length; i++) {
                    this.modifyFeatureStyle(this.features[i], targetStyle);
                }

                var linkedLayers = this.callbackContext.getLinkedLayers(
                    this.getID()
                );
                // Change for wms linked layers
                for (i = 0; i < linkedLayers.length; i++) {
                    linkedLayers[i].getStyle().setOpacity(arg);
                }

                AbstractLayer.prototype.setOpacity.call(this, arg);
            } else {
                throw new RangeError(
                    "opacity value should be a value in [0..1]",
                    "AbstractLayer.js"
                );
            }
        };

        /**************************************************************************************************************/

        /**
         * Reset pool, cache and all OpenSearch data loaded
         * @function resetAll
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.resetAll = function () {
            // Reset pool
            this.pool.resetPool();
            // Reset cache
            this.cleanCache();
            // Remove all features
            this.removeFeatures();
        };

        /**************************************************************************************************************/

        /**
         * Clean the cache
         * @function cleanCache
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.cleanCache = function () {
            this.cache.reset();
            this.previousViewKey = null;
        };

        /**************************************************************************************************************/

        /**
         * Update the GUI (mainly debug purpose)
         * @function updateGUI
         * @memberof OpenSearchLayer#
         */
        OpenSearchLayer.prototype.updateGUI = function () {
            var message = "";
            message +=
                "<a href='javascript:document.currentOpenSearchLayer.resetAll();'>Reset</a><br>";
            message +=
                "<a href='javascript:document.currentOpenSearchLayer.nextPage();'>Next</a><br>";
            message += "# Features : " + this.features.length + "<br>";
            message += this.pool.getPoolsStatus() + "<br>";
            message += this.cache.getCacheStatus();
        };

        /**************************************************************************************************************/

        /**
         * Check is feature still added to global render
         * @function featureStillAdded
         * @memberof OpenSearchLayer#
         * @param {String} featureId Feature id
         * @private
         */
        OpenSearchLayer.prototype.featureStillAdded = function (featureId) {
            var num = this.featuresIdLoaded.indexOf(featureId);

            return num >= 0;
        };

        /**
         * Check is feature still added to tile
         * @function featureStillAddedToTile
         * @memberof OpenSearchLayer#
         * @param {String} featureId Feature id
         * @param {Tile} tile Tile
         * @private
         */
        OpenSearchLayer.prototype.featureStillAddedToTile = function (
            featureId,
            tile
        ) {
            if (typeof tile.associatedFeaturesId.length === "undefined") {
                return false;
            }

            var num = tile.associatedFeaturesId.indexOf(featureId);

            return num >= 0;
        };

        /**************************************************************************************************************/

        /**
         * Load WMS layer
         * @function loadWMS
         * @memberof OpenSearchLayer#
         * @param {Json} selectedData Selected data
         * @fires OpenSearchLayer#toggleWMS
         */
        OpenSearchLayer.prototype.loadWMS = function (selectedData) {
            var extent = this.getGeometryExtent(selectedData.feature.geometry);
            var endpoint =
                selectedData.feature.properties.services.browse.layer.url;
            var name = selectedData.layer.name + " (WMS)";
            var layerDescription = {
                type: "WMS",
                name: name,
                baseUrl: endpoint,
                onlyFirst: true,
                format: "image/png",
                visible: true,
                restrictTo: extent,
                background: false,
                linkedTo: selectedData.layer.ID
            };
            var self = this;
            selectedData.layer.callbackContext.addLayer(layerDescription, function (
                layerID
            ) {
                // Add feature id of wms into list a current WMS displayed
                self.addServicesRunningOnRecord(selectedData.feature.id, layerID);

                if (typeof self.callbackContext !== "undefined") {
                    self.callbackContext.publish(
                        Constants.EVENT_MSG.LAYER_TOGGLE_WMS,
                        {
                            layer_name: selectedData.layer.getShortName(),
                            visible: true
                        }
                    );
                }
            });
        };

        /**************************************************************************************************************/

        /**
         * Unload all WMS layer
         * @function unloadAllWMS
         * @memberof OpenSearchLayer#
         * @fires OpenSearchLayer#toggleWMS
         */
        OpenSearchLayer.prototype.unloadAllWMS = function () {
            this.removeServicesRunningOnRecords();
            this.removeServicesRunningOnCollection();

            this.callbackContext.refresh();

            if (typeof this.callbackContext !== "undefined") {
                if (typeof selectedData !== "undefined") {
                    this.callbackContext.publish(
                        Constants.EVENT_MSG.LAYER_TOGGLE_WMS,
                        {
                            layer_name: selectedData.layer.getShortName(),
                            visible: false
                        }
                    );
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Unload WMS layer
         * @function unloadWMS
         * @memberof OpenSearchLayer#
         * @param {Json} selectedData Selected data
         * @fires OpenSearchLayer#toggleWMS
         */
        OpenSearchLayer.prototype.unloadWMS = function (selectedData) {
            // Remove feature id
            this.removeServicesRunningOnRecord(selectedData.feature.id);

            selectedData.layer.callbackContext.refresh();

            if (typeof this.callbackContext !== "undefined") {
                this.callbackContext.publish(Constants.EVENT_MSG.LAYER_TOGGLE_WMS, {
                    layer_name: selectedData.layer.getShortName(),
                    visible: false
                });
            }
        };

        OpenSearchLayer.prototype.getFeatureById = function (featureId) {
            for (var i = 0; i < this.features.length; i++) {
                if (this.features[i].id === featureId) {
                    return this.features[i];
                }
            }
            return null;
        };

        OpenSearchLayer.prototype.getFeatureIndexById = function (featureId) {
            for (var i = 0; i < this.features.length; i++) {
                if (this.features[i].id === featureId) {
                    return i;
                }
            }
            return -1;
        };

        OpenSearchLayer.prototype.updateFeatureListWithTile = function (
            featureId,
            tile
        ) {
            var feature = this.getFeatureById(featureId);
            if (feature === null) {
                // Feature not found...no action
                return;
            }

            // Creation of list of associated tiles to keep trace of feature by tile
            if (typeof feature.associatedTiles === "undefined") {
                feature.associatedTiles = [];
            }

            // Make key value for tile
            var key = this.cache.getKey(tile.bound);

            if (feature.associatedTiles.indexOf(key) >= 0) {
                // still aded !
            } else {
                // add it
                feature.associatedTiles.push(key);
            }
        };
        /**************************************************************************************************************/
        /**
         * Manage a response to OpenSearch query
         * @function manageFeaturesResponse
         * @memberof OpenSearchLayer#
         * @param {Array} features Array of features loaded
         * @param {Tile} tile Tile
         * @fires OpenSearchLayer#updateStatsAttribute
         */
        OpenSearchLayer.prototype.manageFeaturesResponse = function (
            features,
            tile
        ) {
            this.updateFeatures(features);

            this.result.featuresLoaded += features.length;

            // Init array of feature id associated to tile
            if (
                tile.associatedFeaturesId === null ||
                typeof tile.associatedFeaturesId === "undefined"
            ) {
                tile.associatedFeaturesId = [];
            }

            // For each feature...
            for (i = features.length - 1; i >= 0; i--) {
                var feature = features[i];

                if (!feature.hasOwnProperty("id")) {
                    feature.id = feature.properties.identifier;
                }

                // Check if feature still globaly added ? (even on another tile)
                var alreadyAdded = this.featureStillAdded(feature.id);
                var alreadyAddedToTile = false;
                if (alreadyAdded) {
                    // Check if still added into this tile
                    alreadyAddedToTile = this.featureStillAddedToTile(
                        feature.id,
                        tile
                    );
                    if (alreadyAddedToTile === true) {
                        // Nothing to do !
                    } else {
                        tile.associatedFeaturesId.push(feature.id);
                        this.updateFeatureListWithTile(feature.id, tile);
                    }
                } else {
                    this.addFeature(feature);
                    tile.associatedFeaturesId.push(feature.id);
                    this.updateFeatureListWithTile(feature.id, tile);
                }
                features.splice(i, 1);
            }

            if (typeof this.callbackContext !== "undefined") {
                this.callbackContext.publish(
                    Constants.EVENT_MSG.LAYER_UPDATE_STATS_ATTRIBUTES,
                    {
                        shortName: this.getShortName(),
                        nb_loaded: this.features.length,
                        nb_total: this.result.featuresTotal
                    }
                );
            }

            // Only if tile was LOADING...
            if (tile.osState[this.getID()] === OpenSearchLayer.TileState.LOADING) {
                // ...set to LOADED
                tile.osState[this.getID()] = OpenSearchLayer.TileState.LOADED;
            }

            this.getGlobe().refresh();
        };

        /**************************************************************************************************************/

        /**
         * Update features
         * @function updateFeatures
         * @memberof OpenSearchLayer#
         * @param {Array} features Array of features
         * @private
         */
        OpenSearchLayer.prototype.updateFeatures = function (features) {
            for (var i = 0; i < features.length; i++) {
                var currentFeature = features[i];

                if (currentFeature.geometry) {
                    switch (currentFeature.geometry.type) {
                        case Constants.GEOMETRY.Point:
                            // Convert to geographic to simplify picking
                            if (currentFeature.geometry.coordinates[0] > 180) {
                                currentFeature.geometry.coordinates[0] -= 360;
                            }
                            break;
                        case Constants.GEOMETRY.Polygon:
                            var ring = currentFeature.geometry.coordinates[0];
                            for (var j = 0; j < ring.length; j++) {
                                // Convert to geographic to simplify picking
                                if (ring[j][0] > 180) {
                                    ring[j][0] -= 360;
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
        };

        /*************************************************************************************************************/

        return OpenSearchLayer;
    });

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMSElevationLayer',["../Utils/Utils", "./WMSLayer"], function(Utils, WMSLayer) {
    /**
     * WCSElevation configuration
     * @typedef {AbstractRasterLayer.wms_configuration} AbstractRasterLayer.wmsElevation_configuration
     * @property {int} [tilePixelSize = 33]
     */

    /**
     * @name WMSElevationLayer
     * @class
     *    Creates a layer for elevation data using WMS protocol based on a GeoTiling(4, 2)
     *    with a pixelSize = 33 by default. The only supported format is currently image/x-aaigrid.
     * @augments WMSLayer
     * @param {AbstractLayer.wmsElevation_configuration} options - WMSElevation configuration
     * @constructor
     * @memberof module:Layer
     */
    var WMSElevationLayer = function(options) {
        options.format = "image/x-aaigrid";
        options.tilePixelSize = options.tilePixelSize || 33;
        WMSLayer.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(WMSLayer, WMSElevationLayer);

    /**************************************************************************************************************/

    /**
     * Parse a elevation response
     * @function parseElevations
     * @memberof WMSElevationLayer#
     * @param {String} text Response as text
     * @return {float[]} Array of float
     */
    WMSElevationLayer.prototype.parseElevations = function(text) {
        var elevations = [];
        var lines = text.trim().split("\n");

        for (var i = 5; i < lines.length; i++) {
            var elts = lines[i].trim().split(/\s+/);
            for (var n = 0; n < elts.length; n++) {
                elevations.push(parseInt(elts[n], 10));
            }
        }

        return elevations;
    };

    /**************************************************************************************************************/

    return WMSElevationLayer;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/utils',[],function() {
    var Utils = {};

    /**
     * Inherits from an object
     * @author Jean-Christophe Malapert
     */
    Utils.inherits = function(base, sub) {
        function tempCtor() {}
        tempCtor.prototype = base.prototype;
        sub.prototype = new tempCtor();
        sub.prototype.constructor = sub;
    };

    Utils.makeHttpObject = function() {
        try {
            return new XMLHttpRequest();
        } catch (erreur) {}
        try {
            return new ActiveXObject("Msxml2.XMLHTTP");
        } catch (erreur) {}
        try {
            return new ActiveXObject("Microsoft.XMLHTTP");
        } catch (erreur) {}

        throw new Error(
            "The object creation for making HTTP requests has failed."
        );
    };

    Utils.guid = function() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return (
            s4() +
            s4() +
            "-" +
            s4() +
            "-" +
            s4() +
            "-" +
            s4() +
            "-" +
            s4() +
            s4() +
            s4()
        );
    };

    Utils.findValueByKeyword = function(listKeywords, keyword) {
        var result;
        for (i = 0; i < listKeywords.length; i++) {
            var currentKeyword = listKeywords[i];
            if (currentKeyword[0] === keyword) {
                result = currentKeyword[1];
                break;
            }
        }
        return result;
    };

    Utils.parseXML = function(val) {
        if (document.implementation && document.implementation.createDocument) {
            xmlDoc = new DOMParser().parseFromString(val, "text/xml");
        } else if (window.ActiveXObject) {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.loadXML(val);
        } else {
            alert("Your browser cannot handle this script");
            return null;
        }
        return xmlDoc;
    };

    return Utils;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/cache',[],function() {
    /**
     * Cache system for VOTable.
     * @exports Cache
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Cache = function() {
        this.nodeID = {};
        this.nodeName = {};
        this.warnings = [];
    };

    /**
     * Returns the cache of all nodes having an attribute ID.
     * @returns {Object.<String, AbstractNode>} the cache
     */
    Cache.prototype.getEltsByID = function() {
        return this.nodeID;
    };

    /**
     * Returns the cache of all nodes having an attribute name.
     * @returns {Object.<String, AbstractNode[]>} the cache
     */
    Cache.prototype.getEltsByName = function() {
        return this.nodeName;
    };

    /**
     * Returns the warnings.
     * @returns {String[]} the warnings
     */
    Cache.prototype.getWarnings = function() {
        return this.warnings;
    };

    /**
     * Add an entry to the cache.
     * @param {String} id the identifier of the VOTable element
     * @param {AbstractNode} node VOTable element
     */
    Cache.prototype.addEntryID = function(id, node) {
        this.nodeID[id] = node;
    };

    /**
     * Add an entry to the cache.
     * @param {String} name the identifier of the VOTable element
     * @param {AbstractNode} node VOTable element
     */
    Cache.prototype.addEntryName = function(name, node) {
        if (this.nodeName.hasOwnProperty(name)) {
            this.nodeName[name].push(node);
        } else {
            this.nodeName[name] = [];
            this.nodeName[name].push(node);
        }
    };

    /**
     * Stores a new warning;
     * @param warning warning
     */
    Cache.prototype.addWarning = function(warning) {
        this.warnings.push(warning);
    };

    return Cache;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/abstractNode',["./utils", "./cache"], function(Utils, Cache) {
    /**
     * Abstract node.
     *
     * Parses the attributes.
     *
     * @param {NodeList} childNode XML node
     * @exports AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var AbstractNode = function(childNode) {
        this.attributes = {};
        if (childNode != null && childNode.nodeType == 1) {
            var cache = null;
            for (var i = 0, l = childNode.attributes.length; i < l; i++) {
                var attribute = childNode.attributes[i];
                this.attributes[attribute.name] = attribute.value;
            }
            if (this.attributes.hasOwnProperty("ID")) {
                cache = Singleton.getInstance();
                cache.addEntryID(this.attributes.ID, this);
            }
            if (this.attributes.hasOwnProperty("name")) {
                cache = Singleton.getInstance();
                cache.addEntryName(this.attributes.name, this);
            }
        }
    };

    /**
     * Returns the attributes of a tag.
     * @returns {String[]} the attributes
     */
    AbstractNode.prototype.getAttributes = function() {
        return this.attributes;
    };

    /**
     * Checks if the tag has the "name" as attribute
     * @param name the attribute name to test
     * @returns {boolean} true when the attribute is defined otherwose false
     */
    AbstractNode.prototype.hasAttribute = function(name) {
        return this.attributes.hasOwnProperty(name);
    };

    /**
     * Checks if the tag has attributes
     * @returns {boolean} true when the tag has at least one attribute otherwise false.
     */
    AbstractNode.prototype.hasAttributes = function() {
        return Object.keys(this.attributes).length == 0 ? false : true;
    };

    /**
     * Returns the cache.
     * @returns {Cache}
     */
    AbstractNode.prototype.getCache = function() {
        return Singleton.getInstance();
    };

    /**
     * Creates a singeton for the cache.
     * @type {{getInstance}}
     */
    var Singleton = (function() {
        var instance;

        function createInstance() {
            var object = new Cache();
            return object;
        }

        return {
            getInstance: function() {
                if (!instance) {
                    instance = createInstance();
                }
                return instance;
            }
        };
    })();

    return AbstractNode;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/description',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Creates a Description object.
     * @param {NodeList} childNode
     * @exports Description
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Description = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var element = childNode.childNodes[0];
        if (element != null && element.nodeType == 3) {
            this.value =
                element.textContent == null ? null : element.textContent.trim();
        }
    };

    Utils.inherits(AbstractNode, Description);

    /**
     * Returns the content.
     * @returns {!String} the content
     */
    Description.prototype.getContent = function() {
        return this.value;
    };

    return Description;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/fieldref',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Construct the Fieldref object.
     *
     * @example <caption>Fieldref schema</caption>
     * {@lang xml}
     *  <xs:complexType name="FieldRef">
     *      <xs:attribute name="ref" type="xs:IDREF" use="required"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the FieldRef node
     * @exports Fieldref
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Fieldref = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode, Fieldref);

    /**
     * Returns the ref value.
     * this attribute is required.
     * @returns {!String} the ref value
     */
    Fieldref.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Fieldref.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Fieldref.prototype.utype = function() {
        return this.attributes.utype;
    };

    return Fieldref;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/paramref',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs the Paramref object.
     *
     * @example <caption>Paramref schema</caption>
     * {@lang xml}
     *  <xs:complexType name="ParamRef">
     *      <xs:attribute name="ref" type="xs:IDREF" use="required"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the ParamRef node
     * @exports Paramref
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Paramref = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode, Paramref);

    /**
     * Returns the ref value.
     * @returns {!String} the ref value
     */
    Paramref.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Paramref.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no value attribute.
     */
    Paramref.prototype.utype = function() {
        return this.attributes.utype;
    };

    return Paramref;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/min',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Construct a Min object.
     *
     * @example <caption>Min schema</caption>
     * {@lang xml}
     *   <xs:complexType name="Min">
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *      <xs:attribute name="inclusive" type="yesno" default="yes"/>
     *   </xs:complexType>
     *
     * @param {NodeList} childNode the Min node
     * @exports Min
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Min = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode, Min);

    /**
     * Returns the value value.
     * @returns {!String} the value value
     */
    Min.prototype.value = function() {
        return this.attributes.value;
    };

    /**
     * Returns the inclusive value.
     * @returns {?String} the inclusive value or null when no inclusive attribute.
     */
    Min.prototype.inclusive = function() {
        return this.attributes.inclusive;
    };

    return Min;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/max',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs the Max object
     *
     * @example <caption>Max schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Max">
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *      <xs:attribute name="inclusive" type="yesno" default="yes"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Max node
     * @exports Max
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Max = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode, Max);

    /**
     * Returns the value value.
     * @returns {!String} the value value.
     */
    Max.prototype.value = function() {
        return this.attributes.value;
    };

    /**
     * Returns the inclusive value.
     * @returns {?String} the inclusive value or null when no inclusive attribute.
     */
    Max.prototype.inclusive = function() {
        return this.attributes.inclusive;
    };

    return Max;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/option',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs the Option object.
     *
     * @example <caption>Option schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Option">
     *      <xs:sequence>
     *          <xs:element name="OPTION" type="Option" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Option node
     * @exports Option
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Option = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.options = parseOptionTag(childNode);
    };

    /**
     * Parses the Option node.
     * @param childNode the option node.
     * @returns {Option[]} the list of options
     */
    var parseOptionTag = function(childNode) {
        var options = [];
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "OPTION") {
                    options.push(new Option(element));
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in Option node"
                    );
                }
            }
        }
        return options;
    };

    Utils.inherits(AbstractNode, Option);

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Option.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the value value.
     * @returns {!String} the value value.
     */
    Option.prototype.value = function() {
        return this.attributes.value;
    };

    /**
     * Returns the list of OPTION nodes.
     * @returns {?Option[]} the list of OPTION nodes or 0 length when no OPTION node.
     */
    Option.prototype.getOptions = function() {
        return this.options;
    };

    return Option;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/values',["./utils", "./abstractNode", "./min", "./max", "./option"], function(
    Utils,
    AbstractNode,
    Min,
    Max,
    Option
) {
    /**
     * Constructs VALUES object.
     *
     * VALUES expresses the values that can be taken by the data in a column or by a parameter.
     *
     * @example <caption>Values schema</caption>
     * {@lang xml}
     * <xs:complexType name="Values">
     *  <xs:sequence>
     *      <xs:element name="MIN" type="Min" minOccurs="0"/>
     *      <xs:element name="MAX" type="Max" minOccurs="0"/>
     *      <xs:element name="OPTION" type="Option" minOccurs="0" maxOccurs="unbounded"/>
     *  </xs:sequence>
     *  <xs:attribute name="ID" type="xs:ID"/>
     *  <xs:attribute name="type" default="legal">
     *  <xs:simpleType>
     *      <xs:restriction base="xs:NMTOKEN">
     *          <xs:enumeration value="legal"/>
     *          <xs:enumeration value="actual"/>
     *      </xs:restriction>
     *  </xs:simpleType>
     *  </xs:attribute>
     *  <xs:attribute name="null" type="xs:token"/>
     *  <xs:attribute name="ref"  type="xs:IDREF"/>
     * </xs:complexType>
     *
     * @param {NodeList} childNode the VALUES node
     * @exports Values
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Values = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseValuesTag(childNode);
        this.min = result[0];
        this.max = result[1];
        this.options = result[2];
    };

    /**
     * Parses the VALUES node.
     *
     * @param {NodeList} childNode the VALUES node
     * @returns {Object.<Min,Max,Option[]>} the values
     */
    var parseValuesTag = function(childNode) {
        var min;
        var max;
        var options = [];
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "MIN":
                        min = new Min(element);
                        break;
                    case "MAX":
                        max = new Max(element);
                        break;
                    case "OPTION":
                        options.push(new Option(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Values node"
                        );
                }
            }
        }
        return [min, max, options];
    };

    Utils.inherits(AbstractNode, Values);

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} ID value or null when no ID attribute.
     */
    Values.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the type value of the attribute.
     * type attribute can get the following values:
     * <ul>
     *     <li>legal</li>
     *     <li>actual</li>
     * </ul>
     * @returns {!String} the type value.
     */
    Values.prototype.type = function() {
        return this.attributes.type;
    };

    /**
     * Returns the null value of the attribute.
     * @returns {?String} the null value or null when no null attribute.
     */
    Values.prototype.null = function() {
        return this.attributes["null"];
    };

    /**
     * Returns the ref value of the attribute.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Values.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the Min object of the attribute.
     * @returns {?Min} the Min object or null when no Min node.
     */
    Values.prototype.getMin = function() {
        return this.min;
    };

    /**
     * Returns the Max object of the attribute.
     * @returns {?Max} the Max object or null when no Max node.
     */
    Values.prototype.getMax = function() {
        return this.max;
    };

    /**
     * Returns the list of Options objects.
     *
     * Option is a sequence element of the Values node.
     *
     * @returns {?Option[]} the list of Option objects or 0 length when no Option node.
     */
    Values.prototype.getOptions = function() {
        return this.options;
    };

    return Values;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/link',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs the Link object.
     *
     * @example <caption>Link schema</caption>
     * {@lang xml}
     * The LINK is a URL (href) or some other kind of reference (gref)
     * <xs:complexType name="Link">
     *      <xs:attribute name="ID" type="xs:ID"/>
     *      <xs:attribute name="content-role" type="xs:token"/>
     *      <xs:attribute name="content-type" type="xs:token"/>
     *      <xs:attribute name="title" type="xs:string"/>
     *      <xs:attribute name="value" type="xs:string"/>
     *      <xs:attribute name="href" type="xs:anyURI"/>
     *      <xs:attribute name="gref" type="xs:token"/>
     *      <xs:attribute name="action" type="xs:anyURI"/>
     * </xs:complexType>
     *
     * @param {NodeList} childNode the Link node
     * @exports Link
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Link = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode, Link);

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Link.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the content-role value.
     * @returns {?String} the content-role value or null when no content-role attribute.
     */
    Link.prototype.content_role = function() {
        return this.attributes.content - role;
    };

    /**
     * Returns the content-type value.
     * @returns {?String} the content-type value or null when no content-type attribute.
     */
    Link.prototype.content_type = function() {
        return this.attributes.content - type;
    };

    /**
     * Returns the title value.
     * @returns {?String} the title value or null when no title attribute.
     */
    Link.prototype.title = function() {
        return this.attributes.title;
    };

    /**
     * Returns the value value.
     * @returns {?String} the value value or null when no value attribute.
     */
    Link.prototype.value = function() {
        return this.attributes.value;
    };

    /**
     * Returns the href value.
     * @returns {?String} the href value or null when no href attribute.
     */
    Link.prototype.href = function() {
        return this.attributes.href;
    };

    /**
     * Returns the gref value.
     * @returns {?String} the gref value or null when no gref attribute.
     */
    Link.prototype.gref = function() {
        return this.attributes.gref;
    };

    /**
     * Returns the action value.
     * @returns {?String} the action value or null when no action attribute.
     */
    Link.prototype.action = function() {
        return this.attributes.action;
    };

    return Link;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/field',[
    "./utils",
    "./abstractNode",
    "./description",
    "./values",
    "./link"
], function(Utils, AbstractNode, Description, Values, Link) {
    /**
     * Constructs the Field object.
     *
     * FIELD is the definition of what is in a column of the table.
     *
     * @example <caption>Field schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Field">
     *      <xs:sequence> <!-- minOccurs="0" maxOccurs="unbounded" -->
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="VALUES" type="Values" minOccurs="0"/> <!-- maxOccurs="2" -->
     *          <xs:element name="LINK" type="Link" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID" type="xs:ID"/>
     *      <xs:attribute name="unit" type="xs:token"/>
     *      <xs:attribute name="datatype" type="dataType" use="required"/>
     *      <xs:attribute name="precision" type="precType"/>
     *      <xs:attribute name="width" type="xs:positiveInteger"/>
     *      <xs:attribute name="xtype" type="xs:token"/>
     *      <xs:attribute name="ref" type="xs:IDREF"/>
     *      <xs:attribute name="name" type="xs:token" use="required"/>
     *      <xs:attribute name="ucd" type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="arraysize" type="xs:string"/>
     *      <xs:attribute name="type">
     *          <xs:simpleType>
     *              <xs:restriction base="xs:NMTOKEN">
     *                  <xs:enumeration value="hidden"/>
     *                  <xs:enumeration value="no_query"/>
     *                  <xs:enumeration value="trigger"/>
     *                  <xs:enumeration value="location"/>
     *              </xs:restriction>
     *          </xs:simpleType>
     *      </xs:attribute>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the FIELD node
     * @exports Field
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Field = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseField(childNode);
        this.description = result[0];
        this.values = result[1];
        this.links = result[2];
    };

    /**
     * Parses the FIELD node.
     * @param {NodeList} childNode the FIELD node
     * @returns {Object.<Description,Values,Link[]>} an array of description, values, link
     */
    var parseField = function(childNode) {
        var description;
        var values;
        var links = [];
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "VALUES":
                        values = new Values(element);
                        break;
                    case "LINK":
                        links.push(new Link(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Field node"
                        );
                }
            }
        }
        return [description, values, links];
    };

    Utils.inherits(AbstractNode, Field);

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Field.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the unit value.
     * @returns {?String} the unit value or null when no unit attribute.
     */
    Field.prototype.unit = function() {
        return this.attributes.unit;
    };

    /**
     * Returns the datatype value.
     * @returns {!String} the datatype value
     */
    Field.prototype.datatype = function() {
        return this.attributes.datatype;
    };

    /**
     * Returns the precision value.
     * @returns {?String} the precision value or null when no precision attribute.
     */
    Field.prototype.precision = function() {
        return this.attributes.precision;
    };

    /**
     * Returns the width value.
     * @returns {?String} the width value or null when no width attribute.
     */
    Field.prototype.width = function() {
        return this.attributes.width;
    };

    /**
     * Returns the xtype value.
     * @returns {?String} the xtype value or null when no xtype attribute.
     */
    Field.prototype.xtype = function() {
        return this.attributes.xtype;
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Field.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the name value.
     * @returns {!String} the name value.
     */
    Field.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Field.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Field.prototype.utype = function() {
        return this.attributes.utype;
    };

    /**
     * Returns the arraysize value.
     * @returns {?String} the arraysize value or null when no arraysize attribute.
     */
    Field.prototype.arraysize = function() {
        return this.attributes.arraysize;
    };

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Field.prototype.type = function() {
        return this.attributes.type;
    };

    /**
     * Returns the Description object
     * @returns {?Description} the Description object or null when no Description node.
     */
    Field.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the Values object.
     * @returns {?Values} the Values object or null when no Values node.
     */
    Field.prototype.getValues = function() {
        return this.values;
    };

    /**
     * Returns the set of Link objects.
     * @returns {?Link} the set of Link objects or null when no Link node
     */
    Field.prototype.getLinks = function() {
        return this.links;
    };

    return Field;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/param',["./utils", "./field"], function(Utils, Field) {
    /**
     * Constructs the Param object.
     *
     * @example <caption>Param schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Param">
     *      <xs:complexContent>
     *          <xs:extension base="Field">
     *              <xs:attribute name="value" type="xs:string" use="required"/>
     *          </xs:extension>
     *      </xs:complexContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Param node
     * @exports Param
     * @augments Field
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Param = function(childNode) {
        Field.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(Field, Param);

    /**
     * Returns the value value.
     * @returns {!String} the value value or null when no value attribute.
     */
    Param.prototype.value = function() {
        return this.attributes.value;
    };

    return Param;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/group',[
    "./utils",
    "./abstractNode",
    "./description",
    "./fieldref",
    "./paramref",
    "./param"
], function(Utils, AbstractNode, Description, Fieldref, Paramref, Param) {
    /**
     * Constructs the Group object.
     *
     * @example <caption>Group schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Group">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:choice minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="FIELDref" type="FieldRef"/>
     *              <xs:element name="PARAMref" type="ParamRef"/>
     *              <xs:element name="PARAM" type="Param"/>
     *              <xs:element name="GROUP" type="Group"/>
     *          </xs:choice>
     *      </xs:sequence>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ref"  type="xs:IDREF"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the GROUP node
     * @exports Group
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Group = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseGroup(childNode);
        this.description = result[0];
        this.fieldrefs = result[1];
        this.paramrefs = result[2];
        this.params = result[3];
        this.groups = result[4];
    };

    /**
     * Parses the GROUP node.
     * @param childNode the GROUP node
     * @returns {Object.<Description, Fieldref[], Paramref[], Param[], Group[]>} An array of description, fieldrefs, paramrefs, params, groups
     */
    var parseGroup = function(childNode) {
        var description;
        var fieldrefs = [];
        var paramrefs = [];
        var params = [];
        var groups = [];

        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "FIELDref":
                        fieldrefs.push(new Fieldref(element));
                        break;
                    case "PARAMref":
                        paramrefs.push(new Paramref(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Group node"
                        );
                }
            }
        }
        return [description, fieldrefs, paramrefs, params, groups];
    };

    Utils.inherits(AbstractNode, Group);

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Group.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Group.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Group.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Group.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Group.prototype.utype = function() {
        return this.attributes.utype;
    };

    /**
     * Returns the Description object.
     * @returns {?Description} the Description object or null when no Description node.
     */
    Group.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the set of Fieldref objects.
     * @returns {?Fieldref[]} the set of Fieldref objects or 0 length when no Fieldref node.
     */
    Group.prototype.getFieldrefs = function() {
        return this.fieldrefs;
    };

    /**
     * Returns the set of Paramref objects.
     * @returns {?Paramref[]} the set of Paramref objects or 0 length when no Paramref node.
     */
    Group.prototype.getParamrefs = function() {
        return this.paramrefs;
    };

    /**
     * Returns the set of Param objects.
     * @returns {?Param[]} the set of Param objects or 0 length when no Param node.
     */
    Group.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the set of Group objects.
     * @returns {?Group[]} the set of Group objects or 0 length when non Group node.
     */
    Group.prototype.getGroups = function() {
        return this.groups;
    };

    return Group;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/coosys',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs a CoordinateSystem object.
     *
     * @example <caption>CoordinateSystem schema</caption>
     * {@lang xml}
     *  <xs:complexType name="CoordinateSystem">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="ID" type="xs:ID" use="required"/>
     *              <xs:attribute name="equinox" type="astroYear"/>
     *              <xs:attribute name="epoch" type="astroYear"/>
     *              <xs:attribute name="system" default="eq_FK5">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="eq_FK4"/>
     *                          <xs:enumeration value="eq_FK5"/>
     *                          <xs:enumeration value="ICRS"/>
     *                          <xs:enumeration value="ecl_FK4"/>
     *                          <xs:enumeration value="ecl_FK5"/>
     *                          <xs:enumeration value="galactic"/>
     *                          <xs:enumeration value="supergalactic"/>
     *                          <xs:enumeration value="xy"/>
     *                          <xs:enumeration value="barycentric"/>
     *                          <xs:enumeration value="geo_app"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the CoordinateSystem node
     * @exports Coosys
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Coosys = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.value = parseCoordinateSystem(childNode);
    };

    Utils.inherits(AbstractNode, Coosys);

    /**
     * Parses the CoordinateSystem node.
     * @param {NodeList} childNode the CoordinateSystem node
     * @returns {String} the content of CoordinateSysem node
     */
    var parseCoordinateSystem = function(childNode) {
        var value;
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element != null && element.nodeType == 3) {
                value =
                    element.textContent == null
                        ? null
                        : element.textContent.trim();
            } else {
                this.getCache().addWarning(
                    "unknown element " + element + " in Coosys node"
                );
            }
        }
        return value;
    };

    /**
     * Returns the ID value.
     * @returns {!String} the ID value
     */
    Coosys.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the equinox value.
     * @returns {?String} the equinox value or null when no equinox attribute.
     */
    Coosys.prototype.equinox = function() {
        return this.attributes.equinox;
    };

    /**
     * Returns the epoch value.
     * @returns {?String} the epoch value or null when no epoch attribute.
     */
    Coosys.prototype.epoch = function() {
        return this.attributes.epoch;
    };

    /**
     * Returns the system value.
     * @returns {?String} the system value or null when no system attribute.
     */
    Coosys.prototype.system = function() {
        return this.attributes.system;
    };

    /**
     * Returns the content of CoordinateSystem.
     * @returns {String} the content of CoordinateSystem.
     */
    Coosys.prototype.getContent = function() {
        return this.value;
    };

    return Coosys;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/definitions',[
    "./utils",
    "./abstractNode",
    "./group",
    "./param",
    "./coosys"
], function(Utils, AbstractNode, Group, Param, Coosys) {
    /**
     * Constructs a Definitions object.
     *
     * @example <caption>Definitions schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Definitions">
     *      <xs:choice minOccurs="0" maxOccurs="unbounded">
     *          <xs:element name="COOSYS" type="CoordinateSystem"/>
     *          <xs:element name="PARAM" type="Param"/>
     *      </xs:choice>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the DEFINITIONS node
     * @exports Definitions
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Definitions = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseDefinitions(childNode);
        this.coosys = result[0];
        this.param = result[1];
    };

    /**
     * Parses the DEFINITIONS node
     * @param {NodeList} childNode the DEFINITIONS node
     * @returns {Object.<Coosys[],Param[]>} Returns coosyss, params
     */
    var parseDefinitions = function(childNode) {
        var coosyss = [];
        var params = [];

        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "COOSYS":
                        coosyss.push(new Coosys(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " +
                                nodeName +
                                " in Definitions node"
                        );
                }
                if (nodeName == "COOSYS") {
                    coosyss.push(new Coosys(element));
                } else if (nodeName == "PARAM") {
                    params.push(new Param(element));
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in Definitions node"
                    );
                }
            }
        }
        return [coosyss, params];
    };

    Utils.inherits(AbstractNode, Definitions);

    /**
     * Returns the list of Coosys objects.
     * @returns {?Coosys[]} the list of Coosys objects or 0 length when no Coosys node.
     */
    Definitions.prototype.getCoosyss = function() {
        return this.coosys;
    };

    /**
     * Returns the list of Param objects.
     * @returns {?Param[]} the list of Param objects or 0 length when no Param node.
     */
    Definitions.prototype.getParams = function() {
        return this.param;
    };

    return Definitions;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/info',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Constructs the Info object.
     *
     * @example <caption>Info schema</caption>
     * {@lang xml}
     * <xs:complexType name="Info">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="ID" type="xs:ID"/>
     *              <xs:attribute name="name"  type="xs:token" use="required"/>
     *              <xs:attribute name="value" type="xs:string" use="required"/>
     *              <xs:attribute name="unit"  type="xs:token"/>
     *              <xs:attribute name="xtype" type="xs:token"/>
     *              <xs:attribute name="ref"   type="xs:IDREF"/>
     *              <xs:attribute name="ucd"   type="ucdType"/>
     *              <xs:attribute name="utype" type="xs:string"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     * @param {NodeList} childNode the Info node
     * @exports Info
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Info = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var element = childNode.childNodes[0];
        if (element != null && element.nodeType == 3) {
            this.value =
                element.textContent == null ? null : element.textContent.trim();
        }
    };

    /**
     * Returns the name value.
     * @returns {!String} the name value
     */
    Info.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the value value.
     * @returns {!String} the value value
     */
    Info.prototype.value = function() {
        return this.attributes.value;
    };

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Info.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the unit value.
     * @returns {?String} the unit value or null when no unit attribute.
     */
    Info.prototype.unit = function() {
        return this.attributes.unit;
    };

    /**
     * Returns the xtype value.
     * @returns {?String} the xtype value or null when no xtype attribute.
     */
    Info.prototype.xtype = function() {
        return this.attributes.xtype;
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Info.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Info.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Info.prototype.utype = function() {
        return this.attributes.utype;
    };

    /**
     * Returns the content of INFO node.
     * @returns {?String} the content of INFO node
     */
    Info.prototype.getContent = function() {
        return this.value;
    };

    return Info;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/td',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Construct the Td object.
     *
     * @example <caption>Td schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Td">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <!-- xs:attribute name="ref" type="xs:IDREF"/ -->
                    <xs:annotation><xs:documentation>
     *                  The 'encoding' attribute is added here to avoid
     *                  problems of code generators which do not properly
     *                  interpret the TR/TD structures.
     *                  'encoding' was chosen because it appears in
     *                  appendix A.5
     *              </xs:documentation></xs:annotation>
     *              <xs:attribute name="encoding" type="encodingType"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Td node
     * @exports Td
     * @augments AbstractNode
     * @param {string} options the value provided while parsing a base64 stream
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Td = function(childNode, options) {
        AbstractNode.prototype.constructor.call(this, childNode);
        if (options == null) {
            this.value =
                childNode.textContent == null
                    ? ""
                    : childNode.textContent.trim();
        } else {
            this.value = options == null ? "" : options.trim();
        }
    };

    Utils.inherits(AbstractNode, Td);

    /**
     * Returns the encoding value.
     * @returns {?String} the encoding value or null when no encoding attribute.
     */
    Td.prototype.encoding = function() {
        return this.attributes.encoding;
    };

    /**
     * Returns the content of the name.
     * @returns {string} the content
     */
    Td.prototype.getContent = function() {
        return this.value;
    };

    return Td;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/tr',["./utils", "./abstractNode", "./td"], function(
    Utils,
    AbstractNode,
    Td
) {
    /**
     * Constructs the Tr object.
     *
     * @example <caption>Tr schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Tr">
     *      <xs:annotation><xs:documentation>
     *      The ID attribute is added here to the TR tag to avoid
     *      problems of code generators which do not properly
     *      interpret the TR/TD structures
     *      </xs:documentation></xs:annotation>
     *      <xs:sequence>
     *          <xs:element name="TD" type="Td" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID" type="xs:ID"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Tr node
     * @param {Array} options the tds provided while parsing a base64 stream
     * @exports Tr
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Tr = function(childNode, options) {
        AbstractNode.prototype.constructor.call(this, childNode);
        if (options == null) {
            this.tds = parseTr(childNode);
        } else {
            this.tds = [];
            for (var i = 0; i < options.length; i++) {
                this.tds.push(new Td(null, options[i]));
            }
        }
    };

    /**
     * Parses the Tr node.
     * @param {NodeList} childNode the Tr node
     * @returns {!Td[]} an array of Td
     */
    var parseTr = function(childNode) {
        var tds = [];
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "TD") {
                    tds.push(new Td(element));
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in Tr node"
                    );
                }
            }
        }
        return tds;
    };

    Utils.inherits(AbstractNode, Tr);

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Tr.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the list of Td objects.
     *
     * Td is the sequence element of the Tr node.
     *
     * @returns {Td[]} the list of Td objects or 0 length when no TD node.
     */
    Tr.prototype.getTds = function() {
        return this.tds;
    };

    return Tr;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/abstractData',["./utils", "./abstractNode"], function(Utils, AbstractNode) {
    /**
     * Stores the name of the data implementation
     * @param {NodeList} childNode XML node
     * @param {String} name name of the data implementation
     * @exports AbstractData
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var AbstractData = function(childNode, name) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.name = name;
    };

    Utils.inherits(AbstractNode, AbstractData);

    AbstractData.prototype.getName = function() {
        return this.name;
    };

    return AbstractData;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/tabledata',["./utils", "./tr", "./abstractData"], function(
    Utils,
    Tr,
    AbstractData
) {
    /**
     * Construct a TableData object.
     *
     * @example <caption>Tabledata schema</caption>
     * {@lang xml}
     *  <xs:complexType name="TableData">
     *      <xs:sequence>
     *          <xs:element name="TR" type="Tr" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the TableData node
     * @param {Array} options the trs provided by {@link Base64#decode} while parsing a base64 stream
     * @exports TableData
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var TableData = function(childNode, options) {
        AbstractData.prototype.constructor.call(this, childNode, "TableData");
        if (options == null) {
            this.trs = parseTableData(childNode);
        } else {
            this.trs = [];
            for (var i = 0; i < options.length; i++) {
                this.trs.push(new Tr(null, options[i]));
            }
        }
    };

    /**
     * Parses the TableData node.
     * @param {NodeList} childNode the TableData node
     * @returns {Tr[]} A list of Tr object
     */
    var parseTableData = function(childNode) {
        var trs = [];
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "TR") {
                    trs.push(new Tr(element));
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in TableData node"
                    );
                }
            }
        }
        return trs;
    };

    Utils.inherits(AbstractData, TableData);

    /**
     * Returns the list of Tr objects.
     *
     * Tr is the sequence element of the TableData node.
     *
     * @returns {?Tr[]} the list of Tr objects or 0 length when no Tr node.
     */
    TableData.prototype.getTrs = function() {
        return this.trs;
    };

    return TableData;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/converter/base64',[],function() {
    var TAB_DATA_SIZE = {
        short: 16,
        int: 32,
        float: 32,
        double: 64,
        unsignedByte: 8
    };

    /**
     * Creates a base64 constructor based on the description of the different data types.
     * This description is needed to decode the information encoding in base64
     *
     * A part of the methods comes from {@link http://github.com/aschaaff/votable.js}
     *
     * @param fields the description of the data types based on {@link Field}
     * @exports Base64
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Base64 = function(fields) {
        this.ptrStream = 0;
        this.bufferTabBits = [];
        this.fields = fields;
    };

    /**
     * Computes the data size in bits
     * @param datatype type of the data (e.g char, int, ...)
     * @param fieldNumber the current {@link Field}
     * @param stream the base64 stream
     * @returns {number} the number of bits
     */
    Base64.prototype.computeDataSize = function(datatype, fieldNumber, stream) {
        var dataSize = 0;
        if (datatype === "char") {
            if (/\*/.test(this.fields[fieldNumber].arraysize())) {
                // if size is variable (ex: arraysize="16*")

                var tabBits = this.streamB64(32, stream);
                dataSize = 8 * bin2uint32(tabBits);
                tabBits = [];
            } else {
                // fix size
                dataSize = 8 * this.fields[fieldNumber].arraysize();
            }
        } else {
            dataSize = TAB_DATA_SIZE[datatype];
        }
        return dataSize;
    };

    /**
     * Reads base 64 data, and return binary array.
     * @param datasize the number of bits of the data
     * @param stream the base 64 data
     * @returns {Array} an array of bits
     */
    Base64.prototype.streamB64 = function(datasize, stream) {
        var tabBits = [];
        var bufferLength = this.bufferTabBits.length;
        var needBit = Math.ceil((datasize - bufferLength) / 6);
        for (var i = 0; i < bufferLength; i += 1) {
            tabBits.push(this.bufferTabBits[i]);
        }
        this.bufferTabBits = []; // delete old data

        for (i = 0; i < needBit; i += 1) {
            if (stream.charCodeAt(this.ptrStream) == 10) {
                // Line Feed (Fin de ligne)
                i -= 1;
            } else {
                var nb = b64ToUint6(stream.charCodeAt(this.ptrStream));

                for (var z = 32; z > 0; z >>= 1) {
                    if (tabBits.length !== datasize) {
                        tabBits.push((nb & z) === z ? "1" : "0");
                    } else {
                        this.bufferTabBits.push((nb & z) === z ? "1" : "0");
                    }
                }
            }
            this.ptrStream += 1;
        }
        return tabBits;
    };

    /**
     * Decodes a value read from the stream.
     * @param datatype the datatype
     * @param datasize the datasize in bits
     * @param fieldNumber the current {@link Field}
     * @param stream the base64 stream
     * @returns {string} a value such a string or a number
     */
    Base64.prototype.decodeValue = function(
        datatype,
        datasize,
        fieldNumber,
        stream
    ) {
        var value;
        var tabBits = [];
        //extracts bits from the datasize
        if (datatype != "NULL") {
            tabBits = this.streamB64(datasize, stream);
        }

        //converts the bits in human readable value
        switch (datatype) {
            case "short":
                value = bin2short16(tabBits);
                break;
            case "int":
                value = bin2int32(tabBits);
                break;
            case "float":
                value = bin2float32(tabBits);
                value = value.toFixed(this.fields[fieldNumber].precision()); // round (arrondi)
                break;
            case "double":
                value = bin2double64(tabBits);
                value = value.toFixed(this.fields[fieldNumber].precision()); // round (arrondi)
                break;
            case "unsignedByte":
                value = bin2ubyte8(tabBits);
                break;
            case "char":
                value = bin2string(tabBits);
                break;
            case "NULL": // Empty Data
                value = "NULL";
                break;
        }
        if (value === "NaN" || value === "NULL" || value === 0) {
            value = "";
        }
        return value;
    };

    /**
     * Decodes a stream.
     * @param stream the base64 stream
     * @returns {Array} the table value [td[],td[],..]
     */
    Base64.prototype.decode = function(stream) {
        var trs = [];
        var fieldNumber = 0;
        var tabBits = [];
        var streamLength = stream.length;
        var nbFields = this.fields.length;
        var tds = [];
        do {
            var datatype = this.fields[fieldNumber].datatype();
            var datasize = this.computeDataSize(datatype, fieldNumber, stream);
            if (datasize == 0) {
                datatype = "NULL";
            }
            var value = this.decodeValue(
                datatype,
                datasize,
                fieldNumber,
                stream
            );
            tds.push(value);
            if (fieldNumber === nbFields - 1) {
                fieldNumber = 0;
                trs.push(tds);
                tds = [];
            } else {
                fieldNumber += 1;
            }
        } while (this.ptrStream < streamLength);
        return trs;
    };

    /***
     * Converts binary array to int 16 bits (signed).
     *
     * Example :
     * Input : array(0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1)
     * Ouput : 21 549
     *
     * @param {Array} TabBits Binary array
     * @return {int} int (16 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2short16(TabBits) {
        "use strict";
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(2);
        dataview = new DataView(buffer);
        binary = TabBits.join("");
        dataview.setUint16(0, parseInt(binary, 2));

        return dataview.getInt16(0);
    }

    /***
     * Converts binary array to int 32 bits (signed).
     *
     * Example :
     * Input : array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0)
     * Ouput : 1 049 834
     *
     * @param {array} TabBits Binary array
     * @return {int} int (32 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2int32(TabBits) {
        "use strict";
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join("");
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getInt32(0);
    }

    /***
     * Converts binary array to float 32 bits.
     *
     * Example :
     * Input : array(0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0)
     * Ouput : 0.302
     *
     * @param {Array} TabBits Binary array
     * @return {float} float (32 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2float32(TabBits) {
        "use strict";
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join("");
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getFloat32(0);
    }

    /***
     * Converts binary array to double 64 bits.
     *
     * Example :
     * Input : array(0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1)
     * Ouput : 265.083811
     *
     * @param {Array} TabBits binary array
     * @return {float} (64 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2double64(TabBits) {
        "use strict";
        var buffer, dataview, lenght, binary;

        buffer = new ArrayBuffer(8);
        dataview = new DataView(buffer);

        binary = TabBits.slice(0, 32).join("");
        dataview.setUint32(0, parseInt(binary, 2));
        binary = "";

        binary = TabBits.slice(32, 64).join("");
        dataview.setUint32(4, parseInt(binary, 2));

        return dataview.getFloat64(0);
    }

    /***
     * Converts binary array to int 8 bits (unsigned : 0 - 255).
     *
     * Example :
     * Input : array(1, 0, 0, 0, 1, 1, 0, 0)
     * Ouput : 140
     *
     * @param {Array} TabBits Binary array
     * @return {int} int (8 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2ubyte8(TabBits) {
        "use strict";
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(1);
        dataview = new DataView(buffer);
        binary = TabBits.join("");
        dataview.setUint8(0, parseInt(binary, 2));

        return dataview.getUint8(0);
    }

    /***
     * Converts binary array to string.
     *
     * Example :
     * Input : array(0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1)
     * Ouput : Hi!
     *
     * @param {Array} TabBits binary array
     * @return {string} string (min : 1 char)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2string(TabBits) {
        "use strict";
        var lenght, binary, i, j, str;

        lenght = TabBits.length / 8;
        binary = [];
        str = "";
        j = 0;

        for (i = 0; i < lenght; i += 1) {
            binary = TabBits.slice(j, j + 8);
            str = str.concat(String.fromCharCode(bin2ubyte8(binary)));
            binary = [];
            j += 8;
        }

        return str;
    }

    /***
     * Converts binary array to int 32 bits (unsigned).
     *
     * Example :
     * Input : array(0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0)
     * Ouput : 248 973 430
     *
     * @param {Array} TabBits a binary array
     * @return {int} 32 bit value
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2uint32(TabBits) {
        "use strict";
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join("");
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getUint32(0);
    }

    /***
     * Converts Ascii code to base 64 value.
     *
     * Example :
     * Input : 104 (Ascii code of h)
     * Ouput : 33 (value of h in base 64)
     *
     * @param {int} character ASCII code
     * @return {byte} base 64 value
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function b64ToUint6(caractere) {
        var byte;

        if (caractere > 64 && caractere < 91) {
            // char A-Z
            byte = caractere - 65;
        } else if (caractere > 96 && caractere < 123) {
            // char a-z
            byte = caractere - 71;
        } else if (caractere > 47 && caractere < 58) {
            // number 0-9
            byte = caractere + 4;
        } else if (caractere === 43) {
            // char +
            byte = 62;
        } else if (caractere === 47) {
            // char /
            byte = 63;
        }

        return byte;
    }

    return Base64;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/stream',[
    "./utils",
    "./abstractNode",
    "./converter/base64",
    "./tabledata"
], function(Utils, AbstractNode, Base64, TableData) {
    /**
     * Constructs the Stream object.
     *
     * STREAM can be local or remote, encoded or not
     *
     * @example <caption>Stream schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Stream">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="type" default="locator">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="locator"/>
     *                          <xs:enumeration value="other"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *              <xs:attribute name="href" type="xs:anyURI"/>
     *              <xs:attribute name="actuate" default="onRequest">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="onLoad"/>
     *                          <xs:enumeration value="onRequest"/>
     *                          <xs:enumeration value="other"/>
     *                          <xs:enumeration value="none"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *              <xs:attribute name="encoding" type="encodingType" default="none"/>
     *              <xs:attribute name="expires" type="xs:dateTime"/>
     *              <xs:attribute name="rights" type="xs:token"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Stream node
     * @exports Stream
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Stream = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.value = childNode.textContent;
    };

    Utils.inherits(AbstractNode, Stream);

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Stream.prototype.type = function() {
        return this.attributes.type;
    };

    /**
     * Returns the href value.
     * @returns {?String} the href value or null when no href attribute.
     */
    Stream.prototype.href = function() {
        return this.attributes.href;
    };

    /**
     * Returns the actuate value.
     * @returns {?String} the actuate value or null when no actuate attribute.
     */
    Stream.prototype.actuate = function() {
        return this.attributes.actuate;
    };

    /**
     * Returns the encoding value.
     * @returns {!String} the encoding value or null when no encoding attribute.
     */
    Stream.prototype.encoding = function() {
        return this.attributes.encoding;
    };

    /**
     * Returns the expires value.
     * @returns {?String} the expires value or null when no expires attribute.
     */
    Stream.prototype.expires = function() {
        return this.attributes.expires;
    };

    /**
     * Returns the rights value.
     * @returns {?String} the rights value or null when no rights attribute.
     */
    Stream.prototype.rights = function() {
        return this.attributes.rights;
    };

    /**
     * Returns the content.
     * @returns {!String} the content
     */
    Stream.prototype.getContent = function(decode, fields) {
        var result;
        if (decode == null || decode == false) {
            result = this.value;
        } else {
            var base64 = new Base64(fields);
            result = new TableData(null, base64.decode(this.value));
        }
        return result;
    };

    return Stream;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/binary',["./utils", "./stream", "./abstractData"], function(
    Utils,
    Stream,
    AbstractData
) {
    /**
     * Constructs the Binary object.
     *
     * @example <caption>Binary schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Binary">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Binary node
     * @exports Binary
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Binary = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Binary");
        this.stream = parseBinary(childNode);
    };

    /**
     * Parses the Binary node.
     * @param {NodeList} childNode the Binary node
     * @returns {!Stream} the Stream
     * @throws "Unknown element"
     */
    var parseBinary = function(childNode) {
        var stream;
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Stream(element);
                } else {
                    throw "Unknown element";
                }
            }
        }
        return stream;
    };

    Utils.inherits(AbstractData, Binary);

    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object
     */
    Binary.prototype.getStream = function() {
        return this.stream;
    };

    return Binary;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/binary2',["./utils", "./stream", "./abstractData"], function(
    Utils,
    Stream,
    AbstractData
) {
    /**
     * Constructs the Binary2 object.
     *
     * @example <caption>Binary2 schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Binary2">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Binary2 node
     * @exports Binary2
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Binary2 = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Binary2");
        this.stream = parseBinary2(childNode);
    };

    /**
     * Parses the Binary2 node.
     * @param {NodeList} childNode the Binary node
     * @returns {!String} the Stream
     */
    var parseBinary2 = function(childNode) {
        var stream;
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Definitions(element);
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in Binary2 node"
                    );
                }
            }
        }
        return stream;
    };

    Utils.inherits(AbstractData, Binary2);

    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object
     */
    Binary2.prototype.getStream = function() {
        return this.stream;
    };

    return Binary2;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/fits',["./utils", "./abstractData", "./stream"], function(
    Utils,
    AbstractData,
    Stream
) {
    /**
     * Constructs the Fits object.
     *
     * @example <caption>Fits schema</caption>
     * {@lang xml}
     *  <xs:complexType name="FITS">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *      <xs:attribute name="extnum" type="xs:positiveInteger"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Fits node
     * @exports Fits
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Fits = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Fits");
        this.stream = parseFits(childNode);
    };

    /**
     * Parses the Fits node.
     * @param childNode the Fits node
     * @returns {Stream} the stream
     */
    var parseFits = function(childNode) {
        var stream;
        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Definitions(element);
                } else {
                    this.getCache().addWarning(
                        "unknown element " + nodeName + " in Fits node"
                    );
                }
            }
        }
        return stream;
    };

    Utils.inherits(AbstractData, Fits);

    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object.
     */
    Fits.prototype.getStream = function() {
        return this.stream;
    };

    /**
     * Returns te extnum value.
     * @returns {!String} the extnum value.
     */
    Fits.prototype.extnum = function() {
        return this.attributes.extnum;
    };

    return Fits;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/data',[
    "./utils",
    "./abstractNode",
    "./tabledata",
    "./binary",
    "./binary2",
    "./fits",
    "./info"
], function(Utils, AbstractNode, TableData, Binary, Binary2, Fits, Info) {
    /**
     * Constructs a Data object.
     *
     * @example <caption>Data schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Data">
     *      <xs:sequence>
     *          <xs:choice>
     *              <xs:element name="TABLEDATA" type="TableData"/>
     *              <xs:element name="BINARY" type="Binary"/>
     *              <xs:element name="BINARY2" type="Binary2"/>
     *              <xs:element name="FITS" type="FITS"/>
     *          </xs:choice>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Data node
     * @exports Data
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Data = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseData(childNode);
        this.data = result[0];
        this.infos = result[1];
    };

    /**
     * Parses the Data node.
     * @param {NodeList} childNode the Data node
     * @returns {Object.<TableData|Binary|Binary2|Fits, Info[]>} the data
     */
    var parseData = function(childNode) {
        var data;
        var infos = [];

        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "TABLEDATA":
                        data = new TableData(element);
                        break;
                    case "BINARY":
                        data = new Binary(element);
                        break;
                    case "BINARY2":
                        data = new Binary2(element);
                        break;
                    case "FITS":
                        data = new Fits(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Data node"
                        );
                }
            }
        }
        return [data, infos];
    };

    Utils.inherits(AbstractNode, Data);

    /**
     * Returns the data.
     * @returns {!TableData|Binary|Binary2|Fits}
     */
    Data.prototype.getData = function() {
        return this.data;
    };

    /**
     * Returns the name of the data implementation.
     * @returns {!string} the name of the data implementation
     */
    Data.prototype.getDataImplementationName = function() {
        return this.data.getName();
    };

    /**
     * Returns the Infos object.
     * @returns {?Info[]} the Infos object or 0 length when no Info node.
     */
    Data.prototype.getInfos = function() {
        return this.infos;
    };

    return Data;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/table',[
    "./utils",
    "./abstractNode",
    "./description",
    "./field",
    "./param",
    "./group",
    "./link",
    "./data",
    "./info"
], function(
    Utils,
    AbstractNode,
    Description,
    Field,
    Param,
    Group,
    Link,
    Data,
    Info
) {
    /**
     * Constructs the Table object.
     *
     * A TABLE is a sequence of FIELD/PARAMs and LINKS and DESCRIPTION, possibly followed by a DATA section
     *
     * @example <caption>Table schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Table">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          <xs:choice minOccurs="1" maxOccurs="unbounded">
     *              <xs:element name="FIELD" type="Field"/>
     *              <xs:element name="PARAM" type="Param"/>
     *              <xs:element name="GROUP" type="Group"/>
     *          </xs:choice>
     *          <xs:element name="DATA" type="Data" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ref"  type="xs:IDREF"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="nrows" type="xs:nonNegativeInteger"/>
     *  </xs:complexType>
     * @param {NodeList} childNode the Table node
     * @exports Table
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Table = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);

        var result = parseTable(childNode);
        this.fields = result[0];
        this.params = result[1];
        this.groups = result[2];
        this.links = result[3];
        this.data = result[4];
        this.description = result[5];
        this.infos = result[6];
    };

    /**
     * Parses the Table node.
     * @param {NodeList} childNodes the Table node
     * @returns {Object.<Field[],Param[],Group[],Link[],Data,Description,Info[]>} an array of fields, params, groups, links, data, description, infos
     */
    var parseTable = function(childNodes) {
        var fields = [];
        var params = [];
        var groups = [];
        var links = [];
        var data;
        var description;
        var infos = [];
        for (
            var i = 0;
            childNodes != null && i < childNodes.childNodes.length;
            i++
        ) {
            var element = childNodes.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "FIELD":
                        fields.push(new Field(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    case "LINK":
                        links.push(new Link(element));
                        break;
                    case "DATA":
                        data = new Data(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Table node"
                        );
                }
            }
        }
        return [fields, params, groups, links, data, description, infos];
    };

    Utils.inherits(AbstractNode, Table);

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Table.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the name value of the attribute.
     * @returns {?String} the name value or null when no name attribute.
     */
    Table.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the ref value of the attribute.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Table.prototype.ref = function() {
        return this.attributes.ref;
    };

    /**
     * Returns the ucd value of the attribute.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Table.prototype.ucd = function() {
        return this.attributes.ucd;
    };

    /**
     * Returns the utype value of the attribute.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Table.prototype.utype = function() {
        return this.attributes.utype;
    };

    /**
     * Returns the nrows value of the attribute.
     * @returns {?String} the nrows value or null when no nrows attribute.
     */
    Table.prototype.nrows = function() {
        return this.attributes.nrows;
    };

    /**
     * Returns the list of Field objects.
     *
     * Field is one of the sequence element of the Table node.
     *
     * @returns {!Field[]} the list of Field objects or 0 length when no Field node.
     */
    Table.prototype.getFields = function() {
        return this.fields;
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the Table node.
     *
     * @returns {!Param[]} the list of Param objects
     */
    Table.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the Table node.
     *
     * @returns {!Group[]} the list of Group objects
     */
    Table.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Link objects.
     *
     * Link is one of the sequence element of the Table node.
     *
     * @returns {?Link[]} the list of Link objects or 0 length when no Link node
     */
    Table.prototype.getLinks = function() {
        return this.links;
    };

    /**
     * Returns the Data object
     *
     * Data is one of the sequence element of the Table node.
     *
     * @returns {?Data} the Data object or null when no Data node.
     */
    Table.prototype.getData = function() {
        return this.data;
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the Table node.
     *
     * @returns {?Info[]} the list of Info objects or 0 length when non Info node.
     */
    Table.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the description.
     *
     * Description is one of the sequence element of the Table node.
     *
     * @returns {string} the description.
     */
    Table.prototype.getDescription = function() {
        return this.description;
    };

    return Table;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/resource',[
    "./utils",
    "./abstractNode",
    "./description",
    "./info",
    "./table",
    "./link",
    "./coosys",
    "./param",
    "./group"
], function(
    Utils,
    AbstractNode,
    Description,
    Info,
    Table,
    Link,
    Coosys,
    Param,
    Group
) {
    /**
     * Constructs the Resource object.
     *
     * RESOURCES can contain DESCRIPTION, (INFO|PARAM|COSYS), LINK, TABLEs
     *
     * @example <caption>Resource schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Resource">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          <xs:choice minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="COOSYS" type="CoordinateSystem"/><!-- Deprecated in V1.2 -->
     *              <xs:element name="GROUP" type="Group" />
     *              <xs:element name="PARAM" type="Param" />
     *          </xs:choice>
     *          <xs:sequence minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="LINK" type="Link" minOccurs="0" maxOccurs="unbounded"/>
     *              <xs:choice>
     *                  <xs:element name="TABLE" type="Table" />
     *                  <xs:element name="RESOURCE" type="Resource" />
     *              </xs:choice>
     *              <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          </xs:sequence>
     *          <!-- Suggested Doug Tody, to include new RESOURCE types -->
     *          <xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="type" default="results">
     *          <xs:simpleType>
     *              <xs:restriction base="xs:NMTOKEN">
     *                  <xs:enumeration value="results"/>
     *                  <xs:enumeration value="meta"/>
     *              </xs:restriction>
     *          </xs:simpleType>
     *      </xs:attribute>
     *      <!-- Suggested Doug Tody, to include new RESOURCE attributes -->
     *      <xs:anyAttribute namespace="##other" processContents="lax"/>
     *  </xs:complexType>
     *
     *  @example <caption>Get a table</caption>
     *  var listResourcesOrTable = resource.getResourcesOrTables();
     *  var resourceOrTable = listResourcesOrTable[0];
     *  var table = resourceOrTable["TABLE"];
     *
     * @param {NodeList} childNode The Resource node
     * @exports Resource
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Resource = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseResource(childNode);
        this.description = result[0];
        this.infos = result[1];
        this.coosyss = result[2];
        this.params = result[3];
        this.groups = result[4];
        this.abstractSequences = result[5];
    };

    /**
     * Parses the Resource node.
     * @param {NodeList} childNode the Resource node
     * @returns {Object.<Description,Info[],Coosys[],Param[],Group[],Object>} an array of description, infos, coosyss, params, groups, abstractSequences
     */
    var parseResource = function(childNode) {
        var description;
        var infos = [];
        var coosyss = [];
        var groups = [];
        var params = [];
        var abstractSequences = [];
        var end = 0;
        var element = null;
        var nodeName = null;

        for (
            var i = 0;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    case "COOSYS":
                        coosyss.push(new Coosys());
                        break;
                    case "GROUP":
                        groups.push(new Group());
                        break;
                    case "PARAM":
                        params.push(new Param());
                        break;
                    default:
                        end = i;
                }
            }
            if (end != 0) {
                break;
            }
        }
        var seqElts = {};
        var seqLinks = [];
        var seqInfos = [];
        for (
            i = end;
            childNode != null && i < childNode.childNodes.length;
            i++
        ) {
            element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                nodeName = element.localName;
                switch (nodeName) {
                    case "LINK":
                        if (
                            seqElts.hasOwnProperty("TABLE") ||
                            seqElts.hasOwnProperty("RESOURCE")
                        ) {
                            seqElts.LINKS = seqLinks;
                            seqElts.INFOS = seqInfos;
                            abstractSequences.push(seqElts);
                            seqElts = {};
                            seqLinks = [];
                            seqInfos = [];
                        } else {
                            seqLinks.push(new Link(element));
                        }
                        break;
                    case "TABLE":
                        seqElts.TABLE = new Table(element);
                        break;
                    case "RESOURCE":
                        seqElts.RESOURCE = new Resource(element);
                        break;
                    case "INFO":
                        seqInfos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "Unkknown element " + nodeName + " in RESOURCE node"
                        );
                }
            }
        }
        if (Object.keys(seqElts).length != 0) {
            abstractSequences.push(seqElts);
        }
        return [description, infos, coosyss, params, groups, abstractSequences];
    };

    Utils.inherits(AbstractNode, Resource);

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Resource.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Resource.prototype.name = function() {
        return this.attributes.name;
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Resource.prototype.utype = function() {
        return this.attributes.utype;
    };

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Resource.prototype.type = function() {
        return this.attributes.type;
    };

    /**
     * Returns the Description object.
     *
     * Description is one of the sequence element of the Resource node.
     *
     * @returns {?Description} the Description object or null when no Description node.
     */
    Resource.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the Resource node.
     *
     * @returns {?Info[]} the list of Info objects or 0 length when no Info node
     */
    Resource.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the list of Coosys objects.
     *
     * Coosys is one of the sequence element of the Resource node.
     *
     * @returns {?Coosys[]} the list of Coosys objects or 0 length when no Coosys value.
     */
    Resource.prototype.getCoosyss = function() {
        return this.coosyss;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the Resource node.
     *
     * @returns {?Group[]} the list of Group objects or 0 length when no Group node.
     */
    Resource.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the Resource node.
     *
     * @returns {?Param[]} the list of Param objects or 0 length when no Param node.
     */
    Resource.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the list of Resource or Table objects.
     * @returns {?Object.<Description,Info[],Coosys[],Param[],Group[],Resource[]|Table[]>} the list of Resource or Table objects
     */
    Resource.prototype.getResourcesOrTables = function() {
        return this.abstractSequences;
    };

    return Resource;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/converter/geojson',["../utils"], function(Utils) {
    var UCD_ID = ["meta.record", "meta.id;meta.main", "VOX:Image_Titleq"];
    var UCD_RA = ["pos.eq.ra;meta.main", "POS_EQ_RA_MAIN"];
    var UCD_DEC = ["pos.eq.dec;meta.main", "POS_EQ_DEC_MAIN"];

    /**
     * Contructs a GeoJSON.
     * @param votable Votable format
     * @exports GeoJson
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var GeoJson = function(votable) {
        this.votable = votable;
        this.featureCollection = process(this.votable);
    };

    /**
     * Retrieves a GeoJson.
     * @param {Boolean} option sets to true to get a pretty output of the GeoJSON. By default, option is set to false
     * @returns {String} the GeoJson output of the VOTable
     */
    GeoJson.prototype.getGeoJSon = function(option) {
        var pretty = option | false;
        return JSON.stringify(this.featureCollection, null, pretty);
    };

    /**
     * Process the transformation of the Votable into GeoJson.
     * @param {Votable} votable the votable
     * @return {{type: string, features: Array}} The GeoJson as hash
     */
    function process(votable) {
        var featureCollection = {
            type: "FeatureCollection",
            features: []
        };
        var coosys = findAndGetGlobalCoosys(votable);
        if (coosys != null) {
            featureCollection.crs = {
                type: "name",
                properties: {
                    name: coosys
                }
            };
        }
        var features = [];
        var resources = votable.getResources();
        for (var i = 0; i < resources.length; i++) {
            processResource(resources[i], features);
        }
        featureCollection.features = features;

        /**
         * Finds and get the Coosys if this one is set global to the Votable.
         * @param {Votable} votable the Votable
         * @return {Coosys} The coordinate system
         */
        function findAndGetGlobalCoosys(votable) {
            var coosys;
            var defs = votable.getDefinitions();
            if (defs != null) {
                coosys = defs.getCoosyss()[0];
            }
            if (votable.getCoosyss()[0] != null) {
                coosys = votable.getCoosyss()[0];
            }
            return coosys;
        }

        return featureCollection;
    }

    /**
     * Process a resource.
     * @param {Resource} resource the resource to process
     * @param features the features to fill
     */
    function processResource(resource, features) {
        var resourcesOrTables = resource.getResourcesOrTables();
        for (var i = 0; i < resourcesOrTables.length; i++) {
            var resourceOrTable = resourcesOrTables[i];
            if (resourceOrTable.hasOwnProperty("RESOURCE")) {
                processResource(resourceOrTable.RESOURCE, features);
            } else if (resourceOrTable.hasOwnProperty("TABLE")) {
                processTable(resourceOrTable.TABLE, features);
            }
        }
    }

    /**
     * Process a table.
     * @param {Table} table the table to process
     * @param features the features to fill
     */
    function processTable(table, features) {
        var fields = table.getFields();
        var data = table.getData();
        var trs;
        var infos = table.getInfos();
        var tableData = null;
        switch (data.getDataImplementationName()) {
            case "TableData":
                tableData = data.getData();
                trs = tableData.getTrs();
                break;
            case "Binary":
                var binary = data.getData();
                tableData = binary.getStream().getContent(true, fields);
                trs = tableData.getTrs();
                break;
            case "Binary2":
                var binary2 = data.getData();
                throw new Error("Binary2 not implemented");
            case "Fits":
                var fits = data.getData();
                throw new Error("Fits not implemented");
            default:
                throw new Error("Type of data not implemented");
        }
        creatureFeatures(fields, infos, trs, features);
    }

    /**
     * Creates the features.
     * @param {Field[]} fields the fields
     * @param {Info[]} infos the infos
     * @param {Tr[]} trs the rows
     * @param features the features to fill
     */
    function creatureFeatures(fields, infos, trs, features) {
        for (var i = 0; i < trs.length; i++) {
            var tds = trs[i].getTds();
            features.push(createFeature(fields, infos, tds));
        }
    }

    /**
     * Creates a feature.
     * The infos are set in the GeoJSon properties.
     * @param {Field[]} fields the fields
     * @param {Info[]] infos the infos
     * @param {Td[]} tds the values
     * @return {{type: string, geometry: null, properties: {}}}
     */
    function createFeature(fields, infos, tds) {
        var feature = {
            type: "Feature",
            geometry: null,
            properties: {}
        };
        var coreMetadata = {};
        var properties = null;
        for (var i = 0; i < tds.length; i++) {
            var td = tds[i];
            var field = fields[i];
            var values = field.getValues();
            var nullValue = values != null ? values.null() : null;
            var ucd = field.ucd();
            var datatype = field.datatype();
            var value = td.getContent();
            var name = field.name();
            if (filter(UCD_RA, ucd)) {
                coreMetadata.RA = Number.parseFloat(value);
                coreMetadata.COOSYS = field.ref();
            } else if (filter(UCD_DEC, ucd)) {
                coreMetadata.DEC = Number.parseFloat(value);
            } else if (filter(UCD_ID, ucd)) {
                coreMetadata.ID = value;
            } else {
                properties = feature.properties;
                if (value != nullValue) {
                    properties[name] = parseDatatype(value, datatype);
                }
            }
        }
        if (!coreMetadata.hasOwnProperty("ID")) {
            coreMetadata.ID = Utils.guid();
        }
        for (i = 0; i < infos.length; i++) {
            var info = infos[i];
            properties[info.name()] = info.value();
        }
        checkCoreMetadata(coreMetadata);
        var geometry = {
            type: "Point",
            coordinates: [coreMetadata.RA, coreMetadata.DEC],
            crs: {
                type: "name",
                properties: {
                    name: coreMetadata.COOSYS
                }
            }
        };
        feature.geometry = geometry;

        /**
         * Checks if the core metadata is filled.
         * @param coreMetadata
         */
        function checkCoreMetadata(coreMetadata) {
            if (
                !(
                    coreMetadata.hasOwnProperty("RA") &&
                    coreMetadata.hasOwnProperty("DEC") &&
                    coreMetadata.hasOwnProperty("COOSYS") &&
                    coreMetadata.hasOwnProperty("ID")
                )
            ) {
                throw new Error(
                    "core metadata missing " + JSON.stringify(coreMetadata)
                );
            }
        }

        /**
         * Parses along the datatype (number or string).
         * @param value
         * @param type
         * @return {*}
         */
        function parseDatatype(value, type) {
            var result;
            switch (type) {
                case "short":
                case "int":
                case "long":
                    result = Number.parseInt(value);
                    break;
                case "float":
                case "double":
                    result = Number.parseFloat(value);
                    break;
                default:
                    result = value;
            }
            return result;
        }

        /**
         * Search a criteria in an array.
         * @param arr array
         * @param criteria criteria
         * @return {boolean} true when the criteria is found
         */
        function filter(arr, criteria) {
            var result = arr.filter(function(obj) {
                return obj === criteria;
            });
            return result.length == 0 ? false : true;
        }

        return feature;
    }

    return GeoJson;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/votable',[
    "./utils",
    "./abstractNode",
    "./definitions",
    "./info",
    "./resource",
    "./description",
    "./coosys",
    "./group",
    "./param",
    "./converter/geojson"
], function(
    Utils,
    AbstractNode,
    Definitions,
    Info,
    Resource,
    Description,
    Coosys,
    Group,
    Param,
    GeoJson
) {
    /**
     * Contructs a Votable object.
     *
     * @example <caption>VOTable schema</caption>
     * {@lang xml}
     * <xs:element name="VOTABLE">
     *      <xs:complexType>
     *          <xs:sequence>
     *              <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *              <xs:element name="DEFINITIONS" type="Definitions" minOccurs="0"/><!-- Deprecated -->
     *                  <xs:choice minOccurs="0" maxOccurs="unbounded">
     *                      <xs:element name="COOSYS" type="CoordinateSystem"/><!-- Deprecated in V1.2 -->
     *                      <xs:element name="GROUP" type="Group" />
     *                      <xs:element name="PARAM" type="Param" />
     *                      <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *                  </xs:choice>
     *              <xs:element name="RESOURCE" type="Resource" minOccurs="1" maxOccurs="unbounded"/>
     *              <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          </xs:sequence>
     *          <xs:attribute name="ID" type="xs:ID"/>
     *          <xs:attribute name="version">
     *              <xs:simpleType>
     *                  <xs:restriction base="xs:NMTOKEN">
     *                      <xs:enumeration value="1.3"/>
     *                  </xs:restriction>
     *              </xs:simpleType>
     *          </xs:attribute>
     *      </xs:complexType>
     *  </xs:element>
     *
     *
     * @example <caption>How to load a VOTable</caption>
     * var httpRequest = Utils.makeHttpObject();
     * httpRequest.open("GET", '"http://axel.u-strasbg.fr/HiPSCatService/I/284/out/metadata.xml', false);
     * httpRequest.send(null);
     * var xml = httpRequest.responseXML;
     * var votable = new Votable(xml);
     * @exports Votable
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     * @throws {Error} can be one of the following errors : "xml cannot be null", "This object is not supported", "his input is not a VOTable"
     */
    var Votable = function(xml) {
        xml = checkInputFormat(xml);
        var childNode = xml.documentElement;
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseVotableTag(childNode);
        this.definitions = result[0];
        this.infos = result[1];
        this.resources = result[2];
        this.description = result[3];
        this.coosyss = result[4];
        this.groups = result[5];
        this.params = result[6];
    };

    /**
     * Checks the xml format and converts the xml in a XMLDocument.
     * The different tests applied to the format are :
     * <ul>
     *     <li>checking for a null value</li>
     *     <li>checking for the type of the input<li>
     *     <li>checking for VOTABLE tag</li>
     * </ul>
     * @param {Object} xml the input
     * @returns {XMLDocument} the xml document
     * @throws {Error} can be one of the following errors : "xml cannot be null", "This object is not supported", "his input is not a VOTable"
     */
    function checkInputFormat(xml) {
        if (xml == null) {
            throw new Error("xml cannot be null");
        } else if (typeof xml === "string") {
            var parser = new DOMParser();
            xml = parser.parseFromString(xml, "application/xml");
        } else if (xml.documentElement != null) {
            // everything is fine
        } else {
            throw new Error("This object is not supported");
        }
        var tag = xml.documentElement.localName;
        if (tag != "VOTABLE") {
            throw new Error("This input is not a VOTable");
        }
        return xml;
    }

    /**
     * Parses the VOTable elements and returns the VOTable sequence elements.
     *
     * The VOTable sequence elements are the following :
     * <ul>
     *     <li>the DEFINITIONS element,</li>
     *     <li>the list of INFO elements,</li>
     *     <li>the list of RESOURCE elements,</li>
     *     <li>the DESCRIPTION element</li>
     *     <li>the list of COOSYS elements</li>
     *     <li>the list of GROUP elements</li>
     *     <li>the list of PARAM elements</li>
     * </ul>
     *
     * @param {NodeList} childNode The VOTable node
     * @returns {Object.<Definitions,Info[],Resource[],Description,Coosys[],Group[],Param[]>} The sequence which has been parsed
     */
    var parseVotableTag = function(childNode) {
        var root = childNode;
        var definitions;
        var infos = [];
        var resources = [];
        var description;
        var coosyss = [];
        var groups = [];
        var params = [];

        for (var i = 0; i < root.childNodes.length; i++) {
            var element = root.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DEFINITIONS":
                        definitions = new Definitions(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    case "RESOURCE":
                        resources.push(new Resource(element));
                        break;
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "COOSYS":
                        coosyss.push(new Coosys(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    default:
                        this.getCache().addWarning(
                            "unknown element " + nodeName + " in Votable node"
                        );
                }
            }
        }
        return [
            definitions,
            infos,
            resources,
            description,
            coosyss,
            groups,
            params
        ];
    };

    Utils.inherits(AbstractNode, Votable);

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} the ID value
     */
    Votable.prototype.ID = function() {
        return this.attributes.ID;
    };

    /**
     * Returns the version value of the attribute.
     * @returns {?String} the version value
     */
    Votable.prototype.version = function() {
        return this.attributes.version;
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Info>} the list of Info objects or 0 length when no Info node.
     */
    Votable.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the list of Definitions object.
     *
     * Definitions is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Definitions>} the list of Definitions object or 0 length when no Definitions node.
     */
    Votable.prototype.getDefinitions = function() {
        return this.definitions;
    };

    /**
     * Returns the list of Resource objects.
     *
     * Resource is one of the sequence element of the VOTable node.
     *
     * @returns {!Array.<Resource>} the list of Resource objects
     */
    Votable.prototype.getResources = function() {
        return this.resources;
    };

    /**
     * Returns the list of Coosys objects.
     *
     * Coosys is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Coosys>} the list of Coosys objects or 0 length when no Coosys node.
     */
    Votable.prototype.getCoosyss = function() {
        return this.coosyss;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Group>} the list of Group objects or 0 length when no Group node.
     */
    Votable.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Param>} the list of Param objects or 0 length when no Param node.
     */
    Votable.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the Description object.
     *
     * Description is one of the sequence element of the VOTable node.
     *
     * @returns {?Description} the Description object or null when no Description node.
     */
    Votable.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the VOTable element by its identifier.
     * @param {String] ID identifier of the VOTable element
     * @returns {?AbstractNode} the VOTable element or null when the ID is not found.
     */
    Votable.prototype.getVotableEltByID = function(ID) {
        return this.getCache().getEltsByID()[ID];
    };

    /**
     * Returns the VOTable elements by its name.
     * @param {String} name name of the VOTable element
     * @returns {AbstractNode[]} the VOTable elements or null when the name is not found.
     */
    Votable.prototype.getVotableEltsByName = function(name) {
        return this.getCache().getEltsByName()[name];
    };

    /**
     * Converts the VOTable to GeoJSON.
     * @param {Boolean} option sets to true to get a pretty output of the GeoJSON. By default, option is set to false
     * @returns {String} the GeoJson output of the VOTable
     */
    Votable.prototype.convertToGeoJSon = function(option) {
        var geoJson = new GeoJson(this);
        return geoJson.getGeoJSon(option);
    };

    return Votable;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/JsVotable',[
    "./votable",
    "./binary",
    "./binary2",
    "./coosys",
    "./data",
    "./definitions",
    "./description",
    "./field",
    "./fieldref",
    "./fits",
    "./group",
    "./info",
    "./link",
    "./max",
    "./min",
    "./option",
    "./param",
    "./paramref",
    "./resource",
    "./stream",
    "./table",
    "./tabledata",
    "./td",
    "./tr",
    "./values"
], function(
    Votable,
    Binary,
    Binary2,
    Coosys,
    Data,
    Definitions,
    Description,
    Field,
    Fieldref,
    Fits,
    Group,
    Info,
    Link,
    Max,
    Min,
    Option,
    Param,
    Paramref,
    Resource,
    Stream,
    Table,
    TableData,
    Td,
    Tr,
    Values
) {
    var JsVotable = {};

    JsVotable.Votable = Votable;
    JsVotable.Binary = Binary;
    JsVotable.Binary2 = Binary2;
    JsVotable.Coosys = Coosys;
    JsVotable.Data = Data;
    JsVotable.Definitions = Definitions;
    JsVotable.Description = Description;
    JsVotable.Field = Field;
    JsVotable.Fieldref = Fieldref;
    JsVotable.Fits = Fits;
    JsVotable.Group = Group;
    JsVotable.Info = Info;
    JsVotable.Link = Link;
    JsVotable.Max = Max;
    JsVotable.Min = Min;
    JsVotable.Option = Option;
    JsVotable.Param = Param;
    JsVotable.Paramref = Paramref;
    JsVotable.Resource = Resource;
    JsVotable.Stream = Stream;
    JsVotable.Table = Table;
    JsVotable.TableData = TableData;
    JsVotable.Td = Td;
    JsVotable.Tr = Tr;
    JsVotable.Values = Values;
    JsVotable.version = {
        major: 1,
        minor: 1,
        patch: 0,
        date: "2016-10-12",
        toString: function() {
            return this.major + "." + this.minor + "." + this.patch;
        }
    };

    window.JsVotable = JsVotable;

    return JsVotable;
});

define('Layer/JsCSV/csv',[], function() {
    var PREFIX_COMMENT = "#";

    var JsCSV = function(csv, commonSeparator, headerInfo) {
        csv = checkInputFormat(csv);
        this.store = parseCSV(csv, commonSeparator, headerInfo);
    };

    function checkInputFormat(csv) {
        if (csv == null) {
            throw new Error("csv cannot be null");
        } else if (typeof csv !== "string") {
            throw new Error("This object is not supported");
        } else {
            // everything is fine
        }
        return csv;
    }

    function parseCSV(csv, commonSeparator, headerInfo) {
        var rows = csv.split("\n");
        var lineWithData = 0;
        for (
            var i = 0;
            i < rows.length &&
            isUselessRow(rows[i], commonSeparator, headerInfo.name);
            i++
        ) {
            lineWithData++;
        }
        return parseRows(rows, lineWithData, commonSeparator, headerInfo);
    }

    function isUselessRow(row, commonSeparator, headerName) {
        return (
            row.startsWith(PREFIX_COMMENT) ||
            row.length == 0 ||
            headerName.toString() == row.split(commonSeparator).toString()
        );
    }

    function parseRows(rows, lineWithData, commonSeparator, headerInfo) {
        var store = [];
        for (var i = lineWithData; i < rows.length; i++) {
            if (rows[i].length !== 0) {
                store.push(parseRow(rows[i], commonSeparator, headerInfo));
            }
        }
        return store;
    }

    function parseRow(row, commonSeparator, headerInfo) {
        var store = {};
        var tds = row.split(commonSeparator);
        for (var i = 0; i < tds.length; i++) {
            store[headerInfo.name[i]] = parseDatatype(
                tds[i],
                headerInfo.datatype[i]
            );
        }
        return store;
    }

    function parseDatatype(value, type) {
        var result;
        switch (type) {
            case "short":
            case "int":
            case "long":
                result = Number.parseInt(value);
                break;
            case "float":
            case "double":
                result = Number.parseFloat(value);
                break;
            default:
                result = value;
        }
        return result;
    }

    JsCSV.prototype.getStore = function() {
        return this.store;
    };

    JsCSV.prototype.getGeoJSon = function(mapping, frame) {
        var RA = mapping.RA;
        var DEC = mapping.DEC;
        var ID = mapping.ID;
        //var CRS_NAME = mapping.CRS_NAME;
        var features = [];
        for (var i = 0; i < this.store.length; i++) {
            var feature = {
                type: "Feature",
                id: this.store[i][ID],
                geometry: {
                    type: "Point",
                    coordinates: [this.store[i][RA], this.store[i][DEC]],
                    crs: {
                        type: "name",
                        properties: {
                            name: frame
                        }
                    }
                }
            };
            var newStore = JSON.parse(JSON.stringify(this.store[i]));
            delete newStore[RA];
            delete newStore[DEC];
            delete newStore[ID];
            feature.properties = newStore;

            features.push(feature);
        }
        var featureCollection = {
            type: "FeatureCollection",
            features: features
        };
        return featureCollection;
    };

    return JsCSV;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/HipsCatLayer',[
    "./AbstractHipsLayer",
    "../Renderer/FeatureStyle",
    "../Renderer/RendererManager",
    "../Utils/Utils",
    "../Renderer/RendererTileData",
    "../Tiling/Tile",
    "./JsVotable/JsVotable",
    "./JsVotable/utils",
    "./JsCSV/csv",
    "../Utils/Constants"
], function(
    AbstractHipsLayer,
    FeatureStyle,
    RendererManager,
    Utils,
    RendererTileData,
    Tile,
    JsVotable,
    UtilsJsVotable,
    CSV,
    Constants
) {
    /**************************************************************************************************************/

    function _setDefaultOptions(options) {
        options.icon = options.icon || "css/images/star16x16.png";
        options.background = false;
        options.category = options.category || "Catalog";
        options.pickable = options.pickable || true;
        return options;
    }

    /**
     * Hips catalogue configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.hipsCat_configuration
     * @property {string} serviceUrl - Endpoint to reach the Hips catalogue
     * @property {int} [minOrder = 2] - min order
     * @property {int} [maxRequests = 4] - Max requests in parallel
     * @property {boolean} [invertY = false]
     */

    /**
     * Create a HIPS catalogue
     * @param {AbstractLayer.hipsCat_configuration} options - Hip catalogue configuration
     * @constructor
     * @memberof module:Layer
     * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
     */
    var HipsCatLayer = function(hipsMetadata, options) {
        AbstractHipsLayer.prototype.constructor.call(
            this,
            hipsMetadata,
            _setDefaultOptions(options)
        );
        var i;
        var propertiesObj = new Properties(
            this.proxify(options.baseUrl) + "/properties"
        );
        var properties = propertiesObj.getProperties();
        var hips_order = properties.hips_order;
        this.serviceUrl = this.proxify(options.baseUrl);
        this.minOrder = options.minOrder || 2;
        this.maxOrder = Number.parseInt(hips_order, 10);
        this.maxRequests = options.maxRequests || 4;
        this.invertY = options.invertY || false;
        var xhr = UtilsJsVotable.makeHttpObject();
        xhr.open("GET", this.proxify(options.baseUrl) + "/metadata.xml", false);
        xhr.send(null);
        var jsVotable = new JsVotable.Votable(xhr.responseXML);
        var resource = jsVotable.getResources()[0];
        var table = resource.getResourcesOrTables()[0].TABLE;
        this.fields = table.getFields();
        this.raColNumber = null;
        this.decColNumber = null;
        this.sourceId = null;
        for (i = 0; i < this.fields.length; i++) {
            var ucd = this.fields[i].ucd();
            if (ucd === "pos.eq.ra;meta.main") {
                this.raColNumber = this.fields[i].name();
            } else if (ucd === "pos.eq.dec;meta.main") {
                this.decColNumber = this.fields[i].name();
            } else if (ucd === "meta.id;meta.main") {
                this.sourceId = this.fields[i].name();
            }
        }

        this.extId = "hipsCat";

        // Used for picking management
        this.features = [];
        // Counter set, indicates how many times the feature has been requested
        this.featuresSet = {};

        // Maximum two requests for now
        this.freeRequests = [];
        this.tilesToLoad = [];

        // Build the request objects
        for (i = 0; i < this.maxRequests; i++) {
            xhr = new XMLHttpRequest();
            this.freeRequests.push(xhr);
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractHipsLayer, HipsCatLayer);

    /**************************************************************************************************************/

    /**
     * Parse properties file of the Hips catalogue
     * @param url
     * @constructor
     */
    var Properties = function(url) {
        this.properties = {};
        var i;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        xhr.send();
        var content = xhr.responseText;
        content.trim();
        var lines = content.split("\n");
        for (i = 0; lines !== null && i < lines.length; i++) {
            var line = lines[i];
            if (line !== null && (line.indexOf("#") > -1 || !line.trim())) {
                continue;
            }
            var keywordValue = line.split("=");
            var keyword = keywordValue[0].replace(/^\s+|\s+$/g, "");
            var value = keywordValue[1].replace(/^\s+|\s+$/g, "");
            this.properties[keyword] = value;
        }
    };

    /**
     * Returns the properties
     * @return {{}}
     */
    Properties.prototype.getProperties = function() {
        return this.properties;
    };

    /**
     * Attaches the layer to the globe
     * @param g The globe
     * @private
     */
    HipsCatLayer.prototype._attach = function(g) {
        AbstractHipsLayer.prototype._attach.call(this, g);
        this.extId += this.id;
        g.getTileManager().addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Detaches the layer from the globe
     * @private
     */
    HipsCatLayer.prototype._detach = function() {
        this.getGlobe()
            .getTileManager()
            .removePostRenderer(this);
        AbstractHipsLayer.prototype._detach.call(this);
    };

    /**************************************************************************************************************/

    /**
     * Launches request to the HipsCatLayer service
     * @param tile
     * @param url
     * @fires Layer#startLoad
     * @fires Layer#endLoad
     * @fires Layer#features:added
     */
    HipsCatLayer.prototype.launchRequest = function(tile, url) {
        var tileData = tile.extension[this.extId];
        var index = null;

        if (this.freeRequests.length === 0) {
            return;
        }

        // Set that the tile is loading its data for HipsCatLayer
        tileData.state = HipsCatLayer.TileState.LOADING;

        // Pusblish the start load event, only if there is no pending requests
        if (this.maxRequests === this.freeRequests.length) {
            this.getGlobe().publishEvent(
                Constants.EVENT_MSG.LAYER_START_LOAD,
                this
            );
        }

        var xhr = this.freeRequests.pop();
        var self = this;
        xhr.open("GET", url);
        xhr.send(null);
        xhr.onreadystatechange = function(e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var response = {};
                    var headerInfo = {
                        name: [],
                        datatype: []
                    };
                    self.fields.forEach(function(field) {
                        headerInfo.name.push(field.name());
                        headerInfo.datatype.push(field.datatype());
                    });
                    var csv = new CSV(xhr.response, "\t", headerInfo);
                    var geoJson = csv.getGeoJSon(
                        {
                            RA: self.raColNumber,
                            DEC: self.decColNumber,
                            ID: self.sourceId
                        },
                        "Equatorial"
                    );
                    var features = geoJson.features;
                    response.features = features;
                    response.totalResults = features.length;

                    //var response = JSON.parse(xhr.response);

                    tileData.complete =
                        response.totalResults === response.features.length;

                    //self.updateFeatures(response.features);

                    var i;
                    for (i = response.features.length - 1; i >= 0; i--) {
                        var feature = response.features[i];
                        // Eliminate already added features from response
                        var alreadyAdded = self.featuresSet.hasOwnProperty(
                            feature.id
                        );
                        if (alreadyAdded) response.features.splice(i, 1);

                        feature.properties.style = this.style;
                        self.addFeature(feature, tile);
                    }
                    self.globe.refresh();

                    // Publish event that layer have received new features
                    if (
                        response.hasOwnProperty(features) &&
                        response.features.length > 0
                    ) {
                        self.globe.publishEvent(
                            Constants.EVENT_MSG.FEATURED_ADDED,
                            { layer: self, features: response.features }
                        );
                    }
                } else if (xhr.status >= 400) {
                    tileData.complete = true;
                }

                tileData.state = HipsCatLayer.TileState.LOADED;
                self.freeRequests.push(xhr);

                // Publish the end load event, only if there is no pending requests
                if (self.maxRequests === self.freeRequests.length) {
                    self.globe.publishEvent(
                        Constants.EVENT_MSG.LAYER_END_LOAD,
                        self
                    );
                }
            }
        };
    };

    /**************************************************************************************************************/

    /**
     * Adds feature to the layer and to the tile extension
     * @param feature
     * @param tile
     */
    HipsCatLayer.prototype.addFeature = function(feature, tile) {
        var tileData = tile.extension[this.extId];
        var featureData;

        // Add feature if it doesn't exist
        if (!this.featuresSet.hasOwnProperty(feature.id)) {
            this.features.push(feature);
            featureData = {
                index: this.features.length - 1,
                tiles: [tile]
            };
            this.featuresSet[feature.id] = featureData;
        } else {
            featureData = this.featuresSet[feature.id];

            // Store the tile
            featureData.tiles.push(tile);

            // Always use the base feature to manage geometry indices
            feature = this.features[featureData.index];
        }

        // Add feature id
        tileData.featureIds.push(feature.id);

        // Set the identifier on the geometry
        feature.geometry.gid = feature.id;

        // Add to renderer
        //this.addFeatureToRenderer(feature, tile);

        // MS: Feature could be added from ClusterOpenSearch which have features with different styles
        var style = feature.properties.style
            ? feature.properties.style
            : this.style;

        this.getGlobe()
            .getRendererManager()
            .addGeometryToTile(this, feature.geometry, style, tile);
    };

    /**************************************************************************************************************/

    /**
     * Removes feature from Dynamic HipsCatLayer layer
     * @param identifier
     * @param tile
     */
    HipsCatLayer.prototype.removeFeature = function(identifier, tile) {
        var featureIt = this.featuresSet[identifier];

        if (!featureIt) {
            return;
        }

        // Remove tile from array
        var tileIndex = featureIt.tiles.indexOf(tile);
        if (tileIndex >= 0) {
            featureIt.tiles.splice(tileIndex, 1);
        } else {
            console.error(
                "HipsCatLayer internal error : tile not found when removing feature"
            );
        }

        if (featureIt.tiles.length === 0) {
            // Remove it from the set
            delete this.featuresSet[identifier];

            // Remove it from the array by swapping it with the last feature to optimize removal.
            var lastFeature = this.features.pop();
            if (featureIt.index < this.features.length) {
                // Set the last feature at the position of the removed feature
                this.features[featureIt.index] = lastFeature;
                // Update its index in the Set.
                this.featuresSet[lastFeature.id].index = featureIt.index;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Modifies feature style
     * @param feature
     * @param style
     */
    HipsCatLayer.prototype.modifyFeatureStyle = function(feature, style) {
        feature.properties.style = style;
        var featureData = this.featuresSet[feature.id];
        if (featureData) {
            var i;
            for (i = 0; i < featureData.tiles.length; i++) {
                var tile = featureData.tiles[i];
                this.getGlobe()
                    .getRendererManager()
                    .removeGeometryFromTile(feature.geometry, tile);
                this.getGlobe()
                    .getRendererManager()
                    .addGeometryToTile(this, feature.geometry, style, tile);
            }
        }
    };

    HipsCatLayer.TileState = {
        LOADING: 0,
        LOADED: 1,
        NOT_LOADED: 2,
        INHERIT_PARENT: 3
    };

    /**************************************************************************************************************/

    /**
     * Generates the tile data
     * @param tile
     */
    HipsCatLayer.prototype.generate = function(tile) {
        if (this.minOrder <= tile.order && tile.order <= this.maxOrder) {
            tile.extension[this.extId] = new OSData(this, tile, null);
        }
    };

    /**************************************************************************************************************/

    /**
     * HipsCatLayer renderable
     * @param layer
     * @param tile
     * @param p
     * @constructor
     */
    var OSData = function(layer, tile, p) {
        this.layer = layer;
        this.parent = p;
        this.tile = tile;
        this.featureIds = []; // exclusive parameter to remove from layer
        this.state = HipsCatLayer.TileState.NOT_LOADED;
        this.complete = false;
        this.childrenCreated = false;
    };

    /**************************************************************************************************************/

    /**
     * Traverse
     * @param tile
     */
    OSData.prototype.traverse = function(tile) {
        var i;
        if (!this.layer.isVisible()) return;

        if (tile.state !== Tile.State.LOADED) return;

        // Check if the tile need to be loaded
        if (this.state === HipsCatLayer.TileState.NOT_LOADED) {
            this.layer.tilesToLoad.push(this);
        }

        // Create children if needed
        if (
            this.state === HipsCatLayer.TileState.LOADED &&
            !this.complete &&
            tile.state === Tile.State.LOADED &&
            tile.children &&
            !this.childrenCreated
        ) {
            for (i = 0; i < 4; i++) {
                if (!tile.children[i].extension[this.layer.extId])
                    tile.children[i].extension[this.layer.extId] = new OSData(
                        this.layer,
                        tile.children[i],
                        this
                    );
            }
            this.childrenCreated = true;

            // HACK : set renderable to have children
            var renderables = tile.extension.renderer
                ? tile.extension.renderer.renderables
                : [];
            for (i = 0; i < renderables.length; i++) {
                if (renderables[i].bucket.layer === this.layer)
                    renderables[i].hasChildren = true;
            }
        }
    };

    /**************************************************************************************************************/
    /**
     * Disposes renderable data from tile
     * @param renderContext
     * @param tilePool
     */
    OSData.prototype.dispose = function(renderContext, tilePool) {
        var i;
        if (this.parent && this.parent.childrenCreated) {
            this.parent.childrenCreated = false;
            // HACK : set renderable to not have children!
            var renderables = this.parent.tile.extension.renderer
                ? this.parent.tile.extension.renderer.renderables
                : [];
            for (i = 0; i < renderables.length; i++) {
                if (renderables[i].bucket.layer === this.layer)
                    renderables[i].hasChildren = false;
            }
        }

        for (i = 0; i < this.featureIds.length; i++) {
            this.layer.removeFeature(this.featureIds[i], this.tile);
        }
        this.tile = null;
        this.parent = null;
    };

    /**************************************************************************************************************/

    /**
     * Builds URL
     * @param tile
     * @return {*}
     */
    HipsCatLayer.prototype.buildUrl = function(tile) {
        var url;
        if (tile.order <= 0) {
            url = this.serviceUrl + "/Norder" + tile.order + "/Allsky.xml";
        } else {
            url = this.serviceUrl;

            url += "/Norder";
            url += tile.order;

            url += "/Dir";
            var indexDirectory = Math.floor(tile.pixelIndex / 10000) * 10000;
            url += indexDirectory;

            url += "/Npix";
            url += tile.pixelIndex;
            url += ".tsv";
        }
        return url;
    };

    /**
     * Get Tile URL.
     * @param tile
     * @returns {*}
     */
    HipsCatLayer.prototype.getUrl = function(tile) {
        return this.proxify(this.buildUrl(tile));
    };

    /**************************************************************************************************************/

    /**
     * Internal function to sort tiles
     * @param t1
     * @param t2
     * @return {number}
     * @private
     */
    function _sortTilesByDistance(t1, t2) {
        return t1.tile.distance - t2.tile.distance;
    }

    /**
     * Render function
     *
     * @param tiles The array of tiles to render
     */
    HipsCatLayer.prototype.render = function(tiles) {
        var i;
        if (!this.visible) return;

        // Sort tiles
        this.tilesToLoad.sort(_sortTilesByDistance);

        // Load data for the tiles if needed
        for (
            i = 0;
            i < this.tilesToLoad.length && this.freeRequests.length > 0;
            i++
        ) {
            var tile = this.tilesToLoad[i].tile;
            var url = this.buildUrl(tile);
            if (url) {
                this.launchRequest(tile, url);
            }
        }

        this.tilesToLoad.length = 0;
    };

    /*************************************************************************************************************/

    return HipsCatLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/GeoJsonLayer',[
    "../Utils/Utils",
    "./AbstractVectorLayer",
    "../Utils/Constants"
], function(Utils, AbstractVectorLayer, Constants) {
    /**
     * @name GeoJsonLayer
     * @class
     *    Create a layer to display vector data in GeoJSON format.
     * @augments AbstractVectorLayer
     * @param {AbstractLayer.geojson_configuration} options - GeoJsonLayer configuration
     * @constructor
     * @memberof module:Layer
     */
    var GeoJsonLayer = function(options) {
        AbstractVectorLayer.prototype.constructor.call(
            this,
            Constants.LAYER.GeoJSON,
            options
        );
        this.gid = 0;
    };

    /**
     * Check if the GeoJSon has a valid geometry attribute
     * @param {Object} feature - GeoJSON feature
     * @throws {RangeError} Invalid GeoJson
     * @private
     */
    function _checkValidGeoJson(feature) {
        var geometry = feature.geometry;
        if (!geometry || !geometry.type) {
            throw new RangeError("Invalid GeoJson", "GeoJsonLayer.js");
        }
    }

    /**
     * Set the global crs when the geometry has not crs.
     * If no globalCrs, then WGS84 is set
     * @param {Object} feature - GeoJSON feature
     * @param {Object} globalCrs - GeoJSON crs element
     * @returns {Object} the feature
     * @private
     */
    function _setCrs(feature, globalCrs) {
        if (!feature.geometry.crs) {
            feature.geometry.crs = globalCrs
                ? globalCrs
                : {
                      type: "name",
                      properties: {
                          name: Constants.CRS.WGS84
                      }
                  };
        }
        return feature;
    }

    /**
     * Sets an unique ID of the GeoJSON geometry
     * @param {Object} feature - GeoJSON feature
     * @returns {Object} GeoJSON feature
     * @private
     */
    function _setID(feature) {
        feature.geometry.gid = "GeoJSON_" + this.gid;
        this.gid++;
        return feature;
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractVectorLayer, GeoJsonLayer);

    /**************************************************************************************************************/

    /**
     * Adds a feature collection, in GeoJSON format
     * @function addFeatureCollection
     * @memberof GeoJsonLayer#
     * @param {GeoJSON} featureCollection Feature Collection
     * @throws {ReferenceError} Error, featureCollection is null
     */
    GeoJsonLayer.prototype.addFeatureCollection = function(featureCollection) {
        // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
        if (featureCollection == null) {
            throw new ReferenceError(
                "Error, featureCollection is null",
                "GeoJsonLayer.js"
            );
        }

        var defaultCrs = {
            type: "name",
            properties: {
                name: Constants.CRS.WGS84
            }
        };

        //check if crs is global at the featureCollection
        var crs = featureCollection.crs ? featureCollection.crs : defaultCrs;

        var features = featureCollection.features;
        if (features) {
            for (var i = 0; i < features.length; i++) {
                this.addFeature(features[i], crs);
            }
        }
    };

    /**
     * Set data type of the GeoJSON : Point or LineString
     * @param feature
     * @memberof GeoJsonLayer#
     * @private
     */
    GeoJsonLayer.prototype._setDataType = function(feature) {
        if (!this.datatype) {
            if (feature.geometry.type.startsWith(Constants.GEOMETRY.Point)) {
                this.dataType = Constants.GEOMETRY.Point;
            } else {
                this.dataType = Constants.GEOMETRY.LineString;
            }
        }
    };

    /**************************************************************************************************************/
    /**
     * Add a feature to the layer
     * @function addFeature
     * @memberof GeoJsonLayer.prototype
     * @param {GeoJSON} feature Feature
     */
    GeoJsonLayer.prototype.addFeature = function(feature, globalCrs) {
        //feature.properties.style = this.style;
        _checkValidGeoJson.call(this, feature);

        feature = _setCrs.call(this, feature, globalCrs);

        feature = _setID.call(this, feature);

        this._setDataType(feature);

        AbstractVectorLayer.prototype.addFeature.call(this, feature);
    };

    return GeoJsonLayer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name LayerFactory
 * @class
 * Factory to create a layer
 * @memberof module:Layer
 */
define('Layer/LayerFactory',[
    "jquery",
    "../Utils/Constants",
    "./WMSLayer",
    "./WMTSLayer",
    "./WCSElevationLayer",
    "./VectorLayer",
    "./AtmosphereLayer",
    "./BingLayer",
    "./GroundOverlayLayer",
    "./OSMLayer",
    "./TileWireframeLayer",
    "./CoordinateGridLayer",
    "./HipsFitsLayer",
    "./HipsGraphicLayer",
    "./MocLayer",
    "./OpenSearchLayer",
    "./WMSElevationLayer",
    "./HipsMetadata",
    "./HipsCatLayer",
    "./GeoJsonLayer",
    "./OpenSearch/OpenSearchRequestPool"
], function(
    $,
    Constants,
    WMSLayer,
    WMTSLayer,
    WCSElevationLayer,
    VectorLayer,
    AtmosphereLayer,
    BingLayer,
    GroundOverlayLayer,
    OSMLayer,
    TileWireframeLayer,
    CoordinateGridLayer,
    HipsFitsLayer,
    HipsGraphicLayer,
    MocLayer,
    OpenSearchLayer,
    WMSElevationLayer,
    HipsMetadata,
    HipsCatLayer,
    GeoJsonLayer,
    OpenSearchRequestPool
) {
    this.proxy = {
        url: null,
        use: false
    };

    this.openSearchRequestPool = new OpenSearchRequestPool();

    function createHips(hipsMetadata, options) {
        options.proxy = this.proxy;
        var hipsProperties;
        if (typeof hipsMetadata === "undefined") {
            hipsProperties = new HipsMetadata(options.baseUrl);
        } else if (hipsMetadata instanceof HipsMetadata) {
            hipsProperties = hipsMetadata;
        } else {
            hipsProperties = new HipsMetadata();
            hipsProperties.setMetadata(hipsMetadata);
        }

        var metadata = hipsProperties.getHipsMetadata();

        var formats = options.hasOwnProperty("hips_tile_format")
            ? options.hips_tile_format
            : metadata.hips_tile_format;
        var dataProducts = options.hasOwnProperty("dataproduct_type")
            ? options.dataproduct_type
            : metadata.dataproduct_type;

        var layer;

        switch (dataProducts) {
            case hipsProperties.DataProductType.catalog:
                layer = createHipsCats(metadata, options);
                break;
            case hipsProperties.DataProductType.cube:
                throw new RangeError(
                    "Hips : cannot handle cube dataproduct",
                    "LayerFactor.js"
                );
            case hipsProperties.DataProductType.image:
                options.category = options.hasOwnProperty("category")
                    ? options.category
                    : "Image";
                var hasPNG =
                    $.inArray(hipsProperties.HipsTileFormat.png, formats) !==
                    -1;
                var hasJPEG =
                    $.inArray(hipsProperties.HipsTileFormat.jpeg, formats) !==
                    -1;
                var hasFits =
                    $.inArray(hipsProperties.HipsTileFormat.fits, formats) !==
                    -1;
                if (options.format) {
                    switch (options.format) {
                        case hipsProperties.HipsTileFormat.png:
                            layer = createHipsGraphic(metadata, options);
                            break;
                        case "jpg":
                            layer = createHipsGraphic(metadata, options);
                            break;
                        case hipsProperties.HipsTileFormat.fits:
                            layer = createHipsFits(metadata, options);
                            break;
                        default:
                            // try to get one by default => try jpeg ... maybe I am lucky
                            layer = createHipsGraphic(metadata, options);
                    }
                } else {
                    if (hasPNG) {
                        options.format = hipsProperties.HipsTileFormat.png;
                        layer = createHipsGraphic(metadata, options);
                    } else if (hasJPEG) {
                        options.format = "jpg"; // the right extension should be "jpeg" but jpg is used
                        layer = createHipsGraphic(metadata, options);
                    } else if (hasFits) {
                        options.format = hipsProperties.HipsTileFormat.fits;
                        layer = createHipsFits(metadata, options);
                    } else {
                        // try to get one by default => it happens for old Hips version ... maybe I am lucky
                        options.format = "jpg";
                        layer = createHipsGraphic(metadata, options);
                    }
                }
                break;
            case hipsProperties.DataProductType.meta:
                throw new RangeError(
                    "Hips : cannot handle META dataproduct",
                    "LayerFactor.js"
                );
            default:
                throw new RangeError(
                    "Hips : Unknown dataproduct type",
                    "LayerFactor.js"
                );
        }
        //if(fileExists(options.baseUrl+"/Moc.fits") === 200) {
        //    options.serviceUrl = options.baseUrl+"/Moc.fits";
        //    layer.services.push(this.createMoc(options));
        //}
        return layer;
    }

    function createHipsFits(hipsMetadata, options) {
        options.proxy = this.proxy;
        return new HipsFitsLayer(hipsMetadata, options);
    }

    function createHipsGraphic(hipsMetadata, options) {
        options.proxy = this.proxy;
        return new HipsGraphicLayer(hipsMetadata, options);
    }

    function createHipsCats(hipsMetadata, options) {
        options.proxy = this.proxy;
        return new HipsCatLayer(hipsMetadata, options);
    }

    /**
         Create and get a MOC Layer
         @function createMoc
         @private
         @memberof LayerFactory.prototype
         @param options Configuration properties for the MOC layer. See {@link MocLayer} for properties
         @return {MocLayer} layer
         */
    function createMoc(options) {
        options.proxy = this.proxy;
        options.style.fill = true;
        options.style.fillColor[3] = 0.3; // make transparent
        var layer = new MocLayer(options);
        layer.dataType = "line";
        return layer;
    }

    /**
         Create and get an OpenSearch Layer
         @function createOpenSearch
         @private
         @memberof LayerFactory.prototype
         @param options Configuration properties for the OpenSearch layer. See {@link OpenSearchLayer} for properties
         @return {OpenSearchLayer} layer
         */
    function createOpenSearch(options) {
        options.proxy = this.proxy;
        options.openSearchRequestPool = this.openSearchRequestPool;
        var layer = new OpenSearchLayer(options);
        if (options.displayProperties) {
            layer.displayProperties = options.displayProperties;
        }
        layer.pickable = options.hasOwnProperty("pickable")
            ? options.pickable
            : true;
        return layer;
    }

    return {
        /**
         * Factory for Layer.
         * @param {Object} options - See the base properties {@link AbstractLayer.configuration} and specific properties for specific layers
         * @param {string} options.type - one of the following value {Constants.Layer}
         * @return {AbstractLayer} - Object to handle Layer
         * @alias module:Layer.LayerFactory.create
         * @throws RangeError - "Unable to create the layer"
         * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
         * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
         * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
         * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
         * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
         * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
         * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
         * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
         * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
         * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
         * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
         * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
         * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
         * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.AsynchroneWMSLayer AsynchroneWMSLayer} : A layer to draw images coming from the WMS server (asynchrone loading to manage GetCapabilities)
         * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
         * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
         */
        create: function(options) {
            var proxy = this.proxy;
            options.proxy = this.proxy;
            var layer;
            switch (options.type) {
                case Constants.LAYER.WMS:
                    layer = new WMSLayer(options);
                    break;
                case Constants.LAYER.WMTS:
                    layer = new WMTSLayer(options);
                    break;
                case Constants.LAYER.WMSElevation:
                    layer = new WMSElevationLayer(options);
                    break;
                case Constants.LAYER.WCSElevation:
                    layer = new WCSElevationLayer(options);
                    break;
                case Constants.LAYER.GeoJSON:
                    layer = new GeoJsonLayer(options);
                    layer.pickable = options.hasOwnProperty("pickable")
                        ? options.pickable
                        : true;
                    break;
                case Constants.LAYER.Vector:
                    layer = new VectorLayer(options);
                    layer.pickable = options.hasOwnProperty("pickable")
                        ? options.pickable
                        : true;
                    layer.deletable = options.hasOwnProperty("deletable")
                        ? options.deletable
                        : false;
                    break;
                case Constants.LAYER.Atmosphere:
                    layer = new AtmosphereLayer(options);
                    break;
                case Constants.LAYER.Bing:
                    layer = new BingLayer(options);
                    break;
                case Constants.LAYER.GroundOverlay:
                    layer = new GroundOverlayLayer(options);
                    break;
                case Constants.LAYER.OSM:
                    layer = new OSMLayer(options);
                    break;
                case Constants.LAYER.HipsGrid:
                case Constants.LAYER.TileWireframe:
                    layer = new TileWireframeLayer(options);
                    break;
                case Constants.LAYER.HipsCat:
                    layer = new HipsCatLayer(options.hipsMetadata, options);
                    break;
                case Constants.LAYER.CoordinateGrid:
                    layer = new CoordinateGridLayer(options);
                    break;
                case Constants.LAYER.Hips:
                    layer = createHips(options.hipsMetadata, options);
                    break;
                case Constants.LAYER.Moc:
                    layer = createMoc(options);
                    break;
                case Constants.LAYER.OpenSearch:
                    layer = createOpenSearch(options);
                    break;
                default:
                    throw new RangeError(
                        "Unable to create the layer " + options.type,
                        "LayerFactor.js"
                    );
            }
            return layer;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Image manager
 */
define('Services/FitsVisu',[
    "jquery",
    "../Utils/Constants",
    "../Renderer/FeatureStyle",
    "../Renderer/DynamicImage",
    "../Layer/FitsLoader",
    "fits"
], function($, Constants, FeatureStyle, DynamicImage, FitsLoader) {
    var mizarAPI;

    /**********************************************************************************************/

    /**
     *    Send XHR request for FITS file
     *    @param featureData Feature data(layer,feature)
     *    @param {String} url Url of fits file
     *    @param {Function} preprocessing function if needed
     *    @fires Service#image:downloaded
     */
    function computeFits(featureData, url, preprocessing) {
        // Store xhr on feature data object to cancel it if needed
        featureData.xhr = FitsLoader.loadFits(url, function(fits) {
            delete featureData.xhr;

            var fitsData = fits.getHDU().data;
            if (preprocessing) {
                preprocessing(featureData, fits);
            }

            handleFits(fitsData, featureData);
        });
        mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
    }

    /**********************************************************************************************/

    /**
     *    Send XHR request for quicklook file
     *    @param featureData Feature data(layer,feature)
     *    @param {String} url Url of quicklook file
     *    @fires Service#image:downloaded
     */
    function computeQuicklook(featureData, url) {
        handleQuicklook(featureData, url);
        mizarAPI.publish(Constants.EVENT_MSG.IMAGE_DOWNLOADED, featureData);
    }

    /**********************************************************************************************/

    /**
     * Handle fits data on the given feature
     * @param fitsData
     * @param featureData
     * @returns {Image} image
     */
    function handleFits(fitsData, featureData) {
        // Create new image coming from Fits
        var typedArray = new Float32Array(
            fitsData.view.buffer,
            fitsData.begin,
            fitsData.length / 4
        ); // with gl.FLOAT
        var gl = mizarAPI.getRenderContext().gl;
        var image = new DynamicImage(
            mizarAPI.getRenderContext(),
            typedArray,
            gl.LUMINANCE,
            gl.FLOAT,
            fitsData.width,
            fitsData.height
        );

        var feature = featureData.feature;
        var layer = featureData.layer;
        // Attach texture to style
        var targetStyle;
        if (feature.properties.style) {
            targetStyle = new FeatureStyle(feature.properties.style);
        } else {
            targetStyle = new FeatureStyle(layer.style);
        }
        targetStyle.fillTexture = image.texture;
        targetStyle.uniformValues = image;
        targetStyle.fill = true;
        layer.modifyFeatureStyle(feature, targetStyle);

        // Store image url for zScale processing
        if (feature.services) {
            image.url = mizarAPI._getUrl(feature.services.download.url);
        }

        return image;
    }

    /**
     * Handle quicklook data on the given feature
     * @param featureData
     * @returns {Image} image
     */
    function handleQuicklook(featureData, url) {
        var feature = featureData.feature;
        var layer = featureData.layer;

        if (layer.getType() === "OpenSearch") {
            layer.loadQuicklook(feature, url);
        }
    }

    /**********************************************************************************************/

    function parseFits(response) {
        return FitsLoader.parseFits(response);
    }

    /**********************************************************************************************/

    /**
     * Remove fits texture from feature
     * @param featureData
     */
    function removeFitsFromRenderer(featureData) {
        // Abort xhr if inprogress
        if (featureData.xhr) {
            featureData.xhr.abort();
            delete featureData.xhr;
        }

        var gl = mizarAPI.getRenderContext().gl;
        if (featureData.feature.properties.style.uniformValues) {
            featureData.feature.properties.style.uniformValues.dispose();
        }
        // TODO : style could still contain fillTextures, is it normal ?
        var texture = featureData.feature.properties.style.fillTexture;
        if (texture) {
            gl.deleteTexture(texture);
        }
        var targetStyle = new FeatureStyle(
            featureData.feature.properties.style
        );
        targetStyle.fillTexture = null;
        targetStyle.fill = false;

        // Remove rendering
        targetStyle.fillShader = {
            fragmentCode: null,
            updateUniforms: null
        };
        delete targetStyle.uniformValues;

        featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
    }

    /**********************************************************************************************/

    return {
        /**
         * Initialize ImageManagerCore
         * @param m
         * @param configuration
         *      <ul>
         *          <li>sitoolsBaseUrl : the base sitools url used as proxy here
         *      </ul>
         */
        init: function(m, configuration) {
            mizarAPI = m;
            sitoolsBaseUrl = configuration.sitoolsBaseUrl;
            // Enable float texture extension to have higher luminance range
            var ext = mizarAPI
                .getRenderContext()
                .gl.getExtension("OES_texture_float");
        },

        /**********************************************************************************************/

        /**
         * Hide image
         * @param {Feature} featureData
         */
        hideImage: function(featureData) {
            var style = new FeatureStyle(featureData.feature.properties.style);
            style.fill = false;
            featureData.layer.modifyFeatureStyle(featureData.feature, style);
        },

        /**********************************************************************************************/

        /**
         * Show image
         * @param {Feature} featureData
         */
        showImage: function(featureData) {
            // Attach texture to style
            var targetStyle = new FeatureStyle(
                featureData.feature.properties.style
            );
            targetStyle.fill = true;
            featureData.layer.modifyFeatureStyle(
                featureData.feature,
                targetStyle
            );
        },

        /**********************************************************************************************/

        /**
         * Remove image from renderer
         * @param {Feature} featureData
         * @fires Service#image:removed
         */
        removeImage: function(featureData) {
            // Publish event that the image of the given feature will be removed
            mizarAPI.publish(Constants.EVENT_MSG.IMAGE_REMOVED, featureData);
            if (featureData.isFits) {
                removeFitsFromRenderer(featureData);
                $("#quicklookFits").removeClass("selected");
            } else {
                if (featureData.layer.getType() === "OpenSearch") {
                    featureData.layer.removeQuicklook();
                } else {
                    var style = featureData.feature.properties.style;
                    style.fill = false;
                    style.fillTextureUrl = null;
                    featureData.layer.modifyFeatureStyle(
                        featureData.feature,
                        style
                    );
                }
                $("#quicklook").removeClass("selected");
                $("#quicklookWms").removeClass("selected");
            }
            mizarAPI.getActivatedContext().refresh();
        },

        /**********************************************************************************************/

        /**
         *    Start download of texture
         *    @param {Feature} featureData
         *    @fires Service#image:added
         */
        addImage: function(featureData) {
            var feature = featureData.feature;
            // Set fill to true while loading
            var style = new FeatureStyle(feature.properties.style);
            var url = null;
            style.fill = true;

            // Publish event that the image for the given feature will be loaded
            mizarAPI.publish(Constants.EVENT_MSG.IMAGE_ADDED, featureData);

            if (featureData.isFits) {
                url = mizarAPI._getUrl(feature.services.download.url);
                this.computeFits(featureData, url);
                $("#quicklookFits").addClass("selected");
            } else {
                style.fill = true;
                if (featureData.isWms) {
                    url = mizarAPI._getUrl(
                        feature.properties.services.browse.layer.getUrl()
                    );
                } else {
                    url = mizarAPI._getUrl(feature.properties.quicklook);
                }
                this.computeQuicklook(featureData, url);
                // For DEBUG : 'upload/ADP_WFI_30DOR_RGB_V1.0_degraded.jpg';
                if (featureData.isWms) {
                    $("#quicklookWms").addClass("selected");
                } else {
                    $("#quicklook").addClass("selected");
                }
            }
            featureData.layer.modifyFeatureStyle(feature, style);
            mizarAPI.getActivatedContext().refresh();
        },

        computeFits: computeFits,
        computeQuicklook: computeQuicklook,
        handleFits: handleFits,
        handleQuicklook: handleQuicklook,
        parseFits: parseFits
    };

    /**********************************************************************************************/
});

define('Services/FitsHips',['../Utils/Constants'], function(Constants) {
    var mizarAPI;   

    /**
     * Creates a fits layer
     * @param {Layer} layer
     * @fires Globe#backgroundLayer:changed
     */
    function _createFitsLayer(layer) {
        var isCreated;
        try {
            var selectedLayer = {
                name: layer.getName(),
                type: layer.getType(),
                format: "fits",
                hipsMetadata: layer.getHipsMetadata()
            };
            var fitsLayer = mizarAPI.LayerFactory.create(selectedLayer);
            fitsLayer.ID = layer.getID();
            if (layer.isBackground()) {
                mizarAPI
                    .getActivatedContext()
                    ._getGlobe()
                    .setBaseImagery(fitsLayer);
            } else {
                mizarAPI
                    .getActivatedContext()
                    ._getGlobe()
                    .addLayer(fitsLayer);
            }
            fitsLayer.setVisible(true);
            isCreated = true;
            mizarAPI
                .getActivatedContext()
                .publish(Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED, fitsLayer);
        } catch (e) {
            isCreated = false;
        }
        return isCreated;
    }

    function _removeFitsLayer(ID) {
        var isRemoved;
        var layer = mizarAPI.getActivatedContext().getLayerByID(ID);
        if (layer && layer.getFormat() !== "fits") {
            mizarAPI
                .getActivatedContext()
                ._getGlobe()
                .setBaseImagery(layer);
            isRemoved = true;
        } else {
            isRemoved = false;
        }
        return isRemoved;
    }

    return {
        init: function(m, options) {
            mizarAPI = m;
        },

        createFitsLayer: _createFitsLayer,
        removeFitsLayer: _removeFitsLayer
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Triangle Object use in Histogram classe
 */
define('Services/Triangle',[], function() {
    /**************************************************************************************************************/

    /**
     *    Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
     */
    function _sameSide(p1, p2, a, b) {
        var temp1 = [];
        var temp2 = [];
        var temp3 = [];
        var cp1 = [];
        var cp2 = [];
        vec3.cross(
            vec3.subtract(b, a, temp1),
            vec3.subtract(p1, a, temp2),
            cp1
        );
        vec3.cross(temp1, vec3.subtract(p2, a, temp3), cp2);
        return vec3.dot(cp1, cp2) >= 0;
    }

    /**************************************************************************************************************/

    /**
     *    Private function to check if point is inside the given triangle
     *    If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
     */
    function _pointInTriangle(p, a, b, c) {
        return (
            _sameSide(p, a, b, c) &&
            _sameSide(p, b, a, c) &&
            _sameSide(p, c, a, b)
        );
    }

    /**************************************************************************************************************/

    /**
     *    Isoscele triangle object for thresholds manipulation
     *
     *    @param a Pointer of threshold pointing on histogram
     *    @param b Isoscele point 1
     *    @param c Isoscele point 2
     */
    var Triangle = function(a, b, c) {
        this.initA = a.slice(0);
        this.initB = b.slice(0);
        this.initC = c.slice(0);

        this.a = a; // Pointer to histogram
        this.b = b; // Isoscele point 1
        this.c = c; // Isoscele point 2

        this.dragging = false;
        this.hover = false;
        this.halfWidth = Math.abs((c[0] - b[0]) / 2);
    };

    /**************************************************************************************************************/

    /**
     *    Reset to initial position
     */
    Triangle.prototype.reset = function() {
        this.a = this.initA.slice(0);
        this.b = this.initB.slice(0);
        this.c = this.initC.slice(0);
    };

    /**************************************************************************************************************/

    /**
     *    Test if triangle contains the given point
     *    @param {Array} p point
     */
    Triangle.prototype.contains = function(p) {
        return _pointInTriangle(p, this.a, this.b, this.c);
    };

    /**************************************************************************************************************/

    /**
     * Draw the triangle
     * @param ctx the context
     * @param options
     *      <ul>
     *          <li>draggingColor : color used when moving triangle</li>
     *          <li>noDraggingColor : color used when triangle do not move</li>
     */
    Triangle.prototype.draw = function(ctx, options) {
        if (!options) {
            options = {};
        }
        if (this.dragging) {
            ctx.fillStyle = options.draggingColor | "#FF0";
        } else {
            ctx.fillStyle = options.noDraggingColor | "#F00";
        }

        ctx.beginPath();
        ctx.moveTo(this.a[0], this.a[1]);
        ctx.lineTo(this.b[0], this.b[1]);
        ctx.lineTo(this.c[0], this.c[1]);
        ctx.closePath();
        ctx.fill();

        if (!this.dragging && this.hover) {
            ctx.strokeStyle = options.draggingColor | "#FF0";
            ctx.stroke();
        }
    };

    /**************************************************************************************************************/

    /**
     *    Modify triangle's position by the given "pointer" point
     *    (could be modified only by X-axis)
     *    @param {Array} point point
     */
    Triangle.prototype.modifyPosition = function(point) {
        this.a[0] = point[0];
        this.b[0] = point[0] - this.halfWidth;
        this.c[0] = point[0] + this.halfWidth;
    };

    /**************************************************************************************************************/

    return Triangle;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Histogram module : create histogram to the given image
 */
define('Services/HistogramCore',["./Triangle"], function(Triangle) {
    // Private variables
    var nbBins;
    var self;

    var canvas;
    var hist = [];
    var hmax; // histogram max to scale in image space

    // Origin histogram point
    var originX;
    var originY;
    var hwidth;
    var paddingBottom;
    var triangleHalfWidth;

    /**************************************************************************************************************/

    /**
     * Get mouse position on canvas
     * @param {HTMLElement} canvas
     * @param {Event} evt
     * @returns {{x: number, y: number}}
     */
    function _getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function _handleMouseDown(evt) {
        var mousePos = _getMousePos(canvas, evt);

        if (self.minThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.minThreshold.dragging = true;
            self.minThreshold.draw(self.ctx);
        }

        if (self.maxThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.maxThreshold.dragging = true;
            self.maxThreshold.draw(self.ctx);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseUp(evt) {
        self.minThreshold.dragging = false;
        self.maxThreshold.dragging = false;

        if (self.onUpdate) {
            var min = self.getHistValue(self.minThreshold.a);
            var max = self.getHistValue(self.maxThreshold.a);

            self.minThreshold.reset();
            self.maxThreshold.reset();

            self.onUpdate(min, max);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseMove(evt) {
        var mousePos = _getMousePos(canvas, evt);

        self.ctx.clearRect(0.0, originY, canvas.width, paddingBottom);

        self.minThreshold.hover = self.minThreshold.contains([
            mousePos.x,
            mousePos.y,
            0
        ]);

        self.maxThreshold.hover = self.maxThreshold.contains([
            mousePos.x,
            mousePos.y,
            0
        ]);

        // Draw threshold controls
        if (
            self.minThreshold.dragging &&
            mousePos.x >= self.minThreshold.initA[0] &&
            mousePos.x < self.maxThreshold.a[0]
        ) {
            self.minThreshold.modifyPosition([
                mousePos.x,
                self.minThreshold.a[1]
            ]);
        }

        if (
            self.maxThreshold.dragging &&
            mousePos.x <= self.maxThreshold.initA[0] &&
            mousePos.x > self.minThreshold.a[0]
        ) {
            self.maxThreshold.modifyPosition([
                mousePos.x,
                self.maxThreshold.a[1]
            ]);
        }
        self.drawThresholdControls();

        // Don't draw histogram values if the mouse is out of histogram canvas
        if (
            mousePos.y > canvas.height ||
            mousePos.y < 0.0 ||
            mousePos.x > originX + nbBins ||
            mousePos.x < originX
        ) {
            return;
        }

        // Draw the text indicating the histogram value on mouse position
        self.ctx.font = "8pt Calibri";
        self.ctx.fillStyle = "yellow";
        var thresholdValue = self.getHistValue([mousePos.x, mousePos.y]);
        self.ctx.fillText(
            thresholdValue,
            canvas.width / 2 - 15.0,
            originY + paddingBottom
        );
        // Draw a tiny line indicating the mouse position on X-axis
        self.ctx.fillRect(mousePos.x, originY, 1, 2);
    }

    /**************************************************************************************************************/

    /**
     * Get histogram value from the given X-position on canvas
     * @param {Array} position
     * @returns {number} value
     */
    function getHistValue(position) {
        return (
            Math.floor(
                (((position[0] - originX) / 256.0) *
                    (this.image.tmax - this.image.tmin) +
                    this.image.tmin) *
                    Math.pow(10, this.accuracy)
            ) / Math.pow(10, this.accuracy)
        );
    }

    /**************************************************************************************************************/

    /**
     * Init Thresholds by creating to
     */
    function initThresholds() {
        originY = canvas.height - paddingBottom;
        hwidth =
            nbBins + originX > canvas.width ? canvas.width : nbBins + originX;

        this.minThreshold = new Triangle(
            [originX, originY + 1, 0],
            [originX - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [originX + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );

        this.maxThreshold = new Triangle(
            [hwidth, originY + 1, 0],
            [hwidth - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [hwidth + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );
    }

    /**************************************************************************************************************/

    function drawThresholdControls() {
        this.minThreshold.draw(this.ctx, {});
        this.maxThreshold.draw(this.ctx, {});
    }

    /**************************************************************************************************************/

    /**
     * Draw histogram
     * @param {Object} options
     *        <ul>
     *            <li>color: inside graph color</li>
     *        </ul>
     *
     */
    function drawHistogram(options) {
        if (options == null) {
            options = {};
        }
        this.ctx.fillStyle = options.color || "blue";
        for (var i = 0; i < hist.length; i++) {
            // Scale to y-axis height
            var rectHeight = (hist[i] / hmax) * originY;
            this.ctx.fillRect(originX + i, originY, 1, -rectHeight);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw histogram axis
     */
    function drawAxes() {
        var leftY, rightX;
        leftY = 0;
        rightX = originX + hwidth;
        // Draw y axis.
        this.ctx.beginPath();
        this.ctx.moveTo(originX, leftY);
        this.ctx.lineTo(originX, originY);

        // Draw x axis.
        this.ctx.moveTo(originX, originY);
        this.ctx.lineTo(rightX, originY);

        // Define style and stroke lines.
        this.ctx.closePath();
        this.ctx.strokeStyle = "#fff";
        this.ctx.stroke();
    }

    /**************************************************************************************************************/

    /**
     *    Draw transfer function(linear, log, asin, sqrt, sqr)
     *    @param {Object} options
     *        <ul>
     *            <li>color: transfer stroke color</li>
     *        </ul>
     */
    function drawTransferFunction(options) {
        // Draw transfer functions
        // "Grey" colormap for now(luminance curve only)
        if (options == null) {
            options = {};
        }
        this.ctx.fillStyle = options.color || "red";
        for (var i = 0; i < nbBins; i++) {
            var value = i;
            var posX = originX + value;

            var scaledValue;
            switch (this.image.transferFn) {
                case "linear":
                    scaledValue = (value / nbBins) * originY;
                    break;
                case "log":
                    scaledValue =
                        (Math.log(value / 10.0 + 1) /
                            Math.log(nbBins / 10.0 + 1)) *
                        originY;
                    break;
                case "sqrt":
                    scaledValue =
                        (Math.sqrt(value / 10.0) / Math.sqrt(nbBins / 10.0)) *
                        originY;
                    break;
                case "sqr":
                    scaledValue =
                        (Math.pow(value, 2) / Math.pow(nbBins, 2)) * originY;
                    break;
                case "asin":
                    scaledValue =
                        (Math.log(value + Math.sqrt(Math.pow(value, 2) + 1.0)) /
                            Math.log(
                                nbBins + Math.sqrt(Math.pow(nbBins, 2) + 1.0)
                            )) *
                        originY;
                    break;
                default:
                    break;
            }

            if (!this.image.inverse) {
                scaledValue = originY - scaledValue;
            }
            this.ctx.fillRect(posX, scaledValue, 1, 1);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw the histogram in canvas
     */
    function draw() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.drawHistogram();
        this.drawTransferFunction();
        this.drawAxes();
        this.drawThresholdControls();
    }

    /**************************************************************************************************************/

    /**
     *    TODO : create different module
     *    Compute histogram values
     */
    function compute() {
        var image = this.image;
        // Initialize histogram
        hist = new Array(nbBins);
        for (var i = 0; i < hist.length; i++) {
            hist[i] = 0;
        }

        // Compute histogram
        hmax = Number.MIN_VALUE;
        for (i = 0; i < image.pixels.length; i++) {
            var val = image.pixels[i];

            // Skip NaN
            if (isNaN(val)) {
                continue;
            }
            // Take only values which belongs to the interval [tmin,tmax]
            if (val < image.tmin) {
                continue;
            }
            if (val >= image.tmax) {
                continue;
            }

            // Scale to [0,255]
            var bin = Math.floor(
                (nbBins * (val - image.tmin)) / (image.tmax - image.tmin)
            );
            hist[bin]++;

            // Compute histogram max value
            if (hist[bin] > hmax) {
                hmax = hist[bin];
            }
        }

        // Logarithmic scale for better layout
        for (i = 0; i < hist.length; i++) {
            hist[i] = Math.log(1 + hist[i]);
        }
        hmax = Math.log(1 + hmax);
    }

    /**************************************************************************************************************/

    /**
     *    Set image
     *    @param {Image} image
     */
    function setImage(image) {
        this.image = image;
    }

    function getCanvas() {
        return canvas;
    }

    /**************************************************************************************************************/

    return {
        /**
         *    Histogram contructor
         *    @param options Histogram options
         *        <ul>
         *            <li>canvas: The canvas context where to draw Histogram</li>
         *            <li>image: The image which is represented by current histogram(required)</li>
         *            <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
         *            <li>onUpdate: On update callback
         *            <li>accuracy: The accuracy of histogram(numbers after floating point)
         *            <li>paddingBottom: space at the bottom
         *            <li>triangleHalfWidth: half width of the triangle to draw
         *            <li>originX
         *        </ul>
         */
        init: function(options) {
            this.image = options.image;
            this.onUpdate = options.onUpdate;
            this.accuracy = options.accuracy || 6;

            self = this;
            nbBins = options.nbBins || 256;
            paddingBottom = options.paddingBottom || 15.0;
            originX = options.originX || 5.0;
            triangleHalfWidth = options.triangleHalfWidth || 5;

            // Init canvas
            canvas = document.getElementById(options.canvas);
            canvas.addEventListener("mousemove", _handleMouseMove);

            // Handle threshold controller selection
            canvas.addEventListener("mousedown", _handleMouseDown);

            // Update histogram on mouseup
            canvas.addEventListener("mouseup", _handleMouseUp);
            this.ctx = canvas.getContext("2d");

            this.initThresholds();
        },
        initThresholds: initThresholds,
        getHistValue: getHistValue,
        drawThresholdControls: drawThresholdControls,
        drawHistogram: drawHistogram,
        drawAxes: drawAxes,
        drawTransferFunction: drawTransferFunction,
        draw: draw,
        compute: compute,
        setImage: setImage,
        getCanvas: getCanvas
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    ImageProcessing module
 */
define('Services/ImageProcessingCore',["jquery", "../Renderer/FeatureStyle", "jquery.ui"], function(
    $,
    FeatureStyle
) {
    /**************************************************************************************************************/

    var feature;
    var layer;
    var disable;
    var unselect;
    var $dialog;
    var histogramElement;
    var cutOutElement;

    /**************************************************************************************************************/

    /**
     *    Toggle visibility of dialog
     */
    function toggle() {
        if ($dialog.dialog("isOpen")) {
            $dialog.dialog("close");
        } else {
            $dialog.dialog("open");
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove view
     */
    function remove() {
        if (unselect) {
            unselect();
        }

        if (disable) {
            disable();
        }

        if (histogramElement) {
            histogramElement.remove();
        }

        $dialog.remove();
    }

    /**************************************************************************************************************/

    /**
     *    Set data to process
     *
     *    @param selectedData Object containing feature and layer extracted by <PickingManager>
     */
    function setData(selectedData) {
        if (
            feature &&
            feature.properties.identifier ===
                selectedData.feature.properties.identifier
        ) {
            this.toggle();
        } else {
            if (!$dialog.dialog("isOpen")) {
                this.toggle();
            }
        }

        feature = selectedData.feature;
        layer = selectedData.layer;

        if (selectedData.feature.services) {
            cutOutElement.setUrl(selectedData.feature.services.download.url);
        } /** else {
                // TODO : disable cutOutElement if feature's url isn't defined
            }*/

        var image = selectedData.feature.properties.style.uniformValues;
        if (!image) {
            $dialog
                .find(".histogramContent")
                .children("div")
                .fadeOut(function() {
                    $(this)
                        .siblings("p")
                        .fadeIn();
                });
        } else {
            this.setImage(image);
        }
    }

    /**************************************************************************************************************/

    /**
     * Remove passed feature
     *
     * @param {Feature} data
     */
    function removeData(data) {
        if (
            feature &&
            data.feature.properties.identifier === feature.properties.identifier
        ) {
            if (this.isOpened()) {
                this.toggle();
            }
            $dialog
                .find(".histogramContent")
                .children("div")
                .fadeOut(function() {
                    $(this)
                        .siblings("p")
                        .fadeIn();
                });
            feature = null;
            layer = null;
        }
    }

    /**************************************************************************************************************/

    /**
     * Set image on the Histogram element
     *
     * @param image
     */
    function setImage(image) {
        histogramElement.setImage(image);
        if (image.url) {
            cutOutElement.setUrl(image.url);
        }

        $dialog
            .find(".histogramContent")
            .children("p")
            .fadeOut(function() {
                $(this)
                    .siblings("div")
                    .fadeIn();
            });
    }

    /**************************************************************************************************************/

    /**
     * Change shader callback
     *
     * @param contrast
     */
    function changeShaderCallback(contrast) {
        var targetStyle;
        if (contrast === "raw") {
            targetStyle = new FeatureStyle(feature.properties.style);
            targetStyle.fillShader = {
                fragmentCode: null,
                updateUniforms: null
            };
            layer.modifyFeatureStyle(feature, targetStyle);
        } else {
            targetStyle = new FeatureStyle(feature.properties.style);
            targetStyle.fillShader = {
                fragmentCode: this.image.fragmentCode,
                updateUniforms: this.image.updateUniforms
            };
            layer.modifyFeatureStyle(feature, targetStyle);
        }
    }

    /**************************************************************************************************************/

    /**
     * Check if ImageProcessing is opened
     */
    function isOpened() {
        return $dialog.dialog("isOpen");
    }

    /**************************************************************************************************************/

    return {
        /**
         *    Init ImageProcessingCore
         *
         *    @param options
         *        <ul>
         *            <li>feature: The feature to process
         *            <li>layer: The layer to which the feature belongs to
         *            <li>disable: Disable callback</li>
         *            <li>unselect: Unselect callback</li>
         *        </ul>
         *    @param {HTMLElement} $dl dialogElement
         *    @param {HTMLElement} $histoElmt histogramElement
         *    @param {HTMLElement} $cutOutElmt cutOutElement
         *
         */
        init: function(options, $dl, histoElmt, cutOutElmt) {
            if (options) {
                //this.id = options.id;
                feature = options.feature || null;
                layer = options.layer || null;

                // Callbacks
                disable = options.disable || null;
                unselect = options.unselect || null;
            }

            $dialog = $dl;
            histogramElement = histoElmt;
            cutOutElement = cutOutElmt;
        },

        setData: setData,
        setImage: setImage,
        toggle: toggle
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('Services/MeasureToolPlanetCore',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Layer/VectorLayer",
    "../Renderer/Ray",
    "../Utils/Numeric",
    "../Renderer/FeatureStyle",
    "../Renderer/glMatrix"
], function($, _, Constants, VectorLayer, Ray, Numeric, FeatureStyle) {
    var navigation, mizarAPI, onselect, measureLayer, self, dragging;

    /**********************************************************************************************/

    /**
     * Get first Geo pick point in terms of cursor position
     * @param event
     * @returns {Array} geoPickPoint geo position on the planet
     */
    function _handleMouseDown(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        navigation.stop();

        dragging = true;
        self.elevations = [];

        if (event.type.search("touch") >= 0) {
            self.pickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.pickPoint = [event.layerX, event.layerY];
        }
        var geo = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
        if (geo !== null) {
            self.geoPickPoint = geo;
        } else {
            return null;
        }
        return self.geoPickPoint;
    }

    /**
     * Close the measure with the last point
     * @param event
     */
    function _handleMouseUp(event) {
        event.preventDefault();

        // Compute geo radius
        var stopPickPoint;
        if (event.type.search("touch") >= 0) {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    event.changedTouches[0].clientX,
                    event.changedTouches[0].clientY
                );
        } else {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(event.layerX, event.layerY);
        }

        // No point found, picking was not on planet but sky
        if (!_.isEmpty(stopPickPoint)) {
            // Find angle between start and stop vectors which is in fact the radius
            var dotProduct = vec3.dot(
                vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
            var theta = Math.acos(dotProduct);
            self.geoDistance = Numeric.toDegree(theta);

            if (onselect) {
                onselect();
            }
        }
        navigation.start();
        dragging = false;
    }

    /**
     * Update drawing and label in terms of current point
     * @param event
     */
    function _handleMouseMove(event) {
        event.preventDefault();
        if (!self.activated || !dragging) {
            return;
        }
        if (event.type.search("touch") >= 0) {
            self.secondPickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.secondPickPoint = [event.layerX, event.layerY];
        }

        var geo = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(
                self.secondPickPoint[0],
                self.secondPickPoint[1]
            );
        if (geo !== null) {
            self.secondGeoPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    self.secondPickPoint[0],
                    self.secondPickPoint[1]
                );
        } else {
            return;
        }
        //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

        // Update radius
        self.distance = Math.sqrt(
            Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) +
                Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2)
        );
        var dotProduct;
        if (self.secondGeoPickPoint === undefined) {
            dotProduct = vec3.dot(
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.secondPickPoint)
                ),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
        } else {
            dotProduct = vec3.dot(
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)
                ),
                vec3.normalize(
                    mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)
                )
            );
        }
        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        updateMeasure();
    }

    /**********************************************************************************************/

    function rotateVector2D(vec, theta) {
        theta = Numeric.toRadian(theta);
        var cs = Math.cos(theta);
        var sn = Math.sin(theta);

        return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
    }

    function normalize2D(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
        dest[0] = vec[0] / length;
        dest[1] = vec[1] / length;
        return dest;
    }

    /**********************************************************************************************/

    /**
     * Computes the measure for the given pick point depending on the second point (used to draw)
     * @returns {Array} points to draw
     */
    function computeMeasure() {
        var geoDiff = [
            self.secondGeoPickPoint[0] - self.geoPickPoint[0],
            self.secondGeoPickPoint[1] - self.geoPickPoint[1],
            0
        ];
        var diff = vec3.create(geoDiff);
        var length = vec3.length(diff);
        vec3.normalize(diff);
        vec3.scale(diff, length * 0.001);

        // First arrow
        var arrow = rotateVector2D(diff, 30);
        var arrow2 = rotateVector2D(diff, -30);
        arrow = [
            self.geoPickPoint[0] + 10 * arrow[0],
            self.geoPickPoint[1] + 10 * arrow[1]
        ];
        arrow2 = [
            self.geoPickPoint[0] + 10 * arrow2[0],
            self.geoPickPoint[1] + 10 * arrow2[1]
        ];

        // Second arrow
        var diff2 = [-diff[0], -diff[1]];
        var arrow3 = rotateVector2D(diff2, 30);
        var arrow4 = rotateVector2D(diff2, -30);
        arrow3 = [
            self.secondGeoPickPoint[0] + 10 * arrow3[0],
            self.secondGeoPickPoint[1] + 10 * arrow3[1]
        ];
        arrow4 = [
            self.secondGeoPickPoint[0] + 10 * arrow4[0],
            self.secondGeoPickPoint[1] + 10 * arrow4[1]
        ];

        var points = [
            [arrow[0], arrow[1], null],
            [self.geoPickPoint[0], self.geoPickPoint[1], null],
            [arrow2[0], arrow2[1], null],
            [self.geoPickPoint[0], self.geoPickPoint[1], null],
            [self.secondGeoPickPoint[0], self.secondGeoPickPoint[1], null],
            [arrow3[0], arrow3[1], null],
            [self.secondGeoPickPoint[0], self.secondGeoPickPoint[1], null],
            [arrow4[0], arrow4[1], null]
        ];
        return points;
    }

    /**********************************************************************************************/

    function remove() {
        self.clear();
        mizarAPI.getPlanetContext().removeDraw(measureLayer);
    }

    function createGeoJsonMeasurement(coordinates) {
        return {
            geometry: {
                gid: "measureShape",
                coordinates: coordinates,
                type: Constants.GEOMETRY.LineString,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    fillColor: [1, 0, 0, 1],
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            },
            type: "Feature"
        };
    }

    function createGeoJsonLabel(geoCenter, distance) {
        return {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "measureShape",
                coordinates: geoCenter,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    label: distance + " km",
                    fillColor: [1, 1, 1, 1],
                    pointMaxSize: 600,
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            }
        };
    }

    /**
     *    Updates measure coordinates
     */
    function updateMeasure() {
        self.clear();

        // Create elevation
        var firstPoint = self.geoPickPoint;
        var secondPoint = self.secondGeoPickPoint;

        // Create measurement and  apply elevation to all point of displayed arrow
        var coordinates = self.computeMeasure();
        self.measureFeature = createGeoJsonMeasurement(coordinates);

        // Create measurement label
        var center = [
            (self.secondPickPoint[0] + self.pickPoint[0]) / 2,
            (self.secondPickPoint[1] + self.pickPoint[1]) / 2
        ];
        var geoCenter = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(center[0], center[1]);
        var distance = self.calculateDistanceElevation(
            self.geoPickPoint,
            self.secondGeoPickPoint
        );
        distance = Numeric.roundNumber(distance.toFixed(3), 2);
        self.measureLabel = createGeoJsonLabel(geoCenter, distance);

        // add measurement and label to the the GeoJson collection
        measureLayer.addFeature(self.measureFeature);
        measureLayer.addFeature(self.measureLabel);
    }

    /**************************************************************************************************************/

    /**
     *    Clear measureFeature and measureLabel
     */
    function clear() {
        if (self.measureFeature) {
            measureLayer.removeFeature(self.measureFeature);
        }
        if (self.measureLabel) {
            measureLayer.removeFeature(self.measureLabel);
        }
    }

    /**************************************************************************************************************/

    /**
     * Calculate intermediaries elevation points to increase drawing precision
     *
     * @param {Object} options
     *              <ul>
     *                  <li>nbPoints : number of intermediary points to compute</li>
     *              </ul>
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     * @return {Array} intermediatePoints
     */
    function calculateIntermediateElevationPoint(
        options,
        firstPoint,
        secondPoint
    ) {
        var nbPoints = options.nbPoints | 50;
        var deltaX = firstPoint[0] - secondPoint[0];
        var intervalX;
        if (deltaX > 180.0) {
            deltaX = 360.0 - deltaX;
            intervalX = -deltaX / nbPoints;
        } else if (deltaX < -180.0) {
            deltaX = 360.0 + deltaX;
            intervalX = deltaX / nbPoints;
        } else {
            intervalX = deltaX / nbPoints;
        }
        var intervalY = (firstPoint[1] - secondPoint[1]) / nbPoints;

        var intermediatePoints = [];
        intermediatePoints[0] = firstPoint;
        for (var i = 1; i < nbPoints; i++) {
            var x = intermediatePoints[i - 1][0] - intervalX;
            if (x > 180.0) {
                x = x - 360;
            } else if (x < -180.0) {
                x = x + 360;
            }
            var y = intermediatePoints[i - 1][1] - intervalY;
            intermediatePoints[i] = [x, y];
        }
        intermediatePoints[nbPoints] = secondPoint;
        return intermediatePoints;
    }

    /**
     * Calculate distance elevation from a point
     *
     * url calcul distance : http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     * @returns {number} distance elevation in kilometers
     */
    function calculateDistanceElevation(firstPoint, secondPoint) {
        var R = mizarAPI
            .getCrs()
            .getGeoide()
            .getRealPlanetRadius();
        var phi1 = Numeric.toRadian(firstPoint[1]);
        var phi2 = Numeric.toRadian(secondPoint[1]);
        var delta_phi = Numeric.toRadian(secondPoint[1] - firstPoint[1]);
        var delta_lambda = Numeric.toRadian(secondPoint[0] - firstPoint[0]);

        var a =
            Math.sin(delta_phi / 2) * Math.sin(delta_phi / 2) +
            Math.cos(phi1) *
                Math.cos(phi2) *
                Math.sin(delta_lambda / 2) *
                Math.sin(delta_lambda / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        var distance = R * c;

        return distance / 1000;
    }

    /**
     * Calculate distance and elevation for a given point and store it
     * @param {Array} firstPoint
     * @param {Array} secondPoint
     */
    function storeDistanceAndElevation(firstPoint, secondPoint) {
        var distance = self.calculateDistanceElevation(firstPoint, secondPoint);
        distance = Numeric.roundNumber(distance.toFixed(3), 2);

        var elevation = mizarAPI
            .getActivatedContext()
            .getElevation(secondPoint[0], secondPoint[1]);
        var scale = mizarAPI
            .getActivatedContext()
            .getBaseElevation()
            .getScale();
        elevation = Numeric.roundNumber(elevation / scale, 0);
        var pointElevation = [distance, elevation];

        self.elevations.push(pointElevation);
    }

    function updateContext(mizar) {
        mizarAPI = mizar;
        navigation = mizarAPI.getActivatedContext().getNavigation();
        dragging = false;

        // Layer containing measure feature
        if (!measureLayer) {
            measureLayer = new VectorLayer();
        }
        mizarAPI.getPlanetContext().addDraw(measureLayer);

        this.activated = false;
        this.renderContext = mizarAPI.getRenderContext();

        this.elevations = [];
        this.measureFeature = null;
    }

    return {
        init: function(options) {
            mizarAPI = options.mizar;
            navigation = mizarAPI.getActivatedContext().getNavigation();
            onselect = options.onselect;
            self = this;
            dragging = false;

            // Layer containing measure feature
            measureLayer = mizarAPI.LayerFactory.create({
                type: Constants.LAYER.Vector,
                visible: true
            });
            mizarAPI.getPlanetContext().addDraw(measureLayer);

            this.activated = false;
            this.renderContext = mizarAPI.getRenderContext();

            this.elevations = [];
            this.measureFeature = null;
        },
        _handleMouseDown: _handleMouseDown,
        _handleMouseUp: _handleMouseUp,
        _handleMouseMove: _handleMouseMove,
        clear: clear,
        remove: remove,
        updateContext: updateContext,
        calculateIntermediateElevationPoint: calculateIntermediateElevationPoint,
        calculateDistanceElevation: calculateDistanceElevation,
        computeMeasure: computeMeasure,
        storeDistanceAndElevation: storeDistanceAndElevation
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('Services/MeasureToolSkyCore',[
    "jquery",
    "underscore-min",
    "../Utils/Numeric",
    "../Utils/Constants",
    "../Layer/VectorLayer",
    "../Renderer/Ray",
    "../Renderer/FeatureStyle",
    "../Renderer/glMatrix"
], function($, _, Numeric, Constants, VectorLayer, Ray, FeatureStyle) {
    var mizarAPI, navigation, onselect, measureLayer, self, dragging;

    /**********************************************************************************************/

    /**
     * Get first Geo pick point in terms of cursor position
     * @param event
     * @returns {Array} geoPickPoint geo position on the planet
     */
    function _handleMouseDown(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        self.distance = 0;
        // Disable standard navigation events
        navigation.stop();

        dragging = true;
        self.elevations = [];

        if (event.type.search("touch") >= 0) {
            self.pickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.pickPoint = [event.layerX, event.layerY];
        }
        self.geoPickPoint = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
    }

    /**
     * Close the measure with the last point
     * @param event
     */
    function _handleMouseUp(event) {
        event.preventDefault();
        if (!self.activated) {
            return;
        }

        // Compute geo radius
        var stopPickPoint;
        if (event.type.search("touch") >= 0) {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(
                    event.changedTouches[0].clientX,
                    event.changedTouches[0].clientY
                );
        } else {
            stopPickPoint = mizarAPI
                .getActivatedContext()
                .getLonLatFromPixel(event.layerX, event.layerY);
        }

        // Find angle between start and stop vectors which is in fact the radius
        var dotProduct = vec3.dot(
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)),
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint))
        );
        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        if (onselect) {
            onselect();
        }

        // Enable standard navigation events
        navigation.start();
        dragging = false;
    }

    /**
     * Update drawing and label in terms of current point
     * @param event
     */
    function _handleMouseMove(event) {
        event.preventDefault();
        if (!self.activated || !dragging) {
            return;
        }
        if (event.type.search("touch") >= 0) {
            self.secondPickPoint = [
                event.changedTouches[0].clientX,
                event.changedTouches[0].clientY
            ];
        } else {
            self.secondPickPoint = [event.layerX, event.layerY];
        }

        self.secondGeoPickPoint = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(
                self.secondPickPoint[0],
                self.secondPickPoint[1]
            );

        //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

        // Update radius
        self.distance = Math.sqrt(
            Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) +
                Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2)
        );
        var dotProduct = vec3.dot(
            vec3.normalize(
                mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)
            ),
            vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint))
        );

        var theta = Math.acos(dotProduct);
        self.geoDistance = Numeric.toDegree(theta);

        self.updateMeasure();
    }

    /**************************************************************************************************************/

    /**
     * Transform coordinates to the right world space dimension
     * @param points
     * @returns {Array} points  points transformed
     */
    function computeIntersection(points) {
        var rc = self.renderContext;
        var tmpMat = mat4.create();

        // Computes eye in world space
        mat4.inverse(rc.viewMatrix, tmpMat);
        var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

        // Computes the inverse of view/proj matrix
        mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
        mat4.inverse(tmpMat);

        // Transforms the four corners of measured shape into world space
        // and then for each corner computes the intersection of ray starting from the eye to the sphere
        var worldCenter = [0, 0, 0];
        for (var i = 0; i < points.length; i++) {
            mat4.multiplyVec4(tmpMat, points[i]);
            vec3.scale(points[i], 1.0 / points[i][3]);
            vec3.subtract(points[i], eye, points[i]);
            vec3.normalize(points[i]);

            var ray = new Ray(eye, points[i]);
            var pos3d = ray.computePoint(
                ray.sphereIntersect(
                    worldCenter,
                    mizarAPI
                        .getCrs()
                        .getGeoide()
                        .getRadius()
                )
            );
            points[i] = mizarAPI.getCrs().getWorldFrom3D(pos3d);
        }

        return points;
    }

    /**********************************************************************************************/

    function rotateVector2D(vec, theta) {
        theta = (theta * Math.PI) / 180;
        var cs = Math.cos(theta);
        var sn = Math.sin(theta);

        return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
    }

    function normalize2D(vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
        dest[0] = vec[0] / length;
        dest[1] = vec[1] / length;
        return dest;
    }

    /**********************************************************************************************/

    /**
     * Computes the measure for the given pick point depending on the second point (used to draw)
     * @returns {Array} points to draw
     */
    function computeMeasure() {
        var rc = self.renderContext;
        // Scale to [-1,1]
        var widthScale = 2 / rc.canvas.width;
        var heightScale = 2 / rc.canvas.height;

        var diff = [
            self.secondPickPoint[0] - self.pickPoint[0],
            self.secondPickPoint[1] - self.pickPoint[1]
        ];
        normalize2D(diff);

        // First arrow
        var arrow = rotateVector2D(diff, 30);
        var arrow2 = rotateVector2D(diff, -30);
        arrow = [
            self.pickPoint[0] + 10 * arrow[0],
            self.pickPoint[1] + 10 * arrow[1]
        ];
        arrow2 = [
            self.pickPoint[0] + 10 * arrow2[0],
            self.pickPoint[1] + 10 * arrow2[1]
        ];

        var diff2 = [-diff[0], -diff[1]];
        var arrow3 = rotateVector2D(diff2, 30);
        var arrow4 = rotateVector2D(diff2, -30);
        arrow3 = [
            self.secondPickPoint[0] + 10 * arrow3[0],
            self.secondPickPoint[1] + 10 * arrow3[1]
        ];
        arrow4 = [
            self.secondPickPoint[0] + 10 * arrow4[0],
            self.secondPickPoint[1] + 10 * arrow4[1]
        ];

        var points = [
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow[0] * widthScale - 1,
                (rc.canvas.height - arrow[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow2[0] * widthScale - 1,
                (rc.canvas.height - arrow2[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.pickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.pickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow3[0] * widthScale - 1,
                (rc.canvas.height - arrow3[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ],
            [
                arrow4[0] * widthScale - 1,
                (rc.canvas.height - arrow4[1]) * heightScale - 1,
                1,
                1
            ],
            [
                self.secondPickPoint[0] * widthScale - 1,
                (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1,
                1,
                1
            ]
        ];

        this.computeIntersection(points);
        return points;
    }

    /**********************************************************************************************/

    /**
     *    Updates measure coordinates
     */
    function updateMeasure() {
        self.clear();

        var coordinates = self.computeMeasure();

        // Close the polygon
        coordinates.push(coordinates[0]);

        self.measureFeature = {
            geometry: {
                gid: "measureShape",
                coordinates: [coordinates],
                type: Constants.GEOMETRY.Polygon,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR,
                    fillColor: [1, 0, 0, 1]
                })
            },
            type: "Feature"
        };

        var center = [
            (self.secondPickPoint[0] + self.pickPoint[0]) / 2,
            (self.secondPickPoint[1] + self.pickPoint[1]) / 2
        ];
        var geoCenter = mizarAPI
            .getActivatedContext()
            .getLonLatFromPixel(center[0], center[1]);
        self.measureLabel = {
            geometry: {
                type: Constants.GEOMETRY.Point,
                gid: "measureShape",
                coordinates: geoCenter,
                crs: {
                    type: "name",
                    properties: {
                        name: mizarAPI.getCrs().getGeoideName()
                    }
                }
            },
            properties: {
                style: new FeatureStyle({
                    label: mizarAPI.getCrs().fromDegreesToDMS(self.geoDistance),
                    fillColor: [1, 1, 1, 1],
                    zIndex: Constants.DISPLAY.SERVICE_VECTOR
                })
            }
        };
        var msg =
            "Distance :" +
            self.geoDistance +
            " at " +
            coordinates[0][0] +
            "," +
            coordinates[0][1] +
            "," +
            coordinates[0][2];
        measureLayer.addFeature(self.measureFeature);
        measureLayer.addFeature(self.measureLabel);
    }

    /**************************************************************************************************************/

    /**
     *    Clear measureFeature and measureLabel
     */
    function clear() {
        if (self.measureFeature) {
            measureLayer.removeFeature(self.measureFeature);
        }
        if (self.measureLabel) {
            measureLayer.removeFeature(self.measureLabel);
        }
    }

    function remove() {
        self.clear();
        mizarAPI.getSkyContext().removeDraw(measureLayer);
    }

    return {
        init: function(options) {
            mizarAPI = options.mizar;
            navigation = mizarAPI.getActivatedContext().getNavigation();
            onselect = options.onselect;
            self = this;
            dragging = false;

            // Layer containing measure feature
            measureLayer = mizarAPI.LayerFactory.create({
                type: Constants.LAYER.Vector,
                visible: true
            });
            mizarAPI.getSkyContext().addDraw(measureLayer);

            this.activated = false;
            this.renderContext = mizarAPI.getRenderContext();

            // Measure attributes
            /*this.pickPoint; // Window pick point
                this.secondPickPoint; // Window second pick point
                this.geoPickPoint; // Pick point in geographic reference
                this.secondGeoPickPoint; // Pick point in geographic reference
                this.measureLabel;
                */
            this.elevations = [];
            this.measureFeature = null;
        },
        _handleMouseDown: _handleMouseDown,
        _handleMouseUp: _handleMouseUp,
        _handleMouseMove: _handleMouseMove,
        updateMeasure: updateMeasure,
        clear: clear,
        remove: remove,
        computeMeasure: computeMeasure,
        computeIntersection: computeIntersection
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    Moc base module
 */
define('Services/MocBase',[
    "jquery",
    "../Renderer/FeatureStyle",
    "../Layer/MocLayer",
    "../Utils/Constants",
    "../Utils/Numeric"
], function($, FeatureStyle, MocLayer, Constants, Numeric) {
    var mizarAPI;
    var coverageServiceUrl;

    /**************************************************************************************************************/

    /**
     *    Create moc sublayer
     *
     *    @param layer Parent layer
     */
    function createMocSublayer(layer, successCallback, errorCallback) {
        var ID;
        if (layer.getBaseUrl()) {
            ID = handleMocLayer(layer, layer.getBaseUrl());
            var mocLayer = mizarAPI.getLayerByID(ID);
            if (layer.skyFraction) {
                mocLayer.coverage =
                    Numeric.roundNumber(
                        parseFloat(layer.skyFraction) * 100,
                        2
                    ) + "%";
            } else {
                mocLayer.coverage = "Not available";
            }
            successCallback(mocLayer);
        } else {
            errorCallback(layer);
        }
        return ID;
    }

    /**************************************************************************************************************/

    /**
     *    Handle moc layer as a sublayer
     *
     *    @param layer Parent layer
     *    @param mocServiceUrl Url to moc service
     */
    function handleMocLayer(layer, mocServiceUrl) {
        var style;
        // checks if style is defined
        if (layer.getStyle()) {
            style = layer.getStyle();
            style.fill = true;
            if (style.hasOwnProperty("fillColor")) {
                // add transparency when fill color is defined
                style.fillColor[3] = 0.3;
            } else {
                // no predefined color, set one
                style.fillColor = [1.0, 0.0, 0.0, 0.3];
            }
        } else {
            // no style, create a new one.
            style = new FeatureStyle({
                rendererHint: "Basic",
                fill: true,
                fillColor: [1.0, 0.0, 0.0, 0.3]
            });
        }

        var ID = mizarAPI.addLayer({
            type: Constants.LAYER.Moc,
            baseUrl: mocServiceUrl,
            style: style,
            visible: false
        });
        return ID;
    }

    /**************************************************************************************************************/

    /**
     *    Search moc sublayer
     *    @return    Moc layer if found, null otherwise
     */
    function findMocSublayer(layerID) {
        return mizarAPI.getLayerByID(layerID);
    }

    /**************************************************************************************************************/

    /**
     *    Intersect layers
     */
    function intersectLayers(layersToIntersect) {
        // Construct url & layerNames
        var url = coverageServiceUrl;
        var layerNames = "";
        for (var i = 0; i < layersToIntersect.length; i++) {
            var layer = layersToIntersect[i];

            layerNames += layer.getName();
            url += layer.describeUrl;
            if (i !== layersToIntersect.length - 1) {
                url += ";";
                layerNames += " x ";
            }
        }

        // Create intersection MOC layer
        intersectionLayer = new MocLayer({
            name: "Intersection( " + layerNames + " )",
            serviceUrl: url + "&media=json",
            style: new FeatureStyle({
                rendererHint: "Basic",
                fill: true,
                fillColor: [1.0, 0.0, 0.0, 0.3]
            }),
            visible: false
        });
        mizarAPI.getSkyContext().globe.addLayer(intersectionLayer);

        intersectionLayer.describeUrl = url;

        return intersectionLayer;
    }

    /**************************************************************************************************************/

    return {
        init: function(m, options) {
            mizarAPI = m;
            //coverageServiceUrl = "TODO must use AbstractLayer to get info";//options.coverageService.baseUrl;
            //TODO must use AbstractLayer to get this information
        },
        createMocSublayer: createMocSublayer,
        findMocSublayer: findMocSublayer,
        //getSkyCoverage: getSkyCoverage,
        //requestSkyCoverage: requestSkyCoverage,
        intersectLayers: intersectLayers
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Mollweider viewer module : Sky representation in mollweide coordinate system
 */
define('Services/MollweideViewerCore',[
    "jquery",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function($, Numeric, Ray) {
    var mizarAPI;
    var mizarBaseUrl;
    var navigation;
    var halfPaddingX;
    var halfPaddingY;
    var halfHeight;
    var halfWidth;
    var tesselation;
    var center3d;
    var canvas;
    var context;
    var self;
    var imageObj;

    /**
     *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
     *  @param lat latitude
     *  @see https://en.wikipedia.org/wiki/Mollweide_projection
     *  @return theta
     */
    function _findTheta(lat) {
        // Avoid divide by zero
        if (Math.abs(lat) === Math.PI / 2) {
            return lat;
        }

        var epsilon = 0.001;
        var thetaN; // n
        var thetaN1; // n+1

        do {
            thetaN = thetaN1;
            if (!thetaN) {
                thetaN = lat;
            }
            var twoThetaN = 2 * thetaN;
            thetaN1 =
                twoThetaN / 2 -
                (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) /
                    (2 + 2 * Math.cos(twoThetaN));
        } while (Math.abs(thetaN1 - thetaN) >= epsilon);

        return thetaN1;
    }

    /**********************************************************************************************/

    /**
     *  Canvas 2D point
     *  @param {Object} options
     *      <ul>
     *          <li>options : x,y, color, size</li>
     */
    var Point = function(options) {
        this.x = options.x | 0;
        this.y = options.y | 0;
        this.color = options.color | "rgb(255,0,0)";
        this.size = options.size | 2;
        for (var x in options) {
            if (options.hasOwnProperty(x)) {
                this[x] = options[x];
            }
        }
    };

    /**********************************************************************************************/

    /**
     *  Compute mollweide position for given 3D position
     *  @param {Array} pos position
     *  @return {Array} x,y coordinates
     */
    function computeMollweidePosition(pos) {
        var coordinateSystem = mizarAPI.getCrs();
        var geoPos = coordinateSystem.getWorldFrom3D(pos);
        if (geoPos[0] > 180) geoPos[0] -= 360;
        //var geoPos = coordinateSystem.from3DToEquatorial(pos, null, false);
        //geoPos = coordinateSystem.convert(geoPos, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());
        //geoPos = coordinateSystem.fromEquatorialToGeo(geoPos, null, false);

        var lambda = (geoPos[0] * Math.PI) / 180; // longitude
        var theta0 = (geoPos[1] * Math.PI) / 180; // latitude

        var auxTheta = _findTheta(theta0);

        // Transfrom to Mollweide coordinate system
        var mollX =
            ((2 * Math.sqrt(2)) / Math.PI) * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        // Transform to image space
        //    2.8: max x value in Mollweide projection
        //    1.38: max y value in Mollweide projection
        var x = (-mollX * halfWidth) / 2.8 + halfWidth + halfPaddingX;
        var y = (-mollY * halfHeight) / 1.38 + halfHeight + halfPaddingY;

        return [x, y];
    }

    /**********************************************************************************************/

    /**
     *  Update navigation eye for the given mouse coordinates
     *  @param {Array} moll
     */
    function updateNavigation(moll) {
        // Transform to Mollweide space
        center3d.x = (-(moll[0] - halfWidth - halfPaddingX) * 2.8) / halfWidth;
        center3d.y =
            (-(moll[1] - halfHeight - halfPaddingY) * 1.38) / halfHeight;

        // Transform to geographic coordinate system
        // http://mathworld.wolfram.com/MollweideProjection.html
        var auxTheta = Math.asin(center3d.y / Math.sqrt(2));

        var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
        var lambda =
            (Math.PI * center3d.x) / (2 * Math.sqrt(2) * Math.cos(auxTheta));

        var geo = [(lambda * 180) / Math.PI, (phi * 180) / Math.PI];

        // Update navigation
        mizarAPI.getCrs().get3DFromWorld(geo, navigation.center3d);

        navigation.computeViewMatrix();
    }

    /**********************************************************************************************/

    /**
     *  Function updating the position of center of camera on mollweide element
     */
    function updateMollweideFov() {
        // Reinit canvas
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(imageObj, 0, 0);

        // Draw fov
        context.fillStyle = "rgb(255,0,0)";
        var stepX =
            mizarAPI.getRenderContext().canvas.clientWidth / (tesselation - 1);
        var stepY =
            mizarAPI.getRenderContext().canvas.clientHeight / (tesselation - 1);

        var ray;
        var pos3d;
        var mPos;
        for (var i = 0; i < tesselation; i++) {
            // Width
            for (var j = 0; j < tesselation; j++) {
                // Height
                ray = Ray.createFromPixel(
                    mizarAPI.getRenderContext(),
                    i * stepX,
                    j * stepY
                );
                pos3d = ray.computePoint(
                    ray.sphereIntersect(
                        [0, 0, 0],
                        mizarAPI
                            .getCrs()
                            .getGeoide()
                            .getRadius()
                    )
                );

                mPos = computeMollweidePosition(pos3d);

                // Draw on canvas 2d
                context.fillRect(mPos[0], mPos[1], 2, 2);
            }
        }

        // Draw center
        context.fillStyle = center3d.color;
        mPos = computeMollweidePosition(navigation.center3d);
        center3d.x = mPos[0] - center3d.size / 2;
        center3d.y = mPos[1] - center3d.size / 2;

        // Draw on canvas 2d
        context.fillRect(
            mPos[0] - center3d.size / 2,
            mPos[1] - center3d.size / 2,
            center3d.size,
            center3d.size
        );

        // Update fov degrees
        var fov = navigation.getFov();
        var fovx = Numeric.roundNumber(fov[0], 2);
        fovx = mizarAPI.getCrs().fromDegreesToDMS(fovx);
        var fovy = Numeric.roundNumber(fov[1], 2);
        fovy = mizarAPI.getCrs().fromDegreesToDMS(fovy);
        $("#fov").html("Fov : " + fovx + " x " + fovy);
    }

    function updateGalaxyProjection(ctx) {
        $(self.getImageObj()).attr(
            "src",
            mizarBaseUrl +
                "css/images/MollweideSky_" +
                ctx.getCoordinateSystem().getGeoideName() +
                ".png"
        );
    }

    /**********************************************************************************************/

    return {
        init: function(options) {
            mizarAPI = options.mizar;
            mizarBaseUrl = options.mizarBaseUrl;

            // Init options
            navigation = mizarAPI.getActivatedContext().getNavigation();
            halfPaddingX = 16;
            halfPaddingY = 8;

            // Grid background dimensions
            halfHeight = 50;
            halfWidth = 100;

            // Level of tesselation to represent fov
            tesselation = 9; // Must be >= 2

            // Center of fov
            center3d = new Point({
                size: 5,
                color: "rgb(255,255,0)"
            });

            // Init image background
            canvas = document.getElementById("mollweideCanvas");
            context = canvas.getContext("2d");
            self = this;

            imageObj = new Image();
            imageObj.onload = function() {
                context.drawImage(imageObj, 0, 0);
                updateMollweideFov(imageObj);
            };
        },
        getImageObj: function() {
            return imageObj;
        },
        _findTheta: _findTheta,
        computeMollweidePosition: computeMollweidePosition,
        updateNavigation: updateNavigation,
        updateMollweideFov: updateMollweideFov,
        updateGalaxyProjection: updateGalaxyProjection
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Services/PickingManagerCore',[
    "../Renderer/FeatureStyle",
    "../Layer/OpenSearchLayer",
    "../Utils/Utils",
    "../Utils/UtilsIntersection",
    "../Utils/Constants"
], function(
    FeatureStyle,
    OpenSearchLayer,
    Utils,
    UtilsIntersection,
    Constants
) {
    const DEFAULT_SIZE_MULTIPLICATOR = 1;

    var ctx;
    var globe;

    var pickableLayers = [];
    var selection = [];
    var stackSelectionIndex = -1;

    var selectedStyle = new FeatureStyle({
        strokeColor: [1.0, 0.0, 0.0, 1.0],
        fillColor: [1.0, 1.0, 0.0, 1.0],
        zIndex: Constants.DISPLAY.SELECTED_VECTOR
    });

    /**************************************************************************************************************/

    /**
     *    Add pickable layer to the pickableLayers list
     *    @function addPickableLayer
     *    @param {AbstractLayer} layer
     */
    function addPickableLayer(layer) {
        if (pickableLayers.indexOf(layer) === -1) {
            pickableLayers.push(layer);
        } else {
            console.log("WARN:" + layer.name + " has been already added");
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove pickable layers
     *    @param {AbstractLayer} layer
     */
    function removePickableLayer(layer) {
        for (var i = 0; i < pickableLayers.length; i++) {
            if (layer.id === pickableLayers[i].id) {
                pickableLayers.splice(i, 1);
            }
        }
    }

    /**************************************************************************************************************/

    /**
     * Get the list of pickable layers
     * @returns {Array} pickableLayers
     */
    function getPickableLayers() {
        return pickableLayers;
    }

    /**************************************************************************************************************/

    /**
     *    Revert style of selected feature
     */
    function blurSelectedFeature() {
        var selectedData = this.getSelection()[this.stackSelectionIndex];
        if (selectedData) {
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
                case Constants.GEOMETRY.LineString:
                case Constants.GEOMETRY.MultiLineString:
                case Constants.GEOMETRY.Polygon:
                case Constants.GEOMETRY.MultiPolygon:
                    style.strokeColor = selectedData.layer.getStyle().strokeColor;
                    break;
                case Constants.GEOMETRY.Point:
                    // Use stroke color while reverting
                    style.fillColor =
                        selectedData.feature.properties.style.strokeColor;
                    break;
                default:
                    break;
            }
            style.zIndex = selectedData.layer.getStyle().zIndex;
            if (typeof selectedData.layer.unhighlight !== "undefined") {
                //selectedData.layer.unhighlight(selectedData.feature,style);
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            } else {
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            }
        }
    }

    /**************************************************************************************************************/

    /**
     *    Apply selected style to the feature by the given index in selection array
     *
     *    @param index Index of feature in selection array
     *    @param options
     *        <li>isExclusive : Boolean indicating if the focus is exclusive</li>
     *        <li>color : Highlight color</li>
     */
    function focusFeatureByIndex(index, options) {
        if (options && options.isExclusive) {
            blurSelection();
        }

        // Update highlight color
        var strokeColor = options.color
            ? FeatureStyle.fromStringToColor(options.color)
            : this.selectedStyle.strokeColor;
        var fillColor = options.color
            ? FeatureStyle.fromStringToColor(options.color)
            : this.selectedStyle.fillColor;

        var selectedData = this.getSelection()[index];
        if (selectedData) {
            this.stackSelectionIndex = index;
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
                case Constants.GEOMETRY.LineString:
                case Constants.GEOMETRY.MultiLineString:
                case Constants.GEOMETRY.Polygon:
                case Constants.GEOMETRY.MultiPolygon:
                    style.strokeColor = strokeColor;
                    break;
                case Constants.GEOMETRY.Point:
                    style.fillColor = fillColor;
                    break;
                default:
                    break;
            }
            style.zIndex = this.selectedStyle.zIndex;
            if (typeof selectedData.layer.highlight !== "undefined") {
                //selectedData.layer.highlight(selectedData.feature,style);
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            } else {
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            }
        }
        globe.refresh();
    }

    /**************************************************************************************************************/

    /**
     * Get the current selection
     * @returns {Array}
     */
    function getSelection() {
        return selection;
    }

    /**************************************************************************************************************/

    /**
     *    Revert style of selection
     */
    function blurSelection() {
        for (var i = 0; i < this.getSelection().length; i++) {
            var selectedData = this.getSelection()[i];
            var style = new FeatureStyle(selectedData.feature.properties.style);
            switch (selectedData.feature.geometry.type) {
                case Constants.GEOMETRY.LineString:
                case Constants.GEOMETRY.MultiLineString:
                case Constants.GEOMETRY.Polygon:
                case Constants.GEOMETRY.MultiPolygon:
                    style.strokeColor = selectedData.layer.getStyle().strokeColor;
                    style.strokeWidth = 1;
                    break;
                case Constants.GEOMETRY.Point:
                    // Use stroke color while reverting
                    style.fillColor =
                        selectedData.feature.properties.style.strokeColor;
                    break;
                default:
                    break;
            }
            style.zIndex = selectedData.layer.getStyle().zIndex;

            if (selectedData.layer.getGlobe()) {
                // Layer is still attached to globe
                if (typeof selectedData.layer.unhighlight !== "undefined") {
                    //selectedData.layer.unhighlight(selectedData.feature,style);
                    selectedData.layer.modifyFeatureStyle(
                        selectedData.feature,
                        style
                    );
                } else {
                    selectedData.layer.modifyFeatureStyle(
                        selectedData.feature,
                        style
                    );
                }
            }
        }
    }

    /**************************************************************************************************************/

    /**
     *    Apply style to selection
     *    @param {Array} newSelection selection of data
     */
    function focusSelection(newSelection) {
        var style;
        var startTime;
        var endTime;
        var focusLayers = {};
        for (var i = 0; i < newSelection.length; i++) {
            var selectedData = newSelection[i];
            if (selectedData.feature.properties.style) {
                style = new FeatureStyle(selectedData.feature.properties.style);
            } else {
                style = new FeatureStyle(selectedData.layer.getStyle());
            }
            switch (selectedData.feature.geometry.type) {
                case Constants.GEOMETRY.LineString:
                case Constants.GEOMETRY.MultiLineString:
                case Constants.GEOMETRY.Polygon:
                case Constants.GEOMETRY.MultiPolygon:
                    style.strokeColor = this.selectedStyle.strokeColor;
                    style.strokeWidth = 3;
                    break;
                case Constants.GEOMETRY.Point:
                    style.fillColor = this.selectedStyle.fillColor;
                    break;
                default:
                    break;
            }
            style.zIndex = this.selectedStyle.zIndex;
            if (typeof selectedData.layer.highlight !== "undefined") {
                //selectedData.layer.highlight(selectedData.feature,style);
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            } else {
                selectedData.layer.modifyFeatureStyle(
                    selectedData.feature,
                    style
                );
            }
        }
        /*            for (var layerID in focusLayers) {
                currentLayer = focusLayers[layerID];
                currentLayer.layer.modifyFeatureStyles(
                    currentLayer.focusFeatures,
                    currentLayer.focusStyles
                );
            }
        */
    }

    /**************************************************************************************************************/

    /**
     *    Clear selection
     */
    function clearSelection() {
        this.blurSelection();
        this.setSelection([]);
    }

    /**************************************************************************************************************/

    /**
     * Check if a geometry crosses the date line
     * @param {Array} pickPoint
     * @param {Array}coords
     * @returns {Array} coords
     */
    function fixDateLine(pickPoint, coords) {
        var crossDateLine = false;
        var startLon = coords[0][0];
        for (var i = 1; i < coords.length && !crossDateLine; i++) {
            var deltaLon = Math.abs(coords[i][0] - startLon);
            if (deltaLon > 180) {
                // DateLine!
                crossDateLine = true;
            }
        }
        var n;
        if (crossDateLine) {
            var fixCoords = [];

            if (pickPoint[0] < 0.0) {
                // Ensure coordinates are always negative
                for (n = 0; n < coords.length; n++) {
                    if (coords[n][0] > 0) {
                        fixCoords[n] = [coords[n][0] - 360, coords[n][1]];
                    } else {
                        fixCoords[n] = [coords[n][0], coords[n][1]];
                    }
                }
            } else {
                // Ensure coordinates are always positive
                for (n = 0; n < coords.length; n++) {
                    if (coords[n][0] < 0) {
                        fixCoords[n] = [coords[n][0] + 360, coords[n][1]];
                    } else {
                        fixCoords[n] = [coords[n][0], coords[n][1]];
                    }
                }
            }

            return fixCoords;
        } else {
            return coords;
        }
    }

    /**************************************************************************************************************/

    /**
     * Picking test for feature depending on its geometry type
     * @param {Object} feature
     * @param {Array} pickPoint
     * @returns {Boolean} isPicked
     */
    function featureIsPicked(feature, pickPoint, pickingNoDEM, options) {
        var i, j, p;
        var feat, featNext, ring, isMobile;
        var sizeMultiplicator =
            options && options.sizeMultiplicator
                ? options.sizeMultiplicator
                : DEFAULT_SIZE_MULTIPLICATOR;
        switch (feature.geometry.type) {
            case Constants.GEOMETRY.LineString:
                for (i = 0; i < feature.geometry.coordinates.length - 1; i++) {
                    feat = feature.geometry.coordinates[i];
                    featNext = feature.geometry.coordinates[i + 1];
                    if (
                        UtilsIntersection.pointInLine(pickPoint, feat, featNext)
                    ) {
                        return true;
                    }
                }
                //var ring = this.fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);
                break;
            case Constants.GEOMETRY.MultiLineString:
                for (i = 0; i < feature.geometry.coordinates.length; i++) {
                    for (
                        j = 0;
                        j < feature.geometry.coordinates[i].length - 1;
                        j++
                    ) {
                        feat = feature.geometry.coordinates[i][j];
                        featNext = feature.geometry.coordinates[i][j + 1];
                        if (
                            UtilsIntersection.pointInLine(
                                pickPoint,
                                feat,
                                featNext
                            )
                        ) {
                            return true;
                        }
                    }
                }
                break;
            case Constants.GEOMETRY.Polygon:
                ring = this.fixDateLine(
                    pickPoint,
                    feature.geometry.coordinates[0]
                );
                return UtilsIntersection.pointInRing(pickPoint, ring);
            case Constants.GEOMETRY.MultiPolygon:
                for (p = 0; p < feature.geometry.coordinates.length; p++) {
                    ring = this.fixDateLine(
                        pickPoint,
                        feature.geometry.coordinates[p][0]
                    );
                    if (UtilsIntersection.pointInRing(pickPoint, ring)) {
                        return true;
                    }
                }
                return false;
            case Constants.GEOMETRY.Point:
                var point = feature.geometry.coordinates;
                // Do not pick the labeled features
                var isLabel =
                    feature &&
                    feature.properties &&
                    feature.properties.style &&
                    feature.properties.style.label;
                var pt = [pickPoint[0], pickPoint[1], pickPoint[2]];
                if (pickingNoDEM === true) {
                    pt[2] = 0;
                }
                return (
                    UtilsIntersection.pointInSphere(
                        ctx,
                        pt,
                        point,
                        feature.geometry._bucket.textureHeight *
                            sizeMultiplicator
                    ) && !isLabel
                );
            default:
                console.log(
                    "WARN: Picking for " + feature.geometry.type + " is not yet"
                );
                return false;
        }
    }

    /**************************************************************************************************************/

    function computeFilterPickSelection(pickPoint, options) {
        var selection = this.computePickSelection(pickPoint, options);
        var returnedSelection = [];
        for (var i = 0; i < selection.length; i++) {
            returnedSelection.push(selection[i]);
        }
        return returnedSelection;
    }

    /**
     * Compute the selection at the picking point
     * @param {Array} pickPoint
     * @return {Array} newSelection
     */
    function computePickSelection(pickPoint, options) {
        if (!pickPoint) {
            return [];
        }
        var i, j, feature;
        var newSelection = [];
        for (i = 0; i < this.getPickableLayers().length; i++) {
            var selectedTile = globe.tileManager.getVisibleTile(
                pickPoint[0],
                pickPoint[1]
            );
            var pickableLayer = this.getPickableLayers()[i];
            if (pickableLayer.isVisible() && pickableLayer.globe === globe) {
                if (pickableLayer instanceof OpenSearchLayer) {
                    // Extension using layer
                    // Search for features in each tile
                    var tile = selectedTile;

                    if (tile === null || typeof tile === "undefined") {
                        console.error("no tile found");
                        continue;
                    }
                    var tileData = tile.extension.renderer;
                    //[pickableLayer.extId];
                    /*if (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED) {
                            while (tile.parent && (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED)) {
                                tile = tile.parent;
                                tileData = tile.extension[pickableLayer.extId];
                            }
                        }*/
                    if (tileData) {
                        //for (j = 0; j < tileData.featureIds.length; j++) {
                        for (j = 0; j < pickableLayer.features.length; j++) {
                            //feature = pickableLayer.features[pickableLayer.featuresSet[tileData.featureIds[j]].index];
                            feature = pickableLayer.features[j];
                            if (
                                this.featureIsPicked(
                                    feature,
                                    pickPoint,
                                    pickableLayer.pickingNoDEM,
                                    options
                                )
                            ) {
                                newSelection.push({
                                    feature: feature,
                                    layer: pickableLayer
                                });
                            }
                        }
                    }
                } else {
                    // Vector layer
                    // Search for picked features
                    for (j = 0; j < pickableLayer.features.length; j++) {
                        feature = pickableLayer.features[j];
                        if (
                            this.featureIsPicked(
                                feature,
                                pickPoint,
                                pickableLayer.pickingNoDEM,
                                options
                            )
                        ) {
                            newSelection.push({
                                feature: feature,
                                layer: pickableLayer
                            });
                        }
                    }
                }
            }

            // Add selected tile to selection to be able to make the requests by tile
            // (actually used for asteroids search)
            newSelection.selectedTile = selectedTile;
        }

        return newSelection;
    }

    /**************************************************************************************************************/

    /**
     * Set selection list with passed selection
     * @param {Array} sel selection
     */
    function setSelection(sel) {
        selection = sel;
        return selection;
    }

    /**************************************************************************************************************/

    /**
     *    Highlight the given feature
     *
     *    @param featureData
     *        Feature data is an object composed by feature and its layer
     *    @param options
     *        Focus feature options(isExclusive and color)
     *
     *    // TODO : maybe it's more intelligent to store layer reference on feature ?
     */
    function highlightObservation(featureData, options) {
        selection.push(featureData);
        focusFeatureByIndex(selection - 1, options);
    }

    function updateContext(context) {
        ctx = context;
        globe = context.globe;
    }

    /**************************************************************************************************************/

    return {
        selectedStyle: selectedStyle,
        stackSelectionIndex: stackSelectionIndex,
        init: function(context) {
            ctx = context;
            globe = context.globe;
        },
        addPickableLayer: addPickableLayer,
        removePickableLayer: removePickableLayer,
        getPickableLayers: getPickableLayers,
        blurSelectedFeature: blurSelectedFeature,
        focusFeatureByIndex: focusFeatureByIndex,
        getSelection: getSelection,
        blurSelection: blurSelection,
        focusSelection: focusSelection,
        clearSelection: clearSelection,
        fixDateLine: fixDateLine,
        featureIsPicked: featureIsPicked,
        computePickSelection: computePickSelection,
        computeFilterPickSelection: computeFilterPickSelection,
        setSelection: setSelection,
        highlightObservation: highlightObservation,
        updateContext: updateContext
    };
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

/**
 *    JSON processor module
 *
 *    Module processing feature collection
 *
 */
define('Parser/JsonProcessor',[
    "../Layer/HipsGraphicLayer",
    "../Utils/Constants",
    "../Crs/CoordinateSystemFactory"
], function(HipsLayer, Constants, CoordinateSystemFactory) {
    var gid = 0;

    /**
     *    Handle services of feature
     */
    function handleServices(gwLayer, feature) {
        for (var x in feature.services) {
            var service = feature.services[x];
            if (!gwLayer.subLayers) {
                gwLayer.subLayers = [];
            }
            switch (service.type) {
                case Constants.LAYER.Hips:
                    service.layer = new HipsLayer({
                        format: service.format,
                        baseUrl: service.url,
                        name: service.name,
                        visible: false,
                        coordinates: feature.geometry.coordinates[0]
                    });
                    gwLayer.subLayers.push(service.layer);
                    if (gwLayer.planet && gwLayer.visible()) {
                        // Add sublayer to engine
                        gwLayer.planet.addLayer(service.layer);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    return {
        /**
         *    Handles feature collection
         *    Recompute geometry from equatorial coordinates to geo for each feature
         *    Handle feature services
         *    Add gid
         *
         *    @param gwLayer Layer of feature
         *    @param featureCollection GeoJSON FeatureCollection
         *
         */
        handleFeatureCollection: function(gwLayer, featureCollection) {
            // Default CRS according to GeoJSON specification
            var defaultCrs = {
                type: "name",
                properties: {
                    name: Constants.CRS.WGS84
                }
            };

            if (featureCollection === null || featureCollection === undefined) {
                throw new ReferenceError(
                    "Error, featureCollection is null",
                    "JsonProcessor.js"
                );
            }

            //check if crs is global at the featureCollection
            var crs = featureCollection.crs
                ? featureCollection.crs
                : defaultCrs;

            gwLayer.coordinateSystem = CoordinateSystemFactory.create({
                geoideName: crs.properties.name
            });

            var features = featureCollection.features;
            if (features === null || features === undefined) {
                console.error(
                    "Error, no feature in featureCollection : ",
                    featureCollection
                );
                return;
            }
            var i, j, r;

            for (i = 0; i < features.length; i++) {
                var currentFeature = features[i];

                switch (currentFeature.geometry.type) {
                    case Constants.GEOMETRY.Point:
                        if (!gwLayer.dataType) {
                            gwLayer.dataType = "point";
                        } else {
                            if (gwLayer.dataType !== "point") {
                                gwLayer.dataType = "none";
                            }
                        }
                        break;
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:
                        if (!gwLayer.dataType) {
                            gwLayer.dataType = "line";
                        } else {
                            if (gwLayer.dataType !== "line") {
                                gwLayer.dataType = "none";
                            }
                        }

                        if (currentFeature.properties._imageCoordinates) {
                            // Set _imageCoordinates as geometry's property (may be modified later)
                            currentFeature.geometry._imageCoordinates =
                                currentFeature.properties._imageCoordinates;
                        }

                        break;
                    default:
                        break;
                }
                if (!currentFeature.geometry.crs) {
                    currentFeature.geometry.crs = crs;
                }
                currentFeature.geometry.gid = "jsonProc_" + gid;
                gid++;

                if (currentFeature.services) {
                    handleServices(gwLayer, currentFeature);
                }
            }
        }
    };
});

// samp
// ----
// Provides capabilities for using the SAMP Web Profile from JavaScript.
// Exported tokens are in the samp.* namespace.
// Inline documentation is somewhat patchy (partly because I don't know
// what javascript documentation is supposed to look like) - it is
// suggested to use it conjunction with the provided examples,
// currently visible at http://astrojs.github.com/sampjs/
// (gh-pages branch of github sources).

var samp = (function() {

    // Constants defining well-known location of SAMP Web Profile hub etc.
    var WEBSAMP_PORT = 21012;
    var WEBSAMP_PATH = "/";
    var WEBSAMP_PREFIX = "samp.webhub.";
    var WEBSAMP_CLIENT_PREFIX = "";

    // Tokens representing permissible types in a SAMP object (e.g. a message)
    TYPE_STRING = "string";
    TYPE_LIST = "list";
    TYPE_MAP = "map";

    var heir = function(proto) {
        function F() {};
        F.prototype = proto;
        return new F();
    };

    // Utility functions for navigating DOM etc.
    // -----------------------------------------

    var getSampType = function(obj) {
        if (typeof obj === "string") {
            return TYPE_STRING;
        }
        else if (obj instanceof Array) {
            return TYPE_LIST;
        }
        else if (obj instanceof Object && obj !== null) {
            return TYPE_MAP;
        }
        else {
            throw new Error("Not legal SAMP object type: " + obj);
        }
    };
    var getChildElements = function(el, childTagName) {
        var children = el.childNodes;
        var child;
        var childEls = [];
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (child.nodeType === 1) {  // Element
                if (childTagName && (child.tagName !== childTagName)) {
                    throw new Error("Child <" + children[i].tagName + ">"
                                  + " of <" + el.tagName + ">"
                                  + " is not a <" + childTagName + ">");
                }
                childEls.push(child);
            }
        }
        return childEls;
    };
    var getSoleChild = function(el, childTagName) {
        var children = getChildElements(el, childTagName);
        if (children.length === 1 ) {
            return children[0];
        }
        else {
            throw new Error("No sole child of <" + el.tagName + ">");
        }
    };
    var getTextContent = function(el) {
        var txt = "";
        var i;
        var child;
        for (i = 0; i < el.childNodes.length; i++ ) {
            child = el.childNodes[i];
            if (child.nodeType === 1) {           // Element 
                throw new Error("Element found in text content");
            }
            else if (child.nodeType === 3 ||      // Text
                     child.nodeType === 4 ) {     // CDATASection
                txt += child.nodeValue;
            }
        }
        return txt;
    };
    var stringify = function(obj) {
        return typeof JSON === "undefined" ? "..." : JSON.stringify(obj);
    };

    // XmlRpc class:
    // Utilities for packing and unpacking XML-RPC messages.
    // See xml-rpc.com.

    var XmlRpc = {};

    // Takes text and turns it into something suitable for use as the content
    // of an XML-RPC string - special characters are escaped.
    XmlRpc.escapeXml = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
    };

    // Asserts that the elements of paramList match the types given by typeList.
    // TypeList must be an array containing only TYPE_STRING, TYPE_LIST
    // and TYPE_MAP objects in some combination.  paramList must be the
    // same length.
    // In case of mismatch an error is thrown.
    XmlRpc.checkParams = function(paramList, typeList) {
        var i;
        for (i = 0; i < typeList.length; i++) {
            if (typeList[i] !== TYPE_STRING &&
                typeList[i] !== TYPE_LIST &&
                typeList[i] !== TYPE_MAP) {
                throw new Error("Unknown type " + typeList[i]
                              + " in check list");
            }
        }
        var npar = paramList.length;
        var actualTypeList = [];
        var ok = true;
        for (i = 0; i < npar; i++) {
            actualTypeList.push(getSampType(paramList[i]));
        }
        ok = ok && (typeList.length === npar);
        for (i = 0; ok && i < npar; i++ ) {
            ok = ok && typeList[i] === actualTypeList[i];
        }
        if (!ok) {
            throw new Error("Param type list mismatch: " 
                          + "[" + typeList + "] != "
                          + "[" + actualTypeList + "]");
        }
    };

    // Turns a SAMP object (structure of strings, lists, maps) into an
    // XML string suitable for use with XML-RPC.
    XmlRpc.valueToXml = function v2x(obj, prefix) {
        prefix = prefix || "";
        var a;
        var i;
        var result;
        var type = getSampType(obj);
        if (type === TYPE_STRING) {
            return prefix
                 + "<value><string>"
                 + XmlRpc.escapeXml(obj)
                 + "</string></value>";
        }
        else if (type === TYPE_LIST) {
            result = [];
            result.push(prefix + "<value>",
                        prefix + "  <array>",
                        prefix + "    <data>");
            for (i = 0; i < obj.length; i++) {
                result.push(v2x(obj[i], prefix + "      "));
            }
            result.push(prefix + "    </data>",
                        prefix + "  </array>",
                        prefix + "</value>");
          
            return result.join("\n");
        }
        else if (type === TYPE_MAP) {
            result = [];
            result.push(prefix + "<value>");
            result.push(prefix + "  <struct>");
            for (i in obj) {
                result.push(prefix + "    <member>");
                result.push(prefix + "      <name>"
                          + XmlRpc.escapeXml(i)
                          + "</name>");
                result.push(v2x(obj[i], prefix + "      "));
                result.push(prefix + "    </member>");
            }
            result.push(prefix + "  </struct>");
            result.push(prefix + "</value>");
            return result.join("\n");
        }
        else {
            throw new Error("bad type");  // shouldn't get here
        }
    };

    // Turns an XML string from and XML-RPC message into a SAMP object
    // (structure of strings, lists, maps).
    XmlRpc.xmlToValue = function x2v(valueEl, allowInt) {
        var childEls = getChildElements(valueEl);
        var i;
        var j;
        var txt;
        var node;
        var childEl;
        var elName;
        if (childEls.length === 0) {
            return getTextContent(valueEl);
        }
        else if (childEls.length === 1) {
            childEl = childEls[0];
            elName = childEl.tagName;
            if (elName === "string") {
                return getTextContent(childEl);
            }
            else if (elName === "array") {
                var valueEls =
                    getChildElements(getSoleChild(childEl, "data"), "value");
                var list = [];
                for (i = 0; i < valueEls.length; i++) {
                    list.push(x2v(valueEls[i], allowInt));
                }
                return list;
            }
            else if (elName === "struct") {
                var memberEls = getChildElements(childEl, "member");
                var map = {};
                var s_name;
                var s_value;
                var jc;
                for (i = 0; i < memberEls.length; i++) {
                    s_name = undefined;
                    s_value = undefined;
                    for (j = 0; j < memberEls[i].childNodes.length; j++) {
                        jc = memberEls[i].childNodes[j];
                        if (jc.nodeType == 1) {
                            if (jc.tagName === "name") {
                                s_name = getTextContent(jc);
                            }
                            else if (jc.tagName === "value") {
                                s_value = x2v(jc, allowInt);
                            }
                        }
                    }
                    if (s_name !== undefined && s_value !== undefined) {
                        map[s_name] = s_value;
                    }
                    else {
                        throw new Error("No <name> and/or <value> "
                                      + "in <member>?");
                    }
                }
                return map;
            }
            else if (allowInt && (elName === "int" || elName === "i4")) {
                return getTextContent(childEl);
            }
            else {
                throw new Error("Non SAMP-friendly value content: "
                              + "<" + elName + ">");
            }
        }
        else {
            throw new Error("Bad XML-RPC <value> content - multiple elements");
        }
    };

    // Turns the content of an XML-RPC <params> element into an array of
    // SAMP objects.
    XmlRpc.decodeParams = function(paramsEl) {
        var paramEls = getChildElements(paramsEl, "param");
        var i;
        var results = [];
        for (i = 0; i < paramEls.length; i++) {
            results.push(XmlRpc.xmlToValue(getSoleChild(paramEls[i], "value")));
        }
        return results;
    };

    // Turns the content of an XML-RPC <fault> element into an XmlRpc.Fault
    // object.
    XmlRpc.decodeFault = function(faultEl) {
        var faultObj = XmlRpc.xmlToValue(getSoleChild(faultEl, "value"), true);
        return new XmlRpc.Fault(faultObj.faultString, faultObj.faultCode);
    };

    // Turns an XML-RPC response element (should be <methodResponse>) into
    // either a SAMP response object or an XmlRpc.Fault object.
    // Note that a fault response does not throw an error, so check for
    // the type of the result if you want to know whether a fault occurred.
    // An error will however be thrown if the supplied XML does not
    // correspond to a legal XML-RPC response.
    XmlRpc.decodeResponse = function(xml) {
        var mrEl = xml.documentElement;
        if (mrEl.tagName !== "methodResponse") {
            throw new Error("Response element is not <methodResponse>");
        }
        var contentEl = getSoleChild(mrEl);
        if (contentEl.tagName === "fault") {
            return XmlRpc.decodeFault(contentEl);
        }
        else if (contentEl.tagName === "params") {
            return XmlRpc.decodeParams(contentEl)[0];
        }
        else {
            throw new Error("Bad XML-RPC response - unknown element"
                          + " <" + contentEl.tagName + ">");
        }
    };

    // XmlRpc.Fault class:
    // Represents an XML-RPC Fault response.
    XmlRpc.Fault = function(faultString, faultCode) {
        this.faultString = faultString;
        this.faultCode = faultCode;
    };
    XmlRpc.Fault.prototype.toString = function() {
        return "XML-RPC Fault (" + this.faultCode + "): " + this.faultString;
    };

    // XmlRpcRequest class:
    // Represents an call which can be sent to an XML-RPC server.
    var XmlRpcRequest = function(methodName, params) {
        this.methodName = methodName;
        this.params = params || [];
    }
    XmlRpcRequest.prototype.toString = function() {
        return this.methodName + "(" + stringify(this.params) + ")";
    };
    XmlRpcRequest.prototype.addParam = function(param) {
        this.params.push(param);
        return this;
    };
    XmlRpcRequest.prototype.addParams = function(params) {
        var i;
        for (i = 0; i < params.length; i++) {
            this.params.push(params[i]);
        }
        return this;
    };
    XmlRpcRequest.prototype.checkParams = function(typeList) {
        XmlRpc.checkParams(this.params, typeList);
    };
    XmlRpcRequest.prototype.toXml = function() {
        var lines = [];
        lines.push(
           "<?xml version='1.0'?>",
           "<methodCall>",
           "  <methodName>" + this.methodName + "</methodName>",
           "  <params>");
        for (var i = 0; i < this.params.length; i++) {
            lines.push("    <param>",
                       XmlRpc.valueToXml(this.params[i], "      "),
                       "    </param>");
        }
        lines.push(
           "  </params>",
           "</methodCall>");
        return lines.join("\n");
    };

    // XmlRpcClient class:
    // Object capable of sending XML-RPC calls to an XML-RPC server.
    // That server will typically reside on the host on which the
    // javascript is running; it is not likely to reside on the host
    // which served the javascript.  That means that sandboxing restrictions
    // will be in effect.  Much of the work done here is therefore to
    // do the client-side work required to potentially escape the sandbox.
    // The endpoint parameter, if supplied, is the URL of the XML-RPC server.
    // If absent, the default SAMP Web Profile server is used.
    var XmlRpcClient = function(endpoint) {
        this.endpoint = endpoint ||
                        "http://localhost:" + WEBSAMP_PORT + WEBSAMP_PATH;
    };

    // Creates an XHR facade - an object that presents an interface
    // resembling that of an XMLHttpRequest Level 2.
    // This facade may be based on an actual XMLHttpRequest Level 2 object
    // (on browsers that support it), or it may fake one using other
    // available technology.
    //
    // The created facade in any case presents the following interface:
    //
    //    open(method, url)
    //    send(body)
    //    abort()
    //    setContentType()
    //    responseText
    //    responseXML
    //    onload
    //    onerror(err)  - includes timeout; abort is ignored
    //
    // See the documentation at http://www.w3.org/TR/XMLHttpRequest/
    // for semantics.
    //
    // XMLHttpRequest Level 2 supports Cross-Origin Resource Sharing (CORS)
    // which makes sandbox evasion possible.  Faked XHRL2s returned by
    // this method may use CORS or some other technology to evade the
    // sandbox.  The SAMP hub itself may selectively allow some of these
    // technologies and not others, according to configuration.
    XmlRpcClient.createXHR = function() {

        // Creates an XHR facade based on a genuine XMLHttpRequest Level 2.
        var XhrL2 = function(xhr) {
            this.xhr = xhr;
            xhr.onreadystatechange = (function(l2) {
                return function() {
                    if (xhr.readyState !== 4) {
                        return;
                    }
                    else if (!l2.completed) {
                        if (+xhr.status === 200) {
                            l2.completed = true;
                            l2.responseText = xhr.responseText;
                            l2.responseXML = xhr.responseXML;
                            if (l2.onload) {
                                l2.onload();
                            }
                        }
                    }
                };
            })(this);
            xhr.onerror = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            if (event) {
                                event.toString = function() {return "No hub?";};
                            }
                            else {
                                event = "No hub?";
                            }
                            l2.onerror(event);
                        }
                    }
                };
            })(this);
            xhr.ontimeout = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            l2.onerror("timeout");
                        }
                    }
                };
            })(this);
        };
        XhrL2.prototype.open = function(method, url) {
            this.xhr.open(method, url);
        };
        XhrL2.prototype.send = function(body) {
            this.xhr.send(body);
        };
        XhrL2.prototype.abort = function() {
            this.xhr.abort();
        }
        XhrL2.prototype.setContentType = function(mimeType) {
            if ("setRequestHeader" in this.xhr) {
                this.xhr.setRequestHeader("Content-Type", mimeType);
            }
        }

        // Creates an XHR facade based on an XDomainRequest (IE8+ only).
        var XdrL2 = function(xdr) {
            this.xdr = xdr;
            xdr.onload = (function(l2) {
                return function() {
                    var e;
                    l2.responseText = xdr.responseText;
                    if (xdr.contentType === "text/xml" ||
                        xdr.contentType === "application/xml" ||
                        /\/x-/.test(xdr.contentType)) {
                        try {
                            var xdoc = new ActiveXObject("Microsoft.XMLDOM");
                            xdoc.loadXML(xdr.responseText);
                            l2.responseXML = xdoc;
                        }
                        catch (e) {
                            l2.responseXML = e;
                        }
                    }
                    if (l2.onload) {
                        l2.onload();
                    }
                };
            })(this);
            xdr.onerror = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
            xdr.ontimeout = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
        };
        XdrL2.prototype.open = function(method, url) {
            this.xdr.open(method, url);
        };
        XdrL2.prototype.send = function(body) {
            this.xdr.send(body);
        };
        XdrL2.prototype.abort = function() {
            this.xdr.abort();
        };
        XdrL2.prototype.setContentType = function(mimeType) {
            // can't do it.
        };

        // Creates an XHR Facade based on available XMLHttpRequest-type
        // capabilibities.
        // If an actual XMLHttpRequest Level 2 is available, use that.
        if (typeof XMLHttpRequest !== "undefined") {
            var xhr = new XMLHttpRequest();
            if ("withCredentials" in xhr) {
                return new XhrL2(xhr);
            }
        }

        // Else if an XDomainRequest is available, use that.
        if (typeof XDomainRequest !== "undefined") {
            return new XdrL2(new XDomainRequest());
        }

        // Else fake an XMLHttpRequest using Flash/flXHR, if available
        // and use that.
        if (typeof flensed.flXHR !== "undefined") {
            return new XhrL2(new flensed.flXHR({instancePooling: true}));
        }

        // No luck.
        throw new Error("no cross-origin mechanism available");
    };

    // Executes a request by passing it to the XML-RPC server.
    // On success, the result is passed to the resultHandler.
    // On failure, the errHandler is called with one of two possible
    // arguments: an XmlRpc.Fault object, or an Error object.
    XmlRpcClient.prototype.execute = function(req, resultHandler, errHandler) {
        (function(xClient) {
            var xhr;
            var e;
            try {
                xhr = XmlRpcClient.createXHR();
                xhr.open("POST", xClient.endpoint);
                xhr.setContentType("text/xml");
            }
            catch (e) {
                errHandler(e);
                throw e;
            }
            xhr.onload = function() {
                var xml = xhr.responseXML;
                var result;
                var e;
                if (xml) {
                    try {
                        result = XmlRpc.decodeResponse(xml);
                    }
                    catch (e) {
                        if (errHandler) {
                            errHandler(e);
                        }
                        return;
                    }
                }
                else {
                    if (errHandler) {
                        errHandler("no XML response");
                    }
                    return;
                }
                if (result instanceof XmlRpc.Fault) {
                    if (errHandler) {
                        errHandler(result);
                    }
                }
                else {
                    if (resultHandler) {
                        resultHandler(result);
                    }
                }
            };
            xhr.onerror = function(event) {
                if (event) {
                    event.toString = function() {return "No hub?";}
                }
                else {
                    event = "No hub";
                }
                if (errHandler) {
                    errHandler(event);
                }
            };
            xhr.send(req.toXml());
            return xhr;
        })(this);
    };

    // Message class:
    // Aggregates an MType string and a params map.
    var Message = function(mtype, params) {
        this["samp.mtype"] = mtype;
        this["samp.params"] = params;
    };

    // Connection class:
    // this is what clients use to communicate with the hub.
    //
    // All the methods from the Hub Abstract API as described in the
    // SAMP standard are available as methods of a Connection object.
    // The initial private-key argument required by the Web Profile is
    // handled internally by this object - you do not need to supply it
    // when calling one of the methods.
    //
    // All these calls have the same form:
    //
    //    connection.method([method-args], resultHandler, errorHandler)
    //
    // the first argument is an array of the arguments (as per the SAMP
    // abstract hub API), the second argument is a function which is
    // called on successful completion with the result of the SAMP call
    // as its argument, and the third argument is a function which is
    // called on unsuccessful completion with an error object as its
    // argument.  The resultHandler and errorHandler arguments are optional.
    //
    // So for instance if you have a Connection object conn,
    // you can send a notify message to all other clients by doing, e.g.:
    //
    //    conn.notifyAll([new samp.Message(mtype, params)])
    //
    // Connection has other methods as well as the hub API ones
    // as documented below.
    var Connection = function(regInfo) {
        this.regInfo = regInfo;
        this.privateKey = regInfo["samp.private-key"];
        if (! typeof(this.privateKey) === "string") {
            throw new Error("Bad registration object");
        }
        this.xClient = new XmlRpcClient();
    };
    (function() {
        var connMethods = {
            call: [TYPE_STRING, TYPE_STRING, TYPE_MAP],
            callAll: [TYPE_STRING, TYPE_MAP],
            callAndWait: [TYPE_STRING, TYPE_MAP, TYPE_STRING],
            declareMetadata: [TYPE_MAP],
            declareSubscriptions: [TYPE_MAP],
            getMetadata: [TYPE_STRING],
            getRegisteredClients: [],
            getSubscribedClients: [TYPE_STRING],
            getSubscriptions: [TYPE_STRING],
            notify: [TYPE_STRING, TYPE_MAP],
            notifyAll: [TYPE_MAP],
            ping: [],
            reply: [TYPE_STRING, TYPE_MAP]
        };
        var fn;
        var types;
        for (fn in connMethods) {
            (function(fname, types) {
                // errHandler may be passed an XmlRpc.Fault or a thrown Error.
                Connection.prototype[fname] =
                        function(sampArgs, resultHandler, errHandler) {
                    var closer =
                        (function(c) {return function() {c.close()}})(this);
                    errHandler = errHandler || closer
                    XmlRpc.checkParams(sampArgs, types);
                    var request = new XmlRpcRequest(WEBSAMP_PREFIX + fname);
                    request.addParam(this.privateKey);
                    request.addParams(sampArgs);
                    return this.xClient.
                           execute(request, resultHandler, errHandler);
                };
            })(fn, connMethods[fn]);
        }
    })();
    Connection.prototype.unregister = function() {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
        }
        var request = new XmlRpcRequest(WEBSAMP_PREFIX + "unregister");
        request.addParam(this.privateKey);
        try {
            this.xClient.execute(request);
        }
        catch (e) {
            // log unregister failed
        }
        delete this.regInfo;
        delete this.privateKey;
    };

    // Closes this connection.  It unregisters from the hub if still
    // registered, but may harmlessly be called multiple times.
    Connection.prototype.close = function() {
        var e;
        if (this.closed) {
            return;
        }
        this.closed = true;
        try {
            if (this.regInfo) {
                this.unregister();
            }
        }
        catch (e) {
        }
        if (this.onclose) {
            oc = this.onclose;
            delete this.onclose;
            try {
                oc();
            }
            catch (e) {
            }
        }
    };

    // Arranges for this connection to receive callbacks.
    //
    // The callableClient argument must be an object implementing the
    // SAMP callable client API, i.e. it must have the following methods:
    //
    //     receiveNotification(string sender-id, map message)
    //     receiveCall(string sender-id, string msg-id, map message)
    //     receiveResponse(string responder-id, string msg-tag, map response)
    // 
    // The successHandler argument will be called with no arguments if the
    // allowCallbacks hub method completes successfully - it is a suitable
    // hook to use for declaring subscriptions.
    //
    // The CallableClient class provides a suitable implementation, see below.
    Connection.prototype.setCallable = function(callableClient,
                                                successHandler) {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
            finally {
                delete this.callbackRequest;
            }
        }
        if (!callableClient && !this.regInfo) {
            return;
        }
        var request =
            new XmlRpcRequest(WEBSAMP_PREFIX + "allowReverseCallbacks");
        request.addParam(this.privateKey);
        request.addParam(callableClient ? "1" : "0");
        var closer = (function(c) {return function() {c.close()}})(this);
        if (callableClient) {
            (function(connection) {
                var invokeCallback = function(callback) {
                    var methodName = callback["samp.methodName"];
                    var methodParams = callback["samp.params"];
                    var handlerFunc = undefined;
                    if (methodName === WEBSAMP_CLIENT_PREFIX
                                     + "receiveNotification") {
                        handlerFunc = callableClient.receiveNotification;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveCall") {
                        handlerFunc = callableClient.receiveCall;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveResponse") {
                        handlerFunc = callableClient.receiveResponse;
                    }
                    else {
                        // unknown callback??
                    }
                    if (handlerFunc) {
                        handlerFunc.apply(callableClient, methodParams);
                    }
                };
                var startTime;
                var resultHandler = function(result) {
                    if (getSampType(result) != TYPE_LIST) {
                        errHandler(new Error("pullCallbacks result not List"));
                        return;
                    }
                    var i;
                    var e;
                    for (i = 0; i < result.length; i++) {
                        try {
                            invokeCallback(result[i]);
                        }
                        catch (e) {
                            // log here?
                        }
                    }
                    callWaiter();
                };
                var errHandler = function(error) {
                    var elapsed = new Date().getTime() - startTime;
                    if (elapsed < 1000) {
                        connection.close()
                    }
                    else {
                        // probably a timeout
                        callWaiter();
                    }
                };
                var callWaiter = function() {
                    if (!connection.regInfo) {
                        return;
                    }
                    var request =
                        new XmlRpcRequest(WEBSAMP_PREFIX + "pullCallbacks");
                    request.addParam(connection.privateKey);
                    request.addParam("600");
                    startTime = new Date().getTime();
                    connection.callbackRequest =
                        connection.xClient.
                                   execute(request, resultHandler, errHandler);
                };
                var sHandler = function() {
                    callWaiter();
                    successHandler();
                };
                connection.xClient.execute(request, sHandler, closer);
            })(this);
        }
        else {
            this.xClient.execute(request, successHandler, closer);
        }
    };

    // Takes a public URL and returns a URL that can be used from within
    // this javascript context.  Some translation may be required, since
    // a URL sent by an external application may be cross-domain, in which
    // case browser sandboxing would typically disallow access to it.
    Connection.prototype.translateUrl = function(url) {
        var translator = this.regInfo["samp.url-translator"] || "";
        return translator + url;
    };
    Connection.Action = function(actName, actArgs, resultKey) {
        this.actName = actName;
        this.actArgs = actArgs;
        this.resultKey = resultKey;
    };

    // Suitable implementation for a callable client object which can
    // be supplied to Connection.setCallable().
    // Its callHandler and replyHandler members are string->function maps
    // which can be used to provide handler functions for MTypes and
    // message tags respectively.
    //
    // In more detail:
    // The callHandler member maps a string representing an MType to
    // a function with arguments (senderId, message, isCall).
    // The replyHandler member maps a string representing a message tag to
    // a function with arguments (responderId, msgTag, response).
    var CallableClient = function(connection) {
        this.callHandler = {};
        this.replyHandler = {};
    };
    CallableClient.prototype.init = function(connection) {
    };
    CallableClient.prototype.receiveNotification = function(senderId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var e;
        if (mtype in this.callHandler) {
            try {
                this.callHandler[mtype](senderId, message, false);
            }
            catch (e) {
            }
            handled = true;
        }
        return handled;
    };
    CallableClient.prototype.receiveCall = function(senderId, msgId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var response;
        var result;
        var e;
        if (mtype in this.callHandler) {
            try {
                result = this.callHandler[mtype](senderId, message, true) || {};
                response = {"samp.status": "samp.ok",
                            "samp.result": result};
                handled = true;
            }
            catch (e) {
                response = {"samp.status": "samp.error",
                            "samp.error": {"samp.errortxt": e.toString()}};
            }
        }
        else {
            response = {"samp.status": "samp.warning",
                        "samp.result": {},
                        "samp.error": {"samp.errortxt": "no action"}};
        }
        this.connection.reply([msgId, response]);
        return handled;
    };
    CallableClient.prototype.receiveResponse = function(responderId, msgTag,
                                                        response) {
        var handled = false;
        var e;
        if (msgTag in this.replyHandler) {
            try {
                this.replyHandler[msgTag](responderId, msgTag, response);
                handled = true;
            }
            catch (e) {
            }
        }
        return handled;
    };
    CallableClient.prototype.calculateSubscriptions = function() {
        var subs = {};
        var mt;
        for (mt in this.callHandler) {
            subs[mt] = {};
        }
        return subs;
    };

    // ClientTracker is a CallableClient which also provides tracking of
    // registered clients.
    //
    // Its onchange member, if defined, will be called with arguments
    // (client-id, change-type, associated-data) whenever the list or
    // characteristics of registered clients has changed.
    var ClientTracker = function() {
        var tracker = this;
        this.ids = {};
        this.metas = {};
        this.subs = {};
        this.replyHandler = {};
        this.callHandler = {
            "samp.hub.event.shutdown": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.disconnect": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.event.register": function(senderId, message) {
                var id = message["samp.params"]["id"];
                tracker.ids[id] = true;
                tracker.changed(id, "register", null);
            },
            "samp.hub.event.unregister": function(senderId, message) {
                var id = message["samp.params"]["id"];
                delete tracker.ids[id];
                delete tracker.metas[id];
                delete tracker.subs[id];
                tracker.changed(id, "unregister", null);
            },
            "samp.hub.event.metadata": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var meta = message["samp.params"]["metadata"];
                tracker.metas[id] = meta;
                tracker.changed(id, "meta", meta);
            },
            "samp.hub.event.subscriptions": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var subs = message["samp.params"]["subscriptions"];
                tracker.subs[id] = subs;
                tracker.changed(id, "subs", subs);
            }
        };
    };
    ClientTracker.prototype = heir(CallableClient.prototype);
    ClientTracker.prototype.changed = function(id, type, data) {
        if (this.onchange) {
            this.onchange(id, type, data);
        }
    };
    ClientTracker.prototype.init = function(connection) {
        var tracker = this;
        this.connection = connection;
        var retrieveInfo = function(id, type, infoFuncName, infoArray) {
            connection[infoFuncName]([id], function(info) {
                infoArray[id] = info;
                tracker.changed(id, type, info);
            });
        };
        connection.getRegisteredClients([], function(idlist) {
            var i;
            var id;
            tracker.ids = {};
            for (i = 0; i < idlist.length; i++) {
                id = idlist[i];
                tracker.ids[id] = true;
                retrieveInfo(id, "meta", "getMetadata", tracker.metas);
                retrieveInfo(id, "subs", "getSubscriptions", tracker.subs);
            }
            tracker.changed(null, "ids", null);
        });
    };
    ClientTracker.prototype.getName = function(id) {
        var meta = this.metas[id];
        return (meta && meta["samp.name"]) ? meta["samp.name"] : "[" + id + "]";
    };

    // Connector class:
    // A higher level class which can manage transparent hub
    // registration/unregistration and client tracking.
    //
    // On construction, the name argument is mandatory, and corresponds
    // to the samp.name item submitted at registration time.
    // The other arguments are optional.
    // meta is a metadata map (if absent, no metadata is declared)
    // callableClient is a callable client object for receiving callbacks
    // (if absent, the client is not callable).
    // subs is a subscriptions map (if absent, no subscriptions are declared)
    var Connector = function(name, meta, callableClient, subs) {
        this.name = name;
        this.meta = meta;
        this.callableClient = callableClient;
        this.subs = subs;
        this.regTextNodes = [];
        this.whenRegs = [];
        this.whenUnregs = [];
        this.connection = undefined;
        this.onreg = undefined;
        this.onunreg = undefined;
    };
    var setRegText = function(connector, txt) {
        var i;
        var nodes = connector.regTextNodes;
        var node;
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            node.innerHTML = "";
            node.appendChild(document.createTextNode(txt));
        }
    };
    Connector.prototype.setConnection = function(conn) {
        var connector = this;
        var e;
        if (this.connection) {
            this.connection.close();
            if (this.onunreg) {
                try {
                    this.onunreg();
                }
                catch (e) {
                }
            }
        }
        this.connection = conn;
        if (conn) {
            conn.onclose = function() {
                connector.connection = null;
                if (connector.onunreg) {
                    try {
                        connector.onunreg();
                    }
                    catch (e) {
                    }
                }
                connector.update();
            };
            if (this.meta) {
                conn.declareMetadata([this.meta]);
            }
            if (this.callableClient) {
                if (this.callableClient.init) {
                    this.callableClient.init(conn);
                }
                conn.setCallable(this.callableClient, function() {
                    conn.declareSubscriptions([connector.subs]);
                });
            }
            if (this.onreg) {
                try {
                    this.onreg(conn);
                }
                catch (e) {
                }
            }
        }
        this.update();
    };
    Connector.prototype.register = function() {
        var connector = this;
        var regErrHandler = function(err) {
            setRegText(connector, "no (" + err.toString() + ")");
        };
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            setRegText(connector, conn ? "Yes" : "No");
        };
        register(this.name, regSuccessHandler, regErrHandler);
    };
    Connector.prototype.unregister = function() {
        if (this.connection) {
            this.connection.unregister([]);
            this.setConnection(null);
        }
    };

    // Returns a document fragment which contains Register/Unregister
    // buttons for use by the user to attempt to connect/disconnect
    // with the hub.  This is useful for models where explicit
    // user registration is encouraged or required, but when using
    // the register-on-demand model such buttons are not necessary.
    Connector.prototype.createRegButtons = function() {
        var connector = this;
        var regButt = document.createElement("button");
        regButt.setAttribute("type", "button");
        regButt.appendChild(document.createTextNode("Register"));
        regButt.onclick = function() {connector.register();};
        this.whenUnregs.push(regButt);
        var unregButt = document.createElement("button");
        unregButt.setAttribute("type", "button");
        unregButt.appendChild(document.createTextNode("Unregister"));
        unregButt.onclick = function() {connector.unregister();};
        this.whenRegs.push(unregButt);
        var regText = document.createElement("span");
        this.regTextNodes.push(regText);
        var node = document.createDocumentFragment();
        node.appendChild(regButt);
        node.appendChild(document.createTextNode(" "));
        node.appendChild(unregButt);
        var label = document.createElement("span");
        label.innerHTML = " <strong>Registered: </strong>";
        node.appendChild(label);
        node.appendChild(regText);
        this.update();
        return node;
    };

    Connector.prototype.update = function() {
        var i;
        var isConnected = !! this.connection;
        var enableds = isConnected ? this.whenRegs : this.whenUnregs;
        var disableds = isConnected ? this.whenUnregs : this.whenRegs;
        for (i = 0; i < enableds.length; i++) {
            enableds[i].removeAttribute("disabled");
        }
        for (i = 0; i < disableds.length; i++) {
            disableds[i].setAttribute("disabled", "disabled");
        }
        setRegText(this, "No");
    };

    // Provides execution of a SAMP operation with register-on-demand.
    // You can use this method to provide lightweight registration/use
    // of web SAMP.  Simply provide a connHandler function which
    // does something with a connection (e.g. sends a message) and
    // Connector.runWithConnection on it.  This will connect if not
    // already connected, and call the connHandler on with the connection.
    // No explicit registration action is then required from the user.
    //
    // If the regErrorHandler argument is supplied, it is a function of
    // one (error) argument called in the case that registration-on-demand
    // fails.
    //
    // This is a more-or-less complete sampjs page:
    //   <script>
    //     var connector = new samp.Connector("pinger", {"samp.name": "Pinger"})
    //     var pingFunc = function(connection) {
    //       connection.notifyAll([new samp.Message("samp.app.ping", {})])
    //     }
    //   </script>
    //   <button onclick="connector.runWithConnection(pingFunc)">Ping</button>
    Connector.prototype.runWithConnection =
            function(connHandler, regErrorHandler) {
        var connector = this;
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            connHandler(conn);
        };
        var regFailureHandler = function(e) {
            connector.setConnection(undefined);
            regErrorHandler(e);
        };
        var pingResultHandler = function(result) {
            connHandler(connector.connection);
        };
        var pingErrorHandler = function(err) {
            register(this.name, regSuccessHandler, regFailureHandler);
        };
        if (this.connection) {
            // Use getRegisteredClients as the most lightweight check
            // I can think of that this connection is still OK.
            // Ping doesn't work because the server replies even if the
            // private-key is incorrect/invalid.  Is that a bug or not?
            this.connection.
                 getRegisteredClients([], pingResultHandler, pingErrorHandler);
        }
        else {
            register(this.name, regSuccessHandler, regFailureHandler);
        }
    };

    // Sets up an interval timer to run at intervals and notify a callback
    // about whether a hub is currently running.
    // Every millis milliseconds, the supplied availHandler function is
    // called with a boolean argument: true if a (web profile) hub is
    // running, false if not.
    // Returns the interval timer (can be passed to clearInterval()).
    Connector.prototype.onHubAvailability = function(availHandler, millis) {
        samp.ping(availHandler);

        // Could use the W3C Page Visibility API to avoid making these
        // checks when the page is not visible.
        return setInterval(function() {samp.ping(availHandler);}, millis);
    };

    // Determines whether a given subscriptions map indicates subscription
    // to a given mtype.
    var isSubscribed = function(subs, mtype) {
        var matching = function(pattern, mtype) {
            if (pattern == mtype) {
                return true;
            }
            else if (pattern === "*") {
                return true;
            }
            else {
                var prefix;
                var split = /^(.*)\.\*$/.exec(pat);
                if (split) {
                    prefix = split[1];
                    if (prefix === mtype.substring(0, prefix.length)) {
                        return true;
                    }
                }
            }
            return false;
        };
        var pat;
        for (pat in subs) {
            if (matching(pat, mtype)) {
                return true;
            }
        }
        return false;
    }

    // Attempts registration with a SAMP hub.
    // On success the supplied connectionHandler function is called
    // with the connection as an argument, on failure the supplied
    // errorHandler is called with an argument that may be an Error
    // or an XmlRpc.Fault.
    var register = function(appName, connectionHandler, errorHandler) {
        var xClient = new XmlRpcClient();
        var regRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "register");
        var securityInfo = {"samp.name": appName};
        regRequest.addParam(securityInfo);
        regRequest.checkParams([TYPE_MAP]);
        var resultHandler = function(result) {
            var conn;
            var e;
            try {
                conn = new Connection(result);
            }
            catch (e) {
                errorHandler(e);
                return;
            }
            connectionHandler(conn);
        };
        xClient.execute(regRequest, resultHandler, errorHandler);
    };

    // Calls the hub ping method once.  It is not necessary to be
    // registered to do this.
    // The supplied pingHandler function is called with a boolean argument:
    // true if a (web profile) hub is running, false if not.
    var ping = function(pingHandler) {
        var xClient = new XmlRpcClient();
        var pingRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "ping");
        var resultHandler = function(result) {
            pingHandler(true);
        };
        var errorHandler = function(error) {
            pingHandler(false);
        };
        xClient.execute(pingRequest, resultHandler, errorHandler);
    };


    /* Exports. */
    var jss = {};
    jss.XmlRpcRequest = XmlRpcRequest;
    jss.XmlRpcClient = XmlRpcClient;
    jss.Message = Message;
    jss.TYPE_STRING = TYPE_STRING;
    jss.TYPE_LIST = TYPE_LIST;
    jss.TYPE_MAP = TYPE_MAP;
    jss.register = register;
    jss.ping = ping;
    jss.isSubscribed = isSubscribed;
    jss.Connector = Connector;
    jss.CallableClient = CallableClient;
    jss.ClientTracker = ClientTracker;

    return jss;
})();

define("samp", function(){});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * SampCore Module : containing core methods
 */
define('Services/SampCore',[
    "jquery",
    "underscore-min",
    "../Parser/JsonProcessor",
    "../Gui/dialog/ErrorDialog",
    "samp",
    "jquery.ui"
], function($, _, JsonProcessor, ErrorDialog) {
    var mizar;
    var navigation;
    var imageManager;

    var connector; // SAMP connector
    var sampLayer; // SAMP vector layer containing all incoming fits images
    var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
    var votable2geojsonBaseUrl;
    var sitoolsBaseUrl;

    /**************************************************************************************************************/

    /**
     *    Create SAMP ClientTracker object which handles incoming messages
     */
    function createClientTracker() {
        // Initialize client tracker
        var clientTracker = new samp.ClientTracker();

        // Init available samp income message handlers(as ping, load.votable..)
        var callHandler = clientTracker.callHandler;
        callHandler["samp.app.ping"] = function(senderId, message, isCall) {
            if (isCall) {
                return {
                    text: "ping to you, " + clientTracker.getName(senderId)
                };
            }
        };

        callHandler["table.load.votable"] = function(
            senderId,
            message,
            isCall
        ) {
            if (votable2geojsonBaseUrl) {
                //var params = message["samp.params"];
                //var origUrl = params.url;
                //var proxyUrl = clientTracker.connection.translateUrl(origUrl);
                //Utils.convertVotable2JsonFromURL(proxyUrl, function (response) {
                // Add feature collection
                //    JsonProcessor.handleFeatureCollection(sampLayer, response);
                //    sampLayer.addFeatureCollection(response);
                //});
            } else {
                ErrorDialog.open(
                    "votable2geojson plugin base url isn't defined"
                );
            }
        };

        // callHandler["table.highlight.row"] = function(senderId, message, isCall) {
        // 	var params = message["samp.params"];
        // 	var url = params['url'];
        // 	var row = params['row'];

        // 	if ( highlightedData )
        // 	{
        // 		highlightedData.layer.modifyFeatureStyle( highlightedData.feature, highlightedData.layer.style );
        // 	}

        // 	if ( tables[url] )
        // 	{
        // 		var layer = tables[url].layer;
        // 		var feature = tables[url].features[parseInt(row)];

        // 		layer.modifyFeatureStyle( feature, highlightStyle );
        // 		highlightedData = {
        // 			layer: layer,
        // 			feature: feature
        // 		}

        // 		var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
        // 		navigation.zoomTo( barycenter, (navigation.renderContext.fov < 1. ? navigation.renderContext.fov : 1.), 300. );
        // 	}
        // };

        callHandler["image.load.fits"] = function(senderId, message, isCall) {
            // var params = message["samp.params"];
            //
            // // Create feature
            // var feature = {
            //     "geometry": {
            //         "gid": params.name,
            //         "coordinates": [],
            //         "type": "Polygon"
            //     },
            //     "properties": {
            //         "identifier": params.name
            //     },
            //     "services": {
            //         "download": {
            //             "mimetype": "image/fits",
            //             "url": params['image-id']
            //         }
            //     },
            //     "type": "Feature"
            // };
            //
            // // Get fits texture from url
            // var featureData = {
            //     layer: sampLayer,
            //     feature: feature,
            //     isFits: true
            // };
            // var url = sitoolsBaseUrl + "/proxy?external_url=" + encodeURIComponent(params['image-id']);
            // mizar.publish("image:add", featureData);
            // imageManager.computeFits(featureData, url, function (featureData, fits) {
            //     // Update feature coordinates according to Fits header
            //     var coords = Utils.getPolygonCoordinatesFromFits(fits);
            //     featureData.feature.geometry.coordinates = [coords];
            //     sampLayer.addFeature(featureData.feature);
            // });
        };

        callHandler["coord.pointAt.sky"] = function(senderId, message, isCall) {
            pointAtReceived = true;
            var params = message["samp.params"];
            var ra = parseFloat(params.ra);
            var dec = parseFloat(params.dec);
            var navigation = mizar.getActivatedContext().getNavigation();
            navigation.zoomTo([ra, dec]);
        };

        callHandler["samp.hub.event.unregister"] = function(
            senderId,
            message,
            isCall
        ) {
            // Update jQuery UI buttons
            $("#registerSamp")
                .removeAttr("disabled")
                .button("refresh");
            $("#unregisterSamp")
                .attr("disabled", "disabled")
                .button("refresh");
            $("#sampInvoker").toggleClass("selected");
        };

        return clientTracker;
    }

    /**************************************************************************************************************/

    /**
     *    Init SAMP connector
     */
    function initSamp(mizarAPI) {
        mizar = mizarAPI;
        var clientTracker = createClientTracker();

        // Samp event callbacks
        var logCc = {
            receiveNotification: function(senderId, message) {
                var handled = clientTracker.receiveNotification(
                    senderId,
                    message
                );
                if (message["samp.mtype"] === "samp.hub.event.subscriptions") {
                    // Update jQuery UI buttons
                    $("#unregisterSamp")
                        .removeAttr("disabled")
                        .button("refresh");
                    $("#registerSamp")
                        .attr("disabled", "disabled")
                        .button("refresh");
                    $("#sampInvoker").addClass("selected");
                }
            },
            receiveCall: function(senderId, msgId, message) {
                var handled = clientTracker.receiveCall(
                    senderId,
                    msgId,
                    message
                );
            },
            receiveResponse: function(responderId, msgTag, response) {
                var handled = clientTracker.receiveResponse(
                    responderId,
                    msgTag,
                    response
                );
            },
            init: function(connection) {
                clientTracker.init(connection);
            }
        };

        // Meta-data
        var meta = {
            "samp.name": "Mizar",
            "samp.description.text":
                "Module for Interactive visualiZation from Astronomical Repositories",
            "mizar.version": "v1.0",
            "author.affiliation": "CNES/TPZ",
            "home.page": "http://github.com/MizarWeb"
        };

        // Generate subscriptions map
        var subs = clientTracker.calculateSubscriptions();

        connector = new samp.Connector("Mizar", meta, logCc, subs);

        // Uncomment for automatic registration(check every 2 sec if Hub is available)
        // Adjusts page content depending on whether the hub exists or not.
        // var configureSampEnabled = function(isHubRunning) {
        //     // TODO
        // };
        // connector.onHubAvailability(configureSampEnabled, 2000);

        // Registration status element is updated by samp.js
        connector.regTextNodes.push($("#sampResult")[0]);

        return connector;
    }

    /**************************************************************************************************************/

    return {
        initSamp: initSamp,
        sendImage: function(url) {
            if (this.isConnected()) {
                // Send message
                var msg = new samp.Message("image.load.fits", { url: url });
                connector.connection.notifyAll([msg]);
                return "Image has been sent";
            } else {
                return "Connect to SAMP Hub first";
            }
        },

        sendVOTable: function(layer, url) {
            if (this.isConnected()) {
                // Send message
                var msg = new samp.Message("table.load.votable", {
                    url: url + "&media=votable"
                });
                connector.connection.notifyAll([msg]);

                // Part used to highlighting
                // $.ajax({
                // 	type: "GET",
                // 	url: url,
                // 	success: function(response) {

                // 		if ( response.totalResults > 0 )
                // 		{
                // 			// Store table to be able to highlight features later
                // 			tables[ url+'&media=votable' ] = {
                // 				layer: layer,
                // 				features: []
                // 			};
                // 			for ( var i=0; i<response.features.length; i++ )
                // 			{
                // 				var feature = response.features[i];
                // 				tables[url+'&media=votable'].features.push(feature);
                // 			}
                // 		}
                // 		// Send message
                // 		var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
                // 		connector.connection.notifyAll([msg]);
                // 	},
                // 	error: function(thrownError)
                // 	{
                // 		console.error(thrownError);
                // 	}
                // });
                return "VOTable has been sent";
            } else {
                return "Connect to SAMP Hub first";
            }
        },

        // Commented part is used for highlighting feature which wasn't implemented due to
        // difficulty of SAMP protocol (client doesn't know the feature from row)
        highlightFeature: function(layer, feature) {
            /**if (this.isConnected()) {
                    // for ( var url in tables )
                    // {
                    // 	var table = tables[url];
                    // 	if ( layer == table.layer )
                    // 	{
                    // 		var featureToHighlight = _.filter( table.features, function(x){ return(feature.properties.identifier == x.properties.identifier) } );
                    // 		if ( featureToHighlight.length )
                    // 		{
                    // var featureRow = table.features.indexOf(featureToHighlight[0]);
                    // var msg = new samp.Message("table.highlight.row", {url: url, row: featureRow.toString()});
                    // connector.connection.notifyAll([msg]);
                    // 		}
                    // 	}
                    // }
                }
                */
        },
        isConnected: function() {
            return connector.connection;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('Services/SelectionToolCore',[
    "jquery",
    "../Utils/Constants",
    "../Utils/UtilsIntersection",
    "../Utils/Numeric",
    "../Layer/VectorLayer",
    "../Renderer/FeatureStyle",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    $,
    Constants,
    UtilsIntersection,
    Numeric,
    VectorLayer,
    FeatureStyle,
    Ray
) {
    var ctx, navigation, onselect;
    /**
     *    @constructor
     *    @param options Configuration options
     *        <ul>
     *            <li>planet: planet</li>
     *            <li>navigation: Navigation</li>
     *            <li>onselect: On selection callback</li>
     *            <li>style: Selection tool style</li>
     *        </ul>
     */
    var SelectionToolCore = function(options) {
        // Required options
        ctx = options.ctx;
        navigation = ctx.getNavigation();
        onselect = options.onselect;

        this.activated = options.activated || false;
        this.renderContext = ctx.getRenderContext();
        this.coordinateSystem = ctx.getCoordinateSystem();

        // Set style
        var style;
        if (options && options.style) {
            style = options.style;
        } else {
            style = new FeatureStyle();
        }
        style.zIndex = Constants.DISPLAY.SELECTED_VECTOR;

        // Layer containing selection feature
        this.selectionLayer = new VectorLayer({
            style: style,
            visible: true
        });
        ctx.addDraw(this.selectionLayer);

        this.selectionFeature = null;

        // Selection attributes
        this.radius = null; // Window radius
        this.pickPoint = null; // Window pick point
        this.geoRadius = null; // Radius in geographic reference
        this.geoPickPoint = null; // Pick point in geographic reference

        var self = this;
        var dragging = false;
        var state;

        this.renderContext.canvas.addEventListener("mousedown", function(
            event
        ) {
            var pickPoint = [event.layerX, event.layerY];
            var geoPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );

            if (!self.activated && !self.selectionFeature) {
                return;
            }

            // Dragging : moving/resizing OR drawing selection
            if (self.activated) {
                // Draw
                navigation.stop();
                dragging = true;
                self.pickPoint = pickPoint;
                self.geoPickPoint = geoPickPoint;
                self.radius = 0.0;
                state = "resize";
            } else {
                var pickIsInside = UtilsIntersection.pointInRing(
                    geoPickPoint,
                    self.selectionFeature.geometry.coordinates[0]
                );
                if (!pickIsInside) {
                    return;
                }
                navigation.stop();
                dragging = true;
                // Resize/move
                var inside = false;
                // Check if user clicked on one of control points
                for (
                    var i = 0;
                    i < self.selectionFeature.geometry.coordinates[0].length;
                    i++
                ) {
                    var controlPoint =
                        self.selectionFeature.geometry.coordinates[0][i];
                    inside |= UtilsIntersection.pointInSphere(
                        ctx,
                        geoPickPoint,
                        controlPoint,
                        20
                    );
                }

                if (inside) {
                    state = "resize";
                } else {
                    state = "move";
                }
            }
        });

        this.renderContext.canvas.addEventListener("mousemove", function(
            event
        ) {
            if (!dragging) {
                return;
            }

            var geoPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );
            if (state === "resize") {
                // Update radius
                self.radius = Math.sqrt(
                    Math.pow(event.layerX - self.pickPoint[0], 2) +
                        Math.pow(event.layerY - self.pickPoint[1], 2)
                );
                self.computeGeoRadius(geoPickPoint);
            } else if (state === "move") {
                // Update pick point position
                self.pickPoint = [event.layerX, event.layerY];
                self.geoPickPoint = ctx.getLonLatFromPixel(
                    event.layerX,
                    event.layerY
                );

                // TODO: scale radius of selection shape if fov has been changed(or not?)
            }
            self.updateSelection();
        });

        this.renderContext.canvas.addEventListener("mouseup", function(event) {
            if (!dragging) {
                return;
            }

            // Compute geo radius
            var stopPickPoint = ctx.getLonLatFromPixel(
                event.layerX,
                event.layerY
            );

            var coordinates = self.computeSelection();
            if (self.activated && onselect) {
                onselect(coordinates);
            }

            // Reactivate standard navigation events
            navigation.start();
            dragging = false;
        });
    };

    /**********************************************************************************************/

    /**
     *    Compute selection tool radius between pickPoint and the given point
     *    @param {Array} pt point
     */
    SelectionToolCore.prototype.computeGeoRadius = function(pt) {
        // Find angle between start and stop vectors which is in fact the radius
        var dotProduct = vec3.dot(
            vec3.normalize(this.coordinateSystem.get3DFromWorld(pt)),
            vec3.normalize(
                this.coordinateSystem.get3DFromWorld(this.geoPickPoint)
            )
        );
        var theta = Math.acos(dotProduct);
        this.geoRadius = Numeric.toDegree(theta);
    };

    /**********************************************************************************************/

    /**
     *    Compute selection for the given pick point depending on radius
     *    @return {Array} points
     */
    SelectionToolCore.prototype.computeSelection = function() {
        var rc = this.renderContext;
        var tmpMat = mat4.create();

        // Compute eye in world space
        mat4.inverse(rc.viewMatrix, tmpMat);
        var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

        // Compute the inverse of view/proj matrix
        mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
        mat4.inverse(tmpMat);

        // Scale to [-1,1]
        var widthScale = 2 / rc.canvas.width;
        var heightScale = 2 / rc.canvas.height;
        var points = [
            [
                (this.pickPoint[0] - this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] - this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] - this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] + this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] + this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] + this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ],
            [
                (this.pickPoint[0] + this.radius) * widthScale - 1.0,
                (rc.canvas.height - this.pickPoint[1] - this.radius) *
                    heightScale -
                    1.0,
                1,
                1
            ]
        ];

        // Transform the four corners of selection shape into world space
        // and then for each corner compute the intersection of ray starting from the eye with the sphere
        var worldCenter = [0, 0, 0];
        for (var i = 0; i < 4; i++) {
            mat4.multiplyVec4(tmpMat, points[i]);
            vec3.scale(points[i], 1.0 / points[i][3]);
            vec3.subtract(points[i], eye, points[i]);
            vec3.normalize(points[i]);

            var ray = new Ray(eye, points[i]);
            var pos3d = ray.computePoint(
                ray.sphereIntersect(
                    worldCenter,
                    this.coordinateSystem.getGeoide().getRadius()
                )
            );
            points[i] = this.coordinateSystem.getWorldFrom3D(pos3d);
        }

        return points;
    };

    /**************************************************************************************************************/

    /**
     *    Update selection coordinates
     */
    SelectionToolCore.prototype.updateSelection = function() {
        if (this.selectionFeature) {
            this.selectionLayer.removeFeature(this.selectionFeature);
        }

        var coordinates = this.computeSelection();
        // Close the polygon
        coordinates.push(coordinates[0]);

        this.selectionFeature = {
            geometry: {
                gid: "selectionShape",
                coordinates: [coordinates],
                type: "Polygon",
                crs: {
                    type: "name",
                    properties: {
                        name: ctx.getCoordinateSystem().getGeoideName()
                    }
                }
            },
            type: "Feature"
        };

        this.selectionLayer.addFeature(this.selectionFeature);
    };

    /**************************************************************************************************************/

    /**
     *    Activate/desactivate the tool
     */
    SelectionToolCore.prototype.toggle = function() {
        this.activated = !this.activated;
        if (this.activated) {
            // TODO : Find more sexy image for cursor
            $(this.renderContext.canvas).css(
                "cursor",
                "url(css/images/selectionCursor.png)"
            );
        } else {
            $(this.renderContext.canvas).css("cursor", "default");
        }
    };

    /**************************************************************************************************************/

    /**
     *    Clear selection
     */
    SelectionToolCore.prototype.clear = function() {
        if (this.selectionFeature) {
            this.selectionLayer.removeFeature(this.selectionFeature);
        }

        this.pickPoint = null;
        this.radius = null;
        this.geoPickPoint = null;
        this.geoRadius = null;
    };

    /**************************************************************************************************************/

    return SelectionToolCore;
});

/*!

JSZip v3.1.5 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define('jszip',[],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d=a("./utils"),e=a("./support"),f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o="string"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join("")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m="data:";if(a.substr(0,m.length)===m)throw new Error("Invalid base64 input, it looks like a data url.");a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error("Invalid base64 input, bad content length.");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{"./support":30,"./utils":32}],2:[function(a,b,c){"use strict";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a("./external"),f=a("./stream/DataWorker"),g=a("./stream/DataLengthProbe"),h=a("./stream/Crc32Probe"),g=a("./stream/DataLengthProbe");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g("data_length")),b=this;return a.on("end",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g("uncompressedSize")).pipe(b.compressWorker(c)).pipe(new g("compressedSize")).withStreamInfo("compression",b)},b.exports=d},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(a,b,c){"use strict";var d=a("./stream/GenericWorker");c.STORE={magic:"\0\0",compressWorker:function(a){return new d("STORE compression")},uncompressWorker:function(){return new d("STORE decompression")}},c.DEFLATE=a("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a("./utils"),h=d();b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{"./utils":32}],5:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){"use strict";var d=null;d="undefined"!=typeof Promise?Promise:a("lie"),b.exports={Promise:d}},{lie:58}],7:[function(a,b,c){"use strict";function d(a,b){h.call(this,"FlateWorker/"+a),this._pako=null,this._pakoAction=a,this._pakoOptions=b,this.meta={}}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,f=a("pako"),g=a("./utils"),h=a("./stream/GenericWorker"),i=e?"uint8array":"array";c.magic="\b\0",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,null===this._pako&&this._createPako(),this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},d.prototype._createPako=function(){this._pako=new f[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var a=this;this._pako.onData=function(b){a.push({data:b,meta:a.meta})}},c.compressWorker=function(a){return new d("Deflate",a)},c.uncompressWorker=function(){return new d("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:59}],8:[function(a,b,c){"use strict";function d(a,b,c,d){f.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a("../utils"),f=a("../stream/GenericWorker"),g=a("../utf8"),h=a("../crc32"),i=a("../signature"),j=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo("string",m(p.name)),t=e.transformTo("string",g.utf8encode(p.name)),u=p.comment,v=e.transformTo("string",m(u)),w=e.transformTo("string",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z="",A="",B="",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),"UNIX"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+="up"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+="uc"+j(B.length,2)+B);var I="";I+="\n\0",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+"\0\0\0\0"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g="",h=e.transformTo("string",f(d));return g=i.CENTRAL_DIRECTORY_END+"\0\0\0\0"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b="";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on("error",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(a,b,c){"use strict";var d=a("../compressions"),e=a("./ZipFileWorker"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+" is not a valid compression method !");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo("file",{name:a,dir:i,date:j,comment:c.comment||"",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(a,b,c){"use strict";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a("./object"),d.prototype.loadAsync=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.version="3.1.5",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a("./external"),b.exports=d},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(a,b,c){"use strict";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on("error",function(a){c(a)}).on("end",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error("Corrupted zip : CRC32 mismatch")):b()}).resume()})}var e=a("./utils"),f=a("./external"),g=a("./utf8"),e=a("./utils"),h=a("./zipEntries"),i=a("./stream/Crc32Probe"),j=a("./nodejsUtils");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):e.prepareContent("the loaded zip file",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(a,b,c){"use strict";function d(a,b){f.call(this,"Nodejs stream input adapter for "+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a("../utils"),f=a("../stream/GenericWorker");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on("data",function(a){b.push({data:a,meta:{percent:0}})}).on("error",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on("end",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{"../stream/GenericWorker":28,"../utils":32}],13:[function(a,b,c){"use strict";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on("data",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on("error",function(a){d.emit("error",a)}).on("end",function(){d.push(null)})}var e=a("readable-stream").Readable,f=a("../utils");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{"../utils":32,"readable-stream":16}],14:[function(a,b,c){"use strict";b.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(a,b){return new Buffer(a,b)},allocBuffer:function(a){return Buffer.alloc?Buffer.alloc(a):new Buffer(a)},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&"function"==typeof a.on&&"function"==typeof a.pause&&"function"==typeof a.resume}}},{}],15:[function(a,b,c){"use strict";function d(a){return"[object RegExp]"===Object.prototype.toString.call(a)}var e=a("./utf8"),f=a("./utils"),g=a("./stream/GenericWorker"),h=a("./stream/StreamHelper"),i=a("./defaults"),j=a("./compressedObject"),k=a("./zipObject"),l=a("./generate"),m=a("./nodejsUtils"),n=a("./nodejs/NodejsStreamInputAdapter"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),"string"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l="string"===e&&h.binary===!1&&h.base64===!1;c&&"undefined"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b="",h.compression="STORE",e="string");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){"/"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},q=function(a){return"/"!==a.slice(-1)&&(a+="/"),a},r=function(a,b){return b="undefined"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!==a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),"binarystring"===c.type&&(c.type="string"),!c.type)throw new Error("No output type specified.");f.checkSupport(c.type),"darwin"!==c.platform&&"freebsd"!==c.platform&&"linux"!==c.platform&&"sunos"!==c.platform||(c.platform="UNIX"),"win32"===c.platform&&(c.platform="DOS");var d=c.comment||this.comment||"";b=l.generateWorker(this,c,d)}catch(i){b=new g("error"),b.error(i)}return new h(b,c.type||"string",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type="nodebuffer"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(a,b,c){b.exports=a("stream")},{stream:void 0}],17:[function(a,b,c){"use strict";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],18:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a("../utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{"../utils":32}],19:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./Uint8ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],21:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./ArrayReader":17}],22:[function(a,b,c){"use strict";var d=a("../utils"),e=a("../support"),f=a("./ArrayReader"),g=a("./StringReader"),h=a("./NodeBufferReader"),i=a("./Uint8ArrayReader");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),"string"!==b||e.uint8array?"nodebuffer"===b?new h(a):e.uint8array?new i(d.transformTo("uint8array",a)):new f(d.transformTo("array",a)):new g(a)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],24:[function(a,b,c){"use strict";function d(a){e.call(this,"ConvertWorker to "+a),this.destType=a}var e=a("./GenericWorker"),f=a("../utils");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{"../utils":32,"./GenericWorker":28}],25:[function(a,b,c){"use strict";function d(){e.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}var e=a("./GenericWorker"),f=a("../crc32"),g=a("../utils");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(a,b,c){"use strict";function d(a){f.call(this,"DataLengthProbe for "+a),this.propName=a,this.withStreamInfo(a,0)}var e=a("../utils"),f=a("./GenericWorker");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{"../utils":32,"./GenericWorker":28}],27:[function(a,b,c){"use strict";function d(a){f.call(this,"DataWorker");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a("../utils"),f=a("./GenericWorker"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case"string":b=this.data.substring(this.index,c);break;case"uint8array":b=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{"../utils":32,"./GenericWorker":28}],28:[function(a,b,c){"use strict";function d(a){this.name=a||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit("data",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit("error",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit("error",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.end()}),a.on("error",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a="Worker "+this.name;return this.previous?this.previous+" -> "+a:a}},b.exports=d},{}],29:[function(a,b,c){"use strict";function d(a,b,c){switch(a){case"blob":return h.newBlob(h.transformTo("arraybuffer",b),c);case"base64":return k.encode(b);default:return h.transformTo(a,b)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case"string":return b.join("");case"array":return Array.prototype.concat.apply([],b);case"uint8array":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case"nodebuffer":return Buffer.concat(b);default:throw new Error("concat : unsupported type '"+a+"'")}}function f(a,b){return new m.Promise(function(c,f){var g=[],h=a._internalType,i=a._outputType,j=a._mimeType;a.on("data",function(a,c){g.push(a),b&&b(c)}).on("error",function(a){g=[],f(a)}).on("end",function(){try{var a=d(i,e(h,g),j);c(a)}catch(b){f(b)}g=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case"blob":case"arraybuffer":d="uint8array";break;case"base64":d="string"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j("error"),this._worker.error(e)}}var h=a("../utils"),i=a("./ConvertWorker"),j=a("./GenericWorker"),k=a("../base64"),l=a("../support"),m=a("../external"),n=null;if(l.nodestream)try{n=a("../nodejs/NodejsStreamOutputAdapter")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return"data"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new n(this,{objectMode:"nodebuffer"!==this._outputType},a)}},b.exports=g},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(a,b,c){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof Buffer,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:"application/zip"}).size}catch(e){try{var f=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob("application/zip").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a("readable-stream").Readable}catch(e){c.nodestream=!1}},{"readable-stream":16}],31:[function(a,b,c){"use strict";function d(){i.call(this,"utf-8 decode"),this.leftOver=null}function e(){i.call(this,"utf-8 encode")}for(var f=a("./utils"),g=a("./support"),h=a("./nodejsUtils"),i=a("./stream/GenericWorker"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBufferFrom(a,"utf-8"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo("nodebuffer",a).toString("utf-8"):(a=f.transformTo(g.uint8array?"uint8array":"array",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?"uint8array":"array",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(a,b,c){"use strict";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if("uint8array"===d?e=n.applyCanBeUsed.uint8array:"nodebuffer"===d&&(e=n.applyCanBeUsed.nodebuffer),e)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];
return b}var i=a("./support"),j=a("./base64"),k=a("./nodejsUtils"),l=a("core-js/library/fn/set-immediate"),m=a("./external");c.newBlob=function(a,b){c.checkSupport("blob");try{return new Blob([a],{type:b})}catch(d){try{var e=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)"array"===b||"nodebuffer"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join("")},stringifyByChar:function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.allocBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.allocBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:e,nodebuffer:function(a){return k.newBufferFrom(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":i.nodebuffer&&k.isBuffer(a)?"nodebuffer":i.uint8array&&a instanceof Uint8Array?"uint8array":i.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this platform")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&"undefined"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?("arraybuffer"===h?b=c.transformTo("uint8array",b):"string"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error("Can't read the data of '"+a+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"core-js/library/fn/set-immediate":36}],33:[function(a,b,c){"use strict";function d(a){this.files=[],this.loadOptions=a}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./signature"),h=a("./zipEntry"),i=(a("./utf8"),a("./support"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+f.pretty(b)+", expected "+f.pretty(a)+")")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?"uint8array":"array",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./compressedObject"),h=a("./crc32"),i=a("./utf8"),j=a("./compressions"),k=a("./support"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(b=n(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(a,b,c){"use strict";var d=a("./stream/StreamHelper"),e=a("./stream/DataWorker"),f=a("./utf8"),g=a("./compressedObject"),h=a("./stream/GenericWorker"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=null,c="string";try{if(!a)throw new Error("No output type specified.");c=a.toLowerCase();var e="string"===c||"text"===c;"binarystring"!==c&&"text"!==c||(c="string"),b=this._decompressWorker();var g=!this._dataBinary;g&&!e&&(b=b.pipe(new f.Utf8EncodeWorker)),!g&&e&&(b=b.pipe(new f.Utf8DecodeWorker))}catch(i){b=new h("error"),b.error(i)}return new d(b,c,"")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||"nodebuffer").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],k=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(a,b,c){a("../modules/web.immediate"),b.exports=a("../modules/_core").setImmediate},{"../modules/_core":40,"../modules/web.immediate":56}],37:[function(a,b,c){b.exports=function(a){if("function"!=typeof a)throw TypeError(a+" is not a function!");return a}},{}],38:[function(a,b,c){var d=a("./_is-object");b.exports=function(a){if(!d(a))throw TypeError(a+" is not an object!");return a}},{"./_is-object":51}],39:[function(a,b,c){var d={}.toString;b.exports=function(a){return d.call(a).slice(8,-1)}},{}],40:[function(a,b,c){var d=b.exports={version:"2.3.0"};"number"==typeof __e&&(__e=d)},{}],41:[function(a,b,c){var d=a("./_a-function");b.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},{"./_a-function":37}],42:[function(a,b,c){b.exports=!a("./_fails")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{"./_fails":45}],43:[function(a,b,c){var d=a("./_is-object"),e=a("./_global").document,f=d(e)&&d(e.createElement);b.exports=function(a){return f?e.createElement(a):{}}},{"./_global":46,"./_is-object":51}],44:[function(a,b,c){var d=a("./_global"),e=a("./_core"),f=a("./_ctx"),g=a("./_hide"),h="prototype",i=function(a,b,c){var j,k,l,m=a&i.F,n=a&i.G,o=a&i.S,p=a&i.P,q=a&i.B,r=a&i.W,s=n?e:e[b]||(e[b]={}),t=s[h],u=n?d:o?d[b]:(d[b]||{})[h];n&&(c=b);for(j in c)k=!m&&u&&void 0!==u[j],k&&j in s||(l=k?u[j]:c[j],s[j]=n&&"function"!=typeof u[j]?c[j]:q&&k?f(l,d):r&&u[j]==l?function(a){var b=function(b,c,d){if(this instanceof a){switch(arguments.length){case 0:return new a;case 1:return new a(b);case 2:return new a(b,c)}return new a(b,c,d)}return a.apply(this,arguments)};return b[h]=a[h],b}(l):p&&"function"==typeof l?f(Function.call,l):l,p&&((s.virtual||(s.virtual={}))[j]=l,a&i.R&&t&&!t[j]&&g(t,j,l)))};i.F=1,i.G=2,i.S=4,i.P=8,i.B=16,i.W=32,i.U=64,i.R=128,b.exports=i},{"./_core":40,"./_ctx":41,"./_global":46,"./_hide":47}],45:[function(a,b,c){b.exports=function(a){try{return!!a()}catch(b){return!0}}},{}],46:[function(a,b,c){var d=b.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=d)},{}],47:[function(a,b,c){var d=a("./_object-dp"),e=a("./_property-desc");b.exports=a("./_descriptors")?function(a,b,c){return d.f(a,b,e(1,c))}:function(a,b,c){return a[b]=c,a}},{"./_descriptors":42,"./_object-dp":52,"./_property-desc":53}],48:[function(a,b,c){b.exports=a("./_global").document&&document.documentElement},{"./_global":46}],49:[function(a,b,c){b.exports=!a("./_descriptors")&&!a("./_fails")(function(){return 7!=Object.defineProperty(a("./_dom-create")("div"),"a",{get:function(){return 7}}).a})},{"./_descriptors":42,"./_dom-create":43,"./_fails":45}],50:[function(a,b,c){b.exports=function(a,b,c){var d=void 0===c;switch(b.length){case 0:return d?a():a.call(c);case 1:return d?a(b[0]):a.call(c,b[0]);case 2:return d?a(b[0],b[1]):a.call(c,b[0],b[1]);case 3:return d?a(b[0],b[1],b[2]):a.call(c,b[0],b[1],b[2]);case 4:return d?a(b[0],b[1],b[2],b[3]):a.call(c,b[0],b[1],b[2],b[3])}return a.apply(c,b)}},{}],51:[function(a,b,c){b.exports=function(a){return"object"==typeof a?null!==a:"function"==typeof a}},{}],52:[function(a,b,c){var d=a("./_an-object"),e=a("./_ie8-dom-define"),f=a("./_to-primitive"),g=Object.defineProperty;c.f=a("./_descriptors")?Object.defineProperty:function(a,b,c){if(d(a),b=f(b,!0),d(c),e)try{return g(a,b,c)}catch(h){}if("get"in c||"set"in c)throw TypeError("Accessors not supported!");return"value"in c&&(a[b]=c.value),a}},{"./_an-object":38,"./_descriptors":42,"./_ie8-dom-define":49,"./_to-primitive":55}],53:[function(a,b,c){b.exports=function(a,b){return{enumerable:!(1&a),configurable:!(2&a),writable:!(4&a),value:b}}},{}],54:[function(a,b,c){var d,e,f,g=a("./_ctx"),h=a("./_invoke"),i=a("./_html"),j=a("./_dom-create"),k=a("./_global"),l=k.process,m=k.setImmediate,n=k.clearImmediate,o=k.MessageChannel,p=0,q={},r="onreadystatechange",s=function(){var a=+this;if(q.hasOwnProperty(a)){var b=q[a];delete q[a],b()}},t=function(a){s.call(a.data)};m&&n||(m=function(a){for(var b=[],c=1;arguments.length>c;)b.push(arguments[c++]);return q[++p]=function(){h("function"==typeof a?a:Function(a),b)},d(p),p},n=function(a){delete q[a]},"process"==a("./_cof")(l)?d=function(a){l.nextTick(g(s,a,1))}:o?(e=new o,f=e.port2,e.port1.onmessage=t,d=g(f.postMessage,f,1)):k.addEventListener&&"function"==typeof postMessage&&!k.importScripts?(d=function(a){k.postMessage(a+"","*")},k.addEventListener("message",t,!1)):d=r in j("script")?function(a){i.appendChild(j("script"))[r]=function(){i.removeChild(this),s.call(a)}}:function(a){setTimeout(g(s,a,1),0)}),b.exports={set:m,clear:n}},{"./_cof":39,"./_ctx":41,"./_dom-create":43,"./_global":46,"./_html":48,"./_invoke":50}],55:[function(a,b,c){var d=a("./_is-object");b.exports=function(a,b){if(!d(a))return a;var c,e;if(b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;if("function"==typeof(c=a.valueOf)&&!d(e=c.call(a)))return e;if(!b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;throw TypeError("Can't convert object to primitive value")}},{"./_is-object":51}],56:[function(a,b,c){var d=a("./_export"),e=a("./_task");d(d.G+d.B,{setImmediate:e.set,clearImmediate:e.clear})},{"./_export":44,"./_task":54}],57:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||"undefined"==typeof a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],58:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(d){c.status="error",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a("immediate"),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype["catch"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:57}],59:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":60,"./lib/inflate":61,"./lib/utils/common":62,"./lib/zlib/constants":65}],60:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":62,"./utils/strings":63,"./zlib/deflate":67,"./zlib/messages":72,"./zlib/zstream":74}],61:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":62,"./utils/strings":63,"./zlib/constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72,"./zlib/zstream":74}],62:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],63:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":62}],64:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0;
}b.exports=d},{}],65:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],66:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],67:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./messages":72,"./trees":73}],68:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],69:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],70:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}],71:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(;;){z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":62}],72:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],73:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,
c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":62}],74:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",[],function(){return saveAs})}
;
define("saveAs", function(){});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('Services/ExportToolCore',[
    "jquery",
    "underscore-min",
    "jszip",
    "saveAs",
    "../Gui/dialog/ErrorDialog",
    "../Utils/Constants"
], function($, _, JSZip, saveAs, ErrorDialog, Constants) {
    var self, mizarAPI, layers, availableLayers;

    /**************************************************************************************************************/

    /**
     *    Keep only layers having available searching services
     */
    function filterServicesAvailableOnLayers() {
        availableLayers = [];
        _.each(layers, function(layer) {
            if (
                layer.isVisible() &&
                layer.category !== "Other" &&
                layer.category !== "Solar System" &&
                layer.getName() !== "SAMP" &&
                layer.getName() !== "Planets"
            ) {
                layer.layerId = _.uniqueId("layer_");
                availableLayers.push(layer);
            }
        });
        return availableLayers;
    }

    /**************************************************************************************************************/

    /**
     * Export data included in the passed coordinates selection
     *
     * @param event.data = coordinates
     */
    function exportSelection(event) {
        self.coordinates = event.data;

        $("body").mask("Exporting data...");

        var JSZip = require("jszip");

        // creating empty archive
        var zip = new JSZip();

        // getting all visible and displayed layers
        var backgroundLayers = [];
        var dataLayers = [];
        _.each(availableLayers, function(layer) {
            if ($("#" + layer.layerId).is(":checked")) {
                if (
                    layer.getType() === Constants.LAYER.OpenSearch ||
                    layer.getType() === Constants.LAYER.GeoJSON
                ) {
                    //if (layer.type === "DynamicOpenSearch") {
                    dataLayers.push(layer);
                } else if (
                    layer.getType() === Constants.LAYER.Hips ||
                    layer.getType() === Constants.LAYER.HipsCat
                ) {
                    backgroundLayers.push(layer);
                }
            }
        });

        // Adding a middle point the bbox to be sure no data/image will be omitted
        var middlePoint = [
            (self.coordinates[0][1] + self.coordinates[1][1]) / 2,
            (self.coordinates[0][0] + self.coordinates[3][0]) / 2,
            0
        ];
        self.coordinates.push(middlePoint);

        // getting data url from layer using tile and bbox coordinates
        var tileLayerFeatures = [];
        _.each(dataLayers, function(dataLayer, index) {
            for (var i = 0; i < self.coordinates.length; i++) {
                var tile = mizarAPI
                    .getActivatedContext()
                    .getTileManager()
                    .getVisibleTile(
                        self.coordinates[i][0],
                        self.coordinates[i][1]
                    );

                if (_.isEmpty(tile)) {
                    return;
                }

                var osData = tile.extension[dataLayer.extId];

                if (!_.isEmpty(osData) && !_.isEmpty(osData.featureIds)) {
                    _.each(osData.featureIds, function(fId) {
                        var featureSet = dataLayer.featuresSet[fId];
                        if (!_.isEmpty(featureSet)) {
                            var feature = dataLayer.features[featureSet.index];

                            var isIncluded = true;
                            switch (feature.geometry.type) {
                                case Constants.GEOMETRY.Point:
                                    isIncluded = self.checkIfPointInBbox(
                                        feature.geometry.coordinates,
                                        self.coordinates
                                    );
                                    break;

                                case Constants.GEOMETRY.Polygon:
                                    for (
                                        var i = 0;
                                        i < feature.geometry.coordinates.length;
                                        i++
                                    ) {
                                        if (!isIncluded) {
                                            return;
                                        }
                                        isIncluded = self.checkIfPointInBbox(
                                            feature.geometry.coordinates[0][i],
                                            self.coordinates
                                        );
                                    }
                                    break;
                            }
                            if (isIncluded) {
                                // Adding layer information in order to rank data in archive
                                feature.parentInformation = {
                                    copyright: dataLayer.copyright || "",
                                    copyrightUrl: dataLayer.copyrightUrl || "",
                                    category: dataLayer.category,
                                    name: dataLayer.name
                                };
                                tileLayerFeatures.push(feature);
                            }
                        }
                    });
                }
            }
        });

        // Adding features archive
        _.each(tileLayerFeatures, function(feature) {
            var folder = zip.folder(
                feature.parentInformation.category +
                    "/" +
                    feature.parentInformation.name
            );

            // Adding a copyright file into each folder
            if (
                !_.isEmpty(feature.parentInformation.copyright) ||
                !_.isEmpty(feature.parentInformation.copyrightUrl)
            ) {
                var copyright =
                    "Copyright : " +
                    feature.parentInformation.copyright +
                    " - link : " +
                    feature.parentInformation.copyrightUrl;
                folder.file(feature.parentInformation.name + ".txt", copyright);
            }

            var featureToStringify = {
                geometry: {
                    coordinates: feature.geometry.coordinates,
                    gid: feature.geometry.gid,
                    type: feature.geometry.type,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                id: feature.id,
                properties: feature.properties,
                type: feature.type
            };

            folder.file(
                feature.properties.identifier + ".json",
                JSON.stringify(featureToStringify, null, "\t")
            );
        });

        if (backgroundLayers.length === 0) {
            self.downloadArchive(zip);
        } else {
            var numberOfImages = 0;
            var imageNotFound = false;
            // get images url from Background layer
            _.each(backgroundLayers, function(backgroundLayer, index) {
                backgroundLayer.urlImages = [];
                backgroundLayer.images = [];

                for (var i = 0; i < self.coordinates.length; i++) {
                    // Retrieve the tile according to a
                    var tile = mizarAPI
                        .getActivatedContext()
                        .getTileManager()
                        .getVisibleTile(
                            self.coordinates[i][0],
                            self.coordinates[i][1]
                        );

                    if (_.isEmpty(tile)) {
                        return;
                    }

                    numberOfImages++;
                    var url = backgroundLayer.getUrl(tile);

                    var image = new Image();
                    image.aborted = false;
                    image.crossOrigin = "";
                    image.backgroundName = backgroundLayer.name;
                    image.parentFolder =
                        backgroundLayer.category +
                        "/" +
                        backgroundLayer.name +
                        "/images";
                    image.imageName = url.substring(
                        url.lastIndexOf("/") + 1,
                        url.length
                    );

                    image.onload = function() {
                        self.addImageToArchive(this, zip);
                        numberOfImages--;

                        if (numberOfImages == 0) {
                            self.downloadArchive(zip);
                        }
                    };
                    image.onerror = function() {
                        imageNotFound = true;
                        console.dir(
                            "Error while retrieving image : " + this.imageName
                        );
                        numberOfImages--;
                        if (numberOfImages == 0) {
                            if (imageNotFound) {
                                ErrorDialog.open(
                                    "Some images not found. Change zoom level and retry downloading"
                                );
                            }

                            self.downloadArchive(zip);
                        }
                    };
                    image.src = url;
                }
            });
        }
    }

    /**************************************************************************************************************/

    /**
     * Create a zip file containing data + readme file and download it
     *
     * @param zip
     */
    function downloadArchive(zip) {
        var saveAs = require("saveAs");

        var date = new Date();
        var currentDate = $.datepicker.formatDate(
            "yy/mm/dd " + date.getHours() + ":" + date.getMinutes(),
            date
        );
        var readme =
            "Date : " +
            currentDate +
            "\n" +
            "Query :" +
            JSON.stringify(self.coordinates, null, "\t") +
            "\n" +
            "Copyright : Generated by MIZAR";

        zip.file("README.txt", readme);

        var content = zip.generate({ type: "blob" });
        saveAs(content, "archive_" + currentDate + ".zip");
        $("body").unmask();
    }

    /**************************************************************************************************************/

    /**
     * Check if given is included into the drawn bbox
     * @param point
     * @param bbox
     * @returns {boolean}
     */
    function checkIfPointInBbox(point, bbox) {
        if (
            point[1] >= bbox[0][1] &&
            point[1] <= bbox[1][1] &&
            (point[0] <= bbox[0][0] && point[0] >= bbox[3][0])
        ) {
            return true;
        } else {
            return false;
        }
    }

    /**************************************************************************************************************/

    /**
     * Add an image into the passed archive
     * @param img
     * @param zip
     */
    function addImageToArchive(img, zip) {
        var folder = zip.folder(img.parentFolder);
        folder.file(img.imageName, self.getBase64Image(img), { base64: true });
    }

    /**************************************************************************************************************/

    /**
     * Convert an image into base64
     * @param img
     * @returns {string}
     */
    function getBase64Image(img) {
        // Create an empty canvas element
        var canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;

        // Copy the image contents to the canvas
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // Get the data-URL formatted image
        // Firefox supports PNG and JPEG. You could check img.src to
        // guess the original format, but be aware the using "image/jpg"
        // will re-encode the image.
        var dataURL = canvas.toDataURL("image/png");

        return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
    }

    /**************************************************************************************************************/

    return {
        /**
         *    @constructor
         *    @param options Configuration options
         *        <ul>
         *            <li>planet: planet</li>
         *            <li>layers: Layers</li>
         *        </ul>
         */
        init: function(mizar, options) {
            // Required options
            mizarAPI = mizar;
            layers = mizarAPI.getLayers(Constants.CONTEXT.Sky);
            self = this;
        },
        exportSelection: exportSelection,
        addImageToArchive: addImageToArchive,
        downloadArchive: downloadArchive,
        getBase64Image: getBase64Image,
        filterServicesAvailableOnLayers: filterServicesAvailableOnLayers
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/AbstractNameResolver',[], function() {
    /**************************************************************************************************************/

    /**
     * @name AbstractNameResolverer
     * @class
     * Abstract Wrapper constructor
     * @param {Context} options - Context
     * @constructor
     * @implements {NameResolver}
     */
    var AbstractNameResolver = function(options) {
        this.ctx = options;
    };

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof AbstractNameResolver#
     * @abstract
     */
    AbstractNameResolver.prototype.handle = function(options) {
        throw new SyntaxError(
            "handle from NameResolver not implemented",
            "AbstractNameResolver.js"
        );
    };

    /**
     * @function remove
     * @memberof AbstractNameResolver#
     * @abstract
     */
    AbstractNameResolver.prototype.remove = function() {
        throw new SyntaxError(
            "remove from NameResolver not implemented",
            "AbstractNameResolver.js"
        );
    };

    /**************************************************************************************************************/

    return AbstractNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/DefaultNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver"
], function($, _, Utils, AbstractNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name DefaultNameResolver
     * @class
     *  Plugin to access to default name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     */
    var DefaultNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, DefaultNameResolver);

    /**************************************************************************************************************/

    /**
     * Convert passed url into an url understandable by the service (input transformer)
     * @function handle
     * @memberof DefaultNameResolver#
     */
    DefaultNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        var url =
            context.getMizarConfiguration().nameResolver.baseUrl +
            "/" +
            objectName +
            "/EQUATORIAL";
        $.ajax({
            type: "GET",
            url: url,
            success: function(response) {
                // Check if response contains features
                if (response.type === "FeatureCollection") {
                    var firstFeature = response.features[0];
                    var zoomToCallback = function() {
                        searchLayer(objectName, onSuccess, onError, response);
                    };
                    zoomTo(
                        firstFeature.geometry.coordinates[0],
                        firstFeature.geometry.coordinates[1],
                        null,
                        zoomToCallback,
                        response
                    );
                } else {
                    onError();
                }
            },
            error: function(xhr) {
                searchLayer(objectName, onSuccess, onError);
                console.error(xhr.responseText);
            },
            complete: function(xhr, textStatus) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        });
    };

    /**
     * @function remove
     * @memberof DefaultNameResolver#
     */
    DefaultNameResolver.prototype.remove = function() {};

    /**************************************************************************************************************/

    return DefaultNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Name resolver module : API allowing to search object name and zoom to it
 * @module NameResolver
 * @implements {NameResolver}
 */
define('NameResolver/CDSNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Utils/Utils",
    "./AbstractNameResolver"
], function($, _, Constants, Utils, AbstractNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name CDSNameResolver
     * @class
     *   Plugin to access to CDS name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     */
    var CDSNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, CDSNameResolver);

    /**************************************************************************************************************/

    /**
     * Queries CDS using this URL : http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?<i>objectName</i>
     * and the layers
     * @function handle
     * @memberof CDSNameResolver#
     */
    CDSNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        var url =
            "http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?" +
            objectName;
        $.ajax({
            type: "GET",
            url: url,
            dataType: "xml",
            success: function(xmlResponse) {
                var target = $(xmlResponse).find("Target");
                var name = $(target)
                    .find("name")
                    .text();
                var features = [];

                $(target)
                    .find("Resolver")
                    .each(function(index) {
                        var resolver = this;
                        var ra = $(resolver).find("jradeg");
                        var dec = $(resolver).find("jdedeg");

                        if (!_.isEmpty(ra.text()) && !_.isEmpty(dec.text())) {
                            ra = parseFloat(ra.text());
                            dec = parseFloat(dec.text());
                            var feature = {};
                            feature.ra = ra;
                            feature.dec = dec;
                            feature.credit = $(resolver).attr("name");
                            features.push(feature);
                        }
                    });

                var response = {
                    totalResults: features.length,
                    type: "FeatureCollection",
                    features: []
                };

                _.each(features, function(feature) {
                    response.features.push({
                        type: "Feature",
                        geometry: {
                            coordinates: [feature.ra, feature.dec],
                            type: Constants.GEOMETRY.Point,
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            identifier: "CDS0",
                            name: name,
                            credits:
                                'Powered by <a href="http://cdsweb.u-strasbg.fr/cgi-bin/Sesame">Sesame API</a> (' +
                                feature.credit +
                                ")"
                        }
                    });
                });

                // Check if response contains features
                if (
                    response.type === "FeatureCollection" &&
                    response.features.length > 0
                ) {
                    var firstFeature = response.features[0];
                    var zoomToCallback = function() {
                        searchLayer(objectName, onSuccess, onError, response);
                    };
                    zoomTo(
                        firstFeature.geometry.coordinates[0],
                        firstFeature.geometry.coordinates[1],
                        null,
                        Constants.CRS.Equatorial,
                        zoomToCallback,
                        response
                    );
                } else {
                    searchLayer(objectName, onSuccess, onError, response);
                }
            },
            error: function(xhr) {
                searchLayer(objectName, onSuccess, onError);
                console.error(xhr.responseText);
            },
            complete: function(xhr, textStatus) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        });
    };

    /**
     * @function remove
     * @memberof CDSNameResolver#
     */
    CDSNameResolver.prototype.remove = function() {};

    return CDSNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/DictionaryNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver",
    "../Layer/VectorLayer",
    "../Renderer/FeatureStyle",
    "../Utils/Constants"
], function(
    $,
    _,
    Utils,
    AbstractNameResolver,
    VectorLayer,
    FeatureStyle,
    Constants
) {
    var dictionary;

    /**
     * In case if base url isn't a service but a json containing all known places
     * this method allows to retrieve it
     */
    var retrieveDictionary = function(context) {
        var containsDictionary =
            context
                .getContextConfiguration()
                .nameResolver.baseUrl.indexOf("json") >= 0;
        if (containsDictionary) {
            // Dictionary as json
            var marsResolverUrl = context.getContextConfiguration().nameResolver
                .baseUrl; //.replace('mizar_gui', 'mizar_lite');
            $.ajax({
                type: "GET",
                dataType: "json",
                url: marsResolverUrl,
                success: function(response) {
                    dictionary = response;
                    //nameResolverLayer = new VectorLayer();
                    //for (var i = 0; i < response.features.length; i++) {
                    //    var feature = response.features[i];
                    //    feature.properties.style = new FeatureStyle({
                    //        label: feature.properties.Name,
                    //        fillColor: [1, 0.7, 0, 1]
                    //    });
                    //}
                    //nameResolverLayer.addFeatureCollection(response);
                    //context.globe.addLayer(nameResolverLayer);
                },
                error: function(thrownError) {
                    console.error(thrownError);
                }
            });
        } else {
            dictionary = null;
        }
    };

    /**************************************************************************************************************/
    /**
          @name DictionaryNameResolver
          @class
              Plugin to access to the dictionary name resolver
          @augments AbstractNameResolver
          @param {Context} options - Configuration properties
          @memberof module:NameResolver
          */
    var DictionaryNameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
        dictionary = retrieveDictionary(options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, DictionaryNameResolver);

    function _computeDistance(pt1, pt2) {
        var pt = [
            parseFloat(pt2[0]) - parseFloat(pt1[0]),
            parseFloat(pt2[1]) - parseFloat(pt1[1])
        ];
        return Math.sqrt(pt[0] * pt[0] + pt[1] * pt[1]);
    }

    function _farestDistance(center, pts) {
        var distance = 0;
        for (var i = 0; i < pts.length; i++) {
            var newDistance = _computeDistance.call(this, center, pts[i]);
            if (newDistance > distance) {
                distance = newDistance;
            }
        }
        return distance;
    }

    function _computeFarestDistanceAlongLineString(center, pts) {
        return _farestDistance.call(this, center, pts);
    }

    function _addPoint(p1, p2) {
        return [
            parseFloat(p1[0]) + parseFloat(p2[0]),
            parseFloat(p1[1]) + parseFloat(p2[1])
        ];
    }

    function _computeLineStringBarycenter(pts) {
        var center = pts[0];
        for (var i = 1; i < pts.length; i++) {
            center = _addPoint.call(this, center, pts[i]);
        }
        center = [center[0] / pts.length, center[1] / pts.length];
        return center;
    }

    function _computeBarycenterAndDistance(geometry) {
        var type = geometry.type;
        var coordinates = geometry.coordinates;
        var center;
        var distance;
        var nbPts = null;
        var tmpCenter = null;
        var newDistance = null;
        switch (type) {
            case "Point":
                center = coordinates;
                distance = null;
                break;
            case "LineString":
                center = _computeLineStringBarycenter.call(this, coordinates);
                distance = _computeFarestDistanceAlongLineString.call(
                    this,
                    center,
                    coordinates
                );
                break;
            case "Polygon":
                var exteriorRing = coordinates[0];
                center = _computeLineStringBarycenter.call(this, exteriorRing);
                distance = _computeFarestDistanceAlongLineString.call(
                    this,
                    center,
                    exteriorRing
                );
                break;
            case "MultiPoint":
                center = _computeLineStringBarycenter.call(this, coordinates);
                distance = _computeFarestDistanceAlongLineString.call(
                    this,
                    center,
                    coordinates
                );
                break;
            case "MultiLineString":
                var lineStringArray = coordinates[0];
                center = _computeLineStringBarycenter.call(
                    this,
                    lineStringArray[0]
                );
                center[0] = center[0] * lineStringArray[0].length;
                center[1] = center[1] * lineStringArray[0].length;
                nbPts = 0;
                for (var i = 1; i < lineStringArray.length; i++) {
                    tmpCenter = _computeLineStringBarycenter.call(
                        this,
                        lineStringArray[i]
                    );
                    tmpCenter[0] = tmpCenter[0] * lineStringArray[i].length;
                    tmpCenter[1] = tmpCenter[1] * lineStringArray[i].length;
                    nbPts = nbPts + lineStringArray[i].length;
                    center = _addPoint(center, tmpCenter);
                }
                center[0] = center[0] / nbPts;
                center[1] = center[1] / nbPts;

                distance = 0;
                for (i = 0; i < lineStringArray.length; i++) {
                    newDistance = _farestDistance.call(
                        this,
                        center,
                        lineStringArray[i]
                    );
                    if (newDistance > distance) {
                        distance = newDistance;
                    }
                }
                break;
            case "MultiPolygon":
                var polygonArray = coordinates[0];
                center = _computeLineStringBarycenter.call(
                    this,
                    polygonArray[0][0]
                );
                center[0] = center[0] * polygonArray[0][0].length;
                center[1] = center[1] * polygonArray[0][0].length;
                nbPts = 0;
                for (i = 1; i < polygonArray.length; i++) {
                    tmpCenter = _computeLineStringBarycenter.call(
                        this,
                        lineStringArray[i][0]
                    );
                    tmpCenter[0] = tmpCenter[0] * lineStringArray[i][0].length;
                    tmpCenter[1] = tmpCenter[1] * lineStringArray[i][0].length;
                    nbPts = nbPts + lineStringArray[i][0].length;
                    center = _addPoint.call(this, center, tmpCenter);
                }
                center[0] = center[0] / nbPts;
                center[1] = center[1] / nbPts;
                distance = 0;
                for (i = 0; i < polygonArray.length; i++) {
                    newDistance = _farestDistance.call(
                        this,
                        center,
                        polygonArray[i][0]
                    );
                    if (newDistance > distance) {
                        distance = newDistance;
                    }
                }
                break;
            default:
                throw "geometry " + type + " is not supported";
        }
        return [center, distance];
    }

    /**
     * Queries the GeoJSON passed in parameter in the Mizar options
     * @function handle
     * @memberof DictionaryNameResolver#
     */
    DictionaryNameResolver.prototype.handle = function(options) {
        var context = this.ctx;
        var crs = this.ctx.getCoordinateSystem();
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;

        // Planet resolver(Mars only currently)
        var feature = _.find(dictionary.features, function(f) {
            var name =
                f.properties.Name == undefined
                    ? f.properties.name
                    : f.properties.Name;
            var isFound;
            if (name == null) {
                isFound = false;
            } else {
                isFound = name.toLowerCase() === objectName.toLowerCase();
            }
            return isFound;
        });

        if (feature) {
            var lon;
            var lat;
            var distance;
            if (
                feature.properties.center_lon == undefined ||
                feature.properties.center_lat == undefined
            ) {
                var centerAndDistance = _computeBarycenterAndDistance.call(
                    this,
                    feature.geometry
                );
                lon = parseFloat(centerAndDistance[0][0]);
                lat = parseFloat(centerAndDistance[0][1]);
                distance = centerAndDistance[1];
            } else {
                lon = parseFloat(feature.properties.center_lon);
                lat = parseFloat(feature.properties.center_lat);
                distance = null;
            }

            feature.geometry.crs = {
                type: "name",
                properties: {
                    name: context.getCoordinateSystem().getGeoideName()
                }
            };
            var zoomToCallback = function() {
                searchLayer(objectName, onSuccess, onError, {
                    features: [feature]
                });
            };

            var fov = context.getRenderContext().getFov();

            var distanceCamera;
            if (distance == null) {
                distanceCamera = null;
            } else {
                distance = distance > 180.0 ? 180.0 : distance;
                // aproximation of the distance in meters
                distance =
                    (2 *
                        Math.PI *
                        crs.getGeoide().getRealPlanetRadius() *
                        distance) /
                    360;
                distanceCamera =
                    distance / Math.tan((0.5 * fov * Math.PI) / 180);
            }

            zoomTo(
                lon,
                lat,
                distanceCamera,
                crs.getGeoideName(),
                zoomToCallback,
                { features: [feature] }
            );
        } else {
            searchLayer(objectName, onSuccess, onError);
        }
    };

    /**
     * Code to execute when remove
     * @function remove
     * @memberof DictionaryNameResolver#
     */
    DictionaryNameResolver.prototype.remove = function() {
        dictionary = null;
    };

    return DictionaryNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/IMCCENameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractNameResolver",
    "../Utils/Constants"
], function($, _, Utils, AbstractNameResolver, Constants) {
    /**************************************************************************************************************/

    /**
     * @name IMCCENameResolver
     * @class
     *     Plugin to access to IMCCE name resolver
     * @augments AbstractNameResolver
     * @param {Context} options - Context
     * @memberof module:NameResolver
     */
    var IMCCENameResolver = function(options) {
        AbstractNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractNameResolver, IMCCENameResolver);

    /**************************************************************************************************************/

    /**
     * Queries SSODnet using this URL https://api.ssodnet.imcce.fr/quaero/1/sso?q=<i>objectName</i>
     * and the layers
     * @function handle
     * @memberof IMCCENameResolver#
     */
    IMCCENameResolver.prototype.handle = function(options) {
        var objectName = options.objectName;
        var onError = options.onError;
        var onComplete = options.onComplete;
        var onSuccess = options.onSuccess;
        var searchLayer = options.searchLayer;
        var zoomTo = options.zoomTo;
        var url =
            "https://api.ssodnet.imcce.fr/quaero/1/sso?q=" +
            objectName +
            "&from=Mizar";
        $.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            success: function(jsonResponse) {
                var data = jsonResponse.data;
                parseResponse(data, createsGeoJsonResponse);

                function parseResponse(data, callback) {
                    var features = [];
                    var i = 0;
                    var dataLength = data.length;
                    if (dataLength === 0) {
                        onError();
                    } else {
                        _.each(data, function(data) {
                            parseItem(data, function(feature) {
                                i++;
                                if (!_.isEmpty(feature)) {
                                    features.push(feature);
                                }
                                if (i === dataLength) {
                                    callback(features);
                                }
                            });
                        });
                    }
                }

                function parseItem(data, callback) {
                    var type = data.type;
                    var id = data.id;
                    var name = data.name;
                    if (
                        $.inArray(type, [
                            "Planet",
                            "Asteroid",
                            "Satellite",
                            "Star",
                            "Comet"
                        ]) !== -1
                    ) {
                        var url =
                            "https://api.ssodnet.imcce.fr/quaero/1/sso/" +
                            id +
                            "/resolver";
                        $.ajax({
                            type: "GET",
                            url: url,
                            dataType: "json",
                            success: function(data) {
                                var coordinates = data.geometry.coordinates;
                                var ra = (coordinates[0] * 360) / 24;
                                var dec = coordinates[1];
                                if (_.isNumber(ra) && _.isNumber(dec)) {
                                    ra = parseFloat(ra);
                                    dec = parseFloat(dec);
                                    var feature = {};
                                    feature.ra = ra;
                                    feature.dec = dec;
                                    feature.credits =
                                        'Powered by <a href="http://vo.imcce.fr/webservices/ssodnet/?quaero" target="_blank">SsODNet/Quaero API</a>.';
                                    feature.id = id;
                                    feature.type = type;
                                    feature.name = name;
                                    callback(feature);
                                }
                            },
                            error: function(xhr) {
                                //TODO : Network problem
                                console.error(xhr.responseText);
                            }
                        });
                    } else {
                        callback();
                    }
                }

                function createsGeoJsonResponse(features) {
                    var response = {
                        totalResults: features.length,
                        type: "FeatureCollection",
                        features: []
                    };
                    _.each(features, function(feature) {
                        response.features.push({
                            type: "Feature",
                            geometry: {
                                coordinates: [feature.ra, feature.dec],
                                type: "Point",
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                identifier: feature.id,
                                type: feature.type,
                                name: feature.name,
                                credits: feature.credits
                            }
                        });
                    });
                    if (
                        response.type === "FeatureCollection" &&
                        response.features.length > 0
                    ) {
                        var firstFeature = response.features[0];
                        var zoomToCallback = function() {
                            searchLayer(
                                objectName,
                                onSuccess,
                                onError,
                                response
                            );
                        };
                        zoomTo(
                            firstFeature.geometry.coordinates[0],
                            firstFeature.geometry.coordinates[1],
                            null,
                            Constants.CRS.Equatorial,
                            zoomToCallback,
                            response
                        );
                    } else {
                        onError();
                    }
                }
            },
            error: function(xhr) {
                searchLayer(objectName, onSuccess, onError);
                if (onError) {
                    //TODO : network problem
                }
                console.error(xhr.responseText);
            },
            complete: function(xhr) {
                if (onComplete) {
                    onComplete(xhr);
                }
            }
        });
    };

    /**
     * @function remove
     * @memberof IMCCENameResolver#
     */
    IMCCENameResolver.prototype.remove = function() {};

    return IMCCENameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NameResolver
 * @class
 * Name resolver
 * @memberof module:NameResolver
 */
define('NameResolver/NameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Renderer/FeatureStyle",
    "../Layer/VectorLayer",
    "../Tiling/HEALPixBase",
    "./DefaultNameResolver",
    "jquery.ui",
    "./CDSNameResolver",
    "./DictionaryNameResolver",
    "./IMCCENameResolver"
], function (
    $,
    _,
    Constants,
    FeatureStyle,
    VectorLayer,
    HEALPixBase,
    DefaultNameResolver
) {
        /**
         * plugin:not_found.<br/>
         * Called when no plugin is found whereas it is requested
         * @event NameResolver#plugin:not_found
         * @type {string}
         */

        // Name resolver globals
        var mizarAPI;
        var context;

        // Name resolver properties
        var duration;
        var zoomFov;
        var targetLayer; // Layer containing target feature(cross) on zoom
        var targetFeature; // Zooming destination feature

        //Wrapper Object
        var nameResolverImplementation = null;

        /**************************************************************************************************************/

        /**
         *    Update targetFeature and add it to the target layer
         *
         *    @param lon Destination longitude/right ascension in degrees
         *    @param lat Destination latitude/declination in degrees
         *    @param crs coordinate reference system of the (longitude,latitude)
         */
        function addTarget(lon, lat, crs) {
            targetFeature = {
                geometry: {
                    coordinates: [lon, lat],
                    type: Constants.GEOMETRY.Point,
                    crs: {
                        type: "name",
                        properties: {
                            name: crs
                        }
                    }
                },
                type: "Feature"
            };

            targetLayer.addFeature(targetFeature);
        }

        function zoomToHips(matchHealpix, onSuccess) {
            var order = parseInt(matchHealpix[1], 10);
            var pixelIndex = parseInt(matchHealpix[2], 10);

            // Compute vertices
            var nside = Math.pow(2, order);
            /*jslint bitwise: true */
            var pix = pixelIndex & (nside * nside - 1);
            var ix = HEALPixBase.compress_bits(pix);
            /*jslint bitwise: true */
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            /*jslint bitwise: true */
            var face = pixelIndex >>> (2 * order);

            var i = 0.5;
            var j = 0.5;
            var vert = HEALPixBase.fxyf((ix + i) / nside, (iy + j) / nside, face);
            var geoPos = [];
            mizarAPI.getCrs().getWorldFrom3D(vert, geoPos);
            zoomTo(
                geoPos[0],
                geoPos[1],
                null,
                mizarAPI.getCrs().getGeoideName(),
                onSuccess
            );
        }

        function zoomToSexagesimal(coordinates, onSuccess) {
            // Format to equatorial coordinates
            var word = coordinates.split(" "); // [RA, Dec]

            word[0] = word[0].replace(/h|m|:/g, " ");
            word[0] = word[0].replace("s", "");
            word[1] = word[1].replace(/|'|:/g, " ");
            word[1] = word[1].replace('"', "");

            // Convert to geo and zoom
            var geoPos = [];
            mizarAPI
                .getCrs()
                .getDecimalDegFromSexagesimal([word[0], word[1]], geoPos);
            zoomTo(
                geoPos[0],
                geoPos[1],
                null,
                mizarAPI.getCrs().getGeoideName(),
                onSuccess
            );
        }

        function zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound) {
            var currentGeoBound = mizarAPI.getCrs().getGeoBound();
            var lon = parseFloat(matchDegree[1]);
            var lat = parseFloat(matchDegree[3]);
            var geo = [lon, lat];
            if (currentGeoBound.isPointInside(geo)) {
                zoomTo(
                    geo[0],
                    geo[1],
                    null,
                    mizarAPI.getCrs().getGeoideName(),
                    onSuccess
                );
            } else {
                onErrorOutOfBound.call(this);
            }
        }

        /**************************************************************************************************************/
        /**
         *    Search for object name
         *    Object name could be:
         *        * Degree in "HMS DMS" or "deg deg"
         *        * Object name as "Mars", "m31", "Mizar"
         *        * For debug : healpix(order,pixelIndex)
         *    @fires NameResolver#plugin:not_found
         */
        function search(
            objectName,
            onSuccess,
            onError,
            onErrorOutOfBound,
            onComplete
        ) {
            var geoPos;
            // regexp used only to distinct equatorial coordinates and objects
            // TODO more accurate ( "x < 24h", "x < 60mn", etc.. )
            objectName = objectName.replace(/\s{2,}/g, " "); // Replace multiple spaces by a single one
            var coordinatesExp = new RegExp(
                "\\d{1,2}[h|:]\\d{1,2}[m|:]\\d{1,2}([\\.]\\d+)?s?\\s[-+]?[\\d]+[|:]\\d{1,2}['|:]\\d{1,2}([\\.]\\d+)?\"?",
                "g"
            );
            var healpixRE = /^healpix\((\d)+,(\d+)\)/;
            var degRE = /^(-?\d+(\.\d+)?),?\s(-?\d+(\.\d+)?)/;
            var layerRE = /^layer:(.)*?/;
            var matchHealpix = healpixRE.exec(objectName);
            var matchDegree = degRE.exec(objectName);
            var matchLayer = layerRE.exec(objectName);
            if (matchHealpix) {
                zoomToHips(matchHealpix, onSuccess);
            } else if (objectName.match(coordinatesExp)) {
                zoomToSexagesimal(objectName, coordinatesExp, onSuccess);
            } else if (matchDegree) {
                zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound);
            } else {
                var options = {
                    objectName: objectName,
                    onError: onError,
                    onComplete: onComplete,
                    onSuccess: onSuccess,
                    searchLayer: searchLayer,
                    zoomTo: zoomTo
                };

                if (nameResolverImplementation) {
                    nameResolverImplementation.handle(options);
                } else {
                    mizarAPI.publish(
                        Constants.EVENT_MSG.PLUGIN_NOT_FOUND,
                        "No name resolver found"
                    );
                }
            }
        }

        function searchLayer(objectName, onSuccess, onError, response) {
            var layers = mizarAPI.searchOnLayerDescription(
                objectName,
                mizarAPI.getActivatedContext().getMode()
            );
            if (layers.length === 0 && (!response || response.totalResults === 0)) {
                if (onError) {
                    onError();
                }
                return;
            }

            layers = _.sortBy(layers, function (layer) {
                return layer.category === "background" ? 0 : 1;
            });

            var results;
            // Check if response contains features
            if (response && response.type === "FeatureCollection") {
                results = response;
            } else {
                results = {};
                results.type = "FeatureCollection";
                results.features = [];
            }

            _.each(layers, function (layer) {
                results.features.push({
                    type: "Feature",
                    properties: {
                        type: "layer",
                        name: layer.getName(),
                        description: layer.getDescription(),
                        layerType: layer.getType(),
                        visible: layer.isVisible(),
                        background: layer.category === "background"
                    }
                });
            });

            onSuccess(results);
        }

        /**************************************************************************************************************/

        /**
         *    Zoom to the given longitude/latitude and add target at the end
         *    @param lon Longitude
         *    @param lat Latitude
         *    @param distanceCamera Final Distance in meters from the ground to the camera - only use for PlanetContext / set to null for the others contexts
         *    @param crs coordinate reference system of the (longitude, latitude)
         *    @param callback Callback once animation is over
         *    @param args Callback arguments
         */
        function zoomTo(lon, lat, distanceCamera, crs, callback, args) {
            if (args !== null && typeof args !== "undefined") {
                // updates the coordinates, which is displayed at the screen in the current CRS
                var idx = 0;
                while (idx < args.features.length) {
                    args.features[
                        idx
                    ].geometry.coordinates = mizarAPI
                        .getCrs()
                        .convert(
                            args.features[idx].geometry.coordinates,
                            crs,
                            mizarAPI.getCrs().getGeoideName()
                        );
                    args.features[idx].geometry.crs.properties.name = crs;
                    idx++;
                }
            }

            // Add target feature on animation stop
            var addTargetCallback = function () {
                addTarget(lon, lat, crs);
                if (callback) {
                    callback.call(this, args);
                }
            };
            var position = mizarAPI
                .getCrs()
                .convert([lon, lat], crs, mizarAPI.getCrs().getGeoideName());
            if (
                mizarAPI.getActivatedContext().getMode() === Constants.CONTEXT.Sky
            ) {
                mizarAPI
                    .getActivatedContext()
                    .getNavigation()
                    .zoomTo(position, {
                        fov: zoomFov,
                        duration: duration,
                        callback: addTargetCallback
                    });
            } else {
                var distance =
                    distanceCamera == null
                        ? mizarAPI
                            .getActivatedContext()
                            .getNavigation()
                            .getDistance()
                        : distanceCamera;
                mizarAPI
                    .getActivatedContext()
                    .getNavigation()
                    .zoomTo([lon, lat], {
                        distance: distance,
                        duration: duration,
                        callback: addTargetCallback
                    });
            }
        }

        /**************************************************************************************************************/

        /**
         *    Delete target image
         */
        function removeTarget() {
            if (targetFeature) {
                targetLayer.removeFeature(targetFeature);
                targetFeature = null;
            }
        }

        /**************************************************************************************************************/

        /**************************************************************************************************************/

        return {
            /**
             * Init name resolver
             * @param {Mizar} m - Mizar API
             * @alias module:NameResolver.NameResolver.init
             */
            init: function (m) {
                if (!context) {
                    mizarAPI = m;
                    this.setContext(mizarAPI.getActivatedContext());
                } else {
                    console.error("Name resolver is already initialized");
                }
            },

            /**
             * Unregisters all event handlers
             * @alias module:NameResolver.NameResolver.remove
             */
            remove: function () {
                if (context) {
                    mizarAPI.getActivatedContext().removeDraw(targetLayer);
                    if (nameResolverImplementation !== undefined) {
                        nameResolverImplementation.remove();
                    }
                    mizarAPI
                        .getActivatedContext()
                        .unsubscribe(
                            Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                            removeTarget
                        );
                    context = null;
                }
            },

            /**
             *    Search for object name
             *    Object name could be:
             *    <ul>
             *        <li>Degree in "HMS DMS" or "deg deg"</li>
             *        <li>Object name as "Mars", "m31", "Mizar"</li>
             *        <li>For debug : healpix(order,pixelIndex)</li>
             *    </ul>
             *    @alias module:NameResolver.NameResolver.goTo
             *    @fires Mizar#plugin:not_found
             */
            goTo: search,

            /**
             *    Zoom to the given longitude/latitude and add target at the end
             *    @param lon Longitude
             *    @param lat Latitude
             *    @param crs coordinate reference system of the (longitude, latitude)
             *    @param callback Callback once animation is over
             *    @param args Callback arguments
             *    @alias module:NameResolver.NameResolver.zoomTo
             */
            zoomTo: zoomTo,

            /**
             *    Set context
             *    @alias module:NameResolver.NameResolver.setContext
             *    @listens Context#modifiedNavigation
             */
            setContext: function (ctx) {
                // Remove previous context
                this.remove();
                context = ctx;

                //instantiate name resolver nameResolverImplementation object
                var isDefaultNameResolver;
                var nameResolverClass;
                if (
                    typeof context.getContextConfiguration().nameResolver !==
                    "undefined"
                ) {
                    nameResolverClass = require(context.getContextConfiguration()
                        .nameResolver.jsObject);
                    isDefaultNameResolver = false;
                    nameResolverImplementation = new nameResolverClass(context);
                } else {
                    //Use default name resolver if none defined...
                    isDefaultNameResolver = true;
                    nameResolverImplementation = new DefaultNameResolver(context);
                }

                var style = new FeatureStyle({
                    iconUrl:
                        ctx.getMizarConfiguration().mizarBaseUrl +
                        "css/images/target.png",
                    fillColor: [1, 1, 1, 1]
                });
                targetLayer = new VectorLayer({ style: style, visible: true });

                mizarAPI.getActivatedContext().addDraw(targetLayer);

                // Update name resolver properties
                if (isDefaultNameResolver) {
                    duration = 3000;
                    zoomFov = 15;
                } else {
                    duration =
                        context.getContextConfiguration().nameResolver.duration ||
                        3000;
                    zoomFov =
                        context.getContextConfiguration().nameResolver.zoomFov ||
                        15;
                }

                ctx.subscribe(
                    Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                    removeTarget
                );
            }
        };
    });

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('ReverseNameResolver/AbstractReverseNameResolver',[], function() {
    /**************************************************************************************************************/

    /**
     *   Abstract Wrapper constructor
     *   @param {Context} options - context
     *   @constructor
     *   @implements {ReverseNameResolver}
     */
    var AbstractReverseNameResolver = function(options) {
        this.ctx = options;
    };

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof AbstractReverseNameResolver#
     * @abstract
     */
    AbstractReverseNameResolver.prototype.handle = function() {
        throw new SyntaxError(
            "handle from AbstractReverseNameResolver not implemented",
            "AbstractReverseNameResolver.js"
        );
    };

    /**
     * @function remove
     * @memberof AbstractReverseNameResolver#
     * @abstract
     */
    AbstractReverseNameResolver.prototype.remove = function() {
        throw new SyntaxError(
            "remove from AbstractReverseNameResolver not implemented",
            "AbstractReverseNameResolver.js"
        );
    };

    /**************************************************************************************************************/

    ///**
    // *    Extract HealpixId, order from url
    // */
    //AbstractReverseNameResolver.prototype.extractFilters = function (url) {
    //    var filtersUrl = url.substring(url.indexOf('?') + 1, url.length);
    //
    //    var filtersParts = filtersUrl.split('&');
    //
    //    var startOrder, startHealpixID;
    //    var order, healpixID;
    //    _.each(filtersParts, function (part) {
    //
    //        var keyAndValue = part.split('=');
    //
    //        if (keyAndValue[0] === "order") {
    //            order = keyAndValue[1];
    //        }
    //        if (keyAndValue[0] === "healpix") {
    //            healpixID = keyAndValue[1];
    //        }
    //    });
    //
    //    return this.filters = {
    //        "healpixID": healpixID,
    //        "order": order
    //    };
    //};

    return AbstractReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('ReverseNameResolver/DefaultReverseNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractReverseNameResolver"
], function($, _, Utils, AbstractReverseNameResolver) {
    /**************************************************************************************************************/

    /**
     * @name DefaultReverseNameResolver
     * @class
     *   Plugin to access to Default reverse name resolver
     * @augments AbstractReverseNameResolver
     * @param {Context} options - Context
     * @memberof module:ReverseNameResolver
     */
    var DefaultReverseNameResolver = function(options) {
        AbstractReverseNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractReverseNameResolver, DefaultReverseNameResolver);

    /**************************************************************************************************************/

    /**
     * @function handle
     * @memberof DefaultReverseNameResolver#
     * @param {Object} options
     */
    DefaultReverseNameResolver.prototype.handle = function(options) {
        var self = this;

        var maxOrder = options.maxOrder;
        var equatorialCoordinates = options.equatorialCoordinates;
        var context = options.context;

        var requestUrl =
            context.getMizarConfiguration().reverseNameResolver.baseUrl +
            "/EQUATORIAL/" +
            equatorialCoordinates[0] +
            " " +
            equatorialCoordinates[1] +
            ";" +
            maxOrder;

        $.ajax({
            type: "GET",
            url: requestUrl,
            success: function(response) {
                if (options && options.success) {
                    options.success(response);
                }
            },
            error: function(xhr, ajaxOptions, thrownError) {
                if (options && options.error) {
                    options.error(xhr);
                }
            }
        });
    };

    /**
     * @function remove
     * @memberof DefaultReverseNameResolver#
     */
    DefaultReverseNameResolver.prototype.remove = function(options) {};

    /**************************************************************************************************************/

    return DefaultReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Reverse Name resolver module : API allowing to retrieve information from a geo picking
 * @module ReverseNameResolver
 * @implements {ReverseNameResolver}
 */
define('ReverseNameResolver/CDSReverseNameResolver',[
    "jquery",
    "underscore-min",
    "../Utils/Constants",
    "../Utils/Utils",
    "./AbstractReverseNameResolver",
    "../Tiling/HEALPixBase"
], function($, _, Constants, Utils, AbstractReverseNameResolver, HEALPixBase) {
    /**************************************************************************************************************/

    var HOUR_TO_DEG = 15.0;
    var lastCallTime = null;
    var callTimeInterval = 6000;

    /**
     * @name CDSReverseNameResolver
     * @class
     *   Plugin to access to CDS reverse name resolver
     * @augments AbstractReverseNameResolver
     * @param {Context} options - Context
     * @memberof module:ReverseNameResolver
     */
    var CDSReverseNameResolver = function(options) {
        AbstractReverseNameResolver.prototype.constructor.call(this, options);
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractReverseNameResolver, CDSReverseNameResolver);

    /**************************************************************************************************************/

    /**
     * Queries the CDS reverse name resolver
     * @function handle
     * @memberof CDSReverseNameResolver#
     * @param {Object} options - parameters
     * @param {int} options.maxOrder - Max Hips order
     * @param {float[]} options.pos - position
     * @param {Mizar} options.mizarAPI - mizar API
     * @param {Function} options.error - error function
     * @param {Function} options.success - success function
     */
    CDSReverseNameResolver.prototype.handle = function(options) {
        //Do not call the service to often
        var now = Date.now();
        var diff = now - callTimeInterval;
        if (lastCallTime !== null && diff <= lastCallTime) {
            if (options && options.error) {
                options.error({
                    status: 503
                });
            }
            return;
        }

        var self = this;

        var maxOrder = options.maxOrder;
        var pos = options.pos;
        var mizarAPI = options.mizarAPI;
        pos = mizarAPI
            .getCrs()
            .convert(
                pos,
                mizarAPI.getCrs().getGeoideName(),
                Constants.CRS.Equatorial
            );

        var equatorialCoordinates = [];
        mizarAPI.getCrs().getSexagesimalFromDeg(pos, equatorialCoordinates);

        // Format to equatorial coordinates
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("h ", ":");
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("m ", ":");
        equatorialCoordinates[0] = equatorialCoordinates[0].replace("s", "");

        equatorialCoordinates[1] = equatorialCoordinates[1].replace(" ", ":");
        equatorialCoordinates[1] = equatorialCoordinates[1].replace("' ", ":");
        equatorialCoordinates[1] = equatorialCoordinates[1].replace('"', "");

        //BEGINING OF SPECIFIC PROCESSING
        //DO IT WITHOUT REQUESTING SITOOLS
        /**
         * Arsec 2 degree conversion.
         */
        var ARCSEC_2_DEG = 1 / 3600.0;
        /**
         * MAX radius of a cone in arcsec.
         */
        var MAX_RADIUS = 1800.0;

        var nside = Math.pow(2, maxOrder);

        var pixRes = HEALPixBase.getPixRes(nside);
        var radius = pixRes > MAX_RADIUS ? MAX_RADIUS : pixRes / 2;
        radius *= ARCSEC_2_DEG;

        var requestUrl = mizarAPI
            .getActivatedContext()
            .getContextConfiguration().reverseNameResolver.baseUrl;

        requestUrl = requestUrl.replace(
            "{coordinates}",
            equatorialCoordinates[0] + " " + equatorialCoordinates[1]
        );
        requestUrl = requestUrl.replace("{radius}", radius);

        $.ajax({
            type: "GET",
            url: requestUrl,
            success: function(response) {
                lastCallTime = Date.now();

                // we parse the message that is returned by the server
                var posParenthesis = response.indexOf("(");
                var posComma = response.indexOf(",");
                var posSlash = response.indexOf("/");
                var position = response.substring(0, posSlash);
                var name = response.substring(posSlash + 1, posParenthesis);

                var magnitude = parseFloat(
                    response.substring(posParenthesis + 1, posComma)
                );
                var objectType = response.substring(
                    posComma + 1,
                    response.length - 2
                );

                var positionElts = position.split(" ");

                //GET HMS
                var hours = parseFloat(positionElts[0]);
                var min = parseFloat(positionElts[1]);
                var sec = parseFloat(positionElts[2]);

                var degrees = parseFloat(positionElts[3]);
                var min2 = parseFloat(positionElts[4]);
                var sec2 = parseFloat(positionElts[5]);

                var ra = self._parseRa(hours, min, sec);
                var dec = self._parseDec(degrees, min2, sec2);

                var features = {
                    totalResults: 1,
                    type: "FeatureCollection",
                    features: [
                        {
                            type: "Feature",
                            geometry: {
                                coordinates: [ra, dec],
                                type: Constants.GEOMETRY.Point,
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                title: name,
                                magnitude: magnitude,
                                credits: "CDS",
                                seeAlso:
                                    "http://simbad.u-strasbg.fr/simbad/sim-id?Ident=" +
                                    name,
                                type: objectType,
                                identifier: name
                            }
                        }
                    ]
                };

                if (options && options.success) {
                    options.success(features);
                }
                //END OF SPECIFIC PROCESSING
            },
            error: function(xhr, ajaxOptions, thrownError) {
                if (options && options.error) {
                    options.error(xhr);
                }
            }
        });
    };

    /**
     * Parse RA.
     * @function _parseRa
     * @memberof CDSReverseNameResolver#
     * @param hours
     * @param min
     * @param sec
     * @returns {number}
     * @private
     */
    CDSReverseNameResolver.prototype._parseRa = function(hours, min, sec) {
        var intHours = parseInt(hours, 10);
        var val = (sec / 60.0 + min) / 60.0;

        if (hours < 0.0 || parseFloat(hours) === -0.0) {
            val = hours - val;
            intHours = -intHours;
        } else {
            val = intHours + val;
        }
        return val * HOUR_TO_DEG;
    };

    /**
     * Parse dec
     * @function _parseDec
     * @memberof CDSReverseNameResolver#
     * @param degrees
     * @param min
     * @param sec
     * @returns {number}
     * @private
     */
    CDSReverseNameResolver.prototype._parseDec = function(degrees, min, sec) {
        var intDegrees = parseInt(degrees, 10);

        var val = (sec / 60.0 + min) / 60.0;

        if (degrees < 0.0 || parseFloat(degrees) === -0.0) {
            val = degrees - val;
            intDegrees = -intDegrees;
        } else {
            val = intDegrees + val;
        }
        return val;
    };

    /**
     * @function remove
     * @memberof CDSReverseNameResolver#
     */
    CDSReverseNameResolver.prototype.remove = function() {};

    /**************************************************************************************************************/

    return CDSReverseNameResolver;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Name resolver module : search object name from its coordinates
 * TODO : move _handleMouseDown&Up to View ?
 */
define('ReverseNameResolver/ReverseNameResolver',[
    "jquery",
    "../Utils/Constants",
    "./DefaultReverseNameResolver",
    "./CDSReverseNameResolver"
], function($, Constants, DefaultReverseNameResolver) {
    var mizarAPI;
    var context;

    var reverseNameResolverImplementation = null;

    return {
        init: function(m) {
            mizarAPI = m;
            this.setContext(mizarAPI.getActivatedContext());
        },

        /**************************************************************************************************************/

        /**
         *    Send request to reverse name resolver service for the given gepoint
         *    @param geoPick    Geographic position of point of interest
         *    @param options
         *        <li>success: Function called on success with the response of server as argument</li>
         *        <li>error: Function called on error with the xhr object as argument</li>
         *    @fires Mizar#plugin:not_found
         */
        sendRequest: function(geoPick, options) {
            var self = this;
            // TODO: depending on context, send the request
            // Currently only sky context is handled
            if (
                mizarAPI.getActivatedContext().getMode() ===
                Constants.CONTEXT.Sky
            ) {
                // Find max order
                var maxOrder = 3;
                mizarAPI
                    .getActivatedContext()
                    .getTileManager()
                    .visitTiles(function(tile) {
                        if (maxOrder < tile.order) {
                            maxOrder = tile.order;
                        }
                    });

                options.maxOrder = maxOrder;
                options.pos = geoPick;
                options.mizarAPI = mizarAPI;

                if (reverseNameResolverImplementation) {
                    reverseNameResolverImplementation.handle(options);
                } else {
                    mizarAPI.publish(
                        Constants.EVENT_MSG.PLUGIN_NOT_FOUND,
                        "No reserve name resolver found"
                    );
                }
            } else {
                console.error("Not implemented yet");
                if (options && options.error) {
                    options.error();
                }
            }
        },

        /**************************************************************************************************************/

        /**
         *    Set new context
         */
        setContext: function(ctx) {
            context = ctx;

            //instantiate reverse name resolver nameResolverImplementation object
            var reverseNameResolverClass;
            if (
                typeof context.getContextConfiguration().reverseNameResolver !==
                "undefined"
            ) {
                reverseNameResolverClass = require(context.getContextConfiguration()
                    .reverseNameResolver.jsObject);
                reverseNameResolverImplementation = new reverseNameResolverClass(
                    context
                );
            } else {
                //Use default reverse name resolver if none defined...
                reverseNameResolverImplementation = new DefaultReverseNameResolver(
                    context
                );
            }
        }
    };
});

define('Time/TimeSample',["jquery", "moment", "../Utils/Constants", "../Utils/Utils"], function(
    $,
    Moment,
    Constants,
    Utils
) {
    /**
     * Store time sample
     * @constructor
     */
    var TimeSample = function() {
        this.start = null;
        this.end = null;
        this.stepValue = null;
        this.stepKind = null;
        this.layerID = null;
    };

    /**************************************************************************************************************/

    /**
     * Get the start date
     * @function getStart
     * @return {Date} Start date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStart = function() {
        return this.start;
    };

    /**************************************************************************************************************/

    /**
     * Set the start date of sample
     * @function setStart
     * @param {Date} date Start date
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStart = function(date) {
        this.start = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the end date
     * @function getEnd
     * @return {Date} End date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getEnd = function() {
        return this.end;
    };

    /**************************************************************************************************************/

    /**
     * Set the end date
     * @function setEnd
     * @param {Date} date End date
     * @memberof TimeSample#
     */
    TimeSample.prototype.setEnd = function(date) {
        this.end = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the step value
     * @function getStepValue
     * @return {Integer} Step value
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStepValue = function() {
        return this.stepValue;
    };

    /**************************************************************************************************************/

    /**
     * Set the step value
     * @function setStepValue
     * @param {Integer} stepValue Step value
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStepValue = function(stepValue) {
        this.stepValue = stepValue;
    };

    /**************************************************************************************************************/

    /**
     * Get the step kind
     * @function getStepKind
     * @return {String} Step kind
     * @memberof TimeSample#
     */
    TimeSample.prototype.getStepKind = function() {
        return this.stepKind;
    };

    /**************************************************************************************************************/

    /**
     * Set the step kind
     * @function setStepKind
     * @param {String} stepKind Step kind
     * @memberof TimeSample#
     */
    TimeSample.prototype.setStepKind = function(stepKind) {
        this.stepKind = stepKind;
    };

    /**************************************************************************************************************/

    /**
     * Set the layer ID
     * @function setLayerID
     * @param {String} layerID Layer ID
     * @memberof TimeSample#
     */
    TimeSample.prototype.setLayerID = function(layerID) {
        this.layerID = layerID;
    };

    /**************************************************************************************************************/

    /**
     * Get the layer ID
     * @function getLayerID
     * @return {String} Layer ID
     * @memberof TimeSample#
     */
    TimeSample.prototype.getLayerID = function() {
        return this.layerID;
    };

    /**************************************************************************************************************/

    /**
     * Get next date
     * @function getNextDate
     * @return {Date} Next date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getNextDate = function(date) {
        var nextDate = null;
        nextDate = Moment.utc(date).add(this.stepValue, this.stepKind);
        if (nextDate > this.end) {
            nextDate = null;
        }
        return nextDate;
    };

    /**************************************************************************************************************/

    /**
     * Get previous date
     * @function getPreviousDate
     * @return {Date} Previous date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getPreviousDate = function(date) {
        var previousDate = null;
        previousDate = Moment.utc(date).subtract(this.stepValue, this.stepKind);
        if (previousDate < this.start) {
            previousDate = null;
        }
        return previousDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param {Date} date Date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (date < this.start) {
            // trivial case, first date is after !
            foundDate = this.start;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        } else if (date > this.end) {
            // trivial case, date is after the last date
            foundDate = null;
        } else {
            // go to search
            var currentDate = this.start;
            var isDone = false;
            var nextDate = null;
            while (!isDone) {
                currentDate = this.getNextDate(currentDate);
                if (currentDate === null) {
                    // Null found, no more date, stop it whith found date set to null
                    isDone = true;
                    foundDate = null;
                }
                if (currentDate > date) {
                    isDone = true;
                    foundDate = currentDate;
                }
            }
        }

        if (foundDate !== null) {
            foundPeriod.from = foundDate;
            foundPeriod.to = foundDate;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param {Date} date Date
     * @memberof TimeSample#
     */
    TimeSample.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (date > this.end) {
            // trivial case, end date is before !
            foundDate = this.end;
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
        } else if (date < this.start) {
            // trivial case, date is before the first date
            foundDate = null;
        } else {
            // go to search
            var currentDate = this.start;
            var previousDate = null;
            var isDone = false;
            var nextDate = null;

            while (!isDone) {
                previousDate = currentDate;
                currentDate = this.getNextDate(currentDate);
                if (currentDate === null) {
                    // Null found, no more date, stop it whith found date set to null
                    isDone = true;
                    foundDate = previousDate;
                }
                if (currentDate > date) {
                    isDone = true;
                    foundDate = previousDate;
                }
            }
        }
        if (foundDate !== null) {
            foundDisplay = Moment(foundDate.toISOString()).format(
                Moment(foundDate).creationData().format
            );
            foundPeriod.from = foundDate;
            foundPeriod.to = foundDate;
        }
        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeSample#
     */
    TimeSample.prototype.getMinDate = function() {
        return this.getStart();
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeSample#
     */
    TimeSample.prototype.getMaxDate = function() {
        return this.getEnd();
    };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {String} String representation
     * @memberof TimeSample#
     */
    TimeSample.prototype.toString = function() {
        return (
            Moment(this.start) +
            " / " +
            Moment(this.end) +
            " / " +
            this.stepValue +
            this.stepKind +
            " / ID=" +
            this.layerID
        );
    };

    return TimeSample;
});

define('Time/TimeEnumerated',["jquery", "moment", "../Utils/Constants", "../Utils/Utils"], function(
    $,
    Moment,
    Constants,
    Utils
) {
    /**
     * Stock time sample
     * @constructor
     */
    var TimeEnumerated = function() {
        // Array of enumerated values
        this.enumeratedValues = null;
        this.currentIndex = null;
    };

    /**************************************************************************************************************/

    /**
     * Sort enumerated values by date
     * @function sortTime
     * @param {Date} a First date
     * @param {Date} b Second date
     */
    function sortTime(a, b) {
        return a.date > b.date ? 1 : -1;
    }

    /**************************************************************************************************************/

    /**
     * Get the current index
     * @function getCurrentIndex
     * @return Integer Current index
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getCurrentIndex = function() {
        return this.currentIndex;
    };

    /**************************************************************************************************************/

    /**
     * Parse date
     * @function parseDate
     * @param {String} value Date to parse
     * @return {Json} date { "date", "display", "period" { "from", "to" } }
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.parseDate = function(value) {
        value = value.trim();
        var date = null;
        var period = null;

        var regExpYear = /^\d{4}$/;
        var regExpMonth = /^\d{4}\-\d{2}$/;
        var regExpDay = /^\d{4}\-\d{2}\-\d{2}$/;
        if (typeof value === "string") {
            // Year management
            if (regExpYear.test(value)) {
                date = Moment.utc(value, "YYYY");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.YEAR
                );
            }
            // Month management
            if (regExpMonth.test(value)) {
                date = Moment.utc(value, "YYYY-MM");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.MONTH
                );
            }
            // Day management
            if (regExpDay.test(value)) {
                date = Moment.utc(value, "YYYY-MM-DD");
                period = {};
                period.from = date;
                period.to = Moment.utc(period.from).endOf(
                    Constants.TIME_STEP.DAY
                );
            }
            if (date === null) {
                date = Moment.utc(value);
            }
        } else {
            date = Moment.utc(value);
        }
        return {
            date: date,
            display: value,
            period: period
        };
    };

    /**************************************************************************************************************/

    /**
     * Add date to enumerated values (check if still present)
     * @function addDateToEnumeratedValues
     * @param {Json} date Date
     * @param {String} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.addDateToEnumeratedValues = function(date, ID) {
        if (this.enumeratedValues === null) {
            this.enumeratedValues = [];
        }

        for (var i = 0; i < this.enumeratedValues.length; i++) {
            if (this.enumeratedValues[i].display === date.display) {
                // Still found : add only id
                if (
                    this.enumeratedValues[i].ids &&
                    this.enumeratedValues[i].ids.length
                ) {
                    this.enumeratedValues[i].ids.push(ID);
                    return;
                }
            }
        }
        // Not found, add all
        date.ids = [];
        date.ids.push(ID);
        this.enumeratedValues.push(date);
    };

    /**************************************************************************************************************/

    /**
     * Remove enumerated values for ID
     * @function removeEnumeratedValuesForID
     * @param {String} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.removeEnumeratedValuesForID = function(ID) {
        if (ID === null) {
            ID = TimeTravelParams.NO_ID;
        }
        if (this.enumeratedValues) {
            for (var i = this.enumeratedValues.length - 1; i >= 0; i--) {
                if (
                    this.enumeratedValues[i].ids &&
                    this.enumeratedValues[i].ids.length
                ) {
                    var index = this.enumeratedValues[i].ids.indexOf(ID);
                    if (index !== -1) {
                        this.enumeratedValues[i].ids.splice(index, 1);
                    }
                    if (this.enumeratedValues[i].ids.length === 0) {
                        this.enumeratedValues.splice(i, 1);
                    }
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add enumerated values for ID
     * @function addEnumeratedValuesForID
     * @param {Array<String>} values Array of enumerated values
     * @param {String} ID Id
     * @memberof TimeEnumerated#
     * @private
     */
    TimeEnumerated.prototype.addEnumeratedValuesForID = function(values, ID) {
        if (values === null) {
            // By pass
            return;
        }
        if (ID === null) {
            ID = TimeTravelParams.NO_ID;
        }

        // TODO soon : check format, need conversion ?
        var date = null;
        for (var i = 0; i < values.length; i++) {
            date = this.parseDate(values[i]);
            this.addDateToEnumeratedValues(date, ID);
        }

        // sort tab
        this.enumeratedValues.sort(sortTime);

        this.currentIndex = 0;
        this.currentDate = this.enumeratedValues[this.currentIndex].date;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param Date date date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        return foundDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param Date date date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        return foundDate;
    };

    /**************************************************************************************************************/

    /**
     * Get first date AFTER a specified date
     * @function getFirstDateAfter
     * @param {Date} date Date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateAfter = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            if (date < this.enumeratedValues[0].date) {
                // trivial case, first date is before the first element
                foundDate = this.enumeratedValues[0].date;
                foundPeriod = this.enumeratedValues[0].period;
                foundDisplay = this.enumeratedValues[0].display;
            } else if (
                date >
                this.enumeratedValues[this.enumeratedValues.length - 1].date
            ) {
                // trivial case, date is after the last date
                foundDate = null;
            } else {
                // go to search
                var cpt = 0;
                var isDone = false;
                while (!isDone) {
                    currentDate = this.enumeratedValues[cpt].date;
                    if (currentDate > date) {
                        isDone = true;
                        foundDate = this.enumeratedValues[cpt].date;
                        foundPeriod = this.enumeratedValues[cpt].period;
                        foundDisplay = this.enumeratedValues[cpt].display;
                    }
                    cpt++;
                    isDone = isDone || cpt >= this.enumeratedValues.length;
                }
            }
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get first date BEFORE a specified date
     * @function getFirstDateBefore
     * @param {Date} date Date
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getFirstDateBefore = function(date) {
        var foundDate = null;
        var foundPeriod = { from: null, to: null };
        var foundDisplay = null;

        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            if (
                date >
                this.enumeratedValues[this.enumeratedValues.length - 1].date
            ) {
                // trivial case, end date is before !
                foundDate = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].date;
                foundPeriod = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].period;
                foundDisplay = this.enumeratedValues[
                    this.enumeratedValues.length - 1
                ].display;
            } else if (date < this.enumeratedValues[0].date) {
                // trivial case, date is before the first date
                foundDate = null;
            } else {
                // go to search
                var cpt = this.enumeratedValues.length - 1;
                var isDone = false;

                while (!isDone) {
                    while (!isDone) {
                        currentDate = this.enumeratedValues[cpt].date;
                        if (currentDate < date) {
                            isDone = true;
                            foundDate = this.enumeratedValues[cpt].date;
                            foundPeriod = this.enumeratedValues[cpt].period;
                            foundDisplay = this.enumeratedValues[cpt].display;
                        }
                        cpt--;
                        isDone = isDone || cpt < 0;
                    }
                }
            }
        }

        return {
            date: foundDate,
            period: foundPeriod,
            display: foundDisplay
        };
    };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {String} String representation
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.toString = function() {
        var res = "";
        if (this.enumeratedValues) {
            for (var i = 0; i < this.enumeratedValues.length; i++) {
                res += this.enumeratedValues[i].display + " / ";
            }
        }
        return res;
    };

    /**************************************************************************************************************/

    /**
     * Is empty ?
     * @function isEmpty
     * @return {Boolean} is empty ?
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.isEmpty = function() {
        return !(this.enumeratedValues && this.enumeratedValues.length > 0);
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getMinDate = function() {
        var result = null;
        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            result = this.enumeratedValues[0].date;
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeEnumerated#
     */
    TimeEnumerated.prototype.getMaxDate = function() {
        var result = null;
        if (this.enumeratedValues && this.enumeratedValues.length > 0) {
            result = this.enumeratedValues[this.enumeratedValues.length - 1]
                .date;
        }
        return result;
    };

    return TimeEnumerated;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * globalTime:changed.<br/>
 * Called when the time has changed
 * @event TimeTravel#globalTime:changed
 * @type {TimeTravelParams~details}
 */

/**
* The time object.
* @typedef {object} TimeTravelParams~details
* @property {date|moment} date - the current time.
* @property {string} display - the current date as string for display.
* @property {object} [period] - time period.
* @property {moment} [period.from] - start date.
* @property {moment} [period.to] - stop date.
*/

/**
 * Time travel module : time control
 */
define('Time/TimeTravelParams',[
    "jquery",
    "moment",
    "./TimeSample",
    "./TimeEnumerated",
    "../Utils/Constants"
], function ($, Moment, TimeSample, TimeEnumerated, Constants) {
    /**
     * @name TimeTravelParams
     * @class
     * Management of time travel
     */
    var TimeTravelParams = function () {
        this.currentDate = new Date();

        this.currentPeriod = {
            from: null,
            to: null
        };

        this.currentDisplayDate = Moment(this.currentDate).format(
            Moment(this.currentDate).creationData().format
        );
        this.minDate = null;
        this.maxDate = null;

        this.ctx = null;
        // List of samples
        this.samples = [];
        // Enumerated values
        this.enumeratedValues = new TimeEnumerated();

        // TODO: internationalized
        Moment.locale("fr");
    };

    /**************************************************************************************************************/

    /**
     * Set the context
     * @function setContext
     * @param ctx Context context
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setContext = function (ctx) {
        this.ctx = ctx;
        this.apply();
    };

    /**************************************************************************************************************/

    /**
     * Set the current date
     * @function setCurrentDate
     * @param date Date current date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setCurrentDate = function (date) {
        this.currentDate = Moment.utc(date);
    };

    /**************************************************************************************************************/

    /**
     * Get the current date
     * @function getCurrentDate
     * @return Date current date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentDate = function () {
        return this.currentDate;
    };

    /**************************************************************************************************************/

    /**
     * Get the current period
     * @function getCurrentPeriod
     * @return {Json} period { "from", "to" }
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentPeriod = function () {
        return this.currentPeriod;
    };

    /**************************************************************************************************************/

    /**
     * Add a sample
     * @function addSample
     * @param {Date} start Start date
     * @param {Date} end End date
     * @param {String} stepKind Step kind
     * @param {Integer} stepValue Step value
     * @param {String} ID Layer ID
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.addSample = function (
        start,
        end,
        stepKind,
        stepValue,
        ID
    ) {
        var sample = new TimeSample();
        sample.setStart(start);
        sample.setEnd(end);
        sample.setStepKind(stepKind);
        sample.setStepValue(stepValue);
        sample.setLayerID(ID);
        this.samples.push(sample);
    };

    /**************************************************************************************************************/

    /**
     * Add values
     * @function add values
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.addValues = function (parameters) {
        if (!parameters) {
            return;
        }
        var saveCurrentValue = this.currentDate;

        if (parameters.enumeratedValues) {
            // Add to enumerated
            this.enumeratedValues.addEnumeratedValuesForID(
                parameters.enumeratedValues,
                parameters.ID
            );
        } else if (
            parameters.start &&
            parameters.end &&
            parameters.stepKind &&
            parameters.stepValue &&
            parameters.ID
        ) {
            // Add a new sample
            this.addSample(
                parameters.start,
                parameters.end,
                parameters.stepKind,
                parameters.stepValue,
                parameters.ID
            );
        } else {
            console.error(
                "Can't understand add values for time travel with parameters",
                parameters
            );
        }

        this.setToNearestValue(saveCurrentValue);
    };

    /**************************************************************************************************************/

    /**
     * Remove values
     * @function remove values
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.removeValues = function (parameters) {
        if (!parameters) {
            return;
        }
        var saveCurrentValue = this.currentDate;

        if (parameters.ID) {
            // Remove values into enumerated values
            this.enumeratedValues.removeEnumeratedValuesForID(parameters.ID);

            // Remove samples with ID
            var newSamples = [];
            for (var i = 0; i < this.samples.length; i++) {
                if (this.samples[i].getLayerID() !== parameters.ID) {
                    newSamples.push(samples[i]);
                }
            }
            this.samples = newSamples;
        }
        this.setToNearestValue(saveCurrentValue);
    };

    /**************************************************************************************************************/

    /**
     * Get next date
     * @function getNextDate
     * @return {Date} Date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getNextDate = function (date) {
        var minDate = {
            date: null
        };

        var allDates = [];
        var aDate = null;
        for (var i = 0; i < this.samples.length; i++) {
            aDate = this.samples[i].getFirstDateAfter(date);
            if (aDate.date !== null) {
                allDates.push(aDate);
            }
        }
        aDate = this.enumeratedValues.getFirstDateAfter(date);
        if (aDate.date !== null) {
            allDates.push(aDate);
        }

        for (i = 0; i < allDates.length; i++) {
            var currentNextDate = allDates[i];
            if (minDate.date === null) {
                minDate = currentNextDate;
            } else {
                if (Math.abs(currentNextDate - date < minDate - date)) {
                    minDate = currentNextDate;
                }
            }
        }
        return minDate;
    };

    /**************************************************************************************************************/

    /**
     * Get previous date
     * @function getNextDate
     * @return {Date} Date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getPreviousDate = function (date) {
        var minDate = {
            date: null
        };

        var allDates = [];
        var aDate = null;
        for (var i = 0; i < this.samples.length; i++) {
            aDate = this.samples[i].getFirstDateBefore(date);
            if (aDate.date !== null) {
                allDates.push(aDate);
            }
        }
        aDate = this.enumeratedValues.getFirstDateBefore(date);
        if (aDate.date !== null) {
            allDates.push(aDate);
        }

        for (i = 0; i < allDates.length; i++) {
            var currentPreviousDate = allDates[i];
            if (minDate.date === null) {
                minDate = currentPreviousDate;
            } else {
                if (
                    Math.abs(
                        currentPreviousDate.date - date < minDate.date - date
                    )
                ) {
                    minDate = currentPreviousDate;
                }
            }
        }

        return minDate;
    };

    /**************************************************************************************************************/

    /**
     * Set to nearest value (call only for enumerated)
     * @function setToNearestValue
     * @param {Date} date date
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.setToNearestValue = function (date) {
        var previousExistingDate = this.getPreviousDate(date);
        var nextExistingDate = this.getNextDate(date);

        if (
            previousExistingDate.date === null &&
            nextExistingDate.date === null
        ) {
            // No date found
            this.currentDate = new Date();
            this.currentDisplayDate = Moment(this.currentDate).format(
                "Do MMM Y"
            );
            this.currentPeriod = {
                from: this.currentDate,
                to: this.currentDate
            };
        } else if (previousExistingDate.date === null) {
            // Only before
            this.currentDate = nextExistingDate.date;
            this.currentDisplayDate = nextExistingDate.display;
            this.currentPeriod = nextExistingDate.period;
        } else if (nextExistingDate.date === null) {
            // Only after
            this.currentDate = previousExistingDate.date;
            this.currentDisplayDate = previousExistingDate.display;
            this.currentPeriod = previousExistingDate.period;
        } else {
            // Search nearest
            deltaPrevious = Math.abs(date - previousExistingDate.date);
            deltaNext = Math.abs(nextExistingDate.date - date);
            if (deltaPrevious < deltaNext) {
                this.currentDate = previousExistingDate.date;
                this.currentDisplayDate = previousExistingDate.display;
                this.currentPeriod = previousExistingDate.period;
            } else {
                this.currentDate = nextExistingDate.date;
                this.currentDisplayDate = nextExistingDate.display;
                this.currentPeriod = nextExistingDate.period;
            }
        }
        this.apply();
    };

    /**************************************************************************************************************/

    /**
     * Update
     * @function update
     * @param {Json} parameters Parameters
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.update = function (parameters) {
        if (!parameters) {
            return;
        }
        if (parameters.add) {
            this.addValues(parameters.add);
        }
        if (parameters.remove) {
            this.removeValues(parameters.remove);
        }

        // update metadata
        this.minDate = this.getMinDate();
        this.maxDate = this.getMaxDate();

        // apply !
        this.apply();

        console.log("all dates availables :\n" + this.toString());
    };

    /**************************************************************************************************************/

    /**
     * Apply current date to IHM (launch event)
     * @function apply
     * @memberof TimeTravelParams#
     * @fires TimeTravelParams#globalTime:changed
     */
    TimeTravelParams.prototype.apply = function () {
        var details = {
            date: this.currentDate,
            display: this.currentDisplayDate,
            period: this.currentPeriod
        };
        this.ctx.publish(Constants.EVENT_MSG.GLOBAL_TIME_CHANGED, details);
    };

    /**************************************************************************************************************/

    /**
     * Rewind to previous time step
     * @function rewind
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.rewind = function () {
        if (!this.isEmpty()) {
            var previousDate = this.getPreviousDate(
                Moment(this.currentDate).subtract(
                    1,
                    Constants.TIME_STEP.MILLISECOND
                )
            );
            if (previousDate.date !== null) {
                this.currentDate = previousDate.date;
                this.currentPeriod = previousDate.period;
                this.currentDisplayDate = previousDate.display;
                this.apply();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Forward to next time step
     * @function forward
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.forward = function () {
        if (!this.isEmpty()) {
            var nextDate = this.getNextDate(
                Moment(this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND)
            );
            if (nextDate.date !== null) {
                this.currentDate = nextDate.date;
                this.currentPeriod = nextDate.period;
                this.currentDisplayDate = nextDate.display;
                this.apply();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get date formated (when there is no enumerated values)
     * @function getDateFormated
     * @param {Date} date Date
     * @return String Date formated
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getDateFormated = function (date) {
        // Check with STEP kind value
        var formatPattern = "LLLL";
        if (this.stepKind === Constants.TIME_STEP.YEAR) {
            formatPattern = "Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.QUARTER ||
            this.stepKind === Constants.TIME_STEP.MONTH
        ) {
            formatPattern = "MMM Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.WEEK ||
            this.stepKind === Constants.TIME_STEP.DAY ||
            this.stepKind === Constants.TIME_STEP.ENUMERATED
        ) {
            formatPattern = "Do MMM Y";
        } else if (
            this.stepKind === Constants.TIME_STEP.HOUR ||
            this.stepKind === Constants.TIME_STEP.MINUTE
        ) {
            formatPattern = "Do MMM Y HH:mm";
        } else if (this.stepKind === Constants.TIME_STEP.SECOND) {
            formatPattern = "Do MMM Y   HH:mm:ss";
        } else {
            formatPattern = "Do MMM Y   HH:mm:ss.SSS";
        }
        return Moment.utc(this.currentDate).format(formatPattern);
    };

    /**************************************************************************************************************/

    /**
     * Return date to display on IHM
     * @function getCurrentDisplayDate
     * @return String Date formated
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getCurrentDisplayDate = function () {
        return this.currentDisplayDate;
        /*
        var result = null;
        if (this.stepKind === Constants.TIME_STEP.ENUMERATED) {
            if (this.enumeratedValues.length>0) {
                result = this.enumeratedValues[this.currentIndex].display;
            } else {
                result = this.getDateFormated(new Date());
            }
        } else {
            result = this.getDateFormated(this.currentDate);
        }
        return result;
        */
    };

    /**************************************************************************************************************/

    /**
     * Is current date the first ?
     * @function isCurrentDateTheFirst
     * @return boolean If the current date is the first of range
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isCurrentDateTheFirst = function () {
        if (this.isEmpty() === true) {
            this.isFirstDate = true;
        } else {
            var previousDate = this.getPreviousDate(
                Moment(this.currentDate).subtract(
                    1,
                    Constants.TIME_STEP.MILLISECOND
                )
            );
            this.isFirstDate = previousDate.date === null;
        }
        return this.isFirstDate;
    };

    /**************************************************************************************************************/

    /**
     * Is current date the last ?
     * @function isCurrentDateTheLast
     * @return boolean If the current date is the last of range
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isCurrentDateTheLast = function () {
        if (this.isEmpty() === true) {
            this.isLastDate = true;
        } else {
            var nextDate = this.getNextDate(
                Moment(this.currentDate).add(1, Constants.TIME_STEP.MILLISECOND)
            );
            this.isLastDate = nextDate.date === null;
        }
        return this.isLastDate;
    };

    /**************************************************************************************************************/

    /**
     * Get min date
     * @function getMinDate
     * @return {Date} Min date or null
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getMinDate = function () {
        var result = null;

        var allDates = [];
        for (var i = 0; i < this.samples.length; i++) {
            allDates.push(this.samples[i].getMinDate());
        }
        allDates.push(this.enumeratedValues.getMinDate());

        for (i = 0; i < allDates.length; i++) {
            if (result === null) {
                result = allDates[i];
            } else if (allDates[i] < result && allDates[i] !== null) {
                result = allDates[i];
            }
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get max date
     * @function getMaxDate
     * @return {Date} Max date or null
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.getMaxDate = function () {
        var result = null;

        var allDates = [];
        for (var i = 0; i < this.samples.length; i++) {
            allDates.push(this.samples[i].getMaxDate());
        }
        allDates.push(this.enumeratedValues.getMaxDate());

        for (i = 0; i < allDates.length; i++) {
            if (result === null) {
                result = allDates[i];
            } else if (allDates[i] > result && allDates[i] !== null) {
                result = allDates[i];
            }
        }
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Is time travel empty ?
     * @function toString
     * @return {Boolean} Is time travel empty
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.isEmpty = function () {
        var hasSamples = this.samples && this.samples.length > 0;
        return !hasSamples && this.enumeratedValues.isEmpty();
    };

    /**************************************************************************************************************/

    // /**
    //  * Get all steps
    //  * @function toString
    //  * @return {String} String representation
    //  * @memberof TimeTravelParams#
    //  */
    // TimeTravelParams.prototype.getAllSteps = function () {
    //     throw "TimeTravelParams.getAllSteps : deactivated because too long to execute";

    //     var res = [];
    //     var aDate = this.minDate;
    //     res.push(aDate);
    //     var nextDate = this.getNextDate(
    //         Moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
    //     );

    //     while (nextDate.date !== null) {
    //         aDate = nextDate.date;
    //         res.push(aDate);
    //         if (res.length % 500 === 0) {
    //             console.log(res.length);
    //         }
    //         nextDate = this.getNextDate(
    //             Moment(aDate).add(1, Constants.TIME_STEP.MILLISECOND)
    //         );
    //     }

    //     return res;
    // };

    /**************************************************************************************************************/

    /**
     * Get string representation
     * @function toString
     * @return {String} String representation
     * @memberof TimeTravelParams#
     */
    TimeTravelParams.prototype.toString = function () {
        var res = "";

        res += "Metadata : \n";
        res +=
            "  Start date : " +
            Moment(this.minDate).format(Constants.TIME.DEFAULT_FORMAT) +
            " : " +
            this.minDate +
            "\n";
        res +=
            "  End date   : " +
            Moment(this.maxDate).format(Constants.TIME.DEFAULT_FORMAT) +
            " : " +
            this.maxDate +
            "\n";

        if (this.samples) {
            for (var i = 0; i < this.samples.length; i++) {
                res += "Sample : " + this.samples[i].toString() + "\n";
            }
        }

        if (!this.enumeratedValues.isEmpty()) {
            res += "Enumerated : " + this.enumeratedValues.toString() + "\n";
        }

        return res;
    };

    return TimeTravelParams;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" component
 */
define('Services/TimeTravelCore',["jquery", "../Time/TimeTravelParams", "../Utils/Constants"], function(
    $,
    TimeTravelParams,
    Constants
) {
    /**
     *    Private variables
     */

    var params = new TimeTravelParams();

    var parentElement = null;
    var ctx = null;

    /**************************************************************************************************************/

    /**
     *    Go Rewind
     *
     */
    function goRewind() {
        params.rewind();
    }

    /**
     *    Go Forward
     *
     */
    function goForward() {
        params.forward();
    }

    /**
     *    Choose time
     *
     */
    function chooseTime() {}

    /**************************************************************************************************************/

    /**
     *    Remove time travel element
     *
     */
    function remove() {
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD, goForward);
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
        ctx.unsubscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
        document.getElementById(parentElement).innerHTML = "";
    }

    /**************************************************************************************************************/

    /**
     *    reset values
     *
     */
    function reset() {
        params.reset();
    }

    /**
     *    update
     *
     */
    function update(parameters) {
        params.update(parameters);
    }

    /**
     *    get current date
     *
     */
    function getCurrentDate() {
        return params.getCurrentDate();
    }

    function isCurrentDateTheFirst() {
        return params.isCurrentDateTheFirst();
    }

    function isCurrentDateTheLast() {
        return params.isCurrentDateTheLast();
    }

    /**************************************************************************************************************/

    return {
        init: function(options) {
            parentElement = options.element;
            ctx = options.ctx;
            params.setContext(ctx);

            // subscribe
            if (ctx) {
                ctx.subscribe(
                    Constants.EVENT_MSG.GLOBAL_TIME_FORWARD,
                    goForward
                );
                ctx.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_REWIND, goRewind);
                ctx.subscribe(Constants.EVENT_MSG.GLOBAL_TIME_SET, chooseTime);
            }
        },
        reset: reset,
        update: update,
        goForward: goForward,
        goRewind: goRewind,
        isCurrentDateTheFirst: isCurrentDateTheFirst,
        isCurrentDateTheLast: isCurrentDateTheLast,
        chooseTime: chooseTime,
        remove: remove,
        getCurrentDate: getCurrentDate
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Services/ServiceFactory',[
    "../Utils/Constants",
    "../Services/FitsVisu",
    "../Services/FitsHips",
    "../Services/HistogramCore",
    "../Services/ImageProcessingCore",
    "../Services/MeasureToolPlanetCore",
    "../Services/MeasureToolSkyCore",
    "../Services/MocBase",
    "../Services/MollweideViewerCore",
    "../Services/PickingManagerCore",
    "../Services/SampCore",
    "../Services/SelectionToolCore",
    "../Services/ExportToolCore",
    "../NameResolver/NameResolver",
    "../ReverseNameResolver/ReverseNameResolver",
    "../Services/TimeTravelCore"
], function(
    Constants,
    FitsVisu,
    FitsHips,
    HistogramCore,
    ImageProcessingCore,
    MeasureToolPlanetCore,
    MeasureToolSkyCore,
    MocBase,
    MollweideViewerCore,
    PickingManagerCore,
    SampCore,
    SelectionToolCore,
    ExportToolCore,
    NameResolver,
    ReverseNameResolver,
    TimeTravelCore
) {

    /**
     * image:added
     * Called when an image has been added
     * @event Service#image:added
     * @type {json}
     */ 

    /**
     * image:removed.<br/>
     * Called when an image has been removed
     * @event Service#image:removed
     * @type {json}
     */      

    /**
     * image:downloaded.<br/>
     * Called when an image has been downloaded
     * @event Service#image:downloaded
     * @type {json}
     */      

    return {
        create: function(serviceType, userOptions) {
            var obj;
            switch (serviceType) {
                case Constants.SERVICE.FitsVisu:
                    obj = FitsVisu;
                    break;
                case Constants.SERVICE.Histogram:
                    obj = HistogramCore;
                    break;
                case Constants.SERVICE.ImageProcessing:
                    obj = ImageProcessingCore;
                    break;
                case Constants.SERVICE.MeasureToolPlanet:
                    obj = MeasureToolPlanetCore;
                    break;
                case Constants.SERVICE.MeasureToolSky:
                    obj = MeasureToolSkyCore;
                    break;
                case Constants.SERVICE.MocBase:
                    obj = MocBase;
                    break;
                case Constants.SERVICE.MollweideViewer:
                    obj = MollweideViewerCore;
                    break;
                case Constants.SERVICE.TimeTravel:
                    obj = TimeTravelCore;
                    break;
                case Constants.SERVICE.PickingManager:
                    obj = PickingManagerCore;
                    break;
                case Constants.SERVICE.Samp:
                    obj = SampCore;
                    break;
                case Constants.SERVICE.SelectionTool:
                    obj = new SelectionToolCore(userOptions);
                    break;
                case Constants.SERVICE.NameResolver:
                    obj = NameResolver;
                    break;
                case Constants.SERVICE.ReverseNameResolver:
                    obj = ReverseNameResolver;
                    break;
                case Constants.SERVICE.ExportTool:
                    obj = ExportToolCore;
                    break;
                case Constants.SERVICE.FitsHips:
                    obj = FitsHips;
                    break;
                default:
                    throw new RangeError(
                        "Cannot retrieve service " + serviceType,
                        "ServiceFactory.js"
                    );
            }
            return obj;
        }
    };
});

define('Registry/AbstractRegistryHandler',["underscore-min", "../Layer/LayerFactory"], function(_, LayerFactory) {
    var AbstractRegistryHandler = function() {
        this.next = {
            handleRequest: function(layerDescription, callback, fallback) {
                console.log("All strategies exhausted.");
            }
        };
    };

    AbstractRegistryHandler.prototype.setNext = function(next) {
        this.next = next;
        return next;
    };

    AbstractRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {};

    AbstractRegistryHandler.prototype._handlePendingLayers = function(
        pendingLayers,
        layers
    ) {
        for (var i = 0; i < layers.length && pendingLayers.length !== 0; i++) {
            var layer = layers[i];
            if (
                pendingLayers.length != 0 &&
                layer.isBackground() &&
                layer.isVisible()
            ) {
                var j = pendingLayers.length;
                while (j > 0) {
                    j--;
                    var pendingLayerDescription = pendingLayers[j];
                    try {
                        layers.push(
                            LayerFactory.create(pendingLayerDescription)
                        );
                        pendingLayers.splice(j, 1);
                    } catch (RangeError) {}
                }
            }
        }
    };

    return AbstractRegistryHandler;
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('wms-capabilities',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.WMSCapabilities = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

module.exports = require('./src/wms');

},{"./src/wms":6}],2:[function(require,module,exports){
"use strict";

/**
 * @enum {Number}
 */
module.exports = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};

},{}],3:[function(require,module,exports){
"use strict";

/**
 * Returns true if the specified value is not undefined.
 *
 * @param {?} val Variable to test.
 * @return {Boolean} Whether variable is defined.
 */
module.exports = function isDef(val) {
  return val !== void 0;
};

},{}],4:[function(require,module,exports){
"use strict";

/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {String} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
module.exports = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};

},{}],5:[function(require,module,exports){
"use strict";

var isDef = require('./isdef');

/**
 * Make sure we trim BOM and NBSP
 * @type {RegExp}
 */
var TRIM_RE = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

/**
 * Repeats a string n times.
 * @param {String} string The string to repeat.
 * @param {Number} length The number of times to repeat.
 * @return {String} A string containing {@code length} repetitions of
 *     {@code string}.
 */
function repeat(string, length) {
  return new Array(length + 1).join(string);
}

module.exports = {

  /**
   * @param  {String} str
   * @return {String}
   */
  trim: function(str) {
    return str.replace(TRIM_RE, '');
  },

  /**
   * Pads number to given length and optionally rounds it to a given precision.
   * For example:
   * <pre>padNumber(1.25, 2, 3) -> '01.250'
   * padNumber(1.25, 2) -> '01.25'
   * padNumber(1.25, 2, 1) -> '01.3'
   * padNumber(1.25, 0) -> '1.25'</pre>
   *
   * @param {Number} num The number to pad.
   * @param {Number} length The desired length.
   * @param {Number=} opt_precision The desired precision.
   * @return {String} {@code num} as a string with the given options.
   */
  padNumber: function(num, length, opt_precision) {
    var s = isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
    var index = s.indexOf('.');
    if (index == -1) {
      index = s.length;
    }
    return repeat('0', Math.max(0, length - index)) + s;
  }

};

},{"./isdef":3}],6:[function(require,module,exports){
"use strict";

var XMLParser = require('./xml_parser');
var isDef = require('./utils/isdef');
var nodeTypes = require('./node_types');
var setIfUndefined = require('./utils/setifundefined');
var XSD = require('./xsd');
var XLink = require('./xlink');

/**
 * WMS Capabilities parser
 *
 * @param {String=} xmlString
 * @constructor
 */
function WMS(xmlString) {

  /**
   * @type {String}
   */
  this.version = undefined;

  /**
   * @type {XMLParser}
   */
  this._parser = new XMLParser();

  /**
   * @type {String=}
   */
  this._data = xmlString;
};

/**
 * Shortcut
 * @type {Function}
 */
var makePropertySetter = XMLParser.makeObjectPropertySetter;

/**
 * @param {String} xmlString
 * @return {WMS}
 */
WMS.prototype.data = function(xmlString) {
  this._data = xmlString;
  return this;
};

/**
 * @param  {String=} xmlString
 * @return {Object}
 */
WMS.prototype.toJSON = function(xmlString) {
  xmlString = xmlString || this._data;
  return this.parse(xmlString);
};

/**
 * @return {String} xml
 */
WMS.prototype.parse = function(xmlString) {
  return this._readFromDocument(this._parser.toDocument(xmlString));
};

/**
 * @param  {Document} doc
 * @return {Object}
 */
WMS.prototype._readFromDocument = function(doc) {
  for (var node = doc.firstChild; node; node = node.nextSibling) {
    if (node.nodeType == nodeTypes.ELEMENT) {
      return this.readFromNode(node);
    }
  }
  return null;
};

/**
 * @param  {DOMNode} node
 * @return {Object}
 */
WMS.prototype.readFromNode = function(node) {
  this.version = node.getAttribute('version');
  var wmsCapabilityObject = XMLParser.pushParseAndPop({
    'version': this.version
  }, WMS.PARSERS, node, []);

  return wmsCapabilityObject || null;
};

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */
WMS._readAttribution = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.ATTRIBUTION_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @return {ol.Extent} Bounding box object.
 */
WMS._readBoundingBoxExtent = function(node) {
	var readDecimalString = XSD.readDecimalString;

	return [
	  readDecimalString(node.getAttribute('minx')),
	  readDecimalString(node.getAttribute('miny')),
	  readDecimalString(node.getAttribute('maxx')),
	  readDecimalString(node.getAttribute('maxy'))
	];
}

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object} Bounding box object.
 */
WMS._readBoundingBox = function(node, objectStack) {
  var extent = WMS._readBoundingBoxExtent(node);
  var readDecimalString = XSD.readDecimalString;

  var resolutions = [
    readDecimalString(node.getAttribute('resx')),
    readDecimalString(node.getAttribute('resy'))
  ];

  return {
    'crs': node.getAttribute('CRS') || node.getAttribute('SRS'),
    'extent': extent,
    'res': resolutions
  };
};

/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.Extent|undefined} Bounding box object.
 */
WMS._readLatLonBoundingBox = function(node, objectStack) {
  var extent = WMS._readBoundingBoxExtent(node);

  if (!isDef(extent[0]) || !isDef(extent[1]) ||
    !isDef(extent[2]) || !isDef(extent[3])) {
    return undefined;
  }

  return extent;
};


/**
 * @privat
 * @param  {Node} node  Node
 * @param  {Arra.<Object>} objectStack Object stack
 * @return {Object}
 */
WMS._readScaleHint = function(node, objectStack) {
  var min = parseFloat(node.getAttribute('min'));
  var max = parseFloat(node.getAttribute('max'));

  return {
    min: min,
    max: max
  };
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {ol.Extent|undefined} Bounding box object.
 */
WMS._readEXGeographicBoundingBox = function(node, objectStack) {
  var geographicBoundingBox = XMLParser.pushParseAndPop({},
    WMS.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS,
    node, objectStack);
  if (!isDef(geographicBoundingBox)) {
    return undefined;
  }

  var westBoundLongitude = /** @type {number|undefined} */
    (geographicBoundingBox['westBoundLongitude']);
  var southBoundLatitude = /** @type {number|undefined} */
    (geographicBoundingBox['southBoundLatitude']);
  var eastBoundLongitude = /** @type {number|undefined} */
    (geographicBoundingBox['eastBoundLongitude']);
  var northBoundLatitude = /** @type {number|undefined} */
    (geographicBoundingBox['northBoundLatitude']);

  if (!isDef(westBoundLongitude) || !isDef(southBoundLatitude) ||
    !isDef(eastBoundLongitude) || !isDef(northBoundLatitude)) {
    return undefined;
  }

  return [
    westBoundLongitude, southBoundLatitude,
    eastBoundLongitude, northBoundLatitude
  ];
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Capability object.
 */
WMS._readCapability = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CAPABILITY_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Service object.
 */
WMS._readService = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.SERVICE_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact information object.
 */
WMS._readContactInformation = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_INFORMATION_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact person object.
 */
WMS._readContactPersonPrimary = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_PERSON_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Contact address object.
 */
WMS._readContactAddress = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.CONTACT_ADDRESS_PARSERS,
    node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Array.<string>|undefined} Format array.
 */
WMS._readException = function(node, objectStack) {
  return XMLParser.pushParseAndPop(
    [], WMS.EXCEPTION_PARSERS, node, objectStack);
};


/**
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @private
 * @return {Object|undefined} Layer object.
 */
WMS._readCapabilityLayer = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.LAYER_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Layer object.
 */
WMS._readLayer = function(node, objectStack) {
  var parentLayerObject = /**  @type {Object.<string,*>} */
    (objectStack[objectStack.length - 1]);

  var layerObject = /**  @type {Object.<string,*>} */
    (XMLParser.pushParseAndPop({}, WMS.LAYER_PARSERS,
      node, objectStack));

  if (!isDef(layerObject)) {
    return undefined;
  }

  var queryable = XSD.readBooleanString(node.getAttribute('queryable'));
  if (!isDef(queryable)) {
    queryable = parentLayerObject['queryable'];
  }
  layerObject['queryable'] = isDef(queryable) ? queryable : false;

  var cascaded = XSD.readNonNegativeIntegerString(node.getAttribute('cascaded'));
  if (!isDef(cascaded)) {
    cascaded = parentLayerObject['cascaded'];
  }
  layerObject['cascaded'] = cascaded;

  var opaque = XSD.readBooleanString(node.getAttribute('opaque'));
  if (!isDef(opaque)) {
    opaque = parentLayerObject['opaque'];
  }
  layerObject['opaque'] = isDef(opaque) ? opaque : false;

  var noSubsets = XSD.readBooleanString(node.getAttribute('noSubsets'));
  if (!isDef(noSubsets)) {
    noSubsets = parentLayerObject['noSubsets'];
  }
  layerObject['noSubsets'] = isDef(noSubsets) ? noSubsets : false;

  var fixedWidth = XSD.readDecimalString(node.getAttribute('fixedWidth'));
  if (!isDef(fixedWidth)) {
    fixedWidth = parentLayerObject['fixedWidth'];
  }
  layerObject['fixedWidth'] = fixedWidth;

  var fixedHeight = XSD.readDecimalString(node.getAttribute('fixedHeight'));
  if (!isDef(fixedHeight)) {
    fixedHeight = parentLayerObject['fixedHeight'];
  }
  layerObject['fixedHeight'] = fixedHeight;

  // See 7.2.4.8
  var addKeys = ['Style', 'CRS', 'AuthorityURL'];
  for (var i = 0, len = addKeys.length; i < len; i++) {
    var key = addKeys[i];
    var parentValue = parentLayerObject[key];
    if (isDef(parentValue)) {
      var childValue = setIfUndefined(layerObject, key, []);
      childValue = childValue.concat(parentValue);
      layerObject[key] = childValue;
    }
  }

  var replaceKeys = ['EX_GeographicBoundingBox', 'BoundingBox', 'Dimension',
    'Attribution', 'MinScaleDenominator', 'MaxScaleDenominator'
  ];
  for (var i = 0, len = replaceKeys.length; i < len; i++) {
    var key = replaceKeys[i];
    var childValue = layerObject[key];
    if (!isDef(childValue)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  }

  return layerObject;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object} Dimension object.
 */
WMS._readDimension = function(node, objectStack) {
  var dimensionObject = {
    'name': node.getAttribute('name'),
    'units': node.getAttribute('units'),
    'unitSymbol': node.getAttribute('unitSymbol'),
    'default': node.getAttribute('default'),
    'multipleValues': XSD.readBooleanString(node.getAttribute('multipleValues')),
    'nearestValue': XSD.readBooleanString(node.getAttribute('nearestValue')),
    'current': XSD.readBooleanString(node.getAttribute('current')),
    'values': XSD.readString(node)
  };
  return dimensionObject;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
WMS._readFormatOnlineresource = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.FORMAT_ONLINERESOURCE_PARSERS,
    node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Request object.
 */
WMS._readRequest = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.REQUEST_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} DCP type object.
 */
WMS._readDCPType = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.DCPTYPE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} HTTP object.
 */
WMS._readHTTP = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.HTTP_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Operation type object.
 */
WMS._readOperationType = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.OPERATIONTYPE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Online resource object.
 */
WMS._readSizedFormatOnlineresource = function(node, objectStack) {
  var formatOnlineresource = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(formatOnlineresource)) {
    var readNonNegativeIntegerString = XSD.readNonNegativeIntegerString;
    var size = [
      readNonNegativeIntegerString(node.getAttribute('width')),
      readNonNegativeIntegerString(node.getAttribute('height'))
    ];
    formatOnlineresource['size'] = size;
    return formatOnlineresource;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Authority URL object.
 */
WMS._readAuthorityURL = function(node, objectStack) {
  var authorityObject = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(authorityObject)) {
    authorityObject['name'] = node.getAttribute('name');
    return authorityObject;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Metadata URL object.
 */
WMS._readMetadataURL = function(node, objectStack) {
  var metadataObject = WMS._readFormatOnlineresource(node, objectStack);
  if (isDef(metadataObject)) {
    metadataObject['type'] = node.getAttribute('type');
    return metadataObject;
  }
  return undefined;
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */
WMS._readStyle = function(node, objectStack) {
  return XMLParser.pushParseAndPop({}, WMS.STYLE_PARSERS, node, objectStack);
};


/**
 * @private
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @return {Array.<string>|undefined} Keyword list.
 */
WMS._readKeywordList = function(node, objectStack) {
  return XMLParser.pushParseAndPop(
    [], WMS.KEYWORDLIST_PARSERS, node, objectStack);
};

/**
 * @const
 * @type {Array.<string>}
 */
WMS.NAMESPACE_URIS = [
  null,
  'http://www.opengis.net/wms'
];

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Service': makePropertySetter(WMS._readService),
    'Capability': makePropertySetter(WMS._readCapability)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CAPABILITY_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Request': makePropertySetter(WMS._readRequest),
    'Exception': makePropertySetter(WMS._readException),
    'Layer': makePropertySetter(WMS._readCapabilityLayer)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.SERVICE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'KeywordList': makePropertySetter(WMS._readKeywordList),
    'OnlineResource': makePropertySetter(XLink.readHref),
    'ContactInformation': makePropertySetter(WMS._readContactInformation),
    'Fees': makePropertySetter(XSD.readString),
    'AccessConstraints': makePropertySetter(XSD.readString),
    'LayerLimit': makePropertySetter(XSD.readNonNegativeInteger),
    'MaxWidth': makePropertySetter(XSD.readNonNegativeInteger),
    'MaxHeight': makePropertySetter(XSD.readNonNegativeInteger)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_INFORMATION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'ContactPersonPrimary': makePropertySetter(WMS._readContactPersonPrimary),
    'ContactPosition': makePropertySetter(XSD.readString),
    'ContactAddress': makePropertySetter(WMS._readContactAddress),
    'ContactVoiceTelephone': makePropertySetter(XSD.readString),
    'ContactFacsimileTelephone': makePropertySetter(XSD.readString),
    'ContactElectronicMailAddress': makePropertySetter(XSD.readString)
  });

/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_PERSON_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'ContactPerson': makePropertySetter(XSD.readString),
    'ContactOrganization': makePropertySetter(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.CONTACT_ADDRESS_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'AddressType': makePropertySetter(XSD.readString),
    'Address': makePropertySetter(XSD.readString),
    'City': makePropertySetter(XSD.readString),
    'StateOrProvince': makePropertySetter(XSD.readString),
    'PostCode': makePropertySetter(XSD.readString),
    'Country': makePropertySetter(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.EXCEPTION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': XMLParser.makeArrayPusher(XSD.readString)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.LAYER_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'KeywordList': makePropertySetter(WMS._readKeywordList),
    'CRS': XMLParser.makeObjectPropertyPusher(XSD.readString),
	  'SRS': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'EX_GeographicBoundingBox': makePropertySetter(WMS._readEXGeographicBoundingBox),
	  'LatLonBoundingBox': makePropertySetter(WMS._readLatLonBoundingBox),
    'BoundingBox': XMLParser.makeObjectPropertyPusher(WMS._readBoundingBox),
    'Dimension': XMLParser.makeObjectPropertyPusher(WMS._readDimension),
    'Attribution': makePropertySetter(WMS._readAttribution),
    'AuthorityURL': XMLParser.makeObjectPropertyPusher(WMS._readAuthorityURL),
    'Identifier': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'MetadataURL': XMLParser.makeObjectPropertyPusher(WMS._readMetadataURL),
    'DataURL': XMLParser.makeObjectPropertyPusher(WMS._readFormatOnlineresource),
    'FeatureListURL': XMLParser.makeObjectPropertyPusher(WMS._readFormatOnlineresource),
    'Style': XMLParser.makeObjectPropertyPusher(WMS._readStyle),
    'MinScaleDenominator': makePropertySetter(XSD.readDecimal),
    'MaxScaleDenominator': makePropertySetter(XSD.readDecimal),
    'ScaleHint': makePropertySetter(WMS._readScaleHint),
    'Layer': XMLParser.makeObjectPropertyPusher(WMS._readLayer)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.ATTRIBUTION_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Title': makePropertySetter(XSD.readString),
    'OnlineResource': makePropertySetter(XLink.readHref),
    'LogoURL': makePropertySetter(WMS._readSizedFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS =
  XMLParser.makeParsersNS(WMS.NAMESPACE_URIS, {
    'westBoundLongitude': makePropertySetter(
      XSD.readDecimal),
    'eastBoundLongitude': makePropertySetter(
      XSD.readDecimal),
    'southBoundLatitude': makePropertySetter(
      XSD.readDecimal),
    'northBoundLatitude': makePropertySetter(
      XSD.readDecimal)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.REQUEST_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'GetCapabilities': makePropertySetter(
      WMS._readOperationType),
    'GetMap': makePropertySetter(
      WMS._readOperationType),
    'GetFeatureInfo': makePropertySetter(
      WMS._readOperationType)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.OPERATIONTYPE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': XMLParser.makeObjectPropertyPusher(XSD.readString),
    'DCPType': XMLParser.makeObjectPropertyPusher(
      WMS._readDCPType)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.DCPTYPE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'HTTP': makePropertySetter(
      WMS._readHTTP)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.HTTP_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Get': makePropertySetter(
      WMS._readFormatOnlineresource),
    'Post': makePropertySetter(
      WMS._readFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.STYLE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Name': makePropertySetter(XSD.readString),
    'Title': makePropertySetter(XSD.readString),
    'Abstract': makePropertySetter(XSD.readString),
    'LegendURL': XMLParser.makeObjectPropertyPusher(WMS._readSizedFormatOnlineresource),
    'StyleSheetURL': makePropertySetter(WMS._readFormatOnlineresource),
    'StyleURL': makePropertySetter(WMS._readFormatOnlineresource)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.FORMAT_ONLINERESOURCE_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Format': makePropertySetter(XSD.readString),
    'OnlineResource': makePropertySetter(XLink.readHref)
  });


/**
 * @const
 * @type {Object.<string, Object.<string, XMLParser.Parser>>}
 * @private
 */
WMS.KEYWORDLIST_PARSERS = XMLParser.makeParsersNS(
  WMS.NAMESPACE_URIS, {
    'Keyword': XMLParser.makeArrayPusher(XSD.readString)
  });

module.exports = WMS;

},{"./node_types":2,"./utils/isdef":3,"./utils/setifundefined":4,"./xlink":7,"./xml_parser":8,"./xsd":9}],7:[function(require,module,exports){
"use strict";

/**
 * @const
 * @type {string}
 */
var NAMESPACE_URI = 'http://www.w3.org/1999/xlink';

module.exports = {

  /**
   * @param {Node} node Node.
   * @return {Boolean|undefined} Boolean.
   */
  readHref: function(node) {
    return node.getAttributeNS(NAMESPACE_URI, 'href');
  }
};

},{}],8:[function(require,module,exports){
"use strict";

var isDef = require('./utils/isdef');
var setIfUndefined = require('./utils/setifundefined');
var nodeTypes = require('./node_types');

/**
 * XML DOM parser
 * @constructor
 */
function XMLParser() {

  /**
   * @type {DOMParser}
   */
  this._parser = new DOMParser();
};

/**
 * @param  {String} xmlstring
 * @return {Document}
 */
XMLParser.prototype.toDocument = function(xmlstring) {
  return this._parser.parseFromString(xmlstring, 'application/xml');
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
XMLParser.getAllTextContent = function(node, normalizeWhitespace) {
  return XMLParser.getAllTextContent_(node, normalizeWhitespace, []).join('');
};


/**
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<String|string>} accumulator Accumulator.
 * @private
 * @return {Array.<String|string>} Accumulator.
 */
XMLParser.getAllTextContent_ = function(node, normalizeWhitespace, accumulator) {
  if (node.nodeType === nodeTypes.CDATA_SECTION ||
    node.nodeType === nodeTypes.TEXT) {
    if (normalizeWhitespace) {
      // FIXME understand why goog.dom.getTextContent_ uses String here
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      XMLParser.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
};

/**
 * @param {Object.<string, Object.<string, XMLParser.Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} bind The object to use as `this`.
 */
XMLParser.parseNode = function(parsersNS, node, objectStack, bind) {
  for (var n = XMLParser.firstElementChild(node); n; n = XMLParser.nextElementSibling(n)) {
    var namespaceURI = n.namespaceURI || null;
    var parsers = parsersNS[namespaceURI];
    if (isDef(parsers)) {
      var parser = parsers[n.localName];
      if (isDef(parser)) {
        parser.call(bind, n, objectStack);
      }
    }
  }
};

/**
 * Mostly for node.js
 * @param  {Node} node
 * @return {Node}
 */
XMLParser.firstElementChild = function(node) {
  var firstElementChild = node.firstElementChild || node.firstChild;
  while (firstElementChild && firstElementChild.nodeType !== nodeTypes.ELEMENT) {
    firstElementChild = firstElementChild.nextSibling;
  }
  return firstElementChild;
};

/**
 * Mostly for node.js
 * @param  {Node} node
 * @return {Node}
 */
XMLParser.nextElementSibling = function(node) {
  var nextElementSibling = node.nextElementSibling || node.nextSibling;
  while (nextElementSibling && nextElementSibling.nodeType !== nodeTypes.ELEMENT) {
    nextElementSibling = nextElementSibling.nextSibling;
  }
  return nextElementSibling;
};

/**
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {Object.<string, XMLParser.Parser>} parsers Parsers.
 * @param {Object.<string, Object.<string, XMLParser.Parser>>=} opt_parsersNS
 *     ParsersNS.
 * @return {Object.<string, Object.<string, XMLParser.Parser>>} Parsers NS.
 */
XMLParser.makeParsersNS = function(namespaceURIs, parsers, opt_parsersNS) {
  return /** @type {Object.<string, Object.<string, XMLParser.Parser>>} */ (
    XMLParser.makeStructureNS(namespaceURIs, parsers, opt_parsersNS));
};

/**
 * Creates a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */
XMLParser.makeStructureNS = function(namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = isDef(opt_structureNS) ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {XMLParser.Parser} Parser.
 * @template T
 */
XMLParser.makeObjectPropertySetter = function(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);
      if (isDef(value)) {
        var object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        var property = isDef(opt_property) ? opt_property : node.localName;
        object[property] = value;
      }
    });
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {Function} Parser.
 * @template T
 */
XMLParser.makeObjectPropertyPusher = function(valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);

      if (isDef(value)) {
        var object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
        var property = isDef(opt_property) ? opt_property : node.localName;
        var array = setIfUndefined(object, property, []);
        array.push(value);
      }
    });
};

/**
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {Function} Parser.
 * @template T
 */
XMLParser.makeArrayPusher = function(valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function(node, objectStack) {
      var value = valueReader.call(isDef(opt_this) ? opt_this : this,
        node, objectStack);
      if (isDef(value)) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    });
};

/**
 * @param {Object}                                     object Object.
 * @param {Object.<String, Object.<String, Function>>} parsersNS Parsers by namespace.
 * @param {Node}                                       node Node.
 * @param {Array.<*>}                                  objectStack Object stack.
 * @param {*=}                                         bind The object to use as `this`.
 * @return {Object|undefined} Object.
 */
XMLParser.pushParseAndPop = function(object, parsersNS, node, objectStack, bind) {
  objectStack.push(object);
  XMLParser.parseNode(parsersNS, node, objectStack, bind);
  return objectStack.pop();
};

module.exports = XMLParser;

},{"./node_types":2,"./utils/isdef":3,"./utils/setifundefined":4}],9:[function(require,module,exports){
"use strict";

var isDef = require('./utils/isdef');
var string = require('./utils/string');
var XMLParser = require('./xml_parser');

var XSD = {};

/**
 * @const
 * @type {string}
 */
XSD.NAMESPACE_URI = 'http://www.w3.org/2001/XMLSchema';

/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */
XSD.readBoolean = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readBooleanString(s);
};

/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */
XSD.readBooleanString = function(string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return isDef(m[1]) || false;
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */
XSD.readDateTime = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  var re = /^\s*(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(Z|(?:([+\-])(\d{2})(?::(\d{2}))?))\s*$/;
  var m = re.exec(s);
  if (m) {
    var year = parseInt(m[1], 10);
    var month = parseInt(m[2], 10) - 1;
    var day = parseInt(m[3], 10);
    var hour = parseInt(m[4], 10);
    var minute = parseInt(m[5], 10);
    var second = parseInt(m[6], 10);
    var dateTime = Date.UTC(year, month, day, hour, minute, second) / 1000;
    if (m[7] != 'Z') {
      var sign = m[8] == '-' ? -1 : 1;
      dateTime += sign * 60 * parseInt(m[9], 10);
      if (isDef(m[10])) {
        dateTime += sign * 60 * 60 * parseInt(m[10], 10);
      }
    }
    return dateTime;
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */
XSD.readDecimal = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readDecimalString(s);
};


/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */
XSD.readDecimalString = function(string) {
  // FIXME check spec
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */
XSD.readNonNegativeInteger = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return XSD.readNonNegativeIntegerString(s);
};


/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */
XSD.readNonNegativeIntegerString = function(string) {
  var m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  } else {
    return undefined;
  }
};


/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */
XSD.readString = function(node) {
  var s = XMLParser.getAllTextContent(node, false);
  return string.trim(s);
};


/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */
XSD.writeBooleanTextNode = function(node, bool) {
  XSD.writeStringTextNode(node, (bool) ? '1' : '0');
};


/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */
XSD.writeDateTimeTextNode = function(node, dateTime) {
  var date = new Date(dateTime * 1000);
  var string = date.getUTCFullYear() + '-' +
    string.padNumber(date.getUTCMonth() + 1, 2) + '-' +
    string.padNumber(date.getUTCDate(), 2) + 'T' +
    string.padNumber(date.getUTCHours(), 2) + ':' +
    string.padNumber(date.getUTCMinutes(), 2) + ':' +
    string.padNumber(date.getUTCSeconds(), 2) + 'Z';
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */
XSD.writeDecimalTextNode = function(node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */
XSD.writeNonNegativeIntegerTextNode = function(node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};


/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */
XSD.writeStringTextNode = function(node, string) {
  node.appendChild(XMLParser.DOCUMENT.createTextNode(string));
};

module.exports = XSD;

},{"./utils/isdef":3,"./utils/string":5,"./xml_parser":8}]},{},[1])(1)
});
define('Registry/WMSServer',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "../Layer/LayerFactory",
    "wms-capabilities"
], function($, _, Utils, XmlToJson, LayerFactory, WMSCapabilities) {
    var WMSServer = function(proxyUse, proxyUrl, options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WMSServer.getCapabilitiesFromBaseURl(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WMSLayer.js"
            );
        }
        this.proxyUse = proxyUse;
        this.proxyUrl = proxyUrl;
        this.options = options;
    };

    function _mustBeSkipped(layersFromConf, currentLayerName) {
        return (
            layersFromConf.length !== 0 &&
            !_.contains(layersFromConf, currentLayerName)
        );
    }

    function _hasGroup(jsonLayer) {
        return Array.isArray(jsonLayer.Layer);
    }

    function _computeAttribution(layerDescription, jsonLayers, jsonLayer) {
        var attribution, logo, title;
        if (layerDescription.attribution) {
            attribution = layerDescription.attribution;
        } else if (jsonLayer.Attribution != null) {
            logo =
                jsonLayer.Attribution.LogoURL != null
                    ? "<img src='" +
                      jsonLayer.Attribution.LogoURL.OnlineResource +
                      "' height='25px'/> "
                    : "";
            title =
                jsonLayer.Attribution.Title != null
                    ? jsonLayer.Attribution.Title
                    : "";
            attribution = logo + title;
        } else if (jsonLayers.Attribution != null) {
            logo =
                jsonLayers.Attribution.LogoURL != null
                    ? "<img src='" +
                      jsonLayers.Attribution.LogoURL.OnlineResource +
                      "' height='25px'/> "
                    : "";
            title =
                jsonLayers.Attribution.Title != null
                    ? jsonLayers.Attribution.Title
                    : "";
            attribution = logo + title;
        } else {
            attribution = null;
        }
        return attribution;
    }

    function _computeCopyrightURL(layerDescription, jsonLayers, jsonLayer) {
        var copyrightURL;
        if (layerDescription.copyrightUrl) {
            copyrightURL = layerDescription.copyrightUrl;
        } else if (jsonLayer.Attribution != null) {
            copyrightURL =
                jsonLayer.Attribution.OnlineResource != null
                    ? jsonLayer.Attribution.OnlineResource
                    : "";
        } else if (jsonLayers.Attribution != null) {
            copyrightURL =
                jsonLayers.Attribution.OnlineResource != null
                    ? jsonLayers.Attribution.OnlineResource
                    : "";
        } else {
            copyrightURL = "";
        }
        return copyrightURL;
    }

    function _computeCenterBbox(bbox) {
        var centerLong = 0.5 * (bbox[0] + bbox[2]);
        var centerLat = 0.5 * (bbox[1] + bbox[3]);
        var deltaLong = bbox[2] - bbox[0];
        if (deltaLong > 180) {
            deltaLong = 180;
        }
        var deltaLat = bbox[3] - bbox[1];
        var delta = deltaLong > deltaLat ? deltaLat : deltaLong;
        return [centerLong, centerLat];
    }

    function _bbox(jsonLayer) {
        var bbox = jsonLayer.EX_GeographicBoundingBox;
        var result;
        if (bbox == null) {
            result = [-180, -90, 180, 90];
        } else {
            var long1 = bbox[0] > 180 ? bbox[0] - 360 : bbox[0];
            var long2 = bbox[2] > 180 ? bbox[2] - 360 : bbox[2];
            result = [long1, bbox[1], long2, bbox[3]];
        }
        return result;
    }

    function _bboxGroup(jsonLayer) {
        var result;
        if (_hasGroup.call(this, jsonLayer)) {
            var layer, layerBbox;
            var minLong = 180,
                maxLong = -180,
                minLat = 90,
                maxLat = -90;
            for (var i = 0; i < jsonLayer.Layer.length; i++) {
                layer = jsonLayer.Layer[i];
                layerBbox = _bbox.call(this, layer);
                minLong = Math.min(minLong, layerBbox[0]);
                minLat = Math.min(minLat, layerBbox[1]);
                maxLong = Math.max(maxLong, layerBbox[2]);
                maxLat = Math.max(maxLat, layerBbox[3]);
            }
            result = [minLong, minLat, maxLong, maxLat];
        } else {
            result = _bbox.call(this, jsonLayer);
        }
        return result;
    }

    WMSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            Utils.proxify(this.options.getCapabilities, {
                use: this.proxyUse,
                url: this.proxyUrl
            }),
            "text",
            {},
            function(response) {
                var metadata = new WMSCapabilities().parse(response);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    function _parseDimension(dimension) {
        if (dimension == null) {
            return null;
        }
        var dim = {};
        for (var i = 0; i < dimension.length; i++) {
            var currentDim = dimension[i];
            var myDim = {
                units: currentDim.units,
                unitSymbol: currentDim.unitSymbol,
                default: currentDim.default,
                multipleValues: currentDim.multipleValues,
                nearestValue: currentDim.nearestValue,
                value: currentDim.values
            };
            dim[currentDim.name] = myDim;
        }
        return dim;
    }

    function _createLayer(layerDescription, jsonLayers, jsonLayer) {
        var attribution = [];
        if (_hasGroup.call(this, jsonLayer)) {
            for (var i = 0; i < jsonLayer.Layer.length; i++) {
                var layer = jsonLayer.Layer[i];
                attribution.push(
                    _computeAttribution.call(
                        this,
                        layerDescription,
                        jsonLayers,
                        layer
                    )
                );
            }
        } else {
            attribution.push(
                _computeAttribution.call(
                    this,
                    layerDescription,
                    jsonLayers,
                    jsonLayer
                )
            );
        }
        var copyrightURL = _computeCopyrightURL.call(
            this,
            layerDescription,
            jsonLayers,
            jsonLayer
        );
        var bbox = _bboxGroup.call(this, jsonLayer);
        var center = _computeCenterBbox.call(this, bbox);
        var layerDesc = Object.assign({}, layerDescription, {});
        layerDesc.name = layerDescription.name || jsonLayer.Title;
        layerDesc.format = layerDescription.format || "image/png";
        layerDesc.layers = jsonLayer.Name;
        layerDesc.description =
            layerDescription.description || jsonLayer.Abstract != null
                ? jsonLayer.Abstract
                : jsonLayers.Abstract;
        layerDesc.attribution = attribution.join("<br/>");
        layerDesc.copyrightUrl = copyrightURL;
        layerDesc.autoFillTimeTravel = layerDescription.autoFillTimeTravel;
        layerDesc.properties = {
            initialRa: center[0],
            initialDec: center[1],
            bbox: bbox
        };
        layerDesc.dimension = _parseDimension.call(this, jsonLayer.Dimension);
        layerDesc.metadataAPI = jsonLayer;

        return LayerFactory.create(layerDesc);
    }

    function _createLayers(layerDescription, layersFromConf, jsonLayers) {
        var layers = [];
        for (var i = 0; i < jsonLayers.Layer.length; i++) {
            var jsonLayer = jsonLayers.Layer[i];
            if (jsonLayer.Layer != null) {
                layers = layers.concat(
                    _createLayers(layerDescription, layersFromConf, jsonLayer)
                );
            }
            if (_mustBeSkipped.call(this, layersFromConf, jsonLayer.Name)) {
                continue;
            }
            layers.push(
                _createLayer.call(this, layerDescription, jsonLayers, jsonLayer)
            );
        }
        return layers;
    }

    WMSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];
            var jsonLayers = metadata.Capability.Layer;
            var layers = _createLayers(
                layerDescription,
                layersFromConf,
                jsonLayers
            );
            callback(layers);
        }, fallback);
    };

    WMSServer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.3.0"
        );
        return getCapabilitiesUrl;
    };

    return WMSServer;
});

define('Registry/WMSServerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "./WMSServer"
], function(Utils, AbstractRegistryHandler, Constants, WMSServer) {
    var WMSServerRegistryHandler = function(mizarConfiguration, pendingLayers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
        this.proxyUse = mizarConfiguration.proxyUse;
        this.proxyUrl = mizarConfiguration.proxyUrl;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WMSServerRegistryHandler);

    /**************************************************************************************************************/

    WMSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WMS) {
                var wmsServer = new WMSServer(
                    this.proxyUse,
                    this.proxyUrl,
                    layerDescription
                );
                var self = this;
                wmsServer.createLayers(function(layers) {
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                console.error(e);
            }
        }
    };

    return WMSServerRegistryHandler;
});

define('Registry/WMTSServer',[
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "./WMTSMetadata",
    "../Layer/LayerFactory"
], function(_, Utils, XmlToJson, WMTSMetadata, LayerFactory) {
    var WMTSServer = function(proxyUse, proxyUrl, options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WMTSServer.getCapabilitiesFromBaseURl(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WMSLayer.js"
            );
        }
        this.proxyUse = proxyUse;
        this.proxyUrl = proxyUrl;
        this.options = options;
    };

    function _mustBeSkipped(layersFromConf, currentLayer) {
        return (
            (layersFromConf.length !== 0 &&
                !_.contains(layersFromConf, currentLayer.identifier)) ||
            !_.contains(currentLayer.tileMatrixSetLink, "WGS84")
        );
    }

    WMTSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            Utils.proxify(this.options.getCapabilities, {
                use: this.proxyUse,
                url: this.proxyUrl
            }),
            "text",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var result = XmlToJson.parseString(response, myOptions);
                var metadata = new WMTSMetadata(result);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    WMTSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];
            var jsonLayers = metadata.contents;
            var layers = [];
            for (var i = 0; i < jsonLayers.layers.length; i++) {
                var jsonLayer = jsonLayers.layers[i];
                if (_mustBeSkipped.call(this, layersFromConf, jsonLayer)) {
                    continue;
                }
                var attribution;
                if (layerDescription.attribution) {
                    attribution = layerDescription.attribution;
                } else {
                    attribution = null;
                }

                var copyrightURL = null;

                var layerDesc = Object.assign({}, layerDescription, {});
                layerDesc.name = layerDescription.name || jsonLayer.identifier;
                layerDesc.format = layerDescription.format || "image/png";
                layerDesc.layers = jsonLayer.title;
                layerDesc.description =
                    layerDescription.description || jsonLayer.abstract != null
                        ? jsonLayer.abstract
                        : jsonLayers.abstract;
                layerDesc.attribution = attribution;
                layerDesc.copyrightUrl = copyrightURL;

                var layer = LayerFactory.create(layerDesc);
                layers.push(layer);
            }
            callback(layers);
        }, fallback);
    };

    WMTSServer.getCapabilitiesFromBaseURl = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WMTS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    return WMTSServer;
});

define('Registry/WMTSServerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "./WMTSServer"
], function(Utils, AbstractRegistryHandler, Constants, WMTSServer) {
    var WMTSServerRegistryHandler = function(
        mizarConfiguration,
        pendingLayers
    ) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
        this.proxyUse = mizarConfiguration.proxyUse;
        this.proxyUrl = mizarConfiguration.proxyUrl;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WMTSServerRegistryHandler);

    /**************************************************************************************************************/

    WMTSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WMTS) {
                var wmtsServer = new WMTSServer(
                    this.proxyUse,
                    this.proxyUrl,
                    layerDescription
                );
                var self = this;
                wmtsServer.createLayers(function(layers) {
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                console.error(e);
            }
        }
    };

    return WMTSServerRegistryHandler;
});

define('Registry/WCSServer',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "xmltojson",
    "../Layer/LayerFactory"
], function($, _, Utils, XmlToJson, LayerFactory, WCS) {
    var WCSServer = function(proxyUse, proxyUrl, options) {
        if (options.getCapabilities) {
            options.baseUrl = Utils.computeBaseUrlFromCapabilities(
                options.getCapabilities,
                ["service", "request", "version"]
            );
        } else if (options.baseUrl) {
            options.getCapabilities = WCSServer.getCapabilitiesFromBaseURL(
                options.baseUrl,
                options
            );
        } else {
            throw new ReferenceError(
                "No URL to access to the server is defined",
                "WCSServer.js"
            );
        }
        options.describeCoverage = WCSServer.describeCoverageFromBaseURL(
            options.baseUrl,
            options
        );
        this.proxyUse = proxyUse;
        this.proxyUrl = proxyUrl;
        this.options = options;
    };

    function _mustBeSkipped(layersFromConf, currentLayer) {
        return (
            layersFromConf.length !== 0 &&
            !_.contains(layersFromConf, currentLayer.name._text)
        );
    }

    function _bbox(jsonBbox) {
        var pos = jsonBbox.pos;
        var pos1 = pos[0]._text.split(" ");
        var pos2 = pos[1]._text.split(" ");
        return [
            parseFloat(pos1[0]),
            parseFloat(pos1[1]),
            parseFloat(pos2[0]),
            parseFloat(pos2[1])
        ];
    }

    function _computeCenterBbox(bbox) {
        var center;
        if (bbox == null) {
            center = [0, 0];
        } else {
            var centerLong = 0.5 * (bbox[0] + bbox[2]);
            var centerLat = 0.5 * (bbox[1] + bbox[3]);
            var deltaLong = bbox[2] - bbox[0];
            if (deltaLong > 180) {
                deltaLong = 180;
            }
            var deltaLat = bbox[3] - bbox[1];
            var delta = deltaLong > deltaLat ? deltaLat : deltaLong;
            var distance = (Math.abs(delta) * 3000000) / 180;
            center = [centerLong, centerLat, distance];
        }
        return center;
    }

    function _timeVal(lonlat) {
        var values;
        if (lonlat.timePosition == null) {
            values = null;
        } else {
            var timeArr = [];
            var time = lonlat.timePosition;
            for (var i = 0; i < time.length; i++) {
                timeArr.push(time[i]._text);
            }
            values = timeArr.join(",");
        }
        return values;
    }

    WCSServer.prototype.getMetadata = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            Utils.proxify(this.options.getCapabilities, {
                use: this.proxyUse,
                url: this.proxyUrl
            }),
            "text",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var metadata = XmlToJson.parseString(response, myOptions);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    WCSServer.prototype.getCoverage = function(callback, fallback) {
        var self = this;
        Utils.requestUrl(
            Utils.proxify(this.options.describeCoverage, {
                use: this.proxyUse,
                url: this.proxyUrl
            }),
            "text",
            {},
            function(response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                };
                var metadata = XmlToJson.parseString(response, myOptions);
                callback(self.options, metadata);
            },
            function(e) {
                if (fallback) {
                    e.setLayerDescription(self.options);
                    fallback(e);
                }
            }
        );
    };

    WCSServer.prototype.createLayers = function(callback, fallback) {
        this.getMetadata(function(layerDescription, metadata) {
            var layersFromConf = layerDescription.hasOwnProperty("layers")
                ? layerDescription.layers.trim().split(/\s*,\s*/)
                : [];
            var jsonLayers = [];
            var contentMetadata = metadata.WCS_Capabilities.ContentMetadata;
            if (Array.isArray(contentMetadata.CoverageOfferingBrief)) {
                jsonLayers = contentMetadata.CoverageOfferingBrief;
            } else {
                jsonLayers.push(contentMetadata);
            }
            var layers = [];
            for (var i = 0; i < jsonLayers.length; i++) {
                var jsonLayer = jsonLayers[i].CoverageOfferingBrief;
                if (_mustBeSkipped.call(this, layersFromConf, jsonLayer)) {
                    continue;
                }
                var attribution;
                if (layerDescription.attribution) {
                    attribution = layerDescription.attribution;
                } else {
                    attribution = null;
                }

                var copyrightURL = null;

                var layerDesc = Object.assign({}, layerDescription, {});
                layerDesc.name = layerDescription.name || jsonLayer.label._text;
                layerDesc.format = layerDescription.format;
                layerDesc.layers = jsonLayer.name._text;
                layerDesc.description = layerDescription.description;
                layerDesc.attribution = attribution;
                layerDesc.copyrightUrl = copyrightURL;
                var bbox = _bbox.call(this, jsonLayer.lonLatEnvelope);
                var center = _computeCenterBbox.call(this, bbox);
                layerDesc.properties = {
                    initialRa: center[0],
                    initialDec: center[1],
                    initialFov: center[2],
                    bbox: bbox
                };
                var timeValue = _timeVal.call(this, jsonLayer.lonLatEnvelope);
                layerDesc.dimension = {};
                if (timeValue != null) {
                    layerDesc.dimension.time = {
                        units: "ISO8601",
                        unitSymbol: null,
                        default: null,
                        multipleValues: null,
                        nearestValue: null,
                        current: null,
                        value: timeValue
                    };
                }

                layerDesc.metadataAPI = jsonLayer;

                if (
                    layerDesc.dimension.time &&
                    layerDesc.dimension.time.value != null
                ) {
                    layerDesc.time = layerDesc.dimension.time.value.split(
                        ","
                    )[0];
                }
                var layer = LayerFactory.create(layerDesc);
                layers.push(layer);
            }
            callback(layers);
        }, fallback);
    };

    WCSServer.getCapabilitiesFromBaseURL = function(baseUrl, options) {
        var getCapabilitiesUrl = baseUrl;
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "service",
            "WCS"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "request",
            "getCapabilities"
        );
        getCapabilitiesUrl = Utils.addParameterTo(
            getCapabilitiesUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return getCapabilitiesUrl;
    };

    WCSServer.describeCoverageFromBaseURL = function(baseUrl, options) {
        var describeCoverageUrl = baseUrl;
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "service",
            "WCS"
        );
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "request",
            "describeCoverage"
        );
        describeCoverageUrl = Utils.addParameterTo(
            describeCoverageUrl,
            "version",
            options.hasOwnProperty("version") ? options.version : "1.0.0"
        );
        return describeCoverageUrl;
    };

    return WCSServer;
});

define('Registry/WCSServerRegistryHandler',[
    "underscore-min",
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants",
    "./WCSServer"
], function(_, Utils, AbstractRegistryHandler, Constants, WCSServer) {
    var WCSServerRegistryHandler = function(
        layers,
        mizarConfiguration,
        pendingLayers
    ) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.layers = layers;
        this.pendingLayers = pendingLayers;
        this.proxyUse = mizarConfiguration.proxyUse;
        this.proxyUrl = mizarConfiguration.proxyUrl;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, WCSServerRegistryHandler);

    /**************************************************************************************************************/

    /**
     * Moves an elements of the array to another index
     * @param {[]} array array
     * @param {number} from index where the element to move is located
     * @param {number} to index where the element must be gone.
     * @private
     */
    function _moveArrayEltFromTo(array, from, to) {
        var extracted = array.splice(from, 1)[0];
        array.splice(to, 0, extracted);
    }

    /**
     * Destroys the TileWireFrame if it exists and returns its layer description.
     * @param layers list of layers to load
     * @private
     */
    function _destroyTileWireFrame(layers) {
        var i, layerDescription;
        var isFound = false;
        for (i = 0; i < layers.length; i++) {
            var layer = layers[i];
            if (layer.getType() === Constants.LAYER.TileWireframe) {
                isFound = true;
                break;
            }
        }
        if (isFound) {
            var layerToRemove = layers[i];
            layerDescription = layerToRemove.options;
            layerToRemove._detach();
            layers.splice(i, 1);
        }
        return layerDescription;
    }

    /**
     * Moves the TileWireFrameLayer to render at this end.
     * @param layers layers to render
     * @param AbstractRegistryHandler Registry
     * @param callback callback
     * @param fallback fallback
     * @private
     */
    function _moveTileWireFrameLayer(
        layers,
        AbstractRegistryHandler,
        callback,
        fallback
    ) {
        var layerDescription = _destroyTileWireFrame(layers);
        if (layerDescription) {
            AbstractRegistryHandler.next.handleRequest(
                layerDescription,
                callback,
                fallback
            );
        }
    }

    WCSServerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        try {
            if (layerDescription.type === Constants.LAYER.WCSElevation) {
                var wcsServer = new WCSServer(
                    this.proxyUse,
                    this.proxyUrl,
                    layerDescription
                );
                var self = this;
                wcsServer.createLayers(function(layers) {
                    self._handlePendingLayers(self.pendingLayers, layers);
                    callback(layers);
                    _moveTileWireFrameLayer(
                        self.layers,
                        self,
                        callback,
                        fallback
                    );
                }, fallback);
            } else {
                this.next.handleRequest(layerDescription, callback, fallback);
            }
        } catch (e) {
            if (fallback) {
                fallback(e);
            } else {
                console.error(e);
            }
        }
    };

    return WCSServerRegistryHandler;
});

define('Registry/PendingLayersRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Utils/Constants"
], function(Utils, AbstractRegistryHandler, Constants) {
    var PendingLayersRegistryHandler = function(pendingLayers, layers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.layers = layers;
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, PendingLayersRegistryHandler);

    /**************************************************************************************************************/

    PendingLayersRegistryHandler.prototype.hasLayerBackground = function() {
        var hasBackground = false;
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            if (layer.isBackground() && layer.isVisible()) {
                hasBackground = true;
                break;
            }
        }
        return hasBackground;
    };

    PendingLayersRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        if (
            (layerDescription.type === Constants.LAYER.Atmosphere ||
                layerDescription.type === Constants.LAYER.TileWireframe) &&
            !this.hasLayerBackground()
        ) {
            this.pendingLayers.push(layerDescription);
        } else {
            this.next.handleRequest(layerDescription, callback, fallback);
        }
    };

    return PendingLayersRegistryHandler;
});

define('Registry/LayerRegistryHandler',[
    "../Utils/Utils",
    "./AbstractRegistryHandler",
    "../Layer/LayerFactory"
], function(Utils, AbstractRegistryHandler, LayerFactory) {
    var LayerRegistryHandler = function(pendingLayers) {
        AbstractRegistryHandler.prototype.constructor.call();
        this.pendingLayers = pendingLayers;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractRegistryHandler, LayerRegistryHandler);

    /**************************************************************************************************************/

    LayerRegistryHandler.prototype.handleRequest = function(
        layerDescription,
        callback,
        fallback
    ) {
        var layers = [];
        try {
            var layer = LayerFactory.create(layerDescription);
            layers.push(layer);
            this._handlePendingLayers(this.pendingLayers, layers);
            callback(layers);
        } catch (e) {
            if (e instanceof RangeError) {
                this.next.handleRequest(layerDescription, callback, fallback);
            } else if (fallback) {
                fallback(e);
            } else {
                console.error(e);
            }
        }
    };

    return LayerRegistryHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" component
 */
define('Services/CompassCore',["jquery", "../Utils/Constants"], function($, Constants) {
    const MAX_ROTATION = 360;

    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var crs = null;
    var svgDoc = null;

    /**************************************************************************************************************/

    /**
     * Aligns with north.
     * @param {object} event
     * @private
     */
    function _alignWithNorth(event) {
        var coordinateSystem = ctx.getCoordinateSystem();
        var radius = coordinateSystem.getGeoide().getRadius();

        // scale the up direction to the sphere's surface in order to have the right value after projection.
        var up = [0, 0, radius];

        var temp = [];
        coordinateSystem.from3DToGeo(up, temp);
        temp = coordinateSystem.convert(
            temp,
            coordinateSystem.getGeoideName(),
            crs
        );
        coordinateSystem.fromGeoTo3D(temp, up);
        ctx.getNavigation().moveUpTo(up);
    }

    /**************************************************************************************************************/

    function updateNorthPlanet() {
        var navigation = ctx.getNavigation();
        var currentHeading = navigation.getHeading();

        var upHeading = 0;
        var degNorth =
            (currentHeading - upHeading + MAX_ROTATION) % MAX_ROTATION;

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    function updateNorthAzimuth() {
        var navigation = ctx.getNavigation();
        var currentHeading = navigation.getHeading();

        var upHeading = 0;
        var degNorth =
            (upHeading - currentHeading + MAX_ROTATION) % MAX_ROTATION;

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    function updateNorthSky() {
        var geo = [];
        var coordinateSystem = ctx.getCoordinateSystem();
        var center = ctx.getNavigation().center3d
            ? ctx.getNavigation().center3d
            : (center = ctx.getNavigation().geoCenter);
        coordinateSystem.from3DToGeo(center, geo);
        geo = coordinateSystem.convert(
            geo,
            crs,
            coordinateSystem.getGeoideName()
        );

        var LHV = [];
        coordinateSystem.getLHVTransform(geo, LHV);

        var temp = [];
        var north = [LHV[4], LHV[5], LHV[6]];
        var vertical = [LHV[8], LHV[9], LHV[10]];

        var up = vec3.create(ctx.getNavigation().up);
        vec3.scale(up, coordinateSystem.getGeoide().getRadius());

        coordinateSystem.from3DToGeo(up, temp);
        temp = coordinateSystem.convert(
            temp,
            crs,
            coordinateSystem.getGeoideName()
        );
        coordinateSystem.fromGeoTo3D(temp, up);
        vec3.normalize(up);
        // Find angle between up and north
        var cosNorth =
            vec3.dot(up, north) / (vec3.length(up) * vec3.length(north));
        var radNorth = Math.acos(cosNorth);

        if (isNaN(radNorth)) {
            return;
        }
        var degNorth = (radNorth * 180) / Math.PI;

        // Find sign between up and north
        var sign;
        vec3.cross(up, north, temp);
        sign = vec3.dot(temp, [vertical[0], vertical[1], vertical[2]]);
        if (sign < 0) {
            degNorth *= -1;
        }

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    /**
     * Function updating the north position on compass
     */
    function updateNorth() {
        var mode = ctx.getMode();
        switch (mode) {
            case Constants.CONTEXT.Sky:
                updateNorthSky();
                break;
            case Constants.CONTEXT.Planet:
                updateNorthPlanet();
                break;
            case Constants.CONTEXT.Ground:
                updateNorthAzimuth();
                break;
            default:
                throw new RangeError(
                    "CompassCore is not supported for this context",
                    "CompassCore.js"
                );
        }
    }

    /**************************************************************************************************************/

    /**
     *    Remove compass element
     *
     */
    function remove() {
        document.getElementById(parentElement).innerHTML = "";
    }

    /**************************************************************************************************************/

    return {
        init: function(options) {
            parentElement = options.element;
            //ctx = options.ctx;
            //crs = ctx.getCoordinateSystem().getGeoideName();
            //svgDoc = options.svgDoc;
        },
        setSvg: function(svg) {
            svgDoc = svg;
        },
        setCtx: function(context) {
            ctx = context;
            crs = context.getCoordinateSystem().getGeoideName();
        },
        updateNorth: updateNorth,
        _alignWithNorth: _alignWithNorth,
        remove: remove
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" composant
 */
define('Gui/Compass',[
    "jquery",
    "../Utils/Constants",
    "../Services/CompassCore",
    "../Utils/Utils"
], function($, Constants, CompassCore, Utils) {
    const COMPASS_SVG =
        "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0idGV4dC9jc3MiIGhyZWY9ImNvbXBhc3MuY3NzIj8+PHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjUyMCIKICAgaGVpZ2h0PSI1MjAiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuNDguMSByOTc2MCIKICAgc29kaXBvZGk6ZG9jbmFtZT0iY29tcGFzc05vcnRoMi5zdmciCiAgIHZpZXdCb3g9Ii0yMjAgLTIyMCA1MjAgNTIwIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczQzIj4KICAgIDxyYWRpYWxHcmFkaWVudAogICAgICAgaWQ9ImdyYWQxIgogICAgICAgY3g9IjAiCiAgICAgICBjeT0iMCIKICAgICAgIHI9IjIwNyIKICAgICAgIGZ4PSIwIgogICAgICAgZnk9IjAiCiAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wCiAgICAgICAgIG9mZnNldD0iMC43NSIKICAgICAgICAgaWQ9InN0b3A2IgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojZmZmZmZmO3N0b3Atb3BhY2l0eTowIiAvPgogICAgICA8c3RvcAogICAgICAgICBvZmZzZXQ9IjAuOTQ5OTk5OTkiCiAgICAgICAgIGlkPSJzdG9wOCIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2ZmOTkwMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3AKICAgICAgICAgb2Zmc2V0PSIxMDAlIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjpyZ2IoMjU1LCAyNTUsIDI1NSk7c3RvcC1vcGFjaXR5OjAiCiAgICAgICAgIGlkPSJzdG9wMTAiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEyODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwMCIKICAgICBpZD0ibmFtZWR2aWV3NDEiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjAuNDEzMTgxODMiCiAgICAgaW5rc2NhcGU6Y3g9IjEwMy43NDIwNiIKICAgICBpbmtzY2FwZTpjeT0iNDguNTQ5MDc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkVhc3QiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpndWlkZS1iYm94PSJ0cnVlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMwMTAiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPGcKICAgICBpZD0iT3V0ZXJDaXJjbGUiCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4xNDI4MTM4LDAsMCwxLjEwNTc4OCwwLjMwODI3MzYsNC42MTQ3ODQpIj4KICAgIDxnCiAgICAgICBpZD0iZzMyNjciCiAgICAgICBzdHlsZT0ib3BhY2l0eTowLjYiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOmN5PSIwIgogICAgICAgICBzb2RpcG9kaTpjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJtIDIwNywwIGMgMCwxMTQuMzIyOTQgLTkyLjY3NzA2LDIwNyAtMjA3LDIwNyAtMTE0LjMyMjk0LDAgLTIwNywtOTIuNjc3MDYgLTIwNywtMjA3IDAsLTExNC4zMjI5NCA5Mi42NzcwNiwtMjA3IDIwNywtMjA3IDExNC4zMjI5NCwwIDIwNyw5Mi42NzcwNiAyMDcsMjA3IHoiCiAgICAgICAgIGlkPSJjaXJjbGUyNCIKICAgICAgICAgcj0iMjA3IgogICAgICAgICBzdHlsZT0ib3BhY2l0eTowLjc1O2ZpbGw6dXJsKCNncmFkMSkiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMTA1MjI3OSwwLDAsMS4xMDUyMjc5LDM0LDMyKSIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzE4IgogICAgICAgc3R5bGU9InN0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxMCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuOTY1NTg4OTksMCwwLDAuOTcxMzI0MTUsMzQsMzIpIj4KICAgICAgPGNpcmNsZQogICAgICAgICByPSIyMTEiCiAgICAgICAgIGlkPSJjaXJjbGUyMCIKICAgICAgICAgZD0ibSAyMTEsMCBjIDAsMTE2LjUzMjA4IC05NC40Njc5MiwyMTEgLTIxMSwyMTEgLTExNi41MzIwOCwwIC0yMTEsLTk0LjQ2NzkyIC0yMTEsLTIxMSAwLC0xMTYuNTMyMDggOTQuNDY3OTIsLTIxMSAyMTEsLTIxMSAxMTYuNTMyMDgsMCAyMTEsOTQuNDY3OTIgMjExLDIxMSB6IgogICAgICAgICBjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6cng9IjIxMSIKICAgICAgICAgc29kaXBvZGk6cnk9IjIxMSIgLz4KICAgIDwvZz4KICA8L2c+CiAgPGcKICAgICBpZD0iU291dGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjU3ODM4MywzNi45NzA0MzUpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ciCiAgICAgICBkPSJNIDM5LjQxNiw5NS4xNiBDIDMzLjY1LDEwMy45NSAzMC43NiwxMTAuNSAyOC45MywxMTcuMTggMTUuMjQsMTEzLjQzIDEzLjU0LDEyNy4xNSAyMy4wNCwxMzEgMTMuNzEsMTQ1LjggNy44NCwxNzMuOTMgMCwyMTIgTCAwLDEwMyBhIDEwMywxMDMgMCAwIDAgMzkuNDE2LC03Ljg0IHoiIC8+CiAgICA8dXNlCiAgICAgICBoZWlnaHQ9IjQ0MCIKICAgICAgIHdpZHRoPSI0NDAiCiAgICAgICB5PSIwIgogICAgICAgeD0iMCIKICAgICAgIGlkPSJzb3V0aCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93IiAvPgogIDwvZz4KICA8ZwogICAgIGlkPSJFYXN0IgogICAgIGNsYXNzPSJhcnJvdyIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDEsLTEsMCwzOC44MDYyMSwzNy4yMjA0MjkpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNiIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZiIKICAgICAgIGlkPSJzb3V0aC01IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNiIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iTm9ydGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwtMSw0MS45MDI3OCw0My43ODMzNzYpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNi0wIgogICAgICAgZD0iTSAzOS40MTYsOTUuMTYgQyAzMy42NSwxMDMuOTUgMzAuNzYsMTEwLjUgMjguOTMsMTE3LjE4IDE1LjI0LDExMy40MyAxMy41NCwxMjcuMTUgMjMuMDQsMTMxIDEzLjcxLDE0NS44IDcuODQsMTczLjkzIDAsMjEyIEwgMCwxMDMgYSAxMDMsMTAzIDAgMCAwIDM5LjQxNiwtNy44NCB6IiAvPgogICAgPHVzZQogICAgICAgaGVpZ2h0PSI0NDAiCiAgICAgICB3aWR0aD0iNDQwIgogICAgICAgeT0iMCIKICAgICAgIHg9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmIgogICAgICAgaWQ9InNvdXRoLTUtNiIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93LTYtMCIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iV2VzdCIKICAgICBjbGFzcz0iYXJyb3ciCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwxLDAsMzcuMzc0NzU4LDM5LjU0NzAyMykiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaWQ9IkhhbGZBcnJvdy02LTAtNSIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgaWQ9InNvdXRoLTUtNi0yIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNi0wLTUiIC8+CiAgPC9nPgogIDx0ZXh0CiAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICBzdHlsZT0iZm9udC1zaXplOjkwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7Zm9udC1mYW1pbHk6VGltZXMgTmV3IFJvbWFuOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246J1RpbWVzIE5ldyBSb21hbiwgQm9sZCciCiAgICAgeD0iMTkuMjU0ODc1IgogICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgaWQ9Ik5vcnRoVGV4dCIKICAgICBzb2RpcG9kaTpsaW5lc3BhY2luZz0iMTMwJSIKICAgICB0cmFuc2Zvcm09InNjYWxlKDEuMDA4MzY2NSwwLjk5MTcwMjkyKSI+PHRzcGFuCiAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgaWQ9InRzcGFuMzAyNCIKICAgICAgIHg9IjE5LjI1NDg3NSIKICAgICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjgwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjFweDtmb250LWZhbWlseTpUaW1lcyBOZXcgUm9tYW47LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjonVGltZXMgTmV3IFJvbWFuLCBCb2xkJyI+TjwvdHNwYW4+PC90ZXh0PgogIDxnCiAgICAgaWQ9IklubmVyQ2lyY2xlIgogICAgIHN0eWxlPSJvcGFjaXR5OjAuNiIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOS4yNjA3MjYsNDEuMjEwMTIxKSI+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OCIKICAgICAgIGlkPSJnNyI+CiAgICAgIDxjaXJjbGUKICAgICAgICAgc29kaXBvZGk6cng9Ijc1IgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJNIDc1LDAgQyA3NSw0MS40MjEzNTYgNDEuNDIxMzU2LDc1IDAsNzUgLTQxLjQyMTM1Niw3NSAtNzUsNDEuNDIxMzU2IC03NSwwIGMgMCwtNDEuNDIxMzU2IDMzLjU3ODY0NCwtNzUgNzUsLTc1IDQxLjQyMTM1NiwwIDc1LDMzLjU3ODY0NCA3NSw3NSB6IgogICAgICAgICBpZD0iY2lyY2xlOSIKICAgICAgICAgcj0iNzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpyeT0iNzUiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzFiMWIxYjtzdHJva2Utd2lkdGg6MSIKICAgICAgIGlkPSJnMTEiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSI3MSIKICAgICAgICAgc29kaXBvZGk6cng9IjcxIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6Y3g9IjAiCiAgICAgICAgIGN5PSIwIgogICAgICAgICBjeD0iMCIKICAgICAgICAgZD0iTSA3MSwwIEMgNzEsMzkuMjEyMjE3IDM5LjIxMjIxNyw3MSAwLDcxIC0zOS4yMTIyMTcsNzEgLTcxLDM5LjIxMjIxNyAtNzEsMCBjIDAsLTM5LjIxMjIxNyAzMS43ODc3ODMsLTcxIDcxLC03MSAzOS4yMTIyMTcsMCA3MSwzMS43ODc3ODMgNzEsNzEgeiIKICAgICAgICAgaWQ9ImNpcmNsZTEzIgogICAgICAgICByPSI3MSIgLz4KICAgICAgPGNpcmNsZQogICAgICAgICBzb2RpcG9kaTpyeT0iNzkiCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI3OSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBjeT0iMCIKICAgICAgICAgY3g9IjAiCiAgICAgICAgIGQ9Ik0gNzksMCBDIDc5LDQzLjYzMDQ5NSA0My42MzA0OTUsNzkgMCw3OSAtNDMuNjMwNDk1LDc5IC03OSw0My42MzA0OTUgLTc5LDAgYyAwLC00My42MzA0OTUgMzUuMzY5NTA1LC03OSA3OSwtNzkgNDMuNjMwNDk1LDAgNzksMzUuMzY5NTA1IDc5LDc5IHoiCiAgICAgICAgIGlkPSJjaXJjbGUxNSIKICAgICAgICAgcj0iNzkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K";

    /**
     * Create a compass Widget
     * @param options
     * @throws {ReferenceError} can't get the div to insert the compass
     * @throws {ReferenceError} Can't get the element name
     * @constructor
     * @fires Navigation#modifiedNavigation
     */
    var Compass = function(options) {
        /**
         *    Private variables
         */
        this.svgDoc = null;
        this.panFactor = options.panFactor ? options.panFactor : 30;
        this.parentElement = options.element;
        this.ctx = null;
        this.isMobile = options.isMobile;
        this.options = options;

        this._lastMouseX = -1;
        this._lastMouseY = -1;
        this._balanceX = -1;
        this._balanceY = -1;
        this._dx = 0;
        this._dy = 0;
        this.dragging = false;

        this.east = null;
        this.west = null;
        this.south = null;
        this.north = null;
        this.northText = null;
        this.outerCircle = null;

        //var self = this;

        // Add compass object to parent element
        // Don't use <object> HTML tag due to cross-origin nature of svg
        if (this.parentElement == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(this.parentElement) === null) {
            throw new ReferenceError(
                "can't get the Div " +
                    this.parentElement +
                    " to insert the compass"
            );
        } else {
            // OK
        }

        this.init();
    };

    /**************************************************************************************************************/

    /**
     * Handles mouse down event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseDown(event, self) {
        if (event.type.search("touch") >= 0) {
            event.layerX = event.changedTouches[0].clientX;
            event.layerY = event.changedTouches[0].clientY;
            self._balanceX = event.layerX;
            self._balanceY = event.layerY;
        } else {
            self._balanceX = 0;
            self._balanceY = 0;
        }

        self.dragging = true;
        var _outerCircleRadius =
            self.outerCircle.ownerSVGElement.clientWidth / 2;
        self._lastMouseX = event.layerX - self._balanceX - _outerCircleRadius;
        self._lastMouseY = event.layerY - self._balanceY - _outerCircleRadius;
        self._dx = 0;
        self._dy = 0;
    }

    /**
     * Handles mouse move event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseMove(event, self) {
        if (event.type.search("touch") >= 0) {
            event.layerX = event.changedTouches[0].clientX - self._balanceX;
            event.layerY = event.changedTouches[0].clientY - self._balanceY;
        }

        if (!self.dragging) {
            return;
        }
        var _outerCircleRadius =
            self.outerCircle.ownerSVGElement.clientWidth / 2;
        var c =
            self._lastMouseX * (event.layerY - _outerCircleRadius) -
            self._lastMouseY * (event.layerX - _outerCircleRadius); // c>0 -> clockwise, counterclockwise otherwise

        self.ctx.getNavigation().rotate(c, 0);

        self._lastMouseX = event.layerX - _outerCircleRadius;
        self._lastMouseY = event.layerY - _outerCircleRadius;

        CompassCore.updateNorth();
    }

    /**
     * Handles mouse up event.
     * @param {Event} event
     * @param {Compass} self
     * @private
     */
    function _handleMouseUp(event, self) {
        event.preventDefault();
        self.dragging = false;
        // TODO add inertia
    }

    /**
     * Updates north compass from east move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromEast(self) {
        self.ctx.getNavigation().pan(self.panFactor, 0.0);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from west move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromWest(self) {
        self.ctx.getNavigation().pan(-self.panFactor, 0.0);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from north move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromNorth(self) {
        self.ctx.getNavigation().pan(0, self.panFactor);
        CompassCore.updateNorth();
    }

    /**
     * Updates north compass from south move.
     * @param {Compass} self
     * @private
     */
    function _updateNorthFromSouth(self) {
        self.ctx.getNavigation().pan(0, -self.panFactor);
        CompassCore.updateNorth();
    }

    /**
     * Init compass.
     */
    Compass.prototype.init = function() {
        CompassCore.init({
            element: this.parentElement
        });
    };

    /**
     *    Remove compass element
     */
    Compass.prototype.remove = CompassCore.remove;
    Compass.prototype.setCtx = CompassCore.setCtx;
    Compass.prototype.setSvg = CompassCore.setSvg;

    /**************************************************************************************************************/

    /**
     * Attachs the compass to the context.
     * @function attachTo
     * @memberof Compass#
     */
    Compass.prototype.attachTo = function(context) {
        var self = this;
        this.ctx = context;
        this.setCtx(context);
        $.get(
            COMPASS_SVG,
            function(response) {
                // Import contents of the svg document into this document
                self.svgDoc = document.importNode(
                    response.documentElement,
                    true
                );
                self.ctx = context;
                /* Svg interactive elements */
                self.east = self.svgDoc.getElementById("East"); //get the inner element by id
                self.west = self.svgDoc.getElementById("West"); //get the inner element by id
                self.south = self.svgDoc.getElementById("South"); //get the inner element by id
                self.north = self.svgDoc.getElementById("North"); //get the inner element by id
                self.northText = self.svgDoc.getElementById("NorthText");
                self.outerCircle = self.svgDoc.getElementById("OuterCircle");

                // Update width/height
                self.svgDoc.height.baseVal.value = 100;
                self.svgDoc.width.baseVal.value = 100;

                // Append the imported SVG root element to the appropriate HTML element
                document.getElementById(self.parentElement).innerHTML =
                    '<div id="objectCompass"></div>';
                $("#objectCompass").append(self.svgDoc);

                self.setSvg(self.svgDoc);
                //self.setCtx(self.ctx);

                self.options.svgDoc = self.svgDoc;

                //self.attachTo(self.ctx);
                self.svgDoc.addEventListener("mousedown", function(event) {
                    _handleMouseDown(event, self);
                });

                self.svgDoc.addEventListener("mousemove", function(event) {
                    _handleMouseMove(event, self);
                });

                self.svgDoc.addEventListener("mouseup", function(event) {
                    _handleMouseUp(event, self);
                });

                self.east.addEventListener("click", function() {
                    _updateNorthFromEast(self);
                });

                self.west.addEventListener("click", function() {
                    _updateNorthFromWest(self);
                });

                self.north.addEventListener("click", function() {
                    _updateNorthFromNorth(self);
                });

                self.south.addEventListener("click", function() {
                    _updateNorthFromSouth(self);
                });

                self.northText.addEventListener(
                    "click",
                    CompassCore._alignWithNorth
                );

                if (self.isMobile) {
                    var passiveSupported = Utils.isPassiveSupported();
                    self.svgDoc.addEventListener(
                        "touchstart",
                        function(event) {
                            _handleMouseDown(event, self);
                        },
                        passiveSupported ? { passive: true } : false
                    );
                    self.svgDoc.addEventListener("touchup", function(event) {
                        _handleMouseUp(event, self);
                    });
                    self.svgDoc.addEventListener(
                        "touchmove",
                        function(event) {
                            _handleMouseMove(event, self);
                        },
                        passiveSupported ? { passive: true } : false
                    );
                    self.northText.addEventListener(
                        "touchstart",
                        CompassCore._alignWithNorth,
                        passiveSupported ? { passive: true } : false
                    );
                }

                // Update fov when moving
                self.ctx.subscribe(
                    Constants.EVENT_MSG.NAVIGATION_MODIFIED,
                    CompassCore.updateNorth
                );
                self.ctx.subscribe(
                    Constants.EVENT_MSG.CRS_MODIFIED,
                    CompassCore.updateNorth
                );

                // Publish modified event to update compass north
                $("#" + self.parentElement).css("display", "block");
            },
            "xml"
        );
    };

    /**
     * Detaches the tracker from the context.
     * @function detach
     * @memberof Compass#
     */
    Compass.prototype.detach = function() {
        var self = this;
        this.svgDoc.removeEventListener("mousedown", function(event) {
            _handleMouseDown(event, self);
        });

        this.svgDoc.removeEventListener("mousemove", function(event) {
            _handleMouseMove(event, self);
        });

        this.svgDoc.removeEventListener("mouseup", function(event) {
            _handleMouseUp(event, self);
        });

        this.east.removeEventListener("click", function() {
            _updateNorthFromEast(self);
        });

        this.west.removeEventListener("click", function() {
            _updateNorthFromWest(self);
        });

        this.north.removeEventListener("click", function() {
            _updateNorthFromNorth(self);
        });

        this.south.removeEventListener("click", function() {
            _updateNorthFromSouth(self);
        });

        this.northText.removeEventListener(
            "click",
            CompassCore._alignWithNorth
        );

        if (this.isMobile) {
            var passiveSupported = Utils.isPassiveSupported();
            this.svgDoc.removeEventListener("touchstart", function(event) {
                _handleMouseDown(event, self);
            });
            this.svgDoc.removeEventListener("touchup", function(event) {
                _handleMouseUp(event, self);
            });
            this.svgDoc.removeEventListener(
                "touchmove",
                function(event) {
                    _handleMouseMove(event, self);
                },
                passiveSupported ? { passive: true } : false
            );
            this.northText.removeEventListener(
                "touchstart",
                CompassCore._alignWithNorth,
                passiveSupported ? { passive: true } : false
            );
        }
        // Update fov when moving
        this.ctx.unsubscribe(
            Constants.EVENT_MSG.NAVIGATION_MODIFIED,
            CompassCore.updateNorth
        );
        this.ctx.unsubscribe(
            Constants.EVENT_MSG.CRS_MODIFIED,
            CompassCore.updateNorth
        );
        this.ctx = null;
    };

    /**
     * Destroys the elements.
     * @function destroy
     * @memberof Compass#
     */
    Compass.prototype.destroy = function() {
        this.detach();
        this.remove();
        this.svgDoc = null;
        this.panFactor = null;
        this.parentElement = null;
        this.ctx = null;
        this.isMobile = null;

        this._lastMouseX = -1;
        this._lastMouseY = -1;
        this._balanceX = -1;
        this._balanceY = -1;
        this._dx = 0;
        this._dy = 0;
        this.dragging = false;

        this.east = null;
        this.west = null;
        this.south = null;
        this.north = null;
        this.northText = null;
        this.outerCircle = null;
    };

    return Compass;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/AbstractTracker',["jquery", "../../Utils/Utils", "../dialog/ErrorDialog"], function(
    $,
    Utils,
    ErrorDialog
) {
    /**
     * @name AbstractTracker
     * @class
     *    Abstract class for tracker (position, elevation...)
     * @param {Object} options
     * @throws {ReferenceError} Can't get the Div to insert the tracker
     * @throws {ReferenceError} Can't get the element name
     * @constructor
     * @implements {Tracker}
     */
    var AbstractTracker = function(options) {
        this.options = options;
        this.context = null;
        this.navigation = null;
        this.element = options.element;
        if (this.element == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(this.element) == null) {
            throw new ReferenceError(
                "Can' get the div " +
                    this.element +
                    " in the web page to insert " +
                    this.constructor.name
            );
        } else {
            document.getElementById(this.element).innerHTML = "";
            if (options.position) {
                $("#" + this.element).css(options.position, "2px");
            }
        }
    };

    /**
     * Returns the navigation.
     * @function _getNavigation
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._getNavigation = function() {
        return this.navigation;
    };

    /**
     * Sets the navigation
     * @function _setNavigation
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._setNavigation = function(navigation) {
        this.navigation = navigation;
    };

    /**
     * Returns the globe.
     * @function _getGlobe
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._getGlobe = function() {
        return this.globe;
    };

    /**
     * Sets the globe
     * @function _setGlobe
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._setGlobe = function(globe) {
        this.globe = globe;
    };

    /**
     * Returns the DIV element in which the result is written.
     * @function _getElement
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype._getElement = function() {
        return this.element;
    };

    /**
     * Updates the tracker.
     * @function update
     * @memberof AbstractTracker#
     * @abstract
     */
    AbstractTracker.prototype.update = function(event) {
        throw new SyntaxError(
            "update from AbstractTracker not implemented",
            "AbstractTracker.js"
        );
    };

    /**
     * @function compute
     * @memberof AbstractTracker#
     * @abstract
     */
    AbstractTracker.prototype.compute = function(geoPosition) {
        throw new SyntaxError(
            "compute from AbstractTracker not implemented",
            "AbstractTracker.js"
        );
    };

    /**
     * Attachs the tracker to the globe.
     * @function attachTo
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.attachTo = function(context) {
        this._setGlobe(context._getGlobe());
        this._setNavigation(context.getNavigation());
        this._getGlobe()
            .getRenderContext()
            .canvas.addEventListener("mousemove", this.update);
        if (this.options.isMobile) {
            var passiveSupported = Utils.isPassiveSupported();
            this._getGlobe()
                .getRenderContext()
                .canvas.addEventListener(
                    "touchmove",
                    this.update,
                    passiveSupported ? { passive: true } : false
                );
        }
    };

    /**
     * Detachs the tracker from the globe.
     * @function detach
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.detach = function() {
        document.getElementById(this._getElement()).innerHTML = "";
        this._getGlobe()
            .getRenderContext()
            .canvas.removeEventListener("mousemove", this.update);
        if (this.options.isMobile) {
            this._getGlobe()
                .getRenderContext()
                .canvas.removeEventListener("touchmove", this.update);
        }
    };

    /**
     * Destroys the elements.
     * @function destroy
     * @memberof AbstractTracker#
     */
    AbstractTracker.prototype.destroy = function() {
        document.getElementById(this._getElement()).innerHTML = "";
        this.element = null;
        this.options = null;
        // we do do not destroy the globe now. It will be destroyed later on in the context
    };

    return AbstractTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('Gui/dialog/CrsDialog',["jquery", "jquery.ui"], function($) {
    // The main div for error
    var crsInfo =
        '<div id="crsInfo" style="text-align: left" title="Coordinate Reference System information"></div>';

    // Create the div, use jQuery UI dialog

    var $text = "";

    var $crsInfo = $(crsInfo)
        .appendTo("body")
        .dialog({
            autoOpen: false,
            width: 500,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: "crsBox"
            //beforeClose: function( event, ui ) { $text = ""; }
        });
    var $active = false;

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function(crs) {
            if (this.isActive()) {
                this.destroy();
            }
            var geoBound = crs.getGeoBound();
            $text +=
                "<p align='center'><u><i><b>" +
                crs.getName() +
                " CRS description </b></i></u></p>";
            $text += "<p align='justify'>" + crs.getDescription() + "</p>";
            $text +=
                "<table>" +
                "<caption><i>Sphere parameters</i></caption>" +
                "<tr><th>Parameter</th><th>Value</th></tr>" +
                "<tr><td>Projection</td><td>" +
                (crs.isProjected() ? crs.getProjection().getName() : "3D") +
                "</td></tr>" +
                "<tr><td>radius (meters)</td><td>" +
                crs.getGeoide().getRealPlanetRadius() +
                "</td></tr>" +
                "<tr><td>" +
                crs.getLongitudeLabel() +
                "</td><td>[" +
                geoBound.getWest() +
                "&deg; , " +
                geoBound.getEast() +
                "&deg;]</td></tr>" +
                "<tr><td>" +
                crs.getLatitudeLabel() +
                "</td><td>[" +
                geoBound.getSouth() +
                "&deg; , " +
                geoBound.getNorth() +
                "&deg;]</td></tr>" +
                "</table>";
            $crsInfo.on("dialogclose", function(event) {
                $active = false;
            });
        },
        view: function() {
            $crsInfo.html($text).dialog("open");

            $crsInfo.scrollTop(5000);
            $active = true;
        },
        hide: function() {
            $crsInfo.dialog("close");
            $active = false;
        },
        isActive: function() {
            return $active;
        },
        destroy: function() {
            this.hide();
            $text = "";
            $active = false;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/PositionTracker',[
    "jquery",
    "./AbstractTracker",
    "../dialog/CrsDialog",
    "../../Utils/Utils"
], function($, AbstractTracker, CrsDialog, Utils) {
    var self;
    var posTrackerInfoHTML = '<input type="button" id="posTrackerInfoButton"/>';
    /**
     * Position tracker configuration
     * @typedef {Object} AbstractTracker.position_configuration
     * @property {string} element - tracker div element
     * @property {string} position - tracker position in the GUI
     * @property {boolean} [isMobile = false] - Mobile device
     */

    /**
     * @name PositionTracker
     * @class
     *    PositionTracker constructor
     * @augments AbstractTracker
     * @param {AbstractTracker.position_configuration} options - Position tracker configuration
     * @constructor
     */
    var PositionTracker = function(options) {
        AbstractTracker.prototype.constructor.call(this, options);
    };
    /**************************************************************************************************************/

    Utils.inherits(AbstractTracker, PositionTracker);

    /**************************************************************************************************************/

    /**
     * Updates the tracker's position.
     * @function update
     * @memberof PositionTracker#
     * @param {object} event
     */
    PositionTracker.prototype.update = function(event) {
        if (event.type.search("touch") >= 0) {
            event.clientX = event.changedTouches[0].clientX;
            event.clientY = event.changedTouches[0].clientY;
        }

        if (document.getElementById(self._getElement())) {
            var $crsInfo = $("#" + self._getElement() + "Info");
            var geoPos = self
                ._getGlobe()
                .getLonLatFromPixel(event.clientX, event.clientY);
            if (geoPos) {
                var astro = self.compute([geoPos[0], geoPos[1]]);
                document.getElementById(self._getElement()).innerHTML =
                    astro[0] + " x " + astro[1];
                if ($crsInfo.css("display") == "none") {
                    $crsInfo.show();
                }
            } else {
                document.getElementById(self._getElement()).innerHTML = "";
                if ($crsInfo.css("display") != "none") {
                    $crsInfo.hide();
                }
            }
        }
    };

    /**
     * Formats the coordinates from the position for displaying the coordinates on the screen.
     * @function compute
     * @memberof PositionTracker#
     * @param geoPosition
     * @returns {number} coordinates
     */
    PositionTracker.prototype.compute = function(geoPosition) {
        return this._getGlobe()
            .getCoordinateSystem()
            .formatCoordinates([geoPosition[0], geoPosition[1]]);
    };

    /**
     * Attachs the tracker to the context.
     *
     * Attachs the tracker to the context by calling the attachTo method from the AbstractTracker. Then, the CrsDialog
     * is filled with Crs information. Finally, the onClick event is set to get the Crs information. The onClick event
     * is enabled on the <i>#posTrackerInfoButton</i> ID
     *
     * @function attachTo
     * @memberof PositionTracker#
     * @param {AbstractContext} context
     * @see {@link CrsDialog}
     * @see {@link AbstrackTracker#attachTo}
     */
    PositionTracker.prototype.attachTo = function(context) {
        AbstractTracker.prototype.attachTo.call(this, context);
        $posTrackerInfo = $(posTrackerInfoHTML).appendTo(
            "#" + this._getElement() + "Info"
        );
        CrsDialog.open(context._getGlobe().getCoordinateSystem());
        $("#posTrackerInfoButton").on("click", function() {
            if (CrsDialog.isActive() === true) {
                CrsDialog.hide();
            } else {
                CrsDialog.view();
            }
        });
        self = this;
    };

    /**
     * Detaches the tracker.
     *
     * Detaches the tracker from the glob by calling the detach method from the AbstractTracker. Then, the onClick
     * event is removed and the CrsDialog is destroyed as well.
     *
     * @function detach
     * @memberof PositionTracker#
     */
    PositionTracker.prototype.detach = function() {
        $("#posTrackerInfoButton").off("click");
        $("#" + this._getElement() + "Info").empty();
        CrsDialog.destroy();
        AbstractTracker.prototype.detach.call(this);
        self = null;
    };

    /**
     * Destroys the position tracker.
     * @function destroy
     * @memberof AbstractTracker.prototype
     */
    PositionTracker.prototype.destroy = function() {
        this.detach(this);
        AbstractTracker.prototype.destroy.call(this);
        self = null;
    };

    /**************************************************************************************************************/

    return PositionTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/ElevationTracker',[
    "jquery",
    "./AbstractTracker",
    "../../Utils/Utils",
    "../../Utils/Numeric"
], function($, AbstractTracker, Utils, Numeric) {
    var self;

    /**
     * Elevation tracker configuration
     * @typedef {AbstractTracker.position_configuration} AbstractTracker.elevation_configuration
     * @property {Layer} [elevationLayer] - elevationLayer
     */

    /**
     * @name ElevationTracker
     * @class
     *   ElevationTracker context constructor
     * @augments AbstractTracker
     * @param {AbstractTracker.elevation_configuration} options - Elevation tracker configuration
     * @constructor
     */
    var ElevationTracker = function(options) {
        AbstractTracker.prototype.constructor.call(this, options);
        this.scale = null;
        if (options.elevationLayer != null) {
            this.scale = options.elevationLayer.getScale();
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractTracker, ElevationTracker);

    /**************************************************************************************************************/

    /**
     * Sets the scale layer taken from the elevationLayer
     * @param elevationLayer
     */
    ElevationTracker.prototype.setScaleLayer = function(elevationLayer) {
        this.scale = elevationLayer.getScale();
    };

    /**
     * Update the tracker
     * @function update
     * @memberof AbstractTracker.prototype
     * @param {object} event
     */
    ElevationTracker.prototype.update = function(event) {
        if (event.type.search("touch") >= 0) {
            event.clientX = event.changedTouches[0].clientX;
            event.clientY = event.changedTouches[0].clientY;
        }
        if (document.getElementById(self._getElement())) {
            var geoPos = self
                ._getGlobe()
                .getLonLatFromPixel(event.clientX, event.clientY);
            if (geoPos && self.scale) {
                var elevation = self.compute([geoPos[0], geoPos[1]]);
                document.getElementById(self._getElement()).innerHTML =
                    "Elevation : " +
                    Numeric.roundNumber(elevation / self.scale, 0) +
                    " meters";
            } else {
                document.getElementById(self._getElement()).innerHTML = "";
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Compute elevation from a specific point
     * @function compute
     * @memberof AbstractTracker.prototype
     * @param geoPosition
     * @returns {number} elevation
     */
    ElevationTracker.prototype.compute = function(geoPosition) {
        return this._getGlobe().getElevation(geoPosition[0], geoPosition[1]);
    };

    /**
     * @function attachTo
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.attachTo = function(context) {
        AbstractTracker.prototype.attachTo.call(this, context);
        self = this;
    };

    /**
     * @function detach
     * @memberof ElevationTracker#
     */
    ElevationTracker.prototype.detach = function() {
        AbstractTracker.prototype.detach.call(this);
        self = null;
    };

    /**
     * Destroy the elevation tracker.
     * @function destroy
     * @memberof AbstractTracker.prototype
     */
    ElevationTracker.prototype.destroy = function() {
        this.detach.call(this);
        AbstractTracker.prototype.destroy.call(this);
        this.scale = null;
        self = null;
    };

    /**************************************************************************************************************/

    return ElevationTracker;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/AttributionHandler',[],function () {

    /**
     * Default div ID for attribution.
     */
    const ATTIBUTION_ID_DEFAULT = "attribution";

    /**
     * Create HTML attribution.
     */
    function _createHTMLAttribution(layer) {
        var attribution;
        var title = layer.getAck() != null ? layer.getAck() : "";
        if (
            layer.getCopyrightUrl() !== "" &&
            layer.getCopyrightUrl() !== undefined
        ) {
            attribution =
                '<a class="whiteLink" href="' +
                layer.getCopyrightUrl() +
                '" target="_blank" title="' +
                title +
                '">' +
                layer.getAttribution() +
                "</a>";
        } else {
            attribution = layer.getAttribution();
        }
        return attribution;
    }

    /**
        @name AttributionHandler
        @class
        Manage the attributions
        @param {Globe} globe Globe
        @param options Configuration properties
        <ul>
        <li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
        </ul>
    */
    var AttributionHandler = function (globe, options) {
        // Search for the element to use
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
            } else {
                this.element = elt;
            }
            if (this.element && !elt.hasOwnProperty(this.element)) {
                this.element.id = ATTIBUTION_ID_DEFAULT;
            }
        }

        // Only add the attribution handler to the globe if element is not null
        if (this.element) {
            globe.attributionHandler = this;
        }
    };

    /**
     * Remove attribution from HTML
     * @function removeAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.removeAttribution = function (layer) {
        if (this.element) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                this.element.removeChild(div);
            }
        }
    };

    /**
     * Add attribution in HTML
     * @function addAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.addAttribution = function (layer) {
        if (this.element) {
            var div = document.createElement("div");
            div.innerHTML = _createHTMLAttribution.call(this, layer);
            div.id = this.element.id + "_" + layer.id;

            if (layer.id === 0) {
                // Background layer
                this.element.insertBefore(div, this.element.firstChild);
            } else {
                this.element.appendChild(div);
            }
        }
    };

    /**
     * Enables all HTML attribution.
     * @function enable
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.enable = function (layer) {
        if (this.element && layer && layer.isVisible()) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                div.style.display = "block";
            }
        }
    };

    /**
     * Disables all HTML attribution.
     * @function disable
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.disable = function (layer) {
        if (this.element && layer && layer.isVisible()) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                div.style.display = "none";
            }
        }
    };

    /**
     * Toggle attribution
     * @function toggleAttribution
     * @memberof AttributionHandler.prototype
     * @param {Layer} layer Layer
     */
    AttributionHandler.prototype.toggleAttribution = function (layer) {
        if (this.element) {
            var div = document.getElementById(this.element.id + "_" + layer.id);
            if (div) {
                this.removeAttribution(layer);
            } else {
                this.addAttribution(layer);
            }
        }
    };

    /**************************************************************************************************************/

    return AttributionHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/VectorRenderer',[
    "./RendererTileData",
    "../Tiling/Tile",
    "../Utils/Utils",
    "../Utils/UtilsIntersection"
], function(RendererTileData, Tile, Utils, UtilsIntersection) {
    /**************************************************************************************************************/

    /**
  @name VectorRenderer
  @class
	  VectorRenderer constructor
  @param {AbstractGlobe} globe AbstractGlobe
  @constructor
  */
    var VectorRenderer = function(globe) {
        this.tileManager = globe.tileManager;
        this.globe = globe;
        this.buckets = [];
        this.maxTilePerGeometry = 100;
        this.levelZeroTiledGeometries = [];
    };

    /**************************************************************************************************************/

    /**
     * Find a compatible bucket
     * @function findBucket
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    VectorRenderer.prototype.findBucket = function(layer, style) {
        // Find an existing bucket for the given style
        for (var i = 0; i < this.buckets.length; i++) {
            var bucket = this.buckets[i];
            if (bucket.layer === layer && bucket.isCompatible(style)) {
                return bucket;
            }
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     * Generate the level zero for a tile
     * @function generateLevelZero
     * @memberof VectorRenderer.prototype
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.generateLevelZero = function(tile) {
        for (var i = 0; i < this.levelZeroTiledGeometries.length; i++) {
            var geometry = this.levelZeroTiledGeometries[i];

            // Check that the geometry is on this tile
            var isFound = false;
            for (var n = 0; n < geometry._tileIndices.length && !isFound; n++) {
                var t = this.tileManager.level0Tiles[geometry._tileIndices[n]];
                isFound = t === tile;
            }

            // Found the tile, so add it
            if (isFound) {
                this._addGeometryToTile(geometry._bucket, geometry, tile);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Recursively add a geometry to a tile
     * @function _recursiveAddGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param geometry
     * @param {Tile} tile Tile
     * @private
     */
    VectorRenderer.prototype._recursiveAddGeometryToTile = function(
        bucket,
        geometry,
        tile
    ) {
        var renderable = this._addGeometryToTile(bucket, geometry, tile);

        if (renderable && renderable.generateChild && tile.children) {
            for (var i = 0; i < 4; i++) {
                if (tile.children[i].state === Tile.State.LOADED) {
                    renderable.hasChildren = true;
                    this._recursiveAddGeometryToTile(
                        bucket,
                        geometry,
                        tile.children[i]
                    );
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a vector renderer
     * @function addGeometry
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     */
    VectorRenderer.prototype.addGeometry = function(layer, geometry, style) {
        var bucket = this.getOrCreateBucket(layer, geometry, style);
        geometry._bucket = bucket;
        var tileIndices =
            this.maxTilePerGeometry > 0
                ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry)
                : null;
        if (tileIndices && tileIndices.length < this.maxTilePerGeometry) {
            // Add geometry to each tile in range
            for (var i = 0; i < tileIndices.length; i++) {
                var tile = this.tileManager.level0Tiles[tileIndices[i]];
                if (
                    tile &&
                    typeof tile !== "undefined" &&
                    tile.state === Tile.State.LOADED
                ) {
                    this._recursiveAddGeometryToTile(bucket, geometry, tile);
                }
            }

            geometry._tileIndices = tileIndices;
            this.levelZeroTiledGeometries.push(geometry);
        } else {
            // Attach to mainRenderable
            if (!bucket.mainRenderable) {
                bucket.mainRenderable = bucket.createRenderable();
            }
            bucket.mainRenderable.add(geometry);
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a vector renderer
     * @function removeGeometry
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @private
     */
    VectorRenderer.prototype.removeGeometry = function(geometry) {
        var tileIndices = geometry._tileIndices;

        if (tileIndices) {
            // Remove from tile
            for (var i = 0; i < tileIndices.length; i++) {
                var tile = this.tileManager.level0Tiles[tileIndices[i]];
                this.removeGeometryFromTile(geometry, tile);
            }
            // Remove from geometry arrays
            this.levelZeroTiledGeometries.splice(
                this.levelZeroTiledGeometries.indexOf(geometry),
                1
            );

            geometry._tileIndices = null;
        } else {
            var bucket = geometry._bucket;
            if (bucket.mainRenderable) {
                var numGeometries = bucket.mainRenderable.remove(geometry);
                if (numGeometries === 0) {
                    bucket.mainRenderable.dispose(this.renderContext);
                    bucket.mainRenderable = null;
                }
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Get or create a bucket for the given configuration
     * @function getOrCreateBucket
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     * @return {Bucket} Bucket
     */
    VectorRenderer.prototype.getOrCreateBucket = function(
        layer,
        geometry,
        style
    ) {
        // Then find an existing bucket
        var bucket = this.findBucket(layer, style);
        if (!bucket) {
            bucket = this.createBucket(layer, style);
            bucket.renderer = this;
            bucket.id = this.globe.getRendererManager().bucketId++;
            this.buckets.push(bucket);
        }
        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to a tile
     * @function addGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param layer
     * @param geometry
     * @param style
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.addGeometryToTile = function(
        layer,
        geometry,
        style,
        tile
    ) {
        var bucket = this.getOrCreateBucket(layer, geometry, style);
        geometry._bucket = bucket;
        return this._addGeometryToTile(bucket, geometry, tile);
    };

    /**************************************************************************************************************/

    /**
     * Internal method to add a geometry to a tile
     * @function _addGeometryToTile
     * @memberof VectorRenderer.prototype
     * @param {Bucket} bucket Buckeont
     * @param geometry
     * @param {Tile} tile Tile
     * @private
     */
    VectorRenderer.prototype._addGeometryToTile = function(
        bucket,
        geometry,
        tile
    ) {
        var tileData = tile.extension.renderer;
        if (!tileData) {
            tileData = tile.extension.renderer = new RendererTileData(
                this.globe.getRendererManager()
            );
        }

        var renderable = tileData.getRenderable(bucket);
        var needsToAdd = false;
        if (!renderable) {
            renderable = bucket.createRenderable();
            needsToAdd = true;
        }
        if (renderable.add(geometry, tile)) {
            if (needsToAdd) {
                tileData.renderables.push(renderable);
            }
            return renderable;
        }

        return null;
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from a tile (recursive)
     * @function _removeGeometryFromTile
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @param {Bound} bbox Bbox of geometry
     * @param {Tile} tile Tile
     * @param {Integer} level Level
     * @private
     */
    VectorRenderer.prototype._removeGeometryFromTile = function(
        geometry,
        bbox,
        tile,
        level
    ) {
        var maxLevel = 0;
        if (
            bbox !== null &&
            UtilsIntersection.boundsIntersects(bbox, tile.bound) === false
        ) {
            return maxLevel;
        }

        var tileData = null;
        if (tile && tile.extension) {
            tileData = tile.extension.renderer;
        }

        if (tileData) {
            var i = 0;
            while (i < tileData.renderables.length) {
                var renderable = tileData.renderables[i];
                var renderer = renderable.bucket.renderer;
                if (renderer === this) {
                    // Remove renderable
                    var numGeometries = renderable.remove(geometry);
                    if (numGeometries === 0) {
                        tileData.renderables.splice(i, 1);
                    } else {
                        i++;
                    }

                    // Remove geometry from children if needed
                    if (renderable.hasChildren === true && tile.children) {
                        for (var n = 0; n < 4; n++) {
                            if (tile.children[n].state === Tile.State.LOADED) {
                                levelReturned = this._removeGeometryFromTile(
                                    geometry,
                                    bbox,
                                    tile.children[n],
                                    level + 1
                                );
                                if (levelReturned > maxLevel) {
                                    maxLevel = levelReturned;
                                }
                            }
                        }
                    }
                } else {
                    i++;
                }
            }
        }
        return maxLevel;
    };

    /**
     * Remove a geometry from a tile
     * @function removeGeometryFromTile
     * @memberof VectorRenderer.prototype
     * @param geometry
     * @param {Tile} tile Tile
     */
    VectorRenderer.prototype.removeGeometryFromTile = function(geometry, tile) {
        //var bbox = Utils.getBBoxFromCoordinateArray(geometry.coordinates[0]);
        //var startDate = new Date();
        maxLevel = this._removeGeometryFromTile(geometry, null, tile, 0);
        //var endDate = new Date();
        //console.log("Delta remove : "+(endDate*1.0 - startDate*1.0)+"ms with "+maxLevel+" levels");
    };

    /**************************************************************************************************************/

    return VectorRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/PointRenderer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./VectorRenderer",
    "./RendererManager",
    "./FeatureStyle",
    "./Program",
    "./GeoBound"
], function(
    Utils,
    Constants,
    VectorRenderer,
    RendererManager,
    FeatureStyle,
    Program,
    GeoBound
) {
    /**************************************************************************************************************/

    /**
         Basic module to generate texture from text
         */
    var Text = (function() {
        var fontSize = 18;
        var margin = 1;
        var canvas2d = null;

        var initialize = function() {
            canvas2d = document.createElement("canvas");
            canvas2d.width = 512;
            canvas2d.height = fontSize + 2 * margin;
        };

        var generateImageData = function(text, textColor) {
            if (!canvas2d) {
                initialize();
            }

            var fillColor = textColor;
            if (!fillColor) {
                fillColor = "#fff";
            } else {
                if (fillColor instanceof Array) {
                    fillColor = FeatureStyle.fromColorToString(textColor);
                }
            }

            var ctx = canvas2d.getContext("2d");
            ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
            ctx.fillStyle = fillColor;
            ctx.font = fontSize + "px sans-serif";
            ctx.textBaseline = "top";
            ctx.shadowColor = "#000";
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.shadowBlur = 2;
            ctx.fillText(text, margin, margin);
            //ctx.lineWidth = 1.0;
            //ctx.strokeText(text, margin, margin);

            var metrics = ctx.measureText(text);
            return ctx.getImageData(
                0,
                0,
                Math.floor(metrics.width) + 2 * margin,
                canvas2d.height
            );
        };

        return { generateImageData: generateImageData };
    })();

    /**************************************************************************************************************/

    /**
         @name PointRenderer
         @class
             POI Renderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PointRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        // Store object for rendering
        this.renderContext = globe.tileManager.renderContext;
        this.tileConfig = globe.tileManager.tileConfig;

        // For stats
        this.numberOfRenderPoints = 0;

        var vertexShader =
            "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
        vertexShader += "uniform mat4 viewProjectionMatrix; \n";
        vertexShader += "uniform vec3 poiPosition; // world position \n";
        vertexShader += "uniform vec2 poiScale; // x,y scale \n";
        vertexShader += "uniform vec2 tst; \n";
        vertexShader += "\n";
        vertexShader += "varying vec2 texCoord; \n";
        vertexShader += "\n";
        vertexShader += "void main(void)  \n";
        vertexShader += "{ \n";
        vertexShader +=
            "	// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
        vertexShader += "	texCoord = vertex.xy + vec2(0.5) + tst; \n";
        vertexShader += "	// Invert y \n";
        vertexShader += "	texCoord.y = 1.0 - texCoord.y; \n";
        vertexShader += "	\n";
        vertexShader += "	// Compute poi position in clip coordinate \n";
        vertexShader +=
            "	gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
        vertexShader +=
            "	gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
        vertexShader += "} \n";

        var fragmentShader = "precision lowp float; \n";
        fragmentShader += "varying vec2 texCoord; \n";
        fragmentShader += "uniform sampler2D texture; \n";
        fragmentShader += "uniform float alpha; \n";
        fragmentShader += "uniform vec3 color; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void) \n";
        fragmentShader += "{ \n";
        fragmentShader +=
            "	vec4 textureColor = texture2D(texture, texCoord); \n";
        fragmentShader +=
            "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
        fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
        fragmentShader += "} \n";

        this.program = new Program(this.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        var vertices = new Float32Array([
            -0.5,
            -0.5,
            0.0,
            0.5,
            -0.5,
            0.0,
            0.5,
            0.5,
            0.0,
            -0.5,
            0.5,
            0.0
        ]);

        var gl = this.renderContext.gl;
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        this.defaultTexture = null;
    };

    Utils.inherits(VectorRenderer, PointRenderer);

    /**************************************************************************************************************/

    /**
     * Build a default texture
     * @function _buildDefaultTexture
     * @memberof PointRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @private
     */
    PointRenderer.prototype._buildDefaultTexture = function(bucket) {
        if (!this.defaultTexture) {
            var gl = this.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                1,
                1,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                whitePixel
            );
        }

        bucket.texture = this.defaultTexture;
        bucket.textureWidth = 10;
        bucket.textureHeight = 10;
    };

    /**************************************************************************************************************/
    /**
     * Build a texture from an image and store in a bucket
     * @function _buildTextureFromImage
     * @memberof PointRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param image
     * @private
     */
    PointRenderer.prototype._buildTextureFromImage = function(bucket, image) {
        bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(
            image
        );
        bucket.textureWidth = image.width;
        bucket.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    /**
         @name PointRenderable
         @class
             Renderable constructor for Point
         @param {Bucket} bucket Bucket
         @constructor
         */
    var PointRenderable = function(bucket) {
        this.bucket = bucket;
        this.points = [];
        this.geometries = [];
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderable
     * @function add
     * @memberof PointRenderable.prototype
     * @param geometry
     * @return {Boolean} If the geometry has been successfully added to the renderable
     */
    PointRenderable.prototype.add = function(geometry) {
        // TODO: Find a better way to access to coordinate system
        var coordinateSystem = this.bucket.layer
            .getGlobe()
            .getCoordinateSystem();
        var posGeo = geometry.coordinates;

        posGeo = coordinateSystem.convert(
            posGeo,
            geometry.crs.properties.name,
            coordinateSystem.getGeoideName()
        );

        var csBound = new GeoBound(
            coordinateSystem.getGeoBound().getWest(),
            coordinateSystem.getGeoBound().getSouth(),
            coordinateSystem.getGeoBound().getEast(),
            coordinateSystem.getGeoBound().getNorth()
        );

        if (csBound.isPointInside(posGeo)) {
            var pos3d = coordinateSystem.get3DFromWorld(posGeo);
            var vertical = coordinateSystem.getVerticalAt3D(pos3d);

            this.points.push({
                pos3d: pos3d,
                vertical: vertical,
                geometry: geometry
            });

            return true;
        } else {
            return false;
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderable
     * @function remove
     * @memberof PointRenderable.prototype
     * @param geometry
     * @return {Integer} Number of points after remove
     */
    PointRenderable.prototype.remove = function(geometry) {
        for (var j = 0; j < this.points.length; j++) {
            if (this.points[j].geometry === geometry) {
                this.points.splice(j, 1);
                return this.points.length;
            }
        }
        return this.points.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof PointRenderable.prototype
     * @param renderContext
     */
    PointRenderable.prototype.dispose = function(renderContext) {
        // Nothing to do
    };

    /**************************************************************************************************************/

    /**
         @name PointBucket
         @class
             Bucket constructor for PointRenderer
         @param layer
         @param style
         @constructor
         */
    var PointBucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.renderer = null;
        this.texture = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof PointBucket.prototype
     * @return {PointRenderable} Renderable
     */
    PointBucket.prototype.createRenderable = function() {
        return new PointRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof PointBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    PointBucket.prototype.isCompatible = function(style) {
        return (
            this.style.iconUrl === style.iconUrl &&
            this.style.icon === style.icon &&
            this.style.label === style.label
        );
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a point
     * @function createBucket
     * @memberof PointRenderer.prototype
     * @param layer
     * @param style
     * @return {PointBucket} Bucket
     */
    PointRenderer.prototype.createBucket = function(layer, style) {
        // Create a bucket
        var bucket = new PointBucket(layer, style);

        // Initialize bucket : create the texture
        if (style.label) {
            var imageData = Text.generateImageData(
                style.label,
                style.textColor
            );
            this._buildTextureFromImage(bucket, imageData);
        } else if (style.iconUrl) {
            var image = new Image();
            image.crossOrigin = "";
            var self = this;
            image.onload = function() {
                self._buildTextureFromImage(bucket, image);
                self.renderContext.requestFrame();
            };
            image.onerror = function() {
                self._buildDefaultTexture(bucket);
            };
            image.src = style.iconUrl;
        } else if (style.icon) {
            this._buildTextureFromImage(bucket, style.icon);
        } else {
            this._buildDefaultTexture(bucket);
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render all the POIs
     * @function render
     * @memberof PointRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PointRenderer.prototype.render = function(renderables, start, end) {
        this.numberOfRenderPoints = 0;

        var renderContext = this.renderContext;
        var gl = this.renderContext.gl;

        // TODO
        //var level = renderContext.renderers[0].tileManager.visibleTiles[0].level;
        //if(level < 5) {
        //    return;
        //}
        // end todo

        // Setup states
        // gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Setup program
        this.program.apply();

        // The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.program.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1i(this.program.uniforms.texture, 0);

        // Compute eye direction from inverse view matrix
        mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
        var camZ = [
            renderContext.modelViewMatrix[8],
            renderContext.modelViewMatrix[9],
            renderContext.modelViewMatrix[10]
        ];
        vec3.normalize(camZ);
        vec3.scale(camZ, this.tileConfig.cullSign, camZ);

        // Compute pixel size vector to offset the points from the earth
        var pixelSizeVector = renderContext.computePixelSizeVector();

        // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(
            this.program.attributes.vertex,
            3,
            gl.FLOAT,
            false,
            0,
            0
        );
        var scale;
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var bucket = renderable.bucket;

            if (renderable.points.length === 0) {
                continue;
            }

            if (bucket !== currentBucket) {
                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                // 2.0 * because normalized device coordinates goes from -1 to 1
                scale = [
                    (2.0 * bucket.textureWidth) / renderContext.canvas.width,
                    (2.0 * bucket.textureHeight) / renderContext.canvas.height
                ];
                gl.uniform2fv(this.program.uniforms.poiScale, scale);
                gl.uniform2fv(this.program.uniforms.tst, [
                    0.5 / bucket.textureWidth,
                    0.5 / bucket.textureHeight
                ]);
            }

            for (var i = 0; i < renderable.points.length; i++) {
                // Poi culling
                var worldPoi = renderable.points[i].pos3d;
                var poiVec = renderable.points[i].vertical;
                scale =
                    bucket.textureHeight *
                    (pixelSizeVector[0] * worldPoi[0] +
                        pixelSizeVector[1] * worldPoi[1] +
                        pixelSizeVector[2] * worldPoi[2] +
                        pixelSizeVector[3]);
                scale *= this.tileConfig.cullSign;
                var scaleInKm =
                    (scale /
                        this.globe
                            .getCoordinateSystem()
                            .getGeoide()
                            .getHeightScale()) *
                    0.001;
                if (scaleInKm > bucket.style.pointMaxSize) {
                    continue;
                }

                if (
                    vec3.dot(poiVec, camZ) > 0 &&
                    renderContext.worldFrustum.containsSphere(
                        worldPoi,
                        scale
                    ) >= 0
                ) {
                    var x = poiVec[0] * scale + worldPoi[0];
                    var y = poiVec[1] * scale + worldPoi[1];
                    var z = poiVec[2] * scale + worldPoi[2];

                    gl.uniform3f(this.program.uniforms.poiPosition, x, y, z);
                    gl.uniform1f(
                        this.program.uniforms.alpha,
                        bucket.layer.getOpacity()
                    );
                    var color = bucket.style.getFillColor();
                    gl.uniform3f(
                        this.program.uniforms.color,
                        color[0],
                        color[1],
                        color[2]
                    );

                    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                    this.numberOfRenderPoints++;
                }
            }
        }

        //    gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PointRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    PointRenderer.prototype.canApply = function(type, style) {
        return type === Constants.GEOMETRY.Point && style.iconUrl === null;
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PointRenderer(globe);
    });

    return PointRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/BatchRenderable',[],function() {
    /**
 @name BatchRenderable
 @class
  Base renderable
 @constructor
 */
    var BatchRenderable = function(bucket) {
        this.bucket = bucket;
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.vertices = [];
        this.triIndices = [];
        this.lineIndices = [];
        this.geometryInfos = [];
        this.bufferDirty = true;
        this.vertexSize = 3;
        this.indexType = 0;
        this.vertexBufferShared = false;
    };

    /**
   Remove a geometry from the renderable
   @function remove
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
 */
    BatchRenderable.prototype.remove = function(geometry) {
        var fiIndex = -1;

        // Find the feature
        var vertexIt = 0;
        var lineIndexIt = 0;
        var triIndexIt = 0;
        var n;
        for (var i = 0; i < this.geometryInfos.length; i++) {
            var fi = this.geometryInfos[i];
            if (fi.geometry === geometry) {
                // Remove feature from vertex and index buffer
                this.vertices.splice(vertexIt, fi.vertexCount);
                this.lineIndices.splice(lineIndexIt, fi.lineIndexCount);
                this.triIndices.splice(triIndexIt, fi.triIndexCount);

                // Update index buffer
                var vertexOffset = fi.vertexCount / this.vertexSize;
                for (n = lineIndexIt; n < this.lineIndices.length; n++) {
                    this.lineIndices[n] -= vertexOffset;
                }
                for (n = triIndexIt; n < this.triIndices.length; n++) {
                    this.triIndices[n] -= vertexOffset;
                }
                fiIndex = i;

                break;
            }

            vertexIt += fi.vertexCount;
            lineIndexIt += fi.lineIndexCount;
            triIndexIt += fi.triIndexCount;
        }

        if (fiIndex >= 0) {
            this.bufferDirty = true;

            // Remove the feature from the infos array
            this.geometryInfos.splice(fiIndex, 1);

            return this.vertices.length;
        } else {
            return this.vertices.length;
        }
    };

    /**
   Add a feature to the renderable
   @function add
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
   @param {?} tile Tile
 */
    BatchRenderable.prototype.add = function(geometry, tile) {
        var hasTile = typeof tile !== "undefined";

        this.tile = tile;

        // Store previous number of vertices/indices needed for "after-build" computation
        var numVertices = this.vertices.length;
        var numLineIndices = this.lineIndices.length;
        var numTriIndices = this.triIndices.length;

        var geometryInTile = hasTile === false;
        if (hasTile === true) {
            geometryInTile = this.build(geometry, tile);
        }
        if (geometryInTile) {
            this.geometryInfos.push({
                geometry: geometry,
                vertexCount: this.vertices.length - numVertices,
                lineIndexCount: this.lineIndices.length - numLineIndices,
                triIndexCount: this.triIndices.length - numTriIndices
            });
            this.bufferDirty = true;
            return true;
        } else {
            // Feature not in the tile
            return false;
        }
    };

    /**
   Dispose graphics data
   @function dispose
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
    BatchRenderable.prototype.dispose = function(renderContext) {
        if (typeof renderContext === "undefined") {
            return;
        }

        var gl = renderContext.gl;

        if (this.indexBuffer) {
            gl.deleteBuffer(this.indexBuffer);
        }
        this.indexBuffer = null;
        if (this.vertexBuffer && !this.vertexBufferShared) {
            gl.deleteBuffer(this.vertexBuffer);
            this.vertexBuffer = null;
        }
    };

    /**
   Must be call before rendering
   @function bindBuffers
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
    BatchRenderable.prototype.bindBuffers = function(renderContext) {
        var gl = renderContext.gl;

        if (this.bufferDirty) {
            this.dispose(renderContext);

            // Create vertex buffer if needed
            if (this.vertexBuffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            } else {
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(this.vertices),
                    gl.STATIC_DRAW
                );
            }

            // Create index buffer
            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

            var indices = this.triIndices;
            if (this.triIndices.length > 0) {
                if (this.lineIndices.length > 0) {
                    indices = this.triIndices.concat(this.lineIndices);
                } else {
                    indices = this.triIndices;
                }
            } else {
                indices = this.lineIndices;
            }

            var vertexCount = this.vertices.length / this.vertexSize;
            if (vertexCount > 65535) {
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint32Array(indices),
                    gl.STATIC_DRAW
                );
                this.indexType = gl.UNSIGNED_INT;
            } else {
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(indices),
                    gl.STATIC_DRAW
                );
                this.indexType = gl.UNSIGNED_SHORT;
            }
            this.bufferDirty = false;
        } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        }
    };

    /**************************************************************************************************************/

    return BatchRenderable;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TiledVectorRenderable',[
    "../Utils/Utils",
    "../Renderer/BatchRenderable",
    "../Utils/Constants"
], function(Utils, BatchRenderable, Constants) {
    /**************************************************************************************************************/

    /** @constructor
     *    TiledVectorRenderable constructor
     */
    var TiledVectorRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.tile = null;
        // The tiled vector renderable always has a children
        this.hasChildren = true;
    };

    /**************************************************************************************************************/

    Utils.inherits(BatchRenderable, TiledVectorRenderable);

    /**************************************************************************************************************/

    /**
     * Initialize a child renderable
     */
    TiledVectorRenderable.prototype.initChild = function(i, j) {
        var child = new TiledVectorRenderable(this.bucket);
        child.tile = this.tile;
        child.vertexBufferShared = true;
        child.vertexBuffer = this.vertexBuffer;
        child.vertices = this.vertices;
        child.buildChildrenIndices(this, j * 2 + i);
        return child;
    };

    /**************************************************************************************************************/

    /**
     * Generate a child renderable
     */
    TiledVectorRenderable.prototype.generateChild = function(tile) {
        for (var j = 0; j < this.geometryInfos.length; j++) {
            this.bucket.renderer._addGeometryToTile(
                this.bucket,
                this.geometryInfos[j].geometry,
                tile
            );
        }
    };

    /**************************************************************************************************************/

    /**
     * Build children indices.
     * Children indices are used to render a tile children when it is not completely loaded.
     */
    TiledVectorRenderable.prototype.buildChildrenIndices = function(
        parent,
        index
    ) {
        var n;
        var vertexOffset1, vertexOffset2, vertexOffset3;
        var x1, x2, x3, i;
        var y1, y2, y3, j;
        for (n = 0; n < parent.triIndices.length; n += 3) {
            vertexOffset1 = 3 * parent.triIndices[n];
            vertexOffset2 = 3 * parent.triIndices[n + 1];
            vertexOffset3 = 3 * parent.triIndices[n + 2];

            x1 = parent.vertices[vertexOffset1];
            x2 = parent.vertices[vertexOffset2];
            x3 = parent.vertices[vertexOffset3];

            i = 0;
            if (
                x1 > 0 ||
                (x1 === 0 && x2 > 0) ||
                (x1 === 0 && x2 === 0 && x3 > 0)
            ) {
                i = 1;
            }

            y1 = parent.vertices[vertexOffset1 + 1];
            y2 = parent.vertices[vertexOffset2 + 1];
            y3 = parent.vertices[vertexOffset3 + 1];

            j = 1;
            if (
                y1 > 0 ||
                (y1 === 0 && y2 > 0) ||
                (y1 === 0 && y2 === 0 && y3 > 0)
            ) {
                j = 0;
            }

            if (index === 2 * j + i) {
                this.triIndices.push(
                    parent.triIndices[n],
                    parent.triIndices[n + 1],
                    parent.triIndices[n + 2]
                );
            }
        }
        for (n = 0; n < parent.lineIndices.length / 2; n++) {
            vertexOffset1 = 3 * parent.lineIndices[2 * n];
            vertexOffset2 = 3 * parent.lineIndices[2 * n + 1];

            x1 = parent.vertices[vertexOffset1];
            x2 = parent.vertices[vertexOffset2];

            i = 0;
            if (x1 > 0 || (x1 === 0 && x2 > 0)) {
                i = 1;
            }

            y1 = parent.vertices[vertexOffset1 + 1];
            y2 = parent.vertices[vertexOffset2 + 1];

            j = 1;
            if (y1 > 0 || (y1 === 0 && y2 > 0)) {
                j = 0;
            }

            if (index === 2 * j + i) {
                this.lineIndices.push(
                    parent.lineIndices[2 * n],
                    parent.lineIndices[2 * n + 1]
                );
            }
        }
    };

    /**************************************************************************************************************/

    /**
     *    Add a feature to the renderable
     *    @return    Boolean indicating if geometry intersects the given tile
     */
    TiledVectorRenderable.prototype.build = function(geometry, tile) {
        this.tile = tile;
        var i, j;
        var tileInRange;
        if (
            typeof this.bucket.layer.minLevel === "undefined" ||
            typeof this.bucket.layer.maxLevel === "undefined"
        ) {
            tileInRange = true;
        } else {
            tileInRange =
                this.bucket.layer.minLevel <= tile.level &&
                tile.level <= this.bucket.layer.maxLevel;
        }

        if (tileInRange) {
            var coords = geometry.coordinates;
            switch (geometry.type) {
                case Constants.GEOMETRY.LineString:
                    this.buildVerticesAndIndices(tile, coords);
                    break;
                case Constants.GEOMETRY.Polygon:
                    for (i = 0; i < coords.length; i++) {
                        this.buildVerticesAndIndices(tile, coords[i]);
                    }
                    break;
                case Constants.GEOMETRY.MultiLineString:
                    for (i = 0; i < coords.length; i++) {
                        this.buildVerticesAndIndices(tile, coords[i]);
                    }
                    break;
                case Constants.GEOMETRY.MultiPolygon:
                    for (j = 0; j < coords.length; j++) {
                        for (i = 0; i < coords[j].length; i++) {
                            this.buildVerticesAndIndices(tile, coords[j][i]);
                        }
                    }
                    break;
            }
        }
        return tile.geoBound.intersectsGeometry(geometry);
    };

    /**************************************************************************************************************/

    return TiledVectorRenderable;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TiledVectorRenderer',[
    "../Utils/Utils",
    "../Renderer/VectorRenderer",
    "../Renderer/Program"
], function(Utils, VectorRenderer, Program) {
    /**************************************************************************************************************/

    /** @constructor
     TiledVectorRenderer constructor
     */
    var TiledVectorRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        var vertexShader = "attribute vec3 vertex; \n";
        vertexShader += "uniform float zOffset; \n";
        vertexShader += "uniform mat4 modelViewMatrix;\n";
        vertexShader += "uniform mat4 projectionMatrix;\n";
        vertexShader += "\n";
        vertexShader += "void main(void)  \n";
        vertexShader += "{ \n";
        vertexShader +=
            "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n";
        vertexShader += "} \n";

        var fragmentShader = "#ifdef GL_ES \n";
        fragmentShader += "precision highp float; \n";
        fragmentShader += "#endif \n";
        fragmentShader += "uniform vec4 color; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void) \n";
        fragmentShader += "{ \n";
        fragmentShader += "	gl_FragColor = color; \n";
        fragmentShader += "} \n";

        this.program = new Program(this.tileManager.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);
    };

    Utils.inherits(VectorRenderer, TiledVectorRenderer);

    /**************************************************************************************************************/

    /**
     Render all redenrable on the given tiles
     */
    TiledVectorRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.tileManager.renderContext;
        var gl = renderContext.gl;
        var modelViewMatrix = mat4.create();

        // Setup program
        this.program.apply();

        gl.depthFunc(gl.LEQUAL);
        // Do not write into z-buffer : the tiled vector are clamped to terrain, so the z of terrain should not change
        gl.depthMask(false);
        gl.uniformMatrix4fv(
            this.program.uniforms.projectionMatrix,
            false,
            renderContext.projectionMatrix
        );

        var currentStyle = null;

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];

            var tile = renderable.tile;

            mat4.multiply(
                renderContext.viewMatrix,
                tile.matrix,
                modelViewMatrix
            );
            gl.uniformMatrix4fv(
                this.program.uniforms.modelViewMatrix,
                false,
                modelViewMatrix
            );
            gl.uniform1f(this.program.uniforms.zOffset, tile.radius * 0.0007);

            currentStyle = renderable.bucket.style;

            renderable.bindBuffers(renderContext);

            gl.vertexAttribPointer(
                this.program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            if (renderable.triIndices.length > 0) {
                gl.uniform4f(
                    this.program.uniforms.color,
                    currentStyle.fillColor[0],
                    currentStyle.fillColor[1],
                    currentStyle.fillColor[2],
                    currentStyle.fillColor[3] *
                        renderable.bucket.layer.getOpacity()
                );
                gl.drawElements(
                    gl.TRIANGLES,
                    renderable.triIndices.length,
                    renderable.indexType,
                    0
                );
            }

            if (renderable.lineIndices.length > 0) {
                gl.lineWidth(currentStyle.strokeWidth);
                gl.uniform4f(
                    this.program.uniforms.color,
                    currentStyle.strokeColor[0],
                    currentStyle.strokeColor[1],
                    currentStyle.strokeColor[2],
                    currentStyle.strokeColor[3] *
                        renderable.bucket.layer.getOpacity()
                );
                var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
                gl.drawElements(
                    gl.LINES,
                    renderable.lineIndices.length,
                    renderable.indexType,
                    renderable.triIndices.length * size
                );
            }
        }

        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    return TiledVectorRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/LineStringRenderable',[
    "../Utils/Constants",
    "../Utils/Utils",
    "./FeatureStyle",
    "./RendererManager",
    "../Tiling/TiledVectorRenderable",
    "../Tiling/TiledVectorRenderer",
    "../Utils/Numeric"
], function(
    Constants,
    Utils,
    FeatureStyle,
    RendererManager,
    TiledVectorRenderable,
    TiledVectorRenderer,
    Numeric
) {
    /**************************************************************************************************************/

    /**
         @name LineRenderer
         @class
             LineStringRenderable manages lineString data to be rendered on a tile.
         @augments TiledVectorRenderable
         @param {Bucket} bucket Bucket
         @constructor
         */

    var LineStringRenderable = function(bucket) {
        TiledVectorRenderable.prototype.constructor.call(this, bucket);
    };

    /**************************************************************************************************************/

    // Inheritance
    Utils.inherits(TiledVectorRenderable, LineStringRenderable);

    /**************************************************************************************************************/

    /**************************************************************************************************************/

    /**
     * Check if a geometry crosses the date line
     * @function _fixDateLine
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     * @return {Array} Lines
     * @private
     */
    LineStringRenderable.prototype._fixDateLine = function(tile, coords) {
        var newCoords = [];
        var lines = [newCoords];
        for (var n = 0; n < coords.length - 1; n++) {
            newCoords.push(coords[n]);

            var x1 = coords[n][0];
            var y1 = coords[n][1];
            var x2 = coords[n + 1][0];
            var y2 = coords[n + 1][1];
            if (Math.abs(x2 - x1) > 180) {
                if (x1 < 0) {
                    x1 += 360;
                }
                if (x2 < 0) {
                    x2 += 360;
                }

                var t = (180 - x1) / (x2 - x1);
                if (t > 0 && t < 1) {
                    var y = y1 + t * (y2 - y1);
                    var x = coords[n][0] > 0 ? 180 : -180;
                    newCoords.push([x, y]);
                    newCoords = [[-x, y]];
                    lines.push(newCoords);
                }
            }
        }
        newCoords.push(coords[coords.length - 1]);
        //newCoords.push( coords[0] );

        return lines;
    };

    /**
     * Build vertices and indices from the coordinates.
     * Clamp a line string on a tile
     * @function buildVerticesAndIndices
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     */
    LineStringRenderable.prototype.buildVerticesAndIndices = function(
        tile,
        coords
    ) {
        if (coords.length === 0) {
            return;
        }

        // Fix date line for coordinates first
        var coordinates = this._fixDateLine(tile, coords);

        for (var i = 0; i < coordinates.length; i++) {
            this._buildVerticesAndIndices(tile, coordinates[i]);
        }
    };

    /**
     * Build vertices and indices from the coordinates.
     * Clamp a line string on a tile
     * @function _buildVerticesAndIndices
     * @memberof LineStringRenderable.prototype
     * @param {Tile} tile Tile
     * @param coords
     * @private
     */
    LineStringRenderable.prototype._buildVerticesAndIndices = function(
        tile,
        coords
    ) {
        var size = tile.config.tesselation;
        var vs = tile.config.vertexSize;

        coords.push(coords[coords.length - 1]);
        // Convert lon/lat coordinates to tile coordinates (between [0,size-1] inside the tile)
        var tileCoords = tile.lonlat2tile(coords);

        for (var i = 0; i < coords.length - 1; i++) {
            var u1 = tileCoords[i][0];
            var v1 = tileCoords[i][1];

            var u2 = tileCoords[i + 1][0];
            var v2 = tileCoords[i + 1][1];

            var intersections = [];
            var n, v, res, u;
            var vertexOffset, x, y, z;
            // Intersect the segment with the tile grid

            // First intersect with columns
            // uStart, uEnd represent a range of the tile columns that the segement can intersect
            var uStart = Math.max(-1, Math.min(u1, u2));
            var uEnd = Math.min(size - 1, Math.max(u1, u2));
            for (n = Math.floor(uStart) + 1; n < Math.floor(uEnd) + 1; n++) {
                u = n;
                res = Numeric.lineIntersection(
                    u1,
                    v1,
                    u2,
                    v2,
                    u,
                    0.0,
                    u,
                    size - 1
                );
                if (
                    res[0] > 0.0 &&
                    res[0] < 1.0 &&
                    res[1] >= 0.0 &&
                    res[1] <= 1.0
                ) {
                    v = res[1] * (size - 1);
                    var vFloor = Math.floor(v);
                    var vFrac = v - vFloor;
                    vertexOffset = vs * (vFloor * size + n);
                    x =
                        (1.0 - vFrac) * tile.vertices[vertexOffset] +
                        vFrac * tile.vertices[vertexOffset + vs * size];
                    y =
                        (1.0 - vFrac) * tile.vertices[vertexOffset + 1] +
                        vFrac * tile.vertices[vertexOffset + vs * size + 1];
                    z =
                        (1.0 - vFrac) * tile.vertices[vertexOffset + 2] +
                        vFrac * tile.vertices[vertexOffset + vs * size + 2];
                    intersections.push([res[0], x, y, z]);
                }
            }

            // Then intersect with rows
            // vStart, vEnd represent a range of the tile rows that the segement can intersect
            var vStart = Math.max(-1, Math.min(v1, v2));
            var vEnd = Math.min(size - 1, Math.max(v1, v2));
            for (n = Math.floor(vStart) + 1; n < Math.floor(vEnd) + 1; n++) {
                v = n;
                res = Numeric.lineIntersection(
                    u1,
                    v1,
                    u2,
                    v2,
                    0.0,
                    v,
                    size - 1,
                    v
                );
                if (
                    res[0] > 0.0 &&
                    res[0] < 1.0 &&
                    res[1] >= 0.0 &&
                    res[1] <= 1.0
                ) {
                    u = res[1] * (size - 1);
                    var uFloor = Math.floor(u);
                    var uFrac = u - uFloor;
                    vertexOffset = vs * (n * size + uFloor);
                    x =
                        (1.0 - uFrac) * tile.vertices[vertexOffset] +
                        uFrac * tile.vertices[vertexOffset + vs];
                    y =
                        (1.0 - uFrac) * tile.vertices[vertexOffset + 1] +
                        uFrac * tile.vertices[vertexOffset + vs + 1];
                    z =
                        (1.0 - uFrac) * tile.vertices[vertexOffset + 2] +
                        uFrac * tile.vertices[vertexOffset + vs + 2];
                    intersections.push([res[0], x, y, z]);
                }
            }
            // Sort intersections found on the segment
            intersections.sort(function(a, b) {
                return a[0] > b[0];
            });

            // Build the vertices from the intersections found
            var startIndex = this.vertices.length / 3;
            var vec;
            if (u1 >= 0.0 && u1 <= size - 1 && v1 >= 0.0 && v1 <= size - 1) {
                vec = tile.computePosition(u1, v1);
                this.vertices.push(vec[0]);
                this.vertices.push(vec[1]);
                this.vertices.push(vec[2]);
            }

            for (n = 0; n < intersections.length; n++) {
                this.vertices.push(intersections[n][1]);
                this.vertices.push(intersections[n][2]);
                this.vertices.push(intersections[n][3]);
            }

            if (u2 >= 0.0 && u2 <= size - 1 && v2 >= 0.0 && v2 <= size - 1) {
                vec = tile.computePosition(u2, v2);
                this.vertices.push(vec[0]);
                this.vertices.push(vec[1]);
                this.vertices.push(vec[2]);
            }

            var endIndex = this.vertices.length / 3;

            for (n = startIndex; n < endIndex - 1; n++) {
                this.lineIndices.push(n);
                this.lineIndices.push(n + 1);
            }
        }
    };

    /**************************************************************************************************************/

    /**
 @name LineStringRenderer
 @class
	LineStringRenderer manages lineString data to be rendered on a tile.
 @augments TiledVectorRenderer
 @param {Planet} planet Planet
 @constructor
 */

    var LineStringRenderer = function(globe) {
        TiledVectorRenderer.prototype.constructor.call(this, globe);
    };

    // Inheritance
    Utils.inherits(TiledVectorRenderer, LineStringRenderer);

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof LineStringRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    LineStringRenderer.prototype.canApply = function(type, style) {
        if (this.globe.isSky()) {
            return false;
        }
        result =
            (type === Constants.GEOMETRY.LineString ||
                type === Constants.GEOMETRY.MultiLineString ||
                (!style.fill &&
                    (type === Constants.GEOMETRY.Polygon ||
                        type === Constants.GEOMETRY.MultiPolygon))) &&
            !style.gradientLength;
        return result;
    };
    /**************************************************************************************************************/
    /**
  @name LineStringBucket
  @class
 	  Bucket constructor for LineStringRenderer
  @param layer
	@param style
  @constructor
  */
    var LineStringBucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof LineStringBucket.prototype
     * @return {LineStringRenderable} Renderable
     */
    LineStringBucket.prototype.createRenderable = function() {
        return new LineStringRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof LineStringBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    LineStringBucket.prototype.isCompatible = function(style) {
        result =
            this.style.strokeColor[0] === style.strokeColor[0] &&
            this.style.strokeColor[1] === style.strokeColor[1] &&
            this.style.strokeColor[2] === style.strokeColor[2] &&
            this.style.strokeColor[3] === style.strokeColor[3] &&
            this.style.strokeWidth === style.strokeWidth;
        return result;
    };

    /**************************************************************************************************************/

    /**
     * Get or create a bucket to store a feature with the given style
     * @function createBucket
     * @memberof LineStringRenderer.prototype
     * @param layer
     * @param style
     * @return {LineStringBucket} Bucket
     */
    LineStringRenderer.prototype.createBucket = function(layer, style) {
        // Create a bucket
        return new LineStringBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new LineStringRenderer(globe);
    });

    return LineStringRenderable;
});

// jshint ignore: start
define('Renderer/pnltri',[],function() {
    // pnltri.js / raw.github.com/jahting/pnltri.js/master/LICENSE
    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	(Simple) Polygon Near-Linear Triangulation
     *	  with fast ear-clipping for polygons without holes
     *
     */

    var PNLTRI = { REVISION: "2.1.1" };

    //	#####  Global Constants  #####

    //	#####  Global Variables  #####

    /**
     * @author jahting / http://www.ameco.tv/
     */

    PNLTRI.Math = {
        random: Math.random, // function to use for random number generation

        // generate random ordering in place:
        //	Fisher-Yates shuffle
        array_shuffle: function(inoutArray) {
            for (var i = inoutArray.length - 1; i > 0; i--) {
                var j = Math.floor(PNLTRI.Math.random() * (i + 1));
                var tmp = inoutArray[i];
                inoutArray[i] = inoutArray[j];
                inoutArray[j] = tmp;
            }
            return inoutArray;
        },

        //	like compare (<=>)
        //		yA > yB resp. xA > xB: 1, equal: 0, otherwise: -1
        compare_pts_yx: function(inPtA, inPtB) {
            var deltaY = inPtA.y - inPtB.y;
            if (deltaY < PNLTRI.Math.EPSILON_N) {
                return -1;
            } else if (deltaY > PNLTRI.Math.EPSILON_P) {
                return 1;
            } else {
                var deltaX = inPtA.x - inPtB.x;
                if (deltaX < PNLTRI.Math.EPSILON_N) {
                    return -1;
                } else if (deltaX > PNLTRI.Math.EPSILON_P) {
                    return 1;
                } else {
                    return 0;
                }
            }
        },

        ptsCrossProd: function(inPtVertex, inPtFrom, inPtTo) {
            // two vectors: ( v0: inPtVertex -> inPtFrom ), ( v1: inPtVertex -> inPtTo )
            // CROSS_SINE: sin(theta) * len(v0) * len(v1)
            return (
                (inPtFrom.x - inPtVertex.x) * (inPtTo.y - inPtVertex.y) -
                (inPtFrom.y - inPtVertex.y) * (inPtTo.x - inPtVertex.x)
            );
            // <=> crossProd( inPtFrom-inPtVertex, inPtTo-inPtVertex )
            // == 0: colinear (angle == 0 or 180 deg == PI rad)
            // > 0:  v1 lies left of v0, CCW angle from v0 to v1 is convex ( < 180 deg )
            // < 0:  v1 lies right of v0, CW angle from v0 to v1 is convex ( < 180 deg )
        }
    };

    // precision of floating point arithmetic
    //	PNLTRI.Math.EPSILON_P = Math.pow(2,-32);	// ~ 0.0000000001
    PNLTRI.Math.EPSILON_P = Math.pow(2, -43); // ~ 0.0000000000001
    PNLTRI.Math.EPSILON_N = -PNLTRI.Math.EPSILON_P;

    //	Problem with EPSILON-compares:
    //	- especially when there is a x-coordinate ordering on equal y-coordinates
    //		=> either NO EPSILON-compares on y-coordinates, since almost equal y
    //			can have very different x - so they are not nearly close
    //		or EPSILON must be bigger: Solution so far.
    /**
     * @author jahting / http://www.ameco.tv/
     */

    PNLTRI.PolygonData = function(inPolygonChainList) {
        // list of polygon vertices
        //	.x, .y: coordinates
        this.vertices = [];

        // list of polygon segments, original polygons ane holes
        //	and additional ones added during the subdivision into
        //	uni-y-monotone polygons (s. this.monoSubPolyChains)
        //	doubly linked by: snext, sprev
        this.segments = [];
        this.diagonals = [];

        // for the ORIGINAL polygon chains
        this.idNextPolyChain = 0;
        //	for each original chain: lies the polygon inside to the left?
        //	"true": winding order is CCW for a contour or CW for a hole
        //	"false": winding order is CW for a contour or CCW for a hole
        this.PolyLeftArr = [];

        // indices into this.segments: at least one for each monoton chain for the polygon
        //  these subdivide the polygon into uni-y-monotone polygons, that is
        //  polygons that have only one segment between ymax and ymin on one side
        //  and the other side has monotone increasing y from ymin to ymax
        // the monoSubPolyChains are doubly linked by: mnext, mprev
        this.monoSubPolyChains = [];

        // list of triangles: each 3 indices into this.vertices
        this.triangles = [];

        // initialize optional polygon chains
        if (inPolygonChainList) {
            for (var i = 0, j = inPolygonChainList.length; i < j; i++) {
                this.addPolygonChain(inPolygonChainList[i]);
            }
        }
    };

    PNLTRI.PolygonData.prototype = {
        constructor: PNLTRI.PolygonData,

        /*	Accessors  */

        nbVertices: function() {
            return this.vertices.length;
        },
        getSegments: function() {
            return this.segments;
        },
        getFirstSegment: function() {
            return this.segments[0];
        },
        getMonoSubPolys: function() {
            return this.monoSubPolyChains;
        },
        getTriangles: function() {
            return this.triangles.concat();
        },

        nbPolyChains: function() {
            return this.idNextPolyChain;
        },

        // for the polygon data AFTER triangulation
        //	returns an Array of flags, one flag for each polygon chain:
        //		lies the inside of the polygon to the left?
        //		"true" implies CCW for contours and CW for holes
        get_PolyLeftArr: function() {
            return this.PolyLeftArr.concat();
        },
        set_PolyLeft_wrong: function(inChainId) {
            this.PolyLeftArr[inChainId] = false;
        },

        /*	Helper  */

        // checks winding order by calculating the area of the polygon
        isClockWise: function(inStartSeg) {
            var cursor = inStartSeg,
                doubleArea = 0;
            do {
                doubleArea +=
                    (cursor.vFrom.x - cursor.vTo.x) *
                    (cursor.vFrom.y + cursor.vTo.y);
                cursor = cursor.snext;
            } while (cursor != inStartSeg);
            return doubleArea < 0;
        },

        /*	Operations  */

        appendVertexEntry: function(inVertexX, inVertexY) {
            // private
            var vertex = {
                id: this.vertices.length, // vertex id, representing input sequence
                x: inVertexX, // coordinates
                y: inVertexY
            };
            this.vertices.push(vertex);
            return vertex;
        },

        createSegmentEntry: function(inVertexFrom, inVertexTo) {
            // private
            return {
                chainId: this.idNextPolyChain,
                // end points of segment
                vFrom: inVertexFrom, // -> start point entry in vertices
                vTo: inVertexTo, // -> end point entry in vertices
                // upward segment? (i.e. vTo > vFrom) !!! only valid for sprev,snext NOT for mprev,mnext !!!
                upward:
                    PNLTRI.Math.compare_pts_yx(inVertexTo, inVertexFrom) == 1,
                // doubly linked list of original polygon chains (not the monoChains !)
                sprev: null, // previous segment
                snext: null, // next segment
                //
                //	for performance reasons:
                //	 initialization of all fields added later
                //
                // for trapezoids
                rootFrom: null, // root of partial tree where vFrom is located
                rootTo: null, // root of partial tree where vTo is located
                is_inserted: false, // already inserted into QueryStructure ?
                // for assigning depth: trapezoids
                trLeft: null, // one trapezoid bordering on the left of this segment
                trRight: null, // one trapezoid bordering on the right of this segment
                // for monochains
                mprev: null, // doubly linked list for monotone chains (sub-polygons)
                mnext: null,
                marked: false // already visited during unique monoChain identification ?
            };
        },

        appendSegmentEntry: function(inSegment) {
            // private
            this.segments.push(inSegment);
            return inSegment;
        },

        appendDiagonalsEntry: function(inDiagonal) {
            // <<<<<	public
            this.diagonals.push(inDiagonal);
            return inDiagonal;
        },

        addVertexChain: function(inRawPointList) {
            // private

            function verts_equal(inVert1, inVert2) {
                return (
                    Math.abs(inVert1.x - inVert2.x) < PNLTRI.Math.EPSILON_P &&
                    Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P
                );
            }

            function verts_colinear_chain(inVert1, inVert2, inVert3) {
                if (
                    Math.abs(
                        PNLTRI.Math.ptsCrossProd(inVert2, inVert1, inVert3)
                    ) > PNLTRI.Math.EPSILON_P
                )
                    return false;
                // only real sequences, not direction reversals
                var low, middle, high;
                if (Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P) {
                    // horizontal line
                    middle = inVert2.x;
                    if (inVert1.x < inVert3.x) {
                        low = inVert1.x;
                        high = inVert3.x;
                    } else {
                        low = inVert3.x;
                        high = inVert1.x;
                    }
                } else {
                    middle = inVert2.y;
                    if (inVert1.y < inVert3.y) {
                        low = inVert1.y;
                        high = inVert3.y;
                    } else {
                        low = inVert3.y;
                        high = inVert1.y;
                    }
                }
                return (
                    low - middle < PNLTRI.Math.EPSILON_P &&
                    middle - high < PNLTRI.Math.EPSILON_P
                );
            }

            var newVertices = [];
            var newVertex, acceptVertex, lastIdx;
            for (var i = 0; i < inRawPointList.length; i++) {
                newVertex = this.appendVertexEntry(
                    inRawPointList[i].x,
                    inRawPointList[i].y
                );
                // suppresses zero-length segments
                acceptVertex = true;
                lastIdx = newVertices.length - 1;
                if (lastIdx >= 0) {
                    if (verts_equal(newVertex, newVertices[lastIdx])) {
                        acceptVertex = false;
                    } else if (lastIdx > 0) {
                        if (
                            verts_colinear_chain(
                                newVertices[lastIdx - 1],
                                newVertices[lastIdx],
                                newVertex
                            )
                        ) {
                            newVertices.pop();
                        }
                    }
                }
                if (acceptVertex) newVertices.push(newVertex);
            }
            // compare last vertices to first: suppresses zero-length and co-linear segments
            lastIdx = newVertices.length - 1;
            if (
                lastIdx > 0 &&
                verts_equal(newVertices[lastIdx], newVertices[0])
            ) {
                newVertices.pop();
                lastIdx--;
            }
            if (lastIdx > 1) {
                if (
                    verts_colinear_chain(
                        newVertices[lastIdx - 1],
                        newVertices[lastIdx],
                        newVertices[0]
                    )
                ) {
                    newVertices.pop();
                    lastIdx--;
                }
                if (
                    lastIdx > 1 &&
                    verts_colinear_chain(
                        newVertices[lastIdx],
                        newVertices[0],
                        newVertices[1]
                    )
                ) {
                    newVertices.shift();
                }
            }

            return newVertices;
        },

        addPolygonChain: function(inRawPointList) {
            // <<<<<< public

            // vertices
            var newVertices = this.addVertexChain(inRawPointList);
            if (newVertices.length < 3) {
                console.log("Polygon has < 3 vertices!", newVertices);
                return 0;
            }

            // segments
            var saveSegListLength = this.segments.length;
            //
            var segment, firstSeg, prevSeg;
            for (var i = 0; i < newVertices.length - 1; i++) {
                segment = this.createSegmentEntry(
                    newVertices[i],
                    newVertices[i + 1]
                );
                if (prevSeg) {
                    segment.sprev = prevSeg;
                    prevSeg.snext = segment;
                } else {
                    firstSeg = segment;
                }
                prevSeg = segment;
                this.appendSegmentEntry(segment);
            }
            // close polygon
            segment = this.createSegmentEntry(
                newVertices[newVertices.length - 1],
                newVertices[0]
            );
            segment.sprev = prevSeg;
            prevSeg.snext = segment;
            this.appendSegmentEntry(segment);
            firstSeg.sprev = segment;
            segment.snext = firstSeg;

            this.PolyLeftArr[this.idNextPolyChain++] = true;
            return this.segments.length - saveSegListLength;
        },

        /* Monotone Polygon Chains */

        // Generate the uni-y-monotone sub-polygons from
        //	the trapezoidation of the polygon.

        create_mono_chains: function() {
            // <<<<<< public
            var newMono, newMonoTo, toFirstOutSeg, fromRevSeg;
            for (var i = 0, j = this.segments.length; i < j; i++) {
                newMono = this.segments[i];
                if (this.PolyLeftArr[newMono.chainId]) {
                    // preserve winding order
                    newMonoTo = newMono.vTo; // target of segment
                    newMono.mprev = newMono.sprev; // doubly linked list for monotone chains (sub-polygons)
                    newMono.mnext = newMono.snext;
                } else {
                    // reverse winding order
                    newMonoTo = newMono.vFrom;
                    newMono = newMono.snext;
                    newMono.mprev = newMono.snext;
                    newMono.mnext = newMono.sprev;
                }
                if ((fromRevSeg = newMono.vFrom.lastInDiag)) {
                    // assignment !
                    fromRevSeg.mnext = newMono;
                    newMono.mprev = fromRevSeg;
                    newMono.vFrom.lastInDiag = null; // cleanup
                }
                if ((toFirstOutSeg = newMonoTo.firstOutDiag)) {
                    // assignment !
                    toFirstOutSeg.mprev = newMono;
                    newMono.mnext = toFirstOutSeg;
                    newMonoTo.firstOutDiag = null; // cleanup
                }
            }
        },

        // For each monotone polygon, find the ymax (to determine the two
        // y-monotone chains) and skip duplicate monotone polygons

        unique_monotone_chains_max: function() {
            // <<<<<< public

            function find_monotone_chain_max(frontMono) {
                var frontPt, firstPt, ymaxPt;

                var monoPosmax = frontMono;
                firstPt = ymaxPt = frontMono.vFrom;

                frontMono.marked = true;
                frontMono = frontMono.mnext;
                while ((frontPt = frontMono.vFrom)) {
                    // assignment !
                    if (frontMono.marked) {
                        if (frontPt == firstPt) break; // mono chain completed
                        console.log(
                            "ERR unique_monotone: segment in two chains",
                            firstPt,
                            frontMono
                        );
                        return null;
                    } else {
                        /*					if ( frontPt == firstPt ) {			// check for robustness
						console.log("ERR unique_monotone: point double", firstPt, frontMono );
					}		*/
                        frontMono.marked = true;
                    }
                    if (PNLTRI.Math.compare_pts_yx(frontPt, ymaxPt) == 1) {
                        ymaxPt = frontPt;
                        monoPosmax = frontMono;
                    }
                    frontMono = frontMono.mnext;
                }
                return monoPosmax;
            }

            var frontMono, monoPosmax;

            // assumes attribute "marked" is NOT yet "true" for any mono chain segment
            this.monoSubPolyChains = [];
            // loop through all original segments
            for (var i = 0, j = this.segments.length; i < j; i++) {
                frontMono = this.segments[i];
                if (frontMono.marked) continue; // already in a processed mono chain
                monoPosmax = find_monotone_chain_max(frontMono);
                if (monoPosmax) this.monoSubPolyChains.push(monoPosmax);
            }
            // loop through all additional segments (diagonals)			// TODO: Testcase for mono chain without original segments !!!
            /*		for ( var i = 0, j = this.diagonals.length; i < j; i++ ) {
			frontMono = this.diagonals[i];
			if ( frontMono.marked )		continue;		// already in a processed mono chain
			monoPosmax = find_monotone_chain_max( frontMono );
			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
		}	*/
            return this.monoSubPolyChains;
        },

        /* Triangles */

        clearTriangles: function() {
            this.triangles = [];
        },

        addTriangle: function(inVert1, inVert2, inVert3) {
            this.triangles.push([inVert1.id, inVert2.id, inVert3.id]);
        }
    };

    /**
     * Simple Polygon Triangulation by Ear Clipping
     *
     * description of technique employed:
     *	http://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/polygon1.htm
     *
     * This code is a quick port of code written in C++ which was submitted to
     *	flipcode.com by John W. Ratcliff  // July 22, 2000
     * See original code and more information here:
     *	http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     *
     * ported to actionscript by Zevan Rosser
     *	http://actionsnippet.com/?p=1462
     *
     * ported to javascript by Joshua Koo
     *	http://www.lab4games.net/zz85/blog
     *
     * adapted to doubly linked list by Juergen Ahting
     *	http://www.ameco.tv
     *
     */

    PNLTRI.EarClipTriangulator = function(inPolygonData) {
        this.polyData = inPolygonData;
    };

    PNLTRI.EarClipTriangulator.prototype = {
        constructor: PNLTRI.EarClipTriangulator,

        // triangulates first doubly linked segment list in this.polyData
        //	algorithm uses ear-clipping and runs in O(n^2) time

        triangulate_polygon_no_holes: function() {
            function isEarAt(vertex) {
                var prevX = vertex.mprev.vFrom.x;
                var prevY = vertex.mprev.vFrom.y;

                var vertX = vertex.vFrom.x;
                var vertY = vertex.vFrom.y;

                var nextX = vertex.mnext.vFrom.x;
                var nextY = vertex.mnext.vFrom.y;

                var vnX = nextX - vertX,
                    vnY = nextY - vertY;
                var npX = prevX - nextX,
                    npY = prevY - nextY;
                var pvX = vertX - prevX,
                    pvY = vertY - prevY;

                // concave angle at vertex -> not an ear to cut off
                if (PNLTRI.Math.EPSILON_P > pvX * vnY - vnX * pvY) return false;

                // check whether any other point lieas within the triangle abc
                var vStop = vertex.mprev.mprev;
                var vOther = vertex.mnext;
                while (vOther != vStop) {
                    vOther = vOther.mnext;
                    var otherX = vOther.vFrom.x;
                    var otherY = vOther.vFrom.y;

                    var poX = otherX - prevX,
                        poY = otherY - prevY;
                    // just in case there are several vertices with the same coordinate
                    if (poX === 0 && poY === 0) continue; // vOther == vertex.mprev
                    var voX = otherX - vertX,
                        voY = otherY - vertY;
                    if (voX === 0 && voY === 0) continue; // vOther == vertex
                    var noX = otherX - nextX,
                        noY = otherY - nextY;
                    if (noX === 0 && noY === 0) continue; // vOther == vertex.mnext

                    // if vOther is inside triangle abc -> not an ear to cut off
                    if (
                        vnX * voY - vnY * voX >= PNLTRI.Math.EPSILON_N &&
                        pvX * poY - pvY * poX >= PNLTRI.Math.EPSILON_N &&
                        npX * noY - npY * noX >= PNLTRI.Math.EPSILON_N
                    )
                        return false;
                }
                return true;
            }

            var myPolyData = this.polyData;
            var startSeg = myPolyData.getFirstSegment();

            // create a counter-clockwise ordered doubly linked list (monoChain links)

            var cursor = startSeg;
            if (myPolyData.isClockWise(startSeg)) {
                do {
                    // reverses chain order
                    cursor.mprev = cursor.snext;
                    cursor.mnext = cursor.sprev;
                    cursor = cursor.sprev;
                } while (cursor != startSeg);
                myPolyData.set_PolyLeft_wrong(0);
            } else {
                do {
                    cursor.mprev = cursor.sprev;
                    cursor.mnext = cursor.snext;
                    cursor = cursor.snext;
                } while (cursor != startSeg);
            }

            //  remove all vertices except 2, creating 1 triangle every time

            var vertex = startSeg;
            var fullLoop = vertex; // prevent infinite loop on "defective" polygons

            while (vertex.mnext != vertex.mprev) {
                if (isEarAt(vertex)) {
                    // found a triangle ear to cut off
                    this.polyData.addTriangle(
                        vertex.mprev.vFrom,
                        vertex.vFrom,
                        vertex.mnext.vFrom
                    );
                    // remove vertex from the remaining chain
                    vertex.mprev.mnext = vertex.mnext;
                    vertex.mnext.mprev = vertex.mprev;
                    vertex = vertex.mnext;
                    fullLoop = vertex; // reset error detection
                } else {
                    vertex = vertex.mnext;
                    // loop?: probably non-simple polygon -> stop with error
                    if (vertex == fullLoop) return false;
                }
            }

            return true;
        }

        /*	// takes one element of a double linked segment list
	//	works on array of vertices

	triangulate_polygon_no_holes: function () {
		var startSeg = this.polyData.getFirstSegment();

		function vertList( inStartSeg ) {
			var verts = [];
			// we want a counter-clockwise polygon in verts
			var doubleArea = 0.0;
			var cursor = inStartSeg;
			var p,q;
			var idx = 0;
			do {
				p = cursor.sprev.vFrom;
				q = cursor.vFrom;
				doubleArea += p.x * q.y - q.x * p.y;
				verts[idx++] = q;
				cursor = cursor.snext;
			} while ( cursor != inStartSeg );
			if ( doubleArea < 0.0 ) {
				verts = verts.reverse();
				var tmp = verts.pop();
				verts.unshift( tmp );
			}
			return	verts;
		}

		function snip( verts, u, v, w, n ) {

			var ax = verts[ u ].x;
			var ay = verts[ u ].y;

			var bx = verts[ v ].x;
			var by = verts[ v ].y;

			var cx = verts[ w ].x;
			var cy = verts[ w ].y;

			if ( PNLTRI.Math.EPSILON_P > ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			var p, px, py;

			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			for ( p = 0; p < n; p ++ ) {

				px = verts[ p ].x
				py = verts[ p ].y

				apx = px - ax;  apy = py - ay;
					if ( ( apx == 0 ) && ( apy == 0 ) )		continue;
				bpx = px - bx;  bpy = py - by;
					if ( ( bpx == 0 ) && ( bpy == 0 ) )		continue;
				cpx = px - cx;  cpy = py - cy;
					if ( ( cpx == 0 ) && ( cpy == 0 ) )		continue;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= PNLTRI.Math.EPSILON_N ) &&
					 ( bCROSScp >= PNLTRI.Math.EPSILON_N ) &&
					 ( cCROSSap >= PNLTRI.Math.EPSILON_N ) ) return false;

			}

			return true;

		};

		var result = [];

		var	verts = vertList( startSeg );

		var n = verts.length;
		var nv = n;

		var u, v, w;

		//  remove nv - 2 vertices, creating 1 triangle every time

		var count = 2 * nv;   // error detection

		for ( v = nv - 1; nv > 2; ) {

			// if we loop, it is probably a non-simple polygon

			if ( ( count -- ) <= 0 )	return false;

			// three consecutive vertices in current polygon, <u,v,w>

			u = v; 	 	if ( nv <= u ) u = 0;     // previous
			v = u + 1;  if ( nv <= v ) v = 0;     // new v
			w = v + 1;  if ( nv <= w ) w = 0;     // next

			if ( snip( verts, u, v, w, nv ) ) {

				// output Triangle

				this.polyData.addTriangle( verts[ u ], verts[ v ], verts[ w ] );

				// remove v from the remaining polygon

				var s, t;

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				v --;
				if ( v < 0 )	v = nv-1;

				// reset error detection counter

				count = 2 * nv;

			}

		}

		return true;

	},		*/
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to create the trapezoidation of a polygon with holes
     *	 according to Seidel's algorithm [Sei91]
     */

    PNLTRI.Trapezoid = function(inHigh, inLow, inLeft, inRight) {
        this.vHigh = inHigh
            ? inHigh
            : { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY };
        this.vLow = inLow
            ? inLow
            : { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY };

        this.lseg = inLeft;
        this.rseg = inRight;

        //	this.uL = null;				// -> Trapezoid: upper left neighbor
        //	this.uR = null;				// -> Trapezoid: upper right neighbor
        //	this.dL = null;				// -> Trapezoid: lower left neighbor
        //	this.dR = null;				// -> Trapezoid: lower right neighbor

        //	this.sink = null;			// link to corresponding SINK-Node in QueryStructure

        //	this.usave = null;			// temp: uL/uR, preserved for next step
        //	this.uleft = null;			// temp: from uL? (true) or uR (false)

        this.depth = -1; // no depth assigned yet

        this.monoDone = false; // monotonization: done with trying to split this trapezoid ?
    };

    PNLTRI.Trapezoid.prototype = {
        constructor: PNLTRI.Trapezoid,

        clone: function() {
            var newTrap = new PNLTRI.Trapezoid(
                this.vHigh,
                this.vLow,
                this.lseg,
                this.rseg
            );

            newTrap.uL = this.uL;
            newTrap.uR = this.uR;

            newTrap.dL = this.dL;
            newTrap.dR = this.dR;

            newTrap.sink = this.sink;

            return newTrap;
        },

        splitOffLower: function(inSplitPt) {
            var trLower = this.clone(); // new lower trapezoid

            this.vLow = trLower.vHigh = inSplitPt;

            // L/R unknown, anyway changed later
            this.dL = trLower; // setBelow
            trLower.uL = this; // setAbove
            this.dR = trLower.uR = null;

            // setAbove
            if (trLower.dL) trLower.dL.uL = trLower; // dL always connects to uL
            if (trLower.dR) trLower.dR.uR = trLower; // dR always connects to uR

            return trLower;
        }
    };

    /*==============================================================================
 *
 *============================================================================*/

    // PNLTRI.qsCounter = 0;

    PNLTRI.QsNode = function(inTrapezoid) {
        //	this.qsId = PNLTRI.qsCounter++;				// Debug only
        // Only SINK-nodes are created directly.
        // The others originate from splitting trapezoids
        // - by a horizontal line: SINK-Node -> Y-Node
        // - by a segment: SINK-Node -> X-Node
        this.trap = inTrapezoid;
        inTrapezoid.sink = this;
    };

    PNLTRI.QsNode.prototype = {
        constructor: PNLTRI.QsNode
    };

    /*==============================================================================
 *
 *============================================================================*/

    PNLTRI.QueryStructure = function(inPolygonData) {
        // initialise the query structure and trapezoid list
        var initialTrap = new PNLTRI.Trapezoid(null, null, null, null);
        this.trapArray = [];
        this.appendTrapEntry(initialTrap);

        //	PNLTRI.qsCounter = 0;
        this.root = new PNLTRI.QsNode(initialTrap);

        if (inPolygonData) {
            /*
		 * adds and initializes specific attributes for all segments
		 *	// -> QueryStructure: roots of partial tree where vertex is located
		 *	rootFrom, rootTo:	for vFrom, vTo
		 *	// marker
		 *	is_inserted:	already inserted into QueryStructure ?
		 */
            var segListArray = inPolygonData.getSegments();
            for (var i = 0; i < segListArray.length; i++) {
                segListArray[i].rootFrom = segListArray[i].rootTo = this.root;
                segListArray[i].is_inserted = false;
            }
        }
    };

    PNLTRI.QueryStructure.prototype = {
        constructor: PNLTRI.QueryStructure,

        getRoot: function() {
            return this.root;
        },

        appendTrapEntry: function(inTrapezoid) {
            inTrapezoid.trapID = this.trapArray.length; // for Debug
            this.trapArray.push(inTrapezoid);
        },
        cloneTrap: function(inTrapezoid) {
            var trap = inTrapezoid.clone();
            this.appendTrapEntry(trap);
            return trap;
        },

        splitNodeAtPoint: function(inNode, inPoint, inReturnUpper) {
            // inNode: SINK-Node with trapezoid containing inPoint
            var trUpper = inNode.trap; // trUpper: trapezoid includes the point
            if (trUpper.vHigh == inPoint) return inNode; // (ERROR) inPoint is already inserted
            if (trUpper.vLow == inPoint) return inNode; // (ERROR) inPoint is already inserted
            var trLower = trUpper.splitOffLower(inPoint); // trLower: new lower trapezoid
            this.appendTrapEntry(trLower);

            // SINK-Node -> Y-Node
            inNode.yval = inPoint;
            inNode.trap = null;

            inNode.right = new PNLTRI.QsNode(trUpper); // Upper trapezoid sink
            inNode.left = new PNLTRI.QsNode(trLower); // Lower trapezoid sink

            return inReturnUpper ? trUpper.sink : trLower.sink;
        },

        /*
	 * Mathematics & Geometry helper methods
	 */

        fpEqual: function(inNum0, inNum1) {
            return Math.abs(inNum0 - inNum1) < PNLTRI.Math.EPSILON_P;
        },

        // Checks, whether the vertex inPt is to the left of line segment inSeg.
        //	Returns:
        //		>0: inPt is left of inSeg,
        //		<0: inPt is right of inSeg,
        //		=0: inPt is co-linear with inSeg
        //
        //	ATTENTION: always viewed from -y, not as if moving along the segment chain !!

        is_left_of: function(inSeg, inPt, inBetweenY) {
            var retVal;
            var dXfrom = inSeg.vFrom.x - inPt.x;
            var dXto = inSeg.vTo.x - inPt.x;
            var dYfromZero = this.fpEqual(inSeg.vFrom.y, inPt.y);
            if (this.fpEqual(inSeg.vTo.y, inPt.y)) {
                if (dYfromZero) return 0; // all points on a horizontal line
                retVal = dXto;
            } else if (dYfromZero) {
                retVal = dXfrom;
                /*		} else if ( inBetweenY && ( dXfrom * dXto > 0 ) ) {
			// both x-coordinates of inSeg are on the same side of inPt
			if ( Math.abs( dXto ) >= PNLTRI.Math.EPSILON_P )	return	dXto;
			retVal = dXfrom;	*/
            } else {
                if (inSeg.upward) {
                    return PNLTRI.Math.ptsCrossProd(
                        inSeg.vFrom,
                        inSeg.vTo,
                        inPt
                    );
                } else {
                    return PNLTRI.Math.ptsCrossProd(
                        inSeg.vTo,
                        inSeg.vFrom,
                        inPt
                    );
                }
            }
            if (Math.abs(retVal) < PNLTRI.Math.EPSILON_P) return 0;
            return retVal;
        },

        /*
	 * Query structure main methods
	 */

        //	This method finds the Nodes in the QueryStructure corresponding
        //   to the trapezoids that contain the endpoints of inSegment,
        //	 starting from Nodes rootFrom/rootTo and replacing them with the results.

        segNodes: function(inSegment) {
            this.ptNode(inSegment, true);
            this.ptNode(inSegment, false);
        },

        // TODO: may need to prevent infinite loop in case of messed up
        //	trapezoid structure (s. test_add_segment_special_6)

        ptNode: function(inSegment, inUseFrom) {
            var ptMain, ptOther, qsNode;
            if (inUseFrom) {
                ptMain = inSegment.vFrom;
                ptOther = inSegment.vTo; // used if ptMain is not sufficient
                qsNode = inSegment.rootFrom;
            } else {
                ptMain = inSegment.vTo;
                ptOther = inSegment.vFrom;
                qsNode = inSegment.rootTo;
            }
            var compPt, compRes;
            var isInSegmentShorter;

            while (qsNode) {
                if (qsNode.yval) {
                    // Y-Node: horizontal line
                    // 4 times as often as X-Node
                    qsNode =
                        PNLTRI.Math.compare_pts_yx(
                            ptMain == qsNode.yval // is the point already inserted ?
                                ? ptOther
                                : ptMain,
                            qsNode.yval
                        ) == -1
                            ? qsNode.left
                            : qsNode.right; // below : above
                } else if (qsNode.seg) {
                    // X-Node: segment (~vertical line)
                    // 0.8 to 1.5 times as often as SINK-Node
                    if (
                        ptMain == qsNode.seg.vFrom ||
                        ptMain == qsNode.seg.vTo
                    ) {
                        // the point is already inserted
                        if (this.fpEqual(ptMain.y, ptOther.y)) {
                            // horizontal segment
                            if (
                                !this.fpEqual(
                                    qsNode.seg.vFrom.y,
                                    qsNode.seg.vTo.y
                                )
                            ) {
                                qsNode =
                                    ptOther.x < ptMain.x
                                        ? qsNode.left
                                        : qsNode.right; // left : right
                            } else {
                                // co-linear horizontal reversal: test_add_segment_special_7
                                if (ptMain == qsNode.seg.vFrom) {
                                    // connected at qsNode.seg.vFrom
                                    //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vFrom", inUseFrom, inSegment, qsNode )
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.x >= qsNode.seg.vTo.x
                                        : ptOther.x < qsNode.seg.vTo.x;
                                    qsNode = (isInSegmentShorter
                                      ? inSegment.sprev.upward
                                      : qsNode.seg.snext.upward)
                                        ? qsNode.right
                                        : qsNode.left; // above : below
                                } else {
                                    // connected at qsNode.seg.vTo
                                    //								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vTo", inUseFrom, inSegment, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.x < qsNode.seg.vFrom.x
                                        : ptOther.x >= qsNode.seg.vFrom.x;
                                    qsNode = (isInSegmentShorter
                                      ? inSegment.snext.upward
                                      : qsNode.seg.sprev.upward)
                                        ? qsNode.left
                                        : qsNode.right; // below : above
                                }
                            }
                            continue;
                        } else {
                            compRes = this.is_left_of(
                                qsNode.seg,
                                ptOther,
                                false
                            );
                            if (compRes === 0) {
                                // co-linear reversal (not horizontal)
                                //	a co-linear continuation would not reach this point
                                //  since the previous Y-node comparison would have led to a sink instead
                                //							console.log("ptNode: co-linear, going back on previous segment", ptMain, ptOther, qsNode );
                                // now as we have two consecutive co-linear segments we have to avoid a cross-over
                                //	for this we need the far point on the "next" segment to the SHORTER of our two
                                //	segments to avoid that "next" segment to cross the longer of our two segments
                                if (ptMain == qsNode.seg.vFrom) {
                                    // connected at qsNode.seg.vFrom
                                    //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vFrom", ptMain, ptOther, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.y >= qsNode.seg.vTo.y
                                        : ptOther.y < qsNode.seg.vTo.y;
                                    compRes = isInSegmentShorter
                                        ? this.is_left_of(
                                              qsNode.seg,
                                              inSegment.sprev.vFrom,
                                              false
                                          )
                                        : -this.is_left_of(
                                              qsNode.seg,
                                              qsNode.seg.snext.vTo,
                                              false
                                          );
                                } else {
                                    // connected at qsNode.seg.vTo
                                    //								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vTo", ptMain, ptOther, qsNode );
                                    isInSegmentShorter = inSegment.upward
                                        ? ptOther.y < qsNode.seg.vFrom.y
                                        : ptOther.y >= qsNode.seg.vFrom.y;
                                    compRes = isInSegmentShorter
                                        ? this.is_left_of(
                                              qsNode.seg,
                                              inSegment.snext.vTo,
                                              false
                                          )
                                        : -this.is_left_of(
                                              qsNode.seg,
                                              qsNode.seg.sprev.vFrom,
                                              false
                                          );
                                }
                            }
                        }
                    } else {
                        /*					if ( ( PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vFrom ) *			// TODO: Testcase
							PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vTo )
						   ) == 0 ) {
						console.log("ptNode: Pts too close together#2: ", ptMain, qsNode.seg );
					}		*/
                        compRes = this.is_left_of(qsNode.seg, ptMain, true);
                        if (compRes === 0) {
                            // touching: ptMain lies on qsNode.seg but is none of its endpoints
                            //	should happen quite seldom
                            compRes = this.is_left_of(
                                qsNode.seg,
                                ptOther,
                                false
                            );
                            if (compRes === 0) {
                                // co-linear: inSegment and qsNode.seg
                                //	includes case with ptOther connected to qsNode.seg
                                var tmpPtOther = inUseFrom
                                    ? inSegment.sprev.vFrom
                                    : inSegment.snext.vTo;
                                compRes = this.is_left_of(
                                    qsNode.seg,
                                    tmpPtOther,
                                    false
                                );
                            }
                        }
                    }
                    if (compRes > 0) {
                        qsNode = qsNode.left;
                    } else if (compRes < 0) {
                        qsNode = qsNode.right;
                    } else {
                        // ???	TODO - not reached with current tests
                        //				possible at all ?
                        return qsNode;
                        // qsNode = qsNode.left;		// left
                        // qsNode = qsNode.right;		// right
                    }
                } else {
                    // SINK-Node: trapezoid area
                    // least often
                    if (!qsNode.trap) {
                        console.log("ptNode: unknown type", qsNode);
                    }
                    if (inUseFrom) {
                        inSegment.rootFrom = qsNode;
                    } else {
                        inSegment.rootTo = qsNode;
                    }
                    return qsNode;
                }
            } // end while - should not exit here
        },

        // Add a new segment into the trapezoidation and update QueryStructure and Trapezoids
        // 1) locates the two endpoints of the segment in the QueryStructure and inserts them
        // 2) goes from the high-end trapezoid down to the low-end trapezoid
        //		changing all the trapezoids in between.
        // Except for the high-end and low-end no new trapezoids are created.
        // For all in between either:
        // - the existing trapezoid is restricted to the left of the new segment
        //		and on the right side the trapezoid from above is extended downwards
        // - or the other way round:
        //	 the existing trapezoid is restricted to the right of the new segment
        //		and on the left side the trapezoid from above is extended downwards

        add_segment: function(inSegment) {
            var scope = this;

            // functions handling the relationship to the upper neighbors (uL, uR)
            //	of trNewLeft and trNewRight

            function fresh_seg_or_upward_cusp() {
                // trCurrent has at most 1 upper neighbor
                //	and should also have at least 1, since the high-point trapezoid
                //	has been split off another one, which is now above
                var trUpper = trCurrent.uL || trCurrent.uR;

                // trNewLeft and trNewRight CANNOT have been extended from above
                if (trUpper.dL && trUpper.dR) {
                    // upward cusp: top forms a triangle

                    // ATTENTION: the decision whether trNewLeft or trNewRight is the
                    //	triangle trapezoid formed by the two segments has already been taken
                    //	when selecting trCurrent as the left or right lower neighbor to trUpper !!

                    if (trCurrent == trUpper.dL) {
                        //	*** Case: FUC_UC_LEFT; prev: ----
                        // console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg to the left!" );
                        //		  upper
                        //   -------*-------
                        //		   + \
                        //	  NL  +   \
                        //		 +	NR \
                        //		+		\
                        trNewRight.uL = null; // setAbove; trNewRight.uR, trNewLeft unchanged
                        trUpper.dL = trNewLeft; // setBelow; dR: unchanged, NEVER null
                    } else {
                        //	*** Case: FUC_UC_RIGHT; prev: ----
                        // console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg from the right!" );
                        //		  upper
                        //   -------*-------
                        //		   / +
                        //		  /   +	 NR
                        //		 /	NL +
                        //		/		+
                        trNewLeft.uR = null; // setAbove; trNewLeft.uL, trNewRight unchanged
                        trUpper.dR = trNewRight; // setBelow; dL: unchanged, NEVER null
                    }
                } else {
                    //	*** Case: FUC_FS; prev: "splitOffLower"
                    // console.log( "fresh_seg_or_upward_cusp: fresh segment, high adjacent segment still missing" );
                    //		  upper
                    //   -------*-------
                    //		   +
                    //	  NL  +
                    //		 +	NR
                    //		+
                    trNewRight.uL = null; // setAbove; trNewLeft unchanged, set by "splitOffLower"
                    trNewRight.uR = trUpper;
                    trUpper.dR = trNewRight; // setBelow; trUpper.dL unchanged, set by "splitOffLower"
                }
            }

            function continue_chain_from_above() {
                // trCurrent has at least 2 upper neighbors
                if (trCurrent.usave) {
                    // 3 upper neighbors (part II)
                    if (trCurrent.uleft) {
                        //	*** Case: CC_3UN_LEFT; prev: 1B_3UN_LEFT
                        // console.log( "continue_chain_from_above: 3 upper neighbors (part II): u0a, u0b, uR(usave)" );
                        // => left gets one, right gets two of the upper neighbors
                        // !! trNewRight cannot have been extended from above
                        //		and trNewLeft must have been !!
                        //		   +		/
                        //	  C.uL  + C.uR / C.usave
                        //    - - - -+----*----------
                        //		NL	  +		NR
                        trNewRight.uL = trCurrent.uR; // setAbove
                        trNewRight.uR = trCurrent.usave;
                        trNewRight.uL.dL = trNewRight; // setBelow; trNewRight.uL.dR == null, unchanged
                        trNewRight.uR.dR = trNewRight; // setBelow; trNewRight.uR.dL == null, unchanged
                    } else {
                        //	*** Case: CC_3UN_RIGHT; prev: 1B_3UN_RIGHT
                        // console.log( "continue_chain_from_above: 3 upper neighbors (part II): uL(usave), u1a, u1b" );
                        // => left gets two, right gets one of the upper neighbors
                        // !! trNewLeft cannot have been extended from above
                        //		and trNewRight must have been !!
                        //			\		 +
                        //	 C.usave \ C.uL + C.uR
                        //   ---------*----+- - - -
                        //			NL    +   NR
                        trNewLeft.uR = trCurrent.uL; // setAbove; first uR !!!
                        trNewLeft.uL = trCurrent.usave;
                        trNewLeft.uL.dL = trNewLeft; // setBelow; dR == null, unchanged
                        trNewLeft.uR.dR = trNewLeft; // setBelow; dL == null, unchanged
                    }
                    trNewLeft.usave = trNewRight.usave = null;
                } else if (trCurrent.vHigh == trFirst.vHigh) {
                    // && meetsHighAdjSeg ??? TODO
                    //	*** Case: CC_2UN_CONN; prev: ----
                    // console.log( "continue_chain_from_above: 2 upper neighbors, fresh seg, continues high adjacent seg" );
                    // !! trNewLeft and trNewRight cannot have been extended from above !!
                    //	  C.uL	 /  C.uR
                    //   -------*---------
                    //	   NL  +	NR
                    trNewRight.uR.dR = trNewRight; // setBelow; dL == null, unchanged
                    trNewLeft.uR = trNewRight.uL = null; // setAbove; trNewLeft.uL, trNewRight.uR unchanged
                } else {
                    //	*** Case: CC_2UN; prev: 1B_1UN_CONT, 2B_NOCON_RIGHT/LEFT, 2B_TOUCH_RIGHT/LEFT, 2B_COLIN_RIGHT/LEFT
                    // console.log( "continue_chain_from_above: simple case, 2 upper neighbors (no usave, not fresh seg)" );
                    // !! trNewLeft XOR trNewRight will have been extended from above !!
                    //	  C.uL	 +  C.uR
                    //   -------+---------
                    //	   NL  +	NR
                    if (trNewRight == trCurrent) {
                        // trNewLeft has been extended from above
                        // setAbove
                        trNewRight.uL = trNewRight.uR;
                        trNewRight.uR = null;
                        // setBelow; dR: unchanged, is NOT always null (prev: 2B_NOCON_LEFT, 2B_TOUCH_LEFT, 2B_COLIN_LEFT)
                        trNewRight.uL.dL = trNewRight;
                    } else {
                        // trNewRight has been extended from above
                        trNewLeft.uR = trNewLeft.uL; // setAbove; first uR !!!
                        trNewLeft.uL = null;
                    }
                }
            }

            // functions handling the relationship to the lower neighbors (dL, dR)
            //	of trNewLeft and trNewRight
            // trNewLeft or trNewRight MIGHT have been extended from above
            //  !! in that case dL and dR are different from trCurrent and MUST be set here !!

            function only_one_trap_below(inTrNext) {
                if (trCurrent.vLow == trLast.vLow) {
                    // final part of segment

                    if (meetsLowAdjSeg) {
                        // downward cusp: bottom forms a triangle

                        // ATTENTION: the decision whether trNewLeft and trNewRight are to the
                        //	left or right of the already inserted segment the new one meets here
                        //	has already been taken when selecting trLast to the left or right
                        //	of that already inserted segment !!

                        if (trCurrent.dL) {
                            //	*** Case: 1B_DC_LEFT; next: ----
                            // console.log( "only_one_trap_below: downward cusp, new seg from the left!" );
                            //		+		/
                            //		 +  NR /
                            //	  NL  +	  /
                            //		   + /
                            //   -------*-------
                            //	   C.dL = next

                            // setAbove
                            inTrNext.uL = trNewLeft; // uR: unchanged, NEVER null
                            // setBelow part 1
                            trNewLeft.dL = inTrNext;
                            trNewRight.dR = null;
                        } else {
                            //	*** Case: 1B_DC_RIGHT; next: ----
                            // console.log( "only_one_trap_below: downward cusp, new seg to the right!" );
                            //		\		+
                            //		 \  NL +
                            //		  \	  +  NR
                            //		   \ +
                            //   -------*-------
                            //	   C.dR = next

                            // setAbove
                            inTrNext.uR = trNewRight; // uL: unchanged, NEVER null
                            // setBelow part 1
                            trNewLeft.dL = null;
                            trNewRight.dR = inTrNext;
                        }
                    } else {
                        //	*** Case: 1B_1UN_END; next: ----
                        // console.log( "only_one_trap_below: simple case, new seg ends here, low adjacent seg still missing" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //   ------*-------
                        //		  next

                        // setAbove
                        inTrNext.uL = trNewLeft; // trNewLeft must
                        inTrNext.uR = trNewRight; // must
                        // setBelow part 1
                        trNewLeft.dL = trNewRight.dR = inTrNext; // Error
                        //					trNewRight.dR = inTrNext;
                    }
                    // setBelow part 2
                    trNewLeft.dR = trNewRight.dL = null;
                } else {
                    // NOT final part of segment

                    if (inTrNext.uL && inTrNext.uR) {
                        // inTrNext has two upper neighbors
                        // => a segment ends on the upper Y-line of inTrNext
                        // => inTrNext has temporarily 3 upper neighbors
                        // => marks whether the new segment cuts through
                        //		uL or uR of inTrNext and saves the other in .usave
                        if (inTrNext.uL == trCurrent) {
                            //	*** Case: 1B_3UN_LEFT; next: CC_3UN_LEFT
                            // console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): u0a, u0b, uR(usave)" );
                            //		 +		  /
                            //	  NL  +	 NR	 /
                            //		   +	/
                            //   - - - -+--*----
                            //			 +
                            //		  next
                            //						if ( inTrNext.uR != trNewRight ) {		// for robustness	TODO: prevent
                            inTrNext.usave = inTrNext.uR;
                            inTrNext.uleft = true;
                            // trNewLeft: L/R undefined, will be extended down and changed anyway
                            // } else {
                            // ERROR: should not happen
                            // console.log( "ERR add_segment: Trapezoid Loop right", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
                            //						}
                        } else {
                            //	*** Case: 1B_3UN_RIGHT; next: CC_3UN_RIGHT
                            // console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): uL(usave), u1a, u1b" );
                            //	 \		   +
                            //	  \	  NL  +  NR
                            //	   \	 +
                            //   ---*---+- - - -
                            //		   +
                            //		  next
                            //						if ( inTrNext.uL != trNewLeft ) {		// for robustness	TODO: prevent
                            inTrNext.usave = inTrNext.uL;
                            inTrNext.uleft = false;
                            // trNewRight: L/R undefined, will be extended down and changed anyway
                            // } else {
                            // ERROR: should not happen
                            // console.log( "ERR add_segment: Trapezoid Loop left", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
                            //						}
                        }
                        //} else {
                        //	*** Case: 1B_1UN_CONT; next: CC_2UN
                        // console.log( "only_one_trap_below: simple case, new seg continues down" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //   ------+-------
                        //	 	  +
                        //		next

                        // L/R for one side undefined, which one is not fixed
                        //	but that one will be extended down and changed anyway
                        // for the other side, vLow must lie at the opposite end
                        //	thus both are set accordingly
                    }
                    // setAbove
                    inTrNext.uL = trNewLeft;
                    inTrNext.uR = trNewRight;
                    // setBelow
                    trNewLeft.dR = trNewRight.dL = inTrNext;
                    trNewLeft.dL = trNewRight.dR = null;
                }
            }

            function two_trap_below() {
                // Find out which one (dL,dR) is intersected by this segment and
                //	continue down that one
                var trNext;
                if (trCurrent.vLow == trLast.vLow && meetsLowAdjSeg) {
                    // meetsLowAdjSeg necessary? TODO
                    //	*** Case: 2B_CON_END; next: ----
                    // console.log( "two_trap_below: finished, meets low adjacent segment" );
                    //			  +
                    //		NL	 +  NR
                    //			+
                    //   ------*-------
                    //	 		\  C.dR
                    //	  C.dL	 \

                    // setAbove
                    trCurrent.dL.uL = trNewLeft;
                    trCurrent.dR.uR = trNewRight;
                    // setBelow; sequence of assignments essential, just in case: trCurrent == trNewLeft
                    trNewLeft.dL = trCurrent.dL;
                    trNewRight.dR = trCurrent.dR;
                    trNewLeft.dR = trNewRight.dL = null;

                    trNext = null; // segment finished
                } else {
                    // setAbove part 1
                    trCurrent.dL.uL = trNewLeft;
                    trCurrent.dR.uR = trNewRight;

                    var goDownRight;
                    // passes left or right of an already inserted NOT connected segment
                    //	trCurrent.vLow: high-end of existing segment
                    var compRes = scope.is_left_of(
                        inSegment,
                        trCurrent.vLow,
                        true
                    );
                    if (compRes > 0) {
                        // trCurrent.vLow is left of inSegment
                        //	*** Case: 2B_NOCON_RIGHT; next: CC_2UN
                        // console.log( "two_trap_below: (intersecting dR)" );
                        //		 +
                        //	  NL  +  NR
                        //		   +
                        //   ---*---+- - - -
                        //		 \	 +
                        //	 C.dL \	C.dR
                        goDownRight = true;
                    } else if (compRes < 0) {
                        // trCurrent.vLow is right of inSegment
                        //	*** Case: 2B_NOCON_LEFT; next: CC_2UN
                        // console.log( "two_trap_below: (intersecting dL)" );
                        //			  +
                        //		NL	 +  NR
                        //			+
                        //    - - -+---*-------
                        //	 	  +		\  C.dR
                        //	 	 C.dL	 \
                        goDownRight = false;
                    } else {
                        // trCurrent.vLow lies ON inSegment
                        var vLowSeg = trCurrent.dL.rseg;
                        var directionIsUp = vLowSeg.upward;
                        var otherPt = directionIsUp
                            ? vLowSeg.vFrom
                            : vLowSeg.vTo;
                        compRes = scope.is_left_of(inSegment, otherPt, false);
                        if (compRes > 0) {
                            // otherPt is left of inSegment
                            //	*** Case: 2B_TOUCH_RIGHT; next: CC_2UN
                            // console.log( "two_trap_below: vLow ON new segment, touching from right" );
                            //		 +
                            //	  NL  +  NR
                            //		   +
                            //   -------*- - - -
                            //		   / +
                            //	 C.dL /	C.dR
                            goDownRight = true; // like intersecting dR
                        } else if (compRes < 0) {
                            // otherPt is right of inSegment
                            //	*** Case: 2B_TOUCH_LEFT; next: CC_2UN
                            // console.log( "two_trap_below: vLow ON new segment, touching from left" );
                            //			  +
                            //		NL	 +  NR
                            //			+
                            //    - - -*-------
                            //	 	  +	\  C.dR
                            //	  C.dL	 \
                            goDownRight = false; // like intersecting dL
                        } else {
                            // otherPt lies ON inSegment
                            vLowSeg = directionIsUp
                                ? vLowSeg.snext
                                : vLowSeg.sprev; // other segment with trCurrent.vLow
                            otherPt = directionIsUp
                                ? vLowSeg.vTo
                                : vLowSeg.vFrom;
                            compRes = scope.is_left_of(
                                inSegment,
                                otherPt,
                                false
                            );
                            if (compRes > 0) {
                                // otherPt is left of inSegment
                                //	*** Case: 2B_COLIN_RIGHT; next: CC_2UN
                                // console.log( "two_trap_below: vLow ON new segment, touching from right" );
                                //		  +
                                //	  NL   +  NR
                                //   -------*- - - -
                                //	  C.dL 	\+  C.dR
                                //			 \+
                                goDownRight = true; // like intersecting dR
                                //	} else if ( compRes == 0 ) {		//	NOT POSSIBLE, since 3 points on a line is prevented during input of polychains
                                //		goDownRight = true;		// like intersecting dR
                            } else {
                                // otherPt is right of inSegment
                                //	*** Case: 2B_COLIN_LEFT; next: CC_2UN
                                // console.log( "two_trap_below: vLow ON new segment, touching from left" );
                                //			   +
                                //		NL	  +  NR
                                //    - - - -*-------
                                //	  C.dL	+/  C.dR
                                //		   +/
                                goDownRight = false; // TODO: for test_add_segment_special_4 -> like intersecting dL
                            }
                        }
                    }
                    if (goDownRight) {
                        trNext = trCurrent.dR;
                        // setAbove part 2
                        trCurrent.dR.uL = trNewLeft;
                        // setBelow part 1
                        trNewLeft.dL = trCurrent.dL;
                        trNewRight.dR = null; // L/R undefined, will be extended down and changed anyway
                    } else {
                        trNext = trCurrent.dL;
                        // setAbove part 2
                        trCurrent.dL.uR = trNewRight;
                        // setBelow part 1
                        trNewRight.dR = trCurrent.dR;
                        trNewLeft.dL = null; // L/R undefined, will be extended down and changed anyway
                    }
                    // setBelow part 2
                    trNewLeft.dR = trNewRight.dL = trNext;
                }

                return trNext;
            }

            //
            //	main function body
            //

            /*		if ( ( inSegment.sprev.vTo != inSegment.vFrom ) || ( inSegment.vTo != inSegment.snext.vFrom ) ) {
			console.log( "add_segment: inconsistent point order of adjacent segments: ",
						 inSegment.sprev.vTo, inSegment.vFrom, inSegment.vTo, inSegment.snext.vFrom );
			return;
		}		*/

            //	Find the top-most and bottom-most intersecting trapezoids -> rootXXX
            this.segNodes(inSegment);

            var segLowVert, segLowNode, meetsLowAdjSeg; // y-min vertex
            var segHighVert, segHighNode, meetsHighAdjSeg; // y-max vertex

            if (inSegment.upward) {
                segLowVert = inSegment.vFrom;
                segHighVert = inSegment.vTo;
                segLowNode = inSegment.rootFrom;
                segHighNode = inSegment.rootTo;
                // was lower point already inserted earlier? => segments meet at their ends
                meetsLowAdjSeg = inSegment.sprev.is_inserted;
                // was higher point already inserted earlier? => segments meet at their ends
                meetsHighAdjSeg = inSegment.snext.is_inserted;
            } else {
                segLowVert = inSegment.vTo;
                segHighVert = inSegment.vFrom;
                segLowNode = inSegment.rootTo;
                segHighNode = inSegment.rootFrom;
                meetsLowAdjSeg = inSegment.snext.is_inserted;
                meetsHighAdjSeg = inSegment.sprev.is_inserted;
            }

            //	insert higher vertex into QueryStructure
            if (!meetsHighAdjSeg) {
                // higher vertex not yet inserted => split trapezoid horizontally
                var tmpNode = this.splitNodeAtPoint(
                    segHighNode,
                    segHighVert,
                    false
                );
                // move segLowNode to new (lower) trapezoid, if it was the one which was just split
                if (segHighNode == segLowNode) segLowNode = tmpNode;
                segHighNode = tmpNode;
            }
            var trFirst = segHighNode.trap; // top-most trapezoid for this segment

            // check for robustness		// TODO: prevent
            if (!trFirst.uL && !trFirst.uR) {
                console.log("ERR add_segment: missing trFirst.uX: ", trFirst);
                return;
            }
            if (trFirst.vHigh != segHighVert) {
                console.log(
                    "ERR add_segment: trFirstHigh != segHigh: ",
                    trFirst
                );
                return;
            }

            //	insert lower vertex into QueryStructure
            if (!meetsLowAdjSeg) {
                // lower vertex not yet inserted => split trapezoid horizontally
                segLowNode = this.splitNodeAtPoint(
                    segLowNode,
                    segLowVert,
                    true
                );
            }
            var trLast = segLowNode.trap; // bottom-most trapezoid for this segment

            //
            // Thread the segment into the query "tree" from top to bottom.
            // All the trapezoids which are intersected by inSegment are "split" into two.
            // For each the SINK-QsNode is converted into an X-Node and
            //  new sinks for the new partial trapezoids are added.
            // In fact a real split only happens at the top and/or bottom end of the segment
            //	since at every y-line seperating two trapezoids is traverses it
            //	cuts off the "beam" from the y-vertex on one side, so that at that side
            //	the trapezoid from above can be extended down.
            //

            var trCurrent = trFirst;

            var trNewLeft, trNewRight, trPrevLeft, trPrevRight;

            var counter = this.trapArray.length + 2; // just to prevent infinite loop
            var trNext;
            while (trCurrent) {
                if (--counter < 0) {
                    console.log(
                        "ERR add_segment: infinite loop",
                        trCurrent,
                        inSegment,
                        this
                    );
                    return;
                }
                if (!trCurrent.dL && !trCurrent.dR) {
                    // ERROR: no successors, cannot arise if data is correct
                    console.log(
                        "ERR add_segment: missing successors",
                        trCurrent,
                        inSegment,
                        this
                    );
                    return;
                }

                var qs_trCurrent = trCurrent.sink;
                // SINK-Node -> X-Node
                qs_trCurrent.seg = inSegment;
                qs_trCurrent.trap = null;
                //
                // successive trapezoids bordered by the same segments are merged
                //  by extending the trPrevRight or trPrevLeft down
                //  and redirecting the parent X-Node to the extended sink
                // !!! destroys tree structure since several nodes now point to the same SINK-Node !!!
                // TODO: maybe it's not a problem;
                //  merging of X-Nodes is no option, since they are used as "rootFrom/rootTo" !
                //
                if (trPrevRight && trPrevRight.rseg == trCurrent.rseg) {
                    // console.log( "add_segment: extending right predecessor down!", trPrevRight );
                    trNewLeft = trCurrent;
                    trNewRight = trPrevRight;
                    trNewRight.vLow = trCurrent.vLow;
                    // redirect parent X-Node to extended sink
                    qs_trCurrent.left = new PNLTRI.QsNode(trNewLeft); // trCurrent -> left SINK-Node
                    qs_trCurrent.right = trPrevRight.sink; // deforms tree by multiple links to trPrevRight.sink
                } else if (trPrevLeft && trPrevLeft.lseg == trCurrent.lseg) {
                    // console.log( "add_segment: extending left predecessor down!", trPrevLeft );
                    trNewRight = trCurrent;
                    trNewLeft = trPrevLeft;
                    trNewLeft.vLow = trCurrent.vLow;
                    // redirect parent X-Node to extended sink
                    qs_trCurrent.left = trPrevLeft.sink; // deforms tree by multiple links to trPrevLeft.sink
                    qs_trCurrent.right = new PNLTRI.QsNode(trNewRight); // trCurrent -> right SINK-Node
                } else {
                    trNewLeft = trCurrent;
                    trNewRight = this.cloneTrap(trCurrent);
                    qs_trCurrent.left = new PNLTRI.QsNode(trNewLeft); // trCurrent -> left SINK-Node
                    qs_trCurrent.right = new PNLTRI.QsNode(trNewRight); // new clone -> right SINK-Node
                }

                // handle neighbors above
                if (trCurrent.uL && trCurrent.uR) {
                    continue_chain_from_above();
                } else {
                    fresh_seg_or_upward_cusp();
                }

                // handle neighbors below
                if (trCurrent.dL && trCurrent.dR) {
                    trNext = two_trap_below();
                } else {
                    if (trCurrent.dL) {
                        // console.log( "add_segment: only_one_trap_below! (dL)" );
                        trNext = trCurrent.dL;
                    } else {
                        // console.log( "add_segment: only_one_trap_below! (dR)" );
                        trNext = trCurrent.dR;
                    }
                    only_one_trap_below(trNext);
                }

                if (trNewLeft.rseg) trNewLeft.rseg.trLeft = trNewRight;
                if (trNewRight.lseg) trNewRight.lseg.trRight = trNewLeft;
                trNewLeft.rseg = trNewRight.lseg = inSegment;
                inSegment.trLeft = trNewLeft;
                inSegment.trRight = trNewRight;

                // further loop-step down ?
                if (trCurrent.vLow != trLast.vLow) {
                    trPrevLeft = trNewLeft;
                    trPrevRight = trNewRight;

                    trCurrent = trNext;
                } else {
                    trCurrent = null;
                }
            } // end while

            inSegment.is_inserted = true;
            // console.log( "add_segment: ###### DONE ######" );
        },

        // Assigns a depth to all trapezoids;
        //	0: outside, 1: main polygon, 2: holes, 3:polygons in holes, ...
        // Checks segment orientation and marks those polygon chains for reversal
        //	where the polygon inside lies to their right (contour in CW, holes in CCW)
        assignDepths: function(inPolyData) {
            var thisDepth = [this.trapArray[0]];
            var nextDepth = [];

            var thisTrap,
                borderSeg,
                curDepth = 0;
            do {
                // rseg should exactely go upward on trapezoids inside the polygon (odd depth)
                var expectedRsegUpward = curDepth % 2 == 1;
                while ((thisTrap = thisDepth.pop())) {
                    // assignment !
                    if (thisTrap.depth != -1) continue;
                    thisTrap.depth = curDepth;
                    //
                    if (thisTrap.uL) thisDepth.push(thisTrap.uL);
                    if (thisTrap.uR) thisDepth.push(thisTrap.uR);
                    if (thisTrap.dL) thisDepth.push(thisTrap.dL);
                    if (thisTrap.dR) thisDepth.push(thisTrap.dR);
                    //
                    if (
                        (borderSeg = thisTrap.lseg) &&
                        borderSeg.trLeft.depth == -1
                    )
                        // assignment !
                        nextDepth.push(borderSeg.trLeft);
                    if ((borderSeg = thisTrap.rseg)) {
                        // assignment !
                        if (borderSeg.trRight.depth == -1)
                            nextDepth.push(borderSeg.trRight);
                        if (borderSeg.upward != expectedRsegUpward)
                            inPolyData.set_PolyLeft_wrong(borderSeg.chainId);
                    }
                }
                thisDepth = nextDepth;
                nextDepth = [];
                curDepth++;
            } while (thisDepth.length > 0);
        },

        // creates the visibility map:
        //	for each vertex the list of all vertices in CW order which are directly
        //	visible through neighboring trapezoids and thus can be connected by a diagonal

        create_visibility_map: function(inPolygonData) {
            // positional slots for neighboring trapezoid-diagonals
            var DIAG_UL = 0,
                DIAG_UM = 1,
                DIAG_ULR = 2,
                DIAG_UR = 3;
            var DIAG_DR = 4,
                DIAG_DM = 5,
                DIAG_DLR = 6,
                DIAG_DL = 7;

            var i, j;
            var nbVertices = inPolygonData.nbVertices();

            // initialize arrays for neighboring trapezoid-diagonals and vertices
            var myVisibleDiagonals = new Array(nbVertices);
            for (i = 0; i < nbVertices; i++) {
                myVisibleDiagonals[i] = new Array(DIAG_DL + 1);
            }
            // create the list of neighboring trapezoid-diagonals
            //	put into their positional slots
            var myExternalNeighbors = new Array(nbVertices);
            for (i = 0, j = this.trapArray.length; i < j; i++) {
                var curTrap = this.trapArray[i];
                var highPos = curTrap.uL
                    ? curTrap.uR
                        ? DIAG_DM
                        : DIAG_DL
                    : curTrap.uR
                        ? DIAG_DR
                        : DIAG_DLR;
                var lowPos = curTrap.dL
                    ? curTrap.dR
                        ? DIAG_UM
                        : DIAG_UL
                    : curTrap.dR
                        ? DIAG_UR
                        : DIAG_ULR;

                if (curTrap.depth % 2 == 1) {
                    // inside ?
                    if (
                        highPos == DIAG_DM ||
                        lowPos == DIAG_UM ||
                        (highPos == DIAG_DL && lowPos == DIAG_UR) ||
                        (highPos == DIAG_DR && lowPos == DIAG_UL)
                    ) {
                        var lhDiag = inPolygonData.appendDiagonalsEntry({
                            vFrom: curTrap.vLow,
                            vTo: curTrap.vHigh,
                            mprev: null,
                            mnext: null,
                            marked: false
                        });
                        var hlDiag = inPolygonData.appendDiagonalsEntry({
                            vFrom: curTrap.vHigh,
                            vTo: curTrap.vLow,
                            revDiag: lhDiag,
                            mprev: null,
                            mnext: null,
                            marked: false
                        });
                        lhDiag.revDiag = hlDiag;
                        myVisibleDiagonals[curTrap.vLow.id][lowPos] = lhDiag;
                        myVisibleDiagonals[curTrap.vHigh.id][highPos] = hlDiag;
                    }
                } else {
                    // outside, hole
                    if (curTrap.vHigh.id !== null)
                        myExternalNeighbors[curTrap.vHigh.id] = highPos;
                    if (curTrap.vLow.id !== null)
                        myExternalNeighbors[curTrap.vLow.id] = lowPos;
                }
            }
            // create the list of outgoing diagonals in the right order (CW)
            //	from the ordered list of neighboring trapezoid-diagonals
            //	- starting from an external one
            // and connect those incoming to
            var curDiag, curDiags, firstElem, fromVertex, lastIncoming;
            for (i = 0; i < nbVertices; i++) {
                curDiags = myVisibleDiagonals[i];
                firstElem = myExternalNeighbors[i];
                if (firstElem == null) continue; // eg. skipped vertices (zero length, co-linear		// NOT: === !
                j = firstElem;
                lastIncoming = null;
                do {
                    if (j++ > DIAG_DL) j = DIAG_UL; // circular positional list
                    if ((curDiag = curDiags[j])) {
                        if (lastIncoming) {
                            curDiag.mprev = lastIncoming;
                            lastIncoming.mnext = curDiag;
                        } else {
                            fromVertex = curDiag.vFrom;
                            fromVertex.firstOutDiag = curDiag;
                        }
                        lastIncoming = curDiag.revDiag;
                    }
                } while (j != firstElem);
                if (lastIncoming) fromVertex.lastInDiag = lastIncoming;
            }
        }
    };

    /*==============================================================================
 *
 *============================================================================*/

    PNLTRI.Trapezoider = function(inPolygonData) {
        this.polyData = inPolygonData;
        this.queryStructure = new PNLTRI.QueryStructure(this.polyData);
    };

    PNLTRI.Trapezoider.prototype = {
        constructor: PNLTRI.Trapezoider,

        /*
	 * Mathematics helper methods
	 */

        optimise_randomlist: function(inOutSegListArray) {
            // makes sure that the first N segments are one from each of the N polygon chains
            var mainIdx = 0;
            var helpIdx = this.polyData.nbPolyChains();
            if (helpIdx == 1) return;
            var chainMarker = new Array(helpIdx);
            var oldSegListArray = inOutSegListArray.concat();
            for (var i = 0; i < oldSegListArray.length; i++) {
                var chainId = oldSegListArray[i].chainId;
                if (chainMarker[chainId]) {
                    inOutSegListArray[helpIdx++] = oldSegListArray[i];
                } else {
                    inOutSegListArray[mainIdx++] = oldSegListArray[i];
                    chainMarker[chainId] = true;
                }
            }
        },

        /*
	 * main methods
	 */

        // Creates the trapezoidation of the polygon
        //  and assigns a depth to all trapezoids (odd: inside, even: outside).

        trapezoide_polygon: function() {
            // <<<< public
            var randSegListArray = this.polyData.getSegments().concat();
            //		console.log( "Polygon Chains: ", dumpSegmentList( randSegListArray ) );
            PNLTRI.Math.array_shuffle(randSegListArray);
            this.optimise_randomlist(randSegListArray);
            //		console.log( "Random Segment Sequence: ", dumpRandomSequence( randSegListArray ) );

            var nbSegs = randSegListArray.length;
            var myQs = this.queryStructure;

            var i,
                current = 0,
                logstar = nbSegs;
            while (current < nbSegs) {
                // The CENTRAL mechanism for the near-linear performance:
                //	stratefies the loop through all segments into log* parts
                //	and computes new root-Nodes for the remaining segments in each
                //	partition.
                logstar = Math.log(logstar) / Math.LN2; // == log2(logstar)
                var partEnd =
                    logstar > 1 ? Math.floor(nbSegs / logstar) : nbSegs;

                // Core: adds next partition of the segments
                for (; current < partEnd; current++) {
                    myQs.add_segment(randSegListArray[current]);
                }
                //			console.log( nbSegs, current );

                // To speed up the segment insertion into the trapezoidation
                //	the endponts of those segments not yet inserted
                //	are repeatedly pre-located,
                // thus their final location-query can start at the top of the
                //	appropriate sub-tree instead of the root of the whole
                //	query structure.
                //
                for (i = current; i < nbSegs; i++) {
                    this.queryStructure.segNodes(randSegListArray[i]);
                }
            }

            myQs.assignDepths(this.polyData);
            // cleanup to support garbage collection
            for (i = 0; i < nbSegs; i++) {
                randSegListArray[i].trLeft = randSegListArray[i].trRight = null;
            }
        },

        // Creates a visibility map:
        //	for each vertex the list of all vertices in CW order which are directly
        //	visible through neighboring trapezoids and thus can be connected by a diagonal

        create_visibility_map: function() {
            return this.queryStructure.create_visibility_map(this.polyData);
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to split a polygon into uni-y-monotone sub-polygons
     *
     *	1) creates a trapezoidation of the main polygon according to Seidel's
     *	   algorithm [Sei91]
     *	2) uses diagonals of the trapezoids as additional segments
     *		to split the main polygon into uni-y-monotone sub-polygons
     */

    PNLTRI.MonoSplitter = function(inPolygonData) {
        this.polyData = inPolygonData;

        this.trapezoider = null;
    };

    PNLTRI.MonoSplitter.prototype = {
        constructor: PNLTRI.MonoSplitter,

        monotonate_trapezoids: function() {
            // <<<<<<<<<< public
            // Trapezoidation
            this.trapezoider = new PNLTRI.Trapezoider(this.polyData);
            //	=> one triangular trapezoid which lies inside the polygon
            this.trapezoider.trapezoide_polygon();

            // create segments for diagonals
            this.trapezoider.create_visibility_map();
            // create mono chains by inserting diagonals
            this.polyData.create_mono_chains();

            // create UNIQUE monotone sub-polygons
            this.polyData.unique_monotone_chains_max();
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     *
     *	Algorithm to triangulate uni-y-monotone polygons [FoM84]
     *
     *	expects list of doubly linked monoChains, with Y-max as first vertex
     */

    PNLTRI.MonoTriangulator = function(inPolygonData) {
        this.polyData = inPolygonData;
    };

    PNLTRI.MonoTriangulator.prototype = {
        constructor: PNLTRI.MonoTriangulator,

        // Pass each uni-y-monotone polygon with start at Y-max for greedy triangulation.

        triangulate_all_polygons: function() {
            // <<<<<<<<<< public
            var normedMonoChains = this.polyData.getMonoSubPolys();
            this.polyData.clearTriangles();
            for (var i = 0; i < normedMonoChains.length; i++) {
                // loop through uni-y-monotone chains
                // => monoPosmin is next to monoPosmax (left or right)
                var monoPosmax = normedMonoChains[i];
                var prevMono = monoPosmax.mprev;
                var nextMono = monoPosmax.mnext;

                if (nextMono.mnext == prevMono) {
                    // already a triangle
                    this.polyData.addTriangle(
                        monoPosmax.vFrom,
                        nextMono.vFrom,
                        prevMono.vFrom
                    );
                } else {
                    // triangulate the polygon
                    this.triangulate_monotone_polygon(monoPosmax);
                }
            }
        },

        //	algorithm to triangulate an uni-y-monotone polygon in O(n) time.[FoM84]

        triangulate_monotone_polygon: function(monoPosmax) {
            // private
            var scope = this;

            function error_cleanup() {
                // Error in algorithm OR polygon is not uni-y-monotone
                console.log(
                    "ERR uni-y-monotone: only concave angles left",
                    vertBackLog
                );
                // push all "wrong" triangles => loop ends
                while (vertBackLogIdx > 1) {
                    vertBackLogIdx--;
                    scope.polyData.addTriangle(
                        vertBackLog[vertBackLogIdx - 1],
                        vertBackLog[vertBackLogIdx],
                        vertBackLog[vertBackLogIdx + 1]
                    );
                }
            }

            //
            // Decisive for this algorithm to work correctly is to make sure
            //  the polygon stays uni-y-monotone when cutting off ears, i.e.
            //  to make sure the top-most and bottom-most vertices are removed last
            // Usually this is done by handling the LHS-case ("LeftHandSide is a single segment")
            //	and the RHS-case ("RightHandSide segment is a single segment")
            //	differently by starting at the bottom for LHS and at the top for RHS.
            // This is not necessary. It can be seen easily, that starting
            //	from the vertex next to top handles both cases correctly.
            //

            var frontMono = monoPosmax.mnext; // == LHS: YminPoint; RHS: YmaxPoint.mnext
            var endVert = monoPosmax.vFrom;

            var vertBackLog = [frontMono.vFrom];
            var vertBackLogIdx = 0;

            frontMono = frontMono.mnext;
            var frontVert = frontMono.vFrom;

            // check for robustness		// TODO
            if (frontVert == endVert) return; // Error: only 2 vertices

            while (frontVert != endVert || vertBackLogIdx > 1) {
                if (vertBackLogIdx > 0) {
                    // vertBackLog is not empty
                    var insideAngleCCW = PNLTRI.Math.ptsCrossProd(
                        vertBackLog[vertBackLogIdx],
                        frontVert,
                        vertBackLog[vertBackLogIdx - 1]
                    );
                    if (Math.abs(insideAngleCCW) <= PNLTRI.Math.EPSILON_P) {
                        // co-linear
                        if (
                            frontVert == endVert || // all remaining triangles are co-linear (180 degree)
                            PNLTRI.Math.compare_pts_yx(
                                vertBackLog[vertBackLogIdx],
                                frontVert
                            ) == // co-linear-reversal
                                PNLTRI.Math.compare_pts_yx(
                                    vertBackLog[vertBackLogIdx],
                                    vertBackLog[vertBackLogIdx - 1]
                                )
                        ) {
                            insideAngleCCW = 1; // => create triangle
                        }
                    }
                    if (insideAngleCCW > 0) {
                        // convex corner: cut if off
                        this.polyData.addTriangle(
                            vertBackLog[vertBackLogIdx - 1],
                            vertBackLog[vertBackLogIdx],
                            frontVert
                        );
                        vertBackLogIdx--;
                    } else {
                        // non-convex: add frontVert to the vertBackLog
                        vertBackLog[++vertBackLogIdx] = frontVert;
                        if (frontVert == endVert) error_cleanup();
                        // should never happen !!
                        else {
                            frontMono = frontMono.mnext;
                            frontVert = frontMono.vFrom;
                        }
                    }
                } else {
                    // vertBackLog contains only start vertex:
                    //	add frontVert to the vertBackLog and advance frontVert
                    vertBackLog[++vertBackLogIdx] = frontVert;
                    frontMono = frontMono.mnext;
                    frontVert = frontMono.vFrom;
                }
            }
            // reached the last vertex. Add in the triangle formed
            this.polyData.addTriangle(
                vertBackLog[vertBackLogIdx - 1],
                vertBackLog[vertBackLogIdx],
                frontVert
            );
        }
    };

    /**
     * @author jahting / http://www.ameco.tv/
     */

    /*******************************************************************************
     *
     *	Triangulator for Simple Polygons with Holes
     *
     *  polygon with holes:
     *	- one closed contour polygon chain
     *  - zero or more closed hole polygon chains
     *
     *	polygon chain (closed):
     *	- Array of vertex Objects with attributes "x" and "y"
     *		- representing the sequence of line segments
     *		- closing line segment (last->first vertex) is implied
     *		- line segments are non-zero length and non-crossing
     *
     *	"global vertex index":
     *	- vertex number resulting from concatenation all polygon chains (starts with 0)
     *
     *
     *	Parameters (will not be changed):
     *		inPolygonChains:
     *		- Array of polygon chains
     *
     *	Results (are a fresh copy):
     *		triangulate_polygon:
     *		- Array of Triangles ( Array of 3 "global vertex index" values )
     *
     ******************************************************************************/

    PNLTRI.Triangulator = function() {
        this.lastPolyData = null; // for Debug purposes only
    };

    PNLTRI.Triangulator.prototype = {
        constructor: PNLTRI.Triangulator,

        clear_lastData: function() {
            // save memory after Debug
            this.lastPolyData = null;
        },

        // for the polygon data AFTER triangulation
        //	returns an Array of flags, one flag for each polygon chain:
        //		lies the inside of the polygon to the left?
        //		"true" implies CCW for contours and CW for holes
        get_PolyLeftArr: function() {
            if (this.lastPolyData) return this.lastPolyData.get_PolyLeftArr();
            return null;
        },

        triangulate_polygon: function(inPolygonChains, inForceTrapezoidation) {
            // collected conditions for selecting EarClipTriangulator over Seidel's algorithm
            function is_basic_polygon() {
                if (inForceTrapezoidation) return false;
                return myPolygonData.nbPolyChains() == 1;
            }

            this.clear_lastData();
            if (!inPolygonChains || inPolygonChains.length === 0) return [];
            //
            // initializes general polygon data structure
            //
            var myPolygonData = new PNLTRI.PolygonData(inPolygonChains);
            //
            var basicPolygon = is_basic_polygon();
            var myTriangulator;
            if (basicPolygon) {
                //
                // triangulates single polygon without holes
                //
                myTriangulator = new PNLTRI.EarClipTriangulator(myPolygonData);
                basicPolygon = myTriangulator.triangulate_polygon_no_holes();
            }
            if (!basicPolygon) {
                //
                // splits polygon into uni-y-monotone sub-polygons
                //
                var myMonoSplitter = new PNLTRI.MonoSplitter(myPolygonData);
                myMonoSplitter.monotonate_trapezoids();
                //
                // triangulates all uni-y-monotone sub-polygons
                //
                myTriangulator = new PNLTRI.MonoTriangulator(myPolygonData);
                myTriangulator.triangulate_all_polygons();
            }
            //
            this.lastPolyData = myPolygonData;
            return myPolygonData.getTriangles(); // copy of triangle list
        }
    };

    return PNLTRI;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/PolygonRenderer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "./VectorRenderer",
    "./RendererManager",
    "./FeatureStyle",
    "./Program",
    "./BatchRenderable",
    "./pnltri",
    "./GeoBound"
], function(
    Constants,
    Utils,
    VectorRenderer,
    RendererManager,
    FeatureStyle,
    Program,
    BatchRenderable,
    PNLTRI,
    GeoBound
) {
    /**************************************************************************************************************/
    /**
         @name PolygonRenderer
         @class
             Basic renderer for polygon
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PolygonRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;
        this.renderContext = globe.renderContext;
        this.defaultVertexShader = "attribute vec3 vertex;\n";
        this.defaultVertexShader += "uniform mat4 mvp;\n";
        this.defaultVertexShader += "void main(void) \n";
        this.defaultVertexShader += "{\n";
        this.defaultVertexShader += "	gl_Position = mvp * vec4(vertex, 1.0);\n";
        this.defaultVertexShader += "}\n";

        this.extrudeVertexShader = "attribute vec3 vertex;\n";
        this.extrudeVertexShader += "attribute vec4 normal;\n";
        this.extrudeVertexShader += "uniform float extrusionScale; \n";
        this.extrudeVertexShader += "uniform mat4 mvp;\n";
        this.extrudeVertexShader += "void main(void) \n";
        this.extrudeVertexShader += "{\n";
        this.extrudeVertexShader +=
            "	vec3 extrudedVertex = vertex + normal.w * vec3(normal.x, normal.y, normal.z) * extrusionScale;";
        this.extrudeVertexShader +=
            "	gl_Position = mvp * vec4(extrudedVertex, 1.0);\n";
        this.extrudeVertexShader += "}\n";

        this.fragmentShader = "precision lowp float; \n";
        this.fragmentShader += "uniform vec4 u_color;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader += "	gl_FragColor = u_color;\n";
        this.fragmentShader += "	//if (u_color.a == 0.0) discard;\n";
        this.fragmentShader += "}\n";

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(
            this.defaultVertexShader,
            this.fragmentShader
        );

        this.extrudeProgram = new Program(globe.renderContext);
        this.extrudeProgram.createFromSource(
            this.extrudeVertexShader,
            this.fragmentShader
        );
    };

    /**************************************************************************************************************/

    Utils.inherits(VectorRenderer, PolygonRenderer);

    /**************************************************************************************************************/

    /**
         @name PolygonRenderable
         @class
             Renderable constructor for Polygon
         @param {Bucket} bucket Bucket
         @augments BatchRenderable
         @constructor
         */
    var PolygonRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.origin = null;

        this.vertexSize = bucket.style.extrude ? 7 : 3;
        this.matrix = mat4.create();
    };

    Utils.inherits(BatchRenderable, PolygonRenderable);

    /**************************************************************************************************************/

    /**
     * Create an interpolated for polygon clipping
     */
    var _createInterpolatedVertex = function(t, p1, p2) {
        return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
    };

    /**************************************************************************************************************/

    /**
         Clip polygon to a side
         */
    var clipPolygonToSide = function(coord, sign, value, polygon) {
        var clippedPolygon = [];
        var t, newPoint;
        // iterate through vertices
        for (var i = 0; i < polygon.length; i++) {
            var p1 = polygon[i];
            var p2 = polygon[(i + 1) % polygon.length];
            var val1 = p1[coord];
            var val2 = p2[coord];

            // test containement
            var firstInside = (val1 - value) * sign >= 0.0;
            var secondInside = (val2 - value) * sign >= 0.0;

            // output vertices for inside polygon
            if (!firstInside && secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
                clippedPolygon.push(p2);
            } else if (firstInside && secondInside) {
                clippedPolygon.push(p2);
            } else if (firstInside && !secondInside) {
                t = (value - val1) / (val2 - val1);
                newPoint = _createInterpolatedVertex(t, p1, p2);
                clippedPolygon.push(newPoint);
            }
        }

        return clippedPolygon;
    };

    /**************************************************************************************************************/

    /**
         Clip polygon
         */
    var clipPolygon = function(coordinates, bound) {
        var c;
        c = clipPolygonToSide(0, 1, bound.west, coordinates);
        c = clipPolygonToSide(0, -1, bound.east, c);
        c = clipPolygonToSide(1, 1, bound.south, c);
        c = clipPolygonToSide(1, -1, bound.north, c);
        return c;
    };

    /**************************************************************************************************************/

    /**
         Check if a geometry crosses the date line
         */
    var _fixDateLine = function(coords) {
        //return [coords];
        var crossDateLine = false;
        for (var i = 1; i < coords.length && !crossDateLine; i++) {
            var deltaLon = Math.abs(coords[i][0] - coords[i - 1][0]);
            if (deltaLon > 180 && deltaLon < 360) {
                // DateLine!
                crossDateLine = true;
            }
        }
        var n;
        if (crossDateLine) {
            // Ensure coordinates are always negative
            var negCoords = [];
            for (n = 0; n < coords.length; n++) {
                if (coords[n][0] > 0) {
                    negCoords[n] = [coords[n][0] - 360, coords[n][1]];
                } else {
                    negCoords[n] = [coords[n][0], coords[n][1]];
                }
            }

            var posCoords = [];
            // Ensure coordinates are always positive
            for (n = 0; n < coords.length; n++) {
                if (coords[n][0] < 0) {
                    posCoords[n] = [coords[n][0] + 360, coords[n][1]];
                } else {
                    posCoords[n] = [coords[n][0], coords[n][1]];
                }
            }

            return [posCoords, negCoords];
        } else {
            return [coords];
        }
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderbale
     * Vertex buffer : geometry|extrude
     * Index buffer : geometry triangles|extrude triangles|lines
     * Normal buffer : normals.xyz, extrude value as w
     * @function build
     * @memberof PolygonRenderable.prototype
     * @param geometry
     */
    PolygonRenderable.prototype.build = function(geometry) {
        var renderer = this.bucket.renderer;
        var style = this.bucket.style;
        var coordinateSystem = renderer.globe.getCoordinateSystem();

        var polygons =
            geometry.type === Constants.GEOMETRY.MultiPolygon
                ? geometry.coordinates
                : [geometry.coordinates];

        var geometryBound = new GeoBound();
        var csBound = new GeoBound(
            coordinateSystem.getGeoBound().getWest(),
            coordinateSystem.getGeoBound().getSouth(),
            coordinateSystem.getGeoBound().getEast(),
            coordinateSystem.getGeoBound().getNorth()
        );
        var crsName = "CRS:84";
        if (typeof geometry.crs !== "undefined") {
            crsName = geometry.crs.properties.name;
        }
        var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(
            polygons[0][0],
            crsName,
            coordinateSystem
        );
        if (!geometryBound.intersects(csBound)) {
            return;
        }

        var pos3d = vec3.create();
        var i, n;
        if (!this.origin) {
            this.origin = vec3.create();
            coordinateSystem.get3DFromWorld(convertedCoord[0], this.origin); // Correction : add [0]

            mat4.identity(this.matrix);
            mat4.translate(this.matrix, this.origin);
        }

        var lastIndex = this.vertices.length / this.vertexSize;
        var offset = this.vertices.length;
        var upOffset, lowOffset;

        var contours = [];
        for (n = 0; n < polygons.length; n++) {
            contours = contours.concat(_fixDateLine(polygons[n][0]));
        }

        for (n = 0; n < contours.length; n++) {
            var coords = clipPolygon(contours[n], csBound);

            offset = this.vertices.length;

            // Build upper polygon vertices
            var clockwise = 0;
            for (i = 0; i < coords.length; i++) {
                // Always use coordinates at zero height on vertex construction, height will be taken into account on extrude
                coordinateSystem.get3DFromWorldInCrs(
                    [coords[i][0], coords[i][1], 0.0],
                    crsName,
                    pos3d
                );
                this.vertices[offset] = pos3d[0] - this.origin[0];
                this.vertices[offset + 1] = pos3d[1] - this.origin[1];
                this.vertices[offset + 2] = pos3d[2] - this.origin[2];

                // Find out if its vertices ordered clockwise to build index buffer properly
                if (i < coords.length - 1) {
                    clockwise +=
                        (coords[i + 1][0] - coords[i][0]) *
                        (coords[i + 1][1] + coords[i][1]);
                }

                if (style.extrude) {
                    // Compute normals
                    vec3.normalize(pos3d);
                    this.vertices[offset + 3] = pos3d[0];
                    this.vertices[offset + 4] = pos3d[1];
                    this.vertices[offset + 5] = pos3d[2];
                    var extrudeValue;
                    if (typeof style.extrude === "boolean") {
                        // Extrude value extracted from KML, use the height coordinate
                        extrudeValue = coords[i][2];
                    } else {
                        // Extrude value is a float defined by user
                        extrudeValue = style.extrude;
                    }
                    this.vertices[offset + 6] =
                        extrudeValue * coordinateSystem.geoide.heightScale;
                }

                offset += this.vertexSize;
            }

            // Build bottom polygon vertices on extrude
            if (style.extrude) {
                // Use same vertices as upper polygon but resest the 4-th compoenent
                var prevOffset = lastIndex * this.vertexSize;
                this.vertices = this.vertices.concat(
                    this.vertices.slice(prevOffset, offset)
                );
                // Reset the 4-th component for extrusion
                for (
                    i = offset;
                    i < this.vertices.length;
                    i += this.vertexSize
                ) {
                    this.vertices[i + 6] = 0.0;
                }
            }

            // Build triangle indices for upper polygon
            var triangulator = new PNLTRI.Triangulator();
            var contour = coords.map(function(value) {
                return { x: value[0], y: value[1] };
            });
            var triangList = triangulator.triangulate_polygon([contour]);
            for (i = 0; i < triangList.length; i++) {
                this.triIndices.push(
                    lastIndex + triangList[i][0],
                    lastIndex + triangList[i][1],
                    lastIndex + triangList[i][2]
                );
                //this.lineIndices.push( lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][1], lastIndex + triangList[i][2], lastIndex + triangList[i][2], lastIndex + triangList[i][0] );
            }

            // Build side triangle indices
            if (style.extrude) {
                upOffset = lastIndex;
                lowOffset = lastIndex + coords.length;

                for (i = 0; i < coords.length - 1; i++) {
                    // Depending on vertice order, push the
                    if (clockwise > 0) {
                        this.triIndices.push(upOffset, upOffset + 1, lowOffset);
                        this.triIndices.push(
                            upOffset + 1,
                            lowOffset + 1,
                            lowOffset
                        );
                    } else {
                        this.triIndices.push(upOffset, lowOffset, upOffset + 1);
                        this.triIndices.push(
                            upOffset + 1,
                            lowOffset,
                            lowOffset + 1
                        );
                    }
                    upOffset += 1;
                    lowOffset += 1;
                }
            }

            // Build line indices for upper polygon
            for (i = 0; i < coords.length - 1; i++) {
                this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
            }

            // Build top-to-bottom line indices
            if (style.extrude) {
                upOffset = lastIndex;
                lowOffset = lastIndex + coords.length;
                for (i = 0; i < coords.length - 1; i++) {
                    this.lineIndices.push(upOffset + i, lowOffset + i);
                }
            }

            // Update last index
            lastIndex = this.vertices.length / this.vertexSize;
        }
        // Geometry is always added contrary to tiled renderables
        return true;
    };

    /**************************************************************************************************************/

    /**
         @name PolygonBucket
         @class
             Bucket constructor for PolygonRenderer
         @param layer
         @param style
         @constructor
         */
    var PolygonBucket = function(layer, style) {
        this.layer = layer;
        this.style = style;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof PolygonBucket.prototype
     * @return {PolygonRenderable} Renderable
     */
    PolygonBucket.prototype.createRenderable = function() {
        return new PolygonRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof PolygonBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    PolygonBucket.prototype.isCompatible = function(style) {
        return this.style === style;
    };

    /**************************************************************************************************************/

    /**
     *    Render all the polygons
     * @function render
     * @memberof PolygonRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PolygonRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        //gl.enable(gl.POLYGON_OFFSET_FILL);
        //gl.polygonOffset(-2.0,-2.0);
        //gl.disable(gl.DEPTH_TEST);

        var currentProgram = null;

        // Compute the viewProj matrix
        var viewProjMatrix = mat4.create();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            viewProjMatrix
        );

        var modelViewProjMatrix = mat4.create();
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var style = renderable.bucket.style;

            // Setup program
            var program = style.extrude ? this.extrudeProgram : this.program;
            if (program !== currentProgram) {
                program.apply();
                currentProgram = program;
            }

            mat4.multiply(
                viewProjMatrix,
                renderable.matrix,
                modelViewProjMatrix
            );
            gl.uniformMatrix4fv(
                program.uniforms.mvp,
                false,
                modelViewProjMatrix
            );
            gl.uniform4f(
                program.uniforms.u_color,
                style.fillColor[0],
                style.fillColor[1],
                style.fillColor[2],
                style.fillColor[3] * renderable.bucket.layer.getOpacity()
            ); // use fillColor

            renderable.bindBuffers(renderContext);
            gl.lineWidth(style.strokeWidth);

            // Setup attributes
            gl.vertexAttribPointer(
                program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                4 * renderable.vertexSize,
                0
            );
            if (style.extrude) {
                gl.vertexAttribPointer(
                    program.attributes.normal,
                    4,
                    gl.FLOAT,
                    false,
                    4 * renderable.vertexSize,
                    12
                );
                gl.uniform1f(
                    program.uniforms.extrusionScale,
                    style.extrusionScale
                );
            }

            // Draw
            gl.drawElements(
                gl.TRIANGLES,
                renderable.triIndices.length,
                renderable.indexType,
                0
            );
            if (renderable.lineIndices.length > 0) {
                gl.uniform4f(
                    program.uniforms.u_color,
                    style.strokeColor[0],
                    style.strokeColor[1],
                    style.strokeColor[2],
                    style.strokeColor[3] * renderable.bucket.layer.getOpacity()
                );
                var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
                gl.drawElements(
                    gl.LINES,
                    renderable.lineIndices.length,
                    renderable.indexType,
                    renderable.triIndices.length * size
                );
            }
        }

        // Revert line width
        gl.lineWidth(1.0);

        //gl.enable(gl.DEPTH_TEST);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PolygonRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Can apply ?
     */
    PolygonRenderer.prototype.canApply = function(type, style) {
        return (
            (type === Constants.GEOMETRY.Polygon ||
                type === Constants.GEOMETRY.MultiPolygon) &&
            style.fill
        );
    };

    /**************************************************************************************************************/

    /**
     * Create a bucket
     * @function createBucket
     * @memberof PolygonRenderer.prototype
     * @param layer
     * @param style
     * @return {PolygonBucket} Bucket
     */
    PolygonRenderer.prototype.createBucket = function(layer, style) {
        return new PolygonBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PolygonRenderer(globe);
    });
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/LineRenderer',[
    "../Utils/Constants",
    "../Utils/Utils",
    "../Utils/Numeric",
    "./VectorRenderer",
    "./RendererManager",
    "./Program",
    "./BatchRenderable"
], function(
    Constants,
    Utils,
    Numeric,
    VectorRenderer,
    RendererManager,
    Program,
    BatchRenderable
) {
    /**************************************************************************************************************/

    /**
 	@name LineRenderer
 	@class
 	 Basic renderer to animate lines with gradient color texture
 	@param {AbstractGlobe} globe AbstractGlobe
 	@constructor
 	*/
    var LineRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;
        this.renderContext = globe.getRenderContext();

        this.defaultVertexShader = "attribute vec4 vertex;\n";
        this.defaultVertexShader += "uniform mat4 mvp;\n";
        this.defaultVertexShader += "varying float s;\n";
        this.defaultVertexShader += "void main(void) \n";
        this.defaultVertexShader += "{\n";
        this.defaultVertexShader += "	s = vertex.w;\n";
        this.defaultVertexShader +=
            "	gl_Position = mvp * vec4(vertex.xyz, 1.0);\n";
        this.defaultVertexShader += "}\n";

        this.fragmentShader = "precision lowp float; \n";
        this.fragmentShader += "uniform vec4 u_color;\n";
        this.fragmentShader += "uniform float speed;\n";
        this.fragmentShader += "uniform float time;\n";
        this.fragmentShader += "uniform float gradientLength;\n";
        this.fragmentShader += "varying float s;\n";
        this.fragmentShader += "uniform sampler2D colorTexture;\n";
        this.fragmentShader += "void main(void)\n";
        this.fragmentShader += "{\n";
        this.fragmentShader +=
            "	// 0.5 is a time scale parameter, parametrize it ?\n";
        this.fragmentShader += "	float m = speed * time * 0.5;\n";
        this.fragmentShader += "	float u = (-s+m)/gradientLength;\n";
        this.fragmentShader +=
            "	gl_FragColor.rgb = texture2D(colorTexture, vec2(u,0.)).rgb;\n";
        this.fragmentShader += "	// TODO: handle appereance of rivers\n";
        this.fragmentShader += "	if ( s < m )\n";
        this.fragmentShader += "	{\n";
        this.fragmentShader += "		gl_FragColor.a = 1.0;\n";
        this.fragmentShader += "	}\n";
        this.fragmentShader += "	else\n";
        this.fragmentShader += "	{\n";
        this.fragmentShader += "		gl_FragColor.a = 0.0;\n";
        this.fragmentShader += "	}\n";
        this.fragmentShader += "}\n";

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(
            this.defaultVertexShader,
            this.fragmentShader
        );

        this.time = Date.now() / 1000; // Store it in seconds
        this.palette = null; // Palette is an array containing two colors(start/end and the middle one)
        this.colorTexture = this.generateTexture([
            [0.0, 0.0, 255.0],
            [0.0, 200.0, 255.0]
        ]);
    };

    /**************************************************************************************************************/

    Utils.inherits(VectorRenderer, LineRenderer);

    /**************************************************************************************************************/

    /**
     * Generate color texture from palette
     * The generated gradient is of type : start color -> middle color -> start color
     * @function generateTexture
     * @memberof LineRenderer.prototype
     * @param palette
     */
    LineRenderer.prototype.generateTexture = function(palette) {
        var startColor = palette[0];
        var middleColor = palette[1];
        var i, r, g, b;
        var pixels = [];
        var gl = this.globe.renderContext.gl;
        this.colorTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

        for (i = 0; i < 128; i++) {
            r = Numeric.coserp(i / 128, startColor[0], middleColor[0]);
            g = Numeric.coserp(i / 128, startColor[1], middleColor[1]);
            b = Numeric.coserp(i / 128, startColor[2], middleColor[2]);
            pixels.push(r);
            pixels.push(g);
            pixels.push(b);
            pixels.push(255);
        }
        for (i = 0; i < 128; i++) {
            r = Numeric.coserp(i / 128, middleColor[0], startColor[0]);
            g = Numeric.coserp(i / 128, middleColor[1], startColor[1]);
            b = Numeric.coserp(i / 128, middleColor[2], startColor[2]);
            pixels.push(r);
            pixels.push(g);
            pixels.push(b);
            pixels.push(255);
        }
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            pixels.length / 4,
            1,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            new Uint8Array(pixels)
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

        this.palette = palette;
    };

    /**************************************************************************************************************/
    /**
 	@name LineRenderable
 	@class
 	 Renderable constructor for Line
 	@param {Bucket} bucket Bucket
	@augments BatchRenderable
 	@constructor
 	*/

    var LineRenderable = function(bucket) {
        BatchRenderable.prototype.constructor.call(this, bucket);

        this.vertexSize = 4;

        // TODO : remove matrix ??
        this.matrix = mat4.create();
        mat4.identity(this.matrix);
    };

    /**************************************************************************************************************/

    Utils.inherits(BatchRenderable, LineRenderable);

    /**************************************************************************************************************/

    /**
     * Build vertices and indices for the given geometry
     * @function build
     * @memberof LineRenderable.prototype
     * @param geometry
     */
    LineRenderable.prototype.build = function(geometry) {
        var renderer = this.bucket.renderer;
        var style = this.bucket.style;
        var i, n;

        var lines =
            geometry.type === Constants.GEOMETRY.MultiLineString
                ? geometry.coordinates
                : [geometry.coordinates];

        var currentPoint = vec3.create();
        var previousPoint = vec3.create();

        for (n = 0; n < lines.length; n++) {
            var coords = lines[n];

            var lastIndex = this.vertices.length / 4;
            var coordinateSystem = renderer.globe.getCoordinateSystem();

            // Build line vertices
            var offset = lastIndex * 4;
            var s = 0;
            for (i = 0; i < coords.length; i++) {
                coordinateSystem.get3DFromWorldInCrs(
                    coords[i],
                    geometry.crs.properties.name,
                    currentPoint
                );
                this.vertices[offset] = currentPoint[0];
                this.vertices[offset + 1] = currentPoint[1];
                this.vertices[offset + 2] = currentPoint[2];
                // Compute s(length) between two points
                if (i > 0) {
                    s += vec3.dist(currentPoint, previousPoint);
                }

                // Update previous point(do it by swapping with current cuz it's the same object)
                var tmp = previousPoint;
                previousPoint = currentPoint;
                currentPoint = tmp;

                this.vertices[offset + 3] = s;
                offset += 4;
            }

            // Build line indices
            for (i = 0; i < coords.length - 1; i++) {
                this.lineIndices.push(lastIndex + i, lastIndex + i + 1);
            }
        }
        // Geometry is always added contrary to tiled renderables
        return true;
    };

    /**************************************************************************************************************/
    /**
 	@name LineBucket
 	@class
 	 Bucket constructor for LineRenderer
 	@param layer
	@param style
 	@constructor
 	*/
    var LineBucket = function(layer, style) {
        this.layer = layer;
        this.style = style;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof LineBucket.prototype
     */
    LineBucket.prototype.createRenderable = function() {
        return new LineRenderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function is Compatible
     * @memberof LineBucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    LineBucket.prototype.isCompatible = function(style) {
        return this.style === style;
    };

    /**************************************************************************************************************/

    /**
     * 	Render all the polygons
     * @function render
     * @memberof LineRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    LineRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        //gl.enable(gl.POLYGON_OFFSET_FILL);
        //gl.polygonOffset(-2.0,-2.0);
        //gl.disable(gl.DEPTH_TEST);

        // Compute the viewProj matrix
        var viewProjMatrix = mat4.create();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            viewProjMatrix
        );
        var modelViewProjMatrix = mat4.create();

        this.program.apply();

        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.program.uniforms.colorTexture, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var style = renderable.bucket.style;

            mat4.multiply(
                viewProjMatrix,
                renderable.matrix,
                modelViewProjMatrix
            );
            gl.uniformMatrix4fv(
                this.program.uniforms.mvp,
                false,
                modelViewProjMatrix
            );

            if (style.palette && style.palette !== this.palette) {
                // Generate new color texture(create an array of color textures per bucket ?)
                gl.deleteTexture(this.colorTexture);
                this.generateTexture(style.palette);
            }

            gl.lineWidth(style.strokeWidth);

            // Update uniforms
            gl.uniform4f(
                this.program.uniforms.color,
                style.strokeColor[0],
                style.strokeColor[1],
                style.strokeColor[2],
                style.strokeColor[3] * renderable.bucket.layer.getOpacity()
            );
            gl.uniform1f(
                this.program.uniforms.speed,
                style.hasOwnProperty("speed") ? style.speed : 1.0
            );
            gl.uniform1f(
                this.program.uniforms.time,
                Date.now() / 1000 - this.time
            );
            gl.uniform1f(
                this.program.uniforms.gradientLength,
                style.hasOwnProperty("gradientLength")
                    ? style.gradientLength
                    : 10.0
            );

            renderable.bindBuffers(renderContext);

            gl.vertexAttribPointer(
                this.program.attributes.vertex,
                4,
                gl.FLOAT,
                false,
                0,
                0
            );

            // Draw
            gl.drawElements(
                gl.LINES,
                renderable.lineIndices.length,
                renderable.indexType,
                0
            );
        }

        // Revert to default
        gl.lineWidth(1);

        //gl.enable(gl.DEPTH_TEST);
        //gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthFunc(gl.LESS);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof LineRenderer.prototype
     * @return {Boolean} Can apply ?
     */
    LineRenderer.prototype.canApply = function(type, style) {
        return (
            (type === Constants.GEOMETRY.LineString ||
                type === Constants.GEOMETRY.MultiLineString) &&
            style.gradientLength
        );
    };

    /**************************************************************************************************************/

    /**
     * Create a bucket
     * @function createBucket
     * @memberof LineRenderer.prototype
     * @param layer
     * @param style
     * @return {LineBucket} Line bucket
     */
    LineRenderer.prototype.createBucket = function(layer, style) {
        return new LineBucket(layer, style);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new LineRenderer(globe);
    });
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/PointSpriteRenderer',[
    "../Utils/Utils",
    "./VectorRenderer",
    "./Program",
    "./FeatureStyle",
    "./RendererManager",
    "../Utils/Constants"
], function(
    Utils,
    VectorRenderer,
    Program,
    FeatureStyle,
    RendererManager,
    Constants
) {
    /**************************************************************************************************************/

    /**
         @name PointSpriteRenderer
         @class
             PointSpriteRenderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
    var PointSpriteRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        // For stats
        this.numberOfRenderPoints = 0;

        var vertexShader = "attribute vec3 vertex; \n";
        vertexShader += "uniform mat4 viewProjectionMatrix; \n";
        vertexShader += "uniform float pointSize; \n";
        vertexShader += "void main(void)  \n";
        vertexShader += "{ \n";
        vertexShader +=
            "	gl_Position = viewProjectionMatrix * vec4(vertex,1.0); \n";
        vertexShader += "	gl_PointSize = pointSize; \n";
        vertexShader += "} \n";

        var fragmentShader = "precision lowp float; \n";
        fragmentShader += "uniform sampler2D texture; \n";
        fragmentShader += "uniform float alpha; \n";
        fragmentShader += "uniform vec3 color; \n";
        fragmentShader += "\n";
        fragmentShader += "void main(void) \n";
        fragmentShader += "{ \n";
        fragmentShader +=
            "	vec4 textureColor = texture2D(texture, gl_PointCoord); \n";
        fragmentShader +=
            "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
        fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
        fragmentShader += "	//gl_FragColor = vec4(1.0); \n";
        fragmentShader += "} \n";

        this.program = new Program(globe.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);

        this.defaultTexture = null;
    };

    Utils.inherits(VectorRenderer, PointSpriteRenderer);

    /**************************************************************************************************************/

    /**
         @name Renderable
         @class
             Renderable constructor for PointSprite
         @param {Bucket} bucket Bucket
         @constructor
         */
    var Renderable = function(bucket) {
        this.bucket = bucket;
        this.geometry2vb = {};
        this.vertices = [];
        this.geometries = [];
        this.vertexBuffer = null;
        this.vertexBufferDirty = false;
    };

    /**************************************************************************************************************/

    /**
     * Add a geometry to the renderable
     * @function add
     * @memberof Renderable.prototype
     * @param geometry
     * @return {Boolean} If the geometry has been successfully added to the renderable
     */
    Renderable.prototype.add = function(geometry, stockGeometry) {
        this.geometry2vb[geometry.gid] = this.vertices.length;
        // TODO: Find a better way to access to coordinate system
        var globe = this.bucket.renderer.globe;
        var crs = globe.getCoordinateSystem();
        var pt = crs.get3DFromWorldInCrs(
            geometry.coordinates,
            geometry.crs.properties.name
        );
        var realPlanetRadius = crs.getGeoide().getRealPlanetRadius();
        var planetRadius = crs.getGeoide().getRadius();
        var scale = this.bucket.renderer.globe.isSky()
            ? 0.95
            : 1.0 +
              (crs.getElevation(globe, geometry) + 200) / realPlanetRadius;
        //TODO Instead of 0.95, it should be 0.9995. But with this value, the point is dislayed
        //TODO after order > 5. With order<=5, the image need more control points. Without these
        //TODO control point, the image does not fit perfectly the sphere and the point is behind the image
        this.vertices.push(scale * pt[0], scale * pt[1], scale * pt[2]);
        if (stockGeometry !== false) {
            this.geometries.push(geometry);
        }
        this.vertexBufferDirty = true;
        return true;
    };

    /**************************************************************************************************************/

    /**
     * Update all elevations for each render
     * @function updateElevations
     * @memberof Renderable.prototype
     */
    Renderable.prototype.updateElevations = function() {
        this.vertices = [];
        for (var i = 0; i < this.geometries.length; i++) {
            this.add(this.geometries[i], false);
        }
    };

    /**************************************************************************************************************/

    /**
     * Remove a geometry from the renderable
     * @function remove
     * @memberof Renderable.prototype
     * @param geometry
     */
    Renderable.prototype.remove = function(geometry) {
        if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
            var vbIndex = this.geometry2vb[geometry.gid];
            delete this.geometry2vb[geometry.gid];
            this.vertices.splice(vbIndex, 3);
            this.vertexBufferDirty = true;

            // Update render data for all other geometries
            for (var g in this.geometry2vb) {
                if (g) {
                    if (this.geometry2vb[g] > vbIndex) {
                        this.geometry2vb[g] -= 3;
                    }
                }
            }
        }
        return this.vertices.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable
     * @function dispose
     * @memberof Renderable.prototype
     * @param renderContext
     */
    Renderable.prototype.dispose = function(renderContext) {
        if (this.vertexBuffer) {
            renderContext.gl.deleteBuffer(this.vertexBuffer);
        }
    };

    /**************************************************************************************************************/

    /**
     * Build a default texture
     * @function _buildDefaultTexture
     * @memberof PointSpriteRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @private
     */
    PointSpriteRenderer.prototype._buildDefaultTexture = function(bucket) {
        if (!this.defaultTexture) {
            var gl = this.globe.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                1,
                1,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                whitePixel
            );
        }

        bucket.texture = this.defaultTexture;
        bucket.textureWidth = 10;
        bucket.textureHeight = 10;
    };

    /**************************************************************************************************************/

    /**
     * Build a texture from an image and store in a bucket
     * @function _buildTextureFromImage
     * @memberof PointSpriteRenderer.prototype
     * @param {Bucket} bucket Bucket
     * @param image
     * @private
     */
    PointSpriteRenderer.prototype._buildTextureFromImage = function(
        bucket,
        image
    ) {
        bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(
            image
        );
        bucket.textureWidth = image.width;
        bucket.textureHeight = image.height;
    };

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof PointSpriteRenderer.prototype
     * @param type
     * @param style
     * @return {Boolean} Is applicable ?
     */
    PointSpriteRenderer.prototype.canApply = function(type, style) {
        return type === Constants.GEOMETRY.Point && !style.label;
    };

    /**************************************************************************************************************/

    /**
         @name Bucket
         @class
             Bucket constructor for PointSpriteRenderer
         @param layer
         @param style
         @constructor
         */

    var Bucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.texture = null;
        this.renderer = null;
    };

    /**************************************************************************************************************/

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {Renderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new Renderable(this);
    };

    /**************************************************************************************************************/

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof Bucket.prototype
     * @param style
     * @return {Boolean} Is compatible ?
     */
    Bucket.prototype.isCompatible = function(style) {
        if (
            this.style.iconUrl === style.iconUrl &&
            this.style.icon === style.icon &&
            this.style.fillColor[0] === style.fillColor[0] &&
            this.style.fillColor[1] === style.fillColor[1] &&
            this.style.fillColor[2] === style.fillColor[2]
        ) {
            return true;
        }

        return false;
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a point
     * @function createBucket
     * @memberof PointSpriteRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    PointSpriteRenderer.prototype.createBucket = function(layer, style) {
        var gl = this.globe.renderContext.gl;
        var vb = gl.createBuffer();

        // Create a bucket
        var bucket = new Bucket(layer, style);
        bucket.renderer = this;

        // Initialize bucket : create the texture
        if (style.iconUrl) {
            var image = new Image();
            image.crossOrigin = "";
            var self = this;
            image.onload = function() {
                self._buildTextureFromImage(bucket, image);
                self.globe.renderContext.requestFrame();
            };
            image.onerror = function() {
                self._buildDefaultTexture(bucket);
            };
            image.src = style.iconUrl;
        } else if (style.icon) {
            this._buildTextureFromImage(bucket, style.icon);
        } else {
            this._buildDefaultTexture(bucket);
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render
     * @function render
     * @memberof PointSpriteRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    PointSpriteRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.globe.renderContext;
        var gl = renderContext.gl;

        // Setup states
        //gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Setup program
        this.program.apply();

        // The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.program.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );
        gl.uniform1i(this.program.uniforms.texture, 0);

        // Render each renderables
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            renderable.updateElevations();
            var bucket = renderable.bucket;

            if (currentBucket !== bucket) {
                gl.uniform1f(
                    this.program.uniforms.alpha,
                    bucket.layer.getOpacity()
                );
                var color = bucket.style.getFillColor();
                gl.uniform3f(
                    this.program.uniforms.color,
                    color[0],
                    color[1],
                    color[2]
                );
                gl.uniform1f(
                    this.program.uniforms.pointSize,
                    bucket.textureWidth
                );

                // Bind point texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                currentBucket = bucket;
            }

            if (!renderable.vertexBuffer) {
                renderable.vertexBuffer = gl.createBuffer();
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
            gl.vertexAttribPointer(
                this.program.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            if (renderable.vertexBufferDirty) {
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(renderable.vertices),
                    gl.STATIC_DRAW
                );
                renderable.vertexBufferDirty = false;
            }

            gl.drawArrays(gl.POINTS, 0, renderable.vertices.length / 3);
        }

        //gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    // Register the renderer
    RendererManager.factory.push(function(globe) {
        return new PointSpriteRenderer(globe);
    });
    return PointSpriteRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Triangulator',[],function() {
    /**
     Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     Does not manage holes
     Seems to be O(n^3)!
     */
    var EPSILON = 0.0000000001;

    /*
     Compute the signed area of a polygon
     */
    var Area = function(contour) {
        var n = contour.length;
        var A = 0.0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            A += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
        }
        return A * 0.5;
    };

    /*
     InsideTriangle decides if a point P is Inside of the triangle
     defined by A, B, C.
     */
    var InsideTriangle = function(Ax, Ay, Bx, By, Cx, Cy, Px, Py) {
        var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        ax = Cx - Bx;
        ay = Cy - By;
        bx = Ax - Cx;
        by = Ay - Cy;
        cx = Bx - Ax;
        cy = By - Ay;
        apx = Px - Ax;
        apy = Py - Ay;
        bpx = Px - Bx;
        bpy = Py - By;
        cpx = Px - Cx;
        cpy = Py - Cy;

        aCROSSbp = ax * bpy - ay * bpx;
        cCROSSap = cx * apy - cy * apx;
        bCROSScp = bx * cpy - by * cpx;

        return aCROSSbp >= 0.0 && bCROSScp >= 0.0 && cCROSSap >= 0.0;
    };

    /*
     Check if the giben triangle (u,v,w) is a ear : not other vertex inside
     */
    var Snip = function(contour, u, v, w, n, V) {
        var p;
        var Ax, Ay, Bx, By, Cx, Cy, Px, Py;

        Ax = contour[V[u]][0];
        Ay = contour[V[u]][1];

        Bx = contour[V[v]][0];
        By = contour[V[v]][1];

        Cx = contour[V[w]][0];
        Cy = contour[V[w]][1];

        if (EPSILON > (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax)) {
            return false;
        }

        for (p = 0; p < n; p++) {
            if (p === u || p === v || p === w) {
                continue;
            }
            Px = contour[V[p]][0];
            Py = contour[V[p]][1];
            if (InsideTriangle(Ax, Ay, Bx, By, Cx, Cy, Px, Py)) {
                return false;
            }
        }

        return true;
    };

    /*
     Process triangulation on the given contour
     */
    var Process = function(contour) {
        /* allocate and initialize list of Vertices in polygon */

        var n = contour.length;
        if (
            contour[0][0] === contour[n - 1][0] &&
            contour[0][1] === contour[n - 1][1]
        ) {
            n--;
        }

        if (n < 3) {
            return null;
        }

        var V = new Array(n);
        var m, v;
        /* we want a counter-clockwise polygon in V */

        if (0.0 < Area(contour)) {
            for (v = 0; v < n; v++) {
                V[v] = v;
            }
        } else {
            for (v = 0; v < n; v++) {
                V[v] = n - 1 - v;
            }
        }

        var nv = n;

        var results = [];

        /*  remove nv-2 Vertices, creating 1 triangle every time */
        var count = 2 * nv;
        /* error detection */

        for (m = 0, v = nv - 1; nv > 2; ) {
            /* if we loop, it is probably a non-simple polygon */
            if (0 >= count--) {
                //** Triangulate: ERROR - probable bad polygon!
                return null;
            }

            /* three consecutive vertices in current polygon, <u,v,w> */
            var u = v;
            if (nv <= u) {
                u = 0;
            }
            /* previous */
            v = u + 1;
            if (nv <= v) {
                v = 0;
            }
            /* new v    */
            var w = v + 1;
            if (nv <= w) {
                w = 0;
            }
            /* next     */

            if (Snip(contour, u, v, w, nv, V)) {
                var a, b, c, s, t;

                /* true names of the vertices */
                a = V[u];
                b = V[v];
                c = V[w];

                /* output Triangle */
                results.push(a);
                results.push(b);
                results.push(c);

                m++;

                /* remove v from remaining polygon */
                for (s = v, t = v + 1; t < nv; s++, t++) {
                    V[s] = V[t];
                }
                nv--;

                /* resest error detection counter */
                count = 2 * nv;
            }
        }

        return results;
    };

    var Triangulator = {
        process: Process
    };

    return Triangulator;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/ConvexPolygonRenderer',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./VectorRenderer",
    "./Program",
    "./FeatureStyle",
    "./RendererManager",
    "../Tiling/Triangulator",
    "./glMatrix"
], function(
    Utils,
    Constants,
    VectorRenderer,
    Program,
    FeatureStyle,
    RendererManager,
    Triangulator
) {
    /**
         @name Bucket
         @class
          Bucket constructor for ConvexPolygonRenderer
         @param layer
         @param style
         @constructor
         */
    var Bucket = function(layer, style) {
        this.layer = layer;
        this.style = new FeatureStyle(style);
        this.texture = null;
        this.polygonProgram = null;
        this.renderer = null;
        this.mainRenderable = null;
    };

    /**
     * Check if a bucket is compatible
     * @function isCompatible
     * @memberof Bucket.prototype
     * @param style
     * @return {boolean} Is compatible ?
     */
    Bucket.prototype.isCompatible = function(style) {
        if (
            this.style.strokeColor[0] === style.strokeColor[0] &&
            this.style.strokeColor[1] === style.strokeColor[1] &&
            this.style.strokeColor[2] === style.strokeColor[2] &&
            this.style.fill === style.fill &&
            this.style.fillTexture === style.fillTexture &&
            this.style.fillTextureUrl === style.fillTextureUrl &&
            this.style.fillShader === style.fillShader
        ) {
            return true;
        }
        return false;
    };

    /**************************************************************************************************************/

    /**
          @name Renderable
          @class
            Renderable constructor
            Attach to a bucket
          @param {Bucket} bucket Bucket
          @constructor
         */
    var Renderable = function(bucket) {
        this.bucket = bucket;
        this.geometry2vb = {};
        this.vertices = [];
        this.lineIndices = [];
        this.triangleIndices = [];
        this.vertexBuffer = null;
        this.lineIndexBuffer = null;
        this.triangleIndexBuffer = null;
        this.bufferDirty = false;
        this.triBufferDirty = false;
        this.tcoords = [];
    };

    /**************************************************************************************************************/

    /**
     * Add the geometry to the renderable
     * @function add
     * @memberof Renderable.prototype
     * @return if the geometry has been successfully added to the renderable
     */
    Renderable.prototype.add = function(geometry) {
        var rings = [];
        var geometryCrs = geometry.crs.properties.name;
        var i, r, pt;
        if (geometry.type === Constants.GEOMETRY.MultiPolygon) {
            for (i = 0; i < geometry.coordinates.length; i++) {
                rings.push(geometry.coordinates[i][0]);
            }
        } else if (geometry.type === Constants.GEOMETRY.LineString) {
            rings.push(geometry.coordinates);
        } else if (geometry.type === Constants.GEOMETRY.MultiLineString) {
            for (i = 0; i < geometry.coordinates.length; i++) {
                rings.push(geometry.coordinates[i]);
            }
        } else {
            rings.push(geometry.coordinates[0]);
        }

        for (r = 0; r < rings.length; r++) {
            var coords = rings[r];
            // var coords = geometry['coordinates'][0];
            //var numPoints = coords.length-1;
            var numPoints = coords.length;

            // Store information for the geometry in the buffers used for rendering
            var data = {
                vertexStart: this.vertices.length,
                vertexCount: 3 * numPoints,
                lineIndexStart: this.lineIndices.length,
                lineIndexCount: 2 * numPoints,
                triIndexStart: 0,
                triIndexCount: 0
            };

            var coordinateSystem = this.bucket.renderer.globe.getCoordinateSystem();
            // Compute texture coordinates if defined
            if (geometry._imageCoordinates) {
                data.tcoordsStart = this.tcoords.length;
                data.tcoordsCount = 2 * numPoints;

                // Initialize variables used for texture coordinates computation
                var p0 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][0],
                    geometryCrs
                ); // origin
                var p1 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][1],
                    geometryCrs
                );
                var p3 = coordinateSystem.get3DFromWorldInCrs(
                    geometry._imageCoordinates[0][3],
                    geometryCrs
                );
                var v01 = [];
                vec3.subtract(p1, p0, v01); // U-axis
                var v03 = [];
                vec3.subtract(p3, p0, v03); // V-axis
                var squaredU = vec3.length(v01) * vec3.length(v01);
                var squaredV = vec3.length(v03) * vec3.length(v03);

                for (i = 0; i < numPoints; i++) {
                    pt = coordinateSystem.get3DFromWorldInCrs(
                        coords[i],
                        geometryCrs
                    );
                    var v0P = [];
                    vec3.subtract(pt, p0, v0P);

                    var uDotProduct = vec3.dot(v0P, v01);
                    var vDotProduct = vec3.dot(v0P, v03);
                    var u = uDotProduct / squaredU;
                    var v = vDotProduct / squaredV;
                    this.tcoords.push(u);
                    this.tcoords.push(v);
                }
            }

            // Compute vertices and indices and store them in the buffers
            var startIndex = this.vertices.length / 3;
            for (i = 0; i < numPoints; i++) {
                pt = coordinateSystem.get3DFromWorldInCrs(
                    coords[i],
                    geometryCrs
                );
                this.vertices.push(pt[0], pt[1], pt[2]);

                if (
                    (geometry.type === Constants.GEOMETRY.MultiLineString ||
                        geometry.type === Constants.GEOMETRY.LineString) &&
                    i === numPoints - 1
                ) {
                    break;
                }
                this.lineIndices.push(
                    startIndex + i,
                    startIndex + ((i + 1) % numPoints)
                );
            }

            // If fill, build the triangle indices
            if (this.bucket.style.fill) {
                data.triIndexStart = this.triangleIndices.length;
                data.triIndexCount = 3 * (numPoints - 2);

                var triangleIndices = Triangulator.process(coords);
                if (triangleIndices !== null) {
                    this.triangleIndices = triangleIndices;
                } else {
                    // HACK for not trivial polygons
                    for (i = 0; i < numPoints - 2; i++) {
                        this.triangleIndices.push(
                            startIndex,
                            startIndex + i + 1,
                            startIndex + i + 2
                        );
                    }
                }
            }

            if (this.geometry2vb[geometry.gid]) {
                this.geometry2vb[geometry.gid].vertexCount += data.vertexCount;
                this.geometry2vb[geometry.gid].lineIndexCount +=
                    data.lineIndexCount;
                this.geometry2vb[geometry.gid].triIndexCount +=
                    data.triIndexCount;
            } else {
                this.geometry2vb[geometry.gid] = data;
            }

            this.bufferDirty = true;
            this.triBufferDirty = true;
        }

        return true;
    };

    /**************************************************************************************************************/

    /**
     * Remove the geometry from the renderable
     * @function remove
     * @memberof Renderable.prototype
     * @param geometry
     */
    Renderable.prototype.remove = function(geometry) {
        var i;
        if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
            // retreive the render data for the geometry
            var data = this.geometry2vb[geometry.gid];
            delete this.geometry2vb[geometry.gid];

            // Remove geometry vertex
            this.vertices.splice(data.vertexStart, data.vertexCount);

            // Update indices after vertex removal
            for (
                i = data.lineIndexStart + data.lineIndexCount;
                i < this.lineIndices.length;
                i++
            ) {
                this.lineIndices[i] -= data.vertexCount / 3;
            }
            for (
                i = data.triIndexStart + data.triIndexCount;
                i < this.triangleIndices.length;
                i++
            ) {
                this.triangleIndices[i] -= data.vertexCount / 3;
            }

            this.lineIndices.splice(data.lineIndexStart, data.lineIndexCount);
            this.triangleIndices.splice(data.triIndexStart, data.triIndexCount);
            if (data.tcoordsStart >= 0) {
                this.tcoords.splice(data.tcoordsStart, data.tcoordsCount);
            }

            // Update render data for all other geometries
            for (var g in this.geometry2vb) {
                if (g) {
                    var d = this.geometry2vb[g];
                    if (d.vertexStart > data.vertexStart) {
                        d.vertexStart -= data.vertexCount;
                        d.lineIndexStart -= data.lineIndexCount;
                        d.triIndexStart -= data.triIndexCount;
                        if (d.tcoordsStart >= 0) {
                            d.tcoordsStart -= data.tcoordsCount;
                        }
                    }
                }
            }

            this.bufferDirty = true;
            this.triBufferDirty = true;
        }
        return this.vertices.length;
    };

    /**************************************************************************************************************/

    /**
     * Dispose the renderable : remove all buffers
     * @function dispose
     * @memberof Renderable.prototype
     * @param renderContext
     */
    Renderable.prototype.dispose = function(renderContext) {
        if (this.vertexBuffer) {
            renderContext.gl.deleteBuffer(this.vertexBuffer);
        }
        if (this.lineIndexBuffer) {
            renderContext.gl.deleteBuffer(this.lineIndexBuffer);
        }
        if (this.triangleIndexBuffer) {
            renderContext.gl.deleteBuffer(this.triangleIndexBuffer);
        }
        if (this.tcoordBuffer) {
            renderContext.gl.deleteBuffer(this.tcoordBuffer);
        }
    };

    /**
     * Create a renderable for this bucket
     * @function createRenderable
     * @memberof Bucket.prototype
     * @return {Renderable} Renderable
     */
    Bucket.prototype.createRenderable = function() {
        return new Renderable(this);
    };

    /**************************************************************************************************************/

    /**
          @name ConvexPolygonRenderer
          @class
            ConvexPolygonRenderer  constructor
          @augments VectorRenderer
          @param {AbstractGlobe} globe AbstractGlobe
          @constructor
          */
    var ConvexPolygonRenderer = function(globe) {
        VectorRenderer.prototype.constructor.call(this, globe);
        this.maxTilePerGeometry = 2;

        // Store object for rendering
        this.renderContext = globe.tileManager.renderContext;
        this.tileConfig = globe.tileManager.tileConfig;

        this.programs = [];

        this.basicVertexShader = "attribute vec3 vertex;\n";
        this.basicVertexShader += "uniform mat4 viewProjectionMatrix;\n";
        this.basicVertexShader += "    \n";
        this.basicVertexShader += "    void main(void)\n";
        this.basicVertexShader += "    {\n";
        this.basicVertexShader +=
            "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
        this.basicVertexShader += "    }\n";

        this.basicFragmentShader = "precision lowp float; \n";
        this.basicFragmentShader += "    uniform vec4 color; \n";
        this.basicFragmentShader += "    \n";
        this.basicFragmentShader += "    void main(void) \n";
        this.basicFragmentShader += "    { \n";
        this.basicFragmentShader += "        gl_FragColor = color; \n";
        this.basicFragmentShader += "    } \n";

        this.texVertexShader = "attribute vec3 vertex;\n";
        this.texVertexShader += "    attribute vec2 tcoord;\n";
        this.texVertexShader += "    uniform mat4 viewProjectionMatrix;\n";
        this.texVertexShader += "    \n";
        this.texVertexShader += "    varying vec2 vTextureCoord;\n";
        this.texVertexShader += "    \n";
        this.texVertexShader += "    void main(void) \n";
        this.texVertexShader += "    {\n";
        this.texVertexShader += "        vTextureCoord = tcoord;\n";
        this.texVertexShader +=
            "        vTextureCoord.y = 1.0 - vTextureCoord.y; \n";
        this.texVertexShader +=
            "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
        this.texVertexShader += "    }\n";

        this.texFragmentShader = "precision lowp float; \n";
        this.texFragmentShader += "    uniform vec4 color;\n";
        this.texFragmentShader += "    varying vec2 vTextureCoord;\n";
        this.texFragmentShader += "    uniform sampler2D texture; \n";
        this.texFragmentShader += "    void main(void)\n";
        this.texFragmentShader += "    {\n";
        this.texFragmentShader +=
            "        gl_FragColor = texture2D(texture, vTextureCoord) * color;\n";
        this.texFragmentShader += "    }\n";

        this.basicFillShader = {
            vertexCode: this.basicVertexShader,
            fragmentCode: this.basicFragmentShader,
            updateUniforms: null
        };

        this.texFillShader = {
            vertexCode: this.texVertexShader,
            fragmentCode: this.texFragmentShader,
            updateUniforms: null
        };

        this.basicProgram = this.createProgram(this.basicFillShader);
        this.texProgram = this.createProgram(this.texFillShader);

        var gl = this.renderContext.gl;
        // Parameters used to implement ONE shader for color xor texture rendering
        this.whiteTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
        var whitePixel = new Uint8Array([255, 255, 255, 255]);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            1,
            1,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            whitePixel
        );

        // Shared buffer
        // Create texCoord buffer
        this.tcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);

        var textureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0];

        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(textureCoords),
            gl.STATIC_DRAW
        );
        this.tcoordBuffer.itemSize = 2;
        this.tcoordBuffer.numItems = 5;
    };

    Utils.inherits(VectorRenderer, ConvexPolygonRenderer);

    /**************************************************************************************************************/

    /**
     * Check if renderer is applicable
     * @function canApply
     * @memberof ConvexPolygonRenderer.prototype
     * @param type
     * @param style
     * @return {boolean} Is applicable ?
     */
    ConvexPolygonRenderer.prototype.canApply = function(type, style) {
        if (!this.globe.isSky()) {
            return false;
        }

        return (
            type === Constants.GEOMETRY.Polygon ||
            type === Constants.GEOMETRY.MultiPolygon ||
            type === Constants.GEOMETRY.LineString ||
            type === Constants.GEOMETRY.MultiLineString
        );
    };

    /**************************************************************************************************************/

    /**
     * Create program from fillShader object
     * @function createProgram
     * @memberof ConvexPolygonRenderer.prototype
     * @param fillShader
     * @return {Program} Program
     */
    ConvexPolygonRenderer.prototype.createProgram = function(fillShader) {
        var program = new Program(this.renderContext);
        program.createFromSource(
            fillShader.vertexCode,
            fillShader.fragmentCode
        );

        // Add program
        program.id = this.programs.length;
        this.programs.push({
            fillShader: fillShader,
            program: program
        });
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Get program if known by renderer, create otherwise
     * @function getProgram
     * @memberof ConvexPolygonRenderer.prototype
     * @param fillShader
     * @return {Program} Program
     */
    ConvexPolygonRenderer.prototype.getProgram = function(fillShader) {
        var program;

        for (var id = 0; id < this.programs.length; id++) {
            if (this.programs[id].fillShader === fillShader) {
                program = this.programs[id].program;
            }
        }

        if (!program) {
            program = this.createProgram(fillShader);
        }
        return program;
    };

    /**************************************************************************************************************/

    /**
     * Create bucket to render a polygon
     * @function createBucket
     * @memberof ConvexPolygonRenderer.prototype
     * @param layer
     * @param style
     * @return {Bucket} Bucket
     */
    ConvexPolygonRenderer.prototype.createBucket = function(layer, style) {
        var gl = this.renderContext.gl;
        var vb = gl.createBuffer();

        console.log("ConvexPolygonrenderer.createBucket");
        // Create a bucket
        var bucket = new Bucket(layer, style);

        // Create texture
        var self = this;
        if (style.fill) {
            var hasTexture = false;
            if (style.fillTextureUrl) {
                var image = new Image();
                image.crossOrigin = "";
                image.onload = function() {
                    bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(
                        image,
                        layer.invertY
                    );
                };

                image.onerror = function(event) {
                    console.error("Cannot load " + image.src);
                };

                image.src = style.fillTextureUrl;
                hasTexture = true;
            } else if (style.fillTexture) {
                bucket.texture = style.fillTexture;
                hasTexture = true;
            }

            if (style.fillShader && style.fillShader.fragmentCode) {
                // User defined texture program
                if (!style.fillShader.vertexCode) {
                    style.fillShader.vertexCode = this.texVertexShader;
                }
                if (!style.fillShader.vertexCode) {
                    style.fillShader.fragmentCode = this.texFragmentShader;
                }

                bucket.polygonProgram = this.getProgram(style.fillShader);
            } else {
                // Default program
                bucket.polygonProgram = hasTexture
                    ? this.texProgram
                    : this.basicProgram;
            }
        }

        return bucket;
    };

    /**************************************************************************************************************/

    /**
     * Render all the POIs
     * @function render
     * @memberof ConvexPolygonRenderer.prototype
     * @param renderables
     * @param {Integer} start Start index
     * @param {Integer} end End index
     */
    ConvexPolygonRenderer.prototype.render = function(renderables, start, end) {
        var renderContext = this.renderContext;
        var gl = this.renderContext.gl;

        // Setup states
        gl.disable(gl.DEPTH_TEST);
        gl.depthMask(false);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Setup the basic program
        this.basicProgram.apply();
        mat4.multiply(
            renderContext.projectionMatrix,
            renderContext.viewMatrix,
            renderContext.modelViewMatrix
        );
        gl.uniformMatrix4fv(
            this.basicProgram.uniforms.viewProjectionMatrix,
            false,
            renderContext.modelViewMatrix
        );

        // Render each renderables
        var currentBucket = null;
        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var bucket = renderable.bucket;

            // Set the color
            var color = bucket.style.getStrokeColor();
            gl.uniform4f(
                this.basicProgram.uniforms.color,
                color[0],
                color[1],
                color[2],
                color[3] * bucket.layer.getOpacity()
            );

            // Update vertex buffer
            if (!renderable.vertexBuffer) {
                renderable.vertexBuffer = gl.createBuffer();
                renderable.lineIndexBuffer = gl.createBuffer();
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
            gl.vertexAttribPointer(
                this.basicProgram.attributes.vertex,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);

            if (renderable.bufferDirty) {
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(renderable.vertices),
                    gl.STATIC_DRAW
                );
                gl.bufferData(
                    gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(renderable.lineIndices),
                    gl.STATIC_DRAW
                );
                renderable.bufferDirty = false;
            }

            gl.drawElements(
                gl.LINES,
                renderable.lineIndices.length,
                gl.UNSIGNED_SHORT,
                0
            );

            if (bucket.polygonProgram) {
                var program = bucket.polygonProgram;

                program.apply();
                gl.uniformMatrix4fv(
                    program.uniforms.viewProjectionMatrix,
                    false,
                    renderContext.modelViewMatrix
                );

                gl.uniform1i(program.uniforms.texture, 0);
                if (renderable.tcoords.length > 0) {
                    // Use tcoord buffer defined by _imageCoordinates
                    if (!renderable.tcoordBuffer) {
                        renderable.tcoordBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);

                        gl.bufferData(
                            gl.ARRAY_BUFFER,
                            new Float32Array(renderable.tcoords),
                            gl.STATIC_DRAW
                        );
                        renderable.tcoordBuffer.itemSize = 2;
                        renderable.tcoordBuffer.numItems =
                            renderable.tcoords.length / 2;
                    }

                    gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
                } else {
                    // Use default tcoord buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
                }
                gl.vertexAttribPointer(
                    program.attributes.tcoord,
                    2,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                gl.vertexAttribPointer(
                    program.attributes.vertex,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );

                if (
                    bucket.style.fillShader &&
                    bucket.style.fillShader.updateUniforms
                ) {
                    bucket.style.fillShader.updateUniforms(
                        gl,
                        renderable.bucket,
                        program
                    );
                }

                if (!renderable.triangleIndexBuffer) {
                    renderable.triangleIndexBuffer = gl.createBuffer();
                }
                gl.bindBuffer(
                    gl.ELEMENT_ARRAY_BUFFER,
                    renderable.triangleIndexBuffer
                );
                if (renderable.triBufferDirty) {
                    gl.bufferData(
                        gl.ELEMENT_ARRAY_BUFFER,
                        new Uint16Array(renderable.triangleIndices),
                        gl.STATIC_DRAW
                    );
                    renderable.triBufferDirty = false;
                }
                // Add texture
                gl.activeTexture(gl.TEXTURE0);
                if (renderable.bucket.texture) {
                    gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable
                    gl.uniform4f(
                        program.uniforms.color,
                        1.0,
                        1.0,
                        1.0,
                        color[3] * bucket.layer.getOpacity()
                    ); // use whiteColor
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture); // use white texture
                    color = renderable.bucket.style.fillColor;
                    gl.uniform4f(
                        program.uniforms.color,
                        color[0],
                        color[1],
                        color[2],
                        color[3] * bucket.layer.getOpacity()
                    );
                }

                gl.drawElements(
                    gl.TRIANGLES,
                    renderable.triangleIndices.length,
                    gl.UNSIGNED_SHORT,
                    0
                );

                this.basicProgram.apply();
            }
        }

        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.disable(gl.BLEND);
    };

    /**************************************************************************************************************/

    RendererManager.factory.push(function(globe) {
        return new ConvexPolygonRenderer(globe);
    });

    return ConvexPolygonRenderer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Context/AbstractContext',[
    "jquery",
    "underscore-min",
    "../Utils/Event",
    "moment",
    "../Utils/Utils",
    "../Time/Time",
    "../Utils/UtilsIntersection",
    "../Layer/LayerFactory",
    "../Services/ServiceFactory",
    "../Utils/Constants",
    "../Registry/WMSServerRegistryHandler",
    "../Registry/WMTSServerRegistryHandler",
    "../Registry/WCSServerRegistryHandler",
    "../Registry/PendingLayersRegistryHandler",
    "../Registry/LayerRegistryHandler",
    "../Gui/Compass",
    "../Gui/Tracker/PositionTracker",
    "../Gui/Tracker/ElevationTracker",
    "../Utils/AttributionHandler",
    "../Gui/dialog/ErrorDialog",
    "../Renderer/PointRenderer",
    "../Renderer/LineStringRenderable",
    "../Renderer/PolygonRenderer",
    "../Renderer/LineRenderer",
    "../Renderer/PointSpriteRenderer",
    "../Renderer/ConvexPolygonRenderer"
], function (
    $,
    _,
    Event,
    Moment,
    Utils,
    Time,
    UtilsIntersection,
    LayerFactory,
    ServiceFactory,
    Constants,
    WMSServerRegistryHandler,
    WMTSServerRegistryHandler,
    WCSServerRegistryHandler,
    PendingLayersRegistryHandler,
    LayerRegistryHandler,
    Compass,
    PositionTracker,
    ElevationTracker,
    AttributionHandler,
    ErrorDialog
) {
        //TODO : attention de bien garder les ...Renderer dans le define

        /**
         * @constant
         * @type {string}
         * @default
         */
        const DEFAULT_POSITION_TRACKER_ELT = "posTracker";
        /**
         * @constant
         * @type {string}
         * @default
         */
        const DEFAULT_POSITION_TRACKER_ELT_POS = "bottom";
        /**
         * @constant
         * @type {string}
         * @default
         */
        const DEFAULT_ELEVATION_TRACKER_ELT = "elevTracker";
        /**
         * @constant
         * @type {string}
         * @default
         */
        const DEFAULT_ELEVATION_TRACKER_ELT_POS = "bottom";
        /**
         * @constant
         * @type {string}
         * @default
         */
        const DEFAULT_COMPASS_ELT = "compassDiv";

        /**
         * @name AbstractContext
         * @class
         * The active context object can normally be obtained from the {@link module:Context.ContextManager ContextManager}
         * class of the Mizar instance.<br/>
         * A context is the main webGL object that contains its own coordinate reference system,
         * its own data, its own navigation and its own GUI.<br/>
         * Client implementations should not normally instantiate this class directly.
         * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
         * @param {CONTEXT} mode - the type of context
         * @param {AbstractContext.skyContext|AbstractContext.planetContext} ctxOptions - sky or planet options
         * @constructor
         * @implements {Context}
         * @listens Layer#baseLayersReady
         */
        var AbstractContext = function (mizarConfiguration, mode, ctxOptions) {
            Event.prototype.constructor.call(this);
            var self = this;
            this.time = Time.parse(Moment().toISOString());
            this.globe = null; // Sky or globe
            this.navigation = null;
            this.attributionHandler = null;            
            this.components = {};
            this.dataProviders = {};
            this.canvas = mizarConfiguration.canvas;
            this.isMobile = ctxOptions.isMobile;

            // Link to time travel service
            this.timeTravelService = ctxOptions.timeTravelService;

            this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function (
                imagery
            ) {
                // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
                // with empty values. Because of that, the globe cannot be displayed without moving the camera.
                // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
                if (
                    self.getNavigation().getRenderContext().viewMatrix[0] !==
                    "undefined"
                ) {
                    self.getNavigation().computeViewMatrix();
                }
            });
            this.mizarConfiguration = mizarConfiguration.hasOwnProperty(
                "configuration"
            )
                ? mizarConfiguration.configuration
                : {};
            this.ctxOptions = ctxOptions;
            this.mode = mode;
            this.layers = [];
            this.pendingLayers = [];
            this.initCanvas(this.canvas);

            try {
                this.positionTracker = _createTrackerPosition.call(
                    this,
                    this.mizarConfiguration
                );
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }

            try {
                this.elevationTracker = _createTrackerElevation.call(
                    this,
                    this.mizarConfiguration,
                    ctxOptions
                );
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }

            try {
                this.compass = _createCompass.call(this, this.mizarConfiguration);
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }
        };

        function _initComponentsVisibility(components) {
            // Show UI components depending on its state
            for (var componentId in components) {
                if (_isDivExist(componentId)) {
                    if (components[componentId]) {
                        $("#" + componentId).fadeIn(1000);
                    } else {
                        $("#" + componentId).fadeOut();
                    }
                }
            }
        }

        function _isDivExist(divID) {
            return $("#" + divID).length;
        }

        /**
         * Zoom to the selected layer.
         * @param {Layer} layer - selected layer
         * @private
         */
        function _handleCameraWhenLayerAdded(layer) {
            if (
                layer.isVisible() &&
                layer.getProperties() &&
                !layer.isBackground() &&
                layer.getProperties().hasOwnProperty("initialRa") &&
                layer.getProperties().hasOwnProperty("initialDec")
            ) {
                var fov = layer.getProperties().initialFov
                    ? layer.getProperties().initialFov
                    : layer
                        .getGlobe()
                        .getRenderContext()
                        .getFov();
                var navigation = layer.callbackContext.getNavigation();
                var center = navigation.getCenter();
                var globeType = layer.globe.getType();
                switch (globeType) {
                    case Constants.GLOBE.Sky:
                        navigation.zoomTo(
                            [
                                layer.getProperties().initialRa,
                                layer.getProperties().initialDec
                            ],
                            {
                                fov: fov,
                                duration: 3000
                            }
                        );
                        break;
                    case Constants.GLOBE.Planet:
                        var bbox = layer.getProperties().bbox;
                        if (
                            UtilsIntersection.isValueBetween(
                                center[0],
                                bbox[0],
                                bbox[2]
                            ) &&
                            UtilsIntersection.isValueBetween(
                                center[1],
                                bbox[1],
                                bbox[3]
                            )
                        ) {
                        } else {
                            var crs = layer.globe.getCoordinateSystem();
                            var planetRadius = crs
                                .getGeoide()
                                .getRealPlanetRadius();
                            var distanceCamera = Utils.computeDistanceCameraFromBbox(
                                bbox,
                                fov,
                                planetRadius,
                                crs.isFlat()
                            );
                            navigation.zoomTo(
                                [
                                    layer.getProperties().initialRa,
                                    layer.getProperties().initialDec
                                ],
                                {
                                    distance: distanceCamera,
                                    duration: 3000
                                }
                            );
                        }
                        break;
                    default:
                        throw new Error(
                            "type " + globeType + " is not implemented",
                            "AbstractContext.js"
                        );
                }
            }
        }

        /**
         * Creates position tracker
         *
         * When no position tracker element is defined in the configuration,
         * then {@link DEFAULT_POSITION_TRACKER_ELT} is the default element
         * @param {Mizar.configuration} mizarConfiguration
         * @returns {PositionTracker} positionTracker object or null when the tracker is not configured
         * @throws {ReferenceError} Can't get the Div to insert the tracker
         * @private
         */
        function _createTrackerPosition(mizarConfiguration) {
            return new PositionTracker({
                element:
                    mizarConfiguration.positionTracker &&
                        mizarConfiguration.positionTracker.element
                        ? mizarConfiguration.positionTracker.element
                        : DEFAULT_POSITION_TRACKER_ELT,
                isMobile: mizarConfiguration.isMobile,
                position:
                    mizarConfiguration.positionTracker &&
                        mizarConfiguration.positionTracker.position
                        ? mizarConfiguration.positionTracker.position
                        : DEFAULT_ELEVATION_TRACKER_ELT_POS
            });
        }

        /**
         * Creates elevation tracker.
         * When no elevation tracker element is defined in the configuration,
         * then {@link DEFAULT_ELEVATION_TRACKER_ELT} is the default element
         * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
         * @param {AbstractContext.planetContext} ctxOptions - options
         * @returns {ElevationTracker} elevationTracker object or null when the tracker is not configured
         * @throws {ReferenceError} Can't get the Div to insert the tracker
         * @private
         */
        function _createTrackerElevation(mizarConfiguration, ctxOptions) {
            return new ElevationTracker({
                element:
                    mizarConfiguration.elevationTracker &&
                        mizarConfiguration.elevationTracker.element
                        ? mizarConfiguration.elevationTracker.element
                        : DEFAULT_ELEVATION_TRACKER_ELT,
                isMobile: mizarConfiguration.isMobile,
                position:
                    mizarConfiguration.elevationTracker &&
                        mizarConfiguration.elevationTracker.elevation
                        ? mizarConfiguration.elevationTracker.position
                        : DEFAULT_ELEVATION_TRACKER_ELT_POS,
                elevationLayer:
                    ctxOptions.planetLayer !== undefined
                        ? ctxOptions.planetLayer.elevationLayer
                        : undefined
            });
        }

        /**
         * Creates compass.
         * When no compass element is defined in the configuration,
         * then {@link DEFAULT_COMPASS_ELT} is the default element
         * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
         * @returns {Compass}
         * @throws {ReferenceError} can't get the div to insert the compass
         * @private
         */
        function _createCompass(mizarConfiguration) {
            return new Compass({
                element: mizarConfiguration.compass
                    ? mizarConfiguration.compass
                    : DEFAULT_COMPASS_ELT,
                ctx: this,
                isMobile: this.isMobile
            });
        }

        /**
         * Adds to the globe either as background or as additional layer
         * @param {Layer} layer - layer to add.
         * @private
         */
        function _addToGlobe(layer) {
            if (!this._getGlobe().hasDefinedBackground() && layer.isBackground() && layer.isVisible()) {
                this._getGlobe().setBaseImagery(layer);
            } else {
                this._getGlobe().addLayer(layer);
            }
        }

        /**
         * Removes the layer from rasterOverlayRenderer and set the background attribute to true.
         * 
         * When the user uses setBackgroundLayer or setBackgroundLayerByID,
         * the layer had background = false as attribute , so it was add it as a simple overlay. 
         * To add the layer as background, first we need to remove it from rasterOverlayRenderer.
         * @param {Layer} layer
         * @private 
         */
        function _removeRasterOverlay(layer) {
            if (layer.getInformationType() === Constants.INFORMATION_TYPE.RASTER 
            && !layer.isBackground()) {
                this._getGlobe().rasterOverlayRenderer.removeOverlay(layer);
                layer.background = true;
            }
        }        

        /**************************************************************************************************************/
        Utils.inherits(Event, AbstractContext);
        /**************************************************************************************************************/

        /**
         * @function getTime
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getTime = function () {
            return this.time;
        };

        /**
         * @function setTime
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.setTime = function (time) {
            this.time = Time.parse(time);
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layer.setTime(this.time);
            }
        };

        /**
         * ShowUp message.<br/>
         * Do not display the canvas with the ID <i>MizarCanvas</i> and the loading icon and displays
         * the HTML element with the ID <i>webGLNotAvailable</i>
         * @param err
         * @protected
         * @todo Mettre en paramtre MizarCanvas et webGLNotAvailable
         */
        AbstractContext.prototype._showUpError = function (err) {
            console.error("Globe creation error : ", err);
            if (document.getElementById("MizarCanvas")) {
                document.getElementById("MizarCanvas").style.display = "none";
            }
            if (document.getElementById("loading")) {
                document.getElementById("loading").style.display = "none";
            }
            if (document.getElementById("webGLNotAvailable")) {
                document.getElementById("webGLNotAvailable").style.display =
                    "block";
            }
        };

        /**
         * Fill data-provider-type layer by features coming from data object
         * @function _fillDataProvider
         * @param {Layer} layer - layer in which data should be added.
         * @param {Object} mizarDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
         * @memberof AbstractContext#
         * @protected
         */
        AbstractContext.prototype._fillDataProvider = function (
            layer,
            mizarDescription
        ) {
            if (
                mizarDescription.data &&
                this.dataProviders[mizarDescription.data.type]
            ) {
                var callback = this.dataProviders[mizarDescription.data.type];
                callback(layer, mizarDescription.data);
            }
        };

        /**
         * Returns the data provider layers or an empty array when no data provider layer.
         * @function getDataProviderLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getDataProviderLayers = function () {
            var dpLayers = [];
            var layers = this.getLayers();
            var i = layers.length;
            var layer = layers[i];
            while (layer) {
                if (
                    layer.hasOwnProperty("options") &&
                    layer.options.hasOwnProperty("type") &&
                    layer.options.type === Constants.LAYER.GeoJSON
                ) {
                    dpLayers.push(layer);
                }
                layer = layers[++i];
            }
            return dpLayers;
        };

        /**
         * @function getTileManager
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getTileManager = function () {
            return this._getGlobe().getTileManager();
        };

        /**
         * Registers no standard data provider and call them in the addLayer method.
         * @function registerNoStandardDataProvider
         * @param {string} type - data provider key
         * @param {Function} loadFunc - Function
         * @memberof AbstractContext#
         * @example <caption>Registers planets on the sky</caption>
         *   var planetProvider = ProviderFactory.create(Constants.PROVIDER.Planet);
         *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
         */
        AbstractContext.prototype.registerNoStandardDataProvider = function (
            type,
            loadFunc
        ) {
            this.dataProviders[type.toString()] = loadFunc;
        };

        /**
         * @function getContextConfiguration
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getContextConfiguration = function () {
            return this.ctxOptions;
        };

        /**
         * @function getMizarConfiguration
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getMizarConfiguration = function () {
            return this.mizarConfiguration;
        };

        /**
         * @function _getGlobe
         * @memberof AbstractContext#
         * @private
         */
        AbstractContext.prototype._getGlobe = function () {
            return this.globe;
        };

        /**
         * @function getLonLatFromPixel
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getLonLatFromPixel = function (x, y) {
            return this._getGlobe().getLonLatFromPixel(x, y);
        };

        /**
         * @function getPixelFromLonLat
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getPixelFromLonLat = function (
            longitude,
            latitude
        ) {
            return this._getGlobe().getPixelFromLonLat(longitude, latitude);
        };

        /**
         * @function getElevation
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getElevation = function (lon, lat) {
            return this._getGlobe().getElevation(lon, lat);
        };

        /**
         * @function getPositionTracker
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getPositionTracker = function () {
            return this.positionTracker;
        };

        /**
         * @function getElevationTracker
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getElevationTracker = function () {
            return this.elevationTracker;
        };

        /**
         * @function getLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getLayers = function () {
            return this.layers;
        };

        /**
         * @function getLayerByID
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getLayerByID = function (layerId) {
            return _.find(_.union(this.getLayers()), function (layer) {
                return layer.getID() === layerId;
            });
        };

        /**
         * @function getLayerByName
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getLayerByName = function (layerName) {
            return _.findWhere(this.getLayers(), { name: layerName });
        };

        /**
         * @function addLayer
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.addLayer = function (
            layerDescription,
            callback,
            fallback
        ) {

            var pendingLayersHandler = new PendingLayersRegistryHandler(
                this.pendingLayers,
                this.layers
            );
            var wmsServerHandler = new WMSServerRegistryHandler(
                this.getMizarConfiguration(),
                this.pendingLayers
            );
            var wmtsServerHandler = new WMTSServerRegistryHandler(
                this.getMizarConfiguration(),
                this.pendingLayers
            );
            var wcsServerHandler = new WCSServerRegistryHandler(
                this.layers,
                this.getMizarConfiguration(),
                this.pendingLayers
            );
            var layerHandler = new LayerRegistryHandler(this.pendingLayers);

            pendingLayersHandler.setNext(wmsServerHandler);
            wmsServerHandler.setNext(wmtsServerHandler);
            wmtsServerHandler.setNext(wcsServerHandler);
            wcsServerHandler.setNext(layerHandler);

            var self = this;
            pendingLayersHandler.handleRequest(
                layerDescription,
                function (layers) {
                    for (var i = 0; i < layers.length; i++) {
                        var layer = layers[i];
                        layer.callbackContext = self;

                        self.layers.push(layer);

                        // Take autoFillTimeTravel into account
                        if (layer.autoFillTimeTravel === true) {
                            // Only when visible & time travel service activated and available
                            if (
                                layer.visible === true &&
                                self.timeTravelService &&
                                typeof self.timeTravelService !== "undefined"
                            ) {
                                self.timeTravelService.update(
                                    layer.timeTravelValues
                                );
                            }
                        }

                        _addToGlobe.call(self, layer);

                        self._fillDataProvider(layer, layerDescription);
                        if (layer.isVisible()) {
                            layer.setTime(self.getTime());
                        }

                        if (layer.isPickable()) {
                            ServiceFactory.create(
                                Constants.SERVICE.PickingManager
                            ).addPickableLayer(layer);
                        }

                        layer.subscribe(
                            Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED,
                            _handleCameraWhenLayerAdded
                        );

                        //if (layer.addEventTime) {
                        //    layer.addEventTime();
                        //}

                        if (callback) {
                            callback(layer.ID);
                        }
                    }
                },
                function (e) {
                    if (fallback) {
                        fallback(e);
                    }
                }
            );
        };

        /**
         * @function getLinkedLayers
         * @memberof AbstractContext#
         * @return {Array} Array of linked layers
         * @private
         */

        AbstractContext.prototype.getLinkedLayers = function (layerID) {
            // Search linked layers
            var indexes = $.map(this.layers, function (obj, index) {
                if (obj.linkedTo === layerID) {
                    return index;
                }
            });
            var linkedLayers = [];
            for (var i = 0; i < indexes.length; i++) {
                linkedLayers.push(this.layers[indexes[i]]);
            }
            return linkedLayers;
        };

        /**
         * @function removeLayer
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.removeLayer = function (layerID) {
            var removedLayer = null;
            var indexes = $.map(this.layers, function (obj, index) {
                if (obj.ID === layerID) {
                    return index;
                }
            });

            if (indexes.length > 0) {
                // At least one layer to remove
                var removedLayers = this.layers.splice(indexes[0], 1);
                removedLayer = removedLayers[0];
                if (removedLayer.autoFillTimeTravel === true) {
                    this.timeTravelService.update({
                        remove: { ID: layerID }
                    });
                }
                var tileManager = this.getTileManager();
                tileManager.abortLayerRequests(removedLayer);

                removedLayer.unsubscribe(
                    Constants.EVENT_MSG.LAYER_VISIBILITY_CHANGED,
                    _handleCameraWhenLayerAdded
                );
                ServiceFactory.create(
                    Constants.SERVICE.PickingManager
                ).removePickableLayer(removedLayer);

                this._getGlobe().removeLayer(removedLayer);
                this.getRenderContext().requestFrame();
            }
            return removedLayer;
        };

        /**
         * @function removeAllLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.removeAllLayers = function () {
            var nbLayers = this.layers.length;
            while (nbLayers != 0) {
                var layerIndex = nbLayers - 1;
                var layerID = this.layers[layerIndex].ID;
                if (this.attributionHandler != null)
                    this.attributionHandler.removeAttribution(this.layers[layerIndex]);
                this.removeLayer(layerID);
                nbLayers--;
            }
        };

        /**
         * @function addDraw
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.addDraw = function (layer) {
            this._getGlobe().addLayer(layer);
        };

        /**
         * @function removeDraw
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.removeDraw = function (layer) {
            this._getGlobe().removeLayer(layer);
        };

        /**
         * @function refresh
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.refresh = function () {
            if (this._getGlobe()) {
                this._getGlobe().refresh();
            }
        };

        /**************************************************************************************************************/

        /**
         * Initialization of the canvas element.
         * When no canvas element is provided, sets to full screen.
         * @function initCanvas
         * @memberof AbstractContext#
         * @param {Object} canvas Canvas object
         * @param {?Object} canvas.parentElement HTML object
         */
        AbstractContext.prototype.initCanvas = function (canvas) {
            var width, height;
            var parentCanvas = $(canvas.parentElement);

            $(canvas.parentElement)
                .find("#loading")
                .show();

            if ($(canvas).attr("width")) {
                width = $(canvas).attr("width");
            } else if (parentCanvas.attr("width")) {
                width = parentCanvas.attr("width");
            } else {
                //full screen
                width = window.innerWidth;
            }

            if ($(canvas).attr("height")) {
                height = $(canvas).attr("height");
            } else if (parentCanvas.attr("height")) {
                height = parentCanvas.attr("height");
            } else {
                //full screen
                height = window.innerHeight;
            }

            canvas.width = width;
            canvas.height = height;

            // Add some useful css properties to parent element
            if (parentCanvas) {
                parentCanvas.css({
                    position: "relative",
                    overflow: "hidden"
                });
            }

            // Define on resize function
            var self = this;
            var onResize = function () {
                if (
                    parentCanvas &&
                    parentCanvas.attr("height") &&
                    parentCanvas.attr("width")
                ) {
                    // Embedded
                    canvas.width = parentCanvas.width();
                    canvas.height = parentCanvas.height();
                } else {
                    // Fullscreen
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                self.refresh();
            };

            // Take into account window resize 1s after resizing stopped
            var timer;
            $(window).resize(function () {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(onResize, 500);
            });

            // Context lost listener
            canvas.addEventListener(
                "webglcontextlost",
                function (event) {
                    // TODO
                    event.preventDefault();
                    document.getElementById("loading").style.display = "none";
                    document.getElementById("webGLContextLost").style.display =
                        "block";
                },
                false
            );
        };

        /**
         * Initializes the planet or sky events.
         * @function iniGlobeEvents
         * @memberof AbstractContext#
         * @param {AbstractGlobe} globe Planet or Sky object
         */
        AbstractContext.prototype.initGlobeEvents = function (globe) {
            if (globe) {
                this.globe = globe;
                this.attributionHandler = new AttributionHandler(this.globe, {
                    element:
                        this.mizarConfiguration.attributionHandler &&
                            this.mizarConfiguration.attributionHandler.element
                            ? this.mizarConfiguration.attributionHandler.element
                            : "globeAttributions"
                });

                if (this.positionTracker != null) {
                    this.positionTracker.attachTo(this);
                    // it will be updated by the position tracker
                    this.setComponentVisibility("posTrackerInfo", false);
                }

                if (this.elevationTracker != null) {
                    this.elevationTracker.attachTo(this);
                }

                if (this.compass != null) {
                    this.compass.attachTo(this);
                }
            } else {
                console.warn("Globe is null in initGlobeEvents");
            }

            _initComponentsVisibility(this.components);

            //When base layer failed to load, open error dialog
            var self = this;
            this.subscribe(Constants.EVENT_MSG.BASE_LAYERS_ERROR, function (layer) {
                $(self.canvas.parentElement)
                    .find("#loading")
                    .hide();
                //JSON.stringify(layer)
                ErrorDialog.open(
                    "Cannot add the layer <font style='color:yellow'><b>" +
                    layer.getName() +
                    "</b></font><font color='grey'><i>(" +
                    layer.getBaseUrl() +
                    " - reason : " +
                    layer.message +
                    ")</i></font>."
                );
            });
        };

        /**************************************************************************************************************/

        /**
         * @function show
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.show = function () {
            this.navigation.start();
            this.showComponents();
        };

        /**
         * @function showComponents
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.showComponents = function () {
            // Show UI components depending on its state
            for (var componentId in this.components) {
                if (_isDivExist(componentId) && this.components[componentId]) {
                    $("#" + componentId).fadeIn(1000);
                }
            }
        };

        /**
         * @function hideComponents
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.hideComponents = function (uiArray) {
            // Hide all the UI components
            for (var componentId in this.components) {
                if (
                    _isDivExist(componentId) &&
                    $.inArray(componentId, uiArray) === -1
                ) {
                    $("#" + componentId).fadeOut();
                }
            }
        };

        /**
         * @function hide
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.hide = function () {
            this.navigation.stopAnimations();
            this.navigation.stop();

            // Hide all the UI components
            for (var componentId in this.components) {
                if (_isDivExist(componentId)) {
                    $("#" + componentId).fadeOut();
                }
            }
        };

        /**
         * @function setComponentVisibility
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.setComponentVisibility = function (
            componentId,
            isVisible
        ) {
            var component = $("#" + componentId);
            if (isVisible) {
                component.show();
            } else {
                component.hide();
            }

            this.components[componentId] = isVisible;
        };

        /**
         * @function getComponentVisibility
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getComponentVisibility = function (componentId) {
            return this.components[componentId];
        };

        /**************************************************************************************************************/

        /**
         * @function showAdditionalLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.showAdditionalLayers = function () {
            _.each(this.visibleLayers, function (layer) {
                layer.setVisible(true);
                if (layer.isPickable()) {
                    ServiceFactory.create(
                        Constants.SERVICE.PickingManager
                    ).addPickableLayer(layer);
                }
            });
        };

        /**
         * @function hideAdditionalLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.hideAdditionalLayers = function () {
            var self = this;
            this.visibleLayers = [];
            var gwLayers = this.getAdditionalLayers();
            _.each(gwLayers, function (layer) {
                if (layer.isVisible()) {
                    layer.setVisible(false);
                    self.visibleLayers.push(layer);
                }
            });
        };

        /**
         * @function setBackgroundLayer
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.setBackgroundLayer = function (survey) {
            //var globe = this.globe;

            // Find the layer by name among all the layers
            var gwLayer = this.getLayerByName(survey);
            if (gwLayer) {
                _removeRasterOverlay.call(this, gwLayer);
                this._getGlobe().setBaseImagery(gwLayer);
            } else {
                this.publish(
                    Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR,
                    layerName + " hasn't been found"
                );
            }
            return gwLayer;
        };

        /**
         * @function setBackgroundLayerByID
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.setBackgroundLayerByID = function (surveyID) {
            // Find the layer by name among all the layers
            var gwLayer = this.getLayerByID(surveyID);
            if (gwLayer) {
                _removeRasterOverlay.call(this, gwLayer);
                this._getGlobe().setBaseImagery(gwLayer);
            } else {
                this.publish(
                    Constants.EVENT_MSG.LAYER_BACKGROUND_ERROR,
                    layerName + " hasn't been found"
                );
            }
            return gwLayer;
        };

        /**
         * @function getAdditionalLayers
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getAdditionalLayers = function () {
            return _.filter(this.layers, function (layer) {
                return layer.category !== "background";
            });
        };

        /**
         * @function getRenderContext
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getRenderContext = function () {
            return this._getGlobe().getRenderContext();
        };

        /**
         * @function disbable
         * @memberof AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.disable = function () {
            if (this.positionTracker) {
                this.positionTracker.detach();
            }
            if (this.elevationTracker) {
                this.elevationTracker.detach();
            }
            if (this.compass) {
                this.compass.detach();
            }
            var i = 0;
            var layer = this.layers[i];
            while (layer) {
                if (this.attributionHandler != null)
                    this.attributionHandler.disable(layer);
                layer = this.layers[++i];
            }
            var renderers = this.getRenderContext().renderers;
            for (var j = 0; j < renderers.length; j++) {
                if (renderers[j].getType() === this.getMode()) {
                    renderers[j].disable();
                }
            }
        };

        /**
         * @function enable
         * @memberof AbstractContext#    
         */
        AbstractContext.prototype.enable = function () {
            if (this.positionTracker != null) this.positionTracker.attachTo(this);

            if (this.elevationTracker != null) this.elevationTracker.attachTo(this);

            if (this.compass != null) this.compass.attachTo(this);

            var i = 0;
            var layer = this.layers[i];
            while (layer) {
                if (layer.isPickable()) {
                    ServiceFactory.create(
                        Constants.SERVICE.PickingManager
                    ).addPickableLayer(layer);
                }
                if (this.AttributionHandler != null)
                    this.attributionHandler.enable(layer);
                layer = this.layers[++i];
            }
            var renderers = this.getRenderContext().renderers;
            for (i = 0; i < renderers.length; i++) {
                if (renderers[i].getType() === this.getMode()) {
                    renderers[i].enable();
                }
            }
        };

        /**
         * @function setCompassVisible
         * @memberof AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.setCompassVisible = function (divName, visible) {
            throw new SyntaxError(
                "compass visible not implemented",
                "AbstractContext.js"
            );
        };

        /**
         * @function setTimeTravelVisible
         * @memberof AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.setTimeTravelVisible = function (
            divName,
            visible
        ) {
            throw new SyntaxError(
                "time travel visible not implemented",
                "AbstractContext.js"
            );
        };

        /**
         * @function getMode
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getMode = function () {
            return this.mode;
        };

        /**
         * @function setCoordinateSystem
         * @memberof AbstractContext#
         * @abstract        
         */
        AbstractContext.prototype.setCoordinateSystem = function (cs) {
            throw new SyntaxError("CRS not implemented", "AbstractContext.js");
        };

        /**
         * @function getNavigation
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getNavigation = function () {
            return this.navigation;
        };

        /**
         * @function getCoordinateSystem
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.getCoordinateSystem = function () {
            return this._getGlobe().getCoordinateSystem();
        };

        /**
         * @function addAnimation
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.addAnimation = function (anim) {
            this._getGlobe().addAnimation(anim);
        };

        /**
         * @function removeAnimation
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.removeAnimation = function (anim) {
            this._getGlobe().removeAnimation(anim);
        };

        /**
         * @function render
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.render = function () {
            this._getGlobe().render();
        };

        /**
         * @function dispose
         * @memberof AbstractContext#
         */
        AbstractContext.prototype.dispose = function () {
            this._getGlobe().dispose();
        };

        AbstractContext.prototype.trackerDestroy = function () {
            if (this.elevationTracker) {
                this.elevationTracker.destroy();
                this.elevationTracker = null;
            }
            if (this.positionTracker) {
                this.positionTracker.destroy();
                this.positionTracker = null;
            }
        };

        /**i
         * @function destroy
         * @memberof AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.destroy = function () {
            this.hide();
            this.trackerDestroy();
            if (this.compass) {
                this.compass.destroy();
                this.compass = null;
            }
            this.removeAllLayers();
            this.components = null;
            this.attributionHandler = null;
            this.layers = null;
            this.visibleLayers = null;
            this.dataProviders = null;
            this.mizarConfiguration = null;
            this.ctxOptions = null;
            this.mode = null;

            this.unsubscribe(Constants.EVENT_MSG.BASE_LAYERS_READY, function (
                imagery
            ) {
                // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
                // with empty values. Because of that, the globe cannot be displayed without moving the camera.
                // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
                if (
                    self.getNavigation().getRenderContext().viewMatrix[0] !==
                    "undefined"
                ) {
                    self.getNavigation().computeViewMatrix();
                }
            });
            if (this.navigation) {
                this.navigation.destroy();
                this.navigation = null;
            }

            if (this._getGlobe()) {
                this._getGlobe().destroy();
                this.globe = null;
            }
            this.canvas = null;
        };

        /**************************************************************************************************************/

        return AbstractContext;
    });

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TilePool',[],function() {
    /**************************************************************************************************************/

    /**
     @constructor
     TilePool constructor
     */
    var TilePool = function(rc) {
        // Private properties
        var gl = rc.gl;
        var glTexturePools = {};
        var glBuffers = [];
        var self = this;

        // Choose floating point texture filtering depending on extension support
        var float_linear_ext = gl.getExtension("OES_texture_float_linear");
        var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;

        // Public properties
        this.numCreatedTextures = 0;
        this.numReusedTextures = 0;

        // Private methods

        /**************************************************************************************************************/

        /**
         Create a new GL texture
         */
        var createNewGLTexture = function(image, texturePool) {
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            if (image.dataType === "byte") {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    gl.LINEAR_MIPMAP_LINEAR
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    gl.LINEAR
                );
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.LUMINANCE,
                    image.width,
                    image.height,
                    0,
                    gl.LUMINANCE,
                    gl.FLOAT,
                    image.typedArray
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    float_filtering
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    float_filtering
                );
            }

            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE
            );
            glTexture.pool = texturePool;
            self.numCreatedTextures++;

            return glTexture;
        };

        /**************************************************************************************************************/

        /**
         Reuse a GL texture
         */
        var reuseGLTexture = function(image, texturePool) {
            var glTexture = texturePool.pop();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);

            if (image.dataType === "byte") {
                //gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image
                );
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.LUMINANCE,
                    image.width,
                    image.height,
                    0,
                    gl.LUMINANCE,
                    gl.FLOAT,
                    image.typedArray
                );
            }

            self.numReusedTextures++;

            return glTexture;
        };

        /**
         * Get or create a texture pool for the given image
         */
        var getOrCreateTexturePool = function(image) {
            var key = image.dataType + image.width;
            if (!glTexturePools[key]) {
                glTexturePools[key] = [];
            }
            return glTexturePools[key];
        };

        // Public methods

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLTexture = function(image) {
            var texturePool = getOrCreateTexturePool(image);

            if (texturePool.length > 0) {
                return reuseGLTexture(image, texturePool);
            } else {
                return createNewGLTexture(image, texturePool);
            }
        };

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLBuffer = function(vertices) {
            var vb;
            if (glBuffers.length > 0) {
                vb = glBuffers.pop();
            } else {
                vb = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, vb);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            return vb;
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLTexture = function(texture) {
            texture.pool.push(texture);
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLBuffer = function(buffer) {
            glBuffers.push(buffer);
        };

        /**************************************************************************************************************/

        /**
         Dispose all
         */

        this.disposeAll = function() {
            var i;
            for (var key in glTexturePools) {
                if (glTexturePools.hasOwnProperty(key)) {
                    var glTextures = glTexturePools[key];
                    for (i = 0; i < glTextures.length; i++) {
                        gl.deleteTexture(glTextures[i]);
                    }
                }
            }
            glTexturePools = {};

            for (i = 0; i < glBuffers.length; i++) {
                gl.deleteBuffer(glBuffers[i]);
            }
            glBuffers.length = 0;
        };

        /**************************************************************************************************************/
    };

    return TilePool;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileRequest',["./Tile", "../Utils/ImageRequest"], function(Tile, ImageRequest) {
    /**************************************************************************************************************/

    /**************************************************************************************************************/

    /** @constructor
     TileRequest constructor
     */
    var TileRequest = function(tileManager) {
        // Private variables
        var _imageLoaded = false;
        var _elevationLoaded = true;
        var _xhr = new XMLHttpRequest();
        var _imageRequest;

        // Public variables
        this.tile = null;
        this.elevations = null;
        this.image = null;

        var self = this;

        /**
         Handle when elevation is loaded
         */
        var _handleLoadedElevation = function() {
            self.elevations = tileManager.elevationProvider.parseElevations(
                _xhr.responseText
            );
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(self),
                    1
                );
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading elevation failed
         */
        var _handleErrorElevation = function() {
            self.elevations = null;
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(self),
                    1
                );
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        // Setup the XHR callback
        _xhr.onreadystatechange = function(e) {
            if (_xhr.readyState === 4) {
                if (_xhr.status === 200) {
                    _handleLoadedElevation();
                } else {
                    _handleErrorElevation();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when image is loaded
         */
        var _handleLoadedImage = function() {
            // The method can be called twice when the image is in the cache (see launch())
            if (!_imageLoaded) {
                _imageLoaded = true;
                if (_elevationLoaded) {
                    // Call post-process function if defined
                    if (
                        tileManager.imageryProvider &&
                        tileManager.imageryProvider.handleImage
                    ) {
                        tileManager.imageryProvider.handleImage(_imageRequest);
                    }

                    tileManager.pendingRequests.splice(
                        tileManager.pendingRequests.indexOf(self),
                        1
                    );
                    tileManager.completedRequests.push(self);
                    tileManager.renderContext.requestFrame();
                }
                self.image = _imageRequest.image;
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading image failed
         */
        var _handleErrorImage = function() {
            self.tile.state = Tile.State.ERROR;
            tileManager.pendingRequests.splice(
                tileManager.pendingRequests.indexOf(self),
                1
            );
            tileManager.availableRequests.push(self);
        };

        /**************************************************************************************************************/

        /**
         Abort request
         */
        var _handleAbort = function() {
            self.tile.state = Tile.State.NONE;
            tileManager.pendingRequests.splice(
                tileManager.pendingRequests.indexOf(self),
                1
            );
            tileManager.availableRequests.push(self);
        };

        /**************************************************************************************************************/

        /**
         Launch the HTTP request for a tile
         */
        this.launch = function(tile) {
            tile.state = Tile.State.LOADING;
            this.tile = tile;
            tileManager.pendingRequests.push(this);

            this.image = null;
            this.elevations = null;

            // Request the elevation if needed
            if (tileManager.elevationProvider) {
                // TODO : handle the elevations coming from cache
                _elevationLoaded = false;
                _xhr.open("GET", tileManager.elevationProvider.getUrl(tile));

                // Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top
                var useCredentials =
                    tileManager.elevationProvider.crossOrigin ===
                    "use-credentials";
                _xhr.withCredentials = useCredentials;

                _xhr.send();
            } else {
                _elevationLoaded = true;
            }

            if (tileManager.imageryProvider) {
                if (!_imageRequest) {
                    _imageRequest = new ImageRequest({
                        successCallback: function() {
                            _handleLoadedImage();
                            if (tileManager.imageryProvider.cache) {
                                tileManager.imageryProvider.cache.storeInCache(
                                    self
                                );
                            }
                        },
                        failCallback: _handleErrorImage,
                        abortCallback: _handleAbort
                    });
                }

                // Check if the image isn't already loaded in cache
                var cachedTileRequest;
                if (tileManager.imageryProvider.cache) {
                    cachedTileRequest = cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(
                        tile
                    );
                }

                _imageLoaded = false;
                if (cachedTileRequest) {
                    _imageRequest.image = cachedTileRequest.image;
                    _handleLoadedImage();
                } else {
                    // Tile not found in cache or cache isn't activated, send the request
                    _imageRequest.send(
                        tileManager.imageryProvider.getUrl(tile),
                        tileManager.imageryProvider.crossOrigin
                    );
                }
            } else {
                _imageLoaded = true;
            }

            // Check if there is nothing to load
            if (
                !tileManager.imageryProvider &&
                !tileManager.elevationProvider
            ) {
                tileManager.pendingRequests.splice(
                    tileManager.pendingRequests.indexOf(this),
                    1
                );
                tileManager.completedRequests.push(this);
            }
        };

        /**************************************************************************************************************/

        /**
         *    Abort launched request
         */
        this.abort = function() {
            if (_imageRequest) {
                _imageRequest.abort();
            }
        };
    };

    /**************************************************************************************************************/

    return TileRequest;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileIndexBuffer',[],function() {
    /**************************************************************************************************************/

    /**
     @constructor TileIndexBuffer
     TileIndexBuffer
     */
    var TileIndexBuffer = function(renderContext, config) {
        this.renderContext = renderContext;
        this.config = config;
        this.solidIndexBuffer = null;
        this.indices = null;
        this.subSolidIndexBuffer = [null, null, null, null];
        this.subIndices = [null, null, null, null];
    };

    /**************************************************************************************************************/

    /**
     * Reset the index buffers.
     */
    TileIndexBuffer.prototype.reset = function() {
        var gl = this.renderContext.gl;
        for (var i = 0; i < 4; i++) {
            if (this.subSolidIndexBuffer[i]) {
                gl.deleteBuffer(this.subSolidIndexBuffer[i]);
                this.subSolidIndexBuffer[i] = null;
            }
        }
        if (this.solidIndexBuffer) {
            gl.deleteBuffer(this.solidIndexBuffer);
            this.solidIndexBuffer = null;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Get index buffer for sub solid
     */
    TileIndexBuffer.prototype.getSubSolid = function(ii) {
        if (this.subSolidIndexBuffer[ii] === null) {
            var i = ii % 2;
            var j = Math.floor(ii / 2);
            var n, k;

            var size = this.config.tesselation;
            var halfTesselation = (size - 1) / 2;

            // Build the sub grid for 'inside' tile
            var indices = [];
            for (n = halfTesselation * j; n < halfTesselation * (j + 1); n++) {
                for (
                    k = halfTesselation * i;
                    k < halfTesselation * (i + 1);
                    k++
                ) {
                    indices.push(n * size + k);
                    indices.push((n + 1) * size + k);
                    indices.push(n * size + k + 1);

                    indices.push(n * size + k + 1);
                    indices.push((n + 1) * size + k);
                    indices.push((n + 1) * size + k + 1);
                }
            }

            this.subIndices[ii] = indices;

            if (this.config.skirt) {
                // Build skirts
                // Top skirt
                var start = j === 0 ? size * size : size * size + 4 * size;
                var src = j === 0 ? 0 : halfTesselation * size;
                for (
                    n = halfTesselation * i;
                    n < halfTesselation * (i + 1);
                    n++
                ) {
                    indices.push(start + n);
                    indices.push(src + n);
                    indices.push(start + n + 1);

                    indices.push(start + n + 1);
                    indices.push(src + n);
                    indices.push(src + n + 1);
                }

                // Bottom skirt
                start = j === 0 ? size * size + 4 * size : size * size + size;
                src = j === 0 ? halfTesselation * size : (size - 1) * size;
                for (
                    n = halfTesselation * i;
                    n < halfTesselation * (i + 1);
                    n++
                ) {
                    indices.push(src + n);
                    indices.push(start + n);
                    indices.push(src + n + 1);

                    indices.push(src + n + 1);
                    indices.push(start + n);
                    indices.push(start + n + 1);
                }

                // Left skirt
                start =
                    i === 0 ? size * size + 2 * size : size * size + 5 * size;
                src = i === 0 ? 0 : halfTesselation;
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(start + k);
                    indices.push(start + k + 1);
                    indices.push(src + k * size);

                    indices.push(src + k * size);
                    indices.push(start + k + 1);
                    indices.push(src + (k + 1) * size);
                }

                // Right skirt
                start =
                    i === 0 ? size * size + 5 * size : size * size + 3 * size;
                src = i === 0 ? halfTesselation : size - 1;
                for (
                    k = halfTesselation * j;
                    k < halfTesselation * (j + 1);
                    k++
                ) {
                    indices.push(k * size + src);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k);

                    indices.push(start + k);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW
            );
            ib.numIndices = indices.length;
            this.subSolidIndexBuffer[ii] = ib;
        }

        return this.subSolidIndexBuffer[ii];
    };

    /**************************************************************************************************************/

    /*
     Build index buffer
     */
    TileIndexBuffer.prototype.getSolid = function() {
        if (this.solidIndexBuffer === null) {
            var i, j;
            var size = this.config.tesselation;
            this.indices = [];
            // Build the grid
            for (j = 0; j < size - 1; j++) {
                for (i = 0; i < size - 1; i++) {
                    this.indices.push(j * size + i);
                    this.indices.push((j + 1) * size + i);
                    this.indices.push(j * size + i + 1);

                    this.indices.push(j * size + i + 1);
                    this.indices.push((j + 1) * size + i);
                    this.indices.push((j + 1) * size + i + 1);
                }
            }

            if (this.config.skirt) {
                // Top skirt
                var start = size * size;
                for (i = 0; i < size - 1; i++) {
                    this.indices.push(start + i);
                    this.indices.push(i);
                    this.indices.push(start + i + 1);

                    this.indices.push(start + i + 1);
                    this.indices.push(i);
                    this.indices.push(i + 1);
                }

                // Bottom skirt
                start += size;
                for (i = 0; i < size - 1; i++) {
                    this.indices.push((size - 1) * size + i);
                    this.indices.push(start + i);
                    this.indices.push((size - 1) * size + i + 1);

                    this.indices.push((size - 1) * size + i + 1);
                    this.indices.push(start + i);
                    this.indices.push(start + i + 1);
                }

                // Left skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    this.indices.push(start + j);
                    this.indices.push(start + j + 1);
                    this.indices.push(j * size);

                    this.indices.push(j * size);
                    this.indices.push(start + j + 1);
                    this.indices.push((j + 1) * size);
                }

                // Right skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    this.indices.push(j * size + size - 1);
                    this.indices.push((j + 1) * size + size - 1);
                    this.indices.push(start + j);

                    this.indices.push(start + j);
                    this.indices.push((j + 1) * size + size - 1);
                    this.indices.push(start + j + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(this.indices),
                gl.STATIC_DRAW
            );
            this.numIndices = this.indices.length;

            this.solidIndexBuffer = ib;
            this.solidIndexBuffer.numIndices = this.indices.length;
        }

        return this.solidIndexBuffer;
    };

    /**************************************************************************************************************/

    return TileIndexBuffer;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileManager',[
    "./Tile",
    "./GeoTiling",
    "./TilePool",
    "./TileRequest",
    "./TileIndexBuffer",
    "../Renderer/Program",
    "../Utils/Constants"
], function (
    Tile,
    GeoTiling,
    TilePool,
    TileRequest,
    TileIndexBuffer,
    Program,
    Constants
) {

        /**
         * baseLayersError.
         *
         * @event TileManager#baseLayersError
         * @type {Layer}
         */

        /**
         * baseLayersReady.
         *
         * @event TileManager#baseLayersReady
         * @type {Layer}
         */

        /**
         * startBackgroundLoad.
         * Called when background layers (imagery and/or elevation) start to be loaded
         * @event TileManager#startBackgroundLoad
         */

        /**
         * endBackgroundLoad.<br/>
         * Called when background layers (imagery and/or elevation) end loading
         * @event TileManager#endBackgroundLoad
         */         

        /** @constructor
         * TileManager constructor
         *
         * Take in parameters its parent : can be a globe or a sky
         */
        var TileManager = function (parent, options) {
            //TOOD f(tile)
            // this.processedLevel = 0;
            this.parent = parent;
            this.publishEvent = options.publishEvent;
            this.renderContext = this.parent.renderContext;
            // Create a new tile pool or use the one from the parent
            this.tilePool = parent.tilePool || new TilePool(this.renderContext);
            this.tiling = new GeoTiling(4, 2); // Use geo tiling by default

            this.imageryProvider = null;
            this.elevationProvider = null;
            this.tilesToRender = [];
            this.visibleTiles = [];
            this.tilesToRequest = [];
            this.postRenderers = [];

            // Init default texture
            var gl = this.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var defaultColor = options.defaultColor
                ? options.defaultColor
                : [200, 200, 200, 255];
            var pixel = new Uint8Array(defaultColor);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA,
                1,
                1,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                pixel
            );

            // Tile requests : limit to 4 at a given time
            this.maxRequests = 4;
            this.availableRequests = [];
            for (var i = this.maxRequests; i--;) {
                this.availableRequests[i] = new TileRequest(this);
            }
            this.pendingRequests = [];
            this.completedRequests = [];

            this.level0TilesLoaded = false;

            // Configuration for tile
            this.tileConfig = {
                tesselation: 9,
                skirt: true,
                cullSign: 1.0,
                imageSize: 256,
                vertexSize: this.renderContext.lighting ? 6 : 3,
                normals: this.renderContext.lighting,
                coordinateSystem: this.parent.coordinateSystem
            };
            this.level0Tiles = this.tiling.generateLevelZeroTiles(
                this.tileConfig,
                this.tilePool
            );

            // Shared index and texture coordinate buffer : all tiles uses the same
            this.tcoordBuffer = null;
            this.tileIndexBuffer = new TileIndexBuffer(
                this.renderContext,
                this.tileConfig
            );

            // HACK : to fix sky rendering, sets to false
            this.renderTileWithoutTexture = options.hasOwnProperty(
                "renderTileWithoutTexture"
            )
                ? options.renderTileWithoutTexture
                : true;

            // For debug
            this.freeze = false;

            // Stats
            this.numTilesGenerated = 0;
            this.frameNumber = 0;

            this.vertexShader = "attribute vec3 vertex;\n";
            this.vertexShader += "attribute vec2 tcoord;\n";
            this.vertexShader += "uniform mat4 modelViewMatrix;\n";
            this.vertexShader += "uniform mat4 projectionMatrix;\n";
            this.vertexShader += "varying vec2 texCoord;\n";
            if (this.renderContext.lighting) {
                this.vertexShader +=
                    "attribute vec3 normal;\nvarying vec3 color;\n";
            }
            this.vertexShader += "void main(void) \n";
            this.vertexShader += "{\n";
            this.vertexShader +=
                "gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
            if (this.renderContext.lighting) {
                this.vertexShader +=
                    "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
            }
            this.vertexShader += "texCoord = tcoord;\n";
            this.vertexShader += "}\n";

            this.fragmentShader = "precision lowp float; \n";
            this.fragmentShader += "varying vec2 texCoord;\n";
            if (this.renderContext.lighting) {
                this.fragmentShader += "varying vec3 color;\n";
            }
            this.fragmentShader += "uniform sampler2D colorTexture;\n";
            this.fragmentShader += "void main(void)\n";
            this.fragmentShader += "{\n";
            this.fragmentShader +=
                "	gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
            if (this.renderContext.lighting) {
                this.fragmentShader += "  gl_FragColor.rgb *= color;\n";
            }
            this.fragmentShader += "  gl_FragColor.a = 1.0;\n";
            this.fragmentShader += "}\n";

            this.program = new Program(this.renderContext);
            this.program.createFromSource(this.vertexShader, this.fragmentShader);
        };

        /**
        * Updates overlay of the layer with the updated layer
        * @param renderable renderer related to the current layer
        * @param layer updated layer
        * @private
        */
        function _updateOverlay(renderable, layer) {
            var bucket = renderable.bucket;
            bucket.renderer.removeOverlay(bucket.layer);
            bucket.renderer.addOverlay(layer);
        }

        function _abortTilesForLayer(tiles, layer, callback) {
            for (var i = tiles.length; i--;) {
                var tile = tiles[i];
                var extension = tile.extension;
                if (extension && extension.renderer) {
                    var renderables = extension.renderer.renderables;
                    for (
                        var renderableIdx = renderables.length;
                        renderableIdx--;

                    ) {
                        var renderable = renderables[renderableIdx];
                        if (renderable.bucket.layer.ID === layer.getID()) {
                            _abortBucketRequests.call(this, renderable.bucket);
                            if (callback) {
                                callback(renderable, layer);
                            }
                            break;
                        }
                    }
                }
            }
        }

        function _abortBucketRequests(bucket) {
            var renderer = bucket.renderer;
            var imageRequests = renderer.imageRequests;
            if (imageRequests) {
                for (var i = imageRequests.length; i--;) {
                    var request = imageRequests[i];
                    if (request.renderable) {
                        request.abort();
                    }
                }
            }
        }

        /**************************************************************************************************************/

        /**
        * Add post renderer
        */
        TileManager.prototype.addPostRenderer = function (renderer) {
            this.postRenderers.push(renderer);

            this.postRenderers.sort(function (r1, r2) {
                var z1 = r1.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
                var z2 = r2.zIndex | Constants.DISPLAY.DEFAULT_RASTER;
                return z1 - z2;
            });

            if (renderer.generate) {
                this.visitTiles(function (tile) {
                    renderer.generate(tile);
                });
            }
        };

        /**************************************************************************************************************/

        /**
        * Remove a post renderer
        */
        TileManager.prototype.removePostRenderer = function (renderer) {
            var rendererIndex = this.postRenderers.indexOf(renderer);
            if (rendererIndex !== -1) {
                // Remove the renderer from all the tiles if it has a cleanupTile method
                if (renderer.cleanupTile) {
                    this.visitTiles(function (tile) {
                        renderer.cleanupTile(tile);
                    });
                }
                // Remove renderer from the list
                this.postRenderers.splice(rendererIndex, 1);
            }
        };

        /**************************************************************************************************************/

        /**
        * Set the imagery provider to be used
        */
        TileManager.prototype.setImageryProvider = function (ip) {
            this.reset();
            this.imageryProvider = ip;

            if (ip) {
                // Clean tile pool
                this.tilePool.disposeAll();
                this.tiling = ip.tiling;

                // Rebuild level zero tiles
                this.tileConfig.imageSize = ip.tilePixelSize;
                this.level0Tiles = this.tiling.generateLevelZeroTiles(
                    this.tileConfig,
                    this.tilePool
                );

                // Update program
                if (ip.customShader) {
                    this.program.dispose();
                    this.program = new Program(this.renderContext);

                    // Memorize current fragment shader
                    this.currentFragmentShader = ip.customShader.fragmentCode
                        ? ip.customShader.fragmentCode
                        : this.fragmentShader;
                    this.program.createFromSource(
                        ip.customShader.vertexCode
                            ? ip.customShader.vertexCode
                            : this.vertexShader,
                        this.currentFragmentShader
                    );
                } else {
                    // Revert to default if needed
                    if (this.currentFragmentShader !== null) {
                        this.program.dispose();
                        this.program = new Program(this.renderContext);
                        this.program.createFromSource(
                            this.vertexShader,
                            this.fragmentShader
                        );
                        this.currentFragmentShader = null;
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
        * Set the elevation provider to be used
        */
        TileManager.prototype.setElevationProvider = function (tp) {
            this.reset();
            this.elevationProvider = tp;

            var newTesselation = tp ? tp.tilePixelSize : 9;
            if (newTesselation !== this.tileConfig.tesselation) {
                this.tileConfig.tesselation = newTesselation;

                // Reset the shared buffers : texture coordinate and indices
                var gl = this.renderContext.gl;
                this.tileIndexBuffer.reset();
                if (this.tcoordBuffer) {
                    gl.deleteBuffer(this.tcoordBuffer);
                    this.tcoordBuffer = null;
                }
            }
        };

        /**************************************************************************************************************/

        /**
        * Reset the tile manager : unload all tiles
        */
        TileManager.prototype.reset = function () {
            // Abort all pending requests
            this.abortRequests();

            // Reset all level zero tiles : destroy render data, and reset state to NONE
            for (var i = this.level0Tiles.length; i--;) {
                this.level0Tiles[i].deleteChildren(
                    this.renderContext,
                    this.tilePool
                );
                this.level0Tiles[i].dispose(this.renderContext, this.tilePool);
            }

            this.tileIndexBuffer.reset();

            this.level0TilesLoaded = false;
        };

        /**************************************************************************************************************/

        /**
         *    Abort all pending requests
         */
        TileManager.prototype.abortRequests = function () {
            for (var i = this.pendingRequests.length; i--;) {
                this.pendingRequests[i].abort();
            }
        };

        TileManager.prototype.abortLayerRequests = function (layer, callback) {
            //TODO Ce n'est pas sur pendingRequest mais sur les tiles de pending request
            //_abortTilesForLayer.call(this, this.pendingRequests, layer);
            this.abortRequests();
            _abortTilesForLayer.call(this, this.visibleTiles, layer, callback);
        };

        /**
         * Updates the visible tiles of the layer.
         * @param layer the layer where the tiles must be updated
         */
        TileManager.prototype.updateVisibleTiles = function (layer) {
            this.abortLayerRequests(layer, _updateOverlay);
        };

        /**************************************************************************************************************/

        /**
         * Tile visitor
         * @param callback - Callback function on tile
         */
        TileManager.prototype.visitTiles = function (callback) {
            // Store the tiles to process in an array, first copy level0 tiles
            var tilesToProcess = this.level0Tiles.concat([]);

            while (tilesToProcess.length > 0) {
                // Retrieve the first tile and remove it from the array
                var tile = tilesToProcess.shift();

                callback(tile);

                // Add tile children to array to be processed later
                if (tile.children) {
                    tilesToProcess.push(tile.children[0]);
                    tilesToProcess.push(tile.children[1]);
                    tilesToProcess.push(tile.children[2]);
                    tilesToProcess.push(tile.children[3]);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Traverse tiless tiles
         * @fires TileManager#baseLayersReady
         * @fires TileManager#baseLayersError
        */
        TileManager.prototype.traverseTiles = function () {
            this.tilesToRender.length = 0;
            this.visibleTiles.length = 0;
            this.tilesToRequest.length = 0;
            this.numTraversedTiles = 0;
            var i, tile;

            // First load level 0 tiles if needed
            if (!this.level0TilesLoaded) {
                this.level0TilesLoaded = true;
                for (i = this.level0Tiles.length; i--;) {
                    tile = this.level0Tiles[i];

                    var tileIsLoaded = tile.state === Tile.State.LOADED;

                    // Update frame number
                    tile.frameNumber = this.frameNumber;

                    this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
                    if (!tileIsLoaded) {
                        // Request tile if necessary
                        if (tile.state === Tile.State.NONE) {
                            tile.state = Tile.State.REQUESTED;
                            this.tilesToRequest.push(tile);
                        } else if (
                            tile.state === Tile.State.ERROR &&
                            this.imageryProvider
                        ) {
                            this.publishEvent(
                                Constants.EVENT_MSG.BASE_LAYERS_ERROR,
                                this.imageryProvider
                            );
                        }
                    }
                }
                if (this.level0TilesLoaded && this.imageryProvider) {
                    this.publishEvent(
                        Constants.EVENT_MSG.BASE_LAYERS_READY,
                        this.imageryProvider
                    );
                }
            }

            // Traverse tiles
            if (this.level0TilesLoaded) {
                // Normal traversal, iterate through level zero tiles and process them recursively
                for (i = this.level0Tiles.length; i--;) {
                    tile = this.level0Tiles[i];
                    if (!tile.isCulled(this.renderContext)) {
                        this.processTile(tile, 0);
                    } else {
                        // Delete its children
                        tile.deleteChildren(this.renderContext, this.tilePool);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
        * Process a tile
        */
        TileManager.prototype.processTile = function (tile, level) {
            this.numTraversedTiles++;

            // Update frame number
            tile.frameNumber = this.frameNumber;

            var isLeaf = true;

            // Request the tile if needed
            if (tile.state === Tile.State.NONE) {
                tile.state = Tile.State.REQUESTED;

                // Add it to the request
                this.tilesToRequest.push(tile);
            }

            // Check if the tiles needs to be refined
            // We only refine loaded tile
            if (tile.state === Tile.State.LOADED) {
                if (this.imageryProvider) {
                    isLeaf = level >= this.imageryProvider.numberOfLevels;
                } else {
                    isLeaf = false;
                }
                isLeaf |= !tile.needsToBeRefined(this.renderContext);
            }

            if (isLeaf) {
                // Push the tiles to render only if the texture is valid or there is no imagery provider defined
                if (tile.texture || this.renderTileWithoutTexture) {
                    this.tilesToRender.push(tile);
                }
                this.visibleTiles.push(tile);
            } else {
                // Create the children if needed
                if (tile.children === null) {
                    tile.createChildren();
                }
                for (var i = 0; i < 4; i++) {
                    if (!tile.children[i].isCulled(this.renderContext)) {
                        this.processTile(tile.children[i], level + 1);
                    } else {
                        tile.children[i].deleteChildren(
                            this.renderContext,
                            this.tilePool
                        );
                    }
                }
            }

            // Traverse extension
            for (var x in tile.extension) {
                if (tile.extension.hasOwnProperty(x)) {
                    var e = tile.extension[x];
                    if (e.traverse) {
                        e.traverse(tile, isLeaf);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
        * Generate tile
        */
        TileManager.prototype.generateTile = function (tile, tileRequest) {
            tile.generate(this.tilePool, tileRequest.image, tileRequest.elevations);

            // Now post renderers can generate their data on the new tile
            for (var i = this.postRenderers.length; i--;) {
                if (this.postRenderers[i].generate) {
                    this.postRenderers[i].generate(tile);
                }
            }

            this.numTilesGenerated++;
            this.renderContext.requestFrame();
        };

        /**************************************************************************************************************/

        /**
        * Generate tiles
        * @fires TileManager#endBackgroundLoad
        */
        TileManager.prototype.generateReceivedTiles = function () {
            while (this.completedRequests.length > 0) {
                var tileRequest = this.completedRequests.pop();
                var tile = tileRequest.tile;
                if (tile.frameNumber === this.frameNumber) {
                    this.generateTile(tile, tileRequest);
                } else {
                    tile.state = Tile.State.NONE;
                }
                this.availableRequests.push(tileRequest);
            }

            // All requests have been processed, send endBackgroundLoad event
            if (
                this.availableRequests.length === this.maxRequests &&
                this.imageryProvider
            ) {
                this.publishEvent(Constants.EVENT_MSG.LAYER_END_BACKGROUND_LOAD);
            }
        };

        /**************************************************************************************************************/

        /**
        * Render tiles
        */
        TileManager.prototype.renderTiles = function () {
            var rc = this.renderContext;
            var gl = rc.gl;
            var i, tile;
            // Compute near/far from tiles
            var nr;
            var fr;
            if (this.tileConfig.cullSign < 0) {
                // When in "Astro" mode, do not compute near/far from tiles not really needed
                // And the code used for "Earth" does not works really well, when the earth is seen from inside...
                // rc.near = Math.max(
                //     rc.minNear,
                //     0.2 * this.tileConfig.coordinateSystem.geoide.radius
                // );
                rc.far = Math.max(
                     rc.minFar,
                     1.1 * this.tileConfig.coordinateSystem.geoide.radius
                 );
            }

            if (this.tilesToRender.length !== 0) {
                // Set state (depends if geo or astro)
                if (this.tileConfig.cullSign < 0) {
                    gl.depthMask(false);
                    gl.disable(gl.DEPTH_TEST);
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.POLYGON_OFFSET_FILL);
                    gl.polygonOffset(0, 4);
                }

                // Check if the program of imagery provider changed
                // Only for fragment shader for now
                if (
                    this.currentFragmentShader &&
                    this.currentFragmentShader !==
                    this.imageryProvider.customShader.fragmentCode
                ) {
                    this.program.dispose();
                    this.program = new Program(this.renderContext);

                    if (this.imageryProvider && this.imageryProvider.customShader) {
                        this.currentFragmentShader = this.imageryProvider
                            .customShader.fragmentCode
                            ? this.imageryProvider.customShader.fragmentCode
                            : this.fragmentShader;
                        this.program.createFromSource(
                            this.imageryProvider.customShader.vertexShader
                                ? this.imageryProvider.customShader.vertexShader
                                : this.vertexShader,
                            this.currentFragmentShader
                        );
                    }
                }

                // Setup program
                this.program.apply();

                var attributes = this.program.attributes;

                // Update projection matrix with new near and far values
                mat4.perspective(
                    rc.fov,
                    rc.canvas.width / rc.canvas.height,
                    rc.near,
                    rc.far,
                    rc.projectionMatrix
                );

                // Update uniforms if needed
                if (this.imageryProvider && this.imageryProvider.customShader) {
                    this.imageryProvider.customShader.updateUniforms(
                        gl,
                        this.program
                    );
                }

                // Setup state
                gl.activeTexture(gl.TEXTURE0);
                gl.uniformMatrix4fv(
                    this.program.uniforms.projectionMatrix,
                    false,
                    rc.projectionMatrix
                );
                gl.uniform1i(this.program.uniforms.colorTexture, 0);

                // Bind the texture coordinate buffer (shared between all tiles
                if (!this.tcoordBuffer) {
                    this.buildSharedTexCoordBuffer();
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
                gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);

                var currentIB = null;

                for (i = this.tilesToRender.length; i--;) {
                    tile = this.tilesToRender[i];

                    var isLoaded = tile.state === Tile.State.LOADED;
                    var isLevelZero = tile.parentIndex === -1;

                    // Bind tile texture if defined, the default texture otherwise
                    if (tile.texture) {
                        gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    } else {
                        gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
                    }

                    // Update uniforms for modelview matrix
                    mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
                    gl.uniformMatrix4fv(
                        this.program.uniforms.modelViewMatrix,
                        false,
                        rc.modelViewMatrix
                    );

                    // Bind the vertex buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                    gl.vertexAttribPointer(
                        attributes.vertex,
                        3,
                        gl.FLOAT,
                        false,
                        4 * this.tileConfig.vertexSize,
                        0
                    );
                    if (this.tileConfig.normals) {
                        gl.vertexAttribPointer(
                            attributes.normal,
                            3,
                            gl.FLOAT,
                            false,
                            4 * this.tileConfig.vertexSize,
                            12
                        );
                    }

                    var indexBuffer =
                        isLoaded || isLevelZero
                            ? this.tileIndexBuffer.getSolid()
                            : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
                    // Bind the index buffer only if different (index buffer is shared between tiles)
                    if (currentIB !== indexBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        currentIB = indexBuffer;
                    }

                    // Finally draw the tiles
                    gl.drawElements(
                        gl.TRIANGLES,
                        currentIB.numIndices,
                        gl.UNSIGNED_SHORT,
                        0
                    );
                }

                if (this.tileConfig.cullSign < 0) {
                    gl.depthMask(true);
                    gl.enable(gl.DEPTH_TEST);
                } else {
                    gl.disable(gl.POLYGON_OFFSET_FILL);
                }
            }

            for (i = this.postRenderers.length; i--;) {
                this.postRenderers[i].render(this.visibleTiles);
            }
        };

        // Internal function to sort tiles
        var _sortTilesByDistance = function (t1, t2) {
            return t1.distance - t2.distance;
        };

        /**************************************************************************************************************/

        /**
        * Request tiles
        * @fires TileManager#startBackgroundLoad
        */
        TileManager.prototype.launchRequests = function () {
            // Process request
            this.tilesToRequest.sort(_sortTilesByDistance);

            var trl = this.tilesToRequest.length;
            for (var i = trl; i--;) {
                var tile = this.tilesToRequest[i];
                if (this.availableRequests.length > 0) {
                    // Check to limit the number of requests done per frame
                    // First launch request, send an event
                    if (
                        this.availableRequests.length === this.maxRequests &&
                        this.imageryProvider
                    ) {
                        this.publishEvent(
                            Constants.EVENT_MSG.LAYER_START_BACKGROUND_LOAD
                        );
                    }

                    var tileRequest = this.availableRequests.pop();
                    tileRequest.launch(tile);
                } else {
                    tile.state = Tile.State.NONE;
                }
            }
        };

        /**************************************************************************************************************/

        /**
        * Render the tiles
        * @fires TileManager#baseLayersReady
        */
        TileManager.prototype.render = function () {
            /*           console.log("TileManager.prototype.render",this.tileConfig.coordSystem);
                 if (this.tileConfig.coordSystem === "GAL") {
                 console.log("No rendering");
                 return;
                 }
                 console.log("============================================");
                 */
            if (this.imageryProvider && !this.imageryProvider._ready) {
                return;
            }

            // Specific case when the image provider has a level zero image : generate the texture for each level zero tile
            if (
                !this.level0TilesLoaded &&
                this.imageryProvider &&
                this.imageryProvider.levelZeroImage
            ) {
                this.imageryProvider.generateLevel0Textures(
                    this.level0Tiles,
                    this.tilePool
                );

                for (var n = this.level0Tiles.length; n--;) {
                    var tile = this.level0Tiles[n];
                    // Generate the tile without tile request
                    this.generateTile(tile, {});
                }

                this.level0TilesLoaded = true;

                this.publishEvent(
                    Constants.EVENT_MSG.BASE_LAYERS_READY,
                    this.imageryProvider
                );
            }

            var stats = this.renderContext.stats;

            if (!this.freeze) {
                if (stats) {
                    stats.start("traverseTime");
                }
                this.traverseTiles();
                if (stats) {
                    stats.end("traverseTime");
                }
            }

            if (this.level0TilesLoaded || !this.imageryProvider) {
                if (stats) {
                    stats.start("renderTime");
                }
                this.renderTiles();
                if (stats) {
                    stats.end("renderTime");
                }
            }

            if (stats) {
                stats.start("generateTime");
            }
            this.generateReceivedTiles();
            if (stats) {
                stats.end("generateTime");
            }

            if (stats) {
                stats.start("requestTime");
            }
            this.launchRequests();
            if (stats) {
                stats.end("requestTime");
            }

            this.frameNumber++;
        };

        /**************************************************************************************************************/

        /**
        * Returns visible tile for given longitude/latitude, null otherwise
        */
        TileManager.prototype.getVisibleTile = function (lon, lat) {
            return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
        };

        /**************************************************************************************************************/

        /**
        * Build shared texture coordinate buffer
        */
        TileManager.prototype.buildSharedTexCoordBuffer = function () {
            var size = this.tileConfig.tesselation;
            var skirt = this.tileConfig.skirt;
            var bufferSize = 2 * size * size;
            if (skirt) {
                bufferSize += 2 * size * 6;
            }

            var tcoords = new Float32Array(bufferSize);

            var step = 1.0 / (size - 1);

            var offset = 0;
            var u, v;
            var i, j;
            v = 0.0;
            for (j = 0; j < size; j++) {
                u = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;

                    offset += 2;
                    u += step;
                }

                v += step;
            }

            if (skirt) {
                // Top skirt
                u = 0.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }
                // Bottom skirt
                u = 0.0;
                v = 1.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }
                // Left skirt
                u = 0.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }
                // Right skirt
                u = 1.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }

                // Center skirt
                u = 0.0;
                v = 0.5;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }

                // Middle skirt
                u = 0.5;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }
            }

            var gl = this.renderContext.gl;
            var tcb = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
            gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);

            this.tcoordBuffer = tcb;
        };

        /**
         * Set freeze
         * @function setFreeze
         * @memberof TileManager.prototype
         * @param {Boolean} freeze Freeze active or not
         */
        TileManager.prototype.setFreeze = function (freeze) {
            this.freeze = freeze;
        };
        /**
         * Get freeze
         * @function getFreeze
         * @memberof TileManager.prototype
         * @return {Boolean} Freeze active or not
         */
        TileManager.prototype.getFreeze = function () {
            return this.freeze;
        };

        /**************************************************************************************************************/

        return TileManager;
    });

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/Frustum',["./glMatrix"], function() {
    /**************************************************************************************************************/

    /**
   @name Plane
   @class
   		Plane constructor
   @constructor
  */
    var Plane = function() {
        this.normal = vec3.create([0.0, 0.0, 0.0]);
        this.d = 0.0;
    };

    /**************************************************************************************************************/

    /**
     * Plane init from 3 points
     * @function init
     * @memberof Plane.prototype
     * @param v1 Point 1
     * @param v2 Point 2
     * @param v3 Point 3
     */
    Plane.prototype.init = function(v1, v2, v3) {
        var vu = [];
        var vv = [];
        vec3.subtract(v2, v1, vu);
        vec3.subtract(v3, v1, vv);
        vec3.cross(vu, vv, this.normal);
        vec3.normalize(this.normal);
        this.d = -vec3.dot(v1, this.normal);
    };

    /**************************************************************************************************************/

    /**
     * Transform the plane with the given matrix
     * @function transform
     * @memberof Plane.prototype
     * @param matrix Transformation matrix
     */
    Plane.prototype.transform = function(matrix) {
        var vec = [this.normal[0], this.normal[1], this.normal[2], this.d];
        mat4.multiplyVec4(matrix, vec);
        this.normal[0] = vec[0];
        this.normal[1] = vec[1];
        this.normal[2] = vec[2];
        this.d = vec[3];
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between plane and bounding sphere.
     * @function intersectSphere
     * @memberof Plane.prototype
     * @param center Center
     * @param radius Radius
     * @return {Integer}
     * <ul>
     *   <li>1 if the bounding sphere is completely above plane,</li>
     *   <li>0 if the bounding sphere intersects the plane,</li>
     *   <li>-1 if the bounding sphere is completely below the plane.</li>
     * </ul>
     */
    Plane.prototype.intersectSphere = function(center, radius) {
        var dist = vec3.dot(center, this.normal) + this.d;
        if (dist > radius) {
            return 1;
        } else {
            if (dist < -radius) {
                return -1;
            } else {
                return 0;
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Return the distance between a point and the plane
     * @function distance
     * @memberof Plane.prototype
     * @param point Point
     * @return {Float} Distance
     */
    Plane.prototype.distance = function(point) {
        return (
            point[0] * this.normal[0] +
            point[1] * this.normal[1] +
            point[2] * this.normal[2] +
            this.d
        );
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between plane and bounding box.
     * @function intersectBoundingBox
     * @memberof Plane.prototype
     * @param {BoundingBox} bbox Bounding box
     * @return {Integer}
     * <ul>
     *   <li>1 if the bbox is completely above plane,</li>
     *   <li>0 if the bbox intersects the plane,</li>
     *   <li>-1 if the bbox is completely below the plane.</li>
     * </ul>
     */
    Plane.prototype.intersectBoundingBox = function(bbox) {
        var upperBBCorner =
            (this.normal[0] >= 0.0 ? 1 : 0) |
            (this.normal[1] >= 0.0 ? 2 : 0) |
            (this.normal[2] >= 0.0 ? 4 : 0);

        var lowerBBCorner = ~upperBBCorner & 7;

        // if lowest point above plane than all above.
        if (this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) {
            return 1;
        }

        // if highest point is below plane then all below.
        if (this.distance(bbox.getCorner(upperBBCorner)) < 0.0) {
            return -1;
        }

        // d_lower<=0.0f && d_upper>=0.0f
        // therefore must be crossing plane.
        return 0;
    };

    /**************************************************************************************************************/

    /**
   @name Frustum
   @class
   		Frustum constructor
   @constructor
  */

    var Frustum = function() {
        // The frustum does not contains near and far plane, because near and far are computed during rendering.
        // Some tests have been done with a near plane but are not really useful
        this.planes = [
            new Plane(),
            new Plane(),
            new Plane(),
            new Plane(),
            new Plane()
        ];
    };

    /**************************************************************************************************************/

    /**
     * Compute the frustum from the given projection matrix
     * @function compute
     * @memberof Frustum.prototype
     * @param projectionMatrix Projection matrix
     */
    Frustum.prototype.compute = function(projectionMatrix) {
        var inverseProjectionMatrix = mat4.create();
        mat4.inverse(projectionMatrix, inverseProjectionMatrix);

        var bottomleft = mat4.project(inverseProjectionMatrix, [
            -1.0,
            -1.0,
            -1.0,
            1.0
        ]);
        var topleft = mat4.project(inverseProjectionMatrix, [
            -1.0,
            1.0,
            -1.0,
            1.0
        ]);
        var topright = mat4.project(inverseProjectionMatrix, [
            1.0,
            1.0,
            -1.0,
            1.0
        ]);
        var bottomright = mat4.project(inverseProjectionMatrix, [
            1.0,
            -1.0,
            -1.0,
            1.0
        ]);

        this.planes[0].init([0.0, 0.0, 0.0], bottomleft, topleft);
        this.planes[1].init([0.0, 0.0, 0.0], topleft, topright);
        this.planes[2].init([0.0, 0.0, 0.0], topright, bottomright);
        this.planes[3].init([0.0, 0.0, 0.0], bottomright, bottomleft);

        // A plane for near plane if needed
        this.planes[4].init(bottomleft, topleft, topright);
    };

    /**************************************************************************************************************/

    /**
     * Transform the frustum with the given matrix
     * @function transform
     * @memberof Frustum.prototype
     * @param frustum
     * @param matrix Matrix
     */
    Frustum.prototype.transform = function(frustum, matrix) {
        var mat = mat4.create();
        mat4.inverse(matrix, mat);
        this.inverseTransform(frustum, mat);
    };

    /**************************************************************************************************************/

    /**
     * Inverse transform the frustum with the given matrix
     * @function inverseTransform
     * @memberof Frustum.prototype
     * @param frustum
     * @param matrix Matrix
     */
    Frustum.prototype.inverseTransform = function(frustum, matrix) {
        // Optimized implementation
        for (var i = 0; i < frustum.planes.length; i++) {
            var plane = frustum.planes[i];

            var x = plane.normal[0];
            var y = plane.normal[1];
            var z = plane.normal[2];
            var w = plane.d;

            plane = this.planes[i];

            plane.normal[0] =
                matrix[0] * x + matrix[1] * y + matrix[2] * z + matrix[3] * w;
            plane.normal[1] =
                matrix[4] * x + matrix[5] * y + matrix[6] * z + matrix[7] * w;
            plane.normal[2] =
                matrix[8] * x + matrix[9] * y + matrix[10] * z + matrix[11] * w;
            plane.d =
                matrix[12] * x +
                matrix[13] * y +
                matrix[14] * z +
                matrix[15] * w;
        }
    };

    /**************************************************************************************************************/

    /**
     * Intersection test between frustum and bounding sphere.
     * @function containsSphere
     * @memberof Frustum.prototype
     * @param {Array} center Center
     * @param {Float} radius Radius
     * @return {Integer}
     * <ul>
     *   <li>1 if the bounding sphere is completely inside the frustum,</li>
     *   <li>0 if the bounding sphere intersects the frustum,</li>
     *   <li>-1 if the bounding sphere is completely outside the frustum.</li>
     * </ul>
     */
    Frustum.prototype.containsSphere = function(center, radius) {
        var flag = 1;

        for (var i = 0; i < this.planes.length; i++) {
            var pn = this.planes[i].normal;

            // Compute distance between center and plane (inline to be more efficient)
            var dist =
                center[0] * pn[0] +
                center[1] * pn[1] +
                center[2] * pn[2] +
                this.planes[i].d;

            if (dist <= radius) {
                if (dist < -radius) {
                    return -1;
                } else {
                    flag = 0;
                }
            }
        }

        return flag;
    };

    /**************************************************************************************************************/

    /**
     * Test if the frustum contains the given bounding box
     * @function containsBoundingBox
     * @memberof Frustum.prototype
     * @param {BoundingBox} bbox Bounding box
     * @return {boolean} Contains ?
     */
    Frustum.prototype.containsBoundingBox = function(bbox) {
        // Optimized implementation
        for (var i = 0; i < this.planes.length; i++) {
            var plane = this.planes[i];

            // Get the closest point on the bbox
            var bbx = plane.normal[0] >= 0.0 ? bbox.max[0] : bbox.min[0];
            var bby = plane.normal[1] >= 0.0 ? bbox.max[1] : bbox.min[1];
            var bbz = plane.normal[2] >= 0.0 ? bbox.max[2] : bbox.min[2];

            // Compute the distance
            var distance =
                bbx * plane.normal[0] +
                bby * plane.normal[1] +
                bbz * plane.normal[2] +
                plane.d;

            // if highest point is below plane then all below.
            if (distance < 0.0) {
                return false;
            }
        }

        return true;
    };

    /**************************************************************************************************************/

    // Export plane
    Frustum.Plane = Plane;

    return Frustum;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/RenderContext',["./Frustum", "./glMatrix"], function(Frustum) {
    /**************************************************************************************************************/
    /**
         @name RenderContext
         @class
             RenderContext constructor
         @param options Configuration properties for the Planet :
         <ul>
         <li>shadersPath : Shaders directory path ( "../shaders/" as default)</li>
         <li>tileErrorTreshold : Tile error treshold (4 as default)</li>
         <li>lighting : Lighting ? (false as default))</li>
         <li>continuousRendering : Have to continuously render ? (false as default)</li>
         </ul>
         @constructor
         */
    var RenderContext = function(options) {
        this.activeAnimations = [];
        this.shadersPath = options.shadersPath || "../shaders/";
        this.tileErrorTreshold = options.tileErrorTreshold || 4;
        this.lighting = options.lighting || false;
        this.continuousRendering = options.continuousRendering || false;
        this.stats = null;
        this.isActive = true;

        // Init GL
        var canvas = null;

        // Check canvas options
        if (!options.canvas) {
            throw new ReferenceError("Mizar : no canvas in options");
        }

        if (typeof options.canvas === "string") {
            //canvas = document.getElementById(options.canvas);
            canvas = $(options.canvas);
        } else {
            canvas = options.canvas;
        }
        // Check canvas is valid
        if (!(canvas instanceof HTMLCanvasElement)) {
            throw new TypeError("Mizar : invalid canvas");
        }

        // Create the webl context
        var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        var gl = null;
        for (var ii = 0; ii < names.length && gl === null; ++ii) {
            try {
                gl = canvas.getContext(
                    names[ii],
                    RenderContext.contextAttributes
                );
            } catch (e) {
                /* continue regardless of error */
            }
        }

        if (gl === null) {
            throw new ReferenceError(
                "Mizar : WebGL context cannot be initialized"
            );
        }

        if (options.backgroundColor) {
            var color = options.backgroundColor;
            gl.clearColor(color[0], color[1], color[2], color[3]);
        } else {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
        }

        gl.getExtension("OES_element_index_uint");

        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);

        // Store local variable into static object
        this.viewMatrix = mat4.create();
        this.modelViewMatrix = mat4.create();
        this.projectionMatrix = mat4.create();
        this.viewProjectionMatrix = mat4.create();
        this.gl = gl;
        this.canvas = canvas;
        this.frustum = new Frustum();
        this.worldFrustum = new Frustum();
        this.localFrustum = new Frustum();
        this.eyePosition = vec3.create();
        this.eyeDirection = vec3.create();
        this.minNear = options.minNear || 1e-10;
        this.minFar = options.minFar || 0; // No limit on far
        this.near = 1.0;
        this.far = 6.0;
        this.numActiveAttribArray = 0;
        this.frameRequested = false;
        this.fov = 45;
        this.renderers = [];
        this.cameraUpdateFunction = null;

        // Initialize the window requestAnimationFrame
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = (function() {
                return (
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function(callback, element) {
                        window.setTimeout(callback, 1000 / 60);
                    }
                );
            })();
        }

        var self = this;
        this.frameCallback = function() {
            self.frame();
        };
    };

    /**************************************************************************************************************/

    /**
         The context attributes used when creating WebGL context, see WebGL specification.
         Can be changed by the renderers if needed, or by an external interface.
         */
    RenderContext.contextAttributes = {};

    /**************************************************************************************************************/

    /**
     * Request a frame
     * @function requestFrame
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.requestFrame = function() {
        if (!this.frameRequested) {
            window.requestAnimationFrame(this.frameCallback);
            this.frameRequested = true;
        }
    };

    /**************************************************************************************************************/

    /**
     * Deactivate render context
     * @function deactivate
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.deactivate = function() {
        this.isActive = false;
        this.frameRequested = false;
    };

    /**************************************************************************************************************/

    /**
     * Activate render context
     * @function activate
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.activate = function() {
        this.isActive = true;
    };

    /**************************************************************************************************************/

    /**
     * Frame of the application
     * @function frame
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.frame = function() {
        if (this.isActive) {
            // Reset frame requested flag first
            this.frameRequested = false;

            var stats = this.stats;
            var gl = this.gl;
            var i;

            if (this.stats) {
                this.stats.start("globalRenderTime");
            }

            // Update active animations
            if (this.activeAnimations.length > 0) {
                var time = Date.now();
                for (i = 0; i < this.activeAnimations.length; i++) {
                    this.activeAnimations[i].update(time);
                }
            }

            // Clear the buffer
            if (RenderContext.contextAttributes.stencil) {
                gl.clear(
                    gl.COLOR_BUFFER_BIT |
                        gl.DEPTH_BUFFER_BIT |
                        gl.STENCIL_BUFFER_BIT
                );
            } else {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }

            // Check canvas size is valid
            if (this.canvas.width === 0 || this.canvas.height === 0) {
                return;
            }

            gl.viewport(0, 0, this.canvas.width, this.canvas.height);

            // Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
            if (this.cameraUpdateFunction) {
                this.cameraUpdateFunction();
            }
            this.updateViewDependentProperties();

            // Call render method of all registered renderers
            for (i = 0; i < this.renderers.length; i++) {
                this.renderers[i].render();
            }

            if (this.stats) {
                this.stats.end("globalRenderTime");
            }

            // Request next frame
            if (this.continuousRendering) {
                this.requestFrame();
            } else if (this.activeAnimations.length > 0) {
                this.requestFrame();
            }
        }
    };

    /**************************************************************************************************************/

    /**
     * Update properies that depends on the view matrix
     * @function updateViewDependentProperties
     * @memberof RenderContext.prototype
     */
    RenderContext.prototype.updateViewDependentProperties = function() {
        var inverseViewMatrix = mat4.create();
        mat4.inverse(this.viewMatrix, inverseViewMatrix);

        vec3.set([0.0, 0.0, 0.0], this.eyePosition);
        mat4.multiplyVec3(inverseViewMatrix, this.eyePosition);

        vec3.set([0.0, 0.0, -1.0], this.eyeDirection);
        mat4.rotateVec3(inverseViewMatrix, this.eyeDirection);

        // Init projection matrix
        mat4.perspective(
            this.fov,
            this.canvas.width / this.canvas.height,
            this.near,
            this.far,
            this.projectionMatrix
        );

        // No need to do this computation every time
        mat4.multiply(
            this.projectionMatrix,
            this.viewMatrix,
            this.viewProjectionMatrix
        );
        // Compute the frustum from the projection matrix
        this.frustum.compute(this.projectionMatrix);

        // Compute the world frustum
        this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix);

        // Compute the pixel size vector from the current view/projection matrix
        this.pixelSizeVector = this.computePixelSizeVector();
    };

    /**************************************************************************************************************/

    /**
     * Get mouse coordinates relative to the canvas element
     * @function getXYRelativeToCanvas
     * @memberof RenderContext.prototype
     * @param event
     * @return Coordinates
     */
    RenderContext.prototype.getXYRelativeToCanvas = function(event) {
        // cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
        var pos = [];
        if (event.pageX || event.pageY) {
            pos[0] = event.pageX;
            pos[1] = event.pageY;
        } else {
            pos[0] =
                event.clientX +
                document.body.scrollLeft +
                document.documentElement.scrollLeft;
            pos[1] =
                event.clientY +
                document.body.scrollTop +
                document.documentElement.scrollTop;
        }

        var element = this.canvas;
        while (element) {
            pos[0] -= element.offsetLeft;
            pos[1] -= element.offsetTop;
            element = element.offsetParent;
        }

        return pos;
    };

    /**************************************************************************************************************/

    /**
     * Compute the pixel size vector
     * @function computePixelSizeVector
     * @memberof RenderContext.prototype
     * @param mv
     * @return pixelSizeVector
     */
    RenderContext.prototype.computePixelSizeVector = function(mv) {
        // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
        // here we do it in short hand with the knowledge of how the window matrix is formed
        // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
        // Robert Osfield, June 2002.

        var width = this.canvas.width;
        var height = this.canvas.height;
        var P = this.projectionMatrix;
        var V = mv || this.viewMatrix;

        // scaling for horizontal pixels
        var P00 = P[0] * width * 0.5;
        var P20_00 = P[8] * width * 0.5 + P[11] * width * 0.5;
        var scale_00 = [
            V[0] * P00 + V[2] * P20_00,
            V[4] * P00 + V[6] * P20_00,
            V[8] * P00 + V[10] * P20_00
        ];

        // scaling for vertical pixels
        var P10 = P[5] * height * 0.5;
        var P20_10 = P[9] * height * 0.5 + P[11] * height * 0.5;
        var scale_10 = [
            V[1] * P10 + V[2] * P20_10,
            V[5] * P10 + V[6] * P20_10,
            V[9] * P10 + V[10] * P20_10
        ];

        var P23 = P[11];
        var P33 = P[15];
        var pixelSizeVector = [
            V[2] * P23,
            V[6] * P23,
            V[10] * P23,
            V[14] * P23 + V[15] * P33
        ];

        var scaleRatio =
            0.7071067811 /
            Math.sqrt(
                vec3.dot(scale_00, scale_00) + vec3.dot(scale_10, scale_10)
            );
        pixelSizeVector[0] *= scaleRatio;
        pixelSizeVector[1] *= scaleRatio;
        pixelSizeVector[2] *= scaleRatio;
        pixelSizeVector[3] *= scaleRatio;

        return pixelSizeVector;
    };

    /**************************************************************************************************************/

    /**
     * Get pixel from 3D
     * TODO: move it to Planet/Sky too ?
     * @function getPixelFrom3D
     * @memberof RenderContext.prototype
     * @param x
     * @param y
     * @param z
     * @return {Array} Point as array of 2 float
     */
    RenderContext.prototype.getPixelFrom3D = function(x, y, z) {
        var viewProjectionMatrix = mat4.create();
        mat4.multiply(
            this.projectionMatrix,
            this.viewMatrix,
            viewProjectionMatrix
        );

        // transform world to clipping coordinates
        var point3D = [x, y, z, 1];
        mat4.project(viewProjectionMatrix, point3D);

        // transform clipping to window coordinates
        var winX = Math.round((1 + point3D[0]) * 0.5 * this.canvas.width);

        // reverse y because (0,0) is top left but opengl's normalized
        // device coordinate (-1,-1) is bottom left
        var winY = Math.round((1 - point3D[1]) * 0.5 * this.canvas.height);

        return [winX, winY];
    };

    /**************************************************************************************************************/

    /**
     * Create a non power of two texture from an image
     * @function createNonPowerOfTwoTextureFromImage
     * @memberof RenderContext.prototype
     * @param image
     * @param invertY
     * @return Texture
     */
    RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(
        image,
        invertY
    ) {
        var gl = this.gl;
        var tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
        gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            image
        );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // Restore to default
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        return tex;
    };

    /**
     * Returns the canvas
     * @returns {Object} canvas
     */
    RenderContext.prototype.getCanvas = function() {
        return this.canvas;
    };

    /**
     * Returns the field of view in decimal degree.
     * @returns {Object} field of view
     */
    RenderContext.prototype.getFov = function() {
        return this.fov;
    };

    /**
     * Sets the field of fiew in decimal degree.
     * @param fov field of view
     */
    RenderContext.prototype.setFov = function(fov) {
        this.fov = fov;
    };

    /**
     * Returns the world frustum.
     * @returns {Frustum} frustum
     */
    RenderContext.prototype.getWorldFrustum = function() {
        return this.worldFrustum;
    };

    /**
     * Returns the view matrix.
     * @returns {mat4}
     */
    RenderContext.prototype.getViewMatrix = function() {
        return this.viewMatrix;
    };

    /**
     * Sets the view matrix.
     * @param {mat4} mat4 the matrix
     */
    RenderContext.prototype.setViewMatrix = function(mat4) {
        this.viewMatrix = mat4;
    };

    /**************************************************************************************************************/

    return RenderContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES8 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Globe/AbstractGlobe',[
    "../Utils/Event",
    "../Utils/Utils",
    "../Tiling/TileManager",
    "../Renderer/RendererManager",
    "../Renderer/Ray",
    "../Renderer/GeoBound",
    "../Crs/CoordinateSystemFactory",
    "../Renderer/RenderContext",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function (
    Event,
    Utils,
    TileManager,
    RendererManager,
    Ray,
    GeoBound,
    CoordinateSystemFactory,
    RenderContext,
    Constants
) {
        /**
         * AbstractGlobe configuration
         * @typedef {Object} AbstractGlobe.configuration
         * @property {boolean} [continuousRendering=false] - Options that renders the globe in continue
         * @property {Crs} coordinateSystem - coordinate system of the globe
         * @property {Object} [renderContext] - RenderContext object.
         * @property {string} [shadersPath=../shaders/] - Option for RenderContext : shader location.
         * @property {int} [tileErrorTreshold=4] - Option for RenderContext : tile error
         * @property {boolean} [lighting=false] - Option for RenderContext : enable/disable lighting
         * @property {Object|string} canvas - Option for RenderContext : Canvas element to insert in the globe
         * @property {Array} [backgroundColor=[0.0, 0.0, 0.0, 1.0]] - Option for RenderContext : color for background
         * @property {int} [minFar=0] - Option for RenderContext : When 0 , no limit on far
         * @property {Array} [defaultColor=[200, 200, 200, 255]] - Option for TileManager : pixel default color
         *
         */
        /**
         * @name AbstractGlobe
         * @class
         * Creates a sky or a planet with it own coordinate reference system and renders the globe.
         * According to its coordinate reference system, the globe can be projected on a map.<br/>
         * Client implementations should not normally instantiate this class directly.
         * @param {GLOBE} type - Type of the globe.
         * @param {AbstractGlobe.configuration} options - Options for globe creation.
         * @throws {ReferenceError} Will throw an error when the options.coordinateSystem is not defined.
         * @throws {Error} Will throw an error when options.coordinateSystem.geoideName  is not part of {@link CRS}
         * @see {@link module:Crs.CoordinateSystemFactory}
         * @constructor
         * @implements {Globe}
         */
        var AbstractGlobe = function (type, options) {
            Utils.assert(type === Constants.GLOBE.Sky || type === Constants.GLOBE.Planet || type === Constants.GLOBE.Ground, "Type must be a value of Contants.GLOBE for "+this.constructor.name, "AbstractGlobe.js");
            Utils.assert(options != null, "Options is required "+this.constructor.name, "AbastractGlobe.js");
            Utils.assert(options.coordinateSystem != null 
                && typeof(options.coordinateSystem) === 'object' 
                && options.coordinateSystem.geoideName != null, 
                "coordinate system is required in options parameters for "+this.constructor.name, "AbastractGlobe.js");

            this.type = type;

            this.coordinateSystem = CoordinateSystemFactory.create(
                options.coordinateSystem
            );

            if (!options.renderContext) {
                this.renderContext = new RenderContext(options);
            } else {
                this.renderContext = options.renderContext;
            }

            this.publishEvent = options.publishEvent;

            this.isEnable = true;
            this.continuousRendering = options.continuousRendering || false;
            this.tileManager = new TileManager(this, options);
            this.rendererManager = new RendererManager(this);
            this.attributionHandler = null;
            this.baseImagery = null;
            this.preRenderers = [];
            this.nbCreatedLayers = 0;
            this.definedBackgound = false;

            this.tileManager.addPostRenderer(this.rendererManager);

            this.renderContext.renderers.push(this);
            this.refresh();
        };

        /**
         * Computes intersections.
         * @param {Ray} ray
         * @param {Crs} crs - coordinate reference system
         * @returns {number} The nearest intersection, < 0 if no intersection
         * @private
         */
        function _computeIntersection(ray, crs) {
            var intersection;
            if (crs.isFlat()) {
                intersection = ray.planeIntersect([0, 0, 0], [0, 0, 1]);
            } else {
                intersection = ray.sphereIntersect(
                    [0, 0, 0],
                    crs.getGeoide().getRadius()
                );
            }
            return intersection;
        }

        /**
         * Computes the position.
         * @param {Ray} ray
         * @param {number} intersection
         * @param {Crs} crs
         * @returns {float[]|null} the position
         * @private
         */
        function _computePosition(ray, intersection, crs) {
            if (intersection >= 0) {
                var pos = crs.getWorldFrom3D(ray.computePoint(intersection));
                var geoBound = crs.getGeoBound();
                if (
                    !pos ||
                    pos[0] < geoBound[0] ||
                    pos[0] > geoBound[2] ||
                    pos[1] < geoBound[1] ||
                    pos[1] > geoBound[3] ||
                    isNaN(pos[0]) ||
                    isNaN(pos[1])
                ) {
                    return null;
                } else {
                    return pos;
                }
            } else {
                return null;
            }
        }

        /**
         * Updates the geometry related to the old GeoTiling to the new GeoTiling.
         * @function _updateTileIndexInGeometry
         * @param {TileManager} tileManager tile manager
         * @private
         */
        function _updateTileIndexInGeometry(tileManager) {
            var postRenderers = tileManager.postRenderers;
            var postRendererIdx = postRenderers.length;
            // we use while, this is the fastest loop in Javascript https://jsperf.com/fastest-array-loops-in-javascript/32
            while (postRendererIdx--) {
                // we iterate on renderers
                var postRenderer = postRenderers[postRendererIdx];
                if (postRenderer instanceof RendererManager) {
                    // we look for RendererManager because this one contains geometry
                    var rendererManager = postRenderers[postRendererIdx];
                    var vectors = rendererManager.renderers;
                    var vectorIdx = vectors.length;
                    while (vectorIdx--) {
                        // we iterate on vector
                        var vector = vectors[vectorIdx];
                        if (
                            vector.levelZeroTiledGeometries &&
                            vector.levelZeroTiledGeometries.length > 0
                        ) {
                            // we retrieve the geometries
                            var geometries = vector.levelZeroTiledGeometries;
                            var geometryIdx = geometries.length;
                            while (geometryIdx--) {
                                // we iterate on each geometry to update the indexed tile related to the geometry
                                // the (0,0) is 0, the (1,0) is 1, ....
                                var geometry = geometries[geometryIdx];
                                var tileIndices =
                                    vector.maxTilePerGeometry > 0
                                        ? tileManager.tiling.getOverlappedLevelZeroTiles(
                                            geometry
                                        )
                                        : null;
                                // update
                                geometry._tileIndices = tileIndices;
                            }
                        }
                    }
                }
            }
        }        

        /*************************************************************************************************************/

        /**
         * @function getType
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getType = function () {
            return this.type;
        };

        /**
         * @function isSky
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.isSky = function () {
            return this.getType() === Constants.GLOBE.Sky;
        };  
        
        /**
         * @function isPlanet
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.isPlanet = function () {
            return this.getType() === Constants.GLOBE.Planet;
        };        
        
        /**
         * @function hasDefinedBackground
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.hasDefinedBackground = function () {
            return this.definedBackgound;
        };        

        /**
         * @function setBaseImagery
         * @memberof AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.setBaseImagery = function (layer) {
            throw new SyntaxError(
                "setBaseImagery Not implemented",
                "AbstractGlobe.js"
            );
        };

        /**
         * @function getBaseImagery
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getBaseImagery = function () {
            return this.baseImagery;
        };

        /**
         * @function setBaseElevation
         * @memberof AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.setBaseElevation = function (layer) {
            throw new SyntaxError(
                "setBaseElevation Not implemented",
                "AbstractGlobe.js"
            );
        };

        /**
         * @function getBaseElevation
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getBaseElevation = function () {
            return this.tileManager.elevationProvider;
        };

        /**
         * @function addLayer
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.addLayer = function (layer) {
            Utils.assert(layer != null, "layer must be an AbstractLayer object in addLayer for "+this.constructor.name, "AbstractGlobe.js");
            var globe = this;
            if (layer.isVectorLayer()) {
                $.ajax({
                    url: layer.getUrl(),
                    success: function (data) {
                        layer.addFeatureCollection(data);
                        layer.id = globe.nbCreatedLayers;
                        layer._attach(globe);
                        globe.refresh();
                        globe.nbCreatedLayers++;
                        if (layer.callback) {
                            layer.callback(data);
                        }
                    }
                });
            } else {
                if(!layer.id) {
                    layer.id = this.nbCreatedLayers;
                    this.nbCreatedLayers++;
                }                
                layer._attach(globe);
                this.refresh();                
            }
            if (layer.isBackground()) {
                this.publishEvent(Constants.EVENT_MSG.LAYER_BACKGROUND_ADDED,layer);
            } else {
                this.publishEvent(Constants.EVENT_MSG.LAYER_ADDED, layer);
            }
        };

        /**
         * @function removeLayer
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.removeLayer = function (layer) {
            Utils.assert(layer != null, "layer must be an AbstractLayer object in removeLayer for "+this.constructor.name, "AbstractGlobe.js");
            layer.background = false;
            //layer.setVisible(false); <!-- cannot do it because of PlanetLayer -->
            layer._detach();
            this.publishEvent(Constants.EVENT_MSG.LAYER_REMOVED, layer);
        };

        /**
         * @function addAnimation
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.addAnimation = function (anim) {
            Utils.assert(anim != null, "anim must be an AbstractAnimation object in addAnimation for "+this.constructor.name,"AbstractGlobe.js");
            anim.renderContext = this.renderContext;
        };

        /**
         * @function removeAnimation
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.removeAnimation = function (anim) {
            Utils.assert(anim != null, "anim must be an AbstractAnimation object in removeAnimation for "+this.constructor.name,"AbstractGlobe.js");
            anim.renderContext = null;
        };

        /**
         * @function getElevation
         * @memberof AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.getElevation = function (lon, lat) {
            throw new SyntaxError(
                "getElevation Not implemented",
                "AbstractGlobe.js"
            );
        };

        /**
         * @function getViewportGeoBound
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getViewportGeoBound = function (transformCallback) {
            var rc = this.renderContext;
            var tmpMat = mat4.create();

            // Compute eye in world space
            mat4.inverse(rc.viewMatrix, tmpMat);
            var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

            // Compute the inverse of view/proj matrix
            mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
            mat4.inverse(tmpMat);

            // Transform the four corners of the frustum into world space
            // and then for each corner compute the intersection of ray starting from the eye with the earth
            var points = [
                [-1, -1, 1, 1],
                [1, -1, 1, 1],
                [-1, 1, 1, 1],
                [1, 1, 1, 1]
            ];
            var earthCenter = [0, 0, 0];
            for (var i = 0; i < 4; i++) {
                mat4.multiplyVec4(tmpMat, points[i]);
                vec3.scale(points[i], 1.0 / points[i][3]);
                vec3.subtract(points[i], eye, points[i]);
                vec3.normalize(points[i]);

                var ray = new Ray(eye, points[i]);
                var t = ray.sphereIntersect(
                    earthCenter,
                    this.coordinateSystem.getGeoide().getRadius()
                );
                //var t = ray.sphereIntersect(earthCenter, 15);
                if (t < 0.0) {
                    return null;
                }
                var pos3d = ray.computePoint(t);
                points[i] = this.coordinateSystem.from3DToGeo(pos3d);
                if (transformCallback) {
                    points[i] = transformCallback(points[i]);
                }
            }

            var geoBound = new GeoBound();
            geoBound.computeFromCoordinates(points);

            return geoBound;
        };

        /**
         * @function getLonLatFromPixel
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getLonLatFromPixel = function (x, y) {
            Utils.assert(typeof(x) === "number" && typeof(y) === "number", "(lon,lat) from getLonLatFromPixel must be numbers for "+ this.constructor.name, "AbstractGlobe.js");
            var ray = Ray.createFromPixel(this.renderContext, x, y);
            return this.computeIntersection(ray);
        };

        /**
         * @function getPixelFromLonLat
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getPixelFromLonLat = function (lon, lat) {
            Utils.assert(typeof(lon) === "number" && typeof(lat) === "number", "(lon,lat) from getPixelFromLonLat must be numbers for "+ this.constructor.name, "AbstractGlobe.js");
            var pos3d = vec3.create();
            this.coordinateSystem.get3DFromWorld([lon, lat], pos3d);
            return this.renderContext.getPixelFrom3D(pos3d[0], pos3d[1], pos3d[2]);
        }; 

        /**
         * @function setCoordinateSystem
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.setCoordinateSystem = function (coordinateSystem) {
            Utils.assert(coordinateSystem != null, "coordinateSystem must be a Crs object in setCoordinateSystem for "+this.constructor.name, "AbstractGlobe.js");
            var oldCrs = this.coordinateSystem;
            this.coordinateSystem = coordinateSystem;
            this.dispose();
            this.tileManager.tileConfig.coordinateSystem = coordinateSystem;
            _updateTileIndexInGeometry.call(this, this.getTileManager());
        };  
        
        /**
         * @function getCoordinateSystem
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getCoordinateSystem = function () {
            return this.coordinateSystem;
        };        

        /**
         * @function computeIntersection
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.computeIntersection = function (ray) {
            var intersection;

            if (this.hasMesh()) {
                intersection = Number.MAX_VALUE;
                for (var i = 0; i < this.tileManager.level0Tiles.length; ++i) {
                    const tile = this.tileManager.level0Tiles[i];
                    const t = tile.intersect(
                        ray,
                        this.tileManager.tileIndexBuffer.indices,
                        this.renderContext
                    );
                    if (t < intersection && t >= 0) {
                        intersection = t;
                    }
                }
                if (intersection === Number.MAX_VALUE) {
                    intersection = -1;
                }
            } else {
                //console.log("Ray",ray);
                intersection = _computeIntersection.call(
                    this,
                    ray,
                    this.coordinateSystem
                );
            }

            // console.log("intersection",intersection);
            var result = _computePosition.call(
                this,
                ray,
                intersection,
                this.coordinateSystem
            );
            // console.log("result",result);
            // console.log("=================================");
            return result;
        };

        /**
         * @function getRenderStats
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getRenderStats = function () {
            return "# rendered tiles : " + this.tileManager.tilesToRender.length;
        };   
        
        /**
         * @function getRenderContext
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getRenderContext = function () {
            return this.renderContext;
        };

        /**
         * @function setRenderContext
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.setRenderContext = function (context) {
            Utils.assert(context != null, "context must be a Context object in setRenderContext for "+this.constructor.name, "AbstractGlobe.js");
            this.renderContext = context;
        };        

        /**
         * @function getTileManager
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getTileManager = function () {
            return this.tileManager;
        };
        
        /**
         * @function getRendererManager
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.getRendererManager = function () {
            return this.rendererManager;
        };        

        /**
         * @function render
         * @memberof AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.render = function () {
            throw new SyntaxError("render Not implemented", "AbstractGlobe.js");
        };

        /**
         * @function dispose
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.dispose = function () {
            this.tileManager.reset();
            this.tileManager.tilePool.disposeAll();
        };

        /**     
         * @function destroy
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.destroy = function () {
            if (this.tileManager) {
                this.dispose();
                this.tileManager.removePostRenderer(this.rendererManager);
                this.tileManager = null;
                this.rendererManager = null;
            }
            this.renderContext.renderers.splice(
                this.renderContext.renderers.indexOf(this),
                1
            );
            if (this.coordinateSystem) {
                this.coordinateSystem.destroy();
                this.coordinateSystem = null;
            }
            this.refresh();
            this.definedBackgound = null;
            this.type = null;
            this.publishEvent = null;
            this.isEnable = null;
            this.globe = null;
            this.continuousRendering = null;
            this.attributionHandler = null;
            this.baseImagery = null;
            this.preRenderers = null;
            this.nbCreatedLayers = null;
        };        

        /**
         * @function refresh
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.refresh = function () {
            this.renderContext.requestFrame();
        };

        /**
         * @function isEnabled
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.isEnabled = function () {
            return this.isEnable;
        };

        /**
         * @function enable
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.enable = function () {
            this.isEnable = true;
        };

        /**
         * @function disable
         * @memberof AbstractGlobe#
         */
        AbstractGlobe.prototype.disable = function () {
            this.isEnable = false;
        };

        /**
         * @function hasMesh
         * @memberof AbstractGlobe#     
         */
        AbstractGlobe.prototype.hasMesh = function () {
            return false;
        };

        return AbstractGlobe;
    });

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributered in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Provides classes for handling a globe.
 * <p>
 * The different possible globes in MIZAR are :
 * <ul>
 *     <li>a sky</li>
 *     <li>a planet</li>
 * </ul>
 * <p>
 * A sky is a globe where the camera is located in it whereas the planet is a globe where the camera
 * is located outside.
 * <br/>
 * In addition to the classes, a {@link module:Globe.GlobeFactory factory} is available to help for creating globe.
 * Once the globe is created, the client can handle it by the use of its {@link Globe interface}.
 *
 * @module Globe
 * @implements {Globe}
 */
define('Globe/Planet',[
    "../Tiling/Tile",
    "../Utils/Event",
    "../Utils/Utils",
    "./AbstractGlobe",
    "../Utils/Constants"
], function (Tile, Event, Utils, AbstractGlobe, Constants) {
    /**
     * @name Planet
     * @class
     * Create a virtual planet in a HTML canvas element with its own coordinate reference system.
     * @augments AbstractGlobe
     * @param {AbstractGlobe.configuration} options - Planet configuration
     * @constructor
     * @memberof module:Globe
     */
    var Planet = function (options) {
        AbstractGlobe.prototype.constructor.call(
            this,
            Constants.GLOBE.Planet,
            options
        );
        this.manualRendererlayers = [];
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractGlobe, Planet);

    /**************************************************************************************************************/

    /**
     * Sets the base imagery layer for the Planet.
     * @function setBaseImagery
     * @memberof Planet#
     * @param {AbstractRasterLayer} layer the layer to use
     * @throws {RangeError} layer must be set.
     */
    Planet.prototype.setBaseImagery = function (layer) {
        if (layer == null) {
            throw new RangeError(
                "layer must be exist.",
                "Planet.js"
            );
        }

        if (layer === this.baseImagery) {
            return;
        }

        if (this.baseImagery) {        
            this.tileManager.setImageryProvider(null);
            this.baseImagery = null;
        }

        // Attach the layer to the globe      
        this.definedBackgound = true;
        layer.background = true;
        if (layer.isDetached()) {
            this.addLayer(layer);
        }
        this.tileManager.setImageryProvider(layer);
        this.baseImagery = layer;
        this.publishEvent(
            Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED,
            layer
        );
    };

    /**
     * @function setBaseElevation
     * @memberof Planet#
     */
    Planet.prototype.setBaseElevation = function (layer) {
        if (this.tileManager.elevationProvider) {
            this.removeLayer(this.tileManager.elevationProvider);
        }
        this.tileManager.setElevationProvider(layer);
        if (layer) {
            this.addLayer(layer);
        }
    };

    /**
     * @function getElevation
     * @memberof Planet#
     */
    Planet.prototype.getElevation = function (lon, lat) {
        // Use imagery provider tiling if defined, otherwise use globe default one
        var tiling = this.tileManager.tiling;
        if (this.baseImagery) {
            tiling = this.baseImagery.tiling;
        }
        var levelZeroTile = this.tileManager.level0Tiles[
            tiling.lonlat2LevelZeroIndex(lon, lat)
        ];

        if (
            Tile.State &&
            levelZeroTile &&
            levelZeroTile.state === Tile.State.LOADED
        ) {
            return levelZeroTile.getElevation(lon, lat);
        } else {
            return 0.0;
        }
    };

    /**     
     * @function render
     * @memberof Planet#
     */
    Planet.prototype.render = function () {
        if (this.isEnabled()) {
            // Call pre-renderers (only in 3D mode, no atmosphere for 2D)
            if (!this.coordinateSystem.isFlat()) {
                for (var i = 0; i < this.preRenderers.length; i++) {
                    this.preRenderers[i].preRender();
                }
            }
            // Render tiles
            this.tileManager.render();
        }
    };

    /**
     * @function hashMesh
     * @memberof Planet#
     */
    Planet.prototype.hasMesh = function () {
        return true;
    };

    /**************************************************************************************************************/

    return Planet;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Globe/Sky',[
    "../Tiling/TileManager",
    "../Tiling/TilePool",
    "../Utils/Utils",
    "./AbstractGlobe",
    "../Utils/Constants"
], function(TileManager, TilePool, Utils, AbstractGlobe, Constants) {
    /**
     * @name Sky
     * @class
     * Create a virtual sky in a HTML canvas element with its own coordinate reference system.
     *
     * The sky handles two different grids in the same time in order to display both
     * the galactic and equatorial rasters.
     *
     * @augments AbstractGlobe
     * @param {AbstractGlobe.configuration} options - Sky configuration
     * @constructor
     * @memberof module:Globe
     */
    var Sky = function(options) {
        AbstractGlobe.prototype.constructor.call(
            this,
            Constants.GLOBE.Sky,
            options
        );
        this.tilePool = new TilePool(this.renderContext);

        this.tileManagers = {
            Equatorial: this.tileManager,
            Galactic: new TileManager(this, options)
        };

        this.renderContext.requestFrame();
    };

    /**************************************************************************************************************/
    Utils.inherits(AbstractGlobe, Sky);

    /**************************************************************************************************************/

    /**
     * @function dispose
     * @memberof Sky#
     */
    Sky.prototype.dispose = function() {
        for (var x in this.tileManagers) {
            if (this.tileManagers.hasOwnProperty(x)) {
                this.tileManagers[x].reset();
                this.tileManagers[x].tilePool.disposeAll();
            }
        }
    };

    /**
     * @function setBaseImagery
     * @memberof Sky#
     * @throws {RangeError} Layer must be set
     **/
    Sky.prototype.setBaseImagery = function(layer) {

        if (layer == null) {
            throw new RangeError(
                "layer must be exist.",
                "Sky.js"
            );
        }

        if (this.baseImagery === layer) {
            return;
        }

        if (this.baseImagery) {
            this.tileManagers[
                this.baseImagery.tiling.coordinateSystem.getGeoideName()
            ].setImageryProvider(null);
            this.baseImagery = null;
        }

        layer.loadOverview();
        // Attach the layer to the globe      
        this.definedBackgound = true;
        if (layer.isDetached()) {
            this.addLayer(layer);
        }
        this.tileManagers[
            layer.tiling.coordinateSystem.getGeoideName()
        ].setImageryProvider(layer);
        this.baseImagery = layer;
        this.publishEvent(
            Constants.EVENT_MSG.LAYER_BACKGROUND_CHANGED,
            layer
        );
        layer.setVisible(true);
    
    };

    /**
     * @function render
     * @memberof Sky#
     */
    Sky.prototype.render = function() {
        // Render tiles manager
        if (this.isEnabled()) {
            this.tileManagers[Constants.CRS.Galactic].render();
            this.tileManagers[Constants.CRS.Equatorial].render();
        }
    };

    /**
     * @function destroy
     * @memberof Sky#
     */
    Sky.prototype.destroy = function() {
        AbstractGlobe.prototype.destroy.call(this);
        this.tileManagers.Galactic.reset();
        this.tileManagers.Galactic.tilePool.disposeAll();
        this.tileManagers = null;
    };

    /**************************************************************************************************************/

    return Sky;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name GlobeFactory
 * @class
 * Factory to create a globe.
 * @memberof module:Globe
 */
define('Globe/GlobeFactory',["./Planet", "./Sky", "../Utils/Constants"], function(
    Planet,
    Sky,
    Constants
) {
    return {
        /**
         * Creates a specific globe based on its type (e.g sky, planet).
         * @param {GLOBE} type - the type of globe
         * @param {AbstractGlobe.configuration} options - options to configure a globe
         * @return {Globe} a globe
         * @alias module:Globe.GlobeFactory.create
         * @throws {RangeError} Will throw an error when the type is not part of {@link GLOBE}
         * @see {@link module:Globe.Planet Planet}
         * @see {@link module:Globe.Sky Sky}
         */
        create: function(type, options) {
            var obj;
            switch (type) {
                case Constants.GLOBE.Planet:
                    obj = new Planet(options);
                    break;
                case Constants.GLOBE.Sky:
                    obj = new Sky(options);
                    break;
                default:
                    throw RangeError(
                        "The type " +
                            type +
                            " is not allowed, A valid type is included in the list GLOBE",
                        "GlobeFactory.js"
                    );
            }

            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/GoogleMouseNavigationHandler',["../Utils/Constants"], function(Constants) {    
    /**
     * Google mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.googleMouse_configuration
     */

    /**
     * @name GoogleMouseNavigationHandler
     * @class
     * GoogleMouseNavigationHandler constructor
     * @param {AbstractNavigation.googleMouse_configuration} options
     * @constructor
     * @memberof module:Navigation
     */
    var GoogleMouseNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _needsStartEvent = false;
        var _needsEndEvent = false;
        var _dx = 0;
        var _dy = 0;
        var _pressedGeo = null;
        var _changeInertia = null;
        var _slower = 0;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Event handler for mouse wheel
         * @function _handleMouseWheel
         * @param event Event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Navigation#startNavigation
         * @fires Navigation#endNavigation
         */
        var _handleMouseWheel = function(event) {
            _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_STARTED);

            var factor;
            var geo, pos;

            // Check differences between firefox and the rest of the world
            if (typeof event.wheelDelta === "undefined") {
                factor = event.detail;
            } else {
                factor = -event.wheelDelta / 120.0;
            }

            if (!_navigation.inertia) {
                // Compute mouse position and corresponding lon lat before zoom
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
            }

            _navigation.zoom(factor);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            } else {
                // Compute the new position of lon lat and pan the globe toward it
                if (geo) {
                    var pos2 = _navigation.ctx.getPixelFromLonLat(
                        geo[0],
                        geo[1]
                    );

                    var dx = pos[0] - pos2[0];
                    var widthHeightFactor = Math.round(
                        _navigation.ctx.getRenderContext().getCanvas().width /
                            _navigation.ctx.getRenderContext().getCanvas()
                                .height
                    );
                    widthHeightFactor =
                        widthHeightFactor < 1 ? 1 : widthHeightFactor;
                    dx *= widthHeightFactor;
                    var dy = pos[1] - pos2[1];
                    _navigation.pan(dx, dy);
                }
            }

            // Stop mouse wheel to be propagated, because default is to scroll the page
            // This is need when using Firefox event listener on DOMMouseScroll
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);
            _navigation.ctx.getRenderContext().requestFrame();

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         * @function _handleMouseDown
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleMouseDown = function(event) {
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;
            _dx = 0;
            _dy = 0;

            // Middle click
            if (event.button === 1) {
                // Cursor's style modification: Rotating icon
                _navigation.ctx.getRenderContext().getCanvas().style.cursor =
                    "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
            }
            // Left and right click
            else {
                // Save the lon lat clicked
                var pressedPos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                _pressedGeo = _navigation.ctx.getLonLatFromPixel(
                    pressedPos[0],
                    pressedPos[1]
                );

                // Left click
                if (event.button === 0) {
                    // Cursor's style modification: Grabbing icon
                    _navigation.ctx
                        .getRenderContext()
                        .getCanvas().style.cursor =
                        "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAZUlEQVR42sSTQQrAMAgEHcn/v7w9tYgNNsGW7kkI2TgbRZJ15NbU+waAAFV11MiXz0yq2sxMEiVCDDcHLeky8nQAUDJnM88IuyGOGf/n3wjcQ1zhf+xgxSS+PkXY7aQ9yvy+jccAMs9AI/bwo38AAAAASUVORK5CYII=), auto";
                }
                // Right click
                else {
                    // Cursor's style modification: Zooming (same as Rotating) icon
                    _navigation.ctx
                        .getRenderContext()
                        .getCanvas().style.cursor =
                        "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto";
                }
            }

            _needsStartEvent = true;

            // Return false to stop mouse down to be propagated when using onmousedown
            return false;
        };

        /**
         * Event handler for mouse up
         * @function _handleMouseUp
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Navigation#endNavigation
         */
        var _handleMouseUp = function(event) {
            // No button pressed anymore
            _pressedButton = -1;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Left click
                if (event.button === 0) {
                    //different behavior if the move has change from pan to rotate
                    if (_changeInertia) {
                        _navigation.inertia.launch("rotate", _changeInertia, 0);
                    } else {
                        _navigation.inertia.launch("pan", _dx, _dy);
                    }
                }
                // Middle click
                else if (event.button === 1) {
                    _navigation.inertia.launch("rotate", -_dx, -_dy);
                }
            }

            // Cursor's style modification : Hand icon
            _navigation.ctx.getRenderContext().getCanvas().style.cursor =
                "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto";

            _pressedGeo = null;
            _slower = 0;

            if (_needsEndEvent) {
                _navigation.ctx.publish(Constants.EVENT_MSG.NAVIGATION_ENDED);
            }

            _needsStartEvent = false;
            _needsEndEvent = false;

            // Stop mouse up event
            return false;
        };

        /**
         * Event handler for mouse move
         * @function _handleMouseMove
         * @param event
         * @returns {boolean}
         * @private
         * @memberof GoogleMouseNavigationHandler#
         * @fires Navigation#startNavigation
         * @fires Navigation#endNavigation
         */
        var _handleMouseMove = function(event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = event.clientX - _lastMouseX;
            _dy = event.clientY - _lastMouseY;

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            var inside;
            var pos, pos2;

            // Pan on Left click
            if (_pressedButton === 0) {
                if (_needsStartEvent) {
                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_STARTED
                    );
                    _needsStartEvent = false;
                    _needsEndEvent = true;
                }

                // Compute the mouse position
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                if (_pressedGeo) {
                    _changeInertia = null;
                    inside = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
                    if (inside) {
                        pos2 = _navigation.ctx.getPixelFromLonLat(
                            _pressedGeo[0],
                            _pressedGeo[1]
                        );
                        _dx = pos[0] - pos2[0];
                        _dy = pos[1] - pos2[1];
                        _navigation.pan(_dx, _dy);
                    }
                }
                // If the mouse not on the globe
                if (!_pressedGeo || !inside) {
                    if (Math.abs(_dx) > Math.abs(_dy)) {
                        _changeInertia =
                            pos[1] >
                            _navigation.ctx.getRenderContext().getCanvas()
                                .height /
                                2
                                ? -_dx
                                : _dx;
                    } else {
                        _changeInertia =
                            pos[0] >
                            _navigation.ctx.getRenderContext().getCanvas()
                                .width /
                                2
                                ? _dy
                                : -_dy;
                    }
                    _navigation.rotate(_changeInertia, 0);
                    pos = _navigation.ctx
                        .getRenderContext()
                        .getXYRelativeToCanvas(event);
                    _pressedGeo = _navigation.ctx.getLonLatFromPixel(
                        pos[0],
                        pos[1]
                    );
                    if (_pressedGeo) {
                        _changeInertia = null;
                    }
                }

                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Rotate on Middle click
            else if (_pressedButton === 1) {
                _navigation.rotate(-_dx, -_dy);
                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Zoom on Right click
            else {
                // Mouse move is too fast for zooming, need to slow it down
                _slower++;
                if (_slower % 3 === 0 && _slower > 1) {
                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_STARTED
                    );

                    _navigation.zoom(-_dy / 10);

                    if (_dy > 0 && _dy > _dx) {
                        // Compute the new position of lon lat and pan the globe toward it
                        if (_pressedGeo) {
                            pos = [
                                _navigation.ctx.getRenderContext().getCanvas()
                                    .clientLeft +
                                    _navigation.ctx
                                        .getRenderContext()
                                        .getCanvas().clientWidth /
                                        2,
                                _navigation.ctx.getRenderContext().getCanvas()
                                    .clientTop +
                                    _navigation.ctx
                                        .getRenderContext()
                                        .getCanvas().clientHeight /
                                        2
                            ];
                            pos2 = _navigation.ctx.getPixelFromLonLat(
                                _pressedGeo[0],
                                _pressedGeo[1]
                            );

                            var dx = pos[0] - pos2[0];
                            dx = (dx * 10) / 100;
                            var dy = pos[1] - pos2[1];
                            dy = (dy * 10) / 100;

                            _navigation.pan(dx, dy);
                        }
                    }

                    // Stop all animations when an event is received
                    _navigation.stopAnimations();

                    _navigation.ctx.publish(
                        Constants.EVENT_MSG.NAVIGATION_ENDED
                    );
                    _navigation.ctx.getRenderContext().requestFrame();
                }

                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };

        /**
         * Event handler for mouse double click
         * @function _handleMouseDblClick
         * @param event
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleMouseDblClick = function(event) {
            if (event.button === 0) {
                var pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                var geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo);
                }
            }
        };

        /**
         * Event handler for mouse context menu
         * @function _handleContextMenu
         * @param event
         * @private
         * @memberof GoogleMouseNavigationHandler#
         */
        var _handleContextMenu = function(event) {
            // Need this so browser's context menu won't show up when using right click zooming
            event.preventDefault();
            return false;
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         * Setup the default event handlers for the _navigation
         * @function install
         * @param nav
         * @memberof GoogleMouseNavigationHandler#
         */
        this.install = function(nav) {
            _navigation = nav;

            var canvas = _navigation.getRenderContext.getCanvas;

            // Cursor's style modification : Hand icon
            canvas.style.cursor =
                "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto";

            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mouseup", _handleMouseUp);
            canvas.addEventListener("mousemove", _handleMouseMove);
            canvas.addEventListener("contextmenu", _handleContextMenu);
            canvas.addEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.addEventListener("mousewheel", _handleMouseWheel);
        };

        /**
         * Remove the default event handlers for the _navigation
         * @function uninstall
         * @memberof GoogleMouseNavigationHandler#
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.getRenderContext().getCanvas();

            canvas.style.cursor = "auto";

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mouseup", _handleMouseUp);
            canvas.removeEventListener("mousemove", _handleMouseMove);
            canvas.removeEventListener("contextmenu", _handleContextMenu);
            canvas.removeEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return GoogleMouseNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/KeyboardNavigationHandler',[],function() {
    /**
     * Keyboard navigation handler configuration
     * @typedef {Object} AbstractNavigation.keyboard_configuration
     * @property {float} [panFactor = 10.0] - Factor for panning within the scene
     * @property {float} [zoomFactor = 1.0] - Factor for zooming into the scene
     * @property {boolean} [installOnDocument = false] -true to install the event listener on the document and not on the canvas
     */

    /**
     * @name KeyboardNavigationHandler
     * @class
     * KeyboardNavigationHandler constructor.<br/>
     * The keyboard shortcuts are the following :
     * <ul>
     *     <li><i>space bar</i> : Stop all animations when an event is received</li>
     *     <li><i>+</i> : zoom in the camera</li>
     *     <li><i>-</i> : zoom out the camera</li>
     *     <li><i>Left arrow</i> : pan the camera left</li>
     *     <li><i>shift + left arrow</i> : rotate the camera counterclockwise</li>
     *     <li><i>Right arrow</i> : pan the camera right</li>
     *     <li><i>shift + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Up arrow</i> : pan the camera up</li>
     *     <li><i>shift + up arrow</i> : rotate the camera up</li>
     *     <li><i>Down arrow</i> : pan the camera down</li>
     *     <li><i>shift + down arrow</i> : rotate the camera down</li>
     * </ul>
     *
     * @param {AbstractNavigation.keyboard_configuration} options - Keyboard navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var KeyboardNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */
        var _navigation = null;
        var self = this;

        /**
         * Public variables
         */
        this.panFactor = 10.0;
        this.zoomFactor = 1.0;

        // Setup options
        if (options) {
            if (options.panFactor && typeof options.panFactor === "number") {
                this.panFactor = options.panFactor;
            }
            if (options.zoomFactor && typeof options.zoomFactor === "number") {
                this.zoomFactor = options.zoomFactor;
            }
        }

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Set focus
         */
        var _setFocus = function(event) {
            this.focus();
            return false;
        };

        /**
         * Event handler for key down.
         * @param event
         * @private
         */
        var _handleKeyDown = function(event) {
            switch (event.keyCode) {
                case 32:
                    // space bar
                    // Stop all animations when an event is received
                    _navigation.stopAnimations();
                    break;
                case 187:
                // + on Safari
                // falls through
                case 61:
                // +(=) on Firefox and Opera
                // falls through
                case 107:
                    // + on other
                    _navigation.zoom(-self.zoomFactor);
                    break;
                case 189:
                // - on Safari
                // falls through
                case 54:
                // -(6) on Firefox and Opera
                // falls through
                case 109:
                    // - on other
                    _navigation.zoom(self.zoomFactor);
                    break;
                case 81:
                // q
                // falls through
                case 37:
                    // Left arrow
                    if (event.shiftKey) {
                        _navigation.rotate(self.panFactor, 0);
                    } else {
                        _navigation.pan(self.panFactor, 0);
                    }
                    break;
                case 90:
                // z
                // falls through
                case 38:
                    // Up arrow
                    if (event.shiftKey) {
                        _navigation.rotate(0, self.panFactor);
                    } else {
                        _navigation.pan(0, self.panFactor);
                    }
                    break;
                case 68:
                // d
                // falls through
                case 39:
                    // Right arrow
                    if (event.shiftKey) {
                        _navigation.rotate(-self.panFactor, 0);
                    } else {
                        _navigation.pan(-self.panFactor, 0);
                    }
                    break;
                case 83:
                // s
                // falls through
                case 40:
                    // Down arrow
                    if (event.shiftKey) {
                        _navigation.rotate(0, -self.panFactor);
                    } else {
                        _navigation.pan(0, -self.panFactor);
                    }
                    break;
            }
        };

        var _handleKeyUp = function(event) {
            _navigation.donePanning();
            _navigation.doneRotating();
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         Setup the default event handlers for the navigation
         */
        this.install = function(navigation) {
            // Setup the keyboard event handlers
            _navigation = navigation;

            if (options && options.installOnDocument) {
                document.addEventListener("keydown", _handleKeyDown);
                document.addEventListener("keyup", _handleKeyUp);
            } else {
                var canvas = _navigation.renderContext.canvas;
                canvas.addEventListener("keydown", _handleKeyDown);
                canvas.addEventListener("keyup", _handleKeyUp);
                // Setup focus handling to receive keyboard event on canvas
                canvas.tabIndex = "0";
                canvas.addEventListener("mousedown", _setFocus);
            }
        };

        /**
         Remove the default event handlers for the navigation
         */
        this.uninstall = function() {
            if (options && options.installOnDocument) {
                document.removeEventListener("keydown", _handleKeyDown);
                document.removeEventListener("keyup", _handleKeyUp);
            } else {
                var canvas = _navigation.renderContext.canvas;
                canvas.removeEventListener("keydown", _handleKeyDown);
                canvas.removeEventListener("keyup", _handleKeyUp);
                canvas.removeEventListener("mousedown", _setFocus);
            }
        };
    };

    return KeyboardNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/MouseNavigationHandler',["../Utils/Utils"], function(Utils) {
    /**
     * Mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.mouse_configuration
     * @property {float} [panButton = 0]
     * @property {float} [rotateButton = 1]
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     * @property {Object} [zoomOptions] - @see look at options in {@link Navigation#zoomTo}
     */

    /**
     * @name MouseNavigationHandler
     * @class
     * Mouse_navigationHandler constructor.<br/>
     * The mouse movements are the following :
     * <ul>
     *     <li><i>Wheel up</i> : zoom in the camera</li>
     *     <li><i>Wheel down</i> : zoom out the camera</li>
     *     <li><i>Click left+Ri + left mouse</i> : pan the camera right</li>
     *     <li><i>Wheel press + left mouse</i> : rotate the camera counterclockwise</li>
     *     <li><i>Click left + right mouse</i> : pan the camera left</li>
     *     <li><i>Wheel press + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Click left + up mouse</i> : pan the camera down</li>
     *     <li><i>Wheel press + up mouse</i> : rotate the camera down</li>
     *     <li><i>Click left + down mouse</i> : pan the camera up</li>
     *     <li><i>Wheel press + down mouse</i> : rotate the camera up</li>
     * </ul>
     * @param {AbstractNavigation.mouse_configuration} options - Mouse navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var MouseNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _dx = 0;
        var _dy = 0;
        var _panButton = (options && options.panButton) || 0;
        var _rotateButton = (options && options.rotateButton) || 1;
        var _zoomOptions =
            options && options.zoomOptions ? options.zoomOptions : {};

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         Event handler for mouse wheel
         */
        var _handleMouseWheel = function(event) {
            var factor;

            // Check differences between firefox and the rest of the world
            if (event.wheelDelta === undefined) {
                factor = event.detail;
            } else {
                factor = -event.wheelDelta / 120.0;
            }
            _navigation.zoom(factor);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            }

            event.returnValue = false;

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         */
        var _handleMouseDown = function(event) {
            document.addEventListener("mouseup", _handleMouseUp);
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            if (event.button === _panButton || event.button === _rotateButton) {
                _lastMouseX = event.clientX;
                _lastMouseY = event.clientY;
                _dx = 0;
                _dy = 0;

                // Return false to stop mouse down to be propagated when using onmousedown
                return false;
            }

            return true;
        };

        /**
         * Event handler for mouse up
         */
        var _handleMouseUp = function(event) {
            // No button pressed anymore
            _pressedButton = -1;
            document.removeEventListener("mouseup", _handleMouseUp);

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                if (event.button === _panButton) {
                    _navigation.inertia.launch("pan", _dx, _dy);
                }
                if (event.button === _rotateButton) {
                    _navigation.inertia.launch("rotate", _dx, _dy);
                }
            }

            if (event.button === _panButton) {
                _navigation.donePanning();
            }

            if (event.button === _rotateButton) {
                _navigation.doneRotating();
            }

            if (event.button === _panButton || event.button === _rotateButton) {
                event.preventDefault();

                // Stop mouse up event
                return false;
            }

            return true;
        };

        /**
         Event handler for mouse move
         */
        var _handleMouseMove = function(event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = event.clientX - _lastMouseX;
            _dy = event.clientY - _lastMouseY;

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            // Pan
            if (_pressedButton === _panButton) {
                _navigation.pan(_dx, _dy);
                ret = true;
            }
            // Rotate
            else if (_pressedButton === _rotateButton) {
                _navigation.rotate(_dx, _dy);
                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };

        /**
         Event handler for mouse double click
         */
        var _handleMouseDblClick = function(event) {
            if (event.button === 0) {
                var pos, geo;
                pos = _navigation.ctx
                    .getRenderContext()
                    .getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo, _zoomOptions);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function(nav) {
            _navigation = nav;
            var canvas = _navigation.renderContext.canvas;

            var passiveSupported = Utils.isPassiveSupported();

            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
                canvas.addEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.addEventListener(
                "DOMMouseScroll",
                _handleMouseWheel,
                passiveSupported ? { passive: true } : false
            );
            canvas.addEventListener(
                "mousewheel",
                _handleMouseWheel,
                passiveSupported ? { passive: true } : false
            );

            // Fix for Google Chrome : avoid dragging
            // TODO : a hack, should be more robust (restore on uninstall?)
            canvas.addEventListener("dragstart", function(event) {
                event.preventDefault();
                return false;
            });

            if (_rotateButton === 2) {
                canvas.addEventListener(
                    "contextmenu",
                    function(e) {
                        e.preventDefault();
                        return false;
                    },
                    false
                );
            }
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
                canvas.removeEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return MouseNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/TouchNavigationHandler',["../Utils/Utils"], function(Utils) {
    /**************************************************************************************************************/

    /**
     *    Types of actions for inertia execution
     */
    var Type = {
        PAN: 0,
        ROTATE: 1,
        TILT: 2,
        ZOOM: 3
    };

    /**
     * Touch navigation handler configuration
     * @typedef {Object} AbstractNavigation.touch_configuration
     * @property {boolean} [inversed = false] - if true inverse the sens of touching events
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     */

    /**
     * @name TouchNavigationHandler
     * @class
     * TouchNavigationHandler constructor
     * @param {AbstractNavigation.touch_configuration} options - Touch navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var TouchNavigationHandler = function(options) {
        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _lastFingerDistance;

        var _startTouches = [];
        var _lastTouches;
        var _lastAngle;

        var _dx, _dy;

        // Parameters for intertia management
        var _actionHits = [0, 0, 0, 0];
        var _lastTapDate;
        var _rotation;

        // Double tap
        var _doubletap_interval = 300;
        var _inversed =
            options && options.hasOwnProperty("inversed")
                ? options.inversed
                : false;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Calculate the angle between two coordinates
         */
        var _getAngle = function(touch1, touch2) {
            var y = touch2.clientY - touch1.clientY,
                x = touch2.clientX - touch1.clientX;
            return (Math.atan2(y, x) * 180) / Math.PI;
        };

        /**************************************************************************************************************/

        /**
         * Calculate the rotation degrees between two touchLists (fingers)
         */
        var _getRotation = function(start, end) {
            // Need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return (
                    _getAngle(end[1], end[0]) - _getAngle(start[1], start[0])
                );
            }
            return 0;
        };

        /**************************************************************************************************************/

        /**
         Handle touch start event
         */
        var _handleTouchStart = function(event) {
            //console.log("# events : " + event.touches.length );
            _lastTouches = event.touches;
            _startTouches = event.touches;

            _actionHits = [0, 0, 0, 0];

            // Stop all animations when an event is received
            _navigation.stopAnimations();
            _dx = 0;
            _dy = 0;
            if (event.touches.length === 2) {
                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;
                _lastFingerDistance = Math.sqrt(dx * dx + dy * dy);
                console.log("Finger distance : " + _lastFingerDistance);

                _lastAngle = _getRotation(_startTouches, event.touches);
            }

            event.returnValue = false;

            // Return false to stop event to be propagated
            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch move event
         */
        var _handleTouchMove = function(event) {
            _dx = event.touches[0].clientX - _lastTouches[0].clientX;
            _dy = event.touches[0].clientY - _lastTouches[0].clientY;
            var dx, dy;
            var rotation, fingerDistance, deltaDistance;

            if (event.touches.length === 1) {
                // Pan
                _navigation.pan(_dx, _dy);
                _actionHits[Type.PAN]++;
            } else {
                // Depending on direction of two fingers, decide if tilt OR rotation
                var sameDirection =
                    (event.touches[0].clientY - _lastTouches[0].clientY) *
                        (event.touches[1].clientY - _lastTouches[1].clientY) >
                    0;
                if (sameDirection) {
                    // Tilt
                    _navigation.rotate(0.0, -_dy);
                    _actionHits[Type.TILT]++;
                } else {
                    // Rotation
                    rotation = _getRotation(_startTouches, event.touches);
                    dx = rotation - _lastAngle;
                    _lastAngle = rotation;

                    if (_inversed) {
                        dx *= -1;
                    }

                    _rotation = dx * 10;
                    _navigation.rotate(_rotation, 0);
                    _actionHits[Type.ROTATE]++;
                }

                // Zoom
                dx = event.touches[0].clientX - event.touches[1].clientX;
                dy = event.touches[0].clientY - event.touches[1].clientY;
                fingerDistance = Math.sqrt(dx * dx + dy * dy);
                deltaDistance = fingerDistance - _lastFingerDistance;

                var scale;
                if (_inversed) {
                    scale = fingerDistance / _lastFingerDistance;
                } else {
                    scale = _lastFingerDistance / fingerDistance;
                }

                if (_lastFingerDistance !== 0) {
                    _navigation.zoom(deltaDistance * 0.025, scale);
                    _actionHits[Type.ZOOM]++;
                }
                _navigation.getRenderContext().requestFrame();
                _lastFingerDistance = fingerDistance;
            }

            // Update _lastTouches
            _lastTouches = event.touches;

            event.returnValue = false;

            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch end event
         */
        var _handleTouchEnd = function(event) {
            if (
                options &&
                options.zoomOnDblClick &&
                event.touches.length === 0 &&
                _dx === 0 &&
                _dy === 0
            ) {
                // Handle double tap
                // TODO : take into account the distance
                var now = Date.now();
                if (now - _lastTapDate < _doubletap_interval) {
                    var geo = _navigation.ctx.getLonLatFromPixel(
                        _lastTouches[0].clientX,
                        _lastTouches[0].clientY
                    );

                    if (geo) {
                        _navigation.zoomTo(geo);
                    }
                }
                _lastTapDate = now;
            }

            // Update last touches
            _lastTouches = event.touches;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Launch inertia depending on action hits while "moving" phase
                var hitIndex = _actionHits.indexOf(
                    Math.max.apply(this, _actionHits)
                );
                if (hitIndex === Type.PAN) {
                    // Pan
                    _navigation.inertia.launch("pan", _dx, _dy);
                } else if (hitIndex === Type.ROTATE) {
                    console.error("Rotate not implemented in navigation");
                    // Rotate
                    //_navigation.inertia.launch("rotate", _rotation, 0);
                } else if (hitIndex === Type.TILT) {
                    console.error("Tilt not implemented in navigation");
                    // No inertia for tilt
                }
            }

            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            return false;
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function(nav) {
            _navigation = nav;

            // Setup the touch event handlers
            var canvas = _navigation.renderContext.canvas;

            var passiveSupported = Utils.isPassiveSupported();

            canvas.addEventListener(
                "touchstart",
                _handleTouchStart,
                passiveSupported ? { passive: true } : false
            );
            canvas.addEventListener("touchend", _handleTouchEnd, false);
            canvas.addEventListener(
                "touchmove",
                _handleTouchMove,
                passiveSupported ? { passive: true } : false
            );
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function() {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("touchstart", _handleTouchStart, false);
            canvas.removeEventListener("touchend", _handleTouchEnd, false);
            canvas.removeEventListener("touchmove", _handleTouchMove, false);
        };
    };

    return TouchNavigationHandler;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationHandlerFactory
 * @class
 * Factory to create a device for the control of the camera.
 * @memberof module:Navigation
 */
define('Navigation/NavigationHandlerFactory',[
    "../Utils/Constants",
    "./GoogleMouseNavigationHandler",
    "./KeyboardNavigationHandler",
    "./MouseNavigationHandler",
    "./TouchNavigationHandler"
], function(
    Constants,
    GoogleMouseNavigationHandler,
    KeyboardNavigationHandler,
    MouseNavigationHandler,
    TouchNavigationHandler
) {
    return {
        /**
         * Creates a specific navigation based on its type (e.g Astro, Flat, Sky).
         * @param {HANDLER} type - the type of navigation
         * @param {AbstractNavigation.touch_configuration|AbstractNavigation.mouse_configuration|AbstractNavigation.googleMouse_configuration|AbstractNavigation.keyboard_configuration} options - see the handlers.
         * @return {Object} one of the handler
         * @alias module:Navigation.NavigationHandlerFactory.create
         * @see {@link GoogleMouseNavigationHandler} - Control the camera with mouse as Google movement
         * @see {@link KeyboardNavigationHandler} - Control the camera with the keyboard
         * @see {@link MouseNavigationHandler} - Control the camera with the mouse
         * @see {@link TouchNavigationHandler} - Control the camera with the smartphone
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link HANDLER}
         */
        create: function(type, options) {
            var obj;
            switch (type) {
                case Constants.HANDLER.GoogleMouse:
                    obj = new GoogleMouseNavigationHandler(options);
                    break;
                case Constants.HANDLER.Keyboard:
                    obj = new KeyboardNavigationHandler(options);
                    break;
                case Constants.HANDLER.Mouse:
                    obj = new MouseNavigationHandler(options);
                    break;
                case Constants.HANDLER.Touch:
                    obj = new TouchNavigationHandler(options);
                    break;
                default:
                    throw RangeError(
                        "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.HANDLER",
                        "NavigationHandlerFactory.js"
                    );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/AbstractAnimation',[],function() {
    /**
     * @name AbstractAnimation
     * @class
     * AbstractAnimation is an abstract class for all animation contexts which allow
     * an application to create an animation of the camera around the globe.
     * @implements {Animation}
     * @todo Describes here and link to the tutos about Animation
     */
    var AbstractAnimation = function() {
        this.startTime = -1;
        this.pauseTime = -1;
        this.renderContext = null;
    };

    /**
     * @function getRenderContext
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.getRenderContext = function() {
        return this.renderContext;
    };

    /**
     * Unregisters animation.
     * @function _unregisterActive
     * @memberof AbstractAnimation#
     * @private
     */
    AbstractAnimation.prototype._unregisterActive = function() {
        var index = this.renderContext.activeAnimations.indexOf(this);
        if (index >= 0) {
            this.renderContext.activeAnimations.splice(index, 1);
        }
    };

    /**
     * @function getStatus
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.getStatus = function() {
        if (this.startTime === -1) {
            return "STOPPED";
        } else {
            return this.pauseTime === -1 ? "RUNNING" : "PAUSED";
        }
    };

    /**
     * @function start
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.start = function() {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime === -1 || this.pauseTime !== -1) {
            var now = Date.now();
            if (this.startTime === -1) {
                this.startTime = now;
            } else {
                // resume after pause
                this.startTime += now - this.pauseTime;
                this.pauseTime = -1;
            }

            // Register animation as active
            this.renderContext.activeAnimations.push(this);
            this.renderContext.requestFrame();
        }
    };

    /**
     * @function pause
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.pause = function() {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime !== -1 && this.pauseTime === -1) {
            this.pauseTime = Date.now();
            this._unregisterActive(this);
        }
    };

    /**
     * @function stop
     * @memberof AbstractAnimation#
     */
    AbstractAnimation.prototype.stop = function() {
        this.startTime = -1;
        this.pauseTime = -1;

        if (this.onstop) {
            this.onstop();
        }

        // Unregister animation
        this._unregisterActive(this);
    };

    /**************************************************************************************************************/

    return AbstractAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/SegmentedAnimation',["../Utils/Utils", "./AbstractAnimation", "../Utils/Numeric"], function(
    Utils,
    AbstractAnimation,
    Numeric
) {
    /**
     * Segmented animation configuration
     * @typedef  {Object} AbstractAnimation.segmented_configuration
     * @param {float} duration - duration of the animation
     * @param {function} valueSetter - the function used to set the value.
     */

    /**
     * @name SegmentedAnimation
     * @class
     * SegmentedAnimation is an animation defined with segments.
     * Each segment has a [start,end] pair of 't' value and a [start,end] pair of
     * values that will be interpolated with the interpolator set on the segment.
     * When the animation runs, a t parameter is mapped to [0,1] according to
     * current time and animation duration.
     * The current segment is then looked up with that 't' value and used to interpolate
     * the animation's current value.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.segmented_configuration} options - Configuration of the animation
     * @constructor
     * @memberof module:Animation
     */
    var SegmentedAnimation = function(options) {
        Utils.assert(typeof(options.duration)==="number" 
        && typeof(options.valueSetter)==="function", "Missing required parameters in constructor", "SegmentedAnimation.js");
        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);

        this.segments = [];
        this.duration = options.duration;
        this.valueSetter = options.valueSetter;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, SegmentedAnimation);

    /**
     * Creates a segment.
     * @param start t value at which the segment will be the current segment
     * @param startValue value at t=start
     * @param end value at which the segment will be the current segment
     * @param endValue value at t=end
     * @param interpolator
     * @constructor
     * @todo Create a tutorial with a simple SegmentedAnimation on Mars
     */
    var Segment = function(start, startValue, end, endValue, interpolator) {
        this.start = start;
        this.startValue = startValue;
        this.end = end;
        this.endValue = endValue;
        this.interpolator = interpolator;
    };

    /**************************************************************************************************************/

    /**
     * Adds a new segment to the animation.<br/>
     * start, end are 't' values at which the segment will be the current segment<br/>
     * startValue, endValue are animation values at 't'=start and 't'=end<br/>
     * interpolator is the function that will be called to interpolate bewteen startValue and endValue.
     * @function addSegment
     * @memberof SegmentedAnimation
     * @param {float} start - t value at which the segment will be the current segment
     * @param {float} startValue - value at t=start
     * @param {float} end - value at which the segment will be the current segment
     * @param {float} endValue - value at t=end
     * @param {Function} interpolator - interpolator function
     */
    SegmentedAnimation.prototype.addSegment = function(
        start,
        startValue,
        end,
        endValue,
        interpolator
    ) {
        var count = this.segments.length;
        var index = 0;
        while (index < count && this.segments[index].end <= start) {
            index++;
        }
        // Insert new segment at position 'index'
        this.segments.splice(
            index,
            0,
            new Segment(start, startValue, end, endValue, interpolator)
        );
    };

    /**
     * Animation update method
     * @function update
     * @memberof SegmentedAnimation#
     * @param {float} now - Now
     */
    SegmentedAnimation.prototype.update = function(now) {
        var t = Numeric.map01(
            now,
            this.startTime,
            this.startTime + this.duration
        );
        if (t >= 1) {
            // Set last value
            var lastIndex = this.segments.length - 1;
            this.valueSetter(this.segments[lastIndex].endValue);
            this.stop();
        } else {
            // Find current segment
            var count = this.segments.length;
            var index = 0;
            while (index < count && this.segments[index].end < t) {
                index++;
            }
            index = Math.min(index, count - 1);

            // Remap t between segment bounds
            t = Numeric.map01(
                t,
                this.segments[index].start,
                this.segments[index].end
            );
            // Interpolate value
            var value = this.segments[index].interpolator(
                t,
                this.segments[index].startValue,
                this.segments[index].endValue
            );
            // Use value
            this.valueSetter(value);
        }
    };

    /**************************************************************************************************************/

    return SegmentedAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/PathAnimation',[
    "../Utils/Utils",
    "./AbstractAnimation",
    "../Utils/Numeric",
    "../Renderer/glMatrix"
], function(Utils, AbstractAnimation, Numeric) {
    /**
     * Path animation configuration
     * @typedef {Object} AbstractAnimation.path_configuration
     * @param {Array.<float[]>} coords - The path coordinates
     * @param {float} speed - The speed value
     * @param {Function} setter - the function used to set the value
     * @param {Globe} globe - the globe to clamp path animations on the terrain
     */

    /**
     * @name PathAnimation
     * @class
     * PathAnimation is an animation defined with a path.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.path_configuration} options Configuration of the animation
     * @constructor
     * @memberof module:Animation
     * @todo Create a tutorial with a simple PathAnimation on Mars
     */
    var PathAnimation = function(options) {
        Utils.assert(Array.isArray(options.coords) 
        && typeof(options.speed)==="number"
        && typeof(options.setter)==="function"
        && options.globe != null, "Missing required arguments in constructor", "PathAnimation.js");
        var i;
        var vec1, vec2;
        var dx, dy, dz;
        var node;
        var temp;

        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);
        this.globe = options.globe;
        this.speed =
            (options.speed *
                this.globe
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()) /
            1000;
        this.nodes = [];
        for (i = 0; i < options.coords.length; i++) {
            node = {
                position: this.globe
                    .getCoordinateSystem()
                    .get3DFromWorld(options.coords[i]),
                velocity: null,
                distance: 0.0
            };
            this.nodes.push(node);
            if (i > 0) {
                dx = this.nodes[i].position[0] - this.nodes[i - 1].position[0];
                dy = this.nodes[i].position[1] - this.nodes[i - 1].position[1];
                dz = this.nodes[i].position[2] - this.nodes[i - 1].position[2];
                this.nodes[i - 1].distance = Math.sqrt(
                    dx * dx + dy * dy + dz * dz
                );
            }
        }

        for (i = 1; i < options.coords.length - 1; i++) {
            vec1 = vec3.subtract(
                this.nodes[i + 1].position,
                this.nodes[i].position,
                vec3.create()
            );
            vec2 = vec3.subtract(
                this.nodes[i - 1].position,
                this.nodes[i].position,
                vec3.create()
            );
            vec3.normalize(vec1);
            vec3.normalize(vec2);
            this.nodes[i].velocity = vec3.subtract(vec1, vec2, vec3.create());
            vec3.normalize(this.nodes[i].velocity);
        }

        // Start velocity
        temp = vec3.subtract(
            this.nodes[1].position,
            this.nodes[0].position,
            vec3.create()
        );
        vec3.scale(temp, 3 / this.nodes[0].distance);
        this.nodes[0].velocity = vec3.subtract(
            temp,
            this.nodes[1].velocity,
            vec3.create()
        );
        vec3.scale(this.nodes[0].velocity, 0.5);

        // End velocity
        i = options.coords.length - 1;
        temp = vec3.subtract(
            this.nodes[i].position,
            this.nodes[i - 1].position,
            vec3.create()
        );
        vec3.scale(temp, 3 / this.nodes[i - 1].distance);
        this.nodes[i].velocity = vec3.subtract(
            temp,
            this.nodes[i - 1].velocity,
            vec3.create()
        );
        vec3.scale(this.nodes[i].velocity, 0.5);

        this.index = 0;
        this.currentDistance = 0;
        this.previousTime = -1;
        this.centerOffset = -0.2;
        this.altitudeOffset = 1000;

        var that = this;
        if (options.setter) {
            this.valueSetter = options.setter;
        } else {
            this.valueSetter = function(value, direction) {
                var up = vec3.normalize(value, vec3.create());

                var eye;
                if (options.globe) {
                    var geoEye = options.globe
                        .getCoordinateSystem()
                        .getWorldFrom3D(value);
                    geoEye[2] =
                        options.globe.getElevation(geoEye[0], geoEye[1]) +
                        that.altitudeOffset;
                    eye = options.globe
                        .getCoordinateSystem()
                        .get3DFromWorld(geoEye);
                } else {
                    eye = value;
                    eye[2] += that.altitudeOffset;
                }

                var dirn = vec3.normalize(direction, vec3.create());
                var center = vec3.add(eye, dirn, vec3.create());
                vec3.add(
                    center,
                    vec3.scale(up, that.centerOffset, vec3.create())
                );
                mat4.lookAt(
                    eye,
                    center,
                    up,
                    that.renderContext.getViewMatrix()
                );
            };
        }
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, PathAnimation);

    /**************************************************************************************************************/

    /**
     * Sets the speed.
     * @function setSpeed
     * @memberof PathAnimation#
     * @param {float} val Speed
     */
    PathAnimation.prototype.setSpeed = function(val) {
        this.speed =
            (parseFloat(val) *
                this.globe
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()) /
            1000.0;
    };

    /**
     * Returns the speed.
     * @function getSpeed
     * @memberof PathAnimation#
     * @return {float} Speed
     */
    PathAnimation.prototype.getSpeed = function() {
        return (
            this.speed /
            (this.globe
                .getCoordinateSystem()
                .getGeoide()
                .getHeightScale() /
                1000.0)
        );
    };

    /**
     * Sets the altitude offset.
     * @function setAltitudeOffset
     * @memberof PathAnimation#
     * @param {float} val Altitude offset
     */
    PathAnimation.prototype.setAltitudeOffset = function(val) {
        this.altitudeOffset = parseFloat(val);
    };

    /**
     * Returns the altitude offset.
     * @function getAltitudeOffset
     * @memberof PathAnimation#
     * @return {float} Altitude offset
     */
    PathAnimation.prototype.getAltitudeOffset = function() {
        return this.altitudeOffset;
    };

    /**
     * Sets the direction angle.
     * @function setDirectionAngle
     * @memberof PathAnimation#
     * @param {float} vertical Direction angle in degree
     */
    PathAnimation.prototype.setDirectionAngle = function(vertical) {
        this.centerOffset = Math.tan((parseFloat(vertical) * Math.PI) / 180.0);
    };

    /**
     * Starts the animation.
     * @function start
     * @memberof PathAnimation#
     */
    PathAnimation.prototype.start = function() {
        var previousStartTime = -1;
        if (this.pauseTime !== -1) {
            previousStartTime = this.startTime;
        }

        Animation.prototype.start.call(this);

        if (previousStartTime !== -1) {
            this.previousTime += this.startTime - previousStartTime;
        } else {
            this.previousTime = -1;
        }
    };

    /**
     * Updates the animation.
     * @function update
     * @memberof PathAnimation
     * @param {float} now the date now
     */
    PathAnimation.prototype.update = function(now) {
        if (this.previousTime === -1) {
            this.index = 0;
            this.currentDistance = 0;
        } else {
            this.currentDistance += (now - this.previousTime) * this.speed;
        }
        this.previousTime = now;

        while (
            this.currentDistance >= this.nodes[this.index].distance &&
            this.index < this.nodes.length - 1
        ) {
            this.currentDistance -= this.nodes[this.index].distance;
            this.index = this.index + 1;
        }

        if (this.index < this.nodes.length - 1) {
            var t = this.currentDistance / this.nodes[this.index].distance;
            var startPos = this.nodes[this.index].position;
            var endPos = this.nodes[this.index + 1].position;
            var startVel = vec3.scale(
                this.nodes[this.index].velocity,
                this.nodes[this.index].distance,
                vec3.create()
            );
            var endVel = vec3.scale(
                this.nodes[this.index + 1].velocity,
                this.nodes[this.index].distance,
                vec3.create()
            );
            var position = Numeric.cubicInterpolation(
                t,
                startPos,
                startVel,
                endPos,
                endVel
            );
            var direction = Numeric.cubicInterpolationDerivative(
                t,
                startPos,
                startVel,
                endPos,
                endVel
            );
            this.valueSetter(position, direction);
        } else if (this.index === this.nodes.length - 1) {
            this.valueSetter(
                this.nodes[this.index].position,
                this.nodes[this.index].velocity
            );
        } else {
            this.stop();
        }
    };

    /**************************************************************************************************************/

    return PathAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Mizar is able to create different types of animation on a globe :
 * <ul>
 *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}: Animation simulating inertia for camera navigation</li>
 *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation} : Generic animation to interpolate arbitrary values</li>
 *     <li>{@link module:Animation.PathAnimation PathAnimation} : Animation defined with a path</li>
 *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation} : Animation defined with segments</li>
 * </ul>
 *
 * In addition to the classes, a {@link module:Animation.AnimationFactory factory} is available to help for creating
 * animation. Once the animation is created, the client can handle it by the use of its {@link Animation interface}.
 *
 * @module Animation
 * @implements {Animation}
 * @todo Describes here and link to the tutos about Animation
 */
define('Animation/InertiaAnimation',["../Utils/Utils", "./AbstractAnimation"], function(Utils,AbstractAnimation) {
    /**************************************************************************************************************/

    /**
     * @constant
     * @type {float}
     * @default
     */
    const EPSILON = 0.1;

    /**
     * Default panFactor value
     * @constant
     * @type {number}
     * @default
     */
    const PAN_FACTOR = 0.95;

    /**
     * Default rotateFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ROTATE_FACTOR = 0.95;

    /**
     * Default zoomFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ZOOM_FACTOR = 0.5;

    /**
     * Inertia animation configuration
     * @typedef {Object} AbstractAnimation.inertia_configuration
     * @property {Navigation} nav - Navigation object that applies the transformations.
     * @property {float} [panFactor=0.95] - Pan Factor which is included in [0..1]. - 1 is sensible to the pan
     * @property {float} [zoomFactor=0.50] - Zoom Factor which is included in [0..1]. - 1 is sensible to the zoom
     * @property {float} [rotateFactor=0.95] - Rotate Factor which is included in [0..1]. - 1 is sensible to the rotation
     */

    /**
     * @name InertiaAnimation
     * @class
     * Animation simulating inertia for camera's navigation.
     * Inertia is its tendency to retain its velocity: in the absence of external influence, the camera's motion
     * persists in an uniform rectilinear motion.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.inertia_configuration} options Configuration of the Inertia animation
     * @constructor
     * @memberof module:Animation
     */
    var InertiaAnimation = function(options) {    
        Utils.assert(options.nav != null, "nav is required in constructor", "InertiaAnimation.js");
        AbstractAnimation.prototype.constructor.call(this);
        if (options) {
            this.panFactor = options.hasOwnProperty("panFactor")
                ? options.panFactor
                : PAN_FACTOR;
            this.rotateFactor = options.hasOwnProperty("rotateFactor")
                ? options.rotateFactor
                : ROTATE_FACTOR;
            this.zoomFactor = options.hasOwnProperty("zoomFactor")
                ? options.zoomFactor
                : ZOOM_FACTOR;
        }

        this.type = null;
        this.dx = 0;
        this.dy = 0;
        this.navigation = options.nav;
        this.renderContext = options.nav.getRenderContext();
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InertiaAnimation);

    /**************************************************************************************************************/

    /**
     * Updates the inertia.
     * @function update
     * @memberof InertiaAnimation#
     */
    InertiaAnimation.prototype.update = function(now) {
        var hasToStop = false;

        switch (this.type) {
            case "pan":
                this.navigation.pan(this.dx, this.dy);
                this.dx *= this.panFactor;
                this.dy *= this.panFactor;
                hasToStop =
                    Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
                break;
            case "rotate":
                this.navigation.rotate(this.dx, this.dy);
                this.dx *= this.rotateFactor;
                this.dy *= this.rotateFactor;
                hasToStop =
                    Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON;
                break;
            case "zoom":
                this.navigation.zoom(this.dx);
                this.dx *= this.zoomFactor;
                hasToStop = Math.abs(this.dx) < EPSILON;
                break;
            default:
        }
        this.navigation.getRenderContext().requestFrame();

        if (hasToStop) {
            this.stop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Launches the animation.
     * @function launch
     * @param {String} type Type of inertia
     * <ul>
     *   <li>pan</li>
     *   <li>rotate</li>
     *   <li>zoom</li>
     * </ul>
     * @param {int} dx x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @param {int} dy x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @memberof InertiaAnimation#
     */
    InertiaAnimation.prototype.launch = function(type, dx, dy) {
        // Set first value
        this.type = type;
        this.dx = dx;
        this.dy = dy;

        this.start();
    };

    /**************************************************************************************************************/

    return InertiaAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/InterpolatedAnimation',["../Utils/Utils", "./AbstractAnimation"], function(
    Utils,
    AbstractAnimation
) {
    /**
     * Interpolated animation configuration
     * @typedef {Object} AbstractAnimation.interpolated_configuration
     * @property {float} startValue - Starting point of the interpolation.
     * @property {float} endValue - Ending point of the interpolation.
     * @property {float} duration - Duration of the animation in seconds
     * @property {Function} interpolationFunction-  Interpolation function
     * @property {Function} setFunction - Setter of the Interpolation function
     */

    /**
     * @name InterpolatedAnimation
     * @class
     * Generic animation to interpolate arbitrary values
     * The animation will interpolate between startValue and endValue, using the
     * interpolateFunction(t, startValue, endValue) (t [0,1])
     * The interpolated value is then given to the setFunction(value)
     * @augments AbstractAnimation
     * @param {AbstractAnimation.interpolated_configuration} options Configuration of the InterpolatedAnimation
     * @constructor
     * @memberof module:Animation
     * @todo Create a tutorial with a simple InterpolatedAnimation on Mars
     */
    var InterpolatedAnimation = function(options) {
        Utils.assert(typeof(options.startValue)==="number" 
        && typeof(options.endValue)==="number" 
        && typeof(options.duration)==="number" 
        && typeof(options.interpolationFunction)==="function" 
        && typeof(options.setFunction)==="function", 
        "Missing required arguments in constructor", "InterpolatedAnimation.js");
        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);        
        this.values = [[0.0, options.startValue], [1.0, options.endValue]];
        this.duration = options.duration;
        this.interpolationFunction = options.interpolationFunction;
        this.setFunction = options.setFunction;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InterpolatedAnimation);

    /**************************************************************************************************************/

    /**
     * Adds a new value to the animation.
     * @function addValue
     * @memberof InterpolatedAnimation#
     * @param {float} t Value at [0,1]
     * @param {float} value Value to reach
     */
    InterpolatedAnimation.prototype.addValue = function(t, value) {
        Utils.assert(t >= 0 && t <= 1, "t must be in [0,1] when using addValue method", "InterpolatedAnimation.js");
        Utils.assert(typeof(value) === "number", "value must be a number when using addValue method", "InterpolatedAnimation.js");
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        // Insert new value at position 'upper'
        this.values.splice(upper, 0, [t, value]);
    };

    /**
     * Starts the animation.
     * @function start
     * @memberof InterpolatedAnimation#
     */
    InterpolatedAnimation.prototype.start = function() {
        Animation.prototype.start.call(this);
        this.setFunction(this.startValue);
        //TODO this.startValue is a bug ?
    };

    /**
     * Stops the animation.
     * @function stop
     * @memberof InterpolatedAnimation
     */
    InterpolatedAnimation.prototype.stop = function() {
        Animation.prototype.stop.call(this);
        this.setFunction(this.endValue);
        //TODO this.endValue is a bug ?
    };

    /**
     * Updates the Animation.
     * @function udate
     * @memberof InterpolatedAnimation
     * @param {float} now Now
     */
    InterpolatedAnimation.prototype.update = function(now) {
        var t = Numeric.map01(
            now,
            this.startTime,
            this.startTime + this.duration
        );
        if (t >= 1) {
            this.stop();
            return;
        }

        // Find upper and lower bounds
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        upper = Math.min(upper, count - 1);
        var lower = Math.max(0, upper - 1);

        // Remap t between lower and upper bounds
        t = Numeric.map01(t, this.values[lower][0], this.values[upper][0]);
        // Interpolate value
        var value = this.interpolationFunction(
            t,
            this.values[lower][1],
            this.values[upper][1]
        );
        // Use interpolated value
        this.setFunction(value);
    };

    /**************************************************************************************************************/

    return InterpolatedAnimation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name AnimationFactory
 * @class
 * Factory to create an animation
 * @memberof module:Animation
 * @throws {RangeError} the animation type is unknown
 */
define('Animation/AnimationFactory',[
    "../Utils/Constants",
    "./SegmentedAnimation",
    "./PathAnimation",
    "./InertiaAnimation",
    "./InterpolatedAnimation"
], function(
    Constants,
    SegmentedAnimation,
    PathAnimation,
    InertiaAnimation,
    InterpolatedAnimation
) {
    return {
        /**
         * Factory to create an animation.
         *
         * Creates an animation based on :
         * <ul>
         *     <li>the animation type {@link ANIMATION},</li>
         *     <li>the options for the specific animation</li>
         * </ul>
         *
         * Severals animations can be created :
         * <ul>
         *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}</li>
         *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation}</li>
         *     <li>{@link module:Animation.PathAnimation PathAnimation}</li>
         *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation}</li>
         * </ul>
         * @param {ANIMATION} type - Type of animation.
         * @param {AbstractAnimation.inertia_configuration|AbstractAnimation.interpolated_configuration|AbstractAnimation.path_configuration|AbstractAnimation.segmented_configuration} options - See the options for each animation for further information
         * @return {AbstractAnimation} - the interface to handle an animation
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link ANIMATION}
         * @alias module:Animation.AnimationFactory.create
         * @see {@link module:Animation.InertiaAnimation InertiaAnimation} Animation simulating inertia for camera's navigation
         * @see {@link module:Animation.InterpolatedAnimation InterpolatedAnimation} Generic animation to interpolate arbitrary values
         * @see {@link module:Animation.PathAnimation PathAnimation} Defines an animation based on a path
         * @see {@link module:Animation.SegmentedAnimation SegmentedAnimation} Defines an animation based on segments
         *
         */
        create: function(type, options) {
            var obj;
            switch (type) {
                case Constants.ANIMATION.Inertia:
                    obj = new InertiaAnimation(options);
                    break;
                case Constants.ANIMATION.Interpolated:
                    obj = new InterpolatedAnimation(options);
                    break;
                case Constants.ANIMATION.Path:
                    obj = new PathAnimation(options);
                    break;
                case Constants.ANIMATION.Segmented:
                    obj = new SegmentedAnimation(options);
                    break;
                default:
                    throw RangeError(
                        "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.ANIMATION",
                        "AnimationFactory.js"
                    );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/AbstractNavigation',[
    "../Utils/Utils",
    "../Utils/Event",
    "../Navigation/NavigationHandlerFactory",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Utils/Constants",
    "../Renderer/glMatrix"
], function(
    Utils,
    Event,
    NavigationHandlerFactory,
    AnimationFactory,
    Numeric,
    Constants
) {
    /**
     * Navigation configuration
     * @typedef {Object} AbstractNavigation.configuration
     * @property {boolean} [inertia = false] - Animation simulating inertia for camera's navigation
     * @property {AbstractAnimation.inertia_configuration} inertiaAnimation - Inertia Animation is used when <i>inertia</i> is true
     * @property {Object[]} [handlers = [{@link module:Navigation.MouseNavigationHandler MouseNavigationHandler},{@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler}[,{@link module:Navigation.TouchNavigationHandler TouchNavigationHandler}]]
     * @property {AbstractNavigation.mouse_configuration} [mouse] - Mouse navigation configuration when <i>handlers</i> is not defined
     * @property {AbstractNavigation.keyboard_configuration} [keyboard] - Keyboard navigation configuration when <i>handlers</i> is not defined
     * @property {boolean} [isMobile = false] - {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} configuration when <i>handlers</i> is not defined, sets to true this parameter to support mobile device
     */

    /**
     * @name AbstractNavigation
     * @class
     * The active navigation object can normally be obtained from the {@link Mizar#getNavigation} method of the Mizar instance.
     * Client implementations should not normally instantiate this class directly.
     * @augments Event
     * @param {NAVIGATION} type - type of navigation
     * @param {AbstractContext} ctx - context
     * @param {AbstractNavigation.configuration} [options = {}] - options for navigation
     * @constructor
     * @see {@link module:Navigation.NavigationHandlerFactory NavigationHandlerFactory} the possible handlers
     * @see {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler} for its options when it is set by default
     * @see {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} for its options when it is set by default
     * @see {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} for its options when isMobile is set to true
     * @implements {Navigation}
     *
     */
    var AbstractNavigation = function(type, ctx, options) {
        Event.prototype.constructor.call(this);
        this.type = type;
        this.ctx = ctx;
        this.renderContext = this.ctx.getRenderContext();
        this.renderContext.cameraUpdateFunction = this.update.bind(this);
        this.options = options || {};
        this.options.isMobile = ctx.getMizarConfiguration().isMobile;
        if (this.options.isMobile === true) {
            this.initTouchNavigation();
        }

        // Create default handlers if none are created in options
        this.handlers = _createHandlers.call(this, this.options);

        // Inertia effect
        this.inertia = _addInertiaEffect.call(this, this.options);

        // ZoomTo animation
        this.zoomToAnimation = null;

        // Automatically start
        this.start();
    };

    /**
     * Adds inertia effect
     * @param {Object} options
     * @returns {InertiaAnimation|null} inertia
     * @private
     */
    function _addInertiaEffect(options) {
        var inertia;
        if (options.inertia) {
            var inertiaOptions = options.inertiaAnimation || {};
            inertiaOptions.nav = this;
            inertia = AnimationFactory.create(
                Constants.ANIMATION.Inertia,
                inertiaOptions
            );
            const self = this;
            inertia.onstop = function() {
                self.donePanning();
                self.doneRotating();
            };
        } else {
            inertia = null;
        }
        return inertia;
    }

    /**
     * Creates handlers :
     * <ul>
     *     <li>Provided in options</li>
     *     <li>Create default handlers</li>
     * </ul>
     * @param {Object} options
     * @returns {Object[]} handlers
     * @private
     */
    function _createHandlers(options) {
        var handlers;
        // Create default handlers if none are created in options
        if (options.handlers) {
            handlers = options.handlers;
        } else {
            // Use mouse & keyboard as default handlers
            handlers = _addDefaultHandlers.call(this, options);
        }
        return handlers;
    }

    /**
     * Add default handlers :
     * <ul>
     *     <li>MouseNavigationHandler</li>
     *     <li>KeyboardNavigationHandler</li>
     *     <li>TouchNavigationHandler is isMobile is true</li>
     * </ul>
     * @param {Object} options - options
     * @returns {Object[]} An array of handlers
     * @private
     */
    function _addDefaultHandlers(options) {
        var defaultHandlers = [
            NavigationHandlerFactory.create(
                Constants.HANDLER.Mouse,
                options ? options.mouse : null
            ),
            NavigationHandlerFactory.create(
                Constants.HANDLER.Keyboard,
                options ? options.keyboard : null
            )
        ];
        if (options.isMobile) {
            defaultHandlers.push(
                NavigationHandlerFactory.create(
                    Constants.HANDLER.Touch,
                    options ? options.touch : null
                )
            );
        }
        return defaultHandlers;
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, AbstractNavigation);

    /**************************************************************************************************************/

    /**
     * Initializes the touch navigation handler.
     * @function initTouchNavigation
     * @memberof AbstractContext#
     */
    AbstractNavigation.prototype.initTouchNavigation = function() {
        this.options.touch = {
            inversed: this.ctx.globe.isSky(),
            zoomOnDblClick: true
        };
        var self = this;
        window.addEventListener(
            "orientationchange",
            function() {
                self.ctx.refresh();
            },
            false
        );
    };

    /**
     * Returns the {@link TYPE type} of navigation.
     * The type can take one of the following value : AstroNavigation, FlatNavigation, PlanetNavigation
     * @function getType
     * @return {string} the name of the navigation class, which is used
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getType = function() {
        return this.type;
    };

    /**
     * Returns the navigation's options given at the initialisation.
     * @function getOptions
     * @return {Object} Options
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getOptions = function() {
        return this.options;
    };

    /**
     * Starts the navigation.
     * @function start
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.start = function() {
        // Install handlers
        for (var i = 0; i < this.handlers.length; i++) {
            this.handlers[i].install(this);
        }
    };

    /**
     * Stops the navigation.
     * @function stop
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.stop = function() {
        // Uninstall handlers
        for (var i = 0; i < this.handlers.length; i++) {
            this.handlers[i].uninstall();
        }
    };

    /**
     * Stops the animations.
     * @function stopAnimations
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.stopAnimations = function() {
        if (this.inertia) {
            this.inertia.stop();
        }
        if (this.zoomToAnimation) {
            this.zoomToAnimation.stop();
            this.zoomToAnimation = null;
        }
    };

    /**
     * Returns the field of view in decimal degree.
     * @function getFov
     * @return {float[]} the Field of view [fov along width, fov along height]
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getFov = function() {
        return [this.renderContext.getFov(), this.renderContext.getFov()];
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof AbstractNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = 1000] - Duration of animation in milliseconds
     * @abstract
     */
    AbstractNavigation.prototype.moveUpTo = function(vec, duration) {
        throw new SyntaxError(
            "moveUpTo not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Returns the center of the field of view.
     * @function getCenter
     * @return {float[]} the center in decimal degree of the field of view [longitude, latitude]
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getCenter = function() {
        return this.ctx.getLonLatFromPixel(
            this.renderContext.getCanvas().width * 0.5,
            this.renderContext.getCanvas().height * 0.5
        );
    };

    /**
     * Rotates the camera.
     * @function rotate
     * @param {float} dx Window delta x
     * @param {float} dy Window delta y
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.rotate = function(dx, dy) {
        throw new SyntaxError(
            "rotate is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Pans the camera to a direction up/down or left/right with the same distance from the object
     * @function pan
     * @param {float} dx Window direction left/right
     * @param {float} dy Window direction up/down
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.pan = function(dx, dy) {
        throw new SyntaxError(
            "pan is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Applies zooming.
     * @function zoom
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.zoom = function(delta, scale) {
        throw new SyntaxError(
            "zoom is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Zooms to a 2D position (longitude, latitude).
     * @function zoomTo
     * @param {float[]} geoPos - spatial position in decimal degree [longitude, latitude]
     * @param {Object} options - options for zoomTo
     * @abstract
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.zoomTo = function(geoPos, options) {
        throw new SyntaxError(
            "zoomTo is not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof AbstractNavigation#
     * @abstract
     */
    AbstractNavigation.prototype.computeViewMatrix = function() {
        throw new SyntaxError(
            "computeViewMatrix not implemented",
            "AbstractNavigation.js"
        );
    };

    /**
     * Callback at the end of animation (when stop method is called).
     * @callback navigationCallback
     */

    /**
     * Basic animation from current view matrix to the given one
     * @function toViewMatrix
     * @param {Object[]} mat Destination view matrix (array of 16)
     * @param {int} fov Final zooming fov in degrees
     * @param {int} duration Duration of animation in milliseconds
     * @param {navigationCallback} callback Callback at the end of animation
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.toViewMatrix = function(
        mat,
        fov,
        duration,
        callback
    ) {
        var navigation = this;
        var vm = this.renderContext.getViewMatrix();

        var srcViewMatrix = mat4.toMat3(vm);
        var srcQuat = quat4.fromRotationMatrix(srcViewMatrix);
        var destViewMatrix = mat4.toMat3(mat);
        var destQuat = quat4.fromRotationMatrix(destViewMatrix);
        var destFov = fov || 45;
        duration = duration || 1000;

        // Animate rotation matrix(with quaternion support), translation and fov
        var startValue = [
            srcQuat,
            [vm[12], vm[13], vm[14]],
            navigation.getRenderContext().getFov()
        ];
        var endValue = [destQuat, [mat[12], mat[13], mat[14]], destFov];
        var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                // Update rotation matrix
                var newRotationMatrix = quat4.toMat4(value[0]);

                // Need to transpose the new rotation matrix due to bug in glMatrix
                var viewMatrix = mat4.transpose(newRotationMatrix);

                // Update translation
                viewMatrix[12] = value[1][0];
                viewMatrix[13] = value[1][1];
                viewMatrix[14] = value[1][2];

                // sets the new matrix
                navigation.renderContext.setViewMatrix(viewMatrix);

                // Update fov
                navigation.renderContext.setFov(value[2]);

                navigation.renderContext.requestFrame();
            }
        });

        // Add segment
        animation.addSegment(0.0, startValue, 1.0, endValue, function(t, a, b) {
            var pt = Numeric.easeOutQuad(t);
            var resQuat = quat4.create();
            quat4.slerp(a[0], b[0], pt, resQuat);

            var resTranslate = vec3.create();
            vec3.lerp(a[1], b[1], pt, resTranslate);

            var resFov = Numeric.lerp(pt, a[2], b[2]);
            return [
                resQuat, // quaternions
                resTranslate, // translate
                resFov // fov
            ];
        });

        animation.onstop = function() {
            if (callback) {
                callback();
            }
        };

        this.ctx.addAnimation(animation);
        animation.start();
    };

    /**
     * Returns the rendering context.
     * @function getRenderContext
     * @returns {RenderContext} the rendering context
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.getRenderContext = function() {
        return this.renderContext;
    };

    /**
     * Sets the rendering context
     * @function setRenderContext
     * @param {RenderContext} renderContext - the rendering context to set
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.setRenderContext = function(renderContext) {
        this.renderContext = renderContext;
    };

    /**
     * Destroys the navigation.
     * @function destroy
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.destroy = function() {
        this.renderContext.cameraUpdateFunction = null;
        this.type = null;
        this.options = null;
        this.zoomToAnimation = null;
        this.stop();
        this.ctx = null;
        this.renderContext = null;
    };

    /**
     * Update the navigation values if computations are needed.
     * @function update
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.update = function() {
        // Does nothing by default
    };

    /**
     * Called by mouse and keyboard handler when pan interactions are finished.
     * This is useful to, e.g.,  fetch the new focus point of the navigator.
     * @function donePanning
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.donePanning = function() {
        // Does nothing by default
    };

    /**
     * Called by mouse and keyboard handler when rotate interactions are finished.
     * This is useful to, e.g.,  fetch the new focus point of the navigator.
     * @function doneRotating
     * @memberof AbstractNavigation#
     */
    AbstractNavigation.prototype.doneRotating = function() {
        // Does nothing by default
    };

    /**************************************************************************************************************/

    return AbstractNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/PlanetNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**
     * Flat navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.planet_configuration
     * @property {float[]} [initTarget=[0, 0, 3.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
     * at initialisation. distance in meter is optional.
     * @property {int} [minDistance=0] the minimum distance sets to 60 Km by default or options.initTarget[2]
     * when this one is inferior to options.minDistance
     * @property {int} [maxDistance=3*RADIUS_PLANET] the maximum distance sets to 3*RADIUS_PLANET by default or
     * options.initTarget[2] when this one is superior to options.maxDistance
     * @property {boolean} [updateViewMatrix=false] indicating if view matrix must be updated on initialization.
     */

    /**
     * 1km epsilon error for elevation.
     * @type {number}
     */
    const OFFSET_ELEVATION = 1000.0;

    /**
     * Duration of animation in milliseconds for the zoom_to function.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM_TO = 5000.0;

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000.0;

    /**
     * Min tilt in decimal degree.
     * @type {number}
     */
    const MIN_TILT = 10.0;

    /**
     * Max tilt in decimal degree.
     * @type {number}
     */
    const MAX_TILT = 90.0;

    /**
     * Default tilt in decimal degree.
     * @type {number}
     */
    const DEFAULT_TILT = 90.0;

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degee.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Default heading in decimal degree.
     * @type {number}
     */
    const DEFAULT_HEADING = MIN_HEADING;

    /**
     * Heading difference between two successive rotation (in degree) of the camera
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Tilt difference between two successive rotation (in degree) of the camera
     * @type {number}
     */
    const DELTA_TILT = 0.05;

    /**
     * @name PlanetNavigation
     * @augments AbstractNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
     *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
     *     </tr>
     * </table>
     * At initialisation, the distance of the camera is maxDistance
     * @param {PlanetContext} ctx -  Planet context
     * @param {AbstractNavigation.planet_configuration} options - Planet navigation configuration
     * @memberof module:Navigation
     */
    var PlanetNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.PlanetNavigation,
            ctx,
            options
        );

        Object.defineProperties(this, {
            scale: {
                get: function() {
                    return this.ctx
                        .getCoordinateSystem()
                        .getGeoide()
                        .getHeightScale();
                }
            },

            distance: {
                get: function() {
                    const value = this._distance * this.scale;
                    return value;
                },
                set: function(v) {
                    const value = v / this.scale;
                    this._distance = value;
                }
            },

            targetHeight: {
                get: function() {
                    return this.ctx.getElevation(
                        this.geoCenter[0],
                        this.geoCenter[1]
                    );
                }
            },

            cameraHeight: {
                get: function() {
                    const tilt = ((90 - this.tilt) * Math.PI) / 180;
                    const c = Math.cos(tilt);
                    const d = c * this._distance;
                    return d + this.targetHeight;
                }
            },

            eye: {
                get: function() {
                    return [
                        this.inverseViewMatrix[12],
                        this.inverseViewMatrix[13],
                        this.inverseViewMatrix[14]
                    ];
                }
            },

            geoEye: {
                get: function() {
                    return this.ctx.getCoordinateSystem().from3DToGeo(this.eye);
                }
            }
        });

        const geoide = this.ctx.getCoordinateSystem().getGeoide();
        // Default values for min and max distance (in meter)
        const minDistance = this.options.minDistance || 50;
        const maxDistance =
            this.options.maxDistance || 3.0 * geoide.getRealPlanetRadius();

        // Scale min and max distance from meter to internal ratio
        this.minDistance = minDistance * geoide.getHeightScale();
        this.maxDistance = maxDistance * geoide.getHeightScale();

        // Initialize the navigation
        this.geoCenter = [0.0, 0.0, 0.0];

        this.heading = DEFAULT_HEADING;
        this.tilt = DEFAULT_TILT;
        this._distance = Number.NaN;
        this.offset = 0.0;

        // Coordinate of the North in XYZ frame
        this.up = [0.0, 0.0, 1.0];

        this.inverseViewMatrix = mat4.create();

        var updateViewMatrix = this.options.hasOwnProperty("updateViewMatrix")
            ? this.options.updateViewMatrix
            : true;

        _setInitTarget.call(this, this.options.initTarget);

        // Update the view matrix if needed(true by default)
        if (updateViewMatrix) {
            this.computeViewMatrix();
        }
    };

    /**
     * Defines the position where the camera looks at and the distance of the camera regarding to the planet's surface
     * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.geoCenter[0] = initTarget[0];
            this.geoCenter[1] = initTarget[1];
            this.distance =
                initTarget.length === 3
                    ? initTarget[2] *
                      this.ctx
                          .getCoordinateSystem()
                          .getGeoide()
                          .getHeightScale()
                    : this.distance;
            if (this.distance < this.minDistance) {
                this.minDistance = this.distance;
            }
            if (this.distance > this.maxDistance) {
                this.maxDistance = this.distance;
            }
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, PlanetNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof PlanetNavigation#
     * @return {float[]}
     */
    PlanetNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = this.geoCenter;
        }
        return center;
    };

    /**
     * Saves the current navigation state.
     * @function save
     * @memberof PlanetNavigation#
     * @return {{geoCenter: *, heading: *, tilt: *, distance: *}} a JS object containing the navigation state
     */
    PlanetNavigation.prototype.save = function() {
        return {
            geoCenter: this.geoCenter,
            heading: this.heading,
            tilt: this.tilt,
            distance: this.distance
        };
    };

    /**
     * Restores the navigation state.
     * @function restore
     * @memberof PlanetNavigation#
     * @param {Object} state - a JS object containing the navigation state
     * @param {float[]} state.geoCenter - Target of the camera (longitude, latitude)
     * @param state.heading
     * @param {float} state.tilt - tilt of the camera in decimal degree
     * @param {float} state.distance - Distance from the surface of the globe in meter.
     */
    PlanetNavigation.prototype.restore = function(state) {
        this.geoCenter = state.geoCenter;
        this.heading = state.heading;
        this.tilt = state.tilt;
        this.distance = state.distance;
        this.computeViewMatrix();
    };

    /**
     * Zoom to a geographic position
     * @function zoomTo
     * @memberof PlanetNavigation#
     * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
     * @param {Object} [options] - Options
     * @param {int} [options.distance] - Final zooming distance in meters - if not set, this is the current distance
     * @param {int} [options.duration = 5000] - Duration of animation in milliseconds
     * @param {int} [options.tilt = 90] - Defines the tilt at the end of animation
     * @param {int} [options.heading] - Defines the heading at the end of animation. By default, the current heading is conserved
     * @param {navigationCallback} [options.callback] - Callback at the end of animation
     */
    PlanetNavigation.prototype.zoomTo = function(geoPos, options) {
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE);
        var navigation = this;

        var destDistance =
            options && options.hasOwnProperty("distance")
                ? options.distance
                : this.distance /
                  this.ctx
                      .getCoordinateSystem()
                      .getGeoide()
                      .getHeightScale();
        var duration =
            options && options.hasOwnProperty("duration")
                ? options.duration
                : DEFAULT_DURATION_ZOOM_TO;
        var destTilt =
            options && options.hasOwnProperty("tilt")
                ? options.tilt
                : this.tilt;
        var destHeading =
            options && options.hasOwnProperty("heading")
                ? options.heading
                : this.heading;
        var shortestPath = Numeric.shortestPath180(
            this.geoCenter[0],
            geoPos[0]
        );
        var shortestHeading = Numeric.shortestPath180(
            this.heading,
            destHeading
        );
        // Create a single animation to animate geoCenter, distance and tilt
        var startValue = [
            shortestPath[0], // longitude
            this.geoCenter[1], // latitude
            this.distance, // distance from ground
            this.tilt, // tilt
            shortestHeading[0] // heading
        ];
        var endValue = [
            shortestPath[1], // longitude
            geoPos[1], // latitude
            destDistance *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale(), // distance from ground
            destTilt, // tilt
            shortestHeading[1] // heading
        ];

        this.zoomToAnimation = new AnimationFactory.create(
            Constants.ANIMATION.Segmented,
            {
                duration: duration,
                valueSetter: function(value) {
                    navigation.geoCenter[0] =
                        value[0] > 180 ? value[0] - 360 : value[0];
                    navigation.geoCenter[1] = value[1];
                    navigation.distance = value[2];
                    navigation.tilt = value[3];
                    navigation.heading =
                        value[4] > 180 ? value[4] - 360 : value[4];
                    navigation.computeViewMatrix();
                }
            }
        );

        // Compute a max altitude for the animation
        var worldStart = this.ctx
            .getCoordinateSystem()
            .get3DFromWorld(this.geoCenter);
        var worldEnd = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        var vec = vec3.subtract(worldStart, worldEnd);
        var len = vec3.length(vec);
        var canvas = this.ctx.getRenderContext().canvas;
        var minFov = Math.min(
            Numeric.toRadian(45.0),
            Numeric.toRadian((45.0 * canvas.width) / canvas.height)
        );
        var maxAltitude = (len * 0.5) / Math.tan(minFov * 0.5);
        if (maxAltitude > this.distance) {
            // Compute the middle value
            var midValue = [
                (startValue[0] + endValue[0]) * 0.5,
                (startValue[1] + endValue[1]) * 0.5,
                maxAltitude,
                (startValue[3] + startValue[3]) * 0.5,
                (startValue[4] + startValue[4]) * 0.5
            ];

            // Add two segments
            this.zoomToAnimation.addSegment(
                0.0,
                startValue,
                0.5,
                midValue,
                function(t, a, b) {
                    var pt = Numeric.easeInQuad(t);
                    var dt = Numeric.easeOutQuad(t);
                    var ht = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );

            this.zoomToAnimation.addSegment(
                0.5,
                midValue,
                1.0,
                endValue,
                function(t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    var dt = Numeric.easeInQuad(t);
                    var ht = Numeric.easeInQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );
        } else {
            // Add only one segments
            this.zoomToAnimation.addSegment(
                0.0,
                startValue,
                1.0,
                endValue,
                function(t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    var dt = Numeric.easeInQuad(t);
                    var ht = Numeric.easeInQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                        Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                        Numeric.lerp(dt, a[2], b[2]), // distance
                        Numeric.lerp(t, a[3], b[3]), // tilt
                        Numeric.lerp(ht, a[4], b[4]) // heading
                    ];
                }
            );
        }

        var self = this;
        this.zoomToAnimation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            self.zoomToAnimation = null;
            self.ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
            self.updateGeoCenter();
        };

        this.ctx.addAnimation(this.zoomToAnimation);

        this.zoomToAnimation.start();
    };

    /**
     * Applies to rotation matrix
     * @function applyLocalRotation
     * @memberof Navigation#
     */
    PlanetNavigation.prototype.applyLocalRotation = function(matrix) {
        mat4.rotate(matrix, Numeric.toRadian(this.heading), [0.0, 0.0, 1.0]);
        mat4.rotate(matrix, Numeric.toRadian(90 - this.tilt), [1.0, 0.0, 0.0]);
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof Navigation#
     */
    PlanetNavigation.prototype.computeViewMatrix = function() {
        const oldMatrix = Array.from(this.renderContext.getViewMatrix());
        this.computeInverseViewMatrix();
        mat4.inverse(
            this.inverseViewMatrix,
            this.renderContext.getViewMatrix()
        );
        if (!mat4.equal(this.renderContext.getViewMatrix(), oldMatrix)) {
            this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        }
        this.renderContext.requestFrame();
    };

    /**
     * Compute the inverse view matrix
     * @function computeInverseViewMatrix
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.computeInverseViewMatrix = function() {
        this.ctx
            .getCoordinateSystem()
            .getLHVTransform(this.geoCenter, this.inverseViewMatrix);
        this.applyLocalRotation(this.inverseViewMatrix);
        mat4.translate(this.inverseViewMatrix, [0.0, 0.0, this.distance]);
    };

    /**
     * Zoom to the current observed location
     * @function zoom
     * @memberof PlanetNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    PlanetNavigation.prototype.zoom = function(delta, scale) {
        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.distance *= scale;
        } else {
            this._distance *= 1 + delta * 0.1;
        }

        this.distance = Math.max(
            Math.min(this.distance, this.maxDistance),
            this.minDistance
        );

        // compute the view matrix with new values
        this.computeViewMatrix();
    };

    /**
     * Pans the camera
     * @function pan
     * @memberof PlanetNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    PlanetNavigation.prototype.pan = function(dx, dy) {
        // Get geographic frame
        var local2World = mat4.create();
        var coordinateSystem = this.ctx.getCoordinateSystem();
        coordinateSystem.getLocalTransform(this.geoCenter, local2World);
        // Then corresponding vertical axis and north
        var z = vec3.create();
        var previousNorth = vec3.create([0.0, 1.0, 0.0]);
        coordinateSystem.getUpVector(local2World, z);
        //coordinateSystem.getFrontVector( local2World, previousNorth );
        mat4.multiplyVec3(local2World, previousNorth, previousNorth);

        // Then apply local transform
        this.applyLocalRotation(local2World);
        // Retrieve corresponding axes
        var x = vec3.create();
        var y = vec3.create();
        coordinateSystem.getSideVector(local2World, x);
        coordinateSystem.getFrontVector(local2World, y);
        // According to our local configuration, up is y and side is x

        // Compute direction axes
        vec3.cross(z, x, y);
        vec3.cross(y, z, x);
        vec3.normalize(x, x);
        vec3.normalize(y, y);

        //Normalize dx and dy
        dx = dx / this.renderContext.getCanvas().width;
        dy = dy / this.renderContext.getCanvas().height;

        // Move accordingly
        var position = vec3.create();
        coordinateSystem.get3DFromWorld(this.geoCenter, position);
        // FIXME: Might be interesting to be able to control minimum camera speed
        vec3.scale(x, dx * Math.max(this.distance, 1000 * this.scale), x);
        vec3.scale(y, dy * Math.max(this.distance, 1000 * this.scale), y);
        vec3.subtract(position, x, position);
        vec3.add(position, y, position);

        // Clamp onto sphere
        vec3.normalize(position);
        vec3.scale(position, coordinateSystem.getGeoide().getRadius());

        // Update geographic center
        coordinateSystem.getWorldFrom3D(position, this.geoCenter);
        this.geoCenter[2] = this.targetHeight;

        // Compute new north axis
        var newNorth = vec3.create([0.0, 1.0, 0.0]);
        coordinateSystem.getLocalTransform(this.geoCenter, local2World);
        mat4.multiplyVec3(local2World, newNorth, newNorth);

        // Take care if we traverse the pole, ie the north is inverted
        if (vec3.dot(previousNorth, newNorth) < 0) {
            this.heading = (this.heading + 180.0) % MAX_HEADING;
        }

        this.computeViewMatrix();
    };

    /**
     * Rotates the navigation
     * @function rotate
     * @memberof PlanetNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    PlanetNavigation.prototype.rotate = function(dx, dy) {
        var previousHeading = this.heading;
        var previousTilt = this.tilt;

        this.heading += dx * DELTA_HEADING;
        this.tilt += dy * DELTA_TILT;

        this.clampTilt();

        this.computeViewMatrix();
    };

    /**
     * Check for collision
     * @function hasCollision
     * @memberof PlanetNavigation#
     * @return {Boolean} collision detected ?
     */
    PlanetNavigation.prototype.hasCollision = function() {
        const eye = [
            this.inverseViewMatrix[12],
            this.inverseViewMatrix[13],
            this.inverseViewMatrix[14]
        ];
        const geoEye = vec3.create();
        this.ctx.getCoordinateSystem().from3DToGeo(eye, geoEye);
        const elevation = this.ctx.getElevation(geoEye[0], geoEye[1]);

        const near = this.ctx.getRenderContext().near;

        const dist = geoEye[2] - elevation - 25;
        const collides = dist < 0;

        if (collides) {
            this.offset = -dist + 25;
        }

        return collides;
    };

    /**
     * Compute the new geocenter, being the intersection point
     * with the center of the screen
     */
    PlanetNavigation.prototype.updateGeoCenter = function() {
        const canvas = this.renderContext.canvas;
        const width = canvas.width;
        const height = canvas.height;

        // Recompute the geo position, trace a new ray to check intersection with the terrain
        this.computeInverseViewMatrix();
        const eye = [
            this.inverseViewMatrix[12],
            this.inverseViewMatrix[13],
            this.inverseViewMatrix[14]
        ];
        const pos = vec3.create();
        this.ctx.getCoordinateSystem().fromGeoTo3D(this.geoCenter, pos);
        const dir = vec3.create();
        vec3.subtract(pos, eye, dir);
        vec3.normalize(dir);
        var r = new Ray(eye, dir);

        //const center = this.ctx.globe.getLonLatFromPixel(width / 2, height / 2);
        const center = this.ctx.globe.computeIntersection(r);
        if (center != null && center != undefined) {
            this.geoCenter = center;
            // Update distance
            const center3D = vec3.create();
            this.ctx
                .getCoordinateSystem()
                .fromGeoTo3D(this.geoCenter, center3D);
            this.distance = vec3.dist(center3D, eye);
        }
    };

    /**
     * Returns the distance in meters.
     * @return {float} the distance in meters from the surface of the globe
     */
    PlanetNavigation.prototype.getDistance = function() {
        return this._distance;
    };

    /**
     * Returns a Heading where the values are included in [0,360]
     * @return {number}
     */
    PlanetNavigation.prototype.getHeading = function() {
        return ((this.heading % MAX_HEADING) + MAX_HEADING) % MAX_HEADING;
    };

    /**
     * Destroy
     * @function destroy
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.minDistance = null;
        this.maxDistance = null;
        this.geoCenter = null;
        this._distance = null;
        this.heading = null;
        this.tilt = null;
        this.inverseViewMatrix = null;
    };

    /**
     * Update the navigator inner values
     * @function update
     * @memberof PlanetNavigation#
     * @fires Navigation#navigation:changedDistance
     */
    PlanetNavigation.prototype.update = function() {
        if (!this.ctx.globe.tileManager.level0TilesLoaded) {
            return;
        }

        if (Number.isNaN(this.distance)) {
            this.distance = this.maxDistance;
            this._distance = this.cameraHeight;
        }

        const rc = this.ctx.getRenderContext();

        // Update the near plane distance
        rc.near = this.distance * 0.25;

        this.computeViewMatrix();

        if (this.hasCollision()) {
            const hc = this.cameraHeight;
            const ht = this.targetHeight;
            const nh = (hc + this.offset - ht) / this._distance;
            const as = Math.asin(nh); // New tilt value
            if (Number.isNaN(as)) {
                console.log(
                    `NaN ! ${hc}, ${ht}, ${this.offset}, ${
                        this._distance
                    }, ${nh}`
                );
                this._distance += this.offset;
            } else {
                this.tilt = (as * 180) / Math.PI;
                this.clampTilt();
            }
            this.computeViewMatrix();
        }

        this.ctx.publish(
            Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
            this.cameraHeight
        );
    };

    /**
     * Clamp the tilt value between 5 and 90 degrees
     * @function clampTilt
     * @memberof PlanetNavigation#
     */
    PlanetNavigation.prototype.clampTilt = function() {
        this.tilt = Math.min(Math.max(this.tilt, MIN_TILT), MAX_TILT);
    };

    PlanetNavigation.prototype.donePanning = function() {
        this.updateGeoCenter();
    };

    PlanetNavigation.prototype.doneRotating = function() {
        this.updateGeoCenter();
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof PlanetNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = 1000] - Duration of animation in milliseconds
     */
    PlanetNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, endValue);
        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);

        this.startHeading = this.getHeading();
        if (this.startHeading > 180) {
            this.endHeading = MAX_HEADING;
        } else {
            this.endHeading = MIN_HEADING;
        }

        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var animation = AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                navigation.heading = value;
                navigation.computeViewMatrix();
            }
        });

        animation.addSegment(
            0.0,
            this.startHeading,
            1.0,
            this.endHeading,
            function(t, a, b) {
                return Numeric.lerp(t, a, b);
            }
        );

        this.ctx.addAnimation(animation);
        animation.start();
    };

    /**************************************************************************************************************/

    return PlanetNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of navigation to control the camera on the WebGL scene.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
 *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
 *         It is used to view the sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
 *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
 *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
 *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
 *     </tr>
 * </table>
 *
 * The camera is automatically instantiated by the context {@link AbstractContext}, which is created by client.
 * Usually, the navigation is in 3D (AstroNavigation or PlanetNavigation). However, in a particular case, when
 * the client selects a  {@link module:Crs.CoordinateSystemFactory Coordinate Reference System} with a
 * {@link module:Crs.ProjectedCrs projection}, the {@link module:Navigation.FlatNavigation FlatNavigation} is selected.<br/>
 *
 * Then the client can control the navigation by its {@link Navigation interface}
 *
 * <p><p>
 * In addition, the navigation is controlled by the user with the help of devices : keyboard, touch, mouse.
 * When creating the Mizar instance, the user can define a list of supported devices to be able to control the
 * navigation by these devices. By default, the {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler}
 * and {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} are set up.
 * When the parameter <i>isMobile</i> is set to true in {@link Mizar} options, then the
 * {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} is set up
 *
 * <p>
 * @todo Crer un tuto pour montrer les principales mthodes de Navigation et le changement de 3D <--> 2D
 * @module Navigation
 * @implements {Navigation}
 */
define('Navigation/AstroNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**
     * Astro navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.astro_configuration
     * @property {float[]} [initTarget = [0,0]] - initial target of the camera in decimal degree (longitude, latitude)
     * @property {float} [initFov = 0.001] - initial field of view of the camera in decimal degree
     * @property {float} [minFov = 0.001] - Minimal field of view of the camera in decimal degree
     * @property {float} [maxFov = 100] - Maximal field of view of the camera in decimal degree
     * @property {float[]} [up = [0.0, 0.0, 1.0]] - Up vector that defines the north
     */

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Default min FOV.
     * @type {number}
     */
    const DEFAULT_MIN_FOV = 0.001;

    /**
     * Default max FOV.
     * @type {number}
     */
    const DEFAULT_MAX_FOV = 100;

    /**
     * Arbitrary middle fov value which determines if the animation needs two segments
     * @type {number}
     */
    const DEFAULT_MIDDLE_FOV = 25;

    /**
     * Final FOV.
     * @type {number}
     */
    const DEFAULT_FINAL_FOV = 2.0;

    /**
     * @name AstroNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
     *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
     *         It is used to view the sky.</td>
     *     </tr>
     * </table>
     * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
     * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
     * @augments AbstractNavigation
     * @param {SkyContext} ctx - Sky context
     * @param {AbstractNavigation.astro_configuration} options - navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var AstroNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.AstroNavigation,
            ctx,
            options
        );

        // Default values for fov (in degrees)
        this.minFov = this.options.minFov || DEFAULT_MIN_FOV;
        this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV;

        // Initialize the navigation
        this.center3d = [1.0, 0.0, 0.0];
        this.up = [0.0, 0.0, 1.0];
        _setInitTarget.call(this, this.options.initTarget);
        _setInitFov.call(this, this.options.initFov);
        _setUpVector.call(this, this.options.up);

        // Update the view matrix now
        this.computeViewMatrix();
    };

    /**
     * Defines the Up vector.
     * @param up
     * @private
     */
    function _setUpVector(up) {
        if (up) {
            this.up = up;
        }
    }

    /**
     * Defines the field of view of the camera at initialisation.<br/>
     * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
     * @param {float|undefined} initFov
     * @private
     */
    function _setInitFov(initFov) {
        if (initFov) {
            if (this.minFov > initFov) {
                this.minFov = initFov;
            } else if (this.maxFov < initFov) {
                this.maxFov = initFov;
            }
            this.renderContext.setFov(initFov);
            this._clampFov();
        }
    }

    /**
     * Defines the position where the camera looks at.
     * @param {float[]|undefined} initTarget
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.ctx
                .getCoordinateSystem()
                .get3DFromWorld(initTarget, this.center3d);
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.up[0] = position3d[0];
                navigation.up[1] = position3d[1];
                navigation.up[2] = position3d[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.ctx.getRenderContext().setFov(value[2]);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the middleFov at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} middleFov - FOV
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        middleFov
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            middleFov
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} animation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(animation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        animation.addSegment(parameter, startValue, 1.0, endValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeOutQuad(t);
            var dt = Numeric.easeInQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} animation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @private  
     * @fires Navigation#navigation:changedDistance       
     */
    function _addStop(animation, ctx, destDistance, options) {
        animation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            animation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes parameters for animation
     * @param {AbstractContext} ctx - context
     * @param {Array.<float>} center3D - start position in 3D
     * @param {Array.<float>} geoPos - stop position
     * @param {float} startFov - start FOV
     * @param {float} destFov - stop FOV
     * @return {Array.<float>} Returns [startValue, endValue]
     * @private
     */
    function _computeParametersAnimation(
        ctx,
        center3D,
        geoPos,
        startFov,
        destFov
    ) {
        var geoStart = [];
        ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
        var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
        var startValue = [path[0], geoStart[1], startFov];
        var endValue = [path[1], geoPos[1], destFov];
        return [startValue, endValue];
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, AstroNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof AstroNavigation#
     * @return {float[]}
     */
    AstroNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = [];
            this.ctx
                .getCoordinateSystem()
                .getWorldFrom3D(this.center3d, center);
        }
        return center;
    };

    /**
     * ZoomTo a 3D position
     * @function zoomTo
     * @param {float[]} geoPos - target of the camera
     * @param {Object} options - options
     * @param {float} [options.fov = DEFAULT_FINAL_FOV] - field of view in degree
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] - duration of the animation in milliseconds
     * @param {navigationCallback} [options.callback] - Called at the end of navigation
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.zoomTo = function(geoPos, options) {
        var navigation = this;

        // default values
        var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;

        // Create a single animation to animate center3d and fov
        var parameters = _computeParametersAnimation.call(
            this,
            this.ctx,
            this.center3d,
            geoPos,
            this.renderContext.getFov(),
            destFov
        );
        var startValue = parameters[0];
        var endValue = parameters[1];

        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        // End point which is out of frustum invokes two steps animation, one step otherwise
        var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        if (
            DEFAULT_MIDDLE_FOV > this.renderContext.getFov() &&
            this.renderContext
                .getWorldFrustum()
                .containsSphere(end3DValue, 0.005) < 0
        ) {
            // Two steps animation, 'rising' & 'falling'
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                DEFAULT_MIDDLE_FOV
            );
        } else {
            // One step animation, 'falling' only
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destFov, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof AstroNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = DEFAULT_DURATION_NORTH] - Duration of animation in milliseconds
     */
    AstroNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, startValue);
        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, endValue);
        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _addZoomIn.call(this, moveUpToAnimation, startValue, endValue);
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
     * Computes the view matrix
     * @function computeViewMatrix
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.computeViewMatrix = function() {
        vec3.normalize(this.center3d);
        var vm = this.renderContext.getViewMatrix();
        mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);
        this.up = [vm[1], vm[5], vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**
     * Event handler for mouse wheel
     * @function zoom
     * @memberof AstroNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    AstroNavigation.prototype.zoom = function(delta, scale) {
        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.renderContext.setFov(
                (this.renderContext.getFov() * 1) / scale
            );
        } else {
            // Arbitrary value for smooth zooming
            this.renderContext.setFov(
                this.renderContext.getFov() * (1 + delta * 0.1)
            );
        }

        this._clampFov();
        this.computeViewMatrix();
    };

    /**
     * Pan the navigation by computing the difference between 3D centers
     * @function pan
     * @memberof AstroNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    AstroNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.getCanvas().width / 2.0;
        var y = this.renderContext.getCanvas().height / 2.0;
        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
        this.center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        this.computeViewMatrix();
    };

    /**
     * Rotates the navigation
     * @function rotate
     * @memberof AstroNavigation#
     * @param {float} dx Window delta x
     */
    AstroNavigation.prototype.rotate = function(dx) {
        // constant tiny angle
        var angle = Numeric.toRadian(dx * DELTA_HEADING);
        var rot = quat4.fromAngleAxis(angle, this.center3d);
        quat4.multiplyVec3(rot, this.up);
        this.computeViewMatrix();
    };

    /**
     * Clamping of fov
     * @function _clampFov
     * @memberof AstroNavigation#
     * @private
     */
    AstroNavigation.prototype._clampFov = function() {
        if (this.renderContext.getFov() > this.maxFov) {
            this.renderContext.setFov(this.maxFov);
        }
        if (this.renderContext.getFov() < this.minFov) {
            this.renderContext.setFov(this.minFov);
        }
    };

    /**
     * Destroy
     * @function destroy
     * @memberof AstroNavigation#
     */
    AstroNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.minFov = null;
        this.maxFov = null;
        this.center3d = null;
        this.up = null;
    };

    /**************************************************************************************************************/

    return AstroNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/FlatNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**
     * Flat navigation configuration
     * @typedef {AbstractNavigation.configuration} AbstractNavigation.flat_configuration
     * @property {float[]} [initTarget = [0, 0, 5.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
     * at initialisation. distance in meter is optional.
     * @property {float} [minDistance = DEFAULT_MIN_DISTANCE] - The minimum distance in meter from the surface of the globe
     * or options.initTarget[2] when this one is inferior to options.minDistance
     * @property {float} [maxDistance = 5.0 * RADIUS_PLANET] - The maximum distance in meter or
     * options.initTarget[2] when this one is superior to options.maxDistance
     */

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000.0;

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degree.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Rotation axis according to the center of the map (0,0).
     * Long, lat, distance as vector length
     * @type {number[]}
     */
    const ROTATION_AXIS = [0.0, 0.0, 1.0];

    /**
     * 3D cartesian of planet center.
     * Long lat distance as vector ength.
     * @type {number[]}
     */
    const CENTER = [0.0, 0.0, 0.0];

    /**
     * Default min distance in meter.
     * @type {number}
     */
    const DEFAULT_MIN_DISTANCE = 60000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * @name FlatNavigation
     * @class
     * <table border="0">
     *     <tr>
     *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
     *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context. A 2D navigation
     *         provides a navigation for which there is no tilt and no roll <img src="https://developers.google.com/kml/documentation/kmlreference"/></td>
     *     </tr>
     * </table>
     * @augments AbstractNavigation
     * @param {PlanetContext} ctx - Planet context
     * @param {AbstractNavigation.flat_configuration} options - Flat navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var FlatNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.FlatNavigation,
            ctx,
            options
        );

        // Default values for min and max distance (in meter)
        this.minDistance = this.options.minDistance || DEFAULT_MIN_DISTANCE;
        this.maxDistance =
            this.options.maxDistance ||
            (5.0 *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()) /
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale();

        // Scale min and max distance from meter to internal ratio
        this.minDistance *= this.ctx
            .getCoordinateSystem()
            .getGeoide()
            .getHeightScale();
        this.maxDistance *= this.ctx
            .getCoordinateSystem()
            .getGeoide()
            .getHeightScale();

        // Initialize the navigation
        this.center = CENTER;
        this.distance = this.maxDistance;
        this.heading = 0;
        this.up = [0.0, 1.0, 0.0];
        _setInitTarget.call(this, this.options.initTarget);

        this.computeViewMatrix();
    };

    /**
     * Defines the position where the camera looks at and the distance of the camera from the planet's surface.
     * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            var pos = this.ctx.getCoordinateSystem().get3DFromWorld(initTarget);
            this.center[0] = pos[0];
            this.center[1] = pos[1];
            this.distance =
                initTarget.length === 3
                    ? initTarget[2] *
                      this.ctx
                          .getCoordinateSystem()
                          .getGeoide()
                          .getHeightScale()
                    : this.distance;
            if (this.distance < this.minDistance) {
                this.minDistance = this.distance;
            }
            if (this.distance > this.maxDistance) {
                this.maxDistance = this.distance;
            }
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var angle = value - navigation.heading;
                navigation.heading = value;
                var rot = quat4.fromAngleAxis(
                    Numeric.toRadian(angle),
                    ROTATION_AXIS
                );
                quat4.multiplyVec3(rot, navigation.up);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Rotates from startHeading to North
     * @param {AbstractAnimation} animation - animation on which the rotation is applied
     * @param {float} startHeading - start heading
     * @private
     */
    function _rotateAnimationToNorth(animation, startHeading) {
        var endHeading;
        if (startHeading > 180) {
            endHeading = MAX_HEADING;
        } else {
            endHeading = MIN_HEADING;
        }
        animation.addSegment(0.0, startHeading, 1.0, endHeading, function(
            t,
            a,
            b
        ) {
            return Numeric.lerp(t, a, b);
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                navigation.center[0] = value[0];
                navigation.center[1] = value[1];
                navigation.distance = value[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the maxAltitude at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} maxAltitude - altitude (as vector length) where the camera FOV contains the center and the target position
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        maxAltitude
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            maxAltitude
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(zoomToAnimation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        zoomToAnimation.addSegment(
            parameter,
            startValue,
            1.0,
            endValue,
            function(t, a, b) {
                var pt = Numeric.easeOutQuad(t);
                var dt = Numeric.easeInQuad(t);
                return [
                    Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                    Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                    Numeric.lerp(dt, a[2], b[2])
                ]; // distance
            }
        );
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} zoomToAnimation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @private
     * @fires Navigation#navigation:changedDistance
     */
    function _addStop(zoomToAnimation, ctx, destDistance, options) {
        zoomToAnimation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            zoomToAnimation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes altitude (as vector length) for which the fov see the distance between worldStart-worldEnd
     * @param {AbstractContext} ctx - context
     * @param {float[]} worldStart - Starting position as [longitude, latitude, distance]
     * @param {float[]} worldEnd - Ending position as [longitude, latitude, distance]
     * @return {number} the altitude for which the fov see the distance worldStart-worldEnd
     * @private
     */
    function _computeMaxAltitudeForZoomAnimation(ctx, worldStart, worldEnd) {
        var vec = vec3.subtract(worldStart, worldEnd);
        var len = vec3.length(vec);
        var canvas = ctx.getRenderContext().getCanvas();
        var fov = ctx.getRenderContext().getFov();
        var minFov = Math.min(
            Numeric.toRadian(fov),
            Numeric.toRadian((fov * canvas.width) / canvas.height)
        );
        return len / 2.0 / Math.tan(minFov / 2.0);
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, FlatNavigation);

    /**************************************************************************************************************/

    /**
     * @function getCenter
     * @memberof FlatNavigation#
     * @return {float[]} Returns the central position of the camera
     */
    FlatNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = this.center;
        }
        return center;
    };

    /**
     * Saves the current navigation state.
     * @function save
     * @memberof FlatNavigation#
     * @return {{center: *, distance: *, up: *}} a JS object containing the navigation state
     */
    FlatNavigation.prototype.save = function() {
        return {
            center: this.center,
            distance: this.distance,
            up: this.up
        };
    };

    /**
     * Restores the navigation state.
     * @function restore
     * @memberof FlatNavigation#
     * @param {Object} state a JS object containing the navigation state
     * @param {float[]} state.center - Center of the camera's field of view in decimal degree as [longitude, latitude]
     * @param {int} state.distance - Distance in meters from the surface of the globe to the camera
     */
    FlatNavigation.prototype.restore = function(state) {
        this.center = state.center;
        this.distance = state.distance;
        this.up = state.up;
        this.computeViewMatrix();
    };

    /**
     * Computes the view matrix.
     * @function computeViewMatrix
     * @memberof FlatNavigation#
     */
    FlatNavigation.prototype.computeViewMatrix = function() {
        var vm = this.renderContext.getViewMatrix();
        var eye = [this.center[0], this.center[1], this.distance];
        mat4.lookAt(eye, this.center, this.up, vm);
        this.up = [vm[1], vm[5], vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**
     * Zooms to a geographic position by creating an animation.
     *
     * @function zoomTo
     * @memberof FlatNavigation#
     * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
     * @param {Object} options - options
     * @param {int} [options.distance] - Final zooming distance in meters. By default, the distance does not change
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] -  Duration of animation in milliseconds
     * @param {navigationCallback} options.callback - Callback at the end of animation
     */
    FlatNavigation.prototype.zoomTo = function(geoPos, options) {
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE);
        var navigation = this;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;
        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        var destDistance =
            options && options.distance
                ? options.distance
                : this.distance /
                  this.ctx
                      .getCoordinateSystem()
                      .getGeoide()
                      .getHeightScale();
        var pos = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        var startValue = [this.center[0], this.center[1], this.distance];
        var endValue = [
            pos[0],
            pos[1],
            destDistance *
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getHeightScale()
        ];

        var maxAltitude = _computeMaxAltitudeForZoomAnimation.call(
            this,
            this.ctx,
            this.center,
            pos
        );

        if (maxAltitude > this.distance) {
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                maxAltitude
            );
        } else {
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destDistance, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    /**
     * Zoom to the current observed location
     * @function zoom
     * @memberof FlatNavigation#
     * @param {float} delta Delta zoom
     * @param {float} scale Scale
     */
    FlatNavigation.prototype.zoom = function(delta, scale) {
        var previousDistance = this.distance;

        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.distance *= scale;
        } else {
            this.distance *= 1 + delta * 0.1;
        }

        if (this.distance > this.maxDistance) {
            this.distance = previousDistance;
        }
        if (this.distance < this.minDistance) {
            this.distance = previousDistance;
        }

        //TODO : add the collision algorithm because of the elevation

        this.computeViewMatrix();
        this.ctx.publish(
            Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
            this.getDistance()
        );
    };

    /**
     * Pans the camera
     * @function pan
     * @memberof FlatNavigation#
     * @param {int} dx Window delta x
     * @param {int} dy Window delta y
     */
    FlatNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.getCanvas().width / 2.0;
        var y = this.renderContext.getCanvas().height / 2.0;

        // Get the most-left point
        var ptLeft = this.ctx.getLonLatFromPixel(0, y);
        if (ptLeft === null && dx > 0) {
            dx = 0;
        }

        // Get the most-right point
        var ptRight = this.ctx.getLonLatFromPixel(
            this.renderContext.getCanvas().width,
            y
        );
        if (ptRight === null && dx < 0) {
            dx = 0;
        }

        // Get the most-top point
        var ptTop = this.ctx.getLonLatFromPixel(x, 0);
        if (ptTop === null && dy > 0) {
            dy = 0;
        }

        // Get the most-bottom point
        var ptBottom = this.ctx.getLonLatFromPixel(
            x,
            this.renderContext.getCanvas().height
        );
        if (ptBottom === null && dy < 0) {
            dy = 0;
        }

        if (dx === 0 && dy === 0) {
            return;
        }

        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);

        this.center = ray.computePoint(
            ray.planeIntersect(CENTER, ROTATION_AXIS)
        );

        this.computeViewMatrix();
    };

    /**
     * Camera heading.
     * @function rotate
     * @memberof FlatNavigation#
     * @param {int} dx Window delta x
     */
    FlatNavigation.prototype.rotate = function(dx) {
        // Constant tiny angle
        var angle = dx * DELTA_HEADING;
        this.heading += angle;
        var rot = quat4.fromAngleAxis(Numeric.toRadian(angle), ROTATION_AXIS);
        quat4.multiplyVec3(rot, this.up);
        this.computeViewMatrix();
    };

    /**
     * Returns the distance in meters.
     * @function getDistance
     * @memberof FlatNavigation#
     * @return {float} the distance in meters from the surface of the globe
     */
    FlatNavigation.prototype.getDistance = function() {
        return (
            this.distance *
            this.ctx
                .getCoordinateSystem()
                .getGeoide()
                .getRealPlanetRadius()
        );
    };

    /**
     * Returns the heading of the camera.
     * @function getHeading
     * @memberof FlatNavigation#
     * @return {number} the heading angle between [0, 360]
     */
    FlatNavigation.prototype.getHeading = function() {
        return ((this.heading % MAX_HEADING) + MAX_HEADING) % MAX_HEADING;
    };

    /**
     * Moves up vector.
     * @function moveUpTo
     * @memberof FlatNavigation#
     * @param {float[]} vec Vector
     * @param {int} [duration = DEFAULT_DURATION_NORTH] - Duration of animation in milliseconds
     */
    FlatNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = [];
        var endValue = this.up;
        endValue[0] = Numeric.toDegree(endValue[0]);
        endValue[1] = Numeric.toDegree(endValue[1]);
        endValue[2] = endValue[2];

        this.ctx.getCoordinateSystem().getWorldFrom3D(vec, startValue);

        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _rotateAnimationToNorth.call(
            this,
            moveUpToAnimation,
            this.getHeading()
        );
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
     * Destroy
     * @function destroy
     * @memberof FlatNavigation#
     */
    FlatNavigation.prototype.destroy = function() {
        AbstractNavigation.prototype.destroy.call(this);
        this.up = null;
        this.minDistance = null;
        this.maxDistance = null;
        this.heading = null;
        this.center = null;
        this.distance = null;
    };

    /**************************************************************************************************************/

    return FlatNavigation;
});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/GroundNavigation',[
    "../Utils/Utils",
    "../Utils/Constants",
    "./AbstractNavigation",
    "../Animation/SegmentedAnimation",
    "../Animation/AnimationFactory",
    "../Utils/Numeric",
    "../Renderer/Ray",
    "../Renderer/glMatrix"
], function(
    Utils,
    Constants,
    AbstractNavigation,
    SegmentedAnimation,
    AnimationFactory,
    Numeric,
    Ray
) {
    /**************************************************************************************************************/

    /**
     * Duration of animation in milliseconds to align the camera with the north.
     * @type {number}
     */
    const DEFAULT_DURATION_NORTH = 1000;

    /**
     * Default duration in millisecond for zoom feature.
     * @type {number}
     */
    const DEFAULT_DURATION_ZOOM = 5000;

    /**
     * Default min FOV.
     * @type {number}
     */
    const DEFAULT_MIN_FOV = 0.5;

    /**
     * Default max FOV.
     * @type {number}
     */
    const DEFAULT_MAX_FOV = 70;

    /**
     * Arbitrary middle fov value which determines if the animation needs two segments
     * @type {number}
     */
    const DEFAULT_MIDDLE_FOV = 25;

    /**
     * Final FOV.
     * @type {number}
     */
    const DEFAULT_FINAL_FOV = 2.0;

    /**
     * 3D position of the azimuth 0.
     * @type {number[]}
     */
    const DEFAULT_AZIMUTH_ZERO = [1.0, 0.0, 0.0];

    /**
     * Min heading value in decimal degree.
     * @type {number}
     */
    const MIN_HEADING = 0.0;

    /**
     * Max heading value in decimal degee.
     * @type {number}
     */
    const MAX_HEADING = 360.0;

    /**
     * Difference between two successive rotation (in degree) of the camera.
     * @type {number}
     */
    const DELTA_HEADING = 0.05;

    /**
     * Default heading in decimal degree.
     * @type {number}
     */
    const DEFAULT_HEADING = MIN_HEADING;

    /**
     * @name GroundNavigation
     * @class
     * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
     * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
     * @augments AstroNavigation
     * @param {GroundContext} ctx - ground context
     * @param {AbstractNavigation.astro_configuration} options - navigation configuration
     * @constructor
     * @memberof module:Navigation
     */
    var GroundNavigation = function(ctx, options) {
        AbstractNavigation.prototype.constructor.call(
            this,
            Constants.NAVIGATION.GroundNavigation,
            ctx,
            options
        );

        // Default values for fov (in degrees)
        this.minFov = this.options.minFov || DEFAULT_MIN_FOV;
        this.maxFov = this.options.maxFov || DEFAULT_MAX_FOV;

        // Initialize the navigation
        this.center3d = DEFAULT_AZIMUTH_ZERO;
        this.up = [0.0, 0.0, 1.0];
        this.heading = this.options.initTarget
            ? this.options.initTarget[0]
            : DEFAULT_HEADING;
        _setInitTarget.call(this, this.options.initTarget);
        _setInitFov.call(this, this.options.initFov);
        _setUpVector.call(this, this.options.up);

        // Update the view matrix now
        this.computeViewMatrix();
    };

    /**
     * Defines the position where the camera looks at.
     * @param {float[]|undefined} initTarget
     * @private
     */
    function _setInitTarget(initTarget) {
        if (initTarget) {
            this.ctx
                .getCoordinateSystem()
                .get3DFromWorld(initTarget, this.center3d);
        }
    }

    /**
     * Defines the field of view of the camera at initialisation.<br/>
     * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
     * @param {float|undefined} initFov
     * @private
     */
    function _setInitFov(initFov) {
        if (initFov) {
            if (this.minFov > initFov) {
                this.minFov = initFov;
            } else if (this.maxFov < initFov) {
                this.maxFov = initFov;
            }
            this.renderContext.setFov(initFov);
            this._clampFov();
        }
    }

    /**
     * Defines the Up vector.
     * @param up
     * @private
     */
    function _setUpVector(up) {
        if (up) {
            this.up = up;
        }
    }

    /**
     * Init move up animation.
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} durationTime - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initMoveUpAnimation(navigation, durationTime) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: durationTime,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Init zoom animation
     * @param {AbstractNavigation} navigation - navigation object
     * @param {number} duration - duration of the animation in millisecond
     * @return {AbstractAnimation} animation
     * @private
     */
    function _initZoomAnimation(navigation, duration) {
        return AnimationFactory.create(Constants.ANIMATION.Segmented, {
            duration: duration,
            valueSetter: function(value) {
                var position3d = navigation.ctx
                    .getCoordinateSystem()
                    .get3DFromWorld([value[0], value[1]]);
                navigation.center3d[0] = position3d[0];
                navigation.center3d[1] = position3d[1];
                navigation.center3d[2] = position3d[2];
                navigation.ctx.getRenderContext().setFov(value[2]);
                navigation.computeViewMatrix();
            }
        });
    }

    /**
     * Adds two segments to the animation, which starts to startValue and stops to endValue
     * by crossing the middleFov at middle value of [startValue, endValue]
     * @param {AbstractAnimation} zoomToAnimation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} middleFov - FOV
     * @private
     */
    function _addZoomOutThenZoomIn(
        zoomToAnimation,
        startValue,
        endValue,
        middleFov
    ) {
        // Compute the middle value
        var midValue = [
            startValue[0] * 0.5 + endValue[0] * 0.5,
            startValue[1] * 0.5 + endValue[1] * 0.5,
            middleFov
        ];

        // zoom out to max altitude
        zoomToAnimation.addSegment(0.0, startValue, 0.5, midValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeInQuad(t);
            var dt = Numeric.easeOutQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });

        // zoom in
        _addZoomIn.call(this, zoomToAnimation, midValue, endValue, 0.5);
    }

    /**
     * Adds a segment to the animation, which starts to startValue and stops to endValue
     * @param {AbstractAnimation} animation - animation where the segment is added
     * @param {float[]} startValue - Starting position (longitude, latitude, distance as vector length)
     * @param {float[]} endValue - Ending position (longitude, latitude, distance as vector length)
     * @param {float} [startParameter=0.0] - start parameter
     * @private
     */
    function _addZoomIn(animation, startValue, endValue, startParameter) {
        var parameter = startParameter ? startParameter : 0.0;
        animation.addSegment(parameter, startValue, 1.0, endValue, function(
            t,
            a,
            b
        ) {
            var pt = Numeric.easeOutQuad(t);
            var dt = Numeric.easeInQuad(t);
            return [
                Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                Numeric.lerp(dt, a[2], b[2])
            ]; // distance
        });
    }

    /**
     * Adds an event when the animation stops.
     * @param {AbstractAnimation} animation - animation where the event is added
     * @param {AbstractContext} ctx - context
     * @param {number} destDistance - Final zooming distance in meter
     * @param {Object} [options] - options
     * @param {Object} [options.callback] - Callback function to call when it is defined.
     * @private
     * @fires Navigation#navigation:changedDistance
     */
    function _addStop(animation, ctx, destDistance, options) {
        animation.onstop = function() {
            if (options && options.callback) {
                options.callback();
            }
            animation = null;
            ctx.publish(
                Constants.EVENT_MSG.NAVIGATION_CHANGED_DISTANCE,
                destDistance
            );
        };
    }

    /**
     * Computes parameters for animation
     * @param {AbstractContext} ctx - context
     * @param {Array.<float>} center3D - start position in 3D
     * @param {Array.<float>} geoPos - stop position
     * @param {float} startFov - start FOV
     * @param {float} destFov - stop FOV
     * @return {Array.<float>} Returns [startValue, endValue]
     * @private
     */
    function _computeParametersAnimation(
        ctx,
        center3D,
        geoPos,
        startFov,
        destFov
    ) {
        var geoStart = [];
        ctx.getCoordinateSystem().getWorldFrom3D(center3D, geoStart);
        var path = Numeric.shortestPath360(geoStart[0], geoPos[0]);
        var startValue = [path[0], geoStart[1], startFov];
        var endValue = [path[1], geoPos[1], destFov];
        return [startValue, endValue];
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractNavigation, GroundNavigation);

    /**************************************************************************************************************/

    /**
     * Returns the center of the navigation.
     * @function getCenter
     * @memberof GroundNavigation#
     * @return {float[]}
     */
    GroundNavigation.prototype.getCenter = function() {
        var center = AbstractNavigation.prototype.getCenter.call(this);
        if (center == null) {
            center = [];
            this.ctx
                .getCoordinateSystem()
                .getWorldFrom3D(this.center3d, center);
        }
        return center;
    };

    /**
     * ZoomTo a 3D position
     * @function zoomTo
     * @param {float[]} geoPos - target of the camera
     * @param {Object} options - options
     * @param {float} [options.fov = DEFAULT_FINAL_FOV] - field of view in degree
     * @param {int} [options.duration = DEFAULT_DURATION_ZOOM] - duration of the animation in milliseconds
     * @param {navigationCallback} [options.callback] - Called at the end of navigation
     * @memberof GroundNavigation#
     */
    GroundNavigation.prototype.zoomTo = function(geoPos, options) {
        var navigation = this;

        // default values
        var destFov = options && options.fov ? options.fov : DEFAULT_FINAL_FOV;
        var duration =
            options && options.duration
                ? options.duration
                : DEFAULT_DURATION_ZOOM;

        // Create a single animation to animate center3d and fov
        var parameters = _computeParametersAnimation.call(
            this,
            this.ctx,
            this.center3d,
            geoPos,
            this.renderContext.getFov(),
            destFov
        );
        var startValue = parameters[0];
        var endValue = parameters[1];

        var zoomToAnimation = _initZoomAnimation.call(
            this,
            navigation,
            duration
        );

        // End point which is out of frustum invokes two steps animation, one step otherwise
        var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
        if (
            DEFAULT_MIDDLE_FOV > this.renderContext.getFov() &&
            this.renderContext
                .getWorldFrustum()
                .containsSphere(end3DValue, 0.005) < 0
        ) {
            // Two steps animation, 'rising' & 'falling'
            _addZoomOutThenZoomIn.call(
                this,
                zoomToAnimation,
                startValue,
                endValue,
                DEFAULT_MIDDLE_FOV
            );
        } else {
            // One step animation, 'falling' only
            _addZoomIn.call(this, zoomToAnimation, startValue, endValue);
        }

        _addStop.call(this, zoomToAnimation, this.ctx, destFov, options);

        this.ctx.addAnimation(zoomToAnimation);
        zoomToAnimation.start();
    };

    GroundNavigation.prototype.moveUpTo = function(vec, duration) {
        // Create a single animation to animate up
        var startValue = this.center3d;
        var endValue = DEFAULT_AZIMUTH_ZERO;
        var durationTime = duration || DEFAULT_DURATION_NORTH;

        var navigation = this;
        var moveUpToAnimation = _initMoveUpAnimation.call(
            this,
            navigation,
            durationTime
        );
        _addZoomIn.call(this, moveUpToAnimation, startValue, endValue);
        this.ctx.addAnimation(moveUpToAnimation);
        moveUpToAnimation.start();
    };

    /**
    * Compute the view matrix
    * @function computeViewMatrix
    * @memberof GroundNavigation#
    */
    GroundNavigation.prototype.computeViewMatrix = function() {
        var eye = [];
        vec3.normalize(this.center3d);

        var vm = this.renderContext.viewMatrix;

        mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);

        var geo = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geo);
        this.heading = geo[0];
        this.up = [0, 0, vm[9]];
        this.ctx.publish(Constants.EVENT_MSG.NAVIGATION_MODIFIED);
        this.renderContext.requestFrame();
    };

    /**************************************************************************************************************/

    /**
         Event handler for mouse wheel
         @function zoom
         @param delta Delta zoom
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.zoom = function(delta, scale) {
        // TODO : improve zoom, using scale or delta ? We should use scale always
        if (scale) {
            this.renderContext.setFov(
                (this.renderContext.getFov() * 1) / scale
            );
        } else {
            // Arbitrary value for smooth zooming
            this.renderContext.setFov(
                this.renderContext.getFov() * (1 + delta * 0.1)
            );
        }

        this._clampFov();
        this.computeViewMatrix();
    };

    /**************************************************************************************************************/

    /**
         Pan the navigation by computing the difference between 3D centers
         @function pan
         @param dx Window delta x
         @param dy Window delta y
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.pan = function(dx, dy) {
        var x = this.renderContext.canvas.width / 2.0;
        var y = this.renderContext.canvas.height / 2.0;
        var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
        this.center3d = ray.computePoint(
            ray.sphereIntersect(
                [0, 0, 0],
                this.ctx
                    .getCoordinateSystem()
                    .getGeoide()
                    .getRadius()
            )
        );
        this.computeViewMatrix();
    };

    /**************************************************************************************************************/

    /**
         Rotate the navigation
         @function rotate
         @param dx Window delta x
         @param dy Window delta y
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.rotate = function(dx, dy) {
        var angle = dx * DELTA_HEADING;
        var coord = [];
        this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, coord);
        this.heading += angle;
        coord[0] = this.heading;
        this.ctx.getCoordinateSystem().get3DFromWorld(coord, this.center3d);
        this.computeViewMatrix();
    };

    /**
         @function getHeading
         @memberof GroundNavigation#
         */
    GroundNavigation.prototype.getHeading = function() {
        return this.heading;
    };

    /**************************************************************************************************************/

    /**
     *    Clamping of fov
     */
    GroundNavigation.prototype._clampFov = function() {
        if (this.renderContext.getFov() > this.maxFov) {
            this.renderContext.setFov(this.maxFov);
        }
        if (this.renderContext.getFov() < this.minFov) {
            this.renderContext.setFov(this.minFov);
        }
    };

    /**************************************************************************************************************/

    return GroundNavigation;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationFactory
 * @class
 * Factory to control the camera.
 * @memberof module:Navigation
 */
define('Navigation/NavigationFactory',[
    "./PlanetNavigation",
    "./AstroNavigation",
    "./FlatNavigation",
    "./GroundNavigation",
    "../Utils/Constants"
], function(
    PlanetNavigation,
    AstroNavigation,
    FlatNavigation,
    GroundNavigation,
    Constants
) {
    return {
        /**
         * Mizar owns different types of navigation to control the camera on the WebGL scene.
         * This class allows to create a navigation based on its type (e.g Astro, Flat, Sky).
         * <table border="1">
         *     <tr>
         *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
         *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
         *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
         *         It is used to view the sky</td>
         *     </tr>
         *     <tr>
         *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
         *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
         *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
         *     </tr>
         *     <tr>
         *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
         *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
         *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
         *     </tr>
         * </table>
         * @param {NAVIGATION} type - the type of navigation
         * @param {AbstractContext} ctx - The context where the camera look at
         * @param {AbstractNavigation.astro_configuration|AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} options - see the navigations.
         * @return {Navigation} navigation
         * @alias module:Navigation.NavigationFactory.create
         * @see {@link module:Navigation.PlanetNavigation PlanetNavigation} - Control the camera and turn around the globe, wich is located
         * at the center of the webGL scene.
         * @see {@link module:Navigation.AstroNavigation AstroNavigation} - Control the camera at the center of the scene. The camera is inside the globe
         * @see {@link module:Navigation.FlatNavigation FlatNavigation} - Control the camera. The camera look at the 2D projection
         * @see {@link module:Navigation.GroundNavigation GroundNavigation} - Control the camera. The camera look at the 3D projection of the ground
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link NAVIGATION}
         */
        create: function(type, ctx, options) {
            var obj;
            switch (type) {
                case Constants.NAVIGATION.AstroNavigation:
                    obj = new AstroNavigation(ctx, options);
                    break;
                case Constants.NAVIGATION.PlanetNavigation:
                    obj = new PlanetNavigation(ctx, options);
                    break;
                case Constants.NAVIGATION.FlatNavigation:
                    obj = new FlatNavigation(ctx, options);
                    break;
                case Constants.NAVIGATION.GroundNavigation:
                    obj = new GroundNavigation(ctx, options);
                    break;
                default:
                    throw new RangeError(
                        "The type " +
                            type +
                            " is not allowed, A valid type is included in the list NAVIGATION",
                        "NavigationFactory.js"
                    );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * globalTime:set.<br/>
 * Called when the time is set
 * @event TimeTravel#globalTime:set
 * @type {Context}
 */

 /**
 * globalTime:rewind.<br/>
 * Called when the time is set to rewind
 * @event TimeTravel#globalTime:rewind
 * @type {Context}
 */

 /**
 * globalTime:forward.<br/>
 * Called when the time is set to forward
 * @event TimeTravel#globalTime:forward
 * @type {Context}
 */

/**
 * Compass module : map control with "north" composant
 */
define('Gui/TimeTravel',["jquery", "../Utils/Constants", "../Services/TimeTravelCore"], function(
    $,
    Constants,
    TimeTravelCore
) {
    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var svgDoc;

    const REWIND_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTExIDE4VjZsLTguNSA2IDguNSA2em0uNS02bDguNSA2VjZsLTguNSA2eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+";
    const FORWARD_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+ICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";
    const HOUR_GLASS_SVG =
        "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjMDAwMDAwIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4gICAgPHBhdGggZD0iTTYgMnY2aC4wMUw2IDguMDEgMTAgMTJsLTQgNCAuMDEuMDFINlYyMmgxMnYtNS45OWgtLjAxTDE4IDE2bC00LTQgNC0zLjk5LS4wMS0uMDFIMThWMkg2em0xMCAxNC41VjIwSDh2LTMuNWw0LTQgNCA0em0tNC01bC00LTRWNGg4djMuNWwtNCA0eiIvPiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=";

    /**
     * Create a time travel Widget
     * @param options
     * @throws {ReferenceError} Can't get the Div to insert the time tracker
     * @throws {ReferenceError} Can't get the element name
     * @constructor
     * @fires TimeTravel#globalTime:set
     * @fires TimeTravel#globalTime:rewind
     * @fires TimeTravel#globalTime:forward
     */
    var TimeTravel = function(options) {
        parentElement = options.element;
        ctx = options.ctx;

        // Add compass object to parent element
        // Don't use <object> HTML tag due to cross-origin nature of svg
        if (parentElement == null) {
            throw new ReferenceError(
                "Can't get the element name from the options parameters"
            );
        } else if (document.getElementById(options.element) == null) {
            throw new ReferenceError(
                "Can' get the div " +
                    parentElement +
                    " in the web page to insert " +
                    this.constructor.name
            );
        } else {
            // OK
        }

        var svgRewindDoc = null;
        var svgForwardDoc = null;
        var svgHourGlassDoc = null;

        document.getElementById(parentElement).innerHTML =
            '<div id="objectForward"></div><div id="objectHourGlass"></div><div id="objectRewind"></div>';

        var _handleMouseUp = function(name) {
            ctx.publish(name, ctx);
        };

        var _handleMouseUpSet = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_SET);
        };

        var _handleMouseUpForward = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_FORWARD);
        };

        var _handleMouseUpRewind = function(event) {
            _handleMouseUp(Constants.EVENT_MSG.GLOBAL_TIME_REWIND);
        };

        ctx.subscribe(
            Constants.EVENT_MSG.GLOBAL_TIME_CHANGED,
            this.updateDisplayDate
        );

        TimeTravelCore.init(options);

        $.get(
            HOUR_GLASS_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgHourGlassDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgHourGlassDoc.height.baseVal.value = 32;
                svgHourGlassDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectHourGlass").append(svgHourGlassDoc);

                options.svgHourGlassDoc = svgHourGlassDoc;
                $("#objectHourGlass svg").css({
                    float: "right",
                    fill:
                        TimeTravelCore.isCurrentDateTheFirst() &&
                        TimeTravelCore.isCurrentDateTheLast()
                            ? "#333333"
                            : "white"
                });

                svgHourGlassDoc.addEventListener("mouseup", _handleMouseUpSet);

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
        $.get(
            REWIND_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgRewindDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgRewindDoc.height.baseVal.value = 32;
                svgRewindDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectRewind").append(svgRewindDoc);
                $("#objectRewind svg").css({
                    float: "right",
                    fill: TimeTravelCore.isCurrentDateTheFirst()
                        ? "#333333"
                        : "white"
                });

                options.svgRewindDoc = svgRewindDoc;
                svgRewindDoc.addEventListener("mouseup", _handleMouseUpRewind);

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
        $.get(
            FORWARD_SVG,
            function(response) {
                // Import contents of the svg document into this document
                svgForwardDoc = document.importNode(
                    response.documentElement,
                    true
                );

                // Update width/height
                svgForwardDoc.height.baseVal.value = 32;
                svgForwardDoc.width.baseVal.value = 32;

                // Append the imported SVG root element to the appropriate HTML element
                $("#objectForward").append(svgForwardDoc);
                $("#objectForward svg").css({
                    float: "right",
                    fill: TimeTravelCore.isCurrentDateTheLast()
                        ? "#333333"
                        : "white"
                });

                options.svgForwardDoc = svgForwardDoc;
                svgForwardDoc.addEventListener(
                    "mouseup",
                    _handleMouseUpForward
                );

                if (svgRewindDoc && svgForwardDoc && svgHourGlassDoc) {
                    $("#" + parentElement).css("display", "block");
                }
            },
            "xml"
        );
    };

    /**************************************************************************************************************/

    /**
     * Update display date and send current date to context
     * @function updateDisplayDate
     * @param {Time.configuration} date Time configuration
     * @memberof TimeTravel#
     */
    TimeTravel.prototype.updateDisplayDate = function(date) {
        if (document.getElementById("textTimeTravelDiv") !== null) {
            if (
                TimeTravelCore.isCurrentDateTheFirst() &&
                TimeTravelCore.isCurrentDateTheLast()
            ) {
                document.getElementById("textTimeTravelDiv").innerHTML = "";
            } else {
                document.getElementById("textTimeTravelDiv").innerHTML =
                    date.display;
            }
        }

        ctx.setTime(date);

        var theColorRewind =
            $("#objectRewind:hover svg").css("fill") === "rgb(255, 0, 0)"
                ? "red"
                : "white";
        var theColorForward =
            $("#objectForward:hover svg").css("fill") === "rgb(255, 0, 0)"
                ? "red"
                : "white";

        $("#objectRewind svg").css({
            float: "right",
            fill: TimeTravelCore.isCurrentDateTheFirst()
                ? "#333333"
                : theColorRewind
        });
        $("#objectForward svg").css({
            float: "right",
            fill: TimeTravelCore.isCurrentDateTheLast()
                ? "#333333"
                : theColorForward
        });
        $("#objectHourGlass svg").css({
            float: "right",
            fill:
                TimeTravelCore.isCurrentDateTheFirst() &&
                TimeTravelCore.isCurrentDateTheLast()
                    ? "#333333"
                    : "white"
        });

        $("#objectRewind svg")
            .mouseover(function() {
                if (TimeTravelCore.isCurrentDateTheFirst()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (TimeTravelCore.isCurrentDateTheFirst()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });

        $("#objectForward svg")
            .mouseover(function() {
                if (TimeTravelCore.isCurrentDateTheLast()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (TimeTravelCore.isCurrentDateTheLast()) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });

        $("#objectHourGlass svg")
            .mouseover(function() {
                if (
                    TimeTravelCore.isCurrentDateTheFirst() &&
                    TimeTravelCore.isCurrentDateTheLast()
                ) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "red");
                }
            })
            .mouseout(function() {
                if (
                    TimeTravelCore.isCurrentDateTheFirst() &&
                    TimeTravelCore.isCurrentDateTheLast()
                ) {
                    $(this).css("fill", "#333333");
                } else {
                    $(this).css("fill", "white");
                }
            });
    };

    /**
     *    functions
     */
    TimeTravel.prototype.remove = TimeTravelCore.remove;
    TimeTravel.prototype.goRewind = TimeTravelCore.goRewind;
    TimeTravel.prototype.goForward = TimeTravelCore.goForward;
    TimeTravel.prototype.chooseTime = TimeTravelCore.chooseTime;

    /**************************************************************************************************************/

    return TimeTravel;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * Mizar is able to handle different types of context.
 * <p>
 * A context is a concept that brings together :
 * <ul>
 *     <li>a webGL {@link AbstractGlobe globe}</li>
 *     <li>a {@link AbstractCrs coordinate reference system}</li>
 *     <li>a {@link AbstractNavigation navigation}</li>
 * </ul>
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Context.SkyContext SkyContext}</td>
 *         <td>A context representing a sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Context.PlanetContext PlanetContext}</td>
 *         <td>A context representing a planet</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Context.GroundContext GroundContext}</td>
 *         <td>A context representing a planet's ground</td>
 *     </tr>
 * </table>
 *
 * The context is automatically instantiated by the method createContext from {@link Mizar}.
 * <br/>
 * In addition to the classes, a {@link module:Context.ContextFactory factory} and a {@link ContextManager context manager}
 * are availables to help for creating context. Once the context is created, the client can handle it by the use of its
 * {@link Context interface}.
 *
 * @module Context
 * @implements {Context}
 */
define('Context/PlanetContext',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Utils/Constants",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/Compass",
    "../Gui/TimeTravel",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    Utils,
    AbstractContext,
    Constants,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    Compass,
    TimeTravel,
    ErrorDialog
) {
    /**
     * Planet context configuration
     * @typedef {Object} AbstractContext.planetContext
     * @property {float} [tileErrorTreshold=3]
     * @property {float} [continuousRendering=false]
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigation - navigation configuration
     */

    /**
     * @name PlanetContext
     * @class
     * Virtual globe where the camera is outside the globe.
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.planetContext} options - planet context configuration
     * @constructor
     * @memberof module:Context
     */
    var PlanetContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Planet,
            options
        );
        var self = this;
        this.components = {
            posTrackerInfo: true,
            posTracker: true,
            elevTracker: true,
            compassDiv: true,
            timeTravelDiv: true
        };

        var planetOptions = _createPlanetConfiguration.call(this, options);

        // Initialize planet
        try {
            this.globe = GlobeFactory.create(
                Constants.GLOBE.Planet,
                planetOptions
            );
            this.navigation = _createNavigation.call(
                this,
                this.getCoordinateSystem().isFlat(),
                options.navigation
            );
            this.initGlobeEvents(this.globe);

            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

            try {
                this.setTimeTravelVisible(
                    options.timeTravel && this.components.timeTravelDiv
                        ? options.timeTravel
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Planet configuration data model
     * @typedef {Object} AbstractGlobe.dm_planet
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext|null} renderContext - Rendering context
     * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar = 0
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {boolean} renderTileWithoutTexture = true
     * @property {function} publishEvent - Callback
     */

    /**
     * Create the navigation according to the isFlat parameter.
     * @param {boolean} isFlat - The globe is projected or in 3D
     * @param {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigationOpts - Options for navigation
     * @returns {FlatNavigation|PlanetNavigation} navigation
     * @private
     */
    function _createNavigation(isFlat, navigationOpts) {
        var navigationType;
        if (isFlat) {
            navigationType = Constants.NAVIGATION.FlatNavigation;
        } else {
            navigationType = Constants.NAVIGATION.PlanetNavigation;
        }

        return NavigationFactory.create(navigationType, this, navigationOpts);
    }

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
     * @param {boolean} [options.continuousRendering = false] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet
     * @returns {AbstractGlobe.dm_planet} Planet data model.
     * @private
     */
    function _createPlanetConfiguration(options) {
        var self = this;
        return {
            tileErrorTreshold: options.tileErrorTreshold || 3,
            continuousRendering: options.continuousRendering || false,
            renderContext: options.renderContext,
            canvas: this.canvas,
            isMobile: options.isMobile || false,
            coordinateSystem: options.coordinateSystem,
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            minFar: 0,
            defaultColor: [200, 200, 200, 255],
            renderTileWithoutTexture: true,
            //todofl : redondance car params identiques
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
    }

    /**
     * Computes GeoCenter according to the coordinate reference system.
     * @param {Crs} crs - coordinate reference system
     * @returns {float[]} geocenter
     * @private
     */
    function _computeGeoCenter(crs) {
        var geoCenter;
        if (crs.isFlat()) {
            geoCenter = crs.getWorldFrom3D(this.navigation.center);
        } else {
            geoCenter = this.navigation.geoCenter;
        }
        return geoCenter;
    }

    /**
     * Propagates navigation options (inertia and mouse) when the coordinate reference system changes.
     * @param {AbstractNavigation.configuration} options - Navigation configuration
     * @private
     * @returns {Object} navigation options
     */
    function _propagateNavOptions(options) {
        var navOptions = {};
        navOptions.inertia = options.hasOwnProperty("inertia")
            ? options.inertia
            : false;
        if (options.hasOwnProperty("mouse")) {
            navOptions.mouse = options.mouse;
        }
        return navOptions;
    }

    /**
     * Updates the navigation according to the new coordinate reference system and the current settings
     * of the previous coordinate reference system
     * @param {Crs} newCrs -  the new coordinate reference system
     * @param {float[]} geoCenter - Current geo center of the camera in the previous coordinate reference system
     * @param {float} geoDistance - Distance from the globe's surface of the camera in the previous coordinate reference system
     * @param {Object} navOptions - Navigation's options
     * @param {boolean} [navOptions.inertia=false] - Inertia
     * @param {Object} [navOptions.mouse] - Mouse's configuration
     * @private
     */
    function _updateNavForNewCrs(newCrs, geoCenter, geoDistance, navOptions) {
        if (newCrs.isFlat()) {
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.FlatNavigation,
                this,
                navOptions
            );
            this.navigation.center = newCrs.get3DFromWorld(geoCenter);
        } else {
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.PlanetNavigation,
                this,
                navOptions
            );
            this.navigation.geoCenter = geoCenter;
        }
        this.navigation.distance =
            geoDistance * newCrs.getGeoide().getHeightScale();
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, PlanetContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: this.getCoordinateSystem().getGeoideName()
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setBaseElevation
     * @memberof PlanetContext#
     * @throws {TypeError} The provided error is not a WCSElevation or a WMSElevation
     */
    PlanetContext.prototype.setBaseElevation = function(layer) {
        if (
            layer.getType() !== Constants.LAYER.WCSElevation &&
            layer.getType() !== Constants.LAYER.WMSElevation
        ) {
            throw new TypeError(
                "The provided layer ID=" +
                    layer.getID() +
                    " has a type +" +
                    layer.getType() +
                    " instead of WCSElevation or WMSElevation",
                "PlanetContext.js"
            );
        }
        this.globe.setBaseElevation(layer);
        if (this.elevationTracker != null) {
            this.elevationTracker.setScaleLayer(layer);
        }
    };

    /**
     * @function setBaseElevationByID
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setBaseElevationByID = function(layerID) {
        // Find the layer by name among all the layers
        var layer = this.getLayerByID(layerID);
        if (layer) {
            this.setBaseElevation(layer);
        }
        return layer;
    };

    /**
     * @function getBaseElevation
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.getBaseElevation = function() {
        return this.globe.getBaseElevation();
    };

    /**
     * @function setCoordinateSystem
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.setCoordinateSystem = function(newCrs) {
        if (newCrs.getType() !== this.getMode()) {
            throw new RangeError(
                "incompatible coordinate reference system with Planet context",
                "PlanetContext.js"
            );
        }
        // Change navigation
        var geoCenter;
        var geoDistance;

        var self = this;
        $(self.canvas.parentElement)
            .find("#loading")
            .show();

        // Compute current position and distance in order to set them in the new navigation related to the
        // new coordinate reference system
        geoCenter = _computeGeoCenter.call(
            this,
            this.globe.getCoordinateSystem()
        );
        geoDistance =
            this.navigation.distance /
            this.globe
                .getCoordinateSystem()
                .getGeoide()
                .getHeightScale();

        // Update the coordinate reference system
        this.globe.setCoordinateSystem(newCrs);
        this.navigation.stop();

        // Creates the options for the new navigation related to the new coordinate reference system.
        // We only keep the inertia and the options for the mouse
        var navOptions = _propagateNavOptions.call(
            this,
            this.navigation.getOptions()
        );

        try {
            // Create a new navigation related to the new coordinate reference system
            _updateNavForNewCrs.call(
                this,
                newCrs,
                geoCenter,
                geoDistance,
                navOptions
            );
        } catch (err) {
            this._showUpError(err);
        }

        if (this.positionTracker) {
            this.positionTracker.detach();
            this.positionTracker.attachTo(this);
        }

        if (this.elevationTracker) {
            this.elevationTracker.detach();
            this.elevationTracker.attachTo(this);
        }

        this.navigation.computeViewMatrix();
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof PlanetContext#
     */
    PlanetContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/
    return PlanetContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Context/SkyContext',[
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/TimeTravel",
    "../Utils/Constants",
    "../Gui/dialog/ErrorDialog"
], function(
    _,
    Utils,
    AbstractContext,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    TimeTravel,
    Constants,
    ErrorDialog
) {
    /**
     * sky context configuration
     * @typedef {Object} AbstractContext.skyContext
     * @property {float} [tileErrorTreshold=1.5]
     * @property {float} [continuousRendering=true]
     * @property {float} [radius = 10.0] - Vector distance of the sky
     * @property {int} [minFar = 15]
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
     * @property {string} [compass="compassDiv"] - div element where compass is displayed
     * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
     */

    /**
     * @name SkyContext
     * @class
     * Virtual globe where the camera is inside the globe.<br/>
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.skyContext} options - skyContext configuration
     * @constructor
     * @memberof module:Context
     */
    var SkyContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Sky,
            options
        );

        var self = this;
        this.components = {
            posTrackerInfo: true,
            posTracker: true,
            elevTracker: false,
            compassDiv: true,
            timeTravelDiv: true
        };
        var skyOptions = _createSkyConfiguration.call(this, options);

        // Initialize sky
        try {
            // Create the sky
            this.globe = GlobeFactory.create(Constants.GLOBE.Sky, skyOptions);
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.AstroNavigation,
                this,
                options.navigation ? options.navigation : options
            );
            this.initGlobeEvents(this.globe);

            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

            try {
                this.setTimeTravelVisible(
                    options.timeTravel && this.components.timeTravelDiv
                        ? options.timeTravel
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Planet configuration data model
     * @typedef {Object} AbstractGlobe.dm_sky
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext} [renderContext] - Rendering context
     * @property {Crs} coordinateSystem - Coordinate reference system of the planet
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar
     * @property {float} radius
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} renderTileWithoutTexture = false
     * @property {function} publishEvent - Callback
     */

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
     * @param {boolean} [options.continuousRendering = true] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet
     * @param {float} [options.radius = 10.0] - Radius object in vector length
     * @returns {AbstractGlobe.dm_sky} Planet data model.
     * @private
     */
    function _createSkyConfiguration(options) {
        var self = this;
        var skyOptions = {
            canvas: this.canvas,
            tileErrorTreshold: options.tileErrorTreshold || 1.5,
            continuousRendering: options.continuousRendering || true,
            renderTileWithoutTexture: false,
            radius: options.radius || 10.0,
            minFar: options.minFar || 15, // Fix problem with far buffer, with planet rendering
            coordinateSystem: options.coordinateSystem,
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            defaultColor: [200, 200, 200, 255],
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
        if (options.renderContext) {
            skyOptions.renderContext = options.renderContext;
        }
        return skyOptions;
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, SkyContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof SkyContext#
     */
    SkyContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: Constants.CRS.Equatorial
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setCoordinateSystem
     * @memberof SkyContext#
     * @throws ReferenceError - incompatible coordinate reference system with Sky context
     */
    SkyContext.prototype.setCoordinateSystem = function(cs) {
        if (cs.getType() !== this.getMode()) {
            throw new ReferenceError (
                "incompatible coordinate reference system with Sky context",
                "SkyContex.js"
            );
        }
        this.globe.setCoordinateSystem(cs);
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof SkyContext#
     */
    SkyContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        if (this.timeTravel) {
            this.timeTravel.remove();
        }
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/

    return SkyContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Context/GroundContext',[
    "jquery",
    "underscore-min",
    "../Utils/Utils",
    "./AbstractContext",
    "../Utils/Constants",
    "../Globe/GlobeFactory",
    "../Navigation/NavigationFactory",
    "../Services/ServiceFactory",
    "../Gui/TimeTravel",
    "../Gui/dialog/ErrorDialog"
], function(
    $,
    _,
    Utils,
    AbstractContext,
    Constants,
    GlobeFactory,
    NavigationFactory,
    ServiceFactory,
    TimeTravel,
    ErrorDialog
) {
    /**
     * ground context configuration
     * @typedef {Object} AbstractContext.groundContext
     * @property {float} [tileErrorTreshold=1.5]
     * @property {float} [continuousRendering=true]
     * @property {float} [radius = 10.0] - Vector distance of the sky
     * @property {int} [minFar = 15]
     * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
     * @property {RenderContext} [renderContext] - Context rendering
     * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
     * @property {string} [compass="compassDiv"] - div element where compass is displayed
     * @property {string} [timeTravel="timeTravelDiv"] - div element where time travel is displayed
     */

    /**
     * @name GroundContext
     * @class
     * Virtual globe where the camera is inside the globe and having the horizontal coordinate as .<br/>
     * When an error happens at the initialisation, a message is displayed
     * @augments AbstractContext
     * @param {Mizar.configuration} mizarConfiguration - mizar configuration
     * @param {AbstractContext.skyContext} options - skyContext configuration
     * @constructor
     * @memberof module:Context
     */
    var GroundContext = function(mizarConfiguration, options) {
        AbstractContext.prototype.constructor.call(
            this,
            mizarConfiguration,
            Constants.CONTEXT.Ground,
            options
        );
        var self = this;

        this.components = {
            posTrackerInfo: false,
            posTracker: false,
            elevTracker: false,
            compassDiv: false,
            timeTravelDiv: false
        };

        var groundOptions = _createGroundConfiguration.call(this, options);

        // Initialize sky
        try {
            // Create the sky
            this.globe = GlobeFactory.create(
                Constants.GLOBE.Sky,
                groundOptions
            );
            this.navigation = NavigationFactory.create(
                Constants.NAVIGATION.GroundNavigation,
                this,
                options.navigation ? options.navigation : options
            );
            this.initGlobeEvents(this.globe);
            ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);
            try {
                this.setTimeTravelVisible(
                    options.timeTravel && this.components.timeTravelDiv
                        ? options.timeTravel
                        : "timeTravelDiv",
                    true
                );
            } catch (err) {
                ErrorDialog.open(
                    "<font style='color:orange'>Warning : " + err + "."
                );
            }
        } catch (err) {
            this._showUpError(err);
        }
    };

    /**
     * Ground configuration data model
     * @typedef {Object} AbstractGlobe.dm_ground
     * @property {Object} canvas - canvas object
     * @property {int} tileErrorTreshold - tile error treshold
     * @property {boolean} continuousRendering - continuous rendering
     * @property {renderContext} [renderContext] - Rendering context
     * @property {Crs} coordinateSystem - Coordinate reference system of the planet
     * @property {boolean} lighting = false - Lighting
     * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
     * @property {int} minFar
     * @property {float} radius
     * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
     * @property {string} shadersPath = "../../shaders/" - Shaders location
     * @property {boolean} renderTileWithoutTexture = false
     * @property {function} publishEvent - Callback
     */

    /**
     * Creates planet configuration
     * @param {Object} options
     * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
     * @param {boolean} [options.continuousRendering = true] - continuous rendering
     * @param {renderContext} [options.renderContext] - Rendering context
     * @param {Crs} options.coordinateSystem - Coordinate reference system of the planet' ground
     * @param {float} [options.radius = 10.0] - Radius object in vector length
     * @returns {AbstractGlobe.dm_ground} Ground data model.
     * @private
     */
    function _createGroundConfiguration(options) {
        var self = this;
        return {
            tileErrorTreshold: options.tileErrorTreshold || 3,
            continuousRendering: options.continuousRendering || false,
            renderContext: options.renderContext,
            canvas: this.canvas,
            coordinateSystem: options.coordinateSystem,
            shadersPath: this.mizarConfiguration.mizarAPIUrl + "shaders/",
            lighting: false,
            backgroundColor: [0.0, 0.0, 0.0, 1.0],
            minFar: 0,
            defaultColor: [200, 200, 200, 255],
            renderTileWithoutTexture: true,
            publishEvent: function(message, object) {
                self.publish(message, object);
            }
        };
    }

    /**************************************************************************************************************/

    Utils.inherits(AbstractContext, GroundContext);

    /**************************************************************************************************************/

    /**
     * @function setTimeTravelVisible
     * @memberof GroundContext#
     */
    GroundContext.prototype.setTimeTravelVisible = function(divName, visible) {
        if (visible) {
            this.timeTravel = new TimeTravel({
                element: divName,
                ctx: this,
                crs: this.getCoordinateSystem().getGeoideName()
            });
        } else {
            if (this.timeTravel) {
                this.timeTravel.remove();
            }
        }
        this.setComponentVisibility(divName, visible);
    };

    /**
     * @function setCoordinateSystem
     * @memberof GroundContext#
     * @throws RangeError - "incompatible coordinate reference system with Sky context"
     */
    GroundContext.prototype.setCoordinateSystem = function(cs) {
        if (cs.getType() !== this.getMode()) {
            throw new RangeError(
                "incompatible coordinate reference system with Sky context",
                "GroundContext.js"
            );
        }
        this.globe.setCoordinateSystem(cs);
        this.publish(Constants.EVENT_MSG.CRS_MODIFIED, this);
    };

    /**
     * @function destroy
     * @memberof GroundContext#
     */
    GroundContext.prototype.destroy = function() {
        //this.setTimeTravelVisible(false);
        if (this.timeTravel) {
            this.timeTravel.remove();
        }
        AbstractContext.prototype.destroy.call(this);
    };

    /**************************************************************************************************************/

    return GroundContext;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ContextFactory
 * @class
 * Factory to create a context
 * @memberof module:Context
 */
define('Context/ContextFactory',[
    "../Utils/Constants",
    "./PlanetContext",
    "./SkyContext",
    "./GroundContext"
], function(Constants, PlanetContext, SkyContext, GroundContext) {
    return {
        /**
         * Factory to create a context.
         *
         * Creates a context based on :
         * <ul>
         *     <li>the context type {@link CONTEXT},</li>
         *     <li>the global Mizar's configuration,</li>
         *     <li>the options for the specific context</li>
         * </ul>
         * @param {CONTEXT} type - Type of animation.
         * @param {Object} configuration - see options.configuration for {@link Mizar}
         * @param {Object} options - See options.planetContext or options.skyContext configuration for {@link Mizar}
         * @return {Context} - the object to handle an animation
         * @throws {RangeError} Type not valid - a valid type is included in the list {@link CONTEXT}
         * @alias module:Context.ContextFactory.create
         *
         */
        create: function(type, configuration, options) {
            var obj;
            switch (type) {
                case Constants.CONTEXT.Planet:
                    obj = new PlanetContext(configuration, options);
                    break;
                case Constants.CONTEXT.Sky:
                    obj = new SkyContext(configuration, options);
                    break;
                case Constants.CONTEXT.Ground:
                    obj = new GroundContext(configuration, options);
                    break;
                default:
                    throw new RangeError(
                        "The type " +
                            type +
                            " is not allowed, A valid type is included in the list Constants.CONTEXT",
                        "ContextFactory.js"
                    );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/ConstellationProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants"
], function($, AbstractProvider, FeatureStyle, Utils, Constants) {
    /**************************************************************************************************************/

    var namesFile;
    var catalogueFile;

    var constellations = {};
    var self;

    /**
     *    Extract information in "constellation" variables
     */
    function extractDatabase(mizarLayer) {
        var constellationNamesTab = namesFile.split("\n");
        var catalogueTab = catalogueFile.split("\n");

        // For each constellation point
        for (var i = 0; i < catalogueTab.length; i++) {
            var word = catalogueTab[i].replace("  ", " ");
            word = word.split(" "); // word = "RA Decl Abbreviation "I"/"O"(Inerpolated/Original(Corner))"
            var RA = parseFloat(word[0]);
            var Decl = parseFloat(word[1]);
            var currentAbb = word[2];
            var IO = word[3];

            // Convert hours to degrees
            RA *= 15;

            // If abbreviation doesn't exist
            if (!constellations[currentAbb]) {
                // Find constellation name
                for (var j = 0; j < constellationNamesTab.length; j++) {
                    word = constellationNamesTab[j].split(";"); // word[0] = abbreviation, word[1] = name;
                    var abb = word[0];

                    if (abb === currentAbb) {
                        var name = word[1];

                        // Add new constellation as a property
                        constellations[currentAbb] = {
                            coord: [],
                            name: name,

                            // Values used to calculate the position of the center of constellation
                            x: 0.0,
                            y: 0.0,
                            z: 0.0,
                            nbStars: 0
                        };
                        break;
                    }
                }
            }

            // Convert to default coordinate system
            var posGeo = [RA, Decl];

            // Calculate the center of constillation
            var pos3d = [];
            // Need to convert to 3D because of 0h -> 24h notation
            mizarLayer.globe
                .getCoordinateSystem()
                .get3DFromWorldInCrs(posGeo, Constants.CRS.Equatorial, pos3d);
            constellations[currentAbb].x += pos3d[0];
            constellations[currentAbb].y += pos3d[1];
            constellations[currentAbb].z += pos3d[2];
            constellations[currentAbb].nbStars++;

            constellations[currentAbb].coord.push(posGeo);
        }
    }

    /*
         * 	Failure function
         */
    function failure() {
        console.error("Failed to load files");
    }

    /**
     * @name ConstellationProvider
     * @class
     *   ConstellationProvider context constructor
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     */
    var ConstellationProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, ConstellationProvider);

    /**************************************************************************************************************/

    /**
     * Asynchronous request to load constellation data
     * @function loadFiles
     * @memberof ConstellationProvider#
     * @param {Layer} layer - Mizar layer
     * @param {Object} configuration - Configuration options
     * @param {string} configuration.nameUrl - Url providing the constellations name data
     * @param {string} configuration.catalogueUrl - Url providing all information about each constellation
     * @see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
     */
    ConstellationProvider.prototype.loadFiles = function(layer, configuration) {
        var mizarLayer = layer;
        if (configuration.nameUrl && configuration.catalogueUrl) {
            // loadFiles( configuration.nameUrl, configuration.catalogueUrl );
            var nameRequest = {
                type: "GET",
                url: configuration.nameUrl,
                success: function(response) {
                    namesFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            };

            var catalogueRequest = {
                type: "GET",
                url: configuration.catalogueUrl,
                success: function(response) {
                    catalogueFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            };

            // Synchronizing two asynchronious requests with the same callback
            $.when($.ajax(nameRequest), $.ajax(catalogueRequest)).then(
                function() {
                    extractDatabase(mizarLayer);
                    self.handleFeatures(mizarLayer);
                },
                failure
            );
        } else {
            console.error("Not valid options");
            return false;
        }
    };

    ConstellationProvider.prototype.handleFeatures = function(mizarLayer) {
        var constellationNamesFeatures = [];
        var constellationShapesFeatures = [];

        // Fill constellationShapes & constellationNames
        for (var i in constellations) {
            if (constellations.hasOwnProperty(i)) {
                var current = constellations[i];

                // Close the polygon
                current.coord.push(current.coord[0]);

                var constellationShape = {
                    geometry: {
                        type: Constants.GEOMETRY.Polygon,
                        gid: "constellationShape_" + current.name,
                        coordinates: [current.coord],
                        crs: {
                            type: "name",
                            properties: {
                                name: Constants.CRS.Equatorial
                            }
                        }
                    },
                    properties: {
                        name: current.name
                    }
                };

                constellationShapesFeatures.push(constellationShape);

                // Compute mean value to show the constellation name in the center of constellation..
                // .. sometimes out of constellation's perimeter because of the awkward constellation's shape(ex. "Hydra" or "Draco" constellations)
                var geoPos = [];
                mizarLayer.globe
                    .getCoordinateSystem()
                    .getWorldFrom3D(
                        [
                            current.x / current.nbStars,
                            current.y / current.nbStars,
                            current.z / current.nbStars
                        ],
                        geoPos
                    );

                var constellationName = {
                    geometry: {
                        type: Constants.GEOMETRY.Point,
                        gid: "constellationName_" + current.name,
                        coordinates: [geoPos[0], geoPos[1]],
                        crs: {
                            type: "name",
                            properties: {
                                name: Constants.CRS.Equatorial
                            }
                        }
                    },
                    properties: {
                        name: current.name,
                        style: new FeatureStyle({
                            textColor: "#083BA8",
                            fillColor: [1.0, 1.0, 1.0, 1.0],
                            label: current.name
                        })
                    }
                };
                constellationNamesFeatures.push(constellationName);
            }
        }

        // Create feature collections
        var constellationShapesFeatureCollection = {
            type: "FeatureCollection",
            features: constellationShapesFeatures
        };
        var constellationNameFeatureCollection = {
            type: "FeatureCollection",
            features: constellationNamesFeatures
        };

        // Add shapes&names to the layer
        mizarLayer.addFeatureCollection(constellationShapesFeatureCollection);
        mizarLayer.addFeatureCollection(constellationNameFeatureCollection);
    };

    /**************************************************************************************************************/

    return ConstellationProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/StarProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants"
], function($, AbstractProvider, FeatureStyle, Utils, Constants) {
    var namesFile;
    var catalogueFile;
    var self;

    /*
         * 	Failure function
         */
    function failure() {
        console.error("Failed to load files");
    }

    /**
     * @name StarProvider
     * @class
     *    Specific star catalogue provider of the Brightest Stars (Ochsenbein+ 1988) from VizieR database
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     * @see Search Catalogue of the Brightest Stars (Ochsenbein+ 1988) in VizieR database for more details
     */
    var StarProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, StarProvider);

    /**************************************************************************************************************/

    /**
     * Asynchronous requests to load star database
     * @function loadFiles
     * @memberof StarProvider.prototype
     * @param {Layer} mizarLayer - Mizar layer
     * @param {Object} configuration - Configuration options
     * @param {string} configuration.nameUrl - Url providing the stars name data
     * @param {string} configuration.catalogueUrl - Url providing all information about each star
     */
    StarProvider.prototype.loadFiles = function(mizarLayer, configuration) {
        if (configuration.nameUrl && configuration.catalogueUrl) {
            var nameRequest = {
                type: "GET",
                url: configuration.nameUrl,
                success: function(response) {
                    namesFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            };

            var catalogueRequest = {
                type: "GET",
                url: configuration.catalogueUrl,
                success: function(response) {
                    catalogueFile = response;
                },
                error: function(xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            };

            // Synchronizing two asynchronious requests with the same callback
            $.proxy(
                $.when($.ajax(nameRequest), $.ajax(catalogueRequest)).then(
                    function() {
                        self.handleFeatures(mizarLayer);
                    },
                    failure
                )
            );
        } else {
            console.error("Not valid options");
            return null;
        }
    };

    /**
     * Handle features on layer
     * @function handleFeatures
     * @memberof StarProvider#
     * @param {Layer} mizarLayer
     */
    StarProvider.prototype.handleFeatures = function(mizarLayer) {
        // Extract the table data
        var tmpTab = namesFile.slice(
            namesFile.indexOf("897;Acamar"),
            namesFile.indexOf("1231;Zaurak") + 11
        );
        var namesTab = tmpTab.split("\n");
        tmpTab = catalogueFile.slice(
            catalogueFile.indexOf("001."),
            catalogueFile.indexOf("4.98;K3Ibv") + 10
        );
        var catalogueTab = tmpTab.split("\n");
        var pois = [];

        // For each known star
        for (var i = 0; i < namesTab.length; i++) {
            var word = namesTab[i].split(";"); // word[0] = HR, word[1] = name;
            var HR = parseInt(word[0], 10);
            var starName = word[1];

            // Search corresponding HR in catalogue
            for (var j = 0; j < catalogueTab.length; j++) {
                word = catalogueTab[j].split(";");
                if (parseInt(word[2], 10) === HR) {
                    // Star found in the catalogue

                    var raString = word[6]; // right ascension format : "hours minutes seconds"
                    var declString = word[7]; // declinaton format : "degrees minutes seconds"

                    var geo = [];
                    mizarLayer.globe
                        .getCoordinateSystem()
                        .getDecimalDegFromSexagesimal(
                            [raString, declString],
                            geo
                        );

                    // Add poi layer
                    var poi = {
                        geometry: {
                            type: Constants.GEOMETRY.Point,
                            gid: "star_" + starName,
                            coordinates: [geo[0], geo[1]],
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            name: starName,
                            style: new FeatureStyle({
                                label: starName,
                                fillColor: [1.0, 1.0, 1.0, 1.0]
                            })
                        }
                    };
                    pois.push(poi);
                }
            }
        }

        // Create feature collection
        var poiFeatureCollection = {
            type: "FeatureCollection",
            features: pois
        };

        mizarLayer.addFeatureCollection(poiFeatureCollection);
    };

    /**************************************************************************************************************/

    return StarProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Provider/CraterProvider',[
    "jquery",
    "./AbstractProvider",
    "../Utils/Utils",
    "../Renderer/FeatureStyle",
    "../Utils/Constants"
], function($, AbstractProvider, Utils, FeatureStyle, Constants) {
    const DEFAULT_STROKE_COLOR = [1.0, 1.0, 1.0, 1.0];

    var self;
    var featureCollection;

    /**
     * @name CraterProvider
     * @class
     *   Displays the name of the crater
     * @param {object} options
     * @augments AbstractProvider
     * @constructor
     * @memberof module:Provider
     */
    var CraterProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /*******************************************************************************/
    Utils.inherits(AbstractProvider, CraterProvider);
    /*******************************************************************************/

    /**
     * @function loadFiles
     * @param {Layer} layer - mizar Layer
     * @param {Object} configuration - configuration
     * @param {string} configuration.url - URL of the GeoJSON file
     * @memberof CraterProvider#
     */
    CraterProvider.prototype.loadFiles = function(layer, configuration) {
        $.ajax({
            type: "GET",
            url: configuration.url,
            success: function(response) {
                featureCollection = response;
                self.handleFeatures(layer);
            },
            error: function(xhr, ajaxOptions, thrownError) {
                console.error(xhr.responseText);
            }
        });
    };

    /**
     * @function handleFeatures
     * @param {Layer} layer - mizar layer
     * @memberof CraterProvider#
     */
    CraterProvider.prototype.handleFeatures = function(layer) {
        var crs = featureCollection.crs;
        var features = featureCollection.features;
        var ptMaxSize = layer.options.pointMaxSize
            ? layer.options.pointMaxSize
            : 20;
        var strokeColor = layer.getStyle().getStrokeColor()
            ? layer.getStyle().getStrokeColor()
            : DEFAULT_STROKE_COLOR;
        for (var i = 0; i < features.length; i++) {
            var currentFeature = features[i];
            currentFeature.geometry.crs = crs;
            var craterName = currentFeature.properties.name;
            currentFeature.properties.style = new FeatureStyle({
                label: craterName,
                strokeColor: strokeColor,
                pointMaxSize: ptMaxSize
            });
        }
        layer.addFeatureCollection(featureCollection);
    };

    return CraterProvider;
});

/*******************************************************************************
 * Copyright 2017-2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Provider/TrajectoryProvider',[
    "jquery",
    "./AbstractProvider",
    "../Renderer/FeatureStyle",
    "../Utils/Utils",
    "../Utils/Constants",
    "../Services/MeasureToolPlanetCore"
], function(
    $,
    AbstractProvider,
    FeatureStyle,
    Utils,
    Constants,
    MeasureToolPlanetCore
) {
    var self;
    var interval;
    var poiFeatureCollection;
    var url;
    var data;

    function _parseFile(response) {
        var pois = [];
        var lines = response.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (line.startsWith("#")) {
                continue;
            }
            var data = line.split(",");
            if (data.length > 1) {
                var long = parseFloat(data[0]);
                var lat = parseFloat(data[1]);
                var date = data[2];
                pois.push([long, lat, date]);
            }
        }
        return pois;
    }

    function _createLines(pois) {
        var geom = [];
        for (var j = 1; j < pois.length; j++) {
            var line = [];
            line.push(pois[j - 1]);
            line.push(pois[j]);
            geom.push(line);
        }
        return geom;
    }

    function _extractDates(pois) {
        var dateMin = pois[0][2];
        var dateMax = pois[pois.length - 1][2];
        return [dateMin, dateMax];
    }

    var computePositions = function(mizarLayer) {
        $.ajax({
            type: "GET",
            url: url,
            success: function(response) {
                var pois = _parseFile(response);
                var geom = _createLines(pois);
                var dates = _extractDates(pois);

                var style = new FeatureStyle({
                    iconUrl: "css/images/lander.png",
                    strokeColor: FeatureStyle.fromStringToColor("white"),
                    fillColor: FeatureStyle.fromStringToColor("white")
                });

                var trajectory = createTrajectory(
                    mizarLayer,
                    Constants.GEOMETRY.MultiLineString,
                    mizarLayer.name,
                    { trajectory: geom, color: "white", dates: dates }
                );
                // Create feature collection
                poiFeatureCollection = {
                    type: "FeatureCollection",
                    crs: {
                        type: "name",
                        properties: {
                            name: "IAU2000:30101"
                        }
                    },
                    features: [
                        trajectory,
                        {
                            type: "Feature",
                            properties: {
                                title: "Landing site",
                                style: style,
                                thumbnail:
                                    "http://space.skyrocket.de/img_sat/team-indus__1.jpg",
                                abstract:
                                    'The <a href="http://www.teamindus.in/mission/" class="selectValue">Team Indus Lunar Lander</a> is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).<p>The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP. <p>The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters. <p>Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earths orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/salmost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecrafts fuel.The landing phase of the mission will be initiated at a 100 km  100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on Mare Imbrium, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown.The Team Indus Lunar Lander is a lunar lander developed by the Indian nonprofit organisation Team Indus. It is an entry to win the Google Lunar XPRIZE (GLXP).The Team Indus Lunar Lander is a lunar lander, which has a propulsion system to enable itself to leave earth orbit and to enter a trajectory to the moon. After landing it will deploy the Indian ECA (Ek Choti si Asha) rover, which will move to a distance of at least 500 m to satisfy the rules of the GLXP.The propulsion system is bipropellant, consisting of a single 440 N prime thruster and sixteen 22 N thrusters.Once deployed from the rocket, the spacecraft will orbit the earth twice. In a manoeuvre called the trans-lunar injection by which it will successfully leave Earths orbit, the rocket engines will be fired to set course to the Moon. At this point, the craft will be traveling at the maximum speed of 10.5 km/salmost 39600 km/h for the distance of 384400 km within 10 days. When roughly 100 km from the Moon, it will perform another manoeuvre called the Lunar Orbit Capture to eventually settle into a parking orbit. By now, the craft will have decelerated to 800 m/s. These extreme variations in speed will consume most of the spacecrafts fuel.The landing phase of the mission will be initiated at a 100 km  100 km orbit around the Moon. The entire process will be controlled by software onboard the spacecraft using data collected from laser sensors. These sensors will detect and analysis the surface, orienting the craft accordingly. Considering that manual control of the craft at this point is impossible, automation and preprogramming is the only way to go. At a time optimised to coincide with the lunar dawn on <a href="https://en.wikipedia.org/wiki/Mare_Imbrium" class="selectValue">Mare Imbrium</a>, the spacecraft thrusters will be fired again to decrease the orbit for a soft touchdown.'
                            },
                            geometry: {
                                type: "Point",
                                coordinates: [-25.680079147, 29.5212266285]
                            }
                        }
                    ]
                };

                mizarLayer.addFeatureCollection(poiFeatureCollection);
            },
            error: function(xhr, ajaxOptions, thrownError) {
                console.error(xhr.responseText);
            }
        });
    };

    /*
         * Json template for a point
         */
    function createTrajectory(mizarLayer, type, name, obj) {
        function _computeDistance(trajectory) {
            var distance = 0;
            var line = trajectory[0];
            for (var i = 1; i < trajectory.length; i++) {
                var lineNext = trajectory[i];
                distance += MeasureToolPlanetCore.calculateDistanceElevation(
                    line[0],
                    lineNext[0]
                );
                line = lineNext;
            }
            return distance * 1000;
        }

        return {
            type: "Feature",
            geometry: {
                type: Constants.GEOMETRY.MultiLineString,
                gid: "trajectory" + type + "_" + name,
                coordinates: obj.trajectory
            },
            properties: {
                title: name,
                thumbnail: data.thumbnailPath,
                abstract: data.abstractPath,
                startDate: obj.dates[0],
                endDate: obj.dates[1],
                distance: _computeDistance(obj.trajectory).toFixed() + " meters"
            }
        };
    }

    var TrajectoryProvider = function(options) {
        AbstractProvider.prototype.constructor.call(this, options);
        self = this;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractProvider, TrajectoryProvider);

    /**************************************************************************************************************/

    TrajectoryProvider.prototype.loadFiles = function(layer, configuration) {
        data = configuration;
        interval = configuration.interval ? configuration.interval : 60000;
        url = configuration.url;
        self.handleFeatures(layer);
    };

    TrajectoryProvider.prototype.handleFeatures = function(layer) {
        computePositions(layer);
        setInterval(function() {
            layer.removeFeatureCollection(poiFeatureCollection);
            computePositions(layer);
        }, interval);
    };

    return TrajectoryProvider;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Provider/ProviderFactory',[
    "./ConstellationProvider",
    "./PlanetProvider",
    "./StarProvider",
    "./CraterProvider",
    "./TrajectoryProvider",
    "../Utils/Constants"
], function(
    ConstellationProvider,
    PlanetProvider,
    StarProvider,
    CraterProvider,
    TrajectoryProvider,
    Constants
) {
    return {
        create: function(type, options) {
            var obj;
            switch (type) {
                case Constants.PROVIDER.Constellation:
                    obj = new ConstellationProvider(options);
                    break;
                case Constants.PROVIDER.Crater:
                    obj = new CraterProvider(options);
                    break;
                case Constants.PROVIDER.Planet:
                    obj = new PlanetProvider(options);
                    break;
                case Constants.PROVIDER.Star:
                    obj = new StarProvider(options);
                    break;
                case Constants.PROVIDER.Trajectory:
                    obj = new TrajectoryProvider(options);
                    break;
                default:
                    throw new RangeError(
                        "unable to create the provider " + type,
                        "ProviderFactory.js"
                    );
            }
            return obj;
        }
    };
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Stats',[],function() {
    /**
     @name Stats
     @class
         Display some rendering statistics in a HTML element
     @param {Context} Context
     @param {Object} options - Configuration properties for Stats.
     @param {Object} [options.element] - the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself
     @param {boolean] {[options.verbose=false] - the verbosity of the stats, default is false
     @constructor
    */
    var Stats = function(context, options) {
        this.type = null;
        context.getRenderContext().stats = this;
        //context.globe.renderContext.stats = this;
        this.context = context;
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
                this.type = "dom";
            } else {
                this.element = elt;
                this.type = "jquery";
            }
        }

        this.showFPS = this.context.globe.continuousRendering;
        this.verbose = options && options.verbose ? options.verbose : false;
        this.numFrames = 0;

        var self = this;
        window.setInterval(function() {
            self.print();
        }, 1000);
    };

    /**************************************************************************************************************/

    /**
     Start measuring time
     */
    Stats.prototype.start = function(name) {
        this[name] = Date.now();
    };

    /**************************************************************************************************************/

    /**
     End measuring time
     */
    Stats.prototype.end = function(name) {
        var time = Date.now() - this[name];

        var max = this["max_" + name] || -1;
        if (max < time) {
            max = time;
        }

        var sum = this["sum_" + name] || 0;
        sum += time;

        this[name] = time;
        this["max_" + name] = max;
        this["sum_" + name] = sum;
        if (name === "globalRenderTime") {
            this.numFrames++;
        }
    };

    /**************************************************************************************************************/

    /**
     Print stats in an HTML element
     */
    Stats.prototype.print = function() {
        if (this.numFrames > 0) {
            var content = "";

            if (this.showFPS) {
                content += "FPS : " + this.numFrames + "<br>";
            }

            content +=
                "Average render time : " +
                (this.sum_globalRenderTime / this.numFrames).toFixed(2) +
                " ms";
            // FIXME: currently count stats for the first renderer in render context
            /*if (this.context.globe.renderContext.renderers[0].getRenderStats) {
                content += "<br>" + this.renderContext.renderers[0].getRenderStats();
            }
            */
            if (this.verbose) {
                content +=
                    "<br>Average traverse tiles time : " +
                    (this.sum_traverseTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average render tiles time : " +
                    (this.sum_renderTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average generate tiles time : " +
                    (this.sum_generateTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Average request tiles time : " +
                    (this.sum_requestTime / this.numFrames).toFixed(2) +
                    " ms";
                content +=
                    "<br>Max render time : " +
                    this.max_globalRenderTime +
                    " ms";
                content +=
                    "<br>Max traverse tiles time : " +
                    this.max_traverseTime +
                    " ms";
                content +=
                    "<br>Max render tiles time : " +
                    this.max_renderTime +
                    " ms";
                content +=
                    "<br>Max generate tiles time : " +
                    this.max_generateTime +
                    " ms";
                content +=
                    "<br>Max request tiles time : " +
                    this.max_requestTime +
                    " ms";
            }

            if (this.element) {
                if (this.type === "dom") {
                    this.element.innerHTML = content;
                } else if (this.type === "jquery") {
                    this.element.html(content);
                }
            }

            this.sum_globalRenderTime = 0;
            this.sum_traverseTime = 0;
            this.sum_renderTime = 0;
            this.sum_generateTime = 0;
            this.sum_requestTime = 0;
            this.max_globalRenderTime = 0;
            this.max_traverseTime = 0;
            this.max_renderTime = 0;
            this.max_generateTime = 0;
            this.max_requestTime = 0;
            this.numFrames = 0;
        }
    };

    /**************************************************************************************************************/

    return Stats;
});

/*******************************************************************************
 * Copyright 2017, 2018 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @fileOverview Entry point for the {@link Mizar MIZAR API}
 * @version 1.0.0
 * @author CNES
 */
define('Mizar',[
    "jquery",
    "underscore-min",
    "./Context/ContextFactory",
    "./Navigation/NavigationFactory",
    "./Layer/LayerFactory",
    "./Crs/CoordinateSystemFactory",
    "./Animation/AnimationFactory",
    "./Utils/UtilityFactory",
    "./Services/ServiceFactory",
    "./Provider/ProviderFactory",
    "./Utils/Utils",
    "./Utils/Event",
    "./Utils/Stats",
    "./Utils/Constants",
    "./Gui/dialog/ErrorDialog",
    "./Layer/HipsMetadata",
    "./Time/Time"
], function(
    $,
    _,
    ContextFactory,
    NavigationFactory,
    LayerFactory,
    CoordinateSystemFactory,
    AnimationFactory,
    UtilityFactory,
    ServiceFactory,
    ProviderFactory,
    Utils,
    Event,
    Stats,
    Constants,
    ErrorDialog,
    HipsMetadata,
    Time
) {
    //TODO bug : shortest path
    //TODO : charger cratere Mars et l'afficher  un certain niveau de zoom => fonctionne par FeatureStyle
    //TODO : calculer le getFov pour la navigation de type "Planet" pour en dduire le FOV en fonction du level de Geotiling
    //TODO : Elevation KO quand projection 2D

    /**
     * mizarMode:toggle.<br/>
     * Called when Mizar switches from a context to another context
     * @event Mizar#mizarMode:toggle
     * @type {Context}
     */

    /**
     * @constant
     * @type {string}
     */
    const API_VERSION = "1.0.0";

    /**
     * @constant
     * @type {number}
     */
    const ANGLE_CAMERA_POLE = 30.0;

    /**
     * @constant
     * @type {string}
     */
    const MIZAR_NAME_PROD = "Mizar.min";

    /**
     * @constant
     * @type {string}
     */
    const MIZAR_NAME_DEV = "Mizar.";

    /**
     * Input Mizar parameters
     * @typedef {Object} Mizar.inputParameters
     * @property {Object|string} canvas - div ID or div element
     * @property {Mizar.inputConfiguration} [configuration] - Mizar global configuration
     * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
     * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
     * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
     */

    /**
     * Mizar parameters
     * @typedef {Object} Mizar.parameters
     * @property {Object|string} canvas - div ID or div element
     * @property {Mizar.configuration} [configuration] - Mizar global configuration
     * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
     * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
     * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
     */

    /**
     * Mizar configuration
     * @typedef {Object} Mizar.inputConfiguration
     * @property {string} [mizarBaseUrl] - Used to access to MizarWidget resources
     * @property {boolean} [debug = false] - Debug mode
     * @property {boolean} [isMobile = false] - Mobile support
     * @property {AbstractTracker.position_configuration} [positionTracker] - Position tracker configuration
     * @property {AbstractTracker.elevation_configuration} [elevationTracker] - Elevation tracker configuration
     * @property {Object} [registry] - Hips service registry
     * @property {string} registry.hips - Hips Registry
     * @property {boolean} [proxyUse=false] - Uses a proxy to send request
     * @property {string} [proxyUrl] - Proxy URL to use when proxyUse is true. This is used to avoid CORS errors.
     */

    /**
     * Mizar configuration
     * @typedef {Mizar.inputConfiguration} Mizar.configuration
     * @property {string} mizarAPIUrl - URL of this script, used to reference shaders and CSS of Mizar API
     */

    /**
     * @name Mizar
     * @class
     * Creates an instance of the Mizar API.
     * @param {Mizar.inputParameters} options - Configuration for Mizar
     * @throws {ReferenceError} No option found
     * @throws {TypeError} Canvas not defined
     * @constructor
     */
    var Mizar = function(options) {
        Event.prototype.constructor.call(this);

        _checkConfiguration(options);
        this.options = _createConfiguration(options);

        // Init all factories
        /**
         * Creates a {@link module:Context.ContextFactory Context}
         * @name ContextFactory
         * @memberof Mizar#
         * @private
         */
        this.ContextFactory = ContextFactory;

        /**
         * Creates a {@link module:Layer.LayerFactory Layer}
         * @name LayerFactory
         * @memberof Mizar#
         * @private
         */
        this.LayerFactory = LayerFactory;

        // Set proxy parameters to Layer factory
        this.LayerFactory.proxy = {
            url: this.options.configuration.proxyUrl,
            // Sets to false when proxyUse is undefined or null
            use:
                this.options.configuration.proxyUse == null
                    ? false
                    : this.options.configuration.proxyUse
        };

        proxy = this.LayerFactory.proxy;

        /**
         * Creates an {@link module:Animation.AnimationFactory animation}
         * @name AnimationFactory
         * @memberof Mizar#
         */
        this.AnimationFactory = AnimationFactory;

        /**
         * Creates a service
         * @name ServiceFactory
         * @memberof Mizar#
         */
        this.ServiceFactory = ServiceFactory;

        /**
         * Creates an utility
         * @name UtilityFactory
         * @memberof Mizar#
         * @private
         */
        this.UtilityFactory = UtilityFactory;

        /**
         * Creates a provider
         * @name ProviderFactory
         * @memberof Mizar#
         */
        this.ProviderFactory = ProviderFactory;

        /**
         * Access to time.
         * @name TimeUtility
         * @memberof Mizar#
         * @private
         */
        this.TimeUtility = Time;

        this.skyContext = null;
        this.planetContext = null;
        this.groundContext = null;
        this.activatedContext = null;
        this.renderContext = null;
        this.dataProviders = {};

        if (options.skyContext) {
            options.skyContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Sky, options.skyContext);
            this.setActivatedContext(Mizar.CONTEXT.Sky);
        }

        if (options.planetContext) {
            options.planetContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Planet, options.planetContext);
            this.setActivatedContext(Mizar.CONTEXT.Planet);
        }

        if (options.groundContext) {
            options.groundContext.isMobile = options.isMobile;
            this.createContext(Mizar.CONTEXT.Ground, options.groundContext);
            this.setActivatedContext(Mizar.CONTEXT.Ground);
        }
    };

    /**********************************************************************************************************
     *                                      Static variables
     **********************************************************************************************************/

    /**
     * Static variable, API version.<br/>
     * [SemVer]{@link http://semver.org/} concept is used for versioning
     * @name VERSION
     * @memberof Mizar#
     */
    Mizar.VERSION = API_VERSION;

    /**
     * Static variable, supported {@link ANIMATION animation} type
     * @name ANIMATION
     * @memberof Mizar#
     */
    Mizar.ANIMATION = Constants.ANIMATION;

    /**
     * Static variable, supported {@link LAYER layer} type
     * @name LAYER
     * @memberof Mizar#//
     */
    Mizar.LAYER = Constants.LAYER;

    /**
     * Static variable, supported {@link INFORMATION_TYPE information} type
     * @name INFORMATION_TYPE
     * @memberof Mizar#
     */    
    Mizar.INFORMATION_TYPE = Constants.INFORMATION_TYPE;

    /**
     * Static variable, supported {@link GEOMETRY geometry} type
     * @name GEOMETRY
     * @memberof Mizar#
     */
    Mizar.GEOMETRY = Constants.GEOMETRY;

    /**
     * Static variable, supported {@link NAVIGATION navigation} type
     * @name NAVIGATION
     * @memberof Mizar#
     */
    Mizar.NAVIGATION = Constants.NAVIGATION;

    /**
     * Static variable, supported {@link CONTEXT context} type
     * @name CONTEXT
     * @memberof Mizar#
     */
    Mizar.CONTEXT = Constants.CONTEXT;

    /**
     * Static variable, supported {@link PROJECTION projection} type
     * @name PROJECTION
     * @memberof Mizar#
     */
    Mizar.PROJECTION = Constants.PROJECTION;

    /**
     * Static variable, supported {@link CRS coordinate reference system} type
     * @name CRS
     * @memberof Mizar#
     */
    Mizar.CRS = Constants.CRS;

    /**
     * Static variable, supported {@link DISPLAY display} order
     * @name DISPLAY
     * @memberof Mizar#
     */
    Mizar.DISPLAY = Constants.DISPLAY;

    /**
     * Static variable, supported {@link SERVICE service} type
     * @name SERVICE
     * @memberof Mizar#
     */
    Mizar.SERVICE = Constants.SERVICE;

    /**
     * Static variable, supported {@link UTILITY utility} type
     * @name UTILITY
     * @memberof Mizar#
     */
    Mizar.UTILITY = Constants.UTILITY;

    /**
     * Static variable, supported {@link PROVIDER provider} type
     * @name PROVIDER
     * @memberof Mizar#
     */
    Mizar.PROVIDER = Constants.PROVIDER;

    /**
     * Static variable, supported {@link EVENT_MSG event} type
     * @name EVENT_MSG
     * @memberof Mizar#
     */
    Mizar.EVENT_MSG = Constants.EVENT_MSG;

    /**
     * Static variable, supported {@link TIME_STEP constants} type
     * @name TIME_STEP
     * @memberof Mizar#
     */
    Mizar.TIME_STEP = Constants.TIME_STEP;

    /**********************************************************************************************************
     *                                      Private methods
     **********************************************************************************************************/

    /**
     * Returns the script object that contains the URL of this script
     * @param {Object[]} scripts - All the scripts from the document where Mizar is imported
     * @param {MIZAR_NAME_PROD|MIZAR_NAME_DEV} scriptName - production or dev script name
     * @param {int} index - Number of range '/' to remove from the end of the URL
     * @private
     */
    function _extractURLFrom(scripts, scriptName, index) {
        var mizarSrc = _.find(scripts, function(script) {
            return script.src.indexOf(scriptName) !== -1;
        });
        if (mizarSrc) {
            mizarSrc =
                mizarSrc.src
                    .split("/")
                    .slice(0, index)
                    .join("/") + "/";
        }
        return mizarSrc;
    }

    /**
     * Return the base URL of this script.
     * @returns {string} the base URL
     * @private
     */
    function _getMizarAPIBaseURL() {
        var scripts = document.getElementsByTagName("script");
        return (
            _extractURLFrom.call(this, scripts, MIZAR_NAME_PROD, -1) ||
            _extractURLFrom.call(this, scripts, MIZAR_NAME_DEV, -2)
        );
    }

    /**
     * Checks inputs
     * @param {Object} options - Mizar configuration
     * @throws {ReferenceError} No option found
     * @throws {TypeError} Canvas not defined
     * @function _checkConfiguration
     * @memberof Mizar#
     * @private
     */
    function _checkConfiguration(options) {
        if (typeof options === "undefined") {
            throw new ReferenceError("No option found", "Mizar.js");
        } else if (typeof options.canvas === "undefined") {
            throw new TypeError("Canvas not defined", "Mizar.js");
        } else {
            // do nothing
        }
    }

    /**
     * Checks inputs from user and creates the mizar configuration
     * @param {Mizar.inputParameters} options inputs from user
     * @returns {Mizar.parameters} mizar configuration.
     * @function _createConfiguration
     * @memberof Mizar#
     * @private
     */
    function _createConfiguration(options) {
        var mizarAPIUrl = _getMizarAPIBaseURL();
        var mizarOptions = {
            canvas:
                typeof options.canvas === "string"
                    ? document.getElementById(options.canvas)
                    : options.canvas
        };
        if (options.hasOwnProperty("configuration")) {
            mizarOptions.configuration = options.configuration;
        } else {
            mizarOptions.configuration = {};
        }
        mizarOptions.configuration.mizarAPIUrl = mizarAPIUrl;
        if (options.hasOwnProperty("skyContext")) {
            mizarOptions.skyContext = options.skyContext;
        }
        if (options.hasOwnProperty("planetContext")) {
            mizarOptions.planetContext = options.planetContext;
        }
        if (options.hasOwnProperty("groundContext")) {
            mizarOptions.groundContext = options.groundContext;
        }
        return mizarOptions;
    }

    /**
     * Switch to a context
     * @param {AbstractContext} context - Target context
     * @param {Object} [options] - options management for the source context
     * @param {boolean} options.mustBeDestroyed=false - options management for the source context
     * @function _switchToContext
     * @memberof Mizar#
     * @private
     * @fires Mizar#mizarMode:toggle
     */
    function _switchToContext(context, options) {
        var self = this;
        var mustBeDestroyed = options.hasOwnProperty("mustBeDestroyed")
            ? options.mustBeDestroyed
            : false;
        var mustBeHidden = options.hasOwnProperty("mustBeHidden")
            ? options.mustBeHidden
            : false;

        // Hide sky
        this.getActivatedContext().hide();

        // Hide all additional layers
        this.getActivatedContext().hideAdditionalLayers();

        var viewMatrix;
        var fov;
        if (
            context.hasOwnProperty("_oldVM") &&
            context.hasOwnProperty("_oldFov")
        ) {
            viewMatrix = context._oldVM;
            fov = context._oldFov;
        } else if (context.getNavigation().inverseViewMatrix === undefined) {
            this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
            this.getActivatedContext()._oldFov = this.renderContext.getFov();
            viewMatrix = context
                .getNavigation()
                .getRenderContext()
                .getViewMatrix();
            fov = 90;
        } else {
            this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
            this.getActivatedContext()._oldFov = this.renderContext.getFov();
            viewMatrix = mat4.create();
            context.getNavigation().computeInverseViewMatrix();
            mat4.inverse(context.getNavigation().inverseViewMatrix, viewMatrix);
            fov = 90;
        }

        if (mustBeDestroyed) {
            this.getActivatedContext().destroy();
        } else if (mustBeHidden) {
            this.getActivatedContext().disable();
        } else {
            // display the two contexts in the same time
        }
        this.activatedContext = context;
        if (!context.getNavigation().getRenderContext().cameraUpdateFunction) {
            context
                .getNavigation()
                .getRenderContext().cameraUpdateFunction = context
                .getNavigation()
                .update.bind(context.getNavigation());
        }
        context.getNavigation().toViewMatrix(viewMatrix, fov, 2000, function() {
            if (context) {
                context.enable();
            }
            if (options && options.callback) {
                options.callback.call(self);
            }
            context.showAdditionalLayers();
            self.getActivatedContext().show();
            self.publish(Constants.EVENT_MSG.MIZAR_MODE_TOGGLE, context);            
            self.getActivatedContext().refresh();
            if (self.getRenderContext().viewMatrix[0] !== "undefined") {
                self.getActivatedContext()
                    .getNavigation()
                    .computeViewMatrix();
            }
        });
    }

    /**
     * Saves the atmosphere state and disable it when 2D is used
     * @function _disableAtmosphere
     * @memberof Mizar#
     * @private
     */
    function _disableAtmosphere() {
        if (this.getActivatedContext()._atmosphereLayer !== undefined) {
            if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                this.getActivatedContext()._saveAtmosphereVisible = this.getActivatedContext()._atmosphereLayer.visible;
                this.getActivatedContext()._atmosphereLayer.setVisible(false);
                this.render();
            }
        }
    }

    /**
     * Retrieves the atmosphere and enable it when 3D is used
     * @function _enableAtmosphere
     * @memberof Mizar#
     * @private
     */
    function _enableAtmosphere() {
        if (this.getActivatedContext()._atmosphereLayer !== undefined) {
            if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                this.getActivatedContext()._atmosphereLayer.setVisible(
                    this.getActivatedContext()._saveAtmosphereVisible
                );
                this.render();
            }
        }
    }

    /**
     * Switch 2D to 3D.
     * @function _switch2Dto3D
     * @memberof Mizar#
     * @private
     */
    function _switch2Dto3D() {
        _enableAtmosphere.call(this);

        // Enable skyContext behind the planet
        if (this.skyContext) {
            this.skyContext.enable();
        }

        this.setCrs({ geoideName: this.getCrs().getGeoideName() });

        // Check zoom level
        this.planetContext.navigation.zoom(0);
    }

    /**
     * Switch 3D to 2D.
     * @function _switch3Dto2D
     * @memberof Mizar#
     * @private
     */
    function _switch3Dto2D() {
        _disableAtmosphere.call(this);

        // Disable skyContext
        if (this.skyContext) {
            this.skyContext.disable();
        }

        // If a pole is closed to the center of the canvas, this should mean that
        // the user is interested to the pole, so we switch to azimuth projection
        // instead of plate carre projection
        _project2AzimuthOrPlate.call(
            this,
            this.getActivatedContext().navigation.getCenter()
        );
    }

    /**
     * Selects the right projection according to the target of the camera.<br/>
     * When the angle of the target of the camera with a pole (north or south)
     * is inferior to ANGLE_CAMERA_POLE, then the azimuthal projection is selected
     * otherwise plate carre is selected
     * @param {float[]} lookAt - target of the camera [longitude, latitude] in decimal degree
     * @function _project2AzimuthOrPlate
     * @memberof Mizar#
     * @private
     */
    function _project2AzimuthOrPlate(lookAt) {
        if (lookAt !== null && 90 - Math.abs(lookAt[1]) <= ANGLE_CAMERA_POLE) {
            this.setCrs({
                geoideName: this.getCrs().getGeoideName(),
                projectionName: Mizar.PROJECTION.Azimuth,
                pole: Math.sign(lookAt[1]) > 0 ? "north" : "south"
            });
        } else {
            this.setCrs({
                geoideName: this.getCrs().getGeoideName(),
                projectionName: Mizar.PROJECTION.Plate
            });
        }
    }

    /**
     * Skip if sky mode
     * @function _skipIfSkyMode
     * @memberof Mizar#
     * @throws {RangeError} Toggle Dimension is not implemented for Sky
     * @private
     */
    function _skipIfSkyMode() {
        if (this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky) {
            throw new RangeError(
                "Toggle Dimension is not implemented for Sky",
                "Mizar.js"
            );
        }
    }

    /**
     * Get service url from HIPS Layer
     * @function _getHipsServiceUrlArray
     * @memberof Mizar#
     * @param hipsLayer
     * @returns {Array}
     * @private
     */
    function _getHipsServiceUrlArray(hipsLayer) {
        var hipsServiceUrlArray = [];

        if (hipsLayer.hips_service_url) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url);
        }
        if (hipsLayer.hips_service_url_1) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url_1);
        }
        if (hipsLayer.hips_service_url_2) {
            hipsServiceUrlArray.push(hipsLayer.hips_service_url_2);
        }
        return hipsServiceUrlArray;
    }

    /**
     * Proxify an url
     * @function _proxify
     * @memberof Mizar#
     * @param {string} url - URL
     * @return {string} Url proxified
     * @private
     */
    function _proxify(url) {
        var proxifyUrl;
        if (proxy.use === true) {
            proxifyUrl = proxy.url + url;
        } else {
            proxifyUrl = url;
        }
        return proxifyUrl;
    }

    /**
     * Loads HIPS layers from passed service url
     * @function _checkHipsServiceIsAvailable
     * @memberof Mizar#
     * @param {Array} hipsServiceUrlArray - HIPS service URL
     * @param {serviceRegistryCallback} callback - The callback that handles the response
     * @private
     */
    function _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback) {
        if (hipsServiceUrlArray.length === 0) {
            return callback(undefined);
        }
        var url = hipsServiceUrlArray.shift();

        $.ajax({
            type: "GET",
            url: _proxify(url) + "/properties",
            dataType: "text"
            //context: layerManager,
            //timeout: 10000
        })
            .done(function(data, status, xhr) {
                if (xhr.status === 200) {
                    return callback(url);
                }
            })
            .error(function() {
                _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback);
            });
    }

    /**
     * Loads HIPS layers from passed service url
     * @function _loadHIPSLayers
     * @memberof Mizar#
     * @param {Mizar} Mizar - Mizar API
     * @param {Options} [options] - Options
     * @param {string} [options.registry] - Registry
     * @param {string} [options.registry.hips] - Hips Registry
     * @private
     */
    function _loadHIPSLayers(Mizar, options) {
        if (
            typeof options !== "undefined" &&
            options.hasOwnProperty("registry") &&
            options.registry.hasOwnProperty("hips")
        ) {
            $.ajax({
                type: "GET",
                url: _proxify(options.registry.hips),
                context: Mizar,
                dataType: "json"
            })
                .fail(function(XMLHttpRequest, textStatus, errorThrown) {
                    ErrorDialog.open(
                        "<font style='color:orange'>Warning : Cannot connect to <b>" +
                            options.registry.hips +
                            "</b></font>"
                    );
                })
                .done(function(hipsLayersJSON) {
                    _.each(
                        hipsLayersJSON,
                        function(hipsLayer) {
                            var hipsServiceUrlArray = _getHipsServiceUrlArray(
                                hipsLayer
                            );
                            var hipsUrl = _checkHipsServiceIsAvailable(
                                hipsServiceUrlArray,
                                function(hipsServiceUrl) {
                                    if (typeof hipsServiceUrl === "undefined") {
                                        var text = "";
                                        if (
                                            typeof hipsLayer.obs_title ===
                                            "undefined"
                                        ) {
                                            text =
                                                "with ID <b>" +
                                                hipsLayer.ID +
                                                "</b>";
                                        } else {
                                            text =
                                                "with title <b>" +
                                                hipsLayer.obs_title +
                                                "</b>";
                                        }
                                        ErrorDialog.open(
                                            "<font style='color:orange'>Warning : Cannot add layer <b>" +
                                                text +
                                                "</b> no mirror available</font>"
                                        );
                                        return;
                                    }
                                    $.proxy(_createHips, Mizar)(
                                        hipsLayer,
                                        hipsServiceUrl
                                    );
                                }
                            );
                        },
                        Mizar
                    );
                });
        }
    }

    /**
     * Creates a HIPS layer from registry
     * @function _createHips
     * @memberof Mizar#
     * @param hipsLayer
     * @param hipsServiceUrl
     * @private
     */
    function _createHips(hipsLayer, hipsServiceUrl) {
        try {
            if (
                hipsLayer.hasOwnProperty("hips_status") &&
                hipsLayer.hips_status.match("public") === null
            ) {
                return;
            }
            hipsLayer.hips_service_url = hipsServiceUrl;
            this.addLayer({
                type: Mizar.LAYER.Hips,
                hipsMetadata: new HipsMetadata(hipsLayer)
            });
        } catch (e) {
            var name = hipsLayer.obs_title
                ? hipsLayer.obs_title
                : hipsLayer.obs_collection;
            ErrorDialog.open(
                "Hips layer <font style='color:yellow'><b>" +
                    name +
                    "</b></font>  not valid <font color='grey'><i>(" +
                    hipsLayer.hips_service_url +
                    " - reason : " +
                    e.message +
                    ")</i></font>",
                true
            );
        }
    }

    /**************************************************************************************************************/

    Utils.inherits(Event, Mizar);

    /**************************************************************************************************************/

    /**************************************************************************************************************
     *                                          Public methods
     **************************************************************************************************************/

    //               ***************************** Members *****************************

    /**
     * Returns the sky context.
     * @returns {SkyContext|null}
     * @function getSkyContext
     * @memberof Mizar#
     */
    Mizar.prototype.getSkyContext = function() {
        return this.skyContext;
    };

    /**
     * Returns the planet context.
     * @returns {PlanetContext|null}
     * @function getPlanetContext
     * @memberof Mizar#
     */
    Mizar.prototype.getPlanetContext = function() {
        return this.planetContext;
    };

    /**
     * Returns the ground context.
     * @returns {GroundContext|null}
     * @function getGroundContext
     * @memberof Mizar#
     */
    Mizar.prototype.getGroundContext = function() {
        return this.groundContext;
    };

    /**
     * Returns the context according to the mode.
     * @function _getContext
     * @param {CONTEXT|undefined} mode - the selected mode
     * @memberof Mizar#
     * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
     * @returns {Context} the context
     * @private
     */
    function _getContext(mode) {
        var context;
        switch (mode) {
            case undefined:
                context = this.getActivatedContext();
                break;
            case Mizar.CONTEXT.Sky:
                context = this.getSkyContext();
                break;
            case Mizar.CONTEXT.Planet:
                context = this.getPlanetContext();
                break;
            case Mizar.CONTEXT.Ground:
                context = this.getGroundContext();
                break;
            default:
                throw new RangeError(
                    "The mode " +
                        mode +
                        " is not allowed, A valid mode is included in the list CONTEXT",
                    "Mizar.js"
                );
        }
        return context;
    }

    /**
     * Returns the selected context.
     * When activatedContext is not set, it is set automatically to the created context
     * (in the following order : sky, planet, ground). When no context is created,
     * an  exception "No created context" is send.
     * @returns {PlanetContext|SkyContext|GroundContext|null}
     * @function getActivatedContext
     * @memberof Mizar#
     */
    Mizar.prototype.getActivatedContext = function() {
        try {
            if (this.activatedContext == null) {
                if (this.skyContext != null) {
                    this.activatedContext = this.skyContext;
                } else if (this.planetContext != null) {
                    this.activatedContext = this.planetContext;
                } else if (this.groundContext != null) {
                    this.activatedContext = this.groundContext;
                } else {
                    throw new ReferenceError("No created context", "Mizar.js");
                }
            }
        } catch (e) {
            ErrorDialog.open(
                "Cannot get the context : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return this.activatedContext;
    };

    /**
     * Selects the context as default context according to the {@link CONTEXT context mode}.<br/>
     * Once a context is selected, methods can be applied to it.
     * @param {CONTEXT} contextMode - select one context among {@link CONTEXT context}
     * @returns {boolean} true when the contextMode is known otherwise false
     * @function setActivatedContext
     * @memberof Mizar#
     * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
     */
    Mizar.prototype.setActivatedContext = function(contextMode) {
        var result;
        switch (contextMode) {
            case Mizar.CONTEXT.Planet:
                this.activatedContext = this.planetContext;
                result = true;
                break;
            case Mizar.CONTEXT.Sky:
                this.activatedContext = this.skyContext;
                result = true;
                break;
            case Mizar.CONTEXT.Ground:
                this.activatedContext = this.groundContext;
                result = true;
                break;
            default:
                result = false;
                ErrorDialog.open(
                    "Cannot set the context : <font style='color:orange'><b>" +
                        contextMode +
                        " is not supported</b></font>",
                    true
                );
        }
    };

    /**
     * Returns the mode in which the active context is set.
     * @function getMode
     * @memberof Mizar#
     * @returns {CONTEXT|null} Returns the mode otherwise null when no created context
     */
    Mizar.prototype.getMode = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getMode();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the rendering context.
     * @returns {RenderContext|null} the rendering context
     * @function getRenderContext
     * @memberof Mizar#
     */
    Mizar.prototype.getRenderContext = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getRenderContext();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the options
     * @function getOptions
     * @memberof Mizar#
     * @throws ReferenceError - Will throw an exception when no context has been created.
     * @returns {Mizar.parameters} - Mizar's options
     */
    Mizar.prototype.getOptions = function() {
        return this.options;
    };

    //               ***************************** coordinate reference *****************************

    /**
     * Returns the coordinate reference system related to the selected {@link CONTEXT context}
     * @returns {Crs|null} the coordinate reference system or null when no created context
     * @function getCrs
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getCrs = function() {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            result = context.getCoordinateSystem();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Sets the coordinate reference system related to the selected {@link CONTEXT context}
     * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - coordinate system description
     * @returns {boolean} true when the coordinate system is set otherwise false when an error occurs
     * @function setCrs
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setCrs = function(coordinateSystem) {
        var result;
        var context = this.getActivatedContext();
        if (context) {
            var crs = CoordinateSystemFactory.create(coordinateSystem);
            context.setCoordinateSystem(crs);
            result = true;
        } else {
            result = false;
        }
        return result;
    };

    /**
     * Update the time travel navigation range
     * @param {JSON} parameters Parameters
     * @function setTime
     * @memberof Mizar#
     */
    Mizar.prototype.updateTimeTravel = function(parameters) {
        this.getServiceByName(Mizar.SERVICE.TimeTravel).update(parameters);
    };

    /**
     * Sets the current or integrated time of the application
     * @param time single, multiple or range of values
     * @function setTime
     * @memberof Mizar#
     */
    Mizar.prototype.setTime = function(time) {
        this.activatedContext.setTime(time);
    };

    /**
     * Returns the current or integrated time.
     * @returns {string} the simple, multiple or range of values
     * @function getTime
     * @memberof Mizar#
     */
    Mizar.prototype.getTime = function() {
        return this.activatedContext.getTime();
    };

    //               ***************************** context management *****************************

    /**
     * Creates a context according to the {@link CONTEXT context mode}.<br/>
     * @param {CONTEXT} contextMode - Select on context among {@link CONTEXT context}
     * @param {AbstractContext.skyContext|AbstractContext.planetContext|AbstractContext.groundContext} options - Options for the context, See options.planetContext or options.skycontext configuration for {@link Mizar}
     * @retuns {boolean} true when the context is created otherwise false when the contextMode is unknown
     * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
     * @function createContext
     * @memberof Mizar#
     */
    Mizar.prototype.createContext = function(contextMode, options) {
        var result;
        try {
            options.renderContext = this.renderContext;
            options.timeTravelService = this.getServiceByName(
                Mizar.SERVICE.TimeTravel
            );
            options.isMobile = this.getOptions().configuration.isMobile;

            var ctx = this.ContextFactory.create(
                contextMode,
                this.getOptions(),
                options
            );

            switch (contextMode) {
                case Mizar.CONTEXT.Sky:
                    this.skyContext = ctx;
                    _loadHIPSLayers(this, this.getOptions().configuration);
                    break;
                case Mizar.CONTEXT.Planet:
                    this.planetContext = ctx;
                    break;
                case Mizar.CONTEXT.Ground:
                    this.groundContext = ctx;
                    break;
                default:
                    throw new RangeError(
                        "Unknown contextMode '" + contextMode + "'",
                        "Mizar.js"
                    );
            }
            this.renderContext = ctx.getRenderContext();
            result = true;
        } catch (e) {
            console.error("Error", e);
            result = false;
            ErrorDialog.open(
                "Cannot create the context : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Switches 2D <--> 3D, only for planetary context. <br/>
     * When this method is used in a sky context, and exception is thrown
     * @returns {boolean} true when toggle works otherwise false
     * @function toggleDimension
     * @memberof Mizar#
     */
    Mizar.prototype.toggleDimension = function() {
        var result;
        try {
            _skipIfSkyMode.call(this);
            if (this.getCrs().isFlat()) {
                // we are in 2D and we are going to 3D
                _switch2Dto3D.call(this);
            } else {
                // we are in 3D and we are goint to 2D
                _switch3Dto2D.call(this);
            }
            this.render();
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot toggle the dimension : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Switches To a context.
     * @param {AbstractContext} context - target context
     * @param {Object} [options] - options management for the source context
     * @param {boolean} options.mustBeDestroyed=false - options management for the source context
     * @param {Function} callback - Call at the end of the toggle
     * @fires Mizar#mizarMode:toggle
     * @function toggleToContext
     * @memberof Mizar#
     */
    Mizar.prototype.toggleToContext = function(context, options) {
        var result;
        try {
            var toggleMode =
                this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky
                    ? Mizar.CONTEXT.Planet
                    : Mizar.CONTEXT.Sky;
            var opts = options || {};
            _switchToContext.call(this, context, opts);
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot toggle the context : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    //               ***************************** layer management *****************************

    /**
     * Returns the sky layers, which have been added by {@link Mizar#addLayer}.
     * @function getSkyLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getSkyLayers = function() {
        var result;
        var context = this.getSkyContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the planet layers, which have been added by {@link Mizar#addLayer}
     * @function getPlanetLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getPlanetLayers = function() {
        var result;
        var context = this.getPlanetContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the grounds layers, which have been added by {@link Mizar#addLayer}
     * @function getGroundLayers
     * @returns {Layer[]|null} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getGroundLayers = function() {
        var result;
        var context = this.getGroundContext();
        if (context) {
            result = context.getLayers();
        } else {
            result = null;
        }
        return result;
    };

    /**
     * Returns the layers for a specific context.<br/>
     * When no context is specified, the layers from the selected context are returned.
     * @function getLayers
     * @param {CONTEXT|null} mode - Context on which the function is applied
     * @returns {Layer[]} the layers
     * @memberof Mizar#
     * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getLayers = function(mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayers();
        } catch (e) {
            result = null;
            ErrorDialog.open(
                "Cannot get the layers : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Draws the layer on the top.
     * @function setLayerOnTheTop
     * @param layerID
     * @return {boolean} Returns true when the layer is drawn on the top otherwise false.
     * @memberof Mizar#
     */
    Mizar.prototype.setLayerOnTheTop = function(layerID) {
        var result;
        var layer = this.getLayerByID(layerID);
        if (layer != null) {
            layer.setOnTheTop();
            result = true;
        } else {
            result = false;
            ErrorDialog.open(
                "Cannot set the layer on the top : <font style='color:orange'><b>" +
                    layerID +
                    " does not exist</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Returns all the layers regardless of the {@link CONTEXT context}.
     * @function getAllLayers
     * @return {Layer[]} the layers
     * @memberof Mizar#
     */
    Mizar.prototype.getAllLayers = function() {
        return _.union(this.getSkyLayers(), this.getPlanetLayers());
    };

    /**
     * Returns the layer by its ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, the layer from the selected context is returned.<br/>
     * The ID is a unique layer identifier, which is returned when the layer description is {@link Mizar#addLayer added}
     * to Mizar
     * @function getLayerByID
     * @param {string} layerID - Layer's ID
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {Layer|undefined|null} The layer or undefined when the layer is not found
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getLayerByID = function(layerID, mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayerByID(layerID);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                "Cannot get the layer by ID : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Returns the layer by its name according to the {@link CONTEXT context}.<br/>
     * When no context is specified, the layer from the selected context is returned.<br/>
     * <b>Note:</b> The name may not be unique. In this case, the first layer having this name is returned
     * @function getLayerByName
     * @param {string} layerName - Layer's name, provided in the layer description when the layer is {@link Mizar#addLayer added}
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {Layer|undefined|null} the layer or undefined when the layer is not found
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getLayerByName = function(layerName, mode) {
        var result;
        try {
            result = _getContext.call(this, mode).getLayerByName(layerName);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                "Cannot get the layer by name : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Adds a layer according to the selected {@link CONTEXT context}.<br/>
     * When layerPlanet is not provided, then the layer is added to the selected context otherwise the layer
     * is added to the layerPlanet.
     *
     * @function addLayer
     * @param {Object} layerDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
     * @returns {string|null} a unique identifier or null when a problem happens
     * @memberof Mizar#
     * @listens AbstractLayer#visibility:changed
     * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
     * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
     * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
     * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
     * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
     * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
     * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
     * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
     * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
     * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
     * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
     * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
     * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
     * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
     * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
     * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.addLayer = function(layerDescription, callback, fallback) {
        //var result;
        //try {
        this.getActivatedContext().addLayer(
            layerDescription,
            callback,
            fallback
        );
        //} catch(e) {
        //    result = false;
        //    var prefixe;
        //    var text;
        //    var hipsLayer = layerDescription.hipsMetadata;
        //    if(hipsLayer != null) {
        //        if (typeof hipsLayer.hipsMetadata.obs_title === 'undefined') {
        //            prefixe = "ID ";
        //            text = hipsLayer.hipsMetadata.ID;
        //        } else {
        //            prefixe = "";
        //            text = hipsLayer.hipsMetadata.obs_title;
        //        }
        //        //ErrorDialog.open("Hips layer " + prefixe + "<font style='color:yellow'><b>" + text + "</b></font> not valid in Hips registry <font color='grey'><i>(" + hipsLayer.hipsMetadata.hips_service_url + " - reason : "+ e.message +")</i></font>.");
        //    } else {
        //        //ErrorDialog.open("Cannot add the layer <font style='color:yellow'><b>" + JSON.stringify(layerDescription) + "</b></font><font color='grey'><i>(reason : "+ e.message +")</i></font>.");
        //    }
        //}
    };

    /**
     * Removes a layer by its ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * @function removeLayer
     * @param {string} layerID - Layer's ID
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the layer is added otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.removeLayer = function(layerID, mode) {
        var result;
        try {
            var removedLayer = _getContext
                .call(this, mode)
                .removeLayer(layerID);
            result = typeof removedLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot remove the layer : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Sets the background layer according to the selected context.<br/>
     * When no context is specified, then the function is applied on the selected context.<br/>
     * <b>Note 1:</b> The name is not a unique identifier. The first layer matching at this name is returned<br/>
     * <b>Note 2:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBackgroundLayer
     * @param {string} layerName - Layer's name, which has been provided in the layer description
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the layer is set as background otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBackgroundLayer = function(layerName, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBackgroundLayer(layerName);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot set the background : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Sets the background layer by ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBackgroundLayerByID
     * @param {string} layerID - Unique layer identifier.
     * @param {CONTEXT|undefined} mode - Context on which the function is applied.
     * @returns {boolean} true when the layer is set as background otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBackgroundLayerByID = function(layerID, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBackgroundLayerByID(layerID);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot set the backgorund by ID : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Sets the base elevation by its layer's name according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBaseElevation
     * @param {string} layerName - Name of the layer
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBaseElevation = function(layerName, mode) {
        var result;
        try {
            var layer = this.getLayerByName(layerName, mode);
            var gwLayer = _getContext.call(this, mode).setBaseElevation(layer);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot set the base elevation : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Gets the base elevation to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * @function getBaseElevation
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {WCSElevationLayer|null} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.getBaseElevation = function(mode) {
        return _getContext.call(this, mode).getBaseElevation();
    };

    /**
     * Sets the base elevation by its layer's ID according to the {@link CONTEXT context}.<br/>
     * When no context is specified, then the function is applied on the selected context.
     * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
     * @function setBaseElevation
     * @param {string} layerID - ID of the layer
     * @param {CONTEXT|undefined} mode - Context on which the function is applied
     * @returns {boolean} true when the base elevation is set otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.setBaseElevationByID = function(layerID, mode) {
        var result;
        try {
            var gwLayer = _getContext
                .call(this, mode)
                .setBaseElevationByID(layerID);
            result = typeof gwLayer !== "undefined";
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot set the base elevation by ID : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Looks through each value in the list according to the context, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer.<br/>
     * When no context is specified, the function is applied on the selected context.
     * @function searchOnLayerDescription
     * @param {string} query - query on the layer'name or description
     * @param {CONTEXT|undefined} mode - Context on which the query is run.
     * @returns {Layer[]}
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     */
    Mizar.prototype.searchOnLayerDescription = function(query, mode) {
        var layers = this.getLayers(mode);
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    /**
     * Looks through each value in the sky layers, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer
     * @function searchSkyLayer
     * @param {string} query - query on the layer's name or description
     * @returns {Layer[]} An array of layers matching the constraint
     * @memberof Mizar#
     */
    Mizar.prototype.searchSkyLayer = function(query) {
        var layers = this.getSkyLayers();
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    /**
     * Looks through each value in the planets layers, returning an array of all the values that match the query.<br/>
     * The query is performed on the name and the description of each layer
     * @function searchPlanetLayer
     * @param {string} query - query on the layer'name or description
     * @returns {Layer[]} An array of layers matching the constraint
     * @memberof Mizar#
     */
    Mizar.prototype.searchPlanetLayer = function(query) {
        var layers = this.getPlanetLayers();
        //Search by name
        return _.filter(layers, function(layer) {
            return (
                String(layer.getName()).indexOf(query) >= 0 ||
                String(layer.getDescription() || "").indexOf(query) >= 0
            );
        });
    };

    //               ***************************** Utility management *****************************

    /**
     * Registers no standard data provider in a predefined context.<br/>
     * When no context is specified, the function is applied to the selected context.
     * @function registerNoStandardDataProvider
     * @param {string} type - data provider key
     * @param {Function} loadFunc - Function to convert the data
     * @param {CONTEXT|undefined} mode - Context
     * @returns {boolean} true when data provider is registered otherwise false
     * @memberof Mizar#
     * @see {@link Mizar#setActivatedContext}
     * @see {@link Mizar#createContext}
     * @example <caption>Registers planets on the sky</caption>
     *   var planetProvider = ProviderFactory.create(Mizar.PROVIDER.Planet);
     *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
     */
    Mizar.prototype.registerNoStandardDataProvider = function(
        type,
        loadFunc,
        mode
    ) {
        var result;
        try {
            _getContext
                .call(this, mode)
                .registerNoStandardDataProvider(type, loadFunc);
            result = true;
        } catch (e) {
            result = false;
            ErrorDialog.open(
                "Cannot register the data provider : <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
     * Apply proxy to url if needed
     * @function _getUrl
     * @memberof Mizar#
     * @private
     */
    Mizar.prototype._getUrl = function(url) {
        var result;
        if (this.options.configuration.proxyUse === true) {
            result = this.options.configuration.proxyUrl + url;
        } else {
            result = url;
        }
        return result;
    };

    /**
     * Returns the service based on its name
     * @param {SERVICE} serviceName
     * @param {Object} options - options for the service
     * @memberof Mizar#
     * @returns {Object|null} - the service
     */
    Mizar.prototype.getServiceByName = function(serviceName, options) {
        var result;
        try {
            result = ServiceFactory.create(serviceName, options);
        } catch (e) {
            result = null;
            ErrorDialog.open(
                "Cannot get the service by name: <font style='color:orange'><b>" +
                    e.message +
                    "</b></font>",
                true
            );
        }
        return result;
    };

    /**
         * Creates and get Stats Object
         * @function createStats
         * @param {Object} options - Configuration properties for stats. See {@link Stats} for options
         * @returns {boolean} true when context fors tats exist otherwise false
         * @return {Stats}
         * @memberof Mizar#

         */
    Mizar.prototype.createStats = function(options) {
        var result;
        if (this.skyContext) {
            this.Stats = new Stats(this.skyContext, options);
            result = true;
        } else if (this.planetContext) {
            this.Stats = new Stats(this.planetContext, options);
            result = true;
        } else if (this.groundContext) {
            this.Stats = new Stats(this.groundContext, options);
            result = true;
        } else {
            result = false;
            ErrorDialog.open("Cannot create the stats", true);
        }
        return result;
    };

    //               ***************************** Rendering management *****************************

    /**
     * Renders the canvas.
     * @returns {boolean} true when the canvas is rendered otherwise false
     * @function render
     * @memberof Mizar#
     */
    Mizar.prototype.render = function() {
        var result;
        var renderContext = this.getRenderContext();
        if (renderContext) {
            this.getRenderContext().frame();
            result = true;
        } else {
            result = false;
        }
        return result;
    };

    //               ***************************** Memory management *****************************

    /**
     * Disposes the Mizar's contexts (planet, sky and ground)
     * @function dispose
     * @memberof Mizar#
     */
    Mizar.prototype.dispose = function() {
        if (this.planetContext) {
            this.planetContext.dispose();
        }
        if (this.skyContext) {
            this.skyContext.dispose();
        }
        if (this.groundContext) {
            this.groundContext.dispose();
        }
    };

    /**
     * Reload a layer (keep id and ID)
     * @function reloadLayer
     * @memberof Mizar#
     */
    Mizar.prototype.reloadLayer = function(layer) {
        var ctx = this.getActivatedContext();
        if (ctx) {
            var tileManager = ctx.getTileManager();
            tileManager.abortLayerRequests(layer);
            layer._detach(ctx.globe);
            layer._attach(ctx.globe);
        } else {
            console.error("Context not yet available");
        }
    };

    /**
     * Destroys Mizar
     * @function destroy
     * @memberof Mizar#
     */
    Mizar.prototype.destroy = function() {
        if (this.planetContext) {
            this.planetContext.destroy();
        }
        if (this.skyContext) {
            this.skyContext.destroy();
        }
        if (this.groundContext) {
            this.groundContext.destroy();
        }
        this.activatedContext = null;
        this.renderContext = null;
        this.ContextFactory = null;
        this.LayerFactory = null;
        this.AnimationFactory = null;
        this.ServiceFactory = null;
        this.UtilityFactory = null;
    };

    // Make object MIZAR available in caller web page
    window.Mizar = Mizar;

    return Mizar;
});


require(["Mizar"]);
//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
return require('Mizar');
}));
